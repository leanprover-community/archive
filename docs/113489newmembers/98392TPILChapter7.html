---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/98392TPILChapter7.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html">TPIL Chapter 7</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="190544119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190544119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190544119">Rocky Kamen-Rubio (Mar 13 2020 at 19:20)</a>:</h4>
<ol>
<li>I'm running into type issues with inductively defined types that Lean already has defined. For example, when I try running the code from the book below, I get an error in add_zero that n is of type N but type nat is expected. </li>
</ol>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">nat</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span>

<span class="kn">namespace</span> <span class="n">nat</span>
<span class="n">def</span> <span class="n">add</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span> <span class="n">m</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">add_m_n</span><span class="o">,</span> <span class="n">succ</span> <span class="n">add_m_n</span><span class="o">)</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">add</span> <span class="o">(</span><span class="n">succ</span> <span class="n">zero</span><span class="o">)</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">zero</span><span class="o">))</span>


<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">has_zero</span><span class="bp">.</span><span class="n">mk</span> <span class="n">zero</span> <span class="c1">--instance is explained in ch 10</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">has_add</span><span class="bp">.</span><span class="n">mk</span> <span class="n">add</span>

<span class="kn">theorem</span> <span class="n">add_zero</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">theorem</span> <span class="n">add_succ</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">--this is how we defined addition</span>


<span class="kn">theorem</span> <span class="n">zero_add</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span>
  <span class="o">(</span><span class="k">show</span> <span class="mi">0</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">ih</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">show</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span>
      <span class="k">calc</span>
        <span class="mi">0</span> <span class="bp">+</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
          <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">n</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">ih</span><span class="o">)</span>


<span class="kn">end</span> <span class="n">nat</span>
</pre></div>


<p>Similarly, when I define <code>bool</code>I get the same error when I do <code>bool.cases_on</code></p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">empty</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kn">inductive</span> <span class="n">unit</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">star</span> <span class="o">:</span> <span class="n">unit</span>
<span class="kn">inductive</span> <span class="n">bool</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">ff</span> <span class="o">:</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">tt</span> <span class="o">:</span> <span class="n">bool</span>

<span class="c1">--EXERCISE: Define band bor bnot on this new bool type</span>

<span class="n">def</span> <span class="n">band</span> <span class="o">(</span><span class="n">b1</span> <span class="n">b2</span> <span class="o">:</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">bool</span> <span class="o">:=</span>
<span class="n">bool</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">b1</span> <span class="n">ff</span> <span class="n">b2</span>

<span class="n">def</span> <span class="n">bor</span> <span class="o">(</span><span class="n">b1</span> <span class="n">b2</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="n">bool</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">b1</span> <span class="n">b2</span> <span class="n">tt</span>

<span class="n">def</span> <span class="n">bnot</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="n">bool</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">b</span> <span class="n">tt</span> <span class="n">ff</span>
</pre></div>


<p>The same issue comes up when I do <code>sum</code> and <code>prod</code> from the book. I've been copying over the text from the book, and have imported <code>data.nat.basic</code> and <code>tactic</code></p>

<a name="190544304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190544304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190544304">Bryan Gin-ge Chen (Mar 13 2020 at 19:21)</a>:</h4>
<p>Try adding <code>namespace mydefs</code> before your code and <code>end mydefs</code> after your code. That should help Lean disambiguate the names.</p>

<a name="190544418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190544418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190544418">Patrick Massot (Mar 13 2020 at 19:22)</a>:</h4>
<p>Choosing different names is also a very efficient way to disambiguate.</p>

<a name="190544936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190544936" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190544936">Bryan Gin-ge Chen (Mar 13 2020 at 19:27)</a>:</h4>
<p>Note that in <code>zero_add</code>, <code>ℕ</code> is notation for the built-in <code>nat</code> (<code>_root_.nat</code>), so it fails.</p>

<a name="190545113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190545113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190545113">Bryan Gin-ge Chen (Mar 13 2020 at 19:29)</a>:</h4>
<p>Not sure why the <code>show</code> fails, but this works:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">zero_add</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span>
  <span class="o">(</span><span class="n">rfl</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">ih</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
    <span class="k">show</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span><span class="o">,</span> <span class="k">from</span>
      <span class="k">calc</span>
        <span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:</span> <span class="n">rfl</span>
          <span class="bp">...</span> <span class="bp">=</span> <span class="n">n</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">ih</span><span class="o">)</span>
</pre></div>

<a name="190545956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190545956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190545956">Rocky Kamen-Rubio (Mar 13 2020 at 19:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190544936" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190544936">said</a>:</p>
<blockquote>
<p>Note that in <code>zero_add</code>, <code>ℕ</code> is notation for the built-in <code>nat</code> (<code>_root_.nat</code>), so it fails.</p>
</blockquote>
<p>Interesting, yeah I'm also getting that it fails when I use show but not when I just use <code>(rfl)</code> like you are.</p>

<a name="190546755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190546755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190546755">Rocky Kamen-Rubio (Mar 13 2020 at 19:44)</a>:</h4>
<p>I'm also getting an error on the <code>#check</code> term at the end when I try to do </p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">list</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="bp">→</span> <span class="n">list</span>

<span class="kn">namespace</span> <span class="n">list</span>
<span class="kn">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="kn">notation</span> <span class="n">h</span> <span class="bp">::</span> <span class="n">t</span>  <span class="o">:=</span> <span class="n">cons</span> <span class="n">h</span> <span class="n">t</span>
<span class="n">def</span> <span class="n">append</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">list</span><span class="bp">.</span><span class="n">rec</span> <span class="n">t</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">l</span> <span class="n">u</span><span class="o">,</span> <span class="n">x</span><span class="bp">::</span><span class="n">u</span><span class="o">)</span> <span class="n">s</span>
<span class="kn">notation</span> <span class="n">s</span> <span class="bp">++</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">append</span> <span class="n">s</span> <span class="n">t</span>
<span class="kn">theorem</span> <span class="n">nil_append</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nil</span> <span class="bp">++</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">theorem</span> <span class="n">cons_append</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span><span class="bp">::</span><span class="n">s</span> <span class="bp">++</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">::</span><span class="o">(</span><span class="n">s</span> <span class="bp">++</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">notation</span> <span class="err">&#39;</span><span class="o">[</span><span class="err">&#39;</span> <span class="n">l</span><span class="o">:(</span><span class="n">foldr</span> <span class="err">&#39;</span><span class="o">,</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">cons</span> <span class="n">h</span> <span class="n">t</span><span class="o">)</span> <span class="n">nil</span><span class="o">)</span> <span class="err">&#39;</span><span class="o">]</span><span class="err">&#39;</span> <span class="o">:=</span> <span class="n">l</span>

<span class="bp">#</span><span class="kn">check</span> <span class="o">([</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">)</span>

<span class="c1">--EDIT: It only happens when I open a new section like this</span>
<span class="kn">section</span>
    <span class="kn">open</span> <span class="n">nat</span>
    <span class="bp">#</span><span class="kn">check</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
    <span class="bp">#</span><span class="kn">check</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℤ</span>
<span class="kn">end</span>
</pre></div>

<a name="190799779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190799779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190799779">Rocky Kamen-Rubio (Mar 17 2020 at 01:23)</a>:</h4>
<p>I'm very confused by the exercises suggested at the end of section 7.2. They read</p>
<div class="codehilite"><pre><span></span><span class="n">As</span> <span class="n">exercises</span><span class="o">,</span> <span class="n">we</span> <span class="n">encourage</span> <span class="n">you</span> <span class="n">to</span> <span class="n">develop</span> <span class="n">a</span> <span class="n">notion</span> <span class="n">of</span> <span class="n">composition</span> <span class="n">for</span> <span class="n">partial</span> <span class="n">functions</span> <span class="k">from</span> <span class="n">α</span> <span class="n">to</span> <span class="n">β</span> <span class="n">and</span> <span class="n">β</span> <span class="n">to</span> <span class="n">γ</span><span class="o">,</span> <span class="n">and</span> <span class="k">show</span> <span class="n">that</span> <span class="n">it</span> <span class="n">behaves</span> <span class="n">as</span> <span class="n">expected</span><span class="bp">.</span> <span class="n">We</span> <span class="n">also</span> <span class="n">encourage</span> <span class="n">you</span> <span class="n">to</span> <span class="k">show</span> <span class="n">that</span> <span class="n">bool</span> <span class="n">and</span> <span class="n">nat</span> <span class="n">are</span> <span class="n">inhabited</span><span class="o">,</span> <span class="n">that</span> <span class="n">the</span> <span class="n">product</span> <span class="n">of</span> <span class="n">two</span> <span class="n">inhabited</span> <span class="n">types</span> <span class="n">is</span> <span class="n">inhabited</span><span class="o">,</span> <span class="n">and</span> <span class="n">that</span> <span class="n">the</span> <span class="n">type</span> <span class="n">of</span> <span class="n">functions</span> <span class="n">to</span> <span class="n">an</span> <span class="n">inhabited</span> <span class="n">type</span> <span class="n">is</span> <span class="n">inhabited</span><span class="bp">.</span>

<span class="kn">inductive</span> <span class="n">option</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">none</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">option</span>
<span class="bp">|</span> <span class="n">some</span>    <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span>

<span class="kn">inductive</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">inhabited</span>
</pre></div>


<p>For the inhabited type, I understand conceptually that given an example of an instance of a type, we could generate an object that says this type is inhabited. I'm at a loss for how to actually do something like <code>define inhabited_example ...</code> the we the book does for sum and prod. </p>
<p>For option, I'm substantially more confused. It seems like option would go from a given element of the domain to either none or to a defined function, not the other way around. I feel like I'm misunderstanding something about what it means to have a recursively defined type.</p>

<a name="190801100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190801100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190801100">Mario Carneiro (Mar 17 2020 at 01:50)</a>:</h4>
<p><code>option A</code> is a type which has one more element than <code>A</code>. The extra element is called <code>none : option A</code>, and the function that maps <code>A</code> into <code>option A</code> is called <code>some : A -&gt; option A</code>.</p>

<a name="190801192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190801192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190801192">Mario Carneiro (Mar 17 2020 at 01:53)</a>:</h4>
<p>Can you prove</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="190802208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190802208" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190802208">Rocky Kamen-Rubio (Mar 17 2020 at 02:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190801192" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190801192">said</a>:</p>
<blockquote>
<p>Can you prove</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


</blockquote>
<p>I'm not sure... If we have proofs that A and B and inhabited, it makes sense me that <code>A x B</code> would be inhabited. My intuition is to apply <code>inhabited.mk</code> to the product of the two instances we have, but that gives me a type error (understandably). Is there a way to extract the actual instance from an <code>inhabited</code> object so we can use it to make a new one?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">inhabited</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">h1</span> <span class="bp">×</span> <span class="n">h2</span><span class="o">)</span>
</pre></div>

<a name="190802713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190802713" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190802713">Bryan Gin-ge Chen (Mar 17 2020 at 02:34)</a>:</h4>
<p>(deleted, I was using Lean's definition of inhabited, not the one given by TPiL...)</p>

<a name="190803827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190803827" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190803827">Bryan Gin-ge Chen (Mar 17 2020 at 03:03)</a>:</h4>
<p>One way is to use the <code>match ... with ... end</code> syntax:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">h1</span><span class="o">,</span> <span class="n">h2</span> <span class="k">with</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">inhabited</span><span class="bp">.</span><span class="n">mk</span> <span class="n">a</span><span class="o">),</span> <span class="o">(</span><span class="n">inhabited</span><span class="bp">.</span><span class="n">mk</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩</span>
<span class="kn">end</span>
</pre></div>


<p>This syntax "pattern matches" on <code>h1</code> and <code>h2</code> to pull out <code>a : A</code> and <code>b : B</code>.</p>
<p>You can also use angle brackets in place of the constructors like this:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">h1</span><span class="o">,</span> <span class="n">h2</span> <span class="k">with</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">a</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">b</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩⟩</span>
<span class="kn">end</span>
</pre></div>

<a name="190803999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190803999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190803999">Bryan Gin-ge Chen (Mar 17 2020 at 03:07)</a>:</h4>
<p>Compare also:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="bp">⟨</span><span class="n">a</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">h1</span> <span class="k">in</span>
<span class="k">let</span> <span class="bp">⟨</span><span class="n">b</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">h2</span> <span class="k">in</span>
<span class="bp">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩⟩</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">inhabited</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">a</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">b</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨⟨</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="bp">⟩⟩</span>
</pre></div>

<a name="190805054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190805054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190805054">Bryan Gin-ge Chen (Mar 17 2020 at 03:29)</a>:</h4>
<p>Oh, pattern-matching is introduced in chapter 8, so I guess you're meant  to use <code>inhabited.cases_on</code> instead. Here's a hint:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">inhabited</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">h1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">h2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="bp">_</span><span class="o">))</span>
</pre></div>


<p>[I was hoping this would work with dot notation (so I could write <code>h1.cases_on</code> and <code>h2.cases_on</code> instead of <code>inhabited.cases_on h1</code>, etc.) but it looks like that's too much for the elaborator...]</p>

<a name="190939609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190939609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190939609">Rocky Kamen-Rubio (Mar 18 2020 at 05:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190805054" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190805054">said</a>:</p>
<blockquote>
<p>Oh, pattern-matching is introduced in chapter 8, so I guess you're meant  to use <code>inhabited.cases_on</code> instead. Here's a hint:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">A</span> <span class="bp">×</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">inhabited</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">h1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">h2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="bp">_</span><span class="o">))</span>
</pre></div>


<p>[I was hoping this would work with dot notation (so I could write <code>h1.cases_on</code> and <code>h2.cases_on</code> instead of <code>inhabited.cases_on h1</code>, etc.) but it looks like that's too much for the elaborator...]</p>
</blockquote>
<p>Thanks for your detailed answer! I'm getting a "don't know how to synthesize placeholder<br>
context:" error on the wildecard. Is there something I need to import somewhere? I'm also still a little confused conceptually by how this works but maybe that'll be cleared up after reading chapter 8.</p>

<a name="190939723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190939723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190939723">Rocky Kamen-Rubio (Mar 18 2020 at 05:07)</a>:</h4>
<p>I think part of my confusion comes from the fact that all the solutions you gave rely on implicit notation using either brackets or wildcards. Is there an explicit way to show a type is inhabited, or is that not the way I should be thinking about this problem?</p>

<a name="190939865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190939865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190939865">Bryan Gin-ge Chen (Mar 18 2020 at 05:12)</a>:</h4>
<blockquote>
<p>I'm getting a "don't know how to synthesize placeholder context:" error on the wildecard.</p>
</blockquote>
<p>That's right, the underscore was left for you to fill in. <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span> </p>
<blockquote>
<p>Is there something I need to import somewhere?</p>
</blockquote>
<p>No imports necessary!</p>
<blockquote>
<p>Is there an explicit way to show a type is inhabited</p>
</blockquote>
<p>Yep, in this context, <code>⟨⟨a, b⟩⟩</code> is just shorthand for to <code>inhabited.mk (prod.mk a b)</code>.</p>

<a name="190939929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190939929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190939929">Rocky Kamen-Rubio (Mar 18 2020 at 05:14)</a>:</h4>
<p>Oh, that makes sense haha. I thought you were intentionally leaving it as a wildcard. This is very helpful, thank you!</p>

<a name="190941372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190941372">Rocky Kamen-Rubio (Mar 18 2020 at 05:56)</a>:</h4>
<p>Ok I'm still a little confused about how <code>option</code> works. I'm trying to define a simple function that is the identity on 0 and 1, and undefined everywhere else. I'm getting a type mismatch error on all three <code>:=</code> signs when I do the following. Any thoughts?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">partial</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">option</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">some</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">some</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">none</span>
</pre></div>

<a name="190941519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190941519">Kenny Lau (Mar 18 2020 at 06:01)</a>:</h4>
<p>it does not give any error for me.</p>

<a name="190941706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190941706">Bryan Gin-ge Chen (Mar 18 2020 at 06:06)</a>:</h4>
<p>Rocky's using the <code>option</code> defined in TPiL, so the full code is something like this:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">blah</span>
<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">inductive</span> <span class="n">option</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">none</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">option</span>
<span class="bp">|</span> <span class="n">some</span>    <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span>


<span class="n">def</span> <span class="n">partial</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">option</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">some</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">some</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">none</span>

<span class="kn">end</span> <span class="n">blah</span>
</pre></div>

<a name="190941716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190941716">Bryan Gin-ge Chen (Mar 18 2020 at 06:06)</a>:</h4>
<p><del>The solution is to add <code>open option</code> before <code>def partial</code>.</del></p>
<p>This works:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">blah</span>
<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">inductive</span> <span class="n">option</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">none</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">option</span>
<span class="bp">|</span> <span class="n">some</span>    <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span>

<span class="n">def</span> <span class="n">partial</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">option</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">some</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">some</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">none</span>

<span class="kn">end</span> <span class="n">blah</span>
</pre></div>

<a name="190941794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190941794">Rocky Kamen-Rubio (Mar 18 2020 at 06:08)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>  for catching that! Adding <code>open option</code> doesn't seem to resolve this issue. Leaving the namespace and using lean's default <code>option</code> does work though. I thought the two definitions were the same here... is that not the case?</p>

<a name="190941805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941805" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190941805">Rocky Kamen-Rubio (Mar 18 2020 at 06:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190941716" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190941716">said</a>:</p>
<blockquote>
<p><del>The solution is to add <code>open option</code> before <code>def partial</code>.</del></p>
<p>This works:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">blah</span>
<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">inductive</span> <span class="n">option</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">none</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">option</span>
<span class="bp">|</span> <span class="n">some</span>    <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span>

<span class="n">def</span> <span class="n">partial</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">option</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">some</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">some</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">option</span><span class="bp">.</span><span class="n">none</span>

<span class="kn">end</span> <span class="n">blah</span>
</pre></div>


</blockquote>
<p>That did the trick. Thank you!</p>

<a name="190941884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190941884">Bryan Gin-ge Chen (Mar 18 2020 at 06:11)</a>:</h4>
<p>Yeah, it wasn't <code>open option</code> that worked but rather surrounding <code>def partial</code> with <code>namespace option</code> and <code>end option</code> (or writing the names out fully as I did above).</p>

<a name="190941932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190941932">Bryan Gin-ge Chen (Mar 18 2020 at 06:12)</a>:</h4>
<p>The <code>option</code> provided by Lean's core library is equivalent, but you can't use it when Lean is expecting your <code>option</code>.</p>

<a name="190941986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190941986">Rocky Kamen-Rubio (Mar 18 2020 at 06:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190941932" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190941932">said</a>:</p>
<blockquote>
<p>The <code>option</code> provided by Lean's core library is equivalent, but you can't use it when Lean is expecting your <code>option</code>.</p>
</blockquote>
<p>Makes sense. This has come up before when TPIL makes you define types that are built in and I've forgotten that the interactions are a little different. Thanks!</p>

<a name="190941987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190941987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190941987">Rocky Kamen-Rubio (Mar 18 2020 at 06:14)</a>:</h4>
<p>Another question: I'm trying to define the composite of partial functions also discussed in this section. I have this so far, and am (understandably) running into an error when I try to apply <code>g</code> to <code>(f a)</code> because it is an element of <code>option β</code> rather than <code>β</code>. Is there an easy way to convert back from an option type to the element of the regular type?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">compose_partials</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span>  <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">option</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)))</span> <span class="o">(</span><span class="n">none</span><span class="o">)</span>
</pre></div>

<a name="190942392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190942392" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190942392">Shing Tak Lam (Mar 18 2020 at 06:27)</a>:</h4>
<p><del>I think you might need a helper function like this:</del></p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">helper</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">option</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">x</span>
<span class="bp">|</span> <span class="bp">_</span>               <span class="o">:=</span> <span class="n">none</span>
</pre></div>


<p><del>I don't think there is a way to have a function where<code>f : option a -&gt; a</code> in Lean, since <code>f none</code> would require you to be able to make a value of type <code>a</code> for all <code>a</code>.</del></p>
<p><del>In other languages (Haskell, etc.) there is what you're looking for, but they crash on the case <code>f none</code>.</del></p>
<p>Nevermind.</p>

<a name="190942608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190942608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190942608">Bryan Gin-ge Chen (Mar 18 2020 at 06:31)</a>:</h4>
<p>This works:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">compose_partials</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">option</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">none</span> <span class="n">g</span>
</pre></div>


<p>I think maybe you were thrown off by having <code>none</code> in the wrong slot.</p>

<a name="190946023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/190946023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#190946023">Kevin Buzzard (Mar 18 2020 at 07:38)</a>:</h4>
<p>I think this is called <code>bind</code> and it's basically the proof that <code>option</code> is a monad</p>

<a name="191068324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191068324" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#191068324">Rocky Kamen-Rubio (Mar 19 2020 at 03:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190942608" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190942608">said</a>:</p>
<blockquote>
<p>This works:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">compose_partials</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">option</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">none</span> <span class="n">g</span>
</pre></div>


<p>I think maybe you were thrown off by having <code>none</code> in the wrong slot.</p>
</blockquote>
<p>Wouldn't this just give us the function g in the case that a is in the domain of f, and not the element that g maps (f a) to? Or am I missing something?</p>

<a name="191068428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191068428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#191068428">Rocky Kamen-Rubio (Mar 19 2020 at 03:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="266440">Shing Tak Lam</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190942392" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/190942392">said</a>:</p>
<blockquote>
<p><del>I think you might need a helper function like this:</del></p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">helper</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">option</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">x</span>
<span class="bp">|</span> <span class="bp">_</span>               <span class="o">:=</span> <span class="n">none</span>
</pre></div>


<p><del>I don't think there is a way to have a function where<code>f : option a -&gt; a</code> in Lean, since <code>f none</code> would require you to be able to make a value of type <code>a</code> for all <code>a</code>.</del></p>
<p><del>In other languages (Haskell, etc.) there is what you're looking for, but they crash on the case <code>f none</code>.</del></p>
<p>Nevermind.</p>
</blockquote>
<p>That makes sense. The notation for more abstract recursive types like this still makes my head hurt a little, but I feel like that will probably get better with time.</p>

<a name="191068759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191068759" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#191068759">Reid Barton (Mar 19 2020 at 03:26)</a>:</h4>
<p>It might help to see the definition expanded as <code>λ a : α, option.cases_on (f a) none (λ b, g b)</code></p>

<a name="191068857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191068857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#191068857">Rocky Kamen-Rubio (Mar 19 2020 at 03:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/191068759" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/191068759">said</a>:</p>
<blockquote>
<p>It might help to see the definition expanded as <code>λ a : α, option.cases_on (f a) none (λ b, g b)</code></p>
</blockquote>
<p>Using a helper function and reversing the order of the arguments to <code>option (f a) _ _</code> I still get two errors. </p>
<p>That makes sense to me. Does <code>cases_on</code> do that automatically with the notation <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>  gave?</p>

<a name="191068929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191068929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#191068929">Reid Barton (Mar 19 2020 at 03:30)</a>:</h4>
<p>I don't understand your question. But <code>g</code> equals <code>λ b, g b</code>.</p>

<a name="191069073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191069073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#191069073">Rocky Kamen-Rubio (Mar 19 2020 at 03:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/191068929" title="#narrow/stream/113489-new-members/topic/TPIL.20Chapter.207/near/191068929">said</a>:</p>
<blockquote>
<p>I don't understand your question. But <code>g</code> equals <code>λ b, g b</code>.</p>
</blockquote>
<p>Oh duh, yeah I was just getting a little lost in what was taking in what and going where with <code>cases_on</code>. Yeah that makes sense now. </p>
<p><span class="user-mention" data-user-id="266440">@Shing Tak Lam</span>  I tried doing something like this and got rid of the return type error but I'm getting type mismatches in my helper function and at <code>option.cases_on</code></p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">helper</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">input</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">):</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">some</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">some</span> <span class="n">x</span> <span class="o">:</span> <span class="n">x</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:</span> <span class="n">none</span>

<span class="n">def</span> <span class="n">compose_partials</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span><span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">γ</span>  <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">option</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="n">none</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">helper</span> <span class="o">(</span><span class="n">g</span> <span class="n">b</span><span class="o">))</span>
</pre></div>

<a name="191070850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191070850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#191070850">Shing Tak Lam (Mar 19 2020 at 04:25)</a>:</h4>
<p><span class="user-mention" data-user-id="260106">@Rocky Kamen-Rubio</span> </p>
<p>Nevermind what I said previously. I didn't look at it properly. (I never did TPIL). So I did it with <code>option.map</code> instead of <code>option.cases_on</code>.</p>
<p>Sorry for any confusion</p>

<a name="191079092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191079092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#191079092">Kevin Buzzard (Mar 19 2020 at 07:48)</a>:</h4>
<p><span class="user-mention" data-user-id="261068">@ROCKY KAMEN-RUBIO</span> your helper definition does not look good to me. What is the type of x supposed to be in some (some x)? You say you're getting type mismatches but if you just read them carefully they will tell you by themselves the errors you made</p>

<a name="191079147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191079147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#191079147">Kevin Buzzard (Mar 19 2020 at 07:49)</a>:</h4>
<p>You do understand that alpha and option alpha are completely different types, right?</p>

<a name="191079217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191079217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#191079217">Kevin Buzzard (Mar 19 2020 at 07:50)</a>:</h4>
<p>There is no natural helper map of the kind you're trying to define because where is none going to go? Alpha could be empty</p>

<a name="191079327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191079327" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#191079327">Kevin Buzzard (Mar 19 2020 at 07:52)</a>:</h4>
<p>Maybe you should take a look at learnyouahaskell? This taught me a lot about functional programming</p>

<a name="191079798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191079798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#191079798">Mario Carneiro (Mar 19 2020 at 07:58)</a>:</h4>
<p>Given the type of <code>compose_partials</code>, it looks like the right thing to put in the location of <code>helper</code> is the identity function</p>

<a name="191082205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/TPIL%20Chapter%207/near/191082205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/98392TPILChapter7.html#191082205">Shing Tak Lam (Mar 19 2020 at 08:31)</a>:</h4>
<p><span class="user-mention" data-user-id="260106">@Rocky Kamen-Rubio</span> </p>
<p>The <code>helper</code> function I posted is</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">helper</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">option</span> <span class="o">(</span><span class="n">option</span> <span class="n">α</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">option</span> <span class="n">α</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">x</span>
<span class="bp">|</span> <span class="bp">_</span>               <span class="o">:=</span> <span class="n">none</span>
</pre></div>


<p>The one you posted is below</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">helper</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">input</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">):</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">some</span> <span class="o">(</span><span class="n">some</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">some</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">some</span> <span class="n">x</span> <span class="o">:</span> <span class="n">x</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:</span> <span class="n">none</span>
</pre></div>


<p>Notice how mine is <code>option (option α) -&gt; option α</code>, while yours is <code>option α -&gt; α</code>. That is why the first case from mine <code>(some (some x)) := some x</code> doesn't apply for you, as the left hand side <code>(some (some x))</code> has the type <code>option (option α)</code>, not <code>option α</code>. Also, the parenthesis matter here, as when used to pattern match, <code>(some (some x))</code> and <code>some (some x)</code> are different.</p>
<p>Additionally, there is a syntax error there, it should be <code>:=</code> in the cases.</p>
<p>Also notice the types of your cases do not match, as the first one is <code>option (option α) -&gt; option α</code>, the second one is <code>option α -&gt; α</code>, the last one is <code>option α -&gt; option ???</code>. So lean complains that all of them have different types.</p>
<p>The helper function was when I solved it with <code>option.map</code>, and <code>option.cases_on</code> expects a different function, so that's why you're getting an error there. <code>option.map</code> would produce a <code>option (option α)</code>, which is why I needed the <code>helper</code> function, as for this example, <code>some (none)</code> is pragmatically the same as <code>none</code>, so I use <code>_</code> to catch both cases.</p>
<p>Sorry for any confusion caused</p>


{% endraw %}

{% include archive_update.html %}