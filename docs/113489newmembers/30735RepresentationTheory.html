---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/30735RepresentationTheory.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html">Representation Theory</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="178343253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178343253" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178343253">Jineon Baek (Oct 17 2019 at 01:39)</a>:</h4>
<p>I was reading through a Representation Theory textbook and a question came to my mind: Have the theory been implemented in any LEAN library?</p>

<a name="178344006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178344006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178344006">Scott Morrison (Oct 17 2019 at 01:59)</a>:</h4>
<p>No, there's essentially no representation theory at this point (although there is some commutative algebra).</p>

<a name="178345476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178345476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178345476">Jineon Baek (Oct 17 2019 at 02:36)</a>:</h4>
<p>Thank you for answering. If so, how much it will be worth (for this community) to implement the theory in a library? It's a classical theory, but the fact that it is not yet implemented seems to somewhat imply that there are more urgent needs for other theories now. I want to know the context if any exists.</p>

<a name="178345702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178345702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178345702">Johan Commelin (Oct 17 2019 at 02:42)</a>:</h4>
<p><span class="user-mention" data-user-id="242240">@Jineon Baek</span> It only somewhat implies that we don't have enough people power. It's a relatively small group of contributors, and they just hack on whatever they think is fun.</p>

<a name="178345714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178345714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178345714">Johan Commelin (Oct 17 2019 at 02:43)</a>:</h4>
<p>There are several people on this chat that think that representation theory is extremely important. But we just haven't got round to doing anything so far.</p>

<a name="178345726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178345726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178345726">Johan Commelin (Oct 17 2019 at 02:43)</a>:</h4>
<p>At some point <span class="user-mention" data-user-id="220718">@Ben McDonnell</span> started working on some rep.theory. Maybe he can share what he's got so far somewhere.</p>

<a name="178346393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178346393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178346393">Scott Morrison (Oct 17 2019 at 03:02)</a>:</h4>
<p>Yes, I'd love to see some! A lot depends on what generality you want to do things in, and often for mathlib the answer is "a lot of generality".</p>

<a name="178346406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178346406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178346406">Scott Morrison (Oct 17 2019 at 03:03)</a>:</h4>
<p>The theory of abelian categories is on the horizon, and might be useful to have in place, so if someone wants to work on that I'd be happy to provide some pointers (and get around to doing some of the things I promised to do).</p>

<a name="178346410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178346410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178346410">Scott Morrison (Oct 17 2019 at 03:04)</a>:</h4>
<p>But generally --- pick a (good) book, and have a go. :-)</p>

<a name="178346477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178346477" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178346477">Scott Morrison (Oct 17 2019 at 03:05)</a>:</h4>
<p>I'd love to see someone start on Etingof's Representation Theory: <a href="http://www-math.mit.edu/~etingof/repb.pdf" target="_blank" title="http://www-math.mit.edu/~etingof/repb.pdf">http://www-math.mit.edu/~etingof/repb.pdf</a></p>

<a name="178348965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178348965" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178348965">Jineon Baek (Oct 17 2019 at 04:15)</a>:</h4>
<p>Thanks for the input everyone! I'm a newbie both in this lean game and representation theory, so I'm thinking of learning both by implementing theorems in a textbook as I learn them like the 'intro to proof' course project.</p>

<a name="178349170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178349170" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178349170">Jineon Baek (Oct 17 2019 at 04:20)</a>:</h4>
<p>Full generality is definitely what standard library should aim for though. If my own little project works out well I'll share. Would happy to hear pointers for a starting point. I'm wondering if I should give it a try for finite group rep. with finite dimensional vector space first, or in a bit more generality.</p>

<a name="178349357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178349357" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178349357">Scott Morrison (Oct 17 2019 at 04:24)</a>:</h4>
<p>Why not try to prove the first interesting thing about finite group representations: averaging over the group is the projection onto the trivial isotypic component?</p>

<a name="178349402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178349402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178349402">Scott Morrison (Oct 17 2019 at 04:25)</a>:</h4>
<ol>
<li>define the operator 1/|G| \Sigma_g g</li>
<li>prove that it is idempotent</li>
<li>prove that anything in its image is fixed by the group</li>
<li>prove that if you are fixed by every group element you are fixed by this operator</li>
</ol>

<a name="178349473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178349473" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178349473">Scott Morrison (Oct 17 2019 at 04:27)</a>:</h4>
<p>You'll need to see how to work with linear operators, and use <code>finset.sum</code> to handle the summations.</p>

<a name="178349554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178349554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178349554">Jineon Baek (Oct 17 2019 at 04:29)</a>:</h4>
<p><span class="user-mention" data-user-id="242241">@Seewoo Lee</span></p>

<a name="178352673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178352673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178352673">Johan Commelin (Oct 17 2019 at 05:50)</a>:</h4>
<p><span class="user-mention" data-user-id="242240">@Jineon Baek</span> But certainly you will make your Lean life a lot easier by not putting those finiteness assumptions in your definition</p>

<a name="178352690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178352690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178352690">Johan Commelin (Oct 17 2019 at 05:50)</a>:</h4>
<ol start="5">
<li>prove that the subset of elements fixed by the group is a sub-vectorspace.</li>
</ol>

<a name="178354918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178354918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178354918">Kevin Buzzard (Oct 17 2019 at 06:46)</a>:</h4>
<p>Representation theory is one of the many things on my list of stuff we need to get done at some point. It's a beautiful theory, and essentially self-contained. The first part of Serre's book would be the kind of goal we'd need</p>

<a name="178359160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178359160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178359160">Kenny Lau (Oct 17 2019 at 08:04)</a>:</h4>
<p>inb4 it's a special case of L^2(G) and Peter--Weyl theorem</p>

<a name="178416100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178416100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178416100">Tim Daly (Oct 17 2019 at 19:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  When we developed Axiom at IBM Research there was an effort made to invite and actively support people who worked in areas where we needed implementations, for example, in finite fields. It might be interesting to "talent search" among mathematicians and actively recruit their participation. Perhaps Microsoft could be convinced to do a "Microsoft Summer of Code", providing a summer support program for mathematicians with proposals for lean development.</p>

<a name="178451453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/178451453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#178451453">Kevin Buzzard (Oct 18 2019 at 07:50)</a>:</h4>
<p>I don't think we need a "person who works in representation theory" -- all we need is an intelligent undergraduate who is trained in type theory and is interested, and I'm sure I'll find one in the end.</p>

<a name="190638253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190638253" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190638253">Patrick Stevens (Mar 15 2020 at 09:22)</a>:</h4>
<p>I've collected together some of the bits and pieces of mathlib that I will require to define linear representations, but I'm still too new to be able to assemble them into a definition. I think the following is all the component parts, but it's just a heap of nonsense at the moment. Would some kind soul be able to align them into something I can start expressing lemmas about? (I'll probably only need a few of this kind of really basic question before I can answer such trivia myself.)</p>
<p>One particular question I don't know the answer to: should I be expressing "linear representation" as a typeclass or merely a record? </p>
<p>Alternatively, is there some kind of Lean walkthrough of how to assemble a definition like this?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">field</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">finite_dimensional</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">x</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">U</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">F</span> <span class="o">:</span> <span class="n">field</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">X</span> <span class="o">:</span> <span class="n">Set</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">V</span> <span class="o">:</span> <span class="n">vector_space</span> <span class="n">F</span> <span class="n">X</span><span class="o">]</span>

<span class="c1">-- Definition. Let V be a finite-dimensional vector space over F. A (linear) repre-</span>
<span class="c1">-- sentation of G on V is a homomorphism ρ = ρ_V : G → GL(V).</span>

<span class="c1">--def general_linear_group := units (M →ₗ[R] M)</span>
<span class="c1">--class is_group_hom [group α] [group β] (f : α → β) extends is_mul_hom f : Prop</span>
</pre></div>

<a name="190638449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190638449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190638449">Mario Carneiro (Mar 15 2020 at 09:28)</a>:</h4>
<p>The variables are quite right. The variables are the underlying types, and the structures are anonymous typeclass variables. Like so:</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V</span><span class="o">]</span>
</pre></div>

<a name="190638461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190638461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190638461">Mario Carneiro (Mar 15 2020 at 09:29)</a>:</h4>
<p>Similarly, <code>G</code> is a group means <code>variables {G : Type*} [group G]</code></p>

<a name="190638536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190638536" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190638536">Mario Carneiro (Mar 15 2020 at 09:30)</a>:</h4>
<p>and then a linear representation would be an element of <code>G -&gt;* units (V -&gt;l[F] V)</code></p>

<a name="190639239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190639239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190639239">Patrick Stevens (Mar 15 2020 at 09:47)</a>:</h4>
<p>Thanks. The way I had previously expected this to look was something like <code>def linear_representation (p : G -&gt; general_linear_group F (n -&gt; F)) := is_monoid_hom p</code>, but I suspect my mental model is wrong in a way that I don't understand (that line certainly doesn't compile). Is it clear to you what I've misunderstood?</p>

<a name="190639427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190639427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190639427">Patrick Stevens (Mar 15 2020 at 09:50)</a>:</h4>
<p>to be clear, I currently have:</p>
<div class="codehilite"><pre><span></span>import algebra.field
import linear_algebra.finite_dimensional
import linear_algebra.basic
import algebra.module

open linear_map

universes u v
variables {F : Type u} {V : Type v}
variables [discrete_field F]
variables (n : Type u) [fintype n] [decidable_eq n]
variables [field F]
variables {G : Type*} [add_comm_group G]
variables [vector_space F G]

def linear_representation (p : G -&gt; general_linear_group F (n -&gt; F)) := is_monoid_hom p
</pre></div>

<a name="190640530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190640530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190640530">Mario Carneiro (Mar 15 2020 at 10:18)</a>:</h4>
<p>You have two instances on <code>F</code>, one a <code>field</code> and one a <code>discrete_field</code>, that's definitely wrong. That is saying that <code>F</code> has two independent field structures. (In the latest version of lean/mathlib <code>discrete_field</code> has been renamed to <code>field</code>, replacing the original <code>field</code>.)</p>

<a name="190640544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190640544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190640544">Mario Carneiro (Mar 15 2020 at 10:19)</a>:</h4>
<p>It's true that I didn't say anything about the finite dimensionality in the version I gave. That could be a predicate on <code>V</code>, something like <code>dim V &lt; omega</code>, although perhaps there's a typeclass for this now</p>

<a name="190640597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190640597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190640597">Mario Carneiro (Mar 15 2020 at 10:20)</a>:</h4>
<p>But in your version, <code>vector_space F G</code> means that <code>G</code> is the <code>F</code>-vector space</p>

<a name="190640604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190640604" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190640604">Mario Carneiro (Mar 15 2020 at 10:21)</a>:</h4>
<p>which could be what you mean but doesn't match the math text in the comment</p>

<a name="190640656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190640656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190640656">Mario Carneiro (Mar 15 2020 at 10:23)</a>:</h4>
<p>The way you have set up <code>linear_representation p</code> is as a predicate on functions from G asserting that they are a linear representation, whereas the approach I gave takes linear representations to be the entire type <code>G -&gt;* units (V -&gt;l[F] V)</code>, which bundles together the function with the proof that it is a group hom</p>

<a name="190640695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190640695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190640695">Patrick Stevens (Mar 15 2020 at 10:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190640604" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190640604">said</a>:</p>
<blockquote>
<p>which could be what you mean but doesn't match the math text in the comment</p>
</blockquote>
<p>Ah, you're quite right - I don't know how I could have made that mistake :P</p>

<a name="190640704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190640704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190640704">Mario Carneiro (Mar 15 2020 at 10:24)</a>:</h4>
<p>mathlib is slowly moving away from unbundled homs like <code>is_monoid_hom</code> in favor of bundled homs like <code>G -&gt;+ H</code></p>

<a name="190640707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190640707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190640707">Patrick Stevens (Mar 15 2020 at 10:24)</a>:</h4>
<p>OK, that makes sense - thanks</p>

<a name="190641233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641233" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641233">Patrick Stevens (Mar 15 2020 at 10:41)</a>:</h4>
<p>The flood of my questions should decay exponentially, but in the meantime: the following doesn't compile because "type expected at <code>linear_representation</code>" in the last line. How can I pass a linear representation into the function <code>dimension</code>?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">field</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">finite_dimensional</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">module</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">hom</span>

<span class="kn">open</span> <span class="n">linear_map</span>

<span class="n">universes</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">n</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V</span><span class="o">]</span>

<span class="n">def</span> <span class="n">linear_representation</span> <span class="o">:=</span> <span class="n">monoid_hom</span> <span class="n">G</span> <span class="o">(</span><span class="n">general_linear_group</span> <span class="n">F</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">F</span><span class="o">))</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">dimension</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">linear_representation</span><span class="o">)</span> <span class="o">:=</span> <span class="n">vector_space</span><span class="bp">.</span><span class="n">dim</span> <span class="n">V</span>
</pre></div>

<a name="190641409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641409" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641409">Patrick Massot (Mar 15 2020 at 10:45)</a>:</h4>
<p>Have a look at <code>#check linear_representation</code></p>

<a name="190641447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641447">Patrick Massot (Mar 15 2020 at 10:46)</a>:</h4>
<p>Maybe you don't quite understand how <code>variable</code> works yet.</p>

<a name="190641510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641510">Patrick Massot (Mar 15 2020 at 10:48)</a>:</h4>
<p>Also try <code>#check @linear_representation</code>, and try to think about what is <code>V</code> at the very end of your code, and how it relates to <code>p</code>.</p>

<a name="190641511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641511">Patrick Stevens (Mar 15 2020 at 10:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190641447" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190641447">said</a>:</p>
<blockquote>
<p>Maybe you don't quite understand how <code>variable</code> works yet.</p>
</blockquote>
<p>Ah right - again, I've been misled by Agda, which tends to do this via parameterised modules</p>

<a name="190641522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641522">Patrick Massot (Mar 15 2020 at 10:49)</a>:</h4>
<p>There is also a problem which is completely independent of language differences.</p>

<a name="190641531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641531">Patrick Massot (Mar 15 2020 at 10:49)</a>:</h4>
<p>Your <code>V</code> in the body of the definition has no relation whatsoever with <code>p</code>.</p>

<a name="190641589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641589">Patrick Massot (Mar 15 2020 at 10:50)</a>:</h4>
<p>Your <code>p</code> obviously has dimension <code>n</code> by definition.</p>

<a name="190641647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641647">Patrick Stevens (Mar 15 2020 at 10:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190641589" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190641589">said</a>:</p>
<blockquote>
<p>Your <code>p</code> obviously has dimension <code>n</code> by definition.</p>
</blockquote>
<p>You're right, I actually want the <code>n</code> from the body of <code>linear_representation</code> - but I am happy to leave questions like "have I got the definition correct" for the moment (I'll discover they're wrong as soon as I come to formulate any theorems) while I learn how to use Lean</p>

<a name="190641660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641660" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641660">Mario Carneiro (Mar 15 2020 at 10:53)</a>:</h4>
<p>You have <code>V</code> and also <code>n -&gt; F</code> as vector spaces. Which do you want?</p>

<a name="190641666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641666">Patrick Massot (Mar 15 2020 at 10:53)</a>:</h4>
<p>In case this isn't clear: Mario's question is about the same topic as mine.</p>

<a name="190641667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641667">Mario Carneiro (Mar 15 2020 at 10:53)</a>:</h4>
<p><code>linear_representation</code> has too many implicit variables</p>

<a name="190641671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641671" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641671">Patrick Stevens (Mar 15 2020 at 10:54)</a>:</h4>
<p><code>n -&gt; F</code> - but I can almost certainly work out how to do that by myself, once I've correctly passed a linear representation into <code>dimension</code>. I'll rejig it so that the right variables are explicit and then it'll probably all just fall out</p>

<a name="190641673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641673">Patrick Stevens (Mar 15 2020 at 10:54)</a>:</h4>
<p>Thanks</p>

<a name="190641711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641711">Mario Carneiro (Mar 15 2020 at 10:54)</a>:</h4>
<p>you need to make the type variables explicit, and then write e.g. <code>p : linear_representation F G V</code></p>

<a name="190641720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641720">Mario Carneiro (Mar 15 2020 at 10:54)</a>:</h4>
<p>or <code>linear_representation F G n</code> if you want that version</p>

<a name="190641729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641729">Patrick Massot (Mar 15 2020 at 10:55)</a>:</h4>
<p>That's why I wrote a bunch of <code>#check</code></p>

<a name="190641768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641768">Mario Carneiro (Mar 15 2020 at 10:56)</a>:</h4>
<p>If the definition has the form <code>linear_representation F G n</code>, then the dimension is <code>n</code>, and there is no need for a definition <code>dimension</code>. This is what patrick is saying</p>

<a name="190641776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190641776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190641776">Patrick Massot (Mar 15 2020 at 10:56)</a>:</h4>
<p>Because in this situation Lean will typically complain it cannot synthesize a term of type<code>Type u</code> without telling which implicit variable it wasn't able to synthesize and this is not easy to debug without <code>#check</code></p>

<a name="190643018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643018" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190643018">Kevin Buzzard (Mar 15 2020 at 11:36)</a>:</h4>
<p><span class="user-mention" data-user-id="117987">@Patrick Stevens</span> <code>field</code> means different things in Lean 3.4.2 (the officially sanctioned version of Lean, which is frozen, as is mathlib support) and 3.6.1 (the community version, which current mathlib compiles with). I guess I'd recommend you use 3.6.1 but I just wanted to flag this now.</p>

<a name="190643511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190643511">Kevin Buzzard (Mar 15 2020 at 11:53)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="c1">-- working with Lean 3.6.1 and current mathlib</span>
<span class="c1">-- don&#39;t need all of these imports for group_module</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">field</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">finite_dimensional</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">module</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">hom</span>

<span class="n">class</span> <span class="n">group_module</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span>
  <span class="kn">extends</span>  <span class="n">has_scalar</span> <span class="n">G</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">one_smul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span>
<span class="o">(</span><span class="n">smul_smul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span> <span class="n">h</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">,</span> <span class="n">g</span> <span class="err">•</span> <span class="o">(</span><span class="n">h</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">g</span> <span class="bp">*</span> <span class="n">h</span><span class="o">)</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span>
<span class="o">(</span><span class="n">smul_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">M</span><span class="o">,</span> <span class="n">g</span> <span class="err">•</span> <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">g</span> <span class="err">•</span> <span class="n">n</span><span class="o">)</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">one_smul</span> <span class="n">smul_smul</span> <span class="n">smul_add</span> <span class="c1">-- I think?</span>

<span class="kn">namespace</span> <span class="n">group_module</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">group_module</span> <span class="n">G</span> <span class="n">M</span><span class="o">]</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">smul_neg</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">g</span> <span class="err">•</span> <span class="o">(</span><span class="bp">-</span><span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span><span class="o">(</span><span class="n">g</span> <span class="err">•</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">smul_zero</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">g</span> <span class="err">•</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">smul_sub</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">g</span> <span class="err">•</span> <span class="o">(</span><span class="n">m</span> <span class="bp">-</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">g</span> <span class="err">•</span> <span class="n">m</span> <span class="bp">-</span> <span class="n">g</span> <span class="err">•</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">group_module</span>

<span class="c1">-- new file with more imports</span>

<span class="n">class</span> <span class="n">group_representation</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span>
  <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">F</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">group_module</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">smul_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">μ</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">V</span><span class="o">),</span> <span class="n">g</span> <span class="err">•</span> <span class="o">(</span><span class="n">μ</span> <span class="err">•</span> <span class="n">v</span><span class="o">)</span> <span class="bp">=</span> <span class="n">μ</span> <span class="err">•</span> <span class="o">(</span><span class="n">g</span> <span class="err">•</span> <span class="n">v</span><span class="o">)</span> <span class="o">)</span>

<span class="kn">namespace</span> <span class="n">group_representation</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">F</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">group_module</span> <span class="n">G</span> <span class="n">V</span><span class="o">]</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">dim</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">group_representation</span> <span class="n">G</span> <span class="n">F</span> <span class="n">V</span><span class="o">)</span> <span class="o">:=</span> <span class="n">vector_space</span><span class="bp">.</span><span class="n">dim</span> <span class="n">V</span>

<span class="kn">end</span> <span class="n">group_representation</span>
</pre></div>


<p>There's my effort, but definitions are not my strong point.</p>

<a name="190643519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190643519">Kevin Buzzard (Mar 15 2020 at 11:53)</a>:</h4>
<p>There should really be a bunch of lemmas about <code>group_module</code> first, because this is a simpler object (no field involved)</p>

<a name="190643565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643565" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190643565">Kevin Buzzard (Mar 15 2020 at 11:54)</a>:</h4>
<p>furthermore the definitions should be in two different files really, because someone interested in group cohomology might not want to import the representation theory stuff.</p>

<a name="190643691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643691" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190643691">Patrick Stevens (Mar 15 2020 at 11:58)</a>:</h4>
<p>The following doesn't compile because "maximum class-instance resolution depth has been reached" on the last line for <code>monoid_hom</code>; presumably that means Lean can't figure out that I've specified a homomorphism, so I need to supply an instance of <code>is_monoid_hom</code> to go with the lambda-term. </p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">field</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">finite_dimensional</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">module</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">hom</span>

<span class="kn">open</span> <span class="n">linear_map</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span>

<span class="n">def</span> <span class="n">linear_representation</span>
  <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V</span><span class="o">]</span>
  <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">n</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">n</span><span class="o">]</span>
  <span class="o">:=</span>
  <span class="n">monoid_hom</span> <span class="n">G</span> <span class="o">(</span><span class="n">general_linear_group</span> <span class="n">F</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-&gt;</span> <span class="n">F</span><span class="o">))</span>

<span class="n">def</span> <span class="n">trivial_representation</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">linear_representation</span> <span class="n">F</span> <span class="n">G</span> <span class="n">F</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">monoid_hom</span><span class="bp">.</span><span class="n">of</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">general_linear_group</span><span class="bp">.</span><span class="n">of_linear_equiv</span> <span class="o">(</span><span class="n">linear_equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span> <span class="bp">-&gt;</span> <span class="n">F</span><span class="o">)))</span>
</pre></div>


<p>But my best attempt at that instance is the following, which doesn't compile ("don't know how to synthesize placeholder" on <code>general_linear_group</code>):</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">identity_is_hom</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_monoid_hom</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">general_linear_group</span><span class="bp">.</span><span class="n">of_linear_equiv</span> <span class="o">(</span><span class="n">linear_equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span> <span class="bp">-&gt;</span> <span class="n">F</span><span class="o">))</span>
<span class="k">by</span> <span class="n">sorry</span>
</pre></div>


<p>This problem persists even if I supply <code>F</code> as well (i.e. prepend the arguments <code>(F : Type*) [discrete_field F]</code> to <code>identity_is_hom</code>). It's not clear to me that I can supply any more information to Lean here; what have I missed?</p>

<a name="190643708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190643708">Patrick Stevens (Mar 15 2020 at 11:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643519" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643519">said</a>:</p>
<blockquote>
<p>There should really be a bunch of lemmas about <code>group_module</code> first, because this is a simpler object (no field involved)</p>
</blockquote>
<p>Fair enough - I'm using this more as a "learn Lean" exercise than a "produce something to go into mathlib" at the moment, so am happy just playing around with the definitions at the moment</p>

<a name="190643758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190643758">Kevin Buzzard (Mar 15 2020 at 12:00)</a>:</h4>
<p>OK I'll take a look at your version.</p>

<a name="190643826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190643826">Kevin Buzzard (Mar 15 2020 at 12:02)</a>:</h4>
<p>Which version of Lean are you using?</p>

<a name="190643894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190643894">Kevin Buzzard (Mar 15 2020 at 12:05)</a>:</h4>
<p>Your def of <code>linear_representation</code> has a V as an input which is never used</p>

<a name="190643899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190643899">Patrick Stevens (Mar 15 2020 at 12:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643826" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643826">said</a>:</p>
<blockquote>
<p>Which version of Lean are you using?</p>
</blockquote>
<p>leanprover-community/lean:3.5.1, according to my <code>leanpkg.toml</code></p>

<a name="190643945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190643945">Kevin Buzzard (Mar 15 2020 at 12:06)</a>:</h4>
<p>You should probably upgrade because I just noticed that it's a pain to look at your code because of all this deprecated <code>discrete_field</code> stuff. There will be a painless way to do it with <code>leanproject</code> I suspect.</p>

<a name="190643949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643949" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190643949">Patrick Stevens (Mar 15 2020 at 12:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643945" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643945">said</a>:</p>
<blockquote>
<p>You should probably upgrade because I just noticed that it's a pain to look at your code because of all this deprecated <code>discrete_field</code> stuff. There will be a painless way to do it with <code>leanproject</code> I suspect.</p>
</blockquote>
<p>OK, thanks - I'll do that before anything else</p>

<a name="190643952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190643952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190643952">Kevin Buzzard (Mar 15 2020 at 12:06)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> what do you think of my version by the way? Once we have the definitions right the lemmas should be fun, but the definitions are a minefield.</p>

<a name="190644083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644083">Mario Carneiro (Mar 15 2020 at 12:11)</a>:</h4>
<p>I think it should be a monoid rather than a group</p>

<a name="190644089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644089">Mario Carneiro (Mar 15 2020 at 12:11)</a>:</h4>
<p>it also looks suspiciously like a group action</p>

<a name="190644090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644090">Patrick Stevens (Mar 15 2020 at 12:11)</a>:</h4>
<p>It <em>is</em> a group action</p>

<a name="190644091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644091">Kevin Buzzard (Mar 15 2020 at 12:11)</a>:</h4>
<p>A group module is a group action by module homs</p>

<a name="190644096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644096">Kevin Buzzard (Mar 15 2020 at 12:11)</a>:</h4>
<p>Mario is pointing out that it could extend group actions</p>

<a name="190644135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644135">Kevin Buzzard (Mar 15 2020 at 12:12)</a>:</h4>
<p>(then you get a bunch of theorems for free)</p>

<a name="190644157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644157">Mario Carneiro (Mar 15 2020 at 12:13)</a>:</h4>
<p>You also get a bunch of theorems for free if you don't define this at all and use the high level characterization instead</p>

<a name="190644259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644259">Kevin Buzzard (Mar 15 2020 at 12:14)</a>:</h4>
<p>I'm not sure what you mean, but whatever you mean I suspect people will want this in practice.</p>

<a name="190644262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644262">Mario Carneiro (Mar 15 2020 at 12:14)</a>:</h4>
<p>Don't you get all this if you just say <code>linear_representation := G -&gt;* units (V -&gt;l[F] V)</code>?</p>

<a name="190644267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644267" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644267">Kevin Buzzard (Mar 15 2020 at 12:14)</a>:</h4>
<p>Yes absolutely</p>

<a name="190644304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644304">Mario Carneiro (Mar 15 2020 at 12:15)</a>:</h4>
<p>it's not clear to me what the tradeoffs are here</p>

<a name="190644305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644305">Kevin Buzzard (Mar 15 2020 at 12:15)</a>:</h4>
<p>Is that a high-level characterisation? There is another one -- there's a ring <code>G -&gt;_0 F</code> called the group ring, and a group representation is the same thing as a module over that ring</p>

<a name="190644342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644342">Mario Carneiro (Mar 15 2020 at 12:16)</a>:</h4>
<p>sure, any of those sound good to me</p>

<a name="190644344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644344">Mario Carneiro (Mar 15 2020 at 12:16)</a>:</h4>
<p>they are already very compact</p>

<a name="190644351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644351">Kevin Buzzard (Mar 15 2020 at 12:16)</a>:</h4>
<p>You're a computer scientist so can see advantages in the compactness</p>

<a name="190644353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644353">Kevin Buzzard (Mar 15 2020 at 12:16)</a>:</h4>
<p>It's less clear to me</p>

<a name="190644401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644401">Mario Carneiro (Mar 15 2020 at 12:16)</a>:</h4>
<p>Isn't this usually how the mathematicians do it?</p>

<a name="190644403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644403">Kevin Buzzard (Mar 15 2020 at 12:16)</a>:</h4>
<p>I would prefer clarity</p>

<a name="190644418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644418">Mario Carneiro (Mar 15 2020 at 12:17)</a>:</h4>
<p>I feel like we've swapped sides of this argument</p>

<a name="190644421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644421" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644421">Kevin Buzzard (Mar 15 2020 at 12:17)</a>:</h4>
<p>If you define it as a module over the group ring then all of a sudden you don't have <code>g \bub v</code> you have <code>\u g \bub v</code> etc</p>

<a name="190644424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644424">Kevin Buzzard (Mar 15 2020 at 12:17)</a>:</h4>
<p>and these invisible functions can cause confusion, make rewriting harder etc</p>

<a name="190644466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644466">Mario Carneiro (Mar 15 2020 at 12:18)</a>:</h4>
<p>remind me who is playing the role of the CS guy again</p>

<a name="190644471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644471">Kevin Buzzard (Mar 15 2020 at 12:18)</a>:</h4>
<p>With your approach there are coercions to fun etc, whereas sometimes <code>g \bub v</code> is just the thing you want.</p>

<a name="190644476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644476">Kevin Buzzard (Mar 15 2020 at 12:19)</a>:</h4>
<p>My understanding here is that there is no perfect solution.</p>

<a name="190644478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644478" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644478">Mario Carneiro (Mar 15 2020 at 12:19)</a>:</h4>
<p>That's certainly going to be the case</p>

<a name="190644480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644480">Kevin Buzzard (Mar 15 2020 at 12:19)</a>:</h4>
<p>how about you CS guys make the system we want then ;-)</p>

<a name="190644484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644484" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644484">Mario Carneiro (Mar 15 2020 at 12:19)</a>:</h4>
<p>Like I said, there is a tradeoff here and I don't have a good grasp of it</p>

<a name="190644530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644530">Kevin Buzzard (Mar 15 2020 at 12:20)</a>:</h4>
<p>because you don't know what mathematicians actually use group representations for. This is why we need the area to get bigger, we need people who are experts at everything at once.</p>

<a name="190644594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644594">Kevin Buzzard (Mar 15 2020 at 12:21)</a>:</h4>
<p>Mathematicians just invoke the invisible function machine and pass seamlessly from one concept to the other</p>

<a name="190644595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644595" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644595">Mario Carneiro (Mar 15 2020 at 12:21)</a>:</h4>
<p>I have already argued that DTT is the problem but you're already bought in so ¯\_(ツ)_/¯</p>

<a name="190644596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644596">Kevin Buzzard (Mar 15 2020 at 12:21)</a>:</h4>
<p>and we don't check the diagrams commute because this is trivial</p>

<a name="190644604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644604" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644604">Mario Carneiro (Mar 15 2020 at 12:21)</a>:</h4>
<p>in set theory it really is that easy to pass between representations</p>

<a name="190644653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644653">Kevin Buzzard (Mar 15 2020 at 12:21)</a>:</h4>
<p>I'm not going back to assembly language now</p>

<a name="190644718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644718">Mario Carneiro (Mar 15 2020 at 12:22)</a>:</h4>
<p>to use a rust analogy, I don't want assembly language, I want <code>unsafe</code> blocks</p>

<a name="190644770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644770">Kevin Buzzard (Mar 15 2020 at 12:24)</a>:</h4>
<p>You lost me :-/ but I'm happy to hear more.</p>

<a name="190644781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644781">Mario Carneiro (Mar 15 2020 at 12:24)</a>:</h4>
<p>I want the ability to get around the type system without it getting mad at me forever</p>

<a name="190644786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644786" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644786">Mario Carneiro (Mar 15 2020 at 12:24)</a>:</h4>
<p>In set theory if <code>x \in A</code> and <code>A = B</code> then <code>x \in B</code></p>

<a name="190644792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644792">Mario Carneiro (Mar 15 2020 at 12:25)</a>:</h4>
<p>in type theory this will cause the proof assistant to hate you forever</p>

<a name="190644805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644805" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644805">Kevin Buzzard (Mar 15 2020 at 12:25)</a>:</h4>
<p><span class="user-mention" data-user-id="117987">@Patrick Stevens</span> the problem with your code, I guess, is that you've defined a function <code>j</code> from G to <code>general_linear_group F (fin 1 → F)</code> but Lean has no particular reason to know that this function has the property that <code>j(g*h)=j(g)*j(h)</code>.</p>

<a name="190644875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644875">Kevin Buzzard (Mar 15 2020 at 12:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190644792" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190644792">said</a>:</p>
<blockquote>
<p>in type theory this will cause the proof assistant to hate you forever</p>
</blockquote>
<p>In type theory we have to insert an invisible coercion from A to B and then coerce x over.</p>

<a name="190644909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644909">Mario Carneiro (Mar 15 2020 at 12:26)</a>:</h4>
<p>it's not invisible</p>

<a name="190644912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644912" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644912">Mario Carneiro (Mar 15 2020 at 12:26)</a>:</h4>
<p>I wish it was</p>

<a name="190644918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644918">Mario Carneiro (Mar 15 2020 at 12:27)</a>:</h4>
<p>we try very hard to make it not too annoying with mixed success</p>

<a name="190644922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644922">Kevin Buzzard (Mar 15 2020 at 12:27)</a>:</h4>
<p>Sure -- I just meant "invisible to mathematicians"</p>

<a name="190644973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190644973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190644973">Kevin Buzzard (Mar 15 2020 at 12:27)</a>:</h4>
<p>and we have a rather liberal notion of <code>=</code></p>

<a name="190645022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645022">Mario Carneiro (Mar 15 2020 at 12:28)</a>:</h4>
<p>I think that lean is a great system, probably the best among all systems I know at the user experience. I also think that this property has almost nothing to do with the fact that it implements DTT</p>

<a name="190645030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645030">Kevin Buzzard (Mar 15 2020 at 12:29)</a>:</h4>
<p>We understand the concept of an equivalence of categories, but all these structures on one vector space V (a linear action of a group, a group hom to the automorphisms, a module for the group ring) are all equal because they are simply different ways of packing up precisely the same information. They are a tedious implementation issue which we cunningly avoid by seamlessly changing our implementation decisions mid-proof.</p>

<a name="190645106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645106">Mario Carneiro (Mar 15 2020 at 12:30)</a>:</h4>
<p>in lean, we can do this with equivs of various kinds, and maybe this will eventually be packed into some category machinery</p>

<a name="190645116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645116">Mario Carneiro (Mar 15 2020 at 12:31)</a>:</h4>
<p>but I do think it is essential to be able to do concrete work in any of those representations</p>

<a name="190645117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645117">Kevin Buzzard (Mar 15 2020 at 12:31)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">monoid_hom</span><span class="bp">.</span><span class="n">of</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">monoid_hom.of :</span>
<span class="cm">  Π {M : Type u_3} {N : Type u_4} [mM : monoid M] [mN : monoid N] (f : M → N) [h : is_monoid_hom f], M →* N</span>
<span class="cm">-/</span>
</pre></div>


<p>Patrick -- this definition of <code>monoid_hom.of</code> says "you give me a map <code>f</code> and I will then use type class inference to find a term <code>h</code> of type <code>is_monoid_hom f</code>. Once I've found it I'll give you back a monoid homomorphism (which is essentially the pair consisting of f and h).</p>

<a name="190645122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645122">Patrick Stevens (Mar 15 2020 at 12:31)</a>:</h4>
<p>Yep, I'd got that far - I'm struggling to construct that term though</p>

<a name="190645123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645123">Kevin Buzzard (Mar 15 2020 at 12:31)</a>:</h4>
<p>The type class inference system is a bunch of lemmas of the form "a ring homomorphism is a monoid homomorphism" etc.</p>

<a name="190645216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645216">Patrick Stevens (Mar 15 2020 at 12:32)</a>:</h4>
<p>The following doesn't compile, for example, because "don't know how to synthesize placeholder" at <code>general_linear_group</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">identity_is_hom</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_monoid_hom</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="n">general_linear_group</span><span class="bp">.</span><span class="n">of_linear_equiv</span> <span class="o">(</span><span class="n">linear_equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span> <span class="bp">-&gt;</span> <span class="n">F</span><span class="o">)))</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">sorry</span>
</pre></div>

<a name="190645267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645267" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645267">Kevin Buzzard (Mar 15 2020 at 12:34)</a>:</h4>
<p>It will probably know that <code>general_linear_group X Y</code> is a group and hence a monoid but it won't know that your map is a monoid hom.</p>

<a name="190645273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645273" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645273">Kevin Buzzard (Mar 15 2020 at 12:34)</a>:</h4>
<p>The issue with the synthesizing placeholder will be that Lean can't figure out which ring you're working over.</p>

<a name="190645276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645276" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645276">Patrick Stevens (Mar 15 2020 at 12:34)</a>:</h4>
<p>I was hoping to tell it this was a hom, in the bit where I currently have <code>sorry</code></p>

<a name="190645288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645288">Kevin Buzzard (Mar 15 2020 at 12:35)</a>:</h4>
<p>Before the sorry Lean is failing to elaborate the term.</p>

<a name="190645290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645290">Kevin Buzzard (Mar 15 2020 at 12:35)</a>:</h4>
<p>It can't figure out the type of <code>linear_equiv.refl (fin 1 -&gt; F)</code></p>

<a name="190645334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645334" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645334">Kevin Buzzard (Mar 15 2020 at 12:36)</a>:</h4>
<p>The type is that <code>(fin 1 -&gt; F)</code> is isomorphic to itself as a module over...some metavariable.</p>

<a name="190645345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645345">Kevin Buzzard (Mar 15 2020 at 12:37)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">identity_is_hom</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">is_monoid_hom</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="bp">@</span><span class="n">general_linear_group</span><span class="bp">.</span><span class="n">of_linear_equiv</span> <span class="n">F</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">linear_equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span> <span class="bp">-&gt;</span> <span class="n">F</span><span class="o">)))</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">sorry</span>
</pre></div>

<a name="190645454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645454">Kevin Buzzard (Mar 15 2020 at 12:39)</a>:</h4>
<p>The variable inputs in <code>{}</code> brackets are ones which are supposed to be inferred by unification, but we're claiming that the identity map <code>fin 1 -&gt; F</code> is R-linear where R is a ring acting on <code>fin 1 -&gt; F</code> and we give no indication as to what this ring is. Whatever R is, this theorem is still true. My gut feeling is that your problem has come from a possibly questionable design decision to make the R input implicit.</p>

<a name="190645461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645461">Patrick Stevens (Mar 15 2020 at 12:39)</a>:</h4>
<p>Ooh, yuck - thanks; in Agda you can supply any particular implicit variable, like <code>f {A = B} arg1 {C = C} arg2</code> where <code>A</code> and <code>C</code> were implicit args. It looks like in Lean you can only "make all args explicit"?</p>

<a name="190645464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645464" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645464">Kevin Buzzard (Mar 15 2020 at 12:39)</a>:</h4>
<p>PS I am now talking to you as if you were an expert. Let me know if I'm going over your head.</p>

<a name="190645496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645496">Kevin Buzzard (Mar 15 2020 at 12:40)</a>:</h4>
<p>Yes, you can make all args explicit or none of them! That is a really cool agda thing, I wish we had that in Lean.</p>

<a name="190645512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645512">Patrick Stevens (Mar 15 2020 at 12:40)</a>:</h4>
<p>Yep, I see what you mean</p>

<a name="190645513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645513">Kevin Buzzard (Mar 15 2020 at 12:40)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> can you just pop that into 3.7.2 for us?</p>

<a name="190645533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645533" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645533">Mario Carneiro (Mar 15 2020 at 12:41)</a>:</h4>
<p>there is a concrete syntax for this in lean 4 but I forget what it is</p>

<a name="190645582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645582">Mario Carneiro (Mar 15 2020 at 12:42)</a>:</h4>
<p>if we used that notation it would get confused with passing a singleton of an equality to <code>f</code></p>

<a name="190645587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645587" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645587">Kevin Buzzard (Mar 15 2020 at 12:43)</a>:</h4>
<p>MS should employ an intern who gets an email whenever an issue like this comes up, and solves it manually</p>

<a name="190645593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645593">Kevin Buzzard (Mar 15 2020 at 12:43)</a>:</h4>
<p>Oh here's a better idea -- just use a new kind of bracket.</p>

<a name="190645602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645602">Mario Carneiro (Mar 15 2020 at 12:43)</a>:</h4>
<p>Even if it did exist, the name of the argument could only possibly be the name of the binder, and typeclass args always have ugly names like <code>_inst_1</code></p>

<a name="190645603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645603">Kevin Buzzard (Mar 15 2020 at 12:43)</a>:</h4>
<p>Why are we using <code>{}</code> for both implicit variable and set notation anyway?</p>

<a name="190645697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645697">Kevin Buzzard (Mar 15 2020 at 12:44)</a>:</h4>
<p>Here we were missing <code>R</code> not some typeclass thing. The issue here was with unification failing, not type class inference.</p>

<a name="190645699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645699">Mario Carneiro (Mar 15 2020 at 12:44)</a>:</h4>
<p>Binders are always distinguishable because they come after binding notation tokens</p>

<a name="190645707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645707">Mario Carneiro (Mar 15 2020 at 12:44)</a>:</h4>
<p>but implicit function args are just in regular expression position</p>

<a name="190645731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645731">Kevin Buzzard (Mar 15 2020 at 12:45)</a>:</h4>
<p>Mathematicians got <code>{}</code> first for sets, you just need some wacky unicode for your implicit instances and then we're all set.</p>

<a name="190645782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645782">Mario Carneiro (Mar 15 2020 at 12:46)</a>:</h4>
<p>there is no problem with binders because they only come after <code>\lam</code> and stuff</p>

<a name="190645785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645785">Mario Carneiro (Mar 15 2020 at 12:46)</a>:</h4>
<p><code>\lam {x | x &gt; 0}</code> doesn't make any sense</p>

<a name="190645788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645788">Kevin Buzzard (Mar 15 2020 at 12:46)</a>:</h4>
<p>I don't know what a binder is. I thought that was forall etc.</p>

<a name="190645790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645790">Mario Carneiro (Mar 15 2020 at 12:46)</a>:</h4>
<p>yes</p>

<a name="190645795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645795">Mario Carneiro (Mar 15 2020 at 12:46)</a>:</h4>
<p><code>\Pi</code>, <code>\forall</code>, <code>\lam</code>, <code>\sum</code>, etc</p>

<a name="190645796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645796">Kevin Buzzard (Mar 15 2020 at 12:46)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">linear_equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_3</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_4</span><span class="o">)</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_5</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">],</span> <span class="n">M</span> <span class="err">≃ₗ</span><span class="o">[</span><span class="n">R</span><span class="o">]</span> <span class="n">M</span>
</pre></div>


<p>Should R be explicit here?</p>

<a name="190645801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645801">Mario Carneiro (Mar 15 2020 at 12:47)</a>:</h4>
<p>I think so</p>

<a name="190645802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645802" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645802">Kevin Buzzard (Mar 15 2020 at 12:47)</a>:</h4>
<p>I am confused about what binders have to do with the fact that I just had to write <code>@foo F _ _ _ _</code></p>

<a name="190645807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645807">Mario Carneiro (Mar 15 2020 at 12:47)</a>:</h4>
<p>There are no binders involved in the expression <code>@foo F _ _ _ _</code></p>

<a name="190645809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645809">Kevin Buzzard (Mar 15 2020 at 12:47)</a>:</h4>
<p>whereas I wanted to write <code>foo {R = F}</code></p>

<a name="190645855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645855">Mario Carneiro (Mar 15 2020 at 12:48)</a>:</h4>
<p>but <code>{R = F}</code> is actually a valid expression, of type <code>set Prop</code></p>

<a name="190645860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645860">Kevin Buzzard (Mar 15 2020 at 12:48)</a>:</h4>
<p>and that's why I'm saying you should keep your grubby implicit variable hands off our set notation and come up with some different bracket system.</p>

<a name="190645861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645861" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645861">Mario Carneiro (Mar 15 2020 at 12:48)</a>:</h4>
<p>which is kind of nonsense, but <code>foo</code> might nevertheless have type <code>set Prop -&gt; T</code> and then <code>foo {R = F}</code> is valid</p>

<a name="190645869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645869" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645869">Mario Carneiro (Mar 15 2020 at 12:49)</a>:</h4>
<p>Oh, if the notation is something other than <code>@foo {R = F}</code> then we're fine probably</p>

<a name="190645870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645870" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645870">Kevin Buzzard (Mar 15 2020 at 12:49)</a>:</h4>
<p>or treat us like dirt, like you usually do, and make us use different weird brackets so as to confuse the regular mathematicians</p>

<a name="190645876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645876">Mario Carneiro (Mar 15 2020 at 12:49)</a>:</h4>
<p>I mean we already have those funny unicode brackets that are a pain to type for semi implicit</p>

<a name="190645881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645881">Kevin Buzzard (Mar 15 2020 at 12:49)</a>:</h4>
<p>You wouldn't believe how many times I've been asked why <code>2 | 4</code> throw up wacky errors</p>

<a name="190645966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645966">Kevin Buzzard (Mar 15 2020 at 12:50)</a>:</h4>
<p>when it works in LaTeX</p>

<a name="190645971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645971">Mario Carneiro (Mar 15 2020 at 12:50)</a>:</h4>
<p><code>2 \mid 4</code> is the way to do it in latex</p>

<a name="190645973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190645973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190645973">Kevin Buzzard (Mar 15 2020 at 12:50)</a>:</h4>
<p>(actually it doesn't even work in LaTeX, the glue is incorrect and the user should use <code>\mid</code> ;-) )</p>

<a name="190646000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190646000">Mario Carneiro (Mar 15 2020 at 12:51)</a>:</h4>
<p>Because of the possibility of conflict, it seems pretty sensitive what notation is used for passing implicit arguments like this. I should see what lean 4 picked</p>

<a name="190646045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190646045">Mario Carneiro (Mar 15 2020 at 12:52)</a>:</h4>
<p>but yes, if it's some <code>foo {&lt;&lt;R = F&gt;&gt;}</code> thing then we're fine</p>

<a name="190646053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190646053">Mario Carneiro (Mar 15 2020 at 12:52)</a>:</h4>
<p>then again, typing that may become annoying</p>

<a name="190646056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190646056">Mario Carneiro (Mar 15 2020 at 12:53)</a>:</h4>
<p>syntax is hard</p>

<a name="190646061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190646061">Kevin Buzzard (Mar 15 2020 at 12:53)</a>:</h4>
<p>You all seem to be happy with all that &gt;=-+ monad stuff</p>

<a name="190646062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646062" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190646062">Patrick Stevens (Mar 15 2020 at 12:53)</a>:</h4>
<p>This is a feature that isn't meant to be used very often</p>

<a name="190646108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190646108">Kevin Buzzard (Mar 15 2020 at 12:54)</a>:</h4>
<p>So what you're saying is that instead of all this bracket banter I should just be making a PR changing {R} to (R)? :-)</p>

<a name="190646110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190646110">Kevin Buzzard (Mar 15 2020 at 12:54)</a>:</h4>
<p>unfortuately it won't work for 3.4.2 ;-)</p>

<a name="190646177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646177" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190646177">Kevin Buzzard (Mar 15 2020 at 12:56)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">identity_is_hom</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">is_monoid_hom</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="bp">@</span><span class="n">general_linear_group</span><span class="bp">.</span><span class="n">of_linear_equiv</span> <span class="n">F</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">linear_equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">1</span> <span class="bp">-&gt;</span> <span class="n">F</span><span class="o">)))</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_mul</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">map_one</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span>
</pre></div>


<p>is how to make the instance, in case you didn't know Lean syntax</p>

<a name="190646191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190646191" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190646191">Kevin Buzzard (Mar 15 2020 at 12:57)</a>:</h4>
<p>I got this in VS Code by writing <code>... := {! !}</code> and then clicking on the little lightbulb which appeared and selecting "create a skeleton"</p>

<a name="190661151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190661151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190661151">Patrick Stevens (Mar 15 2020 at 18:44)</a>:</h4>
<p>It's really hard to Google for the <code>example</code> keyword :P is it possible for me to name an example, or do I have to make it a <code>def</code> if I want to refer to it? Currently I have a definition which works, and now I want to run it through <code>#check</code> but I can't work out how to refer to it.</p>
<div class="codehilite"><pre><span></span><span class="c1">-- Trivial representation</span>
<span class="kn">example</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span> <span class="o">:</span> <span class="n">linear_representation</span> <span class="n">F</span> <span class="n">G</span> <span class="n">F</span> <span class="o">:=</span>
  <span class="o">{</span>
    <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g</span><span class="o">,</span> <span class="n">general_linear_group</span><span class="bp">.</span><span class="n">of_linear_equiv</span> <span class="o">(</span><span class="n">linear_equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="bp">_</span><span class="o">),</span>
    <span class="n">map_one&#39;</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="k">by</span>
    <span class="k">begin</span>
      <span class="n">intros</span> <span class="n">g</span> <span class="n">h</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="kn">end</span>
  <span class="o">}</span>
</pre></div>

<a name="190661478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190661478" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190661478">Daniel Keys (Mar 15 2020 at 18:51)</a>:</h4>
<p>You can try giving it a name, like so: <code>def even (n : ℤ) := 2 ∣ n</code></p>

<a name="190661482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190661482" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190661482">Patrick Stevens (Mar 15 2020 at 18:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="259186">Daniel Keys</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190661478" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190661478">said</a>:</p>
<blockquote>
<p>You can try giving it a name, like so: <code>def even (n : ℤ) := 2 ∣ n</code></p>
</blockquote>
<p>Sure, I was just wondering if I could use the <code>example</code> syntax to name an example, or whether I was forced to use <code>def</code></p>

<a name="190661543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/190661543" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#190661543">Daniel Keys (Mar 15 2020 at 18:52)</a>:</h4>
<p>I think you need to make it a lemma or theorem in order to give it a name.</p>

<a name="191337769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191337769">Patrick Stevens (Mar 21 2020 at 09:52)</a>:</h4>
<p>Here's a stupid question: I've defined some stuff, and I want to #eval it to see whether it looks right (before I start going to the effort of proving things about it). For example, I've defined the dimension of a representation, and I want to check that the dimension of a certain representation is in fact 2 when I expect it to be. But for the life of me I can't find any actual examples of groups in mathlib (and so I have nothing to pass into #eval): the cyclic groups seem not to have been defined, Q and R appear not to have been endowed with group structures, etc. Are there actually any groups anywhere? And how should I be trying to find them in mathlib?</p>

<a name="191337883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337883" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191337883">Johan Commelin (Mar 21 2020 at 09:54)</a>:</h4>
<p>Hmm... such examples are certain there.</p>

<a name="191337890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191337890">Johan Commelin (Mar 21 2020 at 09:54)</a>:</h4>
<p>Q and R are both endowed with the structure of a linearly ordered field, so in particular they are additive groups</p>

<a name="191337898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191337898">Johan Commelin (Mar 21 2020 at 09:55)</a>:</h4>
<p>But <code>#eval</code> cannot compute a dimension for you</p>

<a name="191337915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191337915">Johan Commelin (Mar 21 2020 at 09:55)</a>:</h4>
<p>(It would have to cook up a basis, etc...)</p>

<a name="191337917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191337917">Patrick Stevens (Mar 21 2020 at 09:55)</a>:</h4>
<p>My current problem is simply an inability to synthesise a typeclass instance for <code>group R</code>, for example</p>

<a name="191337919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337919" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191337919">Johan Commelin (Mar 21 2020 at 09:55)</a>:</h4>
<p>On the other hand, there is certainly a theorem in mathlib saying that <code>K^n</code> has dimension <code>n</code> over <code>K</code>.</p>

<a name="191337958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191337958">Johan Commelin (Mar 21 2020 at 09:56)</a>:</h4>
<p>Because it's not a group. It's an <code>add_group</code>.</p>

<a name="191337962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191337962">Johan Commelin (Mar 21 2020 at 09:56)</a>:</h4>
<p>This is very unfortunate.</p>

<a name="191337971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191337971">Patrick Stevens (Mar 21 2020 at 09:56)</a>:</h4>
<p>Oh, that's very upsetting</p>

<a name="191337973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191337973">Johan Commelin (Mar 21 2020 at 09:56)</a>:</h4>
<p>But in the current setup, we need to duplicate groups to distinguish between multiplicative and additive groups</p>

<a name="191337976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191337976">Johan Commelin (Mar 21 2020 at 09:56)</a>:</h4>
<p>If we don't do that, we cannot have nice notation.</p>

<a name="191337985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337985" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191337985">Johan Commelin (Mar 21 2020 at 09:57)</a>:</h4>
<p>On the other hand, this is mostly done completely automatically. You prove things for multiplicative groups, and you are done.</p>

<a name="191337988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337988" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191337988">Johan Commelin (Mar 21 2020 at 09:57)</a>:</h4>
<p>So you get <code>monoid R</code> and <code>add_group R</code> in your case.</p>

<a name="191337994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191337994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191337994">Patrick Stevens (Mar 21 2020 at 09:57)</a>:</h4>
<p>So it's just a matter of taste whether you want to use <code>add_group</code> or <code>group</code> in a particular theory?</p>

<a name="191338048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191338048">Johan Commelin (Mar 21 2020 at 09:59)</a>:</h4>
<p>Well, mostly yes.</p>

<a name="191338057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338057" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191338057">Johan Commelin (Mar 21 2020 at 10:00)</a>:</h4>
<p>But the machinery can turn generate an additive version of a multiplicative definition/theorem, but not the other way round.</p>

<a name="191338100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191338100">Johan Commelin (Mar 21 2020 at 10:00)</a>:</h4>
<p>So all the generalities are developed using multiplicative notation.</p>

<a name="191338110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191338110">Johan Commelin (Mar 21 2020 at 10:00)</a>:</h4>
<p>But stuff like modules and representations assumes additive groups</p>

<a name="191338131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191338131">Patrick Stevens (Mar 21 2020 at 10:01)</a>:</h4>
<p>Was that a mistake? Should they not use the phrasing that affords more generality, i.e. multiplicative?</p>

<a name="191338362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191338362">Johan Commelin (Mar 21 2020 at 10:07)</a>:</h4>
<p>No, because of the notation.</p>

<a name="191338371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191338371">Johan Commelin (Mar 21 2020 at 10:07)</a>:</h4>
<p>If M is an R-module, you want to me able to write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>⋅</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r \cdot (x + y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> for <code>r : R</code> and <code>x y : M</code></p>

<a name="191338411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338411" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191338411">Johan Commelin (Mar 21 2020 at 10:08)</a>:</h4>
<p>I agree that it's confusing. (The mathematician in me is still unhappy about it.) But in practice it works quite well.</p>

<a name="191338424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191338424">Johan Commelin (Mar 21 2020 at 10:09)</a>:</h4>
<p>So, the magic command to make a multiplicative theorem additive is</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">to_additive</span><span class="o">]</span>
<span class="kn">theorem</span> <span class="n">my_multiplicative_thm</span> <span class="bp">...</span>
</pre></div>

<a name="191338432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191338432">Johan Commelin (Mar 21 2020 at 10:09)</a>:</h4>
<p>Besides that, if <code>G</code> is a <code>group</code>, then <code>additive G</code> is an <code>add_group</code>. (The only thing this does is switch notation.)<br>
Analogously <code>multiplicative A</code> turns an additive group into a multiplicative one.</p>

<a name="191338476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191338476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191338476">Johan Commelin (Mar 21 2020 at 10:10)</a>:</h4>
<p>Together, this gives a system that's quite flexible, and has nice notation.</p>

<a name="191340607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191340607" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191340607">Patrick Stevens (Mar 21 2020 at 11:09)</a>:</h4>
<p>The following code doesn't compile because I haven't defined a relation: the type is not X -&gt; X -&gt; Prop because the type of <code>is_isomorphic</code> here is <code>linear_representation _ _ V1 -&gt; linear_representation _ _ V2 -&gt; Prop</code>. I could solve this by splitting the definition into two: <code>linear_representation_over_a_specific_vector_space</code> (name TBD), and convert <code>linear_representation</code> to being instead a dependent pair of (vector space, representation on that vector space), but this seems a little sad. Can anyone see anything nicer I could do?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">field</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">finite_dimensional</span>
<span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">module</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span><span class="bp">.</span><span class="n">hom</span>

<span class="kn">open</span> <span class="n">linear_map</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">[</span><span class="n">field</span> <span class="n">F</span><span class="o">]</span>

<span class="n">def</span> <span class="n">linear_representation</span>
  <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V</span><span class="o">]</span>
  <span class="o">:=</span>
  <span class="n">monoid_hom</span> <span class="n">G</span> <span class="o">(</span><span class="n">general_linear_group</span> <span class="n">F</span> <span class="n">V</span><span class="o">)</span>

<span class="c1">-- is_intertwining_map is the same as &quot;being a G-homomorphism&quot;</span>
<span class="n">def</span> <span class="n">is_intertwining_map</span>
  <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V1</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V1</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V1</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V2</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V2</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V2</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">linear_representation</span> <span class="n">F</span> <span class="n">G</span> <span class="n">V1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">linear_representation</span> <span class="n">F</span> <span class="n">G</span> <span class="n">V2</span><span class="o">)</span>
  <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">linear_map</span> <span class="n">F</span> <span class="n">V1</span> <span class="n">V2</span><span class="o">)</span>
  <span class="o">:=</span>
  <span class="bp">∀</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">V1</span><span class="o">),</span>
    <span class="n">linear_map</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">φ</span> <span class="o">(</span><span class="n">units</span><span class="bp">.</span><span class="n">val</span> <span class="o">(</span><span class="n">monoid_hom</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">p1</span> <span class="n">g</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">units</span><span class="bp">.</span><span class="n">val</span> <span class="o">(</span><span class="n">monoid_hom</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">p2</span> <span class="n">g</span><span class="o">))</span> <span class="o">(</span><span class="n">linear_map</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">φ</span> <span class="n">x</span><span class="o">)</span>

<span class="n">def</span> <span class="n">is_isomorphism</span>
  <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V1</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V1</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V1</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V2</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V2</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V2</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">linear_representation</span> <span class="n">F</span> <span class="n">G</span> <span class="n">V1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">linear_representation</span> <span class="n">F</span> <span class="n">G</span> <span class="n">V2</span><span class="o">)</span>
  <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">linear_map</span> <span class="n">F</span> <span class="n">V1</span> <span class="n">V2</span><span class="o">)</span>
  <span class="o">:=</span>
  <span class="n">is_intertwining_map</span> <span class="n">F</span> <span class="n">p1</span> <span class="n">p2</span> <span class="n">φ</span> <span class="bp">∧</span> <span class="n">function</span><span class="bp">.</span><span class="n">bijective</span> <span class="o">(</span><span class="n">linear_map</span><span class="bp">.</span><span class="n">to_fun</span> <span class="n">φ</span><span class="o">)</span>

<span class="n">def</span> <span class="n">is_isomorphic</span>
  <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V1</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V1</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V1</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V2</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V2</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V2</span><span class="o">]</span>
  <span class="o">(</span><span class="n">p1</span> <span class="o">:</span> <span class="n">linear_representation</span> <span class="n">F</span> <span class="n">G</span> <span class="n">V1</span><span class="o">)</span>
  <span class="o">(</span><span class="n">p2</span> <span class="o">:</span> <span class="n">linear_representation</span> <span class="n">F</span> <span class="n">G</span> <span class="n">V2</span><span class="o">)</span>
  <span class="o">:=</span>
  <span class="bp">∃</span> <span class="n">φ</span><span class="o">,</span> <span class="n">is_isomorphism</span> <span class="n">F</span> <span class="n">p1</span> <span class="n">p2</span> <span class="n">φ</span>

<span class="kn">lemma</span> <span class="n">isomorphism_rel_is_reflexive</span>
  <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">group</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V1</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V1</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V1</span><span class="o">]</span>
  <span class="o">{</span><span class="n">V2</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">V2</span><span class="o">]</span> <span class="o">[</span><span class="n">vector_space</span> <span class="n">F</span> <span class="n">V2</span><span class="o">]</span>
  <span class="o">:</span> <span class="n">reflexive</span> <span class="o">(</span><span class="bp">@</span><span class="n">is_isomorphic</span> <span class="n">F</span> <span class="bp">_</span> <span class="n">G</span> <span class="bp">_</span> <span class="n">V1</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">V2</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="c1">-- doesn&#39;t compile</span>
  <span class="o">:=</span>
<span class="k">by</span> <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="191342638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191342638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191342638">Patrick Stevens (Mar 21 2020 at 12:06)</a>:</h4>
<p>I restructured in that way and it does work, of course, although it's a bit gross</p>

<a name="191345620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191345620" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191345620">Mario Carneiro (Mar 21 2020 at 13:26)</a>:</h4>
<p>An example of an actual <code>group</code> in mathlib would be <code>units</code>. For example <code>units (zmod 42)</code> is an interesting, nontrivial and computable finite multiplicative group</p>

<a name="191345780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191345780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191345780">Kevin Buzzard (Mar 21 2020 at 13:31)</a>:</h4>
<p>The way this would be usually done in mathlib is that first you define a bunded <code>intertwining_map</code>, and then you would define the identity intertwining map, and a composition of intertwining maps, and you would define an isomorphism to be an intertwining map with an inverse. I don't think I understand your question about reflexive. Surely the assertion that the relation is reflexive is that V1 is isomorphic to V1, I don't see the role of V2.</p>

<a name="191345843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191345843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191345843">Kevin Buzzard (Mar 21 2020 at 13:33)</a>:</h4>
<p>But here you don't really want to use equivalence relations anyway, because they lose track of data. A mathematician would say "if V1 is isomorphic to V2 then V2 is isomorphic to V1" but this is less than what they mean. They <em>mean</em> "if you have an isomorphism V1 -&gt; V2 then I can give you an isomorphism V2 -&gt; V1, namely its inverse", and you would to well to capture this stronger statement.</p>

<a name="191346036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191346036" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191346036">Kevin Buzzard (Mar 21 2020 at 13:38)</a>:</h4>
<p>You should look at how it is set up for modules. Because a group representation is just a module for the group ring, you are just re-doing that theory anyway. <a href="https://github.com/leanprover-community/mathlib/blob/dd85db0cc7b5d0849f6f75535e109fa3d6f7ac56/src/algebra/module.lean#L165" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/dd85db0cc7b5d0849f6f75535e109fa3d6f7ac56/src/algebra/module.lean#L165">Here are module homomorphisms in mathlib</a>. Instead of making the predicate on a homomorphism of additive abelian groups, they bundle everything up in a structure and then define <code>id</code> and <code>comp</code> -- these are the fundamental things you need to make everything into a category.</p>

<a name="191346259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191346259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191346259">Kevin Buzzard (Mar 21 2020 at 13:44)</a>:</h4>
<p>The reason that you don't see statements such as isomorphism being reflexive, symmetric etc is that everything like that is already done in some huge generality in <a href="https://github.com/leanprover-community/mathlib/blob/dd85db0cc7b5d0849f6f75535e109fa3d6f7ac56/src/data/equiv/mul_add.lean#L73" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/dd85db0cc7b5d0849f6f75535e109fa3d6f7ac56/src/data/equiv/mul_add.lean#L73">files like this</a>. This is a definition, not a theorem, it's the construction of the identity map and the proof that it preserves multiplication on any type with a multiplication. This is some abstract theory of "mul-equiv"s, which means bijections between two sets X and Y with multiplication, such that the bijection preserves the multiplication. Things like that get set up in huge generality and then the idea is that it will apply to your situation if you need it.</p>

<a name="191346602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191346602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191346602">Patrick Stevens (Mar 21 2020 at 13:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191345843" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191345843">said</a>:</p>
<blockquote>
<p>But here you don't really want to use equivalence relations anyway, because they lose track of data. A mathematician would say "if V1 is isomorphic to V2 then V2 is isomorphic to V1" but this is less than what they mean. They <em>mean</em> "if you have an isomorphism V1 -&gt; V2 then I can give you an isomorphism V2 -&gt; V1, namely its inverse", and you would to well to capture this stronger statement.</p>
</blockquote>
<p>Ah, again this is a habit imported from Agda, where to say that A is iso to B is to exhibit an isomorphism</p>

<a name="191346649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191346649" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191346649">Patrick Stevens (Mar 21 2020 at 13:52)</a>:</h4>
<p>There is an <em>awful</em> lot to unlearn here :P</p>

<a name="191346687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191346687" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191346687">Johan Commelin (Mar 21 2020 at 13:53)</a>:</h4>
<p>In Lean, you say that A and B are <code>equiv</code>, which is also an explicit iso.</p>

<a name="191347345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191347345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191347345">Kevin Buzzard (Mar 21 2020 at 14:08)</a>:</h4>
<p><span class="user-mention" data-user-id="117987">@Patrick Stevens</span> your definition of <code>is_isomorphism</code> is a <code>Prop</code>, so when you prove  the isomorphism you'll have to exhibit the map, but the moment the proof has compiled the map will be forgotten, because Lean's Prop is...umm..I think it's called impredicative.</p>

<a name="191347512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191347512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191347512">Patrick Stevens (Mar 21 2020 at 14:12)</a>:</h4>
<p>Fair enough - I just need to get much more clear about what is constructive and what isn't</p>

<a name="191348417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348417" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191348417">Patrick Massot (Mar 21 2020 at 14:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191347345" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191347345">said</a>:</p>
<blockquote>
<p>because Lean's Prop is...umm..I think it's called impredicative.</p>
</blockquote>
<p>No, that's not what impredicative means. <a href="https://en.wikipedia.org/wiki/Impredicativity" target="_blank" title="https://en.wikipedia.org/wiki/Impredicativity">https://en.wikipedia.org/wiki/Impredicativity</a></p>

<a name="191348469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348469" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191348469">Kevin Buzzard (Mar 21 2020 at 14:34)</a>:</h4>
<p>well, Lean's prop is forgetful</p>

<a name="191348483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348483" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191348483">Mario Carneiro (Mar 21 2020 at 14:34)</a>:</h4>
<p>that would be proof irrelevance</p>

<a name="191348486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191348486">Kevin Buzzard (Mar 21 2020 at 14:34)</a>:</h4>
<blockquote>
<p>There is no generally accepted precise definition of what it means to be predicative or impredicative</p>
</blockquote>

<a name="191348489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191348489">Kevin Buzzard (Mar 21 2020 at 14:34)</a>:</h4>
<p>that's the last time I'm using that word. It's as bad as canonical.</p>

<a name="191348491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191348491">Mario Carneiro (Mar 21 2020 at 14:34)</a>:</h4>
<p>we can say that Prop is a proof irrelevant universe</p>

<a name="191348559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348559" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191348559">Mario Carneiro (Mar 21 2020 at 14:36)</a>:</h4>
<p>I don't think I agree with the wikipedia statement. The meaning of impredicativity is context dependent but precise in most places where it appears</p>

<a name="191348594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191348594">Mario Carneiro (Mar 21 2020 at 14:37)</a>:</h4>
<p>Almost all the uses you are likely to have seen are using the same meaning. Alternate meanings are mostly historical and philosophical uses like avoiding self reference in the liar's paradox</p>

<a name="191348668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191348668">Patrick Massot (Mar 21 2020 at 14:39)</a>:</h4>
<p>And this meaning is somehow orthogonal to proof irrelevance, right?</p>

<a name="191348749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191348749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191348749">Mario Carneiro (Mar 21 2020 at 14:40)</a>:</h4>
<p>they are related by a paradox that makes one of the possible permutations inconsistent</p>

<a name="191361408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191361408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191361408">Scott Morrison (Mar 21 2020 at 19:10)</a>:</h4>
<p><span class="user-mention" data-user-id="117987">@Patrick Stevens</span> , could you have a look at <a href="https://github.com/leanprover-community/mathlib/issues/2121" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/2121">#2121</a>, as a "rather bundled" suggestion for the basics of representation theory?</p>

<a name="191375384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Representation%20Theory/near/191375384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/30735RepresentationTheory.html#191375384">Alex J. Best (Mar 22 2020 at 02:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191345620" title="#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191345620">said</a>:</p>
<blockquote>
<p>An example of an actual <code>group</code> in mathlib would be <code>units</code>. For example <code>units (zmod 42)</code> is an interesting, nontrivial and computable finite multiplicative group</p>
</blockquote>
<p>You can also do <code>units</code> of a general linear group to get some fun non-abelian computable groups.</p>


{% endraw %}

{% include archive_update.html %}