---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/83565Type.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html">Type*</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="184686187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184686187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184686187">Enrico Borba (Jan 02 2020 at 21:33)</a>:</h4>
<p>Hi, thank you all for the awesome work done on Lean. I have been messing with it for the past month or so, and I'm absolutely amazed by it. Quick question: what does <code>Type*</code> mean? I haven't encountered an asterisk like that before, and first encountered it when reading Logic and Proof after doing all of the exercises in TPiL.</p>

<a name="184686474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184686474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184686474">Chris Hughes (Jan 02 2020 at 21:36)</a>:</h4>
<p>It usually means <code>Type u</code> where <code>u</code> is a universe variable. Basically it lets Lean choose the universe, and it usually chooses the most polymorphic option.</p>

<a name="184686544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184686544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184686544">Enrico Borba (Jan 02 2020 at 21:37)</a>:</h4>
<p>Oh interesting. Is this a more general notation that can be used elsewhere or is it specific to being a placeholder for universes?</p>

<a name="184689349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184689349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184689349">Chris Hughes (Jan 02 2020 at 22:24)</a>:</h4>
<p>I think it's just <code>Type*</code> and <code>Sort*</code>. I think <code>Type*</code> might be the same as <code>Type _</code> and underscores can be used in a lot of places</p>

<a name="184715911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184715911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184715911">Mukesh Tiwari (Jan 03 2020 at 07:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span>  Does this means that if I don't want to go through the universe details, then I can use Type * or Type _ ?</p>

<a name="184718394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184718394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184718394">Chris Hughes (Jan 03 2020 at 08:40)</a>:</h4>
<p>Yes. <code>Type*</code> is what is used most of the time to avoid having to think about universes.</p>

<a name="184828115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184828115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184828115">Mukesh Tiwari (Jan 05 2020 at 01:35)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span>  Sorry for disturbing you, but could you please tell me that why the second one is not accepted by Lean? <br>
This is accepted by Lean:</p>
<div class="codehilite"><pre><span></span>universe u
class Associative {G : Type u} (f : G → G → G) : Type u :=
(Hassoc : ∀ x y z : G, f (f x y) z = f x (f y z))
</pre></div>


<p>But this one not:</p>
<div class="codehilite"><pre><span></span>class Associative {G : Type _} (f : G → G → G) : Type _ :=
(Hassoc : ∀ x y z : G, f (f x y) z = f x (f y z))
</pre></div>

<a name="184828333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184828333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184828333">Chris Hughes (Jan 05 2020 at 01:42)</a>:</h4>
<p>I guess I was wrong about <code>Type*</code> being the same as <code>Type _</code>. <code>Type _</code> will probably try to infer from the context what the universe should be - it will fill it in with whatever it is forced to be, and will fail if there's nothing forcing it to be a particular universe. and <code>Type*</code> will fill it in with something sensible basically. I don't know the precise algorithms.</p>

<a name="184829264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184829264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184829264">Mario Carneiro (Jan 05 2020 at 02:17)</a>:</h4>
<p>These are not the same; one uses <code>Type u</code> and the other uses <code>Type _</code>. I'm pretty sure that <code>Type*</code> and <code>Type _</code> are identical</p>

<a name="184829336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184829336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184829336">Mario Carneiro (Jan 05 2020 at 02:19)</a>:</h4>
<p>The error message makes it clear what the problem is:</p>
<div class="codehilite"><pre><span></span>failed to add declaration &#39;Associative&#39; to environment, type has metavariables
</pre></div>


<p>It successfully unified, but it wasn't completely able to pin down the target type because this is also valid:</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>
<span class="n">class</span> <span class="n">Associative</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span> <span class="bp">→</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">37</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Hassoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">(</span><span class="n">f</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span>
</pre></div>

<a name="184834481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184834481" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184834481">Mukesh Tiwari (Jan 05 2020 at 05:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  Thanks for the answer. The purpose of the question was to avoid universe hierarchy, and let Lean figured out the universe; hence, I left the return type as Type _.  If I do not mention any return type, then it is fine. </p>
<div class="codehilite"><pre><span></span>class Associative {G : Type _} (f : G → G → G) :=
(Hassoc : ∀ x y z : G, f (f x y) z = f x (f y z))

#check Associative
returns Associative : (?M_1 → ?M_1 → ?M_1) → Type
</pre></div>


<p>Coming back to my question (also because of my Coq background), if I want to avoid the universe hierarchy, then what is the best way to go?</p>

<a name="184847581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Type%2A/near/184847581" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/83565Type.html#184847581">Mario Carneiro (Jan 05 2020 at 12:45)</a>:</h4>
<p><span class="user-mention" data-user-id="239476">@Mukesh Tiwari</span> This technique almost always works, but inductive types are special because you actually have to make a choice of what universe they should live in; the target type is only lower bounded, and different choices above that lead to different types. For definitions and theorems, the universe is uniquely determined from the inputs so you can use <code>Type*</code> consistently and lean will just figure everything out.</p>


{% endraw %}

{% include archive_update.html %}