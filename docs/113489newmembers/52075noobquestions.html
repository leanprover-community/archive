---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/52075noobquestions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html">noob question(s)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="148007940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148007940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148007940">Wojciech Nawrocki (Nov 20 2018 at 00:46)</a>:</h4>
<p>What's the command to make Lean automatically derive <code>decidable_eq</code> for some custom inductive type?</p>

<a name="148007958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148007958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148007958">Chris Hughes (Nov 20 2018 at 00:47)</a>:</h4>
<p>@[derive decidable_eq]</p>

<a name="148007972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148007972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148007972">Wojciech Nawrocki (Nov 20 2018 at 00:47)</a>:</h4>
<p>ah I should've thought of that, thanks! :)</p>

<a name="148013728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148013728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148013728">Wojciech Nawrocki (Nov 20 2018 at 03:18)</a>:</h4>
<p>Hm, when I add</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">classical</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">prop_decidable</span>
</pre></div>


<p>to a file, definitions below it which used to pass now fail with:</p>
<div class="codehilite"><pre><span></span><span class="n">equation</span> <span class="n">compiler</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">generate</span> <span class="n">bytecode</span> <span class="n">for</span> <span class="err">&#39;</span><span class="n">subst</span><span class="bp">._</span><span class="n">main&#39;</span>
<span class="n">nested</span> <span class="n">exception</span> <span class="n">message</span><span class="o">:</span>
<span class="n">code</span> <span class="n">generation</span> <span class="n">failed</span><span class="o">,</span> <span class="n">VM</span> <span class="n">does</span> <span class="n">not</span> <span class="k">have</span> <span class="n">code</span> <span class="n">for</span> <span class="err">&#39;</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice&#39;</span>
</pre></div>


<p>Why might this be?</p>
<p>Is it basically because <code>classical</code> makes things uncomputable? If so, maybe Lean should detect that <code>classical</code> is not used in a particular case and still compile the definition?</p>

<a name="148013848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148013848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148013848">Chris Hughes (Nov 20 2018 at 03:21)</a>:</h4>
<p>Try <code>[instance, priority 0]</code>. Otherwise it uses classical decidability even when there's proper decidability.</p>

<a name="148013915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148013915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148013915">Wojciech Nawrocki (Nov 20 2018 at 03:23)</a>:</h4>
<p>Ah indeed, thanks Chris!</p>

<a name="148024166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148024166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148024166">Kevin Buzzard (Nov 20 2018 at 08:22)</a>:</h4>
<p>This trips lots of people up! I wonder where people are learning this trick? Not putting priority 0 can trip you up later in quite a confusing way</p>

<a name="148024213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148024213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148024213">Patrick Massot (Nov 20 2018 at 08:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110865">@Jeremy Avigad</span>  needs to fix the very bottom of <a href="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html</a></p>

<a name="148024215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148024215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148024215">Johan Commelin (Nov 20 2018 at 08:23)</a>:</h4>
<p>I think Lean shows an error message when it can't find an instance for <code>decidable</code>, and that error message does not include setting the priority. It would be very helpful if it did.</p>

<a name="148024219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148024219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148024219">Patrick Massot (Nov 20 2018 at 08:23)</a>:</h4>
<p>and <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html</a></p>

<a name="148044684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148044684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148044684">Jeremy Avigad (Nov 20 2018 at 15:03)</a>:</h4>
<p>I'm on it -- I'll do it tomorrow.</p>

<a name="148049459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049459">Patrick Massot (Nov 20 2018 at 16:08)</a>:</h4>
<p>Thanks!</p>

<a name="148049511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049511">Kenny Lau (Nov 20 2018 at 16:09)</a>:</h4>
<p>how about <em>not</em> using <code>classical.dec</code></p>

<a name="148049651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049651" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049651">Reid Barton (Nov 20 2018 at 16:10)</a>:</h4>
<p>Let's just agree to not not use it</p>

<a name="148049677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049677">Kenny Lau (Nov 20 2018 at 16:11)</a>:</h4>
<p>that doesn't mean we <em>use</em> it :P</p>

<a name="148049697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049697">Patrick Massot (Nov 20 2018 at 16:11)</a>:</h4>
<p>You may have missed Reid's point</p>

<a name="148049698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049698">Reid Barton (Nov 20 2018 at 16:11)</a>:</h4>
<p>It doesn't mean <em>you</em> use it</p>

<a name="148074938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148074938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148074938">Wojciech Nawrocki (Nov 20 2018 at 22:59)</a>:</h4>
<p>Is it possible to make Lean display the values of constant variables in the tactic state? E.g. if i have <code>lst: list nat</code> which is also empty, it would be nice to see that it's empty.</p>

<a name="148075021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148075021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148075021">Kenny Lau (Nov 20 2018 at 23:01)</a>:</h4>
<p>either this doesn't make sense, or <code>subst lst</code></p>

<a name="148075182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148075182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148075182">Wojciech Nawrocki (Nov 20 2018 at 23:04)</a>:</h4>
<p>Hm I should elaborate, maybe I'm misunderstanding how <code>induction</code> works. Say I have a hypothesis <code>h: InductiveFoo list.nil</code>, where <code>InductiveFoo: list nat -&gt; Prop</code>. So then running <code>induction h</code> creates cases for all the constructors of <code>InductiveFoo</code>, which take the list as an input, say <code>lst</code>. But the <code>lst</code> is empty, so it'd be nice to see that in the state.</p>

<a name="148075295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148075295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148075295">Kenny Lau (Nov 20 2018 at 23:06)</a>:</h4>
<p>you can't because it's forgotten</p>

<a name="148075309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148075309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148075309">Kenny Lau (Nov 20 2018 at 23:06)</a>:</h4>
<p>you might want to <code>generalize_hyp</code></p>

<a name="148075886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148075886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148075886">Wojciech Nawrocki (Nov 20 2018 at 23:16)</a>:</h4>
<p>Thanks!</p>

<a name="148115433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148115433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148115433">Wojciech Nawrocki (Nov 21 2018 at 15:03)</a>:</h4>
<p>Perhaps it would be useful to have a reference sheet for translating from Coq to Lean tactics?</p>

<a name="148115539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148115539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148115539">Mario Carneiro (Nov 21 2018 at 15:05)</a>:</h4>
<p>I recall such a thing being made at one point. Maybe it's in mathlib docs?</p>

<a name="148115560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148115560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148115560">Rob Lewis (Nov 21 2018 at 15:05)</a>:</h4>
<p><a href="https://github.com/jldodds/coq-lean-cheatsheet" target="_blank" title="https://github.com/jldodds/coq-lean-cheatsheet">https://github.com/jldodds/coq-lean-cheatsheet</a></p>

<a name="148115566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148115566" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148115566">Rob Lewis (Nov 21 2018 at 15:05)</a>:</h4>
<p>Note the date though, it'll need updating.</p>

<a name="148115644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148115644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148115644">Wojciech Nawrocki (Nov 21 2018 at 15:06)</a>:</h4>
<p>Oh, nice!</p>

<a name="148119720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148119720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148119720">Wojciech Nawrocki (Nov 21 2018 at 16:06)</a>:</h4>
<p>Is there a general tactic for showing <code>false</code> by "this term could not have been constructed"? E.g.</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">Foo</span><span class="o">:</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">FooT</span><span class="o">:</span> <span class="n">Foo</span> <span class="n">true</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">FooF</span><span class="o">:</span> <span class="n">Foo</span> <span class="n">false</span> <span class="n">false</span>

<span class="c1">-- This term could not have been constructed</span>
<span class="kn">lemma</span> <span class="n">impossible</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">Foo</span> <span class="n">true</span> <span class="n">false</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">sorry</span>
</pre></div>

<a name="148120085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120085" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120085">Mario Carneiro (Nov 21 2018 at 16:11)</a>:</h4>
<p><code>cases</code></p>

<a name="148120091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120091">Mario Carneiro (Nov 21 2018 at 16:11)</a>:</h4>
<p>also empty match</p>

<a name="148120098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120098">Mario Carneiro (Nov 21 2018 at 16:11)</a>:</h4>
<div class="codehilite"><pre><span></span>lemma impossible : Foo true false → false.
</pre></div>

<a name="148120175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120175">Rob Lewis (Nov 21 2018 at 16:12)</a>:</h4>
<p>You have to make <code>Foo : bool -&gt; bool -&gt; Prop</code> for that.</p>

<a name="148120216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120216">Wojciech Nawrocki (Nov 21 2018 at 16:13)</a>:</h4>
<p>Yeah, for <code>Prop -&gt; Prop -&gt; Prop</code> both of these fail, but that wasn't actually my problem, so thanks!</p>

<a name="148120406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120406">Patrick Massot (Nov 21 2018 at 16:16)</a>:</h4>
<p>It seems that variations on this topic comes up again and again. We should really find a way to document that</p>

<a name="148134832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148134832" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148134832">Wojciech Nawrocki (Nov 21 2018 at 20:17)</a>:</h4>
<p>That would be nice :) I was also surprised to see that more often than not <code>contradiction</code> fails when <code>cases h</code> works. Description: <code>The contradiction tactic attempts to find in the current local context an hypothesis that is equivalent to an empty inductive type (e.g. false)</code>. I thought a hypothesis that cannot be constructed is exactly that, but maybe I'm misunderstanding it?</p>

<a name="148147233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148147233" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148147233">Wojciech Nawrocki (Nov 22 2018 at 01:12)</a>:</h4>
<p>Is it possible to reserve some notation for an inductive type and then use it while defining the type, like in Coq? I tried this,  but the parser seems to fail:</p>
<div class="codehilite"><pre><span></span><span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span><span class="err">∋</span><span class="bp">`</span><span class="o">:</span><span class="mi">50</span>

<span class="kn">inductive</span> <span class="n">Typeof</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">Z</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span><span class="o">,</span> <span class="n">Typeof</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">A</span><span class="o">])</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">S_</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">Typeof</span> <span class="err">Γ</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">Typeof</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">B</span><span class="o">])</span> <span class="n">A</span>

<span class="kn">inductive</span> <span class="n">Typeof</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">Z</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">A</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span> <span class="c1">-- fails</span>
<span class="bp">|</span> <span class="n">S_</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="err">Γ</span> <span class="err">∋</span> <span class="n">A</span> <span class="bp">→</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">B</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span>

<span class="kn">infix</span> <span class="err">∋</span> <span class="o">:=</span> <span class="n">Typeof</span>
</pre></div>

<a name="148150619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148150619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148150619">Mario Carneiro (Nov 22 2018 at 03:00)</a>:</h4>
<p>Yes! You can just put a notation line between the inductive header and the first constructor</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">Typeof</span><span class="o">{</span><span class="n">Tp</span><span class="o">}:</span> <span class="n">list</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kn">infix</span> <span class="bp">`</span><span class="err">∋</span><span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">Typeof</span>
<span class="bp">|</span> <span class="n">Z</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">A</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">S_</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="err">Γ</span> <span class="err">∋</span> <span class="n">A</span> <span class="bp">→</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">B</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span>
</pre></div>

<a name="148238627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148238627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148238627">Jeremy Avigad (Nov 23 2018 at 16:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> I added a discussion of the <code>priority 0</code> trick to Section 10.4 of TPIL (search on "priority 0"):<br>
<a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions</a><br>
I also added a back reference in Section 11:<br>
<a href="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle</a></p>
<p>Finally, I fixed an old issue raised by <span class="user-mention" data-user-id="122022">@Joseph Corneli</span> by changing all the examples in 6.4:<br>
<a href="https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#attributes" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#attributes">https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#attributes</a><br>
<a href="https://github.com/leanprover/theorem_proving_in_lean/issues/62" target="_blank" title="https://github.com/leanprover/theorem_proving_in_lean/issues/62">https://github.com/leanprover/theorem_proving_in_lean/issues/62</a></p>
<p>Teaching my class next semester will give me a chance to review and expand TPIL. I am planning to add one more chapter on some of the fine points of dependent type theory, e.g. explaining how to work with equality and dependent types (the dark side of type theory), and explaining how Lean manages recursion on arbitrary well-founded relations. I'll also try to write a less ambitious but up-to-date version of Programming in Lean. But I am counting on the mathlib crew to continue documenting mathlib and all the new tactics, and to provide useful guidance on using the library and proving theorems.</p>

<a name="148238846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148238846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148238846">Kevin Buzzard (Nov 23 2018 at 16:33)</a>:</h4>
<p>I have not been using Lean seriously since term started; there are three weeks to go before it finishes. After that I fully intend to go back to the perfectoid project. But when I don't understand something, my instinct is to write docs about it, because if I work something out and don't write down what I learnt then I realise a month later that I've forgotten it all again!</p>

<a name="148247373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148247373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148247373">Patrick Massot (Nov 23 2018 at 20:02)</a>:</h4>
<p>Thank you very much Jeremy! Your documentation work is really crucial.</p>

<a name="148249579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148249579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148249579">Patrick Massot (Nov 23 2018 at 21:06)</a>:</h4>
<p>I'm now reading random pieces of TPIL, and I have a couple more suggestions about chapter 10:</p>
<ul>
<li>at several places, emacs is mentioned but not VScode. I guess this goes back to before the VScode extension was available, but it could be misleading</li>
<li>in 10.5. Managing Type Class Inference, I think it would be nice to add the standard tricks to see what's the name of an instance Lean is finding, and sometimes what's the actual definition, as in</li>
</ul>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="bp">ℕ</span><span class="o">)</span>
</pre></div>


<p>maybe find a better example for the second one since the answer is not super easy to read (every nice example coming to my mind are in mathlib...)</p>

<a name="148249664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148249664" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148249664">Patrick Massot (Nov 23 2018 at 21:09)</a>:</h4>
<p>Oh, it seems <code>apply_instance</code> is never mentioned in TPIL <span class="emoji emoji-2639" title="sad">:sad:</span></p>

<a name="148249726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148249726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148249726">Patrick Massot (Nov 23 2018 at 21:10)</a>:</h4>
<p>Another thing that would be very helpful, both because it can be puzzling and because it can be very helpful would be to discuss</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="bp">ℕ</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">has_add</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>  <span class="c1">-- ok</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>  <span class="c1">-- fails</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">n</span> <span class="bp">;</span> <span class="n">apply_instance</span>  <span class="c1">-- ok</span>
</pre></div>

<a name="148277429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148277429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148277429">Jeremy Avigad (Nov 24 2018 at 13:23)</a>:</h4>
<p>Thanks for the input. Yes, TPIL evolved over time, and the last major rewrite was early in the days of Lean 3, before there was a VSCode extension. I'll do a global search and try to make the text less emacs-centric.</p>
<p>I'll discuss <code>apply_instance</code> and <code>infer_instance</code>. I am thinking of using these examples:</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm"> example 1: using apply_instance -/</span>

<span class="n">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">nat</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
<span class="n">def</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>

<span class="c">/-</span><span class="cm"> example 2: using infer_instance -/</span>

<span class="n">def</span> <span class="n">baz</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">infer_instance</span>
<span class="n">def</span> <span class="n">bla</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span>

<span class="c">/-</span><span class="cm"> example 3: seeing them -/</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">foo</span>    <span class="c1">-- nat.has_add</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">foo</span>   <span class="c1">-- (unreadable)</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">bar</span>    <span class="c1">-- pi.inhabited ℕ</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">bar</span>   <span class="c1">-- {default := λ (a : ℕ), 0}</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">baz</span>    <span class="c1">-- infer_instance</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">baz</span>   <span class="c1">-- (same as for #reduce foo)</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">bla</span>    <span class="c1">-- infer_instance</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">bla</span>   <span class="c1">-- {default := λ (a : ℕ), 0}</span>

<span class="c">/-</span><span class="cm"> example 4: tricks to be more concise -/</span>

<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">nat</span><span class="bp">.</span><span class="n">inhabited</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="bp">ℕ</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"> examples 5: core Lean can&#39;t find an instance for inhabited set -/</span>

<span class="c1">-- fails</span>
<span class="c1">-- example {α : Type*} : inhabited (set α) := by apply_instance</span>

<span class="c">/-</span><span class="cm"> example 6: supplying one manually -/</span>

<span class="n">def</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="err">∅</span><span class="bp">⟩</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span>     <span class="c1">-- λ {α : Type u}, {default := ∅}</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="bp">ℕ</span>  <span class="c1">-- {default := λ (a : ℕ), false}</span>

<span class="c">/-</span><span class="cm"> example 7: unfolding a definition so Lean can find it -/</span>

<span class="n">def</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">unfold</span> <span class="n">set</span><span class="bp">;</span> <span class="n">apply_instance</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span>     <span class="c1">-- λ (α : Type u), eq.mpr _ (pi.inhabited α)</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="bp">ℕ</span>  <span class="c1">-- {default := λ (a : ℕ), true}</span>

<span class="c">/-</span><span class="cm"> example 8: using dunfold instead -/</span>

<span class="n">def</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">dunfold</span> <span class="n">set</span><span class="bp">;</span> <span class="n">apply_instance</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span>     <span class="c1">-- λ (α : Type u), id (pi.inhabited α)</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="bp">ℕ</span>  <span class="c1">-- {default := λ (a : ℕ), true}</span>
</pre></div>

<a name="151432316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151432316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151432316">Patrick Massot (Dec 11 2018 at 09:17)</a>:</h4>
<blockquote>
<p>Yes! You can just put a notation line between the inductive header and the first constructor</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">Typeof</span><span class="o">{</span><span class="n">Tp</span><span class="o">}:</span> <span class="n">list</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kn">infix</span> <span class="bp">`</span><span class="err">∋</span><span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">Typeof</span>
<span class="bp">|</span> <span class="n">Z</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">A</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">S_</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="err">Γ</span> <span class="err">∋</span> <span class="n">A</span> <span class="bp">→</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">B</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span>
</pre></div>


</blockquote>
<p>Is there something similar for dependant <code>structure</code>? If one field of my structure is a binary operator, can I define an infix notation usable in the remaining fields declaration?</p>

<a name="151432380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151432380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151432380">Kevin Buzzard (Dec 11 2018 at 09:18)</a>:</h4>
<p>I usually make the <code>structure</code> extend the notation typeclass in this situation.</p>

<a name="151432403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151432403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151432403">Kevin Buzzard (Dec 11 2018 at 09:19)</a>:</h4>
<p>In fact I have been known to make new notation typeclasses called things like <code>group_notation</code> extending <code>has_mul</code>, <code>has_one</code> and <code>has_inv</code>, and then extending these too so I get a bunch of notation at once.</p>

<a name="151432470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151432470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151432470">Patrick Massot (Dec 11 2018 at 09:21)</a>:</h4>
<p>Thanks Kevin. I know all this, but I'm still interested in an answer to my question.</p>

<a name="151432479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151432479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151432479">Kevin Buzzard (Dec 11 2018 at 09:21)</a>:</h4>
<p>Yes I understand. For example if the notation is not in the standard notation list then it would be nicer to add it directly in the definition of the structure.</p>

<a name="151440921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151440921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151440921">Rob Lewis (Dec 11 2018 at 12:05)</a>:</h4>
<p>You can define notation in structures that's used in the remaining fields. But I think it's just local to the structure declaration.</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">patrick</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span> <span class="bp">`</span><span class="err">^^^</span><span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">f</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="err">^^^</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">patrick</span><span class="bp">.</span><span class="n">h</span>
</pre></div>

<a name="151445285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151445285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151445285">Patrick Massot (Dec 11 2018 at 13:29)</a>:</h4>
<p>Thanks!</p>

<a name="154258172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154258172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154258172">Jeremy Avigad (Jan 03 2019 at 18:49)</a>:</h4>
<p>I just crossed this item off my to do list. <code>apply_inference</code> and such are now discussed here: <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference</a>. And VS Code is now mentioned whenever Emacs is, with VS Code first.</p>

<a name="154258563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154258563" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154258563">Patrick Massot (Jan 03 2019 at 18:54)</a>:</h4>
<blockquote>
<p>If you add this to your file in Emacs mode and use C-c C-x to run an independent Lean process on your file, the output buffer will show a trace every time the type class resolution procedure is subsequently triggered.</p>
</blockquote>
<p>This paragraph (in the section your referred to) is still Emacs centric</p>

<a name="154260198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154260198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154260198">Jeremy Avigad (Jan 03 2019 at 19:20)</a>:</h4>
<p>Yes, that is the only one, because I don't know how to start an independent Lean process from within VS Code. I guess I'll remind people that they can run Lean from the VS Code terminal.</p>

<a name="154260213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154260213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154260213">Patrick Massot (Jan 03 2019 at 19:20)</a>:</h4>
<p>Why would you do that?</p>

<a name="154260222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154260222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154260222">Patrick Massot (Jan 03 2019 at 19:20)</a>:</h4>
<p>The trace is printed in the info view</p>

<a name="154260439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154260439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154260439">Jeremy Avigad (Jan 03 2019 at 19:23)</a>:</h4>
<p>Oh! I forgot. Good point. I'll fix that.</p>

<a name="154260510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154260510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154260510">Patrick Massot (Jan 03 2019 at 19:24)</a>:</h4>
<p>Great!</p>

<a name="154261167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154261167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154261167">Jeremy Avigad (Jan 03 2019 at 19:34)</a>:</h4>
<p>Fixed. Thanks for catching it.<br>
<a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference</a></p>

<a name="155250652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155250652" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155250652">Wojciech Nawrocki (Jan 16 2019 at 12:50)</a>:</h4>
<p>Hello! Is there anything special I need to do to make Lean recognise my <code>instance : has_zero Foo</code> as being equivalent to <code>0</code>? I got this state while trying to use <code>rw [this]</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kn">instance</span> <span class="n">of</span> <span class="n">the</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">expression</span>
  <span class="mi">0</span> <span class="bp">+</span> <span class="n">π₂</span>
<span class="n">state</span><span class="o">:</span>
<span class="mi">3</span> <span class="n">goals</span>
<span class="n">π₂</span> <span class="o">:</span> <span class="n">mult</span><span class="o">,</span>
<span class="n">this</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">π₂</span> <span class="bp">=</span> <span class="n">π₂</span>
<span class="err">⊢</span> <span class="n">mult</span><span class="bp">.</span><span class="n">Zero</span> <span class="bp">+</span> <span class="n">π₂</span> <span class="bp">=</span> <span class="n">π₂</span> <span class="bp">+</span> <span class="n">mult</span><span class="bp">.</span><span class="n">Zero</span>
</pre></div>


<p>even though I have</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">mult</span> <span class="o">:=</span>
  <span class="bp">⟨</span><span class="n">mult</span><span class="bp">.</span><span class="n">Zero</span><span class="bp">⟩</span>
</pre></div>


<p>above</p>

<a name="155250968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155250968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155250968">Kevin Buzzard (Jan 16 2019 at 12:55)</a>:</h4>
<p>rewrites don't recognise definitional equality, only syntactic equality.</p>

<a name="155250980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155250980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155250980">Kevin Buzzard (Jan 16 2019 at 12:55)</a>:</h4>
<p>So you could try "show 0 + pi2 = _" before the rewrite</p>

<a name="155251052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251052">Kevin Buzzard (Jan 16 2019 at 12:56)</a>:</h4>
<p>or "change mult.Zero + _ = _ at this". Maybe it will work after one of these changes. But not after both ;-)</p>

<a name="155251072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251072">Reid Barton (Jan 16 2019 at 12:56)</a>:</h4>
<p><code>convert this</code> should also work</p>

<a name="155251096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251096">Kevin Buzzard (Jan 16 2019 at 12:57)</a>:</h4>
<p>but <code>this</code> isn't the goal</p>

<a name="155251103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251103">Kevin Buzzard (Jan 16 2019 at 12:57)</a>:</h4>
<p>Oh!</p>

<a name="155251182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251182">Kevin Buzzard (Jan 16 2019 at 12:58)</a>:</h4>
<p>This <code>convert</code> trick works when the thing you're rewriting is precisely one side of the equality I guess.</p>

<a name="155251188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251188">Reid Barton (Jan 16 2019 at 12:58)</a>:</h4>
<p>or <code>erw this</code> would also work but it's not as nice</p>

<a name="155251370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251370">Reid Barton (Jan 16 2019 at 13:01)</a>:</h4>
<p>In fact you can use <code>a' = b'</code> to prove <code>a = b</code> with neither side matching definitionally (you'll get two new goals <code>a = a'</code> and <code>b = b'</code>), but then you run the risk that the new goals are not actually true <span class="emoji emoji-263a" title="smile">:smile:</span></p>

<a name="155252212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252212">Wojciech Nawrocki (Jan 16 2019 at 13:13)</a>:</h4>
<p>Ah, I see, thanks! And related, I'm proving that an object with three elements and custom add/mult tables is a semiring, how ugly is it to do all my proofs like this?</p>
<div class="codehilite"><pre><span></span>  <span class="kn">lemma</span> <span class="n">add_assoc</span> <span class="o">(</span><span class="n">π₁</span> <span class="n">π₂</span> <span class="n">π₃</span><span class="o">:</span> <span class="n">mult</span><span class="o">)</span>
    <span class="o">:</span> <span class="n">π₁</span> <span class="bp">+</span> <span class="n">π₂</span> <span class="bp">+</span> <span class="n">π₃</span> <span class="bp">=</span> <span class="n">π₁</span> <span class="bp">+</span> <span class="o">(</span><span class="n">π₂</span> <span class="bp">+</span> <span class="n">π₃</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">π₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">π₂</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">π₃</span><span class="bp">;</span> <span class="n">refl</span> <span class="o">}</span>
</pre></div>

<a name="155252434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252434" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252434">Mario Carneiro (Jan 16 2019 at 13:17)</a>:</h4>
<p>it will work, although there are simpler proofs where you ony case on one of them, I think</p>

<a name="155252646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252646">Wojciech Nawrocki (Jan 16 2019 at 13:20)</a>:</h4>
<p>Hm, I found that without expanding every case, I had to do a bit more work by using other lemmas and so on. The definition of <code>add</code> is:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">mult</span><span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Zero</span><span class="o">:</span> <span class="n">mult</span>
<span class="bp">|</span> <span class="n">One</span><span class="o">:</span> <span class="n">mult</span>
<span class="bp">|</span> <span class="n">Omega</span><span class="o">:</span> <span class="n">mult</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">mult</span> <span class="o">:=</span>
  <span class="bp">⟨</span><span class="n">mult</span><span class="bp">.</span><span class="n">Zero</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="n">mult</span> <span class="o">:=</span>
  <span class="bp">⟨</span><span class="n">mult</span><span class="bp">.</span><span class="n">One</span><span class="bp">⟩</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="n">ω</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">mult</span><span class="bp">.</span><span class="n">Omega</span>

<span class="n">def</span> <span class="n">add</span><span class="o">:</span> <span class="n">mult</span> <span class="bp">→</span> <span class="n">mult</span> <span class="bp">→</span> <span class="n">mult</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">π</span> <span class="o">:=</span> <span class="n">π</span>
<span class="bp">|</span> <span class="n">π</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">π</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">ω</span>
<span class="bp">|</span> <span class="n">ω</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">ω</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">ω</span> <span class="o">:=</span> <span class="n">ω</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">mult</span> <span class="o">:=</span>
  <span class="bp">⟨</span><span class="n">add</span><span class="bp">⟩</span>
</pre></div>

<a name="155252763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252763" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252763">Mario Carneiro (Jan 16 2019 at 13:22)</a>:</h4>
<p>right</p>

<a name="155252890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252890">Mario Carneiro (Jan 16 2019 at 13:24)</a>:</h4>
<p>you should have lemmas like <code>x + ω = ω</code> as simp lemmas which should simplify most of the cases</p>

<a name="155252915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252915">Mario Carneiro (Jan 16 2019 at 13:25)</a>:</h4>
<p>or you could just split into 27 cases if you want</p>

<a name="155253007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155253007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155253007">Wojciech Nawrocki (Jan 16 2019 at 13:26)</a>:</h4>
<p>Ah ok, i'll try it with simp as well, thanks!</p>

<a name="155254705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155254705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155254705">Johan Commelin (Jan 16 2019 at 13:55)</a>:</h4>
<p>Scott Morrison's case-bashing tactic would probably be useful here. But I don't know where that tactic lives at the moment...</p>

<a name="155255138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155255138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155255138">Mario Carneiro (Jan 16 2019 at 14:01)</a>:</h4>
<p>if you want to do a case bashing proof, another approach is to prove <code>fintype mult</code> and <code>decidable_eq mult</code> (you can <code>derive</code> this), and then you can just revert everything and use <code>dec_trivial</code></p>

<a name="155255210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155255210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155255210">Johan Commelin (Jan 16 2019 at 14:02)</a>:</h4>
<p>Should even be reasonably fast, I guess.</p>

<a name="155255232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155255232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155255232">Mario Carneiro (Jan 16 2019 at 14:02)</a>:</h4>
<p>as long as you don't have too many variables; it is still 27 cases</p>

<a name="155256347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155256347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155256347">Kevin Buzzard (Jan 16 2019 at 14:18)</a>:</h4>
<p>Kind of a stupid question, but when I'm using other computer algebra systems I would expect checking a million cases to be very quick. Mario's comments suggest that 27 is rather large for Lean. What is happening here?</p>

<a name="155257947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155257947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155257947">Mario Carneiro (Jan 16 2019 at 14:37)</a>:</h4>
<p>There is a large overhead of the expression that is generated, elaboration for it, and typechecking</p>

<a name="155258030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258030">Mario Carneiro (Jan 16 2019 at 14:38)</a>:</h4>
<p>I don't think 27 is that large in this context, I guess it's probably less than a second to check</p>

<a name="155258059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258059">Mario Carneiro (Jan 16 2019 at 14:38)</a>:</h4>
<p>I just think it's better to have more "human" proofs with fewer cases</p>

<a name="155258070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258070">Kevin Buzzard (Jan 16 2019 at 14:38)</a>:</h4>
<p>This is what I don't understand. We have to check that 27 things of the form add a (add b c) = add (add a b) c hold and in each case this is by refl.</p>

<a name="155258119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258119">Kevin Buzzard (Jan 16 2019 at 14:39)</a>:</h4>
<p>How long does it take Lean to prove (0 + 1) + 1 = 0 + (1 + 1) in this type?</p>

<a name="155258201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258201">Mario Carneiro (Jan 16 2019 at 14:40)</a>:</h4>
<p>there is also all the intermediate steps, the generation of motives, lots of abstraction and substitution going on, and large terms being built up behind the scenes before you even attack those 27 cases</p>

<a name="155258224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258224">Kevin Buzzard (Jan 16 2019 at 14:40)</a>:</h4>
<p>So the bottleneck is elsewhere?</p>

<a name="155258252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258252">Mario Carneiro (Jan 16 2019 at 14:41)</a>:</h4>
<p>I have heard it repeatedly asserted that the kernel is not a bottleneck</p>

<a name="155258265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258265">Kevin Buzzard (Jan 16 2019 at 14:41)</a>:</h4>
<p>Again the idea of a "large" term is confusing to me. In python I could happily manipulate a list with 1000 elements.</p>

<a name="155258275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258275">Mario Carneiro (Jan 16 2019 at 14:41)</a>:</h4>
<p>this term has way more than 1000 subterms</p>

<a name="155258304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258304">Kevin Buzzard (Jan 16 2019 at 14:41)</a>:</h4>
<p>One of my kids has been learning about algorithms over the last few months and I realise now that I am far more aware of these things than I used to be.</p>

<a name="155258379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258379">Mario Carneiro (Jan 16 2019 at 14:42)</a>:</h4>
<p>all in all it makes lean just look a lot slower to do "simple" things</p>

<a name="155258393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258393">Mario Carneiro (Jan 16 2019 at 14:42)</a>:</h4>
<p>because there is a lot of bookkeeping in the background</p>

<a name="155258552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258552">Mario Carneiro (Jan 16 2019 at 14:44)</a>:</h4>
<p>I would like to figure out ways to minimize the overhead, but that runs close to work on the lean compiler</p>

<a name="155261902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155261902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155261902">Kevin Buzzard (Jan 16 2019 at 15:28)</a>:</h4>
<blockquote>
<p>this term has way more than 1000 subterms</p>
</blockquote>
<p>In the same way that a set with 10 elements has more than 1000 subsets, or in a more serious "we really need to work with way more than 1000 things" way?</p>

<a name="155263745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155263745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155263745">Mario Carneiro (Jan 16 2019 at 15:50)</a>:</h4>
<p>in the more serious way. (It's tricky to count the "size" of an expression but number of subterms is a good proxy)</p>

<a name="155263817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155263817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155263817">Mario Carneiro (Jan 16 2019 at 15:51)</a>:</h4>
<p>there is no exponential growth because subterms can't overlap, they are either disjoint or in a containment relationship</p>

<a name="156331129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156331129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156331129">Wojciech Nawrocki (Jan 18 2019 at 00:04)</a>:</h4>
<p>Is it possible to define a custom synthesis strategy for an implicit argument? I would like to define a function which extracts concrete values from concrete lists, like so:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">get&#39;</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">h</span><span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">l</span><span class="bp">.</span><span class="n">length</span><span class="o">},</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="bp">::</span><span class="n">xs</span><span class="o">)</span> <span class="mi">0</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">x</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="bp">::</span><span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">get&#39;</span> <span class="n">xs</span> <span class="n">n</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">lt_of_succ_lt_succ</span> <span class="n">h</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">n</span> <span class="n">h</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">not_lt_zero</span> <span class="n">n</span><span class="o">)</span>
</pre></div>


<p>and for concrete args, <code>h</code> is always derivable with a custom tactic. I'd like Lean to use that tactic to synthesise it.<br>
OR am I doing this completely wrong and there is a much simpler way?</p>

<a name="156331279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156331279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156331279">Chris Hughes (Jan 18 2019 at 00:07)</a>:</h4>
<p>unification hints! I don't know much about them though.</p>

<a name="156334847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156334847" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156334847">Mario Carneiro (Jan 18 2019 at 00:51)</a>:</h4>
<p>This function is <code>list.nth_le</code> btw</p>

<a name="156334971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156334971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156334971">Mario Carneiro (Jan 18 2019 at 00:53)</a>:</h4>
<p>you can synthesize the argument using typeclasses, but <code>exact_dec_trivial</code> is another easy way to do it</p>

<a name="156335048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156335048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156335048">Mario Carneiro (Jan 18 2019 at 00:54)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">get&#39;</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">l</span><span class="bp">.</span><span class="n">length</span> <span class="bp">.</span> <span class="n">exact_dec_trivial</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">l</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">n</span> <span class="n">h</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">get&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>

<a name="156335623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156335623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156335623">Wojciech Nawrocki (Jan 18 2019 at 01:07)</a>:</h4>
<p>Ah indeed, thanks Mario! Can I use something like this in a Pi-type (to make the equation compiler work)? The <code>foo . tactic</code> syntax doesn't seem to work:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">debrujin_of_nat</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span><span class="o">:</span> <span class="n">Env</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="err">Γ</span><span class="bp">.</span><span class="n">length</span> <span class="bp">.</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">exact_dec_trivial</span><span class="o">),</span> <span class="o">(</span><span class="err">Γ</span> <span class="err">∋</span> <span class="err">Γ</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">n</span> <span class="n">h</span><span class="o">)</span> <span class="c1">-- ill-formed declaration</span>
</pre></div>

<a name="156335911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156335911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156335911">Mario Carneiro (Jan 18 2019 at 01:14)</a>:</h4>
<p>If you can put it left of the colon, the dot notation should work. But if you can't write it that way, it's sugar for <code>auto_param</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">get&#39;</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">auto_param</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;</span> <span class="n">l</span><span class="bp">.</span><span class="n">length</span><span class="o">)</span> <span class="bp">``</span><span class="n">exact_dec_trivial</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth_le</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">get&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>

<a name="156336087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336087">Wojciech Nawrocki (Jan 18 2019 at 01:19)</a>:</h4>
<p>Can I have a _named_ <code>auto_param</code> <span class="emoji emoji-1f605" title="sweat smile">:sweat_smile:</span>? I need to use the hypothesis in the type signature itself, more specifically in the return type.</p>

<a name="156336185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336185">Mario Carneiro (Jan 18 2019 at 01:21)</a>:</h4>
<p>sure, just use a pi instead of an arrow</p>

<a name="156336193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336193">Mario Carneiro (Jan 18 2019 at 01:21)</a>:</h4>
<p><code>auto_param T n</code> is defeq to <code>T</code> so it doesn't cause any problems</p>

<a name="156336460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336460" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336460">Wojciech Nawrocki (Jan 18 2019 at 01:27)</a>:</h4>
<p>Oh, I was sure I'd tried that but apparently not, thanks! Doesn't seem to work under <code>#eval</code> unfortunately:</p>
<div class="codehilite"><pre><span></span><span class="n">don&#39;t</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
<span class="kn">context</span><span class="o">:</span>
<span class="err">⊢</span> <span class="n">auto_param</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="o">[</span><span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span><span class="o">])</span> <span class="o">(</span><span class="n">name</span><span class="bp">.</span><span class="n">mk_string</span> <span class="s2">&quot;exact_dec_trivial&quot;</span> <span class="o">(</span><span class="n">name</span><span class="bp">.</span><span class="n">mk_string</span> <span class="s2">&quot;tactic&quot;</span> <span class="n">name</span><span class="bp">.</span><span class="n">anonymous</span><span class="o">))</span>
</pre></div>

<a name="156336541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336541">Mario Carneiro (Jan 18 2019 at 01:29)</a>:</h4>
<p>what did you write?</p>

<a name="156336637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336637">Mario Carneiro (Jan 18 2019 at 01:30)</a>:</h4>
<p>it's not really related to the context you write it in, but rather the expected type during elaboration</p>

<a name="156336845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336845">Wojciech Nawrocki (Jan 18 2019 at 01:35)</a>:</h4>
<p>Apologies for the length, but this is the full context:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">find</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">auto_cases</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">tidy</span>

<span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">decidable_eq</span><span class="o">]</span>
<span class="kn">inductive</span> <span class="n">Tp</span>
<span class="bp">|</span> <span class="n">Nat</span><span class="o">:</span> <span class="n">Tp</span>
<span class="bp">|</span> <span class="n">Bool</span><span class="o">:</span> <span class="n">Tp</span>
<span class="bp">|</span> <span class="n">Fn</span><span class="o">:</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span>

<span class="n">local</span> <span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⇒</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Fn</span>

<span class="n">def</span> <span class="n">Env</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">Tp</span>

<span class="kn">inductive</span> <span class="n">TypeIn</span><span class="o">:</span> <span class="n">Env</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">∋</span> <span class="bp">`</span><span class="o">:</span><span class="mi">40</span> <span class="o">:=</span> <span class="n">TypeIn</span>
<span class="bp">|</span> <span class="n">ZVar</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">T</span><span class="o">},</span> <span class="n">T</span><span class="bp">::</span><span class="err">Γ</span> <span class="err">∋</span> <span class="n">T</span>
<span class="bp">|</span> <span class="n">SVar</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">T</span> <span class="n">U</span><span class="o">},</span> <span class="err">Γ</span> <span class="err">∋</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">U</span><span class="bp">::</span><span class="err">Γ</span> <span class="err">∋</span> <span class="n">T</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∋</span> <span class="bp">`</span><span class="o">:</span><span class="mi">40</span> <span class="o">:=</span> <span class="n">TypeIn</span>

<span class="kn">open</span> <span class="n">TypeIn</span>

<span class="kn">inductive</span> <span class="n">Term</span><span class="o">:</span> <span class="n">Env</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Nat</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span><span class="o">},</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="c1">-- in all environments, nat literals have type Nat</span>
<span class="bp">|</span> <span class="n">Bool</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">bool</span><span class="o">):</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span><span class="o">},</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Bool</span> <span class="c1">-- and booleans have type Bool</span>
<span class="bp">|</span> <span class="n">Var</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">T</span><span class="o">},</span> <span class="err">Γ</span> <span class="err">∋</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="n">T</span> <span class="c1">-- A variable has type T given its de Brujin index</span>
                                 <span class="c1">-- is in the environment.</span>
<span class="bp">|</span> <span class="n">Abs</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">T</span> <span class="n">U</span><span class="o">},</span> <span class="n">Term</span> <span class="o">(</span><span class="n">T</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">T</span> <span class="err">⇒</span> <span class="n">U</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">App</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">T</span> <span class="n">U</span><span class="o">},</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">T</span> <span class="err">⇒</span> <span class="n">U</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="n">U</span>

<span class="kn">open</span> <span class="n">Term</span>

<span class="n">def</span> <span class="n">debrujin_of_nat</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span><span class="o">:</span> <span class="n">Env</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">h</span><span class="o">:</span> <span class="n">auto_param</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;</span> <span class="err">Γ</span><span class="bp">.</span><span class="n">length</span><span class="o">)</span> <span class="bp">``</span><span class="n">tactic</span><span class="bp">.</span><span class="n">exact_dec_trivial</span><span class="o">},</span> <span class="o">(</span><span class="err">Γ</span> <span class="err">∋</span> <span class="err">Γ</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">n</span> <span class="n">h</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">T</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="mi">0</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">ZVar</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">T</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">SVar</span> <span class="o">(</span><span class="bp">@</span><span class="n">debrujin_of_nat</span> <span class="err">Γ</span> <span class="n">n</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">lt_of_succ_lt_succ</span> <span class="n">h</span><span class="o">))</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">n</span> <span class="n">h</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">not_lt_zero</span> <span class="n">n</span><span class="o">)</span> <span class="n">h</span> <span class="o">}</span>

<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`#`</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">Var</span> <span class="o">(</span><span class="n">debrujin_of_nat</span> <span class="n">n</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">App</span> <span class="o">[]</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">Abs</span> <span class="o">[]</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">Var</span> <span class="o">[</span><span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span><span class="o">]</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="o">(</span><span class="n">debrujin_of_nat</span> <span class="mi">0</span><span class="o">)))</span> <span class="o">(</span><span class="bp">@</span><span class="n">Nat</span> <span class="mi">3</span> <span class="o">[]))</span>
</pre></div>

<a name="156336955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336955">Wojciech Nawrocki (Jan 18 2019 at 01:37)</a>:</h4>
<p>Basically given a concrete <code>list Tp</code> and a concrete <code>n</code>, I'd like it to figure out that <code>n</code> is within bounds and include the result of <code>lst.nth_le n _</code> in the return type.</p>

<a name="156337127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156337127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156337127">Wojciech Nawrocki (Jan 18 2019 at 01:41)</a>:</h4>
<p>This does work: <code>#eval (@App [] Tp.Nat Tp.Nat (@Abs [] Tp.Nat Tp.Nat (@Var [Tp.Nat] Tp.Nat (@debrujin_of_nat [Tp.Nat] 0 (by tactic.exact_dec_trivial)))) (@Nat 3 []))</code> (notice the explicit proof I put in)</p>

<a name="156338055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338055" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338055">Mario Carneiro (Jan 18 2019 at 02:06)</a>:</h4>
<p>so what did you write?</p>

<a name="156338116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338116">Wojciech Nawrocki (Jan 18 2019 at 02:07)</a>:</h4>
<p>Well, the <code>#eval</code> at the bottom of that long snippet is what fails synthesis. The <code>#eval</code> with an explicit proof works</p>

<a name="156338117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338117">Mario Carneiro (Jan 18 2019 at 02:07)</a>:</h4>
<p>aha, you made the arg implicit</p>

<a name="156338118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338118">Mario Carneiro (Jan 18 2019 at 02:07)</a>:</h4>
<p>auto params should be explicit</p>

<a name="156338120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338120">Mario Carneiro (Jan 18 2019 at 02:07)</a>:</h4>
<div class="codehilite"><pre><span></span>def debrujin_of_nat: Π {Γ: Env} (n: ℕ) (h: auto_param (n &lt; Γ.length) ``tactic.exact_dec_trivial), (Γ ∋ Γ.nth_le n h)
</pre></div>

<a name="156338198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338198">Wojciech Nawrocki (Jan 18 2019 at 02:09)</a>:</h4>
<p>Oh thanks, now it does work, but still behaves as if it were implicit <span class="emoji emoji-1f914" title="thinking">:thinking:</span> is this currying at work, meaning I have to place <code>auto_param</code> last, s.t. given <code>foo: nat -&gt; auto_param blah -&gt; nat</code>, <code>(foo n): nat</code> (and <code>foo n _</code> still fails)?</p>

<a name="156408748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156408748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156408748">Wojciech Nawrocki (Jan 18 2019 at 23:39)</a>:</h4>
<p>(unrelated to above)<br>
I'm seeing a wierd error in an inductive type: <code>invalid occurrence of recursive arg#3 of 'context.cons', the body of the functional type depends on it.</code>. The type definition is below, and as far as I know it's a perfectly legit defn, so what's wrong?</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="kn">context</span><span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">nil</span><span class="o">:</span> <span class="kn">context</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="n">ns</span><span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="bp">_</span><span class="o">:</span> <span class="kn">context</span> <span class="n">ns</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="kn">context</span> <span class="o">(</span><span class="n">n</span><span class="bp">::</span><span class="n">ns</span><span class="o">)</span>
</pre></div>


<p>EDIT: swapping two arguments makes it compile, but why?</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="kn">context</span><span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">nil</span><span class="o">:</span> <span class="kn">context</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">cons</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">ns</span><span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">_</span><span class="o">:</span> <span class="kn">context</span> <span class="n">ns</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="kn">context</span> <span class="o">(</span><span class="n">n</span><span class="bp">::</span><span class="n">ns</span><span class="o">)</span>
</pre></div>

<a name="156409198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156409198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156409198">Mario Carneiro (Jan 18 2019 at 23:48)</a>:</h4>
<p>I think Gabriel recently pointed out an example similar to this. You have a dependent pi (<code>n</code>) after a recursive arg (<code>_ : context ns</code>) and lean doesn't like this</p>

<a name="156411833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156411833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156411833">Wojciech Nawrocki (Jan 19 2019 at 00:37)</a>:</h4>
<p>Ah ok, maybe this could be fixed in Lean 4? :)</p>

<a name="156414862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156414862" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156414862">Wojciech Nawrocki (Jan 19 2019 at 01:51)</a>:</h4>
<p>Do I need to do something special to make the semiring-ness of my custom type available to the <code>ring</code> tactic? I have a state like this:</p>
<div class="codehilite"><pre><span></span><span class="n">π</span> <span class="n">π&#39;</span> <span class="o">:</span> <span class="n">mult</span><span class="o">,</span>
<span class="n">π_1</span> <span class="o">:</span> <span class="n">mult</span><span class="o">,</span>
<span class="err">⊢</span> <span class="n">π</span> <span class="bp">*</span> <span class="n">π&#39;</span> <span class="bp">*</span> <span class="n">π_1</span> <span class="bp">=</span> <span class="n">π</span> <span class="bp">*</span> <span class="o">(</span><span class="n">π&#39;</span> <span class="bp">*</span> <span class="n">π_1</span><span class="o">)</span>
</pre></div>


<p>which is provable by <code>exact mult.monoid.mul_assoc π π' π_1</code>, but <code>ring</code> fails. I have <code>instance : semiring mult</code> shown a few lines above.</p>

<a name="156415302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156415302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156415302">Mario Carneiro (Jan 19 2019 at 02:01)</a>:</h4>
<p>you need to prove <code>comm_semiring mult</code></p>

<a name="156554174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554174">Wojciech Nawrocki (Jan 21 2019 at 18:36)</a>:</h4>
<p>Given <code>def add (a b: foo): foo := blah</code>, what's the difference between <code>infix </code> ++ <code> := add</code> and <code>instance : has_add foo := ⟨add⟩</code>? If i switch from the former to the latter and replace <code>++</code> with <code>+</code>, my proofs break at the simplification stage, namely addition seems to not be <code>unfold</code>able anymore</p>

<a name="156554210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554210">Kevin Buzzard (Jan 21 2019 at 18:37)</a>:</h4>
<p>They're very different in the sense that they're using different machinery to figure out what's going on.</p>

<a name="156554280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554280">Kevin Buzzard (Jan 21 2019 at 18:38)</a>:</h4>
<p>I guess the <code>infix</code> trick is just syntax sugar, whereas the <code>instance</code> approach is using type class inference. Can you give an example of something which breaks?</p>

<a name="156554315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554315">Kevin Buzzard (Jan 21 2019 at 18:39)</a>:</h4>
<p>I guess if you go via the instance approach then you have an extra layer of unfolding to do. <code>+</code> is <code>has_add.add</code>, which unfolds to your add.</p>

<a name="156554337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554337">Kevin Buzzard (Jan 21 2019 at 18:39)</a>:</h4>
<p>Maybe that's the answer to your question. If you're trying to unfold things explicitly in the middle of a proof, maybe you have to insert some <code>unfold has_add.add</code>'s</p>

<a name="156554416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554416">Kevin Buzzard (Jan 21 2019 at 18:40)</a>:</h4>
<p><code>++</code> unfolds directly to your <code>add</code>, whereas <code>+</code> unfolds to <code>has_add.add</code> which unfolds to your add.</p>

<a name="156554455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554455" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554455">Kevin Buzzard (Jan 21 2019 at 18:42)</a>:</h4>
<p>[NB I'm a bit of a CS noob, I don't know if "unfolds" is the right terminology for notation turning into its underlying definition]</p>

<a name="156554512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554512">Kevin Buzzard (Jan 21 2019 at 18:42)</a>:</h4>
<p>[they might well be syntactically equal rather than just definitionally equal]</p>

<a name="156556743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156556743" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156556743">Wojciech Nawrocki (Jan 21 2019 at 19:29)</a>:</h4>
<p>Ah indeed, <code>unfold</code>ing twice does make it work - thanks!</p>

<a name="156571293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156571293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156571293">Wojciech Nawrocki (Jan 22 2019 at 01:12)</a>:</h4>
<p>Does there exist a general tactic for proving <code>f a0 .. an = f b0 .. bn</code> from <code>a0 = b0 .. an = bn</code>?</p>

<a name="156571984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156571984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156571984">Mario Carneiro (Jan 22 2019 at 01:33)</a>:</h4>
<p><code>congr</code></p>

<a name="156572109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156572109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156572109">Wojciech Nawrocki (Jan 22 2019 at 01:36)</a>:</h4>
<p>Hm, I tried <code>congr</code> but it seems to iterate the congruence, which gives me unprovable goals. Namely, I have a goal <code>f (g x) = f (g y)</code> and <code>congr</code> gives me <code>x = y</code> but I just want <code>g x = g y</code>. EDIT: <code>congr' 1</code> works, thx!</p>

<a name="156574364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156574364" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156574364">Mario Carneiro (Jan 22 2019 at 02:37)</a>:</h4>
<p>use <code>congr' 1</code> and increase the number until you get a good result</p>

<a name="156647038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156647038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156647038">Wojciech Nawrocki (Jan 22 2019 at 22:43)</a>:</h4>
<p>The issue of <code>has_add.add</code> and its actual value not being definitionally equal makes a lot of my proofs quite ugly - I have to expand definitions first so that the expressions can simplify and then fold them back into the <code>has_add.add</code> version (or <code>has_mul.mul</code>, etc), because all the ring/module/whatever laws only work on those. For example:</p>
<div class="codehilite"><pre><span></span>  <span class="o">{</span> <span class="c">/-</span><span class="cm"></span>
<span class="cm">    case context.cons</span>
<span class="cm">    δ γ γ₁ : precontext,</span>
<span class="cm">    π₁ : mult,</span>
<span class="cm">    T₁ : tp,</span>
<span class="cm">    Γ₁ : context γ₁,</span>
<span class="cm">    ih₁ : ∀ {Γ₂ : context γ₁} {Ξ : matrix γ₁ δ}, vmul (Γ₁ + Γ₂) Ξ = vmul Γ₁ Ξ + vmul Γ₂ Ξ,</span>
<span class="cm">    Γ₂ : context (T₁ :: γ₁),</span>
<span class="cm">    Ξ : matrix (T₁ :: γ₁) δ</span>
<span class="cm">    ⊢ vmul (cons π₁ T₁ Γ₁ + Γ₂) Ξ = vmul (cons π₁ T₁ Γ₁) Ξ + vmul Γ₂ Ξ</span>
<span class="cm">    -/</span>
    <span class="n">cases</span> <span class="err">Γ₂</span> <span class="k">with</span> <span class="bp">_</span> <span class="n">π₂</span> <span class="bp">_</span> <span class="err">Γ₂</span><span class="o">,</span>
    <span class="c1">-- unfold</span>
    <span class="n">unfold</span> <span class="n">vmul</span> <span class="n">has_add</span><span class="bp">.</span><span class="n">add</span> <span class="kn">context</span><span class="bp">.</span><span class="n">add</span> <span class="n">has_scalar</span><span class="bp">.</span><span class="n">smul</span> <span class="kn">context</span><span class="bp">.</span><span class="n">smul</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
    <span class="n">simp</span> <span class="bp">*</span><span class="o">,</span>
    <span class="c1">-- fold back</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">vmul</span> <span class="err">Γ₁</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">tp</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">γ₁</span> <span class="err">∋</span> <span class="n">U</span><span class="o">),</span> <span class="err">Ξ</span> <span class="n">U</span> <span class="o">(</span><span class="n">SVar</span> <span class="n">x</span><span class="o">)),</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">vmul</span> <span class="err">Γ₂</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">tp</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">γ₁</span> <span class="err">∋</span> <span class="n">U</span><span class="o">),</span> <span class="err">Ξ</span> <span class="n">U</span> <span class="o">(</span><span class="n">SVar</span> <span class="n">x</span><span class="o">)),</span>
    <span class="n">change</span>
      <span class="o">(</span><span class="n">π₁</span> <span class="bp">+</span> <span class="n">π₂</span><span class="o">)</span> <span class="err">•</span> <span class="o">(</span><span class="err">Ξ</span> <span class="n">T₁</span> <span class="n">ZVar</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>
      <span class="bp">=</span>
      <span class="o">(</span><span class="n">π₁</span><span class="err">•</span><span class="o">(</span><span class="err">Ξ</span> <span class="n">T₁</span> <span class="n">ZVar</span><span class="o">)</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">π₂</span><span class="err">•</span><span class="o">(</span><span class="err">Ξ</span> <span class="n">T₁</span> <span class="n">ZVar</span><span class="o">)</span> <span class="bp">+</span> <span class="n">b</span><span class="o">),</span>
    <span class="c1">-- simplify using monoid laws</span>
    <span class="n">simp</span> <span class="o">[</span><span class="kn">context</span><span class="bp">.</span><span class="n">add_smul</span><span class="o">,</span> <span class="kn">context</span><span class="bp">.</span><span class="n">add_assoc</span><span class="o">]</span> <span class="o">},</span>
</pre></div>


<p>is there some tactic or such that I could apply to do this automatically?</p>

<a name="156647545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156647545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156647545">Mario Carneiro (Jan 22 2019 at 22:51)</a>:</h4>
<p>This is what simp lemmas are for</p>

<a name="156647677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156647677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156647677">Mario Carneiro (Jan 22 2019 at 22:53)</a>:</h4>
<p>If you define <code>add x (y :: z) := y :: add x z</code>, for example, and then install <code>add</code> as a <code>has_add</code> instance, then you can prove <code>x + (y :: z) = y :: (x + z)</code> by rfl, and you should state this as a simp lemma</p>

<a name="156647754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156647754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156647754">Mario Carneiro (Jan 22 2019 at 22:54)</a>:</h4>
<p>You should not ever have to unfold <code>has_add.add</code></p>

<a name="156647865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156647865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156647865">Wojciech Nawrocki (Jan 22 2019 at 22:56)</a>:</h4>
<p>Hm okay, so basically I need to "lift" the behaviour of my functions from the custom definition to one using <code>has_op.op</code>? I'll try</p>

<a name="156648686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156648686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156648686">Wojciech Nawrocki (Jan 22 2019 at 23:09)</a>:</h4>
<p>Is it fine to unfold <code>has_zero.zero</code> though? My definition of <code>0</code> for this type is</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">zeros</span><span class="o">:</span> <span class="bp">Π</span> <span class="n">γ</span><span class="o">,</span> <span class="kn">context</span> <span class="n">γ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">T</span><span class="bp">::</span><span class="n">δ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">cons</span> <span class="mi">0</span> <span class="n">T</span> <span class="o">(</span><span class="n">zeros</span> <span class="n">δ</span><span class="o">)</span>
</pre></div>


<p>and I need the <code>cons</code> to prove <code>0+Γ=Γ</code></p>

<a name="156649254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156649254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156649254">Wojciech Nawrocki (Jan 22 2019 at 23:21)</a>:</h4>
<p>In any case this is pretty awesome, all my proofs have shortened by half now without the unfolding, thanks a lot!</p>

<a name="156653719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156653719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156653719">Mario Carneiro (Jan 23 2019 at 00:37)</a>:</h4>
<p>For this, you should decide whether you prefer to write the empty context as <code>0</code> or <code>[]</code>, and write a simp lemma like <code>0 = []</code> if you want to get rid of the 0 everywhere. In this case you should also make sure that all your other simp lemmas use the "preferred form" of this element on the LHS</p>

<a name="159247553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159247553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159247553">Wojciech Nawrocki (Feb 23 2019 at 22:04)</a>:</h4>
<p>What's the closest thing to the <code>ring</code> tactic when what I have is not a commutative semiring, e.g. just a monoid? Say my theorems are provable simply by repeated application of monoid or group laws, what tactic could I use?</p>

<a name="159247675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159247675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159247675">Kevin Buzzard (Feb 23 2019 at 22:08)</a>:</h4>
<p>If it's abelian then <code>abel</code> might work, and if it's not then you're best going with <code>simp</code> I think</p>

<a name="159247686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159247686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159247686">Kevin Buzzard (Feb 23 2019 at 22:09)</a>:</h4>
<p>You might have to write <code>simp [mul_assoc]</code> maybe, I can't remember if mul_assoc is a simp lemma</p>

<a name="159247850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159247850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159247850">Wojciech Nawrocki (Feb 23 2019 at 22:15)</a>:</h4>
<p><code>abel</code> worked :) thanks. And no, <code>mul_assoc</code> doesn't seem to be a simp lemma.</p>

<a name="159250591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159250591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159250591">Wojciech Nawrocki (Feb 23 2019 at 23:41)</a>:</h4>
<p>Say I would like to work with a particular module which uses a variable <code>v</code> instantiated over a concrete <code>v</code>. For example, a file <code>foo.lean</code> could first declare <code>variable {v: Type}</code> and then use <code>v</code> in all definitions/lemmas in the file. I would like to import everything in <code>foo</code> instantiated with e.g. <code>nat</code> for <code>v</code>. This would be equivalent to partially applying everything in the file to <code>nat</code>. Is such a thing possible without manually redefining everything?</p>

<a name="159250640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159250640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159250640">Andrew Ashworth (Feb 23 2019 at 23:42)</a>:</h4>
<p>You could write a tactic to do it</p>

<a name="159250642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159250642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159250642">Andrew Ashworth (Feb 23 2019 at 23:43)</a>:</h4>
<p>But, why?</p>

<a name="159250779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159250779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159250779">Wojciech Nawrocki (Feb 23 2019 at 23:47)</a>:</h4>
<p>I would like to do this in order to:<br>
a) Avoid type class search by giving it the right instance from the start.<br>
b) Make inference work. I found that making one of my modules more generic (I changed it from using a particular semiring to being generic over arbitrary semirings) broke inference in a lot of places where I use this module because it no longer knows which semiring to pick and I don't want to specify it everywhere manually.<br>
For a more concrete example which is close to what I'm doing, say I define a list <code>inductive slist {α: Type} [semiring α]: Type</code> which is a list the elements of which are also elements of a semiring and then derive a bunch of theorems about the behaviour of such a list under some transformations. I would then like to use all of these theorems only with a particular choice of <code>α</code>, even though the <code>slist</code> file/module is generic.</p>

<a name="159251390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159251390" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159251390">Kevin Buzzard (Feb 24 2019 at 00:06)</a>:</h4>
<p>But if you're using <code>{alpha  : Type}</code> correctly, then Lean should be able to infer what alpha is from subsequent terms, so you don't need to change it to nat, Lean will just guess it for you and do it itself. Have I missed the point?</p>

<a name="159251642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159251642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159251642">Andrew Ashworth (Feb 24 2019 at 00:15)</a>:</h4>
<p>"no longer knows which semiring to pick" this sounds fishy</p>

<a name="159251765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159251765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159251765">Kevin Buzzard (Feb 24 2019 at 00:18)</a>:</h4>
<p>The <code>{}</code> brackets aren't type class search, they are dealt with using unification.</p>

<a name="159251957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159251957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159251957">Wojciech Nawrocki (Feb 24 2019 at 00:23)</a>:</h4>
<p>You're right, Lean can still unify it and find the class instance - I was perhaps a bit rash there when figuring out what's going on. However, tactic state updates that used to take about 300ms when I was working over a concrete object now take several seconds, making it somewhat painful to work interactively. I was hoping that reinstantiating all the lemmas over the concrete objects again would alleviate this.</p>

<a name="159252010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252010">Kevin Buzzard (Feb 24 2019 at 00:24)</a>:</h4>
<p>Again, if you're talking about <code>{}</code>s then this isn't to do with classes, it's something else.</p>

<a name="159252015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252015">Kevin Buzzard (Feb 24 2019 at 00:24)</a>:</h4>
<p>But I agree that sometimes things get slow, and it can sometimes be quite difficult to find out why.</p>

<a name="159252030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252030">Wojciech Nawrocki (Feb 24 2019 at 00:25)</a>:</h4>
<p>I'm talking about both - the <code>{alpha}</code> variable being unified and <code>[semiring alpha]</code> which needs a class instance.</p>

<a name="159252032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252032" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252032">Kevin Buzzard (Feb 24 2019 at 00:25)</a>:</h4>
<p>Aah yes, that is a class instance. Sorry.</p>

<a name="159252038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252038">Kevin Buzzard (Feb 24 2019 at 00:25)</a>:</h4>
<p>Does it help to actually put the type class instances explicitly into Lean at the top of the file?</p>

<a name="159252086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252086">Kevin Buzzard (Feb 24 2019 at 00:26)</a>:</h4>
<p>e.g. you were working with a random alpha assumed to be a semiring, and now you're working with nat, so you could put <code>instance : semiring nat := by apply_instance</code> at the top of the file. However that instance should already be there so I can't imagine it will help :-/</p>

<a name="159252098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252098">Kevin Buzzard (Feb 24 2019 at 00:27)</a>:</h4>
<p>oh this can't be the problem. Unless your actual instances are hard to find.</p>

<a name="159252205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252205">Wojciech Nawrocki (Feb 24 2019 at 00:30)</a>:</h4>
<p>I couldn't say for sure without benchmarking, but I would guess that the two implicit arguments I added to <em>everything</em> makes it appreciably more difficult to carry out elaboration.</p>

<a name="159252209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252209" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252209">Kevin Buzzard (Feb 24 2019 at 00:30)</a>:</h4>
<p>I'm afraid you'll have to speak to a computer scientist about this one :-)</p>

<a name="159252211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252211">Kevin Buzzard (Feb 24 2019 at 00:31)</a>:</h4>
<p>In maths, everything runs instantly.</p>

<a name="159252220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252220" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252220">Kevin Buzzard (Feb 24 2019 at 00:31)</a>:</h4>
<p>You should consider moving to the Platonic universe.</p>

<a name="159252221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252221">Kevin Buzzard (Feb 24 2019 at 00:31)</a>:</h4>
<p>We don't have engineering troubles there.</p>

<a name="159252992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252992" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252992">Wojciech Nawrocki (Feb 24 2019 at 00:55)</a>:</h4>
<p>Oh okay, I ran into the problem that made me think unification fails again. In fact, I believe it could eventually succeed, but currently <code>simp *</code> takes so long it times out, while it would work fine before I added the implicit parameters to one of my modules.</p>

<a name="159253178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159253178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159253178">Kevin Buzzard (Feb 24 2019 at 01:00)</a>:</h4>
<p>If you want to try to speed things up yourself, you could take a look at what simp was doing before and after by putting logging on.</p>

<a name="159253197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159253197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159253197">Kevin Buzzard (Feb 24 2019 at 01:01)</a>:</h4>
<p><code>set_option trace.simplify.rewrite true</code> is what you need to see what simp is doing.</p>

<a name="159302724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159302724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159302724">Wojciech Nawrocki (Feb 24 2019 at 23:55)</a>:</h4>
<p>Does Lean have an equivalent of Haskell's/Agda's <code>where</code>? E.g. <code>def abc := two where two := 2</code></p>

<a name="159303137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159303137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159303137">Mario Carneiro (Feb 25 2019 at 00:06)</a>:</h4>
<p>no</p>

<a name="159303140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159303140" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159303140">Mario Carneiro (Feb 25 2019 at 00:06)</a>:</h4>
<p>it messes with elaboration order</p>

<a name="159303855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159303855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159303855">Wojciech Nawrocki (Feb 25 2019 at 00:27)</a>:</h4>
<p>Could you <em>elaborate</em> on what the issue is?</p>

<a name="159304378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159304378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159304378">Mario Carneiro (Feb 25 2019 at 00:43)</a>:</h4>
<p>Lean does pretty much all elaboration from left to right. If you use a postfix <code>let</code>, then the type and value of the defined variable will not be known when it is needed</p>

<a name="159304384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159304384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159304384">Mario Carneiro (Feb 25 2019 at 00:43)</a>:</h4>
<p>Is this stupid? Yes. I think lean 4 will relax the elaboration order a bit to allow stuff like this to work</p>

<a name="159645662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159645662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159645662">Wojciech Nawrocki (Feb 28 2019 at 19:47)</a>:</h4>
<p>Does anyone know where the extra argument comes from (I do know <code>(n = 0)</code> is probably not valid syntax for a hypothesis)?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">foo_fn</span> <span class="o">:=</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span> <span class="n">string</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">foo_fn</span>
<span class="c">/-</span><span class="cm"> def foo_fn : Type :=</span>
<span class="cm">   ℕ → Π (n : ℕ), n = 0 → string -/</span>
<span class="c1">-- ^ what is this?</span>
</pre></div>

<a name="159645923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159645923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159645923">Chris Hughes (Feb 28 2019 at 19:51)</a>:</h4>
<p>Do you have a <code>variable</code> somewhere in your file?</p>

<a name="159646059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159646059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159646059">Chris Hughes (Feb 28 2019 at 19:52)</a>:</h4>
<p>Oh no actually. <code>Π (n = 0), _</code> is shorthand for <code>Π n, n = 0 -&gt; _</code></p>

<a name="159646200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159646200" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159646200">Wojciech Nawrocki (Feb 28 2019 at 19:54)</a>:</h4>
<p>Ah so it <em>is</em> valid syntax. Thanks!</p>

<a name="159657235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159657235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159657235">Wojciech Nawrocki (Feb 28 2019 at 22:08)</a>:</h4>
<p>I would like to define a subtype of Lean functions like so:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span>
<span class="n">def</span> <span class="n">foo_fn</span> <span class="o">:=</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>

<span class="kn">inductive</span> <span class="n">is_foo</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">Id</span><span class="o">:</span> <span class="n">is_foo</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">Rec</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span><span class="o">},</span> <span class="n">is_foo</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">is_foo</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">foo</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span><span class="o">)</span>
<span class="o">(</span><span class="n">hf</span><span class="o">:</span> <span class="n">is_foo</span> <span class="n">f</span><span class="o">)</span>
</pre></div>


<p>Where a <code>foo</code> is a <code>ℕ → ℕ</code> together with a proof that it's a valid kind of <code>foo_fn</code>, i.e. either the identity or some other <code>foo</code> plus 1. Then, I would also like to carry out transformations on the <code>foo</code> structure by modifying the <code>foo_fn</code> and adjusting its proof. Unfortunately the <code>foo_fn</code> is opaque as just a Lean function, so to actually do this it seems I need the following:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">foo&#39;</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Id</span><span class="o">:</span> <span class="n">foo&#39;</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">Rec</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span><span class="o">},</span> <span class="n">foo&#39;</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">foo&#39;</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>


<p>My question is, can <code>foo'</code> be considered equivalent to <code>foo</code> in the sense that I can extract <code>f: foo_fn</code> out of <code>foo' f</code> and use it as I would use the <code>f</code> member of the structure <code>foo</code>?</p>

<a name="159663701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159663701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159663701">Kevin Buzzard (Feb 28 2019 at 23:42)</a>:</h4>
<p>I don't understand the question. Are you not happy with this sort of thing:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">foo_fn</span> <span class="o">:=</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>

<span class="kn">inductive</span> <span class="n">is_foo</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">Id</span><span class="o">:</span> <span class="n">is_foo</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">Rec</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span><span class="o">},</span> <span class="n">is_foo</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">is_foo</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">foo</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span><span class="o">)</span>
<span class="o">(</span><span class="n">hf</span><span class="o">:</span> <span class="n">is_foo</span> <span class="n">f</span><span class="o">)</span>

<span class="n">def</span> <span class="n">add_one</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">foo</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">hf</span><span class="bp">⟩</span>
</pre></div>


<p>?</p>

<a name="159798929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159798929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159798929">Wojciech Nawrocki (Mar 02 2019 at 14:09)</a>:</h4>
<p>The problem is that I couldn't redefine <code>add_one</code> like this:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">add_one&#39;</span><span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">foo</span>
<span class="c">/-</span><span class="cm"> induction tactic failed, recursor &#39;is_foo.dcases_on&#39; can only eliminate into Prop -/</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Id</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Id</span><span class="bp">⟩</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">hf&#39;</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="o">(</span><span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">hf&#39;</span><span class="o">)</span><span class="bp">⟩</span>
</pre></div>


<p>And in general any definition which tries to extract an inner <code>foo_fn</code> out of an <code>is_foo</code> constructor will fail, but I need to do that sometimes in order to transform the <code>foo_fn</code>. So far the <code>inductive foo': foo_fn -&gt; Type</code> definition seems to work well though.</p>

<a name="159799119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159799119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159799119">Kevin Buzzard (Mar 02 2019 at 14:15)</a>:</h4>
<p>Aah I see; the recursor for <code>is_foo</code> only eliminates into <code>Prop</code>. Yeah you need an expert, not a mathematician :-)</p>

<a name="159799673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159799673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159799673">Chris Hughes (Mar 02 2019 at 14:26)</a>:</h4>
<p>The reason this isn't possible in general, is that by proof irrelevance <code>is_foo.Id = is_foo.rec _</code> if the proofs have the same type, so I cannot define functions that treat these two cases differently.</p>
<p>Since both cases are equal in your function, you can write</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">add_one&#39;</span><span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">foo</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h</span> <span class="o">(</span><span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Id</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hf&#39;</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="o">(</span><span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">hf&#39;</span><span class="o">))</span><span class="bp">⟩</span>
</pre></div>

<a name="159799742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159799742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159799742">Chris Hughes (Mar 02 2019 at 14:28)</a>:</h4>
<p>Usually this form is preferred however</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">add_one&#39;</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span> <span class="o">:=</span>
 <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="mi">1</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">f</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Id</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hf&#39;</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="o">(</span><span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">hf&#39;</span><span class="o">))</span><span class="bp">⟩</span>
</pre></div>

<a name="159799766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159799766" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159799766">Chris Hughes (Mar 02 2019 at 14:30)</a>:</h4>
<p>The second <code>add_one'</code> will definitionally reduce in a nice way when applied to an argument <code>f : foo</code>, wherease the first definition will only reduce when applied to an argument of the form <code>⟨f, h⟩ : foo</code>. This makes the first definition harder to work with in proofs.</p>

<a name="159801343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159801343" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159801343">Wojciech Nawrocki (Mar 02 2019 at 15:12)</a>:</h4>
<p>Thanks!</p>

<a name="159866654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159866654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159866654">drocta (Mar 03 2019 at 21:57)</a>:</h4>
<p>I am trying to say something about free objects, using an existing definition of concrete categories in mathlib.<br>
I couldn't find an existing definition in mathlib for free objects (edit: really, I just need to define free objects over a set or type with one element), so I was going to define them myself.<br>
I have mathlib installed using leanpkg, and it looks like because I have lean version 3.4.1 installed, leanpkg used the branch with that name from the mathlib repository.<br>
However, I notice that the master branch and the 3.4.1 branch have the definition of concrete categories in different places.<br>
Should I go ahead and use the version which is defined in the 3.4.1 branch, and is in the category.lean file, or ought I somehow use the version in the concrete_category.lean version currently in the master branch?</p>

<a name="159868739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159868739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159868739">Kevin Buzzard (Mar 03 2019 at 22:56)</a>:</h4>
<p>The master branch of mathlib doesn't work with Lean 3.4.1.</p>

<a name="159868775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159868775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159868775">Kevin Buzzard (Mar 03 2019 at 22:58)</a>:</h4>
<p>If I were you I'd use 3.4.2 (probably the last release of Lean 3) and mathlib master. If you install elan then it will all work by magic and you won't have to worry.</p>

<a name="159870797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159870797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159870797">drocta (Mar 03 2019 at 23:56)</a>:</h4>
<p>thank you<br>
(edit 7:33 : that worked for me)</p>

<a name="159876903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159876903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159876903">drocta (Mar 04 2019 at 02:48)</a>:</h4>
<p>I'm not sure where to find the documentation on out_param . Could you point me towards it?<br>
the definition in core.lean looks like it is just an identity function, but I assume I'm missing something, seeing as I think the lack of it just caused me to get a type error.</p>

<a name="159884489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159884489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159884489">drocta (Mar 04 2019 at 03:50)</a>:</h4>
<p>found a way to do what I was trying to do which didn't require that, so nvm I guess?</p>

<a name="159891658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159891658" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159891658">Kevin Buzzard (Mar 04 2019 at 07:03)</a>:</h4>
<p><code>out_param</code> is something to do with telling Lean's elaborator what order to do type inference, or something like that. I'm afraid the only documentation that I know of is when I asked for details about it on either this chat or at the old chat, and Mario Carneiro explained it.</p>

<a name="159893666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159893666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159893666">Kevin Buzzard (Mar 04 2019 at 07:52)</a>:</h4>
<p><a href="https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351" target="_blank" title="https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351">https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351</a></p>

<a name="159971264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159971264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159971264">drocta (Mar 05 2019 at 02:35)</a>:</h4>
<blockquote>
<p><code>out_param</code> is something to do with telling Lean's elaborator what order to do type inference, or something like that. I'm afraid the only documentation that I know of is when I asked for details about it on either this chat or at the old chat, and Mario Carneiro explained it.<br>
<a href="https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351" target="_blank" title="https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351">https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351</a></p>
</blockquote>
<p>Ah! Thank you!</p>

<a name="160008880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160008880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160008880">Wojciech Nawrocki (Mar 05 2019 at 14:51)</a>:</h4>
<p>What is the meaning of this error: <code>rewrite tactic failed, motive is not type correct</code>?<br>
I get it when trying to apply <code>rw [sesh_tp.dual_end_recv]</code> where <code>sesh_tp.dual_end_recv : sesh_tp.dual End? = End!</code> to the following state:</p>
<div class="codehilite"><pre><span></span><span class="err">⊢</span> <span class="err">⟦</span><span class="mi">1</span><span class="bp">⬝</span><span class="err">↑</span><span class="o">(</span><span class="n">sesh_tp</span><span class="bp">.</span><span class="n">dual</span> <span class="n">End</span><span class="err">?</span><span class="o">)</span><span class="err">⟧</span><span class="bp">::</span><span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span> <span class="n">matrix</span><span class="bp">.</span><span class="n">identity</span> <span class="o">(</span><span class="err">↑</span><span class="o">(</span><span class="n">sesh_tp</span><span class="bp">.</span><span class="n">dual</span> <span class="n">End</span><span class="err">?</span><span class="o">)</span> <span class="bp">::</span> <span class="n">γ</span><span class="o">)</span> <span class="err">↑</span><span class="n">End</span><span class="bp">!</span> <span class="o">(</span><span class="n">ZVar</span> <span class="n">γ</span> <span class="err">↑</span><span class="n">End</span><span class="bp">!</span><span class="o">)</span>
</pre></div>


<p>I thought that <code>rw</code> should be able to simply replace the instances of <code>sesh_tp.dual End?</code>.<br>
(<code>End?</code> and <code>End!</code> are constructors for the <code>sesh_tp</code> inductive type.)</p>

<a name="160012954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160012954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160012954">Patrick Massot (Mar 05 2019 at 15:39)</a>:</h4>
<p>We need an emoji for this error</p>

<a name="160013094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160013094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160013094">Patrick Massot (Mar 05 2019 at 15:41)</a>:</h4>
<p>It means that doing the rewrite will give you an expression which doesn't type check, presumably because you had a dependent type and rewrote the parameter. The classical example is:</p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="kn">notation</span> <span class="n">false</span>
<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">implicit</span> <span class="n">true</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">))</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">add_comm</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>

  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="160013133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160013133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160013133">Patrick Massot (Mar 05 2019 at 15:41)</a>:</h4>
<p>Try understanding this simple example and then your complicated one</p>

<a name="160015041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160015041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160015041">Wojciech Nawrocki (Mar 05 2019 at 16:04)</a>:</h4>
<p>Oh right, I get the issue, thanks! But if you <code>rw add_comm</code> both sides of the equation, it should still type check, no? I managed to solve my problem by explicitly stating the type of the goal with both instances of <code>sesh_tp.dual End?</code> rewritten to <code>End!</code>. Could <code>rw</code> not check the type after doing <em>both</em> rewrites?</p>

<a name="160024039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160024039" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160024039">Kevin Buzzard (Mar 05 2019 at 17:52)</a>:</h4>
<p><code>rw</code> is what it is. If you want more you can try lots of tricks, e.g. <code>erw</code> or <code>simp only</code> or using <code>conv</code> mode -- we have lots of workarounds :-)  But this is dependent type theory, random rewriting can create terms which are not type correct and Lean pulls the plug when this happens.</p>

<a name="160029879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160029879" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160029879">Plam (Mar 05 2019 at 18:58)</a>:</h4>
<p>Is there a way to make use of the fact that pattern matches in a theorem have the same structure as in a definition? In particular, that given a catchall pattern match later in the theorem, it can't be the case that the thing being matched against matches one of the earlier pattern matches?</p>
<p>Concretely, when proving <code>simp_const_eq</code> below, I want to match on <code>plus (const a) (const b)</code>, <code>times (const a) (const b)</code> and then a catchall. Is this possible, or do I just need some extra cases that I can rfl my way through? </p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">aexpr</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">const</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">aexpr</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">aexpr</span>
<span class="bp">|</span> <span class="n">plus</span> <span class="o">:</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">aexpr</span>
<span class="bp">|</span> <span class="n">times</span> <span class="o">:</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">aexpr</span>

<span class="kn">open</span> <span class="n">aexpr</span>

<span class="n">def</span> <span class="n">aeval</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">v</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">plus</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">aeval</span> <span class="n">e₁</span> <span class="bp">+</span> <span class="n">aeval</span> <span class="n">e₂</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">times</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">aeval</span> <span class="n">e₁</span> <span class="bp">*</span> <span class="n">aeval</span> <span class="n">e₂</span>

<span class="n">def</span> <span class="n">simp_const</span> <span class="o">:</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">aexpr</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">plus</span> <span class="o">(</span><span class="n">const</span> <span class="n">n₁</span><span class="o">)</span> <span class="o">(</span><span class="n">const</span> <span class="n">n₂</span><span class="o">))</span> <span class="o">:=</span> <span class="n">const</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">times</span> <span class="o">(</span><span class="n">const</span> <span class="n">n₁</span><span class="o">)</span> <span class="o">(</span><span class="n">const</span> <span class="n">n₂</span><span class="o">))</span> <span class="o">:=</span> <span class="n">const</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">*</span> <span class="n">n₂</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">e</span>

<span class="kn">theorem</span> <span class="n">simp_const_eq</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">e</span> <span class="o">:</span> <span class="n">aexpr</span><span class="o">,</span> <span class="n">aeval</span> <span class="n">v</span> <span class="o">(</span><span class="n">simp_const</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">aeval</span> <span class="n">v</span> <span class="n">e</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>

<a name="161024741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161024741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161024741">Wojciech Nawrocki (Mar 18 2019 at 01:48)</a>:</h4>
<p>While I don't think this is possible right now (correct me if I'm wrong), would it in principle be possible to extend Lean with support for custom type unification procedures? The way I defined some inductive families requires me to do <em>a lot</em> of conversions from terms of type <code>T a</code> to a type <code>T b</code> that Lean expects, where <code>a = b</code>. All of these are resolvable more or less with a single tactic, and it would be awesome if I could just teach Lean a heuristic like "If type U is expected and a term of type T is given, see if T or U (or both) contain a specific expression. If so, try to use this tactic to convert T to U".</p>

<a name="161036029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161036029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161036029">Johan Commelin (Mar 18 2019 at 07:15)</a>:</h4>
<p>Search the chat for "unification hints"</p>

<a name="161036030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161036030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161036030">Johan Commelin (Mar 18 2019 at 07:15)</a>:</h4>
<p>I'm hoping that might be exactly the thing you want. Note however that we don't have much experience with them. Unification hints haven't been used outside of a demo, as far as I am aware.</p>

<a name="161036875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161036875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161036875">Mario Carneiro (Mar 18 2019 at 07:34)</a>:</h4>
<p>If by <code>a = b</code> you mean you have a proof that they are equal, not that they are defeq, then unification hints won't help, and a lot of things will get more complicated</p>

<a name="161053399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161053399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161053399">Wojciech Nawrocki (Mar 18 2019 at 12:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> indeed by <code>a = b</code> I mean <code>eq a b</code>. What I end up having in the actual terms is a bunch of <code>eq.mpr</code>s which do the conversions from <code>T a</code> to <code>T b</code>. My idea here was, could I not just tell Lean to try to insert those conversions automatically when it fails to unify types?</p>

<a name="161053547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161053547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161053547">Wojciech Nawrocki (Mar 18 2019 at 12:41)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I was looking into those but it seems they are not powerful enough to modify the term in question which is what seems to be needed when the types are not algorithmically definitonally equal according to Lean. Moreover, some of the problems that Coq resolves using Canonical Structures, which seem to be a type of unification hint, Lean resolves using type class inference.</p>

<a name="161055174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161055174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161055174">Kevin Buzzard (Mar 18 2019 at 13:04)</a>:</h4>
<p>There was some discussion about these issues at Lean Together in January. Note that Lean 4 will apparently be removing unification hints, perhaps because nobody uses them in Lean.</p>

<a name="161055192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161055192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161055192">Kevin Buzzard (Mar 18 2019 at 13:04)</a>:</h4>
<p>The speakers who talked about it were Assia Mahboubi and Cyril Cohen, and I am pretty sure their slides are online and linked to here somewhere.</p>

<a name="161055258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161055258" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161055258">Johan Commelin (Mar 18 2019 at 13:05)</a>:</h4>
<p>See: <br>
<a href="#narrow/stream/113488-general/topic/unification.20hints/near/158613068" title="#narrow/stream/113488-general/topic/unification.20hints/near/158613068">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unification.20hints/near/158613068</a></p>

<a name="161059451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161059451" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161059451">Jesse Michael Han (Mar 18 2019 at 14:01)</a>:</h4>
<p>We also ran into this issue in Flypitch. I found it helpful to have a library of <code>simp</code> lemmas to normalize the location of the casts. I also had the occasional odd experience of being unable to prove an instance of a cast lemma by <code>refl</code> inside a larger proof, but was able to prove that lemma by <code>refl</code> separately, mark it as <code>simp</code>, and then <code>simp</code> would work...</p>

<a name="161072189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161072189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161072189">Patrick Massot (Mar 18 2019 at 16:18)</a>:</h4>
<blockquote>
<p>Note that Lean 4 will apparently be removing unification hints, perhaps because nobody uses them in Lean.</p>
</blockquote>
<p>Is this really clear? I thought that Assia and Cyril provided ample proofs that this would be a tragic mistake. I understand they were removed at the beginning of Lean 4, but many things were removed, and some of them will return at some point. Is there any update on this <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span>?</p>

<a name="161072430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161072430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161072430">Sebastian Ullrich (Mar 18 2019 at 16:21)</a>:</h4>
<p>no</p>

<a name="161537406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161537406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161537406">Wojciech Nawrocki (Mar 23 2019 at 18:30)</a>:</h4>
<p>Why does <code>auto_param</code> seem to not work as an implicit argument? I'd like to have a constructor like <code>foo {h: auto_param some_prop ``mytac}: Foo</code> and match on it like <code>| foo</code> rather than <code>| (foo _)</code>, but if I put the <code>auto_param</code> in curly brackets, it seems to not actually run the tactic when using <code>def abc := foo</code> - it fails with "failed to synthesize placeholder" rather than trying to run <code>mytac</code>.</p>

<a name="161612010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161612010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161612010">drocta (Mar 25 2019 at 03:36)</a>:</h4>
<p>I want the unique function from the type <code>empty</code> to another type. I thought I might be able to do that with <code>empty.rec</code> or <code>empty.rec_on</code> , (going off of the tutorial's use of that with days of the week), but it looks like those both expect to be given a function from empty as an argument, when that is what I'm trying to get.<br>
What am I missing?</p>

<a name="161616137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161616137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161616137">Johan Commelin (Mar 25 2019 at 05:38)</a>:</h4>
<p>I think this is what you want:</p>
<div class="codehilite"><pre><span></span><span class="n">src</span><span class="bp">/</span><span class="n">logic</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="n">def</span> <span class="n">empty</span><span class="bp">.</span><span class="n">elim</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">empty</span> <span class="bp">→</span> <span class="n">C</span><span class="bp">.</span>
</pre></div>

<a name="161817781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161817781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161817781">Wojciech Nawrocki (Mar 27 2019 at 00:51)</a>:</h4>
<p><code>congr</code> gave me the following goal:</p>
<div class="codehilite"><pre><span></span><span class="n">γ</span> <span class="o">:</span> <span class="n">precontext</span><span class="o">,</span>
<span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span> <span class="n">γ</span><span class="o">,</span>
<span class="n">M</span> <span class="o">:</span> <span class="bp">@</span><span class="n">term</span> <span class="n">γ</span> <span class="err">Γ</span> <span class="err">↑</span><span class="n">End</span><span class="err">?</span>
<span class="err">⊢</span> <span class="bp">@</span><span class="n">Wait</span> <span class="n">γ</span> <span class="err">Γ</span> <span class="n">M</span> <span class="bp">==</span> <span class="bp">@</span><span class="n">eq</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="bp">@</span><span class="n">term</span> <span class="n">γ</span> <span class="o">(</span><span class="err">Γ</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">)</span> <span class="n">tp</span><span class="bp">.</span><span class="n">unit</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">term</span> <span class="n">γ</span> <span class="err">Γ</span> <span class="n">tp</span><span class="bp">.</span><span class="n">unit</span><span class="o">)</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">Wait</span> <span class="n">γ</span> <span class="err">Γ</span> <span class="n">M</span><span class="o">)</span>
</pre></div>


<p>Having never worked with <code>heq</code>, I'm not sure if this is provable? Clearly both sides are the same expression, but one has been passed through <code>eq.mpr</code> to cast its type. If it's provable, what would be a good tactic/term to solve it? <em>EDIT</em>: It's probably worth noting that it has been casted to the wrong type, i.e. RHS has the same type as LHS before the cast, but a different one after. Can I undo <code>eq.mpr</code> in here somehow?</p>

<a name="161819590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161819590" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161819590">Wojciech Nawrocki (Mar 27 2019 at 01:25)</a>:</h4>
<p>Ah <code>h_generalize</code> did it. I would still be interested in hearing if there's a more automated way of doing it.</p>

<a name="161819890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161819890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161819890">Jesse Michael Han (Mar 27 2019 at 01:30)</a>:</h4>
<p><code>cc</code> can sometimes handle heqs of casts which are close to being definitional equalities</p>

<a name="161819901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161819901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161819901">Jesse Michael Han (Mar 27 2019 at 01:30)</a>:</h4>
<p>however, it works better when <code>eq.mpr</code>s are hidden beneath <code>cast</code>s</p>

<a name="161820139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161820139" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161820139">Wojciech Nawrocki (Mar 27 2019 at 01:35)</a>:</h4>
<p>What's the difference between <code>cast</code> and <code>eq.mpr</code>?</p>

<a name="161820220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161820220" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161820220">Kenny Lau (Mar 27 2019 at 01:37)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="kn">inline</span><span class="o">]</span>
<span class="n">def</span> <span class="n">cast</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">},</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">eq</span><span class="bp">.</span><span class="n">rec</span> <span class="n">a</span> <span class="n">h</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">inline</span><span class="o">]</span>
<span class="n">def</span> <span class="n">eq</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">},</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="bp">_</span> <span class="n">h₂</span>
</pre></div>

<a name="161820396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161820396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161820396">Wojciech Nawrocki (Mar 27 2019 at 01:40)</a>:</h4>
<p>Oh, it's just reversed? Okay then :)</p>

<a name="161820412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161820412" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161820412">Kenny Lau (Mar 27 2019 at 01:41)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="kn">inline</span><span class="o">]</span>
<span class="n">def</span> <span class="n">eq</span><span class="bp">.</span><span class="n">mp</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">},</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">},</span> <span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span>
</pre></div>

<a name="161835910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161835910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161835910">Kevin Buzzard (Mar 27 2019 at 07:40)</a>:</h4>
<p>There are people here who would say that if you're dealing with heqs, you're doing it wrong</p>

<a name="161835917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161835917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161835917">Kevin Buzzard (Mar 27 2019 at 07:40)</a>:</h4>
<p>Equality of types is evil in type theory</p>

<a name="161835932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161835932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161835932">Kevin Buzzard (Mar 27 2019 at 07:41)</a>:</h4>
<p>And maybe you'd be better off making an equiv if you have two types which you have identified in your mind</p>

<a name="161835946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161835946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161835946">Kevin Buzzard (Mar 27 2019 at 07:41)</a>:</h4>
<p>Many of the key facts about equality are also proved for equivs</p>

<a name="161835947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161835947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161835947">Kevin Buzzard (Mar 27 2019 at 07:41)</a>:</h4>
<p>The key missing one is <code>rw</code></p>

<a name="161835992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161835992" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161835992">Kevin Buzzard (Mar 27 2019 at 07:42)</a>:</h4>
<p>But we're working on it</p>

<a name="161858773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161858773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161858773">Wojciech Nawrocki (Mar 27 2019 at 13:30)</a>:</h4>
<p>Yeah, I (ab)use dependent types in a way that makes it necessary to prove type equality quite often. I try to give my functions built-in &amp; semi-automated support for this by adding arguments like <code>(h: auto_param (expected_T = actual_T) ``some_tac)</code>, but it's not always possible</p>

<a name="161866241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161866241" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161866241">Wojciech Nawrocki (Mar 27 2019 at 14:48)</a>:</h4>
<p>While I'm at it, how can I <code>rw</code> using a <code>heq</code>? Given <code>Hx: M == x</code>, <code>rw [Hx]</code> tells me that <code>lemma is not an equality nor an iff</code>.</p>

<a name="161866351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161866351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161866351">Chris Hughes (Mar 27 2019 at 14:49)</a>:</h4>
<p>With great difficulty. You can try using <code>heq.rec_on</code>, but I think this is usually quite hard, because the resulting expression often won't type check.</p>

<a name="161870735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161870735" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161870735">Simon Hudon (Mar 27 2019 at 15:28)</a>:</h4>
<p>This is a lesson you have to learn eventually: just because you can write it this way and that it is type correct doesn't mean it's a good idea. Keep the type of your definitions as simple as possible. Move your added logic to separate lemmas or separate definitions.</p>

<a name="161872490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161872490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161872490">Jesse Michael Han (Mar 27 2019 at 15:47)</a>:</h4>
<p><code>heq.subst</code> will let you simulate some rewriting, but as Chris said, it is very painful</p>

<a name="161896451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161896451" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161896451">Kevin Buzzard (Mar 27 2019 at 20:15)</a>:</h4>
<p>If you know you are abusing dependent types then maybe you are bringing the pain on yourself. I had a maths repo where I used equality of types, because I was learning type theory and didn't understand the difference between equality and definitional equality; I ran into real trouble, which was only fixed by a refactor. What I am pushing for now is a tactic which will rewrite appropriate terms along equivs (or however you say it: if P is a predicate on rings which is mathematically reasonable then for two isomorphic rings R and S, P R will be true iff P S is, and I want a tactic which will show this -- this is something mathematicians do all the time but which seems to be painful in type theory).</p>

<a name="161905929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161905929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161905929">Wojciech Nawrocki (Mar 27 2019 at 22:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Well, kind of, but not necessarily. I'm still a newcomer to type theory/theorem proving, but from what I read and some discussions I've had, my understanding is that currently Coq can handle these kinds of things much better than Lean. Adding good support for working with dependent types which are only propositionally equal could be well worth the effort. In particular, Coq has a <a href="https://coq.inria.fr/refman/addendum/program.html" target="_blank" title="https://coq.inria.fr/refman/addendum/program.html">Program</a> framework (which I think I've mentioned here at some point) which is able to find which <code>eq</code>s need to be proven while constructing an expression and generate them as external goals. This way we get a clean expression and all the nasty details are resolved externally. After the goals are proven, <code>Program</code> seems to automatically insert <code>casts</code>, more or less. Moreover, Coq can be told which tactics to use in order to automatically resolve most of such side equality goals. In PVS, I believe these things are called "Type Correctness Conditions" and are also dealt with outside the expression. HoTT also seems to provide an interesting answer to this in the form of paths, but I've only started looking into that.</p>

<a name="161926249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161926249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161926249">Andrew Ashworth (Mar 28 2019 at 05:56)</a>:</h4>
<p>Is <code>Program</code> ready for prime time? I only read about it in CPDT, Chlipala is not big on it. <a href="http://adam.chlipala.net/cpdt/html/Subset.html" target="_blank" title="http://adam.chlipala.net/cpdt/html/Subset.html">http://adam.chlipala.net/cpdt/html/Subset.html</a></p>

<a name="162060279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162060279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162060279">Wojciech Nawrocki (Mar 29 2019 at 16:21)</a>:</h4>
<p>In Coq, <a href="https://coq.inria.fr/library/Coq.Logic.JMeq.html" target="_blank" title="https://coq.inria.fr/library/Coq.Logic.JMeq.html"><code>JMeq_eq</code></a> is an axiom, but in Lean <a href="https://github.com/leanprover/lean/blob/master/library/init/core.lean#L205" target="_blank" title="https://github.com/leanprover/lean/blob/master/library/init/core.lean#L205"><code>eq_of_heq</code></a> seems to be a lemma with no non-core axioms below it. Does that mean it follows from proof irrelevance or another axiom that Lean has built-in?</p>

<a name="162069155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162069155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162069155">Mario Carneiro (Mar 29 2019 at 17:56)</a>:</h4>
<p><span class="user-mention" data-user-id="128280">@Wojciech Nawrocki</span> Yes, it relies on proof irrelevance.</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">eq_of_heq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">a&#39;</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">a&#39;</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a&#39;</span> <span class="o">:=</span>
<span class="k">have</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">α&#39;</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">a&#39;</span> <span class="o">:</span> <span class="n">α&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">@</span><span class="n">heq</span> <span class="n">α</span> <span class="n">a</span> <span class="n">α&#39;</span> <span class="n">a&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">α&#39;</span><span class="o">),</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h₂</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α&#39;</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a&#39;</span><span class="o">,</span> <span class="k">from</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">α&#39;</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">a&#39;</span> <span class="o">:</span> <span class="n">α&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">@</span><span class="n">heq</span> <span class="n">α</span> <span class="n">a</span> <span class="n">α&#39;</span> <span class="n">a&#39;</span><span class="o">),</span> <span class="n">heq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h₁</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h₂</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">α</span><span class="o">,</span> <span class="n">rfl</span><span class="o">),</span>
<span class="k">show</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="o">)</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a&#39;</span><span class="o">,</span> <span class="k">from</span>
  <span class="n">this</span> <span class="n">α</span> <span class="n">a&#39;</span> <span class="n">h</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="o">)</span>
</pre></div>


<p>the <code>rfl</code> on line 3 has type <code>eq.rec_on h₂ a = a</code>, which only makes sense because <code>h₂  : α = α</code> is defeq to <code>rfl</code> by proof irrelevance</p>

<a name="162070989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162070989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162070989">Wojciech Nawrocki (Mar 29 2019 at 18:16)</a>:</h4>
<p>Gotcha, thanks!</p>

<a name="162185922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162185922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162185922">Wojciech Nawrocki (Mar 31 2019 at 18:16)</a>:</h4>
<p>How can I introduce a new constant into all goals using <code>;</code>? <code>sometac; have a := 2,</code> doesn't seem to work. <em>EDIT</em>: <code>all_goals { have a := 2 }</code> worked. Unsure why <code>;</code> doesn't.</p>

<a name="162186078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162186078" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162186078">Chris Hughes (Mar 31 2019 at 18:20)</a>:</h4>
<p>This worked for me</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">false</span> <span class="bp">∧</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="k">have</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>However, this didn't work</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">false</span> <span class="bp">∧</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span> <span class="n">skip</span><span class="bp">;</span> <span class="k">have</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>Maybe the semicolon only works for the goals generated by the last tactic.</p>

<a name="162186080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162186080" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162186080">Rob Lewis (Mar 31 2019 at 18:20)</a>:</h4>
<p><code>sometac; have a := 2</code> works. Remember <code>have</code> is different from <code>let</code>. You'll get <code>a : ℕ</code> in the context, but won't see that it's 2.<br>
Edit: oh, I see the confusion. <code>;</code> doesn't mean "do the second tactic to all goals." I think <code>t; s</code> means "do <code>t</code> to the first goal, and then do <code>s</code> to all remaining goals."<br>
Edit 2: I'm thinking about too many things at once and writing unclearly, sorry. Chris phrased what I meant better. <code>t; s</code> focuses on the first goal, applies t, and then applies <code>s</code> to all goals generated from that. "Remaining goals" meaning remaining in the focus.</p>

<a name="162186223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162186223" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162186223">Wojciech Nawrocki (Mar 31 2019 at 18:24)</a>:</h4>
<p>Double-checked, it acts wierdly:</p>
<div class="codehilite"><pre><span></span><span class="n">cases</span> <span class="n">h</span><span class="o">:</span> <span class="n">H</span><span class="bp">;</span> <span class="k">have</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">,</span> <span class="c1">-- works</span>
<span class="n">cases</span> <span class="n">h</span><span class="o">:</span> <span class="n">H</span><span class="o">,</span> <span class="n">skip</span><span class="bp">;</span> <span class="k">have</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">,</span> <span class="c1">-- doesn&#39;t work</span>
<span class="n">cases</span> <span class="n">h</span><span class="o">:</span> <span class="n">H</span><span class="o">,</span> <span class="n">case</span> <span class="n">Foo</span> <span class="o">{</span> <span class="bp">..</span> <span class="o">}</span><span class="bp">;</span> <span class="k">have</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">,</span> <span class="c1">-- doesn&#39;t work</span>
</pre></div>

<a name="162186513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162186513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162186513">Reid Barton (Mar 31 2019 at 18:33)</a>:</h4>
<p>What Chris said. <code>x; y</code> applies <code>y</code> to each goal produced by <code>x</code>.</p>

<a name="162186557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162186557" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162186557">Wojciech Nawrocki (Mar 31 2019 at 18:34)</a>:</h4>
<p>Oooh, ok! Thanks</p>

<a name="162186774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162186774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162186774">Wojciech Nawrocki (Mar 31 2019 at 18:41)</a>:</h4>
<p>Different question - in every goal I have a hypothesis of the form <code>h : hE' = Foo Γₑ' hΓ_1 N E_1 a</code>, where <code>Foo</code> is that goal's case. I would like to solve each goal by applying that goal/case's constructor, but with different arguments. Can I somehow "extract" which constructor was used for the case and reuse it to solve the goal without quoting expressions and all that?</p>

<a name="162242088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162242088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162242088">Wojciech Nawrocki (Apr 01 2019 at 14:09)</a>:</h4>
<p>How can I debug a <code>(deterministic) timeout</code> when Lean tries to prove well-foundedness of a recursion given my custom tactic?</p>

<a name="162242434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162242434" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162242434">Wojciech Nawrocki (Apr 01 2019 at 14:13)</a>:</h4>
<p>Oh actually I also get a "failed to prove well-foundedness" with the state:</p>
<div class="codehilite"><pre><span></span><span class="n">h</span> <span class="o">:</span> <span class="n">hE&#39;</span> <span class="bp">=</span> <span class="n">EAppLeft</span> <span class="err">Γₑ&#39;</span> <span class="n">h</span><span class="err">Γ</span><span class="bp">_</span><span class="mi">1</span> <span class="n">N</span> <span class="n">E_1</span> <span class="n">a</span><span class="o">,</span>
<span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span> <span class="n">γ</span><span class="o">,</span>
<span class="n">M</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">A&#39;&#39;</span>
<span class="err">⊢</span> <span class="n">eval_ctx</span><span class="bp">.</span><span class="n">sizeof</span>
      <span class="o">(((</span><span class="bp">⟨</span><span class="n">γ</span><span class="o">,</span>
          <span class="bp">⟨</span><span class="err">Γₑ</span><span class="o">,</span>
           <span class="bp">⟨</span><span class="err">Γ₁</span><span class="o">,</span>
            <span class="bp">⟨</span><span class="n">A&#39;&#39;</span><span class="o">,</span>
             <span class="bp">⟨</span><span class="n">A&#39;</span><span class="o">,</span>
              <span class="bp">⟨</span><span class="n">A_1</span><span class="err">⊸</span><span class="n">A</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">E</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hE</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">E_1</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="bp">⟨</span><span class="err">Γₑ</span> <span class="bp">+</span> <span class="err">Γ₁</span><span class="o">,</span> <span class="bp">_⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">fst</span><span class="o">)</span>
      <span class="o">(((((((((</span><span class="bp">⟨</span><span class="n">γ</span><span class="o">,</span>
                <span class="bp">⟨</span><span class="err">Γₑ</span><span class="o">,</span>
                 <span class="bp">⟨</span><span class="err">Γ₁</span><span class="o">,</span>
                  <span class="bp">⟨</span><span class="n">A&#39;&#39;</span><span class="o">,</span>
                   <span class="bp">⟨</span><span class="n">A&#39;</span><span class="o">,</span>
                    <span class="bp">⟨</span><span class="n">A_1</span><span class="err">⊸</span><span class="n">A</span><span class="o">,</span>
                     <span class="bp">⟨</span><span class="n">E</span><span class="o">,</span>
                      <span class="bp">⟨</span><span class="n">hE</span><span class="o">,</span>
                       <span class="bp">⟨</span><span class="n">E_1</span><span class="o">,</span>
                        <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span>
                         <span class="bp">⟨</span><span class="err">Γₑ</span> <span class="bp">+</span> <span class="err">Γ₁</span><span class="o">,</span>
                          <span class="bp">_⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">fst</span><span class="o">)</span>
      <span class="n">a</span> <span class="bp">&lt;</span>
    <span class="n">eval_ctx</span><span class="bp">.</span><span class="n">sizeof</span>
      <span class="o">(((</span><span class="bp">⟨</span><span class="n">γ</span><span class="o">,</span>
          <span class="bp">⟨</span><span class="err">Γₑ</span><span class="o">,</span>
           <span class="bp">⟨</span><span class="err">Γₑ&#39;</span><span class="o">,</span>
            <span class="bp">⟨</span><span class="n">A&#39;&#39;</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">A&#39;</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">A</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">E</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hE</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">E&#39;</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hE&#39;</span><span class="o">,</span> <span class="bp">⟨</span><span class="err">Γ</span><span class="o">,</span> <span class="n">h</span><span class="err">Γ</span><span class="bp">⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">fst</span><span class="o">)</span>
      <span class="o">(((((((((</span><span class="bp">⟨</span><span class="n">γ</span><span class="o">,</span>
                <span class="bp">⟨</span><span class="err">Γₑ</span><span class="o">,</span>
                 <span class="bp">⟨</span><span class="err">Γₑ&#39;</span><span class="o">,</span>
                  <span class="bp">⟨</span><span class="n">A&#39;&#39;</span><span class="o">,</span>
                   <span class="bp">⟨</span><span class="n">A&#39;</span><span class="o">,</span>
                    <span class="bp">⟨</span><span class="n">A</span><span class="o">,</span>
                     <span class="bp">⟨</span><span class="n">E</span><span class="o">,</span>
                      <span class="bp">⟨</span><span class="n">hE</span><span class="o">,</span>
                       <span class="bp">⟨</span><span class="n">E&#39;</span><span class="o">,</span>
                        <span class="bp">⟨</span><span class="n">hE&#39;</span><span class="o">,</span> <span class="bp">⟨</span><span class="err">Γ</span><span class="o">,</span> <span class="n">h</span><span class="err">Γ</span><span class="bp">⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">fst</span><span class="o">)</span>
      <span class="n">hE&#39;</span>
</pre></div>


<p>Since <code>h: hE' = EAppLeft ... a</code> is in the context, why can't Lean just rewrite it using that and then show that <code>sizeof a &lt; sizeof EAppLeft .. a</code>?</p>

<a name="162245368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162245368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162245368">Andrew Ashworth (Apr 01 2019 at 14:47)</a>:</h4>
<p>this error log is pretty hard to understand just by looking at it</p>

<a name="162245470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162245470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162245470">Andrew Ashworth (Apr 01 2019 at 14:48)</a>:</h4>
<p>what always gets linked when these things come up: TPIL and <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/well_founded_recursion.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/well_founded_recursion.md">https://github.com/leanprover-community/mathlib/blob/master/docs/extras/well_founded_recursion.md</a></p>

<a name="162246128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162246128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162246128">Andrew Ashworth (Apr 01 2019 at 14:55)</a>:</h4>
<p>what is not mentioned in the mathlib doc is what I usually do when I don't want to stare at a bunch of errors: prove my relation is well-founded by hand <code>well_founded r</code> and directly use <code>well_founded.fix</code></p>

<a name="162246653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162246653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162246653">Wojciech Nawrocki (Apr 01 2019 at 15:01)</a>:</h4>
<p>Oh yeah I'd read that, but was hoping Lean could employ a bit of automation when trying to prove the inequality. I'll try <code>fix</code> as I don't think I can use <code>have</code>( the fn definition is entirely in tactic mode), thanks.</p>

<a name="162247008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162247008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162247008">Andrew Ashworth (Apr 01 2019 at 15:04)</a>:</h4>
<p>oh, don't forget <a href="http://adam.chlipala.net/cpdt/html/GeneralRec.html" target="_blank" title="http://adam.chlipala.net/cpdt/html/GeneralRec.html">http://adam.chlipala.net/cpdt/html/GeneralRec.html</a></p>

<a name="162247040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162247040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162247040">Andrew Ashworth (Apr 01 2019 at 15:04)</a>:</h4>
<p>the definitions are sorta almost the same if you squint</p>

<a name="162316155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316155">snowbunting (Apr 02 2019 at 09:12)</a>:</h4>
<p>What would be the correct way to define a function from ℤ to (abelian) groups? (i.e. having indexed groups G_1, G_2, ...)</p>
<p>I don't think that this here is working as it should.  This would be a constant function, wouldn't it?</p>
<div class="codehilite"><pre><span></span>universes u
variables {α: Type u}
def my_indexes_groups (i:ℤ) := add_group α
#check my_indexes_groups 3
</pre></div>


<p>Thx :)</p>

<a name="162316216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316216">Johan Commelin (Apr 02 2019 at 09:12)</a>:</h4>
<p>No, because then all groups have the same cardinality</p>

<a name="162316224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316224">Kevin Buzzard (Apr 02 2019 at 09:12)</a>:</h4>
<p>You define a function from Z to <code>Type</code></p>

<a name="162316234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316234" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316234">Johan Commelin (Apr 02 2019 at 09:12)</a>:</h4>
<p>What you do is <code>G : Z → Type</code></p>

<a name="162316254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316254">Johan Commelin (Apr 02 2019 at 09:13)</a>:</h4>
<p>And then <code>[\for i, add_group G i]</code></p>

<a name="162316274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316274">Kevin Buzzard (Apr 02 2019 at 09:13)</a>:</h4>
<p>And then you define another function from Z to the structure of a group on the image of the first function :-)</p>

<a name="162316367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316367">Kevin Buzzard (Apr 02 2019 at 09:14)</a>:</h4>
<p>And you also note that Lean's definition of <code>add_group</code> doesn't require commutativity so if you're doing exact sequences you might want to use add_comm_group</p>

<a name="162316397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316397">Kevin Buzzard (Apr 02 2019 at 09:15)</a>:</h4>
<p>Johan and I are both interested in seeing exact sequences in Lean by the way, we're both mathematicians</p>

<a name="162316483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316483" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316483">Kevin Buzzard (Apr 02 2019 at 09:16)</a>:</h4>
<p>The way to think about groups in Lean is that they are two things. First you have G, a <em>type</em></p>

<a name="162316499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316499">Kevin Buzzard (Apr 02 2019 at 09:16)</a>:</h4>
<p>And then you have another thing h, a term of type [group G]</p>

<a name="162316522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316522">Kevin Buzzard (Apr 02 2019 at 09:17)</a>:</h4>
<p>And it's h that has all the data of the multiplication and the axioms</p>

<a name="162316532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316532">Kevin Buzzard (Apr 02 2019 at 09:17)</a>:</h4>
<p>But amazingly you never have to mention h at all when you're working with groups</p>

<a name="162316589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316589">Kevin Buzzard (Apr 02 2019 at 09:18)</a>:</h4>
<p>Because whenever Lean needs this data it gets it from G using something called type class inference</p>

<a name="162316617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316617">Kevin Buzzard (Apr 02 2019 at 09:18)</a>:</h4>
<p>You try to do a group thing on G like multiplying two elements together</p>

<a name="162316655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316655">snowbunting (Apr 02 2019 at 09:19)</a>:</h4>
<p>ok that works indeed! Maybe it would be actually ask to ask what the difference between <code>Type</code> and <code>Type u</code> is, although it feels super dumb...</p>

<a name="162316675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316675">Kevin Buzzard (Apr 02 2019 at 09:19)</a>:</h4>
<p>And Lean says "what's this multiplication they're talking about? Does my big list of type class stuff contain anything which mentions a multiplication on G? And then it looks and it finds h and says "ok I'll just use that stuff"</p>

<a name="162316719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316719">Kevin Buzzard (Apr 02 2019 at 09:20)</a>:</h4>
<p>Type is Type 0</p>

<a name="162316729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316729">Kevin Buzzard (Apr 02 2019 at 09:20)</a>:</h4>
<p>In type theory everything has to have a type</p>

<a name="162316736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316736">Kevin Buzzard (Apr 02 2019 at 09:20)</a>:</h4>
<p>So unfortunately Type has to have a type</p>

<a name="162316742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316742">Kevin Buzzard (Apr 02 2019 at 09:20)</a>:</h4>
<p>Which is Type 1</p>

<a name="162316743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316743" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316743">Kevin Buzzard (Apr 02 2019 at 09:20)</a>:</h4>
<p>You get the picture</p>

<a name="162316760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316760">Kevin Buzzard (Apr 02 2019 at 09:21)</a>:</h4>
<p>Type u is a random universe somewhere up in the hierarchy</p>

<a name="162316792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316792">Kevin Buzzard (Apr 02 2019 at 09:21)</a>:</h4>
<p>It's best practice to make functions and constructions take inputs from arbitrary universes in type theory</p>

<a name="162316875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316875">Kevin Buzzard (Apr 02 2019 at 09:22)</a>:</h4>
<p>You should do a map from Z to <code>Type u</code> really</p>

<a name="162316906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316906" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316906">Kevin Buzzard (Apr 02 2019 at 09:23)</a>:</h4>
<p>People might also write <code>Type*</code> -- this is the same thing, it just saves you having to name u</p>

<a name="162317141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162317141" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162317141">snowbunting (Apr 02 2019 at 09:28)</a>:</h4>
<p>ok so <code>u</code> really is just a number, like <code>Type u</code> one of <code>Type 0</code>, <code>Type 1</code>,  ...<br>
And if I don't want to force two variables to be both for example <code>Type 2</code> simultaneously, then I should use <code>Type u</code> and <code>Type v</code> in the definition, right?</p>
<p>And if I would write <code>def xxx (a: Type*) (b: Type*): Type* := sorry</code> then there is no constrains if they have the same type or not, is there?</p>
<p>Thx :)</p>

<a name="162317205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162317205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162317205">Kevin Buzzard (Apr 02 2019 at 09:28)</a>:</h4>
<p>That's right.</p>

<a name="162317229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162317229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162317229">Kevin Buzzard (Apr 02 2019 at 09:29)</a>:</h4>
<p>u is a natural number, but it's not a Lean natural number, it's a universe variable, which is treated differently; it's part of the core language or something.</p>

<a name="162342248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162342248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162342248">snowbunting (Apr 02 2019 at 14:53)</a>:</h4>
<blockquote>
<p>And then <code>[\for i, add_group G]</code></p>
</blockquote>
<p>This works great together with <code>variable</code>, but how would I now include that into a class? This does not seem to be working:</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>
<span class="n">class</span> <span class="n">chain</span> <span class="o">(</span><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">group</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">):</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
    <span class="o">(</span><span class="n">diff</span> <span class="o">{</span><span class="n">i</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">}:</span> <span class="o">(</span><span class="n">group</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">group</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">)))</span>
    <span class="o">[</span><span class="n">x</span><span class="o">:</span> <span class="bp">∀</span><span class="n">i</span><span class="o">,</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">group</span> <span class="n">i</span><span class="o">)]</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">C</span><span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="kn">variable</span> <span class="o">[</span><span class="n">chain</span> <span class="n">C</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">g</span> <span class="n">h</span><span class="o">:</span> <span class="n">chain</span><span class="bp">.</span><span class="n">group</span> <span class="n">C</span> <span class="mi">1</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">g</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">chain</span><span class="bp">.</span><span class="n">group</span> <span class="n">C</span> <span class="mi">1</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">chain</span><span class="bp">.</span><span class="n">diff</span> <span class="n">g</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">g</span> <span class="bp">+</span> <span class="n">h</span>    <span class="c1">-- has_add (chain.group C 1)</span>
</pre></div>

<a name="162342427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162342427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162342427">Johan Commelin (Apr 02 2019 at 14:54)</a>:</h4>
<p>Put it with <code>()</code> in the class. Then aftwerwards state:</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">foo</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_group</span> <span class="n">C</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">C</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span>
</pre></div>

<a name="162342450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162342450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162342450">Johan Commelin (Apr 02 2019 at 14:54)</a>:</h4>
<p>Modulo mistakes</p>

<a name="162342638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162342638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162342638">Johan Commelin (Apr 02 2019 at 14:56)</a>:</h4>
<p>Also, you might be interested in <code>category_theory/</code></p>

<a name="162342654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162342654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162342654">snowbunting (Apr 02 2019 at 14:56)</a>:</h4>
<p>Of course, I should have remembered <code>instance</code>, used that before, thank you!</p>

<a name="162358531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162358531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162358531">Kevin Buzzard (Apr 02 2019 at 17:59)</a>:</h4>
<p>Your alpha doesn't do anything</p>

<a name="162358571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162358571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162358571">Kevin Buzzard (Apr 02 2019 at 17:59)</a>:</h4>
<p>You could just remove it, and you could change class to structure</p>

<a name="162358765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162358765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162358765">Kevin Buzzard (Apr 02 2019 at 18:01)</a>:</h4>
<p>Then a term of type <code>chain</code> would be a bunch of abelian groups and homs</p>

<a name="162358791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162358791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162358791">Kevin Buzzard (Apr 02 2019 at 18:01)</a>:</h4>
<p>You use <code>class</code> when there's only expected to be one term of that type</p>

<a name="162378298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162378298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162378298">Scott Morrison (Apr 02 2019 at 22:05)</a>:</h4>
<blockquote>
<p>Also, you might be interested in <code>category_theory/</code></p>
</blockquote>
<p>Regarding initial experiments, this isn't meant at all as discouragement --- but eventually we'd like the definition of <code>chain_complex</code> to be as generic as possible (e.g. any category enriched in a category with_zero).</p>

<a name="162659075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162659075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162659075">Wojciech Nawrocki (Apr 05 2019 at 20:42)</a>:</h4>
<p>Is there anything I can do to debug "equation compiler failed to prove equation lemma (workaround: disable lemma generation using <code>set_option eqn_compiler.lemmas false</code>)"?</p>

<a name="162661482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162661482" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162661482">Kevin Buzzard (Apr 05 2019 at 21:10)</a>:</h4>
<p>Wow that's some error! How did you get that?</p>

<a name="162661525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162661525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162661525">Patrick Massot (Apr 05 2019 at 21:11)</a>:</h4>
<p>Kevin is so jalous...</p>

<a name="162666797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162666797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162666797">Wojciech Nawrocki (Apr 05 2019 at 22:24)</a>:</h4>
<p>:) It happens in <a href="https://github.com/Vtec234/lean-sesh/blob/master/src/sesh/eval.lean#L194" target="_blank" title="https://github.com/Vtec234/lean-sesh/blob/master/src/sesh/eval.lean#L194">this definition (link)</a></p>

<a name="162667290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162667290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162667290">Kevin Buzzard (Apr 05 2019 at 22:31)</a>:</h4>
<p>it doesn't compile for me because it needs imports I don't have :-/</p>

<a name="162667295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162667295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162667295">Kevin Buzzard (Apr 05 2019 at 22:31)</a>:</h4>
<p>but even if it did compile for me I think I wouldn't be able to help.</p>

<a name="162669637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162669637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162669637">Wojciech Nawrocki (Apr 05 2019 at 23:04)</a>:</h4>
<p>Oh, it's self-contained modulo downloading mathlib, but for some reason leanpkg.path was in my .gitignore and it's needed for import paths to resolve - fixed that</p>

<a name="162671215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162671215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162671215">Reid Barton (Apr 05 2019 at 23:31)</a>:</h4>
<p>leanpkg.path should indeed be in .gitignore (assuming you are actually using leanpkg)</p>

<a name="162678219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162678219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162678219">Mario Carneiro (Apr 06 2019 at 02:15)</a>:</h4>
<p>Is it related to the use of <code>let</code> in the type of the function you are defining by pattern matching?</p>

<a name="162720668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162720668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162720668">Wojciech Nawrocki (Apr 06 2019 at 21:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> it doesn't seem like it, I can inline the <code>let</code>, same error</p>

<a name="162720727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162720727" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162720727">Mario Carneiro (Apr 06 2019 at 21:10)</a>:</h4>
<p>do you have a self contained MWE?</p>

<a name="162720738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162720738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162720738">Mario Carneiro (Apr 06 2019 at 21:10)</a>:</h4>
<p>(Try putting everything needed in one file, then start deleting things that don't matter for the error)</p>

<a name="162944584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162944584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162944584">Wojciech Nawrocki (Apr 09 2019 at 19:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> thanks, that was good idea! It took a while but I was able to simplify it to this:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">foo</span><span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="n">def</span> <span class="n">foo_fn</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">foo</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">foo</span> <span class="n">n</span> <span class="n">m</span>

<span class="kn">inductive</span> <span class="n">is_foo_fn</span>
  <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="n">foo_fn</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">IsFooEta</span><span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="n">n</span> <span class="n">m</span><span class="o">},</span>
  <span class="n">is_foo_fn</span> <span class="n">f</span>
<span class="bp">→</span> <span class="n">is_foo_fn</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">M</span><span class="o">,</span> <span class="n">f</span> <span class="n">M</span><span class="o">)</span>
<span class="kn">open</span> <span class="n">is_foo_fn</span>

<span class="n">def</span> <span class="n">ext</span><span class="o">:</span> <span class="c1">-- equation compiler failed to prove equation lemma (workaround: disable lemma generation using `set_option eqn_compiler.lemmas false`)</span>
    <span class="bp">Π</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>
      <span class="o">{</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="n">n</span> <span class="n">m</span><span class="o">},</span>
    <span class="n">is_foo_fn</span> <span class="n">f</span>
  <span class="bp">→</span> <span class="err">Σ</span> <span class="n">f&#39;</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">is_foo_fn</span> <span class="n">f&#39;</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">IsFooEta</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">⟨_</span><span class="o">,</span> <span class="n">IsFooEta</span> <span class="o">(</span><span class="n">ext</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="bp">⟩</span>
</pre></div>


<p>which still fails, while making the following change makes the eqn compiler work:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">ext</span><span class="o">:</span> <span class="c1">-- good</span>
    <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>
      <span class="o">{</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="n">n</span> <span class="n">m</span><span class="o">},</span>
    <span class="n">is_foo_fn</span> <span class="n">f</span>
  <span class="bp">→</span> <span class="err">Σ</span> <span class="n">f&#39;</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">is_foo_fn</span> <span class="n">f&#39;</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">IsFooEta</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">⟨_</span><span class="o">,</span> <span class="n">IsFooEta</span> <span class="o">(</span><span class="n">ext</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="bp">⟩</span>
</pre></div>


<p>Can you spot the difference? :) (it's the order of arguments). To me this seems like an eqn_compiler bug<br>
And indeed this stupid-simple fix works on my actual code :D</p>

<a name="162947094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162947094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162947094">Wojciech Nawrocki (Apr 09 2019 at 20:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> What do you think? Is this a bug or am I missing something obvious?</p>

<a name="162947160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162947160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162947160">Kevin Buzzard (Apr 09 2019 at 20:31)</a>:</h4>
<p>Thanks for putting in the effort. I've never seen this error before.</p>

<a name="162947406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162947406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162947406">Sebastian Ullrich (Apr 09 2019 at 20:34)</a>:</h4>
<p>Me neither</p>

<a name="162947461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162947461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162947461">Patrick Massot (Apr 09 2019 at 20:34)</a>:</h4>
<p>Can you reproduce it in Lean 4?</p>

<a name="162947480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162947480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162947480">Patrick Massot (Apr 09 2019 at 20:35)</a>:</h4>
<p>If not, then who cares about this error?</p>

<a name="162947821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162947821" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162947821">Kevin Buzzard (Apr 09 2019 at 20:39)</a>:</h4>
<p>those of us who are stuck with Lean 3?</p>

<a name="162947830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162947830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162947830">Kevin Buzzard (Apr 09 2019 at 20:39)</a>:</h4>
<p>;-)</p>

<a name="162956880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162956880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162956880">Andrew Ashworth (Apr 09 2019 at 22:42)</a>:</h4>
<p>I don't have time to look into this deeply, but just remarking that I have seen 'equation compiler failed to prove equation lemma' before</p>

<a name="162956912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162956912" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162956912">Andrew Ashworth (Apr 09 2019 at 22:42)</a>:</h4>
<p>a very long time ago, I think the last time I saw it there was some problem with eta reduction</p>

<a name="162956941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162956941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162956941">Andrew Ashworth (Apr 09 2019 at 22:43)</a>:</h4>
<p>but i could be hallucinating how I fixed it, since it was awhile ago</p>

<a name="163636511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636511">Kevin Kappelmann (Apr 18 2019 at 09:51)</a>:</h4>
<p>Given</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">P</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">42</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="c1">-- this is obviously false</span>
<span class="k">begin</span>
<span class="n">unfold</span> <span class="n">P</span><span class="o">,</span> <span class="c1">-- this unfolds both occurrences</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>how can I unfold <code>P</code> just at the right-hand side?</p>

<a name="163636605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636605">Kevin Buzzard (Apr 18 2019 at 09:52)</a>:</h4>
<p>you can just use <code>change</code> or <code>show</code></p>

<a name="163636661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636661" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636661">Kevin Buzzard (Apr 18 2019 at 09:53)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">P</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">42</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="c1">-- this is obviously false</span>
<span class="k">begin</span>
  <span class="k">show</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">((</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="mi">42</span><span class="o">),</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="163636738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636738">Kevin Buzzard (Apr 18 2019 at 09:54)</a>:</h4>
<p>If you're planning on using the <code>rw</code> tactic, then Lean might be very fussy about exactly which form a term is in</p>

<a name="163636776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636776">Kevin Buzzard (Apr 18 2019 at 09:55)</a>:</h4>
<p>but conversely Lean is happy to switch between definitionally equal forms of the same term, using the <code>change</code> and <code>show</code> tactics (which do the same thing, <code>change</code> having the advantage that it also works for hypotheses in your context with <code>change ... at H</code>)</p>

<a name="163636784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636784">Kevin Kappelmann (Apr 18 2019 at 09:55)</a>:</h4>
<p>Ah okay, thanks. If my goal statement is very long though, I end up copy-pasting a lot of text.</p>

<a name="163636823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636823">Kevin Buzzard (Apr 18 2019 at 09:56)</a>:</h4>
<p>there are other ways</p>

<a name="163636873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636873" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636873">Kevin Buzzard (Apr 18 2019 at 09:57)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">P</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">42</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="c1">-- this is obviously false</span>
<span class="k">begin</span>
  <span class="n">conv</span> <span class="k">begin</span>
    <span class="n">to_rhs</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">P</span><span class="o">],</span>
  <span class="kn">end</span><span class="o">,</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="163636890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636890">Kevin Buzzard (Apr 18 2019 at 09:57)</a>:</h4>
<p><code>conv</code> mode is a mode which isn't mentioned at all in the official docs</p>

<a name="163636893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636893">Kevin Buzzard (Apr 18 2019 at 09:57)</a>:</h4>
<p>It enables you to zoom into parts of terms</p>

<a name="163636946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636946">Kevin Buzzard (Apr 18 2019 at 09:58)</a>:</h4>
<p>Unfortunately, when you're in conv mode, the tools available to you are completely different, and it doesn't look like <code>unfold</code> is available yet.</p>

<a name="163636948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636948">Kevin Buzzard (Apr 18 2019 at 09:58)</a>:</h4>
<p>So I had to use <code>simp only</code></p>

<a name="163636952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636952">Kevin Buzzard (Apr 18 2019 at 09:58)</a>:</h4>
<p>which is close to the same thing</p>

<a name="163636953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636953" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636953">Kevin Kappelmann (Apr 18 2019 at 09:58)</a>:</h4>
<p>uuh, the hidden secrets. that does not seem very elegant to me though :')</p>

<a name="163636958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636958">Kevin Buzzard (Apr 18 2019 at 09:58)</a>:</h4>
<p>The community documented <code>conv</code> mode.</p>

<a name="163636975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636975">Kevin Kappelmann (Apr 18 2019 at 09:58)</a>:</h4>
<p>I though I could make use of some pattern matching or occurrence counting when I was reading <a href="https://leanprover.github.io/tutorial/A1_Quick_Reference.html" target="_blank" title="https://leanprover.github.io/tutorial/A1_Quick_Reference.html">https://leanprover.github.io/tutorial/A1_Quick_Reference.html</a> A1.6.2.1</p>

<a name="163636989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636989">Kevin Kappelmann (Apr 18 2019 at 09:59)</a>:</h4>
<p>But I am either to silly or misinterpreting what is written there.</p>

<a name="163636992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636992" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636992">Kevin Buzzard (Apr 18 2019 at 09:59)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md">https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md</a></p>

<a name="163637060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637060">Kevin Buzzard (Apr 18 2019 at 10:00)</a>:</h4>
<p>Your link there is to an out of date file :-/ That's Lean 2 you're looking at</p>

<a name="163637073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637073">Kevin Buzzard (Apr 18 2019 at 10:00)</a>:</h4>
<p>You can use <code>conv</code> to zoom directly into the right hand side with <code>conv in</code> or <code>conv at</code> or something, I can never remember the details, but they're clearly documented in Patrick's conv.md write-up</p>

<a name="163637094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637094">Kevin Kappelmann (Apr 18 2019 at 10:01)</a>:</h4>
<p>Oh damn, google fooled me</p>

<a name="163637097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637097">Kevin Buzzard (Apr 18 2019 at 10:01)</a>:</h4>
<p>That way you avoid the <code>to_rhs</code> conv-mode tactic</p>

<a name="163637103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637103">Kevin Buzzard (Apr 18 2019 at 10:01)</a>:</h4>
<blockquote>
<p>Oh damn, google fooled me</p>
</blockquote>
<p>call them up and complain</p>

<a name="163637176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637176">Kevin Buzzard (Apr 18 2019 at 10:02)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="c1">-- this is obviously false</span>
<span class="k">begin</span>
  <span class="n">conv</span> <span class="k">in</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="k">begin</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">P</span><span class="o">],</span>
  <span class="kn">end</span><span class="o">,</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="163637250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637250">Kevin Buzzard (Apr 18 2019 at 10:03)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">P</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">42</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="c1">-- this is obviously false</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="n">P</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">42</span><span class="o">),</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">),</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="163637270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637270">Kevin Buzzard (Apr 18 2019 at 10:03)</a>:</h4>
<p>This way avoids conv mode and is more precise about what you want done</p>

<a name="163637329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637329" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637329">Kevin Buzzard (Apr 18 2019 at 10:04)</a>:</h4>
<p>What exactly are you looking for? Tactic-writers here are very good.</p>

<a name="163637360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637360">Kevin Buzzard (Apr 18 2019 at 10:04)</a>:</h4>
<p>People can just make new stuff. Lean tactics are written in Lean and some people (not me though! I'm a mathematician) can just knock them off before breakfast.</p>

<a name="163637832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637832" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637832">Kevin Kappelmann (Apr 18 2019 at 10:11)</a>:</h4>
<p>Basically, I had a rather long equation of the form <code>l=r</code> and I wanted to unfold an expression in <code>r</code> by its definition, which again, is a rather long term. Hence, I neither want to re-state the whole goal nor the result of the unfolded definition. What I want to do is something like</p>
<div class="codehilite"><pre><span></span><span class="k">begin</span>
<span class="n">unfold</span> <span class="n">P</span> <span class="o">{</span><span class="mi">2</span><span class="o">}</span> <span class="c1">-- this should unfold the second occurrence of P in the goal (or the third if you count from zero)</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="163637905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637905">Kevin Buzzard (Apr 18 2019 at 10:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> is that already a tactic, do you know?</p>

<a name="163637917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637917">Kevin Buzzard (Apr 18 2019 at 10:12)</a>:</h4>
<p>Is there any obstruction to making it?</p>

<a name="163638014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638014">Kevin Buzzard (Apr 18 2019 at 10:14)</a>:</h4>
<p><span class="user-mention" data-user-id="198376">@Kevin Kappelmann</span> you could just do all the unfolds manually, ignore what happens to <code>l</code>, and then once you've got <code>r</code> into the form you want you can just delet everything and write <code>show _ = [what you want r to be]</code></p>

<a name="163638029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638029">Kevin Buzzard (Apr 18 2019 at 10:14)</a>:</h4>
<p>(the point being that <code>show</code> will take <code>_</code> for the left hand side)</p>

<a name="163638165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638165" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638165">Kevin Buzzard (Apr 18 2019 at 10:16)</a>:</h4>
<p>I think I've now told you all the tricks I know -- but I can see that your proposed idea is nicer. It might be a pain though -- if you want to unfold a bunch of stuff in <code>r</code> but not in <code>l</code> you might have to keep changing the numbers, depending on which things you want to unfold in <code>r</code> also show up in <code>l</code>. I think that if you're adamant that you want to change <code>r</code> and leave <code>l</code> untouched, just use <code>conv</code> mode and <code>to_rhs</code>. That's only a couple of lines and I think it's better than your idea because of the issue with numbers perhaps changing depending on exactly you want to unfold.</p>

<a name="163638189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638189">Gabriel Ebner (Apr 18 2019 at 10:17)</a>:</h4>
<p>Yes, you can do this with <code>conv</code>.  Unfortunately, <code>unfold</code> isn't wrapped so you need to use <code>simp</code>.</p>
<div class="codehilite"><pre><span></span><span class="n">conv</span> <span class="o">{</span> <span class="n">for</span> <span class="o">(</span><span class="n">P</span> <span class="bp">_</span><span class="o">)</span> <span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">P</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
</pre></div>

<a name="163638194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638194">Kevin Buzzard (Apr 18 2019 at 10:17)</a>:</h4>
<p>OTOH I guess your idea has its merits when there is more than one occurrence of P in the RHS.</p>

<a name="163638210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638210">Kevin Buzzard (Apr 18 2019 at 10:17)</a>:</h4>
<p>Aah, I'd forgotten <code>conv</code> could take numbers!</p>

<a name="163638215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638215">Kevin Buzzard (Apr 18 2019 at 10:17)</a>:</h4>
<p>Thanks Gabriel</p>

<a name="163638303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638303">Kevin Buzzard (Apr 18 2019 at 10:18)</a>:</h4>
<p>hey what is this voodoo? <code>for</code>? I thought functional languages didn't have <code>for</code> loops!</p>

<a name="163638383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638383">Kevin Buzzard (Apr 18 2019 at 10:20)</a>:</h4>
<p>Aah yes, I see now that <code>for</code> is documented in the <code>conv</code> document I linked to earlier.</p>

<a name="163638461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638461">Kevin Buzzard (Apr 18 2019 at 10:20)</a>:</h4>
<p>It's about time I re-read it :D</p>

<a name="163638592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638592">Kevin Buzzard (Apr 18 2019 at 10:22)</a>:</h4>
<p>I'll show you a Lean trick Kevin. </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">P</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">42</span>

<span class="bp">#</span><span class="kn">print</span> <span class="kn">prefix</span> <span class="n">P</span>

<span class="c1">-- P.equations._eqn_1 : ∀ (n : ℕ), P n = (n &gt; 42)</span>
</pre></div>


<p>When you define <code>P</code>, Lean makes one or more "equation lemmas" for it. <code>unfold P</code> is basically the same as <code>simp only [P.equations._eqn_1]</code> or <code>simp only [P]</code> for short. It's a shame there's no <code>unfold</code> in <code>conv</code> mode, but these are the tricks you can use to emulate it.</p>

<a name="163638639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638639">Kevin Buzzard (Apr 18 2019 at 10:23)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">P</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">42</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="c1">-- this is obviously false</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">P</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_1</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">),</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="163638662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638662">Kevin Kappelmann (Apr 18 2019 at 10:23)</a>:</h4>
<p>Okay, I summarise: <code>conv</code> is pretty useful, I should read about it, and I guess it should also be included in the official docs at some point to avoid noobs like me wondering how to rewrite subterms :p</p>

<a name="163638723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638723">Kevin Buzzard (Apr 18 2019 at 10:24)</a>:</h4>
<p>The Lean team is currently working on Lean 4, I don't think they're interested in documentation-writing at the minute.</p>

<a name="163638734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638734" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638734">Kevin Buzzard (Apr 18 2019 at 10:24)</a>:</h4>
<p>If Lean 4 is a success then we'll all be porting the docs over to there</p>

<a name="163638750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638750">Kevin Buzzard (Apr 18 2019 at 10:25)</a>:</h4>
<p>The community-written docs are really helpful for technical questions not covered by Theorem Proving In Lean.</p>

<a name="163638771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638771">Kevin Buzzard (Apr 18 2019 at 10:25)</a>:</h4>
<p>They all live in the mathlib repo but they're not really anything to do with mathlib, they're just where these community-generated docs ended up.</p>

<a name="163638971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638971">Kevin Kappelmann (Apr 18 2019 at 10:29)</a>:</h4>
<p>I see. I think rewriting subterms is quite common though, so I would mention it at least in the official doc. Anyway, thanks Kevin &amp; Gabriel :)</p>

<a name="163648072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163648072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163648072">Jesse Michael Han (Apr 18 2019 at 12:52)</a>:</h4>
<p>you can use underscores with <code>change</code> and Lean will try to infer what should be there from the current goal. that way <code>change _ = new_rhs</code> lets you avoid copy-pasting the entire left hand side</p>

<a name="163860118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860118">Greg Conneen (Apr 21 2019 at 17:24)</a>:</h4>
<p>How would I go about proving ∀ x : ℤ, even x ∨ odd x? I have even and odd as<br>
def even : ℤ → Prop := λ n, ∃ m : ℤ, 2*m = n<br>
def odd : ℤ → Prop := λ n, ∃ m : ℤ, 2*m + 1 = n<br>
I assume that I would first have to show that odd is equivalent to not even, then apply classical.em. However, I'm having trouble proving odd x ↔ ¬(even x)</p>

<a name="163860254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860254">Kevin Buzzard (Apr 21 2019 at 17:28)</a>:</h4>
<p>My instinct would be to prove even n -&gt; odd (n+1) etc, and then prove by induction that every integer was odd or even.</p>

<a name="163860266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860266">Kevin Buzzard (Apr 21 2019 at 17:28)</a>:</h4>
<p>There are induction hypotheses of the form (P 0 and (forall n, P n -&gt; P(n+1)) and (forall N, P(n)-&gt;P(n-1))) implies P(n) for all n</p>

<a name="163860279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860279">Greg Conneen (Apr 21 2019 at 17:29)</a>:</h4>
<p>Ah, I see. That makes sense. I'm not familiar enough with induction in Lean yet, but I'll try it out</p>

<a name="163860281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860281" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860281">Greg Conneen (Apr 21 2019 at 17:29)</a>:</h4>
<p>thank you, I'll respond again if I'm stuck on the inductive bit</p>

<a name="163860285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860285">Kevin Buzzard (Apr 21 2019 at 17:29)</a>:</h4>
<p>If you just apply the induction tactic out of the box, you'll get an unpleasant surprise</p>

<a name="163860338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860338">Kevin Buzzard (Apr 21 2019 at 17:30)</a>:</h4>
<p>You'll end up with some question about natural numbers instead, and it will be pain converting from naturals to integers.</p>

<a name="163860351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860351">Kevin Buzzard (Apr 21 2019 at 17:30)</a>:</h4>
<p>You'll need to find an appropriate custom induction term in the library.</p>

<a name="163860369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860369">Greg Conneen (Apr 21 2019 at 17:31)</a>:</h4>
<p>Oh, okay. I'm not familiar enough with the library to get started with that. Where would I go to look for something like that?</p>

<a name="163860373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860373">Kevin Buzzard (Apr 21 2019 at 17:31)</a>:</h4>
<p><code>int.induction_on</code> should be fine for you.</p>

<a name="163860436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860436">Kevin Buzzard (Apr 21 2019 at 17:33)</a>:</h4>
<p><code>import data.int.basic</code> at the top of your file (you'll need the maths library mathlib) and then apply that function, and you'll be left with goals of the form "n even or n odd -&gt; n+1 even or n+1 odd" which you should be able to cope with. Prove n even -&gt; n+1 odd and the other three results (e.g. n odd -&gt; n-1 even) first and then use them all to prove the result.</p>

<a name="163860497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860497">Greg Conneen (Apr 21 2019 at 17:34)</a>:</h4>
<p>Neat. I have mathlib, but I find most of the algebra/analysis files unreadable despite being highly competent with the material on paper. Are there any other packages you would recommend before diving into that level of material?</p>

<a name="163860556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860556">Kevin Buzzard (Apr 21 2019 at 17:36)</a>:</h4>
<p>I would recommend doing just what you're doing -- writing material yourself. I agree that the library is impenetrable for a beginner. Proofs are specifically shortened for efficiency reasons, they are not written to be readable. We are still lacking a bunch of good teaching material for mathematicians; I intend to make some this summer, however I also said that last summer.</p>

<a name="163860618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860618">Kevin Buzzard (Apr 21 2019 at 17:38)</a>:</h4>
<p>Here's me trying to do some problem sheets which we give to 1st year mathematicians at Imperial: <a href="https://github.com/ImperialCollegeLondon/M1F_example_sheets" target="_blank" title="https://github.com/ImperialCollegeLondon/M1F_example_sheets">https://github.com/ImperialCollegeLondon/M1F_example_sheets</a></p>

<a name="163860637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860637">Greg Conneen (Apr 21 2019 at 17:39)</a>:</h4>
<p>Oh wow, that's a substantial amount of material. Thank you so much!</p>

<a name="163860684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860684">Kevin Buzzard (Apr 21 2019 at 17:40)</a>:</h4>
<p>The proofs are written in a far more longwinded way, they might be more instructional but there are still not many comments.</p>

<a name="163860685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860685">Kevin Buzzard (Apr 21 2019 at 17:40)</a>:</h4>
<p>You can step through them in tactic mode and watch the state change, of course.</p>

<a name="163860739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860739">Greg Conneen (Apr 21 2019 at 17:42)</a>:</h4>
<p>Right, I think that as long as I can just run through the tactic state I should be fine. Are there solutions for every single exercise?</p>

<a name="163860801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860801">Greg Conneen (Apr 21 2019 at 17:44)</a>:</h4>
<p>Also, despite there being a real numbers package in mathlib, I've never seen it before. That's super useful!</p>

<a name="163860817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860817">Greg Conneen (Apr 21 2019 at 17:45)</a>:</h4>
<p>oh wow, there's also complex numbers defined. That's amazing</p>

<a name="163860818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860818">Kevin Buzzard (Apr 21 2019 at 17:45)</a>:</h4>
<p>I don't think I managed every single exercise. There were some which were hard to formalise.</p>

<a name="163860865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860865">Kevin Buzzard (Apr 21 2019 at 17:46)</a>:</h4>
<p>Those answers are really just a big work in progress. They were just me trying to figure out if Lean was ready for a beginning undergraduate level maths course. It was.</p>

<a name="163860866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860866">Greg Conneen (Apr 21 2019 at 17:46)</a>:</h4>
<p>Are you a professor at Imperial?</p>

<a name="163860867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860867">Kevin Buzzard (Apr 21 2019 at 17:46)</a>:</h4>
<p>Yes</p>

<a name="163860881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860881">Greg Conneen (Apr 21 2019 at 17:47)</a>:</h4>
<p>Oh, that's awesome. I'm just an undergrad math student</p>

<a name="163860882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860882" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860882">Kevin Buzzard (Apr 21 2019 at 17:48)</a>:</h4>
<p>I felt like that when I was trying to get Lean to do my own problem sheets.</p>

<a name="163860993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860993" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860993">Greg Conneen (Apr 21 2019 at 17:50)</a>:</h4>
<p>Haha yeah, the professor here at UVA has a tough time teaching Lean. It seems like it's one of those things where many trivial proofs on paper are just very difficult to formalise, despite familiarity</p>

<a name="163861008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861008">Kevin Buzzard (Apr 21 2019 at 17:51)</a>:</h4>
<p>Yes. I spent about a year being very frustrated with not being able to make Lean do obvious things. I'm now finally over that initial learning hump and I can write even research level maths in Lean now, although it can take a long time.</p>

<a name="163861071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861071">Greg Conneen (Apr 21 2019 at 17:53)</a>:</h4>
<p>Well congrats. I hope to get to that point someday. What maths research have you been able to formalise in Lean?</p>

<a name="163861075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861075">Kevin Buzzard (Apr 21 2019 at 17:53)</a>:</h4>
<p><a href="https://github.com/leanprover-community/lean-perfectoid-spaces" target="_blank" title="https://github.com/leanprover-community/lean-perfectoid-spaces">https://github.com/leanprover-community/lean-perfectoid-spaces</a></p>

<a name="163861076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861076">Kevin Buzzard (Apr 21 2019 at 17:53)</a>:</h4>
<p>It's not finished yet but we're getting there.</p>

<a name="163861121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861121" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861121">Kevin Buzzard (Apr 21 2019 at 17:54)</a>:</h4>
<p>I've just spent the last 30 minutes staring at <a href="#narrow/stream/116395-maths/topic/Cute.20lemma/near/163135381" title="#narrow/stream/116395-maths/topic/Cute.20lemma/near/163135381">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cute.20lemma/near/163135381</a></p>

<a name="163861130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861130">Kevin Buzzard (Apr 21 2019 at 17:54)</a>:</h4>
<p>some technical lemma about topological spaces which we need.</p>

<a name="163861147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861147">Greg Conneen (Apr 21 2019 at 17:55)</a>:</h4>
<p>that's... absolutely amazing. I never imagined we could do something like this in Lean so soon.</p>

<a name="163861149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861149">Kevin Buzzard (Apr 21 2019 at 17:55)</a>:</h4>
<p>Yeah me neither</p>

<a name="163861150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861150">Kevin Buzzard (Apr 21 2019 at 17:55)</a>:</h4>
<p>I've had a huge amount of support from other people here</p>

<a name="163861156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861156" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861156">Kevin Buzzard (Apr 21 2019 at 17:56)</a>:</h4>
<p>18 months ago there weren't even complex numbers</p>

<a name="163861201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861201">Kevin Buzzard (Apr 21 2019 at 17:56)</a>:</h4>
<p>Now we have schemes <a href="https://github.com/ramonfmir/lean-scheme" target="_blank" title="https://github.com/ramonfmir/lean-scheme">https://github.com/ramonfmir/lean-scheme</a> and they work</p>

<a name="163861203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861203">Greg Conneen (Apr 21 2019 at 17:56)</a>:</h4>
<p>Wow. Yeah, I'm now very happy that I've been introduced to this chat by Dr. Hölzl</p>

<a name="163861205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861205">Greg Conneen (Apr 21 2019 at 17:56)</a>:</h4>
<p>Oh wow, algebraic geometry? I'll have to tell my advisor about this</p>

<a name="163861218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861218">Kevin Buzzard (Apr 21 2019 at 17:57)</a>:</h4>
<p>we have stuff which reflects the interests of the people involved, I guess.</p>

<a name="163861264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861264">Greg Conneen (Apr 21 2019 at 17:58)</a>:</h4>
<p>Thank you so much for all this info. I really appreciate it. I look forward to participating more in the future, when I get a little bit more acquainted with Lean.</p>

<a name="163861269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861269">Kevin Buzzard (Apr 21 2019 at 17:58)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/Taking.20the.20Stacks.20Project.20formalisation.20forward" title="#narrow/stream/116395-maths/topic/Taking.20the.20Stacks.20Project.20formalisation.20forward">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Taking.20the.20Stacks.20Project.20formalisation.20forward</a></p>

<a name="163861270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861270">Kevin Buzzard (Apr 21 2019 at 17:58)</a>:</h4>
<p>That's the schemes thread</p>

<a name="163861273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861273" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861273">Kevin Buzzard (Apr 21 2019 at 17:58)</a>:</h4>
<p>we're going to re-write it using the category theory library; at the minute we make all the categories by hand.</p>

<a name="163861283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861283" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861283">Kevin Buzzard (Apr 21 2019 at 17:59)</a>:</h4>
<p>There are universe issues, as ever in category theory, so it gets a bit hairy because you have to do it all properly in a system like this</p>

<a name="163861354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861354">Greg Conneen (Apr 21 2019 at 18:00)</a>:</h4>
<p>That makes sense. Cat theory makes for the introduction of some interesting nuances</p>

<a name="163861817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861817">Greg Conneen (Apr 21 2019 at 18:14)</a>:</h4>
<p>How do I apply one direction of an iff? Like, if I wanted to only apply the left implication in a proof.</p>

<a name="163862508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163862508" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163862508">Mario Carneiro (Apr 21 2019 at 18:36)</a>:</h4>
<p><code>bla.1</code> or <code>bla.mp</code></p>

<a name="163862512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163862512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163862512">Mario Carneiro (Apr 21 2019 at 18:36)</a>:</h4>
<p>which is short for <code>iff.mp bla</code></p>

<a name="163862527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163862527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163862527">Greg Conneen (Apr 21 2019 at 18:37)</a>:</h4>
<p>oh okay, so if my iff statement was titled bla, bla.1 would be the left implication, and bla.2 would be the right?</p>

<a name="163862878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163862878" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163862878">Greg Conneen (Apr 21 2019 at 18:48)</a>:</h4>
<p>Also, where can I find the xenalib package?</p>

<a name="163862942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163862942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163862942">Greg Conneen (Apr 21 2019 at 18:50)</a>:</h4>
<p>nvm, found it</p>

<a name="163902237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163902237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163902237">Greg Conneen (Apr 22 2019 at 13:02)</a>:</h4>
<p>Okay, I've got a Lean file I've tinkered around with in the past, which includes some simple proofs about integers. Some propositions I've failed to prove in Lean, and the rest I'm sure are anything but efficient. I was wondering if anyone would be willing to look over this file for me and give me some pointers on how to improve my proving techniques. <a href="/user_uploads/3121/oDrGTH44Zfg48XIg3ZaoHSYE/int_props.lean" target="_blank" title="int_props.lean">int_props.lean</a></p>

<a name="163902261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163902261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163902261">Greg Conneen (Apr 22 2019 at 13:03)</a>:</h4>
<p>It's sort of a long file, and not very organised, but any help at all would be really appreciated. Sorry in advance.</p>

<a name="163965002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163965002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163965002">Greg Conneen (Apr 23 2019 at 06:12)</a>:</h4>
<p>I'm having trouble defining structure fields. The generic construction of structures is fine, I just don't understand fields. How would I go about appending them to a given structure?</p>

<a name="163965231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163965231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163965231">Johan Commelin (Apr 23 2019 at 06:16)</a>:</h4>
<p>Do you mean extending a structure?</p>

<a name="163965232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163965232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163965232">Johan Commelin (Apr 23 2019 at 06:16)</a>:</h4>
<p>Search for "extend" in mathlib and you will find lots of examples</p>

<a name="163966248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163966248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163966248">Greg Conneen (Apr 23 2019 at 06:41)</a>:</h4>
<p>oh, cool. Thank you. I didn't even know what I was looking for until you showed me</p>

<a name="163967041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163967041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163967041">Kevin Buzzard (Apr 23 2019 at 06:58)</a>:</h4>
<p>You might want to read the chapters on inductive types and structures in TPIL.</p>

<a name="163968134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163968134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163968134">Patrick Massot (Apr 23 2019 at 07:22)</a>:</h4>
<p><span class="user-mention" data-user-id="218940">@Greg Conneen</span> what Kevin really means is: if you have any interest in learning Lean, you want to read all of TPIL. The modern way of doing that is to launch VScode, open any Lean file, type Ctrl-shift-p type lean, select "Open documentation view", click "Theorem proving in Lean". This way you can click "Try it!" links on code snippets to open them right in VScode and play with them.</p>

<a name="163968575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163968575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163968575">Patrick Massot (Apr 23 2019 at 07:32)</a>:</h4>
<p>Trying to figure out the community map: Greg, are you a student of the Kevin Sullivan?</p>

<a name="163985682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163985682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163985682">Greg Conneen (Apr 23 2019 at 12:47)</a>:</h4>
<p>I was Prof. Sullivan's student last year, yes.</p>

<a name="163985995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163985995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163985995">Greg Conneen (Apr 23 2019 at 12:49)</a>:</h4>
<p>I've read the entirety of TPIL. I'm just still having trouble with implementation. I guess I'll tinker around with it a bit more</p>

<a name="163988098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163988098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163988098">Greg Conneen (Apr 23 2019 at 13:09)</a>:</h4>
<p>Okay, so if a group is defined like this</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">group</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">fields</span><span class="o">:</span>
<span class="n">group</span><span class="bp">.</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="n">group</span><span class="bp">.</span><span class="n">mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c_1</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c_1</span><span class="o">)</span>
<span class="n">group</span><span class="bp">.</span><span class="n">one</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span>
<span class="n">group</span><span class="bp">.</span><span class="n">one_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span>
<span class="n">group</span><span class="bp">.</span><span class="n">mul_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span>
<span class="n">group</span><span class="bp">.</span><span class="n">inv</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="n">group</span><span class="bp">.</span><span class="n">mul_left_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">a</span>
</pre></div>


<p>the way I would make something like this would be</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">fake_group</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">...</span>
</pre></div>


<p>except, I want to change group α to fake_group α and I don't understand how to do that. I also in general don't understand the bracket notation or what pi does.</p>

<a name="163988588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163988588" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163988588">Johan Commelin (Apr 23 2019 at 13:14)</a>:</h4>
<p>Note, you can use</p>
<div class="codehilite"><pre><span></span>```lean
foobar
```
</pre></div>


<p>to get code blocks with syntax highlighting</p>

<a name="163988616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163988616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163988616">Greg Conneen (Apr 23 2019 at 13:15)</a>:</h4>
<p>oh okay, thanks</p>

<a name="163988667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163988667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163988667">Johan Commelin (Apr 23 2019 at 13:16)</a>:</h4>
<p>Note that a group is not defined the way you did. (Internally that is what Lean sees, maybe. But it isn't how it's written in the Lean source files.)</p>

<a name="163988729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163988729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163988729">Johan Commelin (Apr 23 2019 at 13:16)</a>:</h4>
<p>Tip: write <code>#print group</code> in VScode, and <code>Ctrl</code>-click on <code>group</code>.</p>

<a name="163988749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163988749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163988749">Johan Commelin (Apr 23 2019 at 13:16)</a>:</h4>
<p>Or put your cursor on <code>group</code> and hit <code>Ctrl - Shift - F10</code></p>

<a name="163988801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163988801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163988801">Greg Conneen (Apr 23 2019 at 13:17)</a>:</h4>
<p>ohhhh I see. So a group is simply an extension of a monoid, which I assume is an extension of a semigroup.</p>

<a name="163988875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163988875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163988875">Greg Conneen (Apr 23 2019 at 13:18)</a>:</h4>
<p>...which it is, 4 lines above. Thank you so much.</p>

<a name="163989273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989273" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989273">Greg Conneen (Apr 23 2019 at 13:22)</a>:</h4>
<p>So, in general, classes are used in the backend, but Lean interprets them as structures. What's the difference?</p>

<a name="163989367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989367">Greg Conneen (Apr 23 2019 at 13:23)</a>:</h4>
<p>Also, is there any way to formalise has_mul and has_one without extending those classes?</p>

<a name="163989436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989436">Johan Commelin (Apr 23 2019 at 13:24)</a>:</h4>
<p>No the difference between classes and structures is type class inference</p>

<a name="163989470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989470">Johan Commelin (Apr 23 2019 at 13:24)</a>:</h4>
<blockquote>
<p>Also, is there any way to formalise has_mul and has_one without extending those classes?</p>
</blockquote>
<p>Just copy paste their definitions.</p>

<a name="163989477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989477" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989477">Greg Conneen (Apr 23 2019 at 13:24)</a>:</h4>
<p>I don't know what you mean by that</p>

<a name="163989478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989478" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989478">Johan Commelin (Apr 23 2019 at 13:24)</a>:</h4>
<p>The word <code>class</code> is a red herring in this discussion</p>

<a name="163989495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989495">Johan Commelin (Apr 23 2019 at 13:24)</a>:</h4>
<p>You could write <code>structure</code> everywhere</p>

<a name="163989589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989589">Greg Conneen (Apr 23 2019 at 13:25)</a>:</h4>
<p>gotcha. So the only difference is that structures are't able to inherit the properties of other structures. So when would you use a structure over a class?</p>

<a name="163989676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989676">Johan Commelin (Apr 23 2019 at 13:26)</a>:</h4>
<p>No, structures can inherit</p>

<a name="163989696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989696">Johan Commelin (Apr 23 2019 at 13:26)</a>:</h4>
<p>The difference is "type class instance". Search for that in TPIL.</p>

<a name="163989699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989699">Greg Conneen (Apr 23 2019 at 13:26)</a>:</h4>
<p>oh. Then what do you mean by "type class inference?"</p>

<a name="163989710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989710">Greg Conneen (Apr 23 2019 at 13:27)</a>:</h4>
<p>oh okay, gotcha</p>

<a name="163989725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989725" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989725">Greg Conneen (Apr 23 2019 at 13:27)</a>:</h4>
<p>must've skimmed over that section</p>

<a name="163989731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989731">Johan Commelin (Apr 23 2019 at 13:27)</a>:</h4>
<p>inference, not inheritance <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>

<a name="163989753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989753">Johan Commelin (Apr 23 2019 at 13:27)</a>:</h4>
<p>/me never read TPIL in detail. I'm a cargo cult Leaner.</p>

<a name="163989760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989760">Kevin Buzzard (Apr 23 2019 at 13:27)</a>:</h4>
<p>The difference between a structure and a class is that classes are structures with extra magical sauce.</p>

<a name="163989767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989767">Greg Conneen (Apr 23 2019 at 13:27)</a>:</h4>
<p>Ah, that's my confusion. Thank you for being patient with me</p>

<a name="163989772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989772">Kevin Buzzard (Apr 23 2019 at 13:27)</a>:</h4>
<p>I was trying to write some advanced notes on type class inference</p>

<a name="163989828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989828">Kevin Buzzard (Apr 23 2019 at 13:28)</a>:</h4>
<p>but before I wrote them I wrote some basic notes on type class inference for mathematicians</p>

<a name="163989843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989843">Kevin Buzzard (Apr 23 2019 at 13:28)</a>:</h4>
<p>These might help. They present the same material as in TPIL but in a way far more suited to mathematicians.</p>

<a name="163989867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989867">Kevin Buzzard (Apr 23 2019 at 13:28)</a>:</h4>
<p>They're in a branch of mathlib, hang on, I'll dig it out. I'm actually on an aeroplane at this point</p>

<a name="163990167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163990167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163990167">Kevin Buzzard (Apr 23 2019 at 13:32)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/kbuzzard_typeclass_inference_doc/docs/extras/typeclass_inference.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/kbuzzard_typeclass_inference_doc/docs/extras/typeclass_inference.md">https://github.com/leanprover-community/mathlib/blob/kbuzzard_typeclass_inference_doc/docs/extras/typeclass_inference.md</a></p>

<a name="163990228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163990228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163990228">Kevin Buzzard (Apr 23 2019 at 13:33)</a>:</h4>
<p>I found typeclass inference really hard to learn. It was only when I began to try to do normal maths in Lean that I began to see the point of it and understand it properly.</p>

<a name="163990426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163990426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163990426">Kevin Buzzard (Apr 23 2019 at 13:36)</a>:</h4>
<p>For reasons that you don't need to worry about and which might change, Lean keeps a ring in two packages not one. The first is a type called something like R. The second is a whole bunch of data which might be called something like <code>_inst_1 : ring R</code> and which you should never need to look at, but it's here that all the multiplication and the addition and the zero and the axioms are all stored. You will probably not need to dig out the axioms, you should just be applying lemmas, if you're doing mathematics -- but sometimes it's important to know where Lean magics up e.g. the proof of the distributivity law for the integers, and if you want to know this then you need to know about typeclass inference.</p>

<a name="163993041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993041">Greg Conneen (Apr 23 2019 at 14:10)</a>:</h4>
<p>What if I wanted to talk about a ternary operator instead of a binary one (I want to define an algebraic heap)? I can't use has_mul, since it's strictly binary...</p>

<a name="163993235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993235">Andrew Ashworth (Apr 23 2019 at 14:12)</a>:</h4>
<p>yup</p>

<a name="163993287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993287">Andrew Ashworth (Apr 23 2019 at 14:13)</a>:</h4>
<p>what exactly is your question about ternary operators?</p>

<a name="163993708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993708">Greg Conneen (Apr 23 2019 at 14:17)</a>:</h4>
<p>I want to define a class, let's start with semiheap. I only need it to have the following property, called para-associativity:</p>
<div class="codehilite"><pre><span></span><span class="k">forall</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">alpha</span><span class="o">,</span> <span class="o">[[</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">]</span> <span class="n">d</span> <span class="n">e</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">a</span> <span class="o">[</span><span class="n">d</span> <span class="n">c</span> <span class="n">b</span><span class="o">]</span> <span class="n">e</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">a</span> <span class="n">b</span> <span class="o">[</span><span class="n">c</span> <span class="n">d</span> <span class="n">e</span><span class="o">]]</span>
</pre></div>


<p>where [a b c] is a ternary operator. Although, If I have to use different notation given Lean's use of square brackets, that's fine</p>

<a name="163993810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993810">Greg Conneen (Apr 23 2019 at 14:19)</a>:</h4>
<p>I assume I have to define some sort of infix for a ternary operator, but I don't know how to implement that</p>

<a name="163993844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993844" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993844">Johan Commelin (Apr 23 2019 at 14:19)</a>:</h4>
<p>Does the operator have a "canonical" name in the literature?</p>

<a name="163993867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993867">Andrew Ashworth (Apr 23 2019 at 14:19)</a>:</h4>
<p>section 10.3 in TPIL describes notation</p>

<a name="163993868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993868">Johan Commelin (Apr 23 2019 at 14:19)</a>:</h4>
<p>You will first want to define it without the ternary notation.</p>

<a name="163993885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993885">Johan Commelin (Apr 23 2019 at 14:19)</a>:</h4>
<p>Afterward, you can define the notation, and start using it.</p>

<a name="163994014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994014">Greg Conneen (Apr 23 2019 at 14:20)</a>:</h4>
<p>Okay. I assume that I need to give it an operation on 3 elements, then state the rule</p>

<a name="163994076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994076">Greg Conneen (Apr 23 2019 at 14:21)</a>:</h4>
<p>And no, unfortunately there's not really a canonical name for the operator. It's just a ternary operation, in the same way that the standard operation a group deals with is just a binary one</p>

<a name="163994086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994086">Johan Commelin (Apr 23 2019 at 14:22)</a>:</h4>
<p>Yup. So you want fields</p>
<div class="codehilite"><pre><span></span><span class="o">(</span><span class="n">tern_op</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">semi_assoc</span> <span class="o">:</span> <span class="err">\</span><span class="n">for</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span><span class="o">,</span> <span class="n">blabla</span><span class="o">)</span>
</pre></div>

<a name="163994154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994154">Johan Commelin (Apr 23 2019 at 14:22)</a>:</h4>
<blockquote>
<p>And no, unfortunately there's not really a canonical name for the operator. It's just a ternary operation, in the same way that the standard operation a group deals with is just a binary one</p>
</blockquote>
<p>We "canonically" call it <em>multiplication</em>.</p>

<a name="163994218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994218">Greg Conneen (Apr 23 2019 at 14:23)</a>:</h4>
<p>Ah, I see. That makes sense. Although, most mathematicians I know don't like to be so restrictive in terminology :P</p>

<a name="163994232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994232">Johan Commelin (Apr 23 2019 at 14:23)</a>:</h4>
<p>I was just wondering whether there was a good alternative to <code>tern_op</code>.</p>

<a name="163994355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994355" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994355">Greg Conneen (Apr 23 2019 at 14:24)</a>:</h4>
<p>Yeah, I figured that's what you were after. Heaps aren't really a common algebraic structure, I'm really just trying to implement this so I have a better understanding of how Lean deals with structures/classes</p>

<a name="163994731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994731">Greg Conneen (Apr 23 2019 at 14:29)</a>:</h4>
<p>Also, am I able to say that 3 things are equal in one field without using "and"?</p>

<a name="163994748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994748">Greg Conneen (Apr 23 2019 at 14:29)</a>:</h4>
<p>like how I wrote above</p>

<a name="163994885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994885">Patrick Massot (Apr 23 2019 at 14:31)</a>:</h4>
<p>there are stupid indirect ways to say it, but using <code>and</code> is the reasonable one</p>

<a name="163995024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995024">Greg Conneen (Apr 23 2019 at 14:32)</a>:</h4>
<p>Okay. Unfortunate, but I guess it's better than defining two separate fields</p>

<a name="163995099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995099">Patrick Massot (Apr 23 2019 at 14:33)</a>:</h4>
<p>If you really want to you can build an API around this</p>

<a name="163995181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995181">Greg Conneen (Apr 23 2019 at 14:34)</a>:</h4>
<p>No thank you lol</p>

<a name="163995227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995227">Patrick Massot (Apr 23 2019 at 14:34)</a>:</h4>
<p>You will need lemmas about heaps saying that anyway</p>

<a name="163995273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995273" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995273">Patrick Massot (Apr 23 2019 at 14:35)</a>:</h4>
<p>Whatever is inside your field, you'll want a lemma asserting the three relevant equalities</p>

<a name="163995312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995312">Greg Conneen (Apr 23 2019 at 14:35)</a>:</h4>
<p>I don't know what you mean</p>

<a name="163995379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995379">Greg Conneen (Apr 23 2019 at 14:36)</a>:</h4>
<p>Why would I need a lemma? Are you talking about showing that some object is a heap?</p>

<a name="163995408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995408">Greg Conneen (Apr 23 2019 at 14:36)</a>:</h4>
<p>I'd expect that just implementing the classes wouldn't require lemmas</p>

<a name="163995431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995431">Johan Commelin (Apr 23 2019 at 14:36)</a>:</h4>
<p>No, he is talking about making it usable</p>

<a name="163995485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995485">Greg Conneen (Apr 23 2019 at 14:37)</a>:</h4>
<p>Oh, okay. So I can't refer to the fields until I define lemmas for them?</p>

<a name="163995586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995586" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995586">Patrick Massot (Apr 23 2019 at 14:39)</a>:</h4>
<p>You will have:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">heap</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:=</span>
<span class="bp">...</span>

<span class="kn">namespace</span> <span class="n">heap</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">heap</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span>
<span class="kn">lemma</span> <span class="n">assoc1</span>  <span class="o">:</span> <span class="o">[[</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">]</span> <span class="n">d</span> <span class="n">e</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">a</span> <span class="o">[</span><span class="n">d</span> <span class="n">c</span> <span class="n">b</span><span class="o">]</span> <span class="n">e</span><span class="o">]</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">lemma</span> <span class="n">assoc2</span>  <span class="o">:</span> <span class="o">[</span><span class="n">a</span> <span class="o">[</span><span class="n">d</span> <span class="n">c</span> <span class="n">b</span><span class="o">]</span> <span class="n">e</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">a</span> <span class="n">b</span> <span class="o">[</span><span class="n">c</span> <span class="n">d</span> <span class="n">e</span><span class="o">]]</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">lemma</span> <span class="n">assoc3</span>  <span class="o">:</span> <span class="o">[[</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">]</span> <span class="n">d</span> <span class="n">e</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">a</span> <span class="n">b</span> <span class="o">[</span><span class="n">c</span> <span class="n">d</span> <span class="n">e</span><span class="o">]]</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">end</span> <span class="n">heap</span>
</pre></div>

<a name="163995601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995601" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995601">Chris Hughes (Apr 23 2019 at 14:39)</a>:</h4>
<p>I would have three fields rather than an <code>and</code></p>

<a name="163995610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995610">Johan Commelin (Apr 23 2019 at 14:39)</a>:</h4>
<p>You can refer to them, otherwise you can't state the lemmas. What Patrick is saying is that with only the fields you'll have something that is cumbersome to use.</p>

<a name="163995614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995614">Greg Conneen (Apr 23 2019 at 14:39)</a>:</h4>
<p>yeah I'm putting it into 3 fields. I've realised that's easier</p>

<a name="163995629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995629" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995629">Patrick Massot (Apr 23 2019 at 14:39)</a>:</h4>
<p>The point is: whatever the implementaion chosen, after writing  those three lemmas, you will have your three equalities</p>

<a name="163995708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995708">Greg Conneen (Apr 23 2019 at 14:40)</a>:</h4>
<p>What does that change? Just being able to refer to the property without using semiheap.*?</p>

<a name="163995709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995709">Patrick Massot (Apr 23 2019 at 14:40)</a>:</h4>
<p>Of course if you put all three lemmas as fields then you don't have to state theses lemmas to use them (unless for some reason you want to change binder types, but that's a more advanced discussion)</p>

<a name="163995722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995722">Greg Conneen (Apr 23 2019 at 14:41)</a>:</h4>
<p>Also, is Type* a way of referring to an arbitrary Type level without defining a universe?</p>

<a name="163995769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995769">Patrick Massot (Apr 23 2019 at 14:41)</a>:</h4>
<p>And if you use redundant fields like that you will probably want a custom constructor</p>

<a name="163995886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995886">Greg Conneen (Apr 23 2019 at 14:43)</a>:</h4>
<p>How would a custom constructor help me?</p>

<a name="163995931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995931">Greg Conneen (Apr 23 2019 at 14:43)</a>:</h4>
<p>Sorry, but I'm still very new, and I don't really see the big picture yet</p>

<a name="163996078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163996078" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163996078">Patrick Massot (Apr 23 2019 at 14:45)</a>:</h4>
<p>I think the discussion would be much easier if you write something and then we comment it</p>

<a name="163996098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163996098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163996098">Patrick Massot (Apr 23 2019 at 14:45)</a>:</h4>
<p>Abstract discussion won't help</p>

<a name="163996115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163996115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163996115">Greg Conneen (Apr 23 2019 at 14:45)</a>:</h4>
<p>Yeah I agree. I'll post in just a second</p>

<a name="163997611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163997611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163997611">Greg Conneen (Apr 23 2019 at 15:00)</a>:</h4>
<p>This is what I've got so far:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">semiheap</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">tern_op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">)</span>
<span class="o">(</span><span class="n">para_assoc1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
    <span class="n">tern_op</span> <span class="o">(</span><span class="n">tern_op</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="n">d</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">tern_op</span> <span class="n">a</span> <span class="o">(</span><span class="n">tern_op</span> <span class="n">d</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="n">e</span><span class="o">)</span>
<span class="o">(</span><span class="n">para_assoc2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
    <span class="n">tern_op</span> <span class="o">(</span><span class="n">tern_op</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="n">d</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">tern_op</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="n">tern_op</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span><span class="o">))</span>
<span class="o">(</span><span class="n">para_assoc3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
    <span class="n">tern_op</span> <span class="n">a</span> <span class="o">(</span><span class="n">tern_op</span> <span class="n">d</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">tern_op</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="n">tern_op</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span><span class="o">))</span>


<span class="kn">namespace</span> <span class="n">semiheap</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="o">[</span><span class="bp">`</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">tern_op</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiheap</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">para_assoc1</span> <span class="o">:</span> <span class="n">sorry</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">lemma</span> <span class="n">para_assoc2</span> <span class="o">:</span> <span class="n">sorry</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">lemma</span> <span class="n">para_assoc3</span> <span class="o">:</span> <span class="n">sorry</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">end</span> <span class="n">semiheap</span>
</pre></div>


<p>The semiheap as defined is fine. I'm just having trouble with the notation, since it throws an error saying I'm referencing local variables if I put it below them, and I don't know how to reference the semiheap alpha if I put it above.</p>

<a name="163998753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163998753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163998753">Patrick Massot (Apr 23 2019 at 15:12)</a>:</h4>
<p>I don't think you can use space as a delimiter in this notation. You can play with</p>
<div class="codehilite"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="n">semiheap</span><span class="w"> </span><span class="p">(</span><span class="err">α</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nc">Type</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="p">(</span><span class="n">tern_op</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">α</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">α</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">α</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">α</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="n">notation</span><span class="w"> </span><span class="n">`</span><span class="p">[</span><span class="n">`</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">`</span><span class="o">|</span><span class="n">`</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">`</span><span class="o">|</span><span class="n">`</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">`</span><span class="p">]</span><span class="n">`</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">tern_op</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="n">para_assoc1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">∀</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">α</span><span class="p">,</span><span class="w"> </span><span class="p">[[</span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">[</span><span class="n">d</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">])</span><span class="w"></span>
<span class="p">(</span><span class="n">para_assoc2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">∀</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">α</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">[</span><span class="n">d</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">]])</span><span class="w"></span>
<span class="p">(</span><span class="n">para_assoc3</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">∀</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">α</span><span class="p">,</span><span class="w"> </span><span class="p">[[</span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">]])</span><span class="w"></span>


<span class="n">def</span><span class="w"> </span><span class="n">semiheap</span><span class="o">.</span><span class="n">mk</span><span class="err">&#39;</span><span class="w"> </span><span class="p">{</span><span class="err">α</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nc">Type</span><span class="o">*</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="o">:</span><span class="err">α</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">α</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">α</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">α</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="n">h1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">∀</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">α</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">op</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="n">h2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">∀</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">α</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">op</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">semiheap</span><span class="w"> </span><span class="err">α</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="p">{</span><span class="w"> </span><span class="n">tern_op</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">para_assoc1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">h1</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">para_assoc2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="err">λ</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">h1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="err">▸</span><span class="w"> </span><span class="p">(</span><span class="n">h2</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="n">para_assoc3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">h2</span><span class="p">}</span><span class="w"></span>
</pre></div>

<a name="163998816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163998816" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163998816">Patrick Massot (Apr 23 2019 at 15:13)</a>:</h4>
<p>The function is the custom constructor, it lets you build a structure by providing only two equalities</p>

<a name="163999075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163999075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163999075">Greg Conneen (Apr 23 2019 at 15:16)</a>:</h4>
<p>Why have we defined .mk'? What does it do? Also, what is ▸?</p>

<a name="163999113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163999113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163999113">Patrick Massot (Apr 23 2019 at 15:17)</a>:</h4>
<p>Please first try to define an instance of <code>semiheap</code></p>

<a name="163999124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163999124" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163999124">Greg Conneen (Apr 23 2019 at 15:17)</a>:</h4>
<p>It clearly rewrote, but what does it do in general?</p>

<a name="163999130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163999130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163999130">Greg Conneen (Apr 23 2019 at 15:17)</a>:</h4>
<p>Okay, I will</p>

<a name="164003046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164003046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164003046">Greg Conneen (Apr 23 2019 at 16:01)</a>:</h4>
<p>I've got it.</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">tern_add</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span><span class="bp">+</span><span class="n">b</span><span class="bp">+</span><span class="n">c</span>
<span class="kn">instance</span> <span class="n">int_semiheap</span> <span class="o">:</span> <span class="n">semiheap</span> <span class="bp">ℤ</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">apply</span> <span class="n">semiheap</span><span class="bp">.</span><span class="n">mk&#39;</span> <span class="n">tern_add</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">tern_add</span><span class="o">,</span>
<span class="n">simp</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">tern_add</span><span class="o">,</span>
<span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="164003070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164003070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164003070">Greg Conneen (Apr 23 2019 at 16:01)</a>:</h4>
<p>Thank you so much for your help.</p>

<a name="164003572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164003572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164003572">Patrick Massot (Apr 23 2019 at 16:06)</a>:</h4>
<p>Does that code compile?</p>

<a name="164003623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164003623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164003623">Patrick Massot (Apr 23 2019 at 16:07)</a>:</h4>
<p>Anyway, the point is you had to prove only para-associativity equalities instead of three</p>

<a name="164003676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164003676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164003676">Patrick Massot (Apr 23 2019 at 16:07)</a>:</h4>
<p>You can also study (after adding <code>import tactic.abel</code> on top of your file):</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">tern_add</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span><span class="bp">+</span><span class="n">b</span><span class="bp">+</span><span class="n">c</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">semiheap</span> <span class="bp">ℤ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">tern_op</span> <span class="o">:=</span> <span class="n">tern_add</span><span class="o">,</span>
  <span class="n">para_assoc1</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">dsimp</span><span class="o">[</span><span class="n">tern_add</span><span class="o">],</span> <span class="n">abel</span> <span class="o">},</span>
  <span class="n">para_assoc2</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">dsimp</span><span class="o">[</span><span class="n">tern_add</span><span class="o">],</span> <span class="n">abel</span> <span class="o">},</span>
  <span class="n">para_assoc3</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">dsimp</span><span class="o">[</span><span class="n">tern_add</span><span class="o">],</span> <span class="n">abel</span> <span class="o">}</span> <span class="o">}</span>


<span class="kn">example</span> <span class="o">:</span> <span class="n">semiheap</span> <span class="bp">ℤ</span> <span class="o">:=</span>
<span class="n">semiheap</span><span class="bp">.</span><span class="n">mk&#39;</span> <span class="n">tern_add</span> <span class="o">(</span><span class="k">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">tern_add</span><span class="o">],</span> <span class="n">abel</span> <span class="o">})</span> <span class="o">(</span><span class="k">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">tern_add</span><span class="o">],</span> <span class="n">abel</span> <span class="o">}</span>
</pre></div>

<a name="164003782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164003782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164003782">Patrick Massot (Apr 23 2019 at 16:08)</a>:</h4>
<p>you can also replace <code>dsimp [tern_add]</code> by <code>unfold tern_add</code></p>

<a name="164003941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164003941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164003941">Greg Conneen (Apr 23 2019 at 16:10)</a>:</h4>
<p>Okay, I will. I'm currently implementing heaps as an extension of semiheaps. How do I avoid having to write the notation as a field over and over?</p>

<a name="164004090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164004090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164004090">Patrick Massot (Apr 23 2019 at 16:12)</a>:</h4>
<p>you need to reissue the notation command after the semiheap definition. The one inside the definition has limited scope</p>

<a name="164004118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164004118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164004118">Greg Conneen (Apr 23 2019 at 16:12)</a>:</h4>
<p>Gotcha. So at most I'll only have to write it twice</p>

<a name="164004140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164004140" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164004140">Patrick Massot (Apr 23 2019 at 16:13)</a>:</h4>
<p>yes</p>

<a name="164019736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164019736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164019736">Greg Conneen (Apr 23 2019 at 19:07)</a>:</h4>
<p>Is the symmetric group defined anywhere in mathlib? If not, I'd like to go about implementing it, and in doing so would need some guidance</p>

<a name="164019868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164019868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164019868">Johan Commelin (Apr 23 2019 at 19:08)</a>:</h4>
<p>It is:</p>
<div class="codehilite"><pre><span></span><span class="n">src</span><span class="bp">/</span><span class="n">data</span><span class="bp">/</span><span class="n">equiv</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="c">/-</span><span class="cm">- `perm α` is the type of bijections from `α` to itself. -/</span>
</pre></div>

<a name="164019920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164019920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164019920">Greg Conneen (Apr 23 2019 at 19:09)</a>:</h4>
<p>Thank you</p>

<a name="164020042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164020042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164020042">Greg Conneen (Apr 23 2019 at 19:10)</a>:</h4>
<p>Followup question, has Cayley's theorem been proven?</p>

<a name="164020295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164020295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164020295">Johan Commelin (Apr 23 2019 at 19:13)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> I guess you did Cayley somewhere, right?</p>

<a name="164020371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164020371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164020371">Chris Hughes (Apr 23 2019 at 19:14)</a>:</h4>
<p>No.</p>

<a name="164020394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164020394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164020394">Chris Hughes (Apr 23 2019 at 19:14)</a>:</h4>
<p>But it won't be hard.</p>

<a name="164020421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164020421" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164020421">Johan Commelin (Apr 23 2019 at 19:14)</a>:</h4>
<p><span class="user-mention" data-user-id="218940">@Greg Conneen</span> It would be a very nice project to start with!</p>

<a name="164020443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164020443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164020443">Greg Conneen (Apr 23 2019 at 19:14)</a>:</h4>
<p>Okay. I assume it won't be. That sounds like a great thing to do.</p>

<a name="164020496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164020496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164020496">Greg Conneen (Apr 23 2019 at 19:15)</a>:</h4>
<p>I'm going to need help understanding data.equiv.basic though</p>

<a name="164020674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164020674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164020674">Greg Conneen (Apr 23 2019 at 19:17)</a>:</h4>
<p>It looks like α ≃ β means α is isomorphic to β, given the defn. perm α makes sense. I'm still not completely comfortable with set theory notation and techniques in Lean, since I was introduced almost exclusively through propositions</p>

<a name="164021104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164021104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164021104">Johan Commelin (Apr 23 2019 at 19:21)</a>:</h4>
<p><span class="user-mention" data-user-id="218940">@Greg Conneen</span> Do you have an idea how you would formalise the statement?</p>

<a name="164021263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164021263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164021263">Greg Conneen (Apr 23 2019 at 19:23)</a>:</h4>
<p>I'm looking into that now. The proof is trivial to me on paper. I should be fine in abstracting it. I'll definitely ask for help with it when I need it</p>

<a name="164021723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164021723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164021723">Patrick Massot (Apr 23 2019 at 19:28)</a>:</h4>
<blockquote>
<p>It looks like α ≃ β means α is isomorphic to β</p>
</blockquote>
<p>This is an extremely confusing notation, but you'll get used to it</p>

<a name="164021787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164021787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164021787">Patrick Massot (Apr 23 2019 at 19:29)</a>:</h4>
<p>The first piece of truth is <code>α ≃ β</code> is the type of isomorphisms from <code>α</code> to <code>β</code></p>

<a name="164021806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164021806" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164021806">Patrick Massot (Apr 23 2019 at 19:29)</a>:</h4>
<p>So it's not a <code>Prop</code>, it contains data</p>

<a name="164021815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164021815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164021815">Greg Conneen (Apr 23 2019 at 19:29)</a>:</h4>
<p>oh no</p>

<a name="164021875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164021875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164021875">Greg Conneen (Apr 23 2019 at 19:30)</a>:</h4>
<p>lol that's certainly unintuitive</p>

<a name="164021956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164021956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164021956">Patrick Massot (Apr 23 2019 at 19:30)</a>:</h4>
<p>The next layer of confusion is that an isomorphism from <code>α</code> to <code>β</code> is not only a map from <code>α</code> to <code>β</code> which happens to be an isomorphism, it's a bundle containing such a map, the corresponding inverse map and two proofs</p>

<a name="164022067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022067" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022067">Patrick Massot (Apr 23 2019 at 19:31)</a>:</h4>
<p>you need to read <a href="https://github.com/leanprover-community/mathlib/blob/master/src/data/equiv/basic.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/data/equiv/basic.lean">https://github.com/leanprover-community/mathlib/blob/master/src/data/equiv/basic.lean</a></p>

<a name="164022095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022095">Patrick Massot (Apr 23 2019 at 19:31)</a>:</h4>
<p>keeping the above explanation in mind</p>

<a name="164022151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022151">Greg Conneen (Apr 23 2019 at 19:32)</a>:</h4>
<p>That's perfectly fine. I can understand that such a map needs more info packaged in with it. So, what's the actual prop that A is iso to B?</p>

<a name="164022152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022152">Patrick Massot (Apr 23 2019 at 19:32)</a>:</h4>
<p>don't forget to first read back the section on coercions in TPIL</p>

<a name="164022169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022169">Greg Conneen (Apr 23 2019 at 19:32)</a>:</h4>
<p>And yeah I've been reading that file</p>

<a name="164022251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022251">Patrick Massot (Apr 23 2019 at 19:33)</a>:</h4>
<p><code>nonempty (α ≃ β)</code></p>

<a name="164022274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022274">Patrick Massot (Apr 23 2019 at 19:33)</a>:</h4>
<p>This is the Prop you are looking for</p>

<a name="164022456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022456">Patrick Massot (Apr 23 2019 at 19:35)</a>:</h4>
<p>Probably I missed that piece of information: at what stage of your math studies are you? (Knowing this will help choosing explanations for you)</p>

<a name="164022688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022688">Greg Conneen (Apr 23 2019 at 19:38)</a>:</h4>
<p>I don't think I've fully elaborated. I'm a 2nd year undergraduate math major currently taking my first semester of graduate real and complex analysis, and my third semester of graduate algebra. I plan on studying algebraic combinatorics, algebraic geometry, or algebraic topology. Either way, interested in algebra</p>

<a name="164022856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022856">Patrick Massot (Apr 23 2019 at 19:40)</a>:</h4>
<p>I'm afraid my knowledge of the American university system is clearly not good enough to understand that answer. Can you give a couple of examples of theorems you recently learned in your most advanced courses?</p>

<a name="164023106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164023106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164023106">Kevin Buzzard (Apr 23 2019 at 19:42)</a>:</h4>
<blockquote>
<p><code>nonempty (α ≃ β)</code></p>
</blockquote>
<p>That just says alpha bijects with beta. You want an isomorphism of what structure?</p>

<a name="164023186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164023186" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164023186">Johan Commelin (Apr 23 2019 at 19:43)</a>:</h4>
<p>He doesn't need more structure. He is trying to formalise Cayley's theorem.</p>

<a name="164023555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164023555" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164023555">Greg Conneen (Apr 23 2019 at 19:48)</a>:</h4>
<p>Yeah. I'm currently in a course on wedderburn theory/commutative algebra. So, for example, we just covered the classification theorem for semisimple rings and semisimple algebras. In manifolds, we just covered the generalisation of stokes' theorem, and we just had an ending seminar on the Poincare lemma and the DeRham cohomology.</p>

<a name="164023653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164023653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164023653">Patrick Massot (Apr 23 2019 at 19:49)</a>:</h4>
<p>Thanks, this I understand (but I have no idea how to relate this to your abstract answer)</p>

<a name="164023777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164023777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164023777">Greg Conneen (Apr 23 2019 at 19:50)</a>:</h4>
<p>Well, I'm glad I could clarify for you</p>

<a name="164249738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164249738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164249738">Kevin Kappelmann (Apr 26 2019 at 10:27)</a>:</h4>
<p>What is the recommended/most elegant way to simplify/rewrite a hypothesis/assumption while re-stating the desired outcome of the simplification/rewriting? For example, doing</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">hyp</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">∧</span> <span class="n">true</span> <span class="bp">=</span> <span class="n">false</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">hyp</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">=</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">hyp</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
<span class="n">sorry</span>
</pre></div>


<p>is not quite perfect as I have to write <code>by { simp at hyp, assumption }</code> (preferably, I'd like to simply write <code>by simp at hyp</code>) and leaves me with two hypotheses called <code>hyp</code>, namely</p>
<div class="codehilite"><pre><span></span><span class="n">hyp</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">∧</span> <span class="n">true</span> <span class="bp">=</span> <span class="n">false</span><span class="o">,</span>
<span class="n">hyp</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">=</span> <span class="n">false</span>
</pre></div>


<p>Is there something like <code>change</code> for hypotheses?</p>

<a name="164251420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164251420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164251420">Johan Commelin (Apr 26 2019 at 10:59)</a>:</h4>
<p>There is <code>rwa</code> and <code>simpa</code>. Do those help you?</p>

<a name="164251567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164251567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164251567">Kevin Kappelmann (Apr 26 2019 at 11:01)</a>:</h4>
<p>Alright, that solves the former issue. Can I also somehow drop the non-simplified version from the list of assumptions?</p>

<a name="164251650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164251650" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164251650">Johan Commelin (Apr 26 2019 at 11:03)</a>:</h4>
<p><span class="user-mention" data-user-id="198376">@Kevin Kappelmann</span>  <code>replace hyp : bla, by foobar</code>?</p>

<a name="164251946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164251946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164251946">Kevin Kappelmann (Apr 26 2019 at 11:08)</a>:</h4>
<p>Yeah, that's exactly what I was looking for! thanks :) I do not think <code>replace</code> is mentioned in the tutorial. Is there some sort of document/website with "advanced tactics/APIs" that I can consult in such cases?</p>

<a name="164251990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164251990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164251990">Johan Commelin (Apr 26 2019 at 11:09)</a>:</h4>
<p>Which tutorial?</p>

<a name="164251998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164251998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164251998">Johan Commelin (Apr 26 2019 at 11:09)</a>:</h4>
<p>See the <code>docs/</code> folder in mathlib. There is some stuff there.</p>

<a name="164252005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164252005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164252005">Kevin Kappelmann (Apr 26 2019 at 11:10)</a>:</h4>
<p>This document: <a href="https://leanprover.github.io/theorem_proving_in_lean/theorem_proving_in_lean.pdf" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/theorem_proving_in_lean.pdf">https://leanprover.github.io/theorem_proving_in_lean/theorem_proving_in_lean.pdf</a></p>

<a name="164253453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164253453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164253453">Patrick Massot (Apr 26 2019 at 11:38)</a>:</h4>
<blockquote>
<p>Is there something like <code>change</code> for hypotheses?</p>
</blockquote>
<p>Yes, it's called <code>change</code></p>

<a name="164253515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164253515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164253515">Patrick Massot (Apr 26 2019 at 11:39)</a>:</h4>
<p>If you have <code>hyp : 1 + 1 = 2</code> you can <code>change 2 = 2 at hyp</code></p>

<a name="164446721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164446721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164446721">Kevin Kappelmann (Apr 29 2019 at 12:20)</a>:</h4>
<p>It's me again :') I'm having some problems when using <code>let</code>-expressions + cases/induction. For example, this does not work</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
<span class="n">case</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="o">:</span> <span class="o">{</span><span class="n">sorry</span><span class="o">},</span> <span class="c1">-- error: could not find open goal of given case</span>
<span class="n">case</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:</span> <span class="o">{</span><span class="n">sorry</span><span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>whereas this works</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
<span class="n">case</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="o">:</span> <span class="o">{</span><span class="n">sorry</span><span class="o">},</span>
<span class="n">case</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:</span> <span class="o">{</span><span class="n">sorry</span><span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>Does someone know what I am doing wrong?</p>

<a name="164446952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164446952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164446952">Kevin Buzzard (Apr 29 2019 at 12:24)</a>:</h4>
<p>Maybe that's a bug in <code>case</code>? You know that you don't need it, right?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
<span class="o">{</span><span class="n">sorry</span><span class="o">},</span>
<span class="o">{</span><span class="n">sorry</span><span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="164447000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164447000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164447000">Kevin Kappelmann (Apr 29 2019 at 12:25)</a>:</h4>
<p>Yep, I'd really like to keep the <code>case nat.xxx</code> annotations though to keep my proofs more readable.</p>

<a name="164447056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164447056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164447056">Kevin Buzzard (Apr 29 2019 at 12:25)</a>:</h4>
<p>Make it a comment within the <code>{}</code>. And complain to the devs :-)</p>

<a name="164447163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164447163" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164447163">Kevin Kappelmann (Apr 29 2019 at 12:27)</a>:</h4>
<p>Haha, alright :D Thanks</p>

<a name="164447324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164447324" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164447324">Kevin Buzzard (Apr 29 2019 at 12:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> is this a bug?</p>

<a name="164447705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164447705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164447705">Simon Hudon (Apr 29 2019 at 12:35)</a>:</h4>
<p>I think it is. I'll look into it</p>

<a name="164506505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164506505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164506505">Greg Conneen (Apr 30 2019 at 02:51)</a>:</h4>
<p>Does <code>unfold</code> actually do anything other than change what the goal looks like? Isn't <code>#print</code> or <code>Ctrl-click</code> on what you're unfolding a replacement, since it's just a method of getting information about your goal? It seems that any proof can have the <code>unfold</code> statement removed, and it works just the same</p>

<a name="164506888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164506888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164506888">Mario Carneiro (Apr 30 2019 at 03:01)</a>:</h4>
<p>yes and no (and no). <code>unfold</code> will rewrite with equations that are not necessarily definitional equalities, so it might do more than just change the appearance of the goal. It's really a wrapper around <code>simp</code> with particular config options. <code>dunfold</code> is closer to your description, as it only does defeq simplifications. But there are two reasons that it's still not correct to say that it "doesn't actually do anything other than change what the goal looks like" and "any proof can have the <code>dunfold</code> statement removed and it works just the same". First, it does actually do something - it inserts an <code>id</code> term into the result (the partial proof being constructed). So you can see the result of <code>dsimp</code> and <code>dunfold</code> applications in the resulting proof if you <code>#print</code> it. This is done to keep typechecking time down by remembering the simplification path in the proof term.</p>
<p>The more important reason why <code>dunfold</code> and friends can't necessarily be removed from a proof is because many tactics depend on the syntactic shape of the goal or a hypothesis. For example, <code>rw</code> will not match against the goal if some definitional unfolding is required to see the constant that appears. For example if the goal is <code>2 * n = 0</code> where <code>n : nat</code>, then this is defeq to <code>n + n = 0</code> but <code>rw add_comm</code> would only work on the second form of the goal. So anything that "changes what the goal looks like" could potentially affect whether a later tactic succeeds. That said, many tactics don't care about anything beyond defeq, in particular <code>apply</code>, <code>refine</code> and <code>exact</code>, and in many cases you can remove superfluous <code>unfold</code> and <code>dunfold</code> tactics without breaking the proof.</p>

<a name="164832882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164832882" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164832882">Simon Hudon (May 03 2019 at 21:45)</a>:</h4>
<p><span class="user-mention" data-user-id="198376">@Kevin Kappelmann</span> I now have a fix for your <code>let</code> / <code>case</code> issue. It should be in the next nightly build of Lean 3.5.0c</p>

<a name="164884660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884660" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884660">Greg Conneen (May 04 2019 at 20:07)</a>:</h4>
<p>Real quick, what is a meta variable and why is <code>tactic.finish</code> absolutely packed with them? I'm not sure exactly what's going on, but it seems that any trivial propositional technique is proven immediately with <code>by finish</code></p>

<a name="164884711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884711">Patrick Massot (May 04 2019 at 20:08)</a>:</h4>
<p>What do you mean <code>finish</code> is packed with metavariable?</p>

<a name="164884724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884724">Patrick Massot (May 04 2019 at 20:09)</a>:</h4>
<p>A meta-variable is a kind of hole Lean will have to fill in. It can be the goal you need to solve or some implicit argument to be inferred by unification</p>

<a name="164884862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884862" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884862">Greg Conneen (May 04 2019 at 20:13)</a>:</h4>
<p>I just mean that when I pressed <code>Ctrl-Click</code> on <code>tactic.finish</code>, I came upon a file that was filled with the keyword <code>meta</code> and I wasn't sure what any of it meant</p>

<a name="164884865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884865">Patrick Massot (May 04 2019 at 20:14)</a>:</h4>
<p>oohh</p>

<a name="164884911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884911">Patrick Massot (May 04 2019 at 20:14)</a>:</h4>
<p>that's a different meta</p>

<a name="164884923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884923">Greg Conneen (May 04 2019 at 20:15)</a>:</h4>
<p>I suppose so, I just assumed that <code>meta def</code> was defining a metavariable, although I suppose that wouldn't make sense given my preconceived notion of what a metavariable is</p>

<a name="164884925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884925">Patrick Massot (May 04 2019 at 20:15)</a>:</h4>
<p><code>meta</code> in this context means "unsafe". It's code that won't be checked by Lean. It particular it doesn't have to be provably terminating</p>

<a name="164884946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884946">Greg Conneen (May 04 2019 at 20:15)</a>:</h4>
<p>Why would one ever need such a thing?</p>

<a name="164884950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884950">Patrick Massot (May 04 2019 at 20:15)</a>:</h4>
<p>Typically tactics (the commands you type between begin and end) are meta. They produce proofs that <em>will</em> be checked by Lean. But the way they produces those proofs is freestyle</p>

<a name="164885023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885023">Greg Conneen (May 04 2019 at 20:17)</a>:</h4>
<p>Ah, okay. So it's not just a cheeky way of making axioms. So the reason I can solve so many things with <code>by finish</code> is because all of the structures in <code>finish</code> are using this meta keyword? I assume without it, there wouldn't be a way of taking arbitrary propositions and figuring out how to solve them</p>

<a name="164885069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885069">Greg Conneen (May 04 2019 at 20:18)</a>:</h4>
<p>That is, <code>finish</code> wouldn't know how to solve a proposition handed to it if it weren't in a specific order of some sort</p>

<a name="164885070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885070">Scott Morrison (May 04 2019 at 20:18)</a>:</h4>
<p><code>meta</code> code can do non-terminating recursion, and it can also work with "reflected" versions of mathematical objects, i.e. their actual representations as <code>expr</code> objects in the C++ code.</p>

<a name="164885074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885074" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885074">Patrick Massot (May 04 2019 at 20:18)</a>:</h4>
<p><code>finish</code> constructs a proof for you</p>

<a name="164885086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885086">Greg Conneen (May 04 2019 at 20:19)</a>:</h4>
<p>Okay, that's really cool <span class="user-mention" data-user-id="110087">@Scott Morrison</span></p>

<a name="164885089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885089">Patrick Massot (May 04 2019 at 20:19)</a>:</h4>
<p>I don't think there is any risk of non-termination here. But the type of Lean expressions is meta, for reasons too long to explain (unless you understand what Scott wrote)</p>

<a name="164885133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885133">Scott Morrison (May 04 2019 at 20:20)</a>:</h4>
<p>This is one of the lovely things about Lean --- you can write new tactics (i.e. programs that construct proofs, but aren't necessarily themselves correct) in Lean itself.</p>

<a name="164885135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885135">Greg Conneen (May 04 2019 at 20:20)</a>:</h4>
<p>I understand C++ enough to generally know what he means</p>

<a name="164885145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885145">Scott Morrison (May 04 2019 at 20:20)</a>:</h4>
<p>In previous interactive theorem provers you needed to step out, either into the base implementation language, or some DSL, to write new tactics.</p>

<a name="164885155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885155">Greg Conneen (May 04 2019 at 20:21)</a>:</h4>
<p>So, even with meta, there's still no way to prove false? Because a bad tactic won't construct a good proof?</p>

<a name="164885159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885159">Greg Conneen (May 04 2019 at 20:21)</a>:</h4>
<p>That makes sense</p>

<a name="164885161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885161">Scott Morrison (May 04 2019 at 20:21)</a>:</h4>
<p>The <code>meta</code> keyword <em>protects</em> the real maths from these "helper" functions that we write to help construct proofs.</p>

<a name="164885165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885165" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885165">Greg Conneen (May 04 2019 at 20:21)</a>:</h4>
<p>ahh</p>

<a name="164885169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885169">Scott Morrison (May 04 2019 at 20:22)</a>:</h4>
<p>Exactly. The tactic framework lets you <em>run</em> meta code to produce proof terms, but those proof terms will be rejected if they refer to any <code>meta</code> functions.</p>

<a name="164885214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885214" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885214">Greg Conneen (May 04 2019 at 20:22)</a>:</h4>
<p>so, how would a noob go about using meta? Or, should I just not even touch the thing?</p>

<a name="164885226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885226">Patrick Massot (May 04 2019 at 20:23)</a>:</h4>
<p>It depends on your taste, background and goals</p>

<a name="164885227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885227">Scott Morrison (May 04 2019 at 20:23)</a>:</h4>
<p>Read <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/tactic_writing.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/tactic_writing.md">https://github.com/leanprover-community/mathlib/blob/master/docs/extras/tactic_writing.md</a></p>

<a name="164885234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885234" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885234">Scott Morrison (May 04 2019 at 20:23)</a>:</h4>
<p>And start reading all the files in <code>src/tactic/</code> in the mathlib repository.</p>

<a name="164885236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885236">Scott Morrison (May 04 2019 at 20:23)</a>:</h4>
<p>and ask here :-)</p>

<a name="164885242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885242">Patrick Massot (May 04 2019 at 20:23)</a>:</h4>
<p>Yes, reading that tutorial will give you a first glance at what it looks like</p>

<a name="164885244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885244">Patrick Massot (May 04 2019 at 20:24)</a>:</h4>
<p>Reading <code>src/tactic/</code> will give you a lot more (after a <em>lot</em> more time)</p>

<a name="164885297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885297">Greg Conneen (May 04 2019 at 20:24)</a>:</h4>
<p>Great, thank you. My goal generally is to git gud in Lean, but eventually I want to start implementing some actual maths. I expect that will take me some time, given I'll have to read quite a bit of mathlib</p>

<a name="164885311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885311">Patrick Massot (May 04 2019 at 20:25)</a>:</h4>
<p>You don't have to read all of mathlib before starting to implement actual maths</p>

<a name="164885428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885428">Greg Conneen (May 04 2019 at 20:28)</a>:</h4>
<p>sure, but I'd like to understand a chunk of what's already there on a fundamental level</p>

<a name="164885432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885432">Scott Morrison (May 04 2019 at 20:28)</a>:</h4>
<p>Do you have an idea what maths you'd like to do?</p>

<a name="164885440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885440">Scott Morrison (May 04 2019 at 20:29)</a>:</h4>
<p>If you're ever tempted to add documentation to stuff you're reading, documentation-only pull requests are very welcome. :-)</p>

<a name="164885457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885457">Greg Conneen (May 04 2019 at 20:29)</a>:</h4>
<p>I'd like to define a manifold, and maybe prove the inverse/implicit function theorem</p>

<a name="164885514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885514">Greg Conneen (May 04 2019 at 20:30)</a>:</h4>
<p>I just really need to look over how topology and euclidean space are implemented first</p>

<a name="164885519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885519">Greg Conneen (May 04 2019 at 20:30)</a>:</h4>
<p>Also, do we have the definition of a metric space?</p>

<a name="164885594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885594">Kevin Buzzard (May 04 2019 at 20:32)</a>:</h4>
<p><span class="user-mention" data-user-id="218940">@Greg Conneen</span> If you want to implement some actual maths in Lean, then don't try to get good at Lean first, just try to implement some actual maths in Lean, get stuck, ask for help here, and you will succeed.</p>

<a name="164885598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885598">Sebastien Gouezel (May 04 2019 at 20:32)</a>:</h4>
<p>I am precisely working on the definition of a manifold. Work in progress (very much in a preliminary state) at <a href="https://github.com/sgouezel/mathlib/blob/aa7fbab39d1e6a01665e24e6197b09338e855467/src/geometry/manifolds/basic.lean#L1598" target="_blank" title="https://github.com/sgouezel/mathlib/blob/aa7fbab39d1e6a01665e24e6197b09338e855467/src/geometry/manifolds/basic.lean#L1598">https://github.com/sgouezel/mathlib/blob/aa7fbab39d1e6a01665e24e6197b09338e855467/src/geometry/manifolds/basic.lean#L1598</a></p>

<a name="164885608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885608">Kevin Buzzard (May 04 2019 at 20:32)</a>:</h4>
<p>I have no idea how to write tactics. Tactics are written in meta code because they can fail. You don't need to know anything about tactic-writing (which is what people use meta code for) to write maths.</p>

<a name="164885624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885624">Kevin Buzzard (May 04 2019 at 20:33)</a>:</h4>
<p>However, what you do need to know is what is already there and what is being worked on, because this changes <em>fast</em> here</p>

<a name="164885676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885676">Kevin Buzzard (May 04 2019 at 20:34)</a>:</h4>
<p>Yes we have metric spaces. You can see this yourself by firing up a project with mathlib as a dependency in VS Code and searching for metric space. This is a really important beginner skill to learn.</p>

<a name="164885695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885695">Kevin Buzzard (May 04 2019 at 20:35)</a>:</h4>
<p>Make sure that "the cog doesn't have a box around it" in "files to exclude" in VS Code. That way you can search your dependencies.</p>

<a name="164885701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885701">Kevin Buzzard (May 04 2019 at 20:35)</a>:</h4>
<p>Several people would like to define manifolds and people are sort of in the middle of things, so it might not be a perfect project right now for a beginner.</p>

<a name="164885752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885752">Kevin Buzzard (May 04 2019 at 20:36)</a>:</h4>
<p>Definitions are harder than theorems; proofs can be sloppy but it's important to get definitions right.</p>

<a name="164885756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885756">Kevin Buzzard (May 04 2019 at 20:36)</a>:</h4>
<p>One big obstruction to doing much with manifolds is that we don't have enough calculus, but again people are working on this and things are changing fast.</p>

<a name="164885771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885771">Kevin Buzzard (May 04 2019 at 20:37)</a>:</h4>
<p>Bump functions are still a little out of reach at the minute, but it won't be long until we have them.</p>

<a name="164885840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885840">Kevin Buzzard (May 04 2019 at 20:38)</a>:</h4>
<p>For polynomials we have multivariable ones and single variable ones; I am not an expert in either analysis or Lean-analysis, but I am wondering whether we are going to need a robust theory of calculus in one real variable, proving basic theorems such that the derivative of the integral is the function. I don't think we even have that.</p>

<a name="164885857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885857">Kevin Buzzard (May 04 2019 at 20:39)</a>:</h4>
<p>We have no complex analysis worth mentioning, not even integrating along a reasonable path.</p>

<a name="164885923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885923">Kevin Buzzard (May 04 2019 at 20:40)</a>:</h4>
<p>Because of our lack of analysis, this makes manifolds harder to do, however having goals like manifolds in mind is driving the library forwards in the right direction (as far as I am concerned). Lean seems to me to be focussing on the kind of mathematics mathematicians do, as opposed to the kind of mathematics that computer scientists have managed to pick up somehow.</p>

<a name="164886015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164886015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164886015">Greg Conneen (May 04 2019 at 20:43)</a>:</h4>
<p>Gotcha, thanks for the information. Do you think that complex would be a good thing to get working on, or do we not have it because it's hard to implement?</p>

<a name="164886260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164886260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164886260">Kevin Buzzard (May 04 2019 at 20:49)</a>:</h4>
<p>I am not an analyst and it's been nearly 30 years since I thought about the basics, Cauchy's integral formula etc. I've never taught the course either, so I am not the person to ask.</p>

<a name="164886319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164886319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164886319">Kevin Buzzard (May 04 2019 at 20:50)</a>:</h4>
<p>One thing I know was an issue is that someone has to make a decision about in what generality to define path integrals -- C^infinity paths isn't good enough because you want to integrate round semicircles and rectangles etc.</p>

<a name="164886332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164886332" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164886332">Kevin Buzzard (May 04 2019 at 20:51)</a>:</h4>
<p>I really don't know what's there already though; I know a lot of the algebra stuff in Lean but the analysis stuff is changing quickly at the minute.</p>

<a name="164886554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164886554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164886554">Patrick Massot (May 04 2019 at 20:56)</a>:</h4>
<p>Kevin, the way this is going, we'll soon have manifolds with boundary <em>and</em> corners. When we'll have differential forms this will be much more than enough for rectangle and semi-circles</p>

<a name="164887338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164887338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164887338">Kevin Buzzard (May 04 2019 at 21:17)</a>:</h4>
<p>Woo hoo we'll have de Rham. cohomology one day. Is this in any other theorem prover?</p>

<a name="167754387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/167754387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#167754387">Wojciech Nawrocki (Jun 10 2019 at 12:24)</a>:</h4>
<p>Is it possible to "unimport" <code>core</code>/<code>prelude</code>, i.e. the basic definitions of <code>nat</code>, <code>eq</code>, etc, leaving an environment pretty much free of any definitions?</p>

<a name="167754427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/167754427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#167754427">Kevin Buzzard (Jun 10 2019 at 12:25)</a>:</h4>
<p>You can put <code>prelude</code> at the top of your file</p>

<a name="167754438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/167754438" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#167754438">Kevin Buzzard (Jun 10 2019 at 12:25)</a>:</h4>
<p>which translates to "this file is part of the prelude" (so don't be importing all the prelude)</p>

<a name="167754444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/167754444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#167754444">Kevin Buzzard (Jun 10 2019 at 12:25)</a>:</h4>
<p>I've never used it, I've just seen people suggest it</p>

<a name="167754516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/167754516" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#167754516">Wojciech Nawrocki (Jun 10 2019 at 12:26)</a>:</h4>
<p>Yup, that seems to work. Thank you!</p>

<a name="167898225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/167898225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#167898225">Wojciech Nawrocki (Jun 11 2019 at 22:56)</a>:</h4>
<p>Is the notation <code>h.fn arg</code> given <code>class myclass (α: Type*) := (fn: α → ℕ)</code> and <code>[h: myclass α]</code> discouraged? It stops working for example if <code>fn: ℕ → α</code> because the type argument <code>α </code> to <code>myclass.fn</code> becomes explicit, i.e. <code>myclass.fn : Π (α : Type u_1) [c : myclass α], ℕ → α</code>.</p>

<a name="168518423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168518423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168518423">Adrian Chu (Jun 19 2019 at 15:44)</a>:</h4>
<p>Given a positive integer n, how to define a vector with n entries? Thanks</p>

<a name="168518493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168518493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168518493">Kenny Lau (Jun 19 2019 at 15:45)</a>:</h4>
<p><code>vector \alpha n</code></p>

<a name="168518616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168518616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168518616">Adrian Chu (Jun 19 2019 at 15:46)</a>:</h4>
<p>Oh, and say x is the vector, how do we decribe its i-th entry?</p>

<a name="168518620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168518620" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168518620">Kenny Lau (Jun 19 2019 at 15:46)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>
<span class="n">universes</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span>
</pre></div>

<a name="168518656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168518656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168518656">Kenny Lau (Jun 19 2019 at 15:47)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>
<span class="n">universes</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">v</span><span class="bp">.</span><span class="n">nth</span> <span class="n">k</span>
</pre></div>

<a name="168519365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168519365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168519365">Adrian Chu (Jun 19 2019 at 15:55)</a>:</h4>
<p>how to do summation from i=1 to n ?</p>

<a name="168519856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168519856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168519856">Kenny Lau (Jun 19 2019 at 16:00)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector2</span>
<span class="n">universes</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">v</span><span class="bp">.</span><span class="n">to_list</span><span class="bp">.</span><span class="n">sum</span>
</pre></div>

<a name="168521168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168521168" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168521168">Adrian Chu (Jun 19 2019 at 16:18)</a>:</h4>
<p>one more question: how do we define new 3-vector, say, (x,y,x+y) where x, y are variable?</p>

<a name="168521321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168521321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168521321">Adrian Chu (Jun 19 2019 at 16:20)</a>:</h4>
<p>and more importantly, is there some online resource where I can read and get familiarized with these simple commands? I skimmed through theorem_proving_in_lean.pdf and couldn't find what I want... I feel like i'm asking too many noob questions like an idiot lol</p>

<a name="168521500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168521500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168521500">Kenny Lau (Jun 19 2019 at 16:23)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>
<span class="n">universes</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="bp">⟨</span><span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="bp">+</span><span class="n">y</span><span class="o">],</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="mi">3</span><span class="o">)</span>
</pre></div>

<a name="168521617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168521617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168521617">Adrian Chu (Jun 19 2019 at 16:25)</a>:</h4>
<p>how about an n-vector like (x, 2x, 3x, ..., nx)? <span aria-label="mischievous" class="emoji emoji-1f61b" role="img" title="mischievous">:mischievous:</span></p>

<a name="168521647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168521647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168521647">Bryan Gin-ge Chen (Jun 19 2019 at 16:25)</a>:</h4>
<blockquote>
<p>is there some online resource where I can read and get familiarized with these simple commands</p>
</blockquote>
<p>Unfortunately there isn't much beyond TPiL. You'll have to get used to reading source files. <a href="https://github.com/leanprover/lean/blob/master/library/data/vector.lean" target="_blank" title="https://github.com/leanprover/lean/blob/master/library/data/vector.lean">Here's data.vector</a>.</p>

<a name="168521728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168521728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168521728">Adrian Chu (Jun 19 2019 at 16:26)</a>:</h4>
<blockquote>
<blockquote>
<p>is there some online resource where I can read and get familiarized with these simple commands</p>
</blockquote>
<p>Unfortunately there isn't much beyond TPiL. You'll have to get used to reading source files. <a href="https://github.com/leanprover/lean/blob/master/library/data/vector.lean" target="_blank" title="https://github.com/leanprover/lean/blob/master/library/data/vector.lean">Here's data.vector</a>.</p>
</blockquote>
<p>Oh i see, thanks</p>

<a name="168521872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168521872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168521872">Floris van Doorn (Jun 19 2019 at 16:28)</a>:</h4>
<p>Currently, if you want to figure these things out yourself, the best way is just to look through the library files in mathlib (and core). You can go to <code>data/vector2</code> in mathlib or the file Bryan mentioned in core. Also, operations on list might be useful to know for vectors. Other ways to find things you're searching for: </p>
<ul>
<li>Browse through files (either on Github or locally)</li>
<li>"Go to definition" and "peek definition" (F12 and alt-F12 / option-F12?)</li>
<li>Search in VSCode (ctrl+shift+F)</li>
<li>Search on Github</li>
<li>Execute <code>#print prefix vector</code> in Lean</li>
<li>Find lemmas using the tactic <code>library_search</code></li>
</ul>

<a name="168521944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168521944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168521944">Floris van Doorn (Jun 19 2019 at 16:29)</a>:</h4>
<blockquote>
<p>(x, 2x, 3x, ..., nx)</p>
</blockquote>
<p>without looking at the library: hopefully <code>vector.range</code> and <code>vector.map</code> both exists, from which you should be able to figure it out (if not, use <code>list.range</code> and/or <code>list.map</code>)</p>

<a name="168522426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168522426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168522426">Kenny Lau (Jun 19 2019 at 16:35)</a>:</h4>
<blockquote>
<p>how about an n-vector like (x, 2x, 3x, ..., nx)? <span aria-label="mischievous" class="emoji emoji-1f61b" role="img" title="mischievous">:mischievous:</span></p>
</blockquote>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group_power</span> <span class="n">data</span><span class="bp">.</span><span class="n">pnat</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>
<span class="n">universes</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span>
<span class="n">def</span> <span class="n">multiple</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">x</span> <span class="c1">-- junk value</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">x</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">multiple</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">x</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="bp">⟨</span><span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">multiple</span> <span class="n">x</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)),</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span>
</pre></div>

<a name="168523081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168523081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168523081">Floris van Doorn (Jun 19 2019 at 16:43)</a>:</h4>
<p>If \a is an <code>add_monoid</code>, you can use <code>add_monoid.smul</code> instead of <code>multiple</code></p>

<a name="168524430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168524430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168524430">Adrian Chu (Jun 19 2019 at 17:00)</a>:</h4>
<blockquote>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector2</span>
<span class="n">universes</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">v</span><span class="bp">.</span><span class="n">to_list</span><span class="bp">.</span><span class="n">sum</span>
</pre></div>


</blockquote>
<p>Is there a way to do summation without using vector?</p>

<a name="168524753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168524753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168524753">Johan Commelin (Jun 19 2019 at 17:02)</a>:</h4>
<p>You might be interested in <code>finset.sum</code> and <code>finset.range</code>. The first gives you sums, the second gives you the <code>finset</code> "{0, ..., n-1}"</p>

<a name="168524885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168524885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168524885">Kevin Buzzard (Jun 19 2019 at 17:04)</a>:</h4>
<p><span class="user-mention" data-user-id="218709">@Adrian Chu</span> the problem is that TPIL just deals with core Lean, and you are asking about how to use stuff in the maths library. When I was learning the basics, I found the maths library very intimidating, but when I realised that I should just stop reading the proofs and instead just look at the definitions, I found that I could proceed with my mathematics very nicely, which in turn led to more understanding, which in turn made reading the proofs which I had been ignoring all this time much easier.</p>
<p>One thing I learnt fairly quickly was to abstract exactly what I wanted. For example you asked how to make (x, 2x, 3x, ..., nx). But in fact you can break this down into smaller questions. Probably you know well how to make a function like <code>lam n, (n + 1) * x</code>, so then you realise that what you really need is how to make (f 0, f 1, ..., f m). Now from general functional programming you might know that they like things like working out how to take a function f and to apply it to a vector like (0 1 2 ... n) so now you have two smaller questions -- how to make a vector like (0 1 2 ... n) and how to apply a function to every element of a vector. By this stage we are in the world where these ideas have a common name -- <code>range</code> for (0 1 2 ... n) and <code>map</code> for applying a function to a bunch of things at once. Now you can begin to guess the actual names of the functions you want. </p>
<p>Learning to think this way was a very important stepping stone for me; I slowly began to realise that I was developing a method for being able to answer my own questions of this nature. I am still learning, but this is the way to think about it. For every question, figure out how to build it from general tools and then figure out where those general tools are, perhaps by figuring out first what they should be called.</p>

<a name="168525940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168525940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168525940">Adrian Chu (Jun 19 2019 at 17:16)</a>:</h4>
<p>I see... I feel that TPiL is like a book teaching grammar, while mathlib is a dictionary. And knowing all the grammar does not immediately guarantee one can fluently read a dictionary, let alone writing sentences or paragraphs.</p>

<a name="168538087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168538087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168538087">Kevin Buzzard (Jun 19 2019 at 19:27)</a>:</h4>
<p>If you look through something like <code>data.list.basic</code> and take a look at just the names and the statements of the theorems, you can learn a lot about mathlib's naming conventions. The description above (breaking what you want down into small pieces) is I think how you're supposed to think about functional programming; the same sort of themes come up again and again; import <code>data.finset</code> and then use <code>#check</code> to look at the types of <code>list.map</code> and <code>multiset.map</code> and <code>finset.map</code> and it slowly dawns on you that <code>map</code> means a very specific thing in this game. Then try <code>list.range</code> and <code>multiset.range</code> and <code>finset.range</code>. It will slowly dawn on you by people are suggesting that you use <code>vector.map</code> and <code>vector.range</code> without even knowing if these functions are defined in Lean -- and if they're not then it's not hard to make them.</p>

<a name="168565250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168565250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168565250">Luis Berlioz (Jun 20 2019 at 04:08)</a>:</h4>
<p>Can I place a variable declaration in the middle of a proof? <br>
For example instead of this:</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="n">s</span> <span class="o">:</span> <span class="n">α</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">→</span> <span class="o">(</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">hr</span> <span class="o">:</span> <span class="n">r</span><span class="o">,</span>
<span class="k">show</span> <span class="o">(</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">r</span><span class="o">),</span> <span class="k">from</span>  <span class="bp">⟨</span> <span class="n">s</span><span class="o">,</span> <span class="n">hr</span> <span class="bp">⟩</span>
</pre></div>


<p>I want the variable <code>s : α </code> declared inside the proof, like:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">→</span> <span class="o">(</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">hr</span> <span class="o">:</span> <span class="n">r</span><span class="o">,</span>
<span class="kn">variable</span> <span class="n">s</span> <span class="o">:</span> <span class="n">α</span>
<span class="k">show</span> <span class="o">(</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">r</span><span class="o">),</span> <span class="k">from</span>  <span class="bp">⟨</span> <span class="n">s</span><span class="o">,</span> <span class="n">hr</span> <span class="bp">⟩</span>
</pre></div>

<a name="168565314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168565314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168565314">Johan Commelin (Jun 20 2019 at 04:10)</a>:</h4>
<p>No, that's not possible. Maybe you mean <code>have</code> or <code>let</code>?</p>

<a name="168565329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168565329" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168565329">Johan Commelin (Jun 20 2019 at 04:11)</a>:</h4>
<p>The goal is to prove that some <code>alpha</code> exists. You can't just grab it out of nowhere.</p>

<a name="168565408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168565408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168565408">Luis Berlioz (Jun 20 2019 at 04:13)</a>:</h4>
<p>Ok, that makes sense.</p>

<a name="168583023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168583023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168583023">Adrian Chu (Jun 20 2019 at 10:14)</a>:</h4>
<p>how to fix <br>
<code>def y := [1,2,3] 
#eval 4+y.nth 2</code> ? why can't I add?</p>

<a name="168583185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168583185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168583185">Mario Carneiro (Jun 20 2019 at 10:16)</a>:</h4>
<p>nth returns <code>option nat</code></p>

<a name="168583205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168583205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168583205">Mario Carneiro (Jun 20 2019 at 10:17)</a>:</h4>
<p>you should be able to use <code>y.nth_le 2 dec_trivial</code></p>

<a name="168583631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168583631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168583631">Adrian Chu (Jun 20 2019 at 10:25)</a>:</h4>
<p>oh it works, thanks! but what do .nth_le and dec_trivial means?</p>

<a name="168583717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168583717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168583717">Mario Carneiro (Jun 20 2019 at 10:26)</a>:</h4>
<p>no one wants an array out of bounds exception</p>

<a name="168583726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168583726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168583726">Mario Carneiro (Jun 20 2019 at 10:26)</a>:</h4>
<p>the dec_trivial is a proof that 2 &lt; 3</p>

<a name="168584110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168584110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168584110">Adrian Chu (Jun 20 2019 at 10:32)</a>:</h4>
<p>i see</p>

<a name="168585134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168585134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168585134">Adrian Chu (Jun 20 2019 at 10:52)</a>:</h4>
<p>How about </p>
<div class="codehilite"><pre><span></span>def y := [1,2,3]
def g (i : fin 3) : ℕ := y.nth_le i-1
def f (i : fin 3) : ℕ := 4 + y.nth_le i-1 dec_trivial
</pre></div>


<p>? What's wrong?</p>

<a name="168587909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168587909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168587909">Reid Barton (Jun 20 2019 at 11:42)</a>:</h4>
<p>Clearly you intended to have parentheses around <code>i-1</code>, but I'm not sure what you are trying to achieve</p>

<a name="168588087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168588087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168588087">Wojciech Nawrocki (Jun 20 2019 at 11:45)</a>:</h4>
<p>Yep, function application binds tighter than subtraction, so to express what you want you need to put parentheses around <code>i-1</code>. You're also missing a proof that <code>(i-i &lt; list.length y)</code> in <code>g</code> (no second argument is given).</p>

<a name="168589081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168589081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168589081">Adrian Chu (Jun 20 2019 at 12:03)</a>:</h4>
<blockquote>
<p>Yep, function application binds tighter than subtraction, so to express what you want you need to put parentheses around <code>i-1</code>. You're also missing a proof that <code>(i-i &lt; list.length y)</code> in <code>g</code> (no second argument is given).</p>
</blockquote>
<p>How exactly should I give the proof then?</p>

<a name="168589164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168589164" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168589164">Mario Carneiro (Jun 20 2019 at 12:04)</a>:</h4>
<p>You could use <code>fin.last</code> instead</p>

<a name="168589276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168589276" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168589276">Mario Carneiro (Jun 20 2019 at 12:06)</a>:</h4>
<p>If you were doing this from scratch, you would be proving i-1 &lt; 3 given i &lt; 3. There are theorems in data.nat.basic to help with this</p>

<a name="168589294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168589294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168589294">Mario Carneiro (Jun 20 2019 at 12:06)</a>:</h4>
<p>alternatively, you can skip the proof and just handle the possibility of error using <code>nth</code></p>

<a name="168589705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168589705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168589705">Wojciech Nawrocki (Jun 20 2019 at 12:14)</a>:</h4>
<p>I'm kinda surprised that <code>forall (n m k: nat), n &lt; m -&gt; n-k &lt; m</code> isn't already in mathlib.</p>

<a name="168590997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168590997" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168590997">Mario Carneiro (Jun 20 2019 at 12:36)</a>:</h4>
<p>it's just the composition of lt_of_le_of_lt and sub_le</p>

<a name="168641043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168641043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168641043">Scott Morrison (Jun 20 2019 at 22:45)</a>:</h4>
<p>That said, I think we should add it. Finding these lemmas is excruciating for beginners (who haven't even learnt that you can in principle guess the names of most basic facts, let alone learnt how to do it).</p>

<a name="168641134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168641134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168641134">Scott Morrison (Jun 20 2019 at 22:47)</a>:</h4>
<p>How bad is the downside of swamping Lean with these sort of "composition of two lemmas" lemmas?</p>

<a name="168641154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168641154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168641154">Mario Carneiro (Jun 20 2019 at 22:47)</a>:</h4>
<p>there is a combinatorial explosion</p>

<a name="168641198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168641198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168641198">Mario Carneiro (Jun 20 2019 at 22:48)</a>:</h4>
<p>it's not even clear which compositions are the most common</p>

<a name="168641218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168641218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168641218">Mario Carneiro (Jun 20 2019 at 22:48)</a>:</h4>
<p>and we don't even have the complete set of basic lemmas</p>

<a name="168641245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168641245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168641245">Mario Carneiro (Jun 20 2019 at 22:49)</a>:</h4>
<p>I would rather put more smarts into <code>library_search</code>type provers than flood the library with random facts</p>

<a name="168643353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168643353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168643353">Scott Morrison (Jun 20 2019 at 23:27)</a>:</h4>
<p>/me needs to get back to <code>back</code></p>

<a name="168646368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168646368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168646368">Tim Daly (Jun 21 2019 at 00:35)</a>:</h4>
<p>There need not be a combinatorial explosion, nor does the naming convention have to be so baroque.</p>
<p>It appears to me that Lean is using a flat namespace.  The naming convention makes it really hard to guess what you need.</p>
<p>Farmer and Carette (McMaster U.) have the notion of "tiny theories" which intrioduce a single axiom or a single signature. These can be combined to form larger objects which inherit the axioms and signatures. So, for instance, there would be a "commutative" axiom which can be inherited everywhere it makes sense.</p>
<p>This hierarchical organization enables re-use of axioms and signatures and allows the same name to occur in different paths in the inheritance graph.</p>

<a name="168646462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168646462" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168646462">Mario Carneiro (Jun 21 2019 at 00:37)</a>:</h4>
<p>Lean has namespaces, which are used to label the major components in the theorem, or the broad area in which it lives</p>

<a name="168646544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168646544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168646544">Mario Carneiro (Jun 21 2019 at 00:39)</a>:</h4>
<p>The naming convention is designed to be easy to guess based on the statement, so you can think of a statement that you think is true and then search for the corresponding name. I'm curious how you would propose to improve on that scheme</p>

<a name="168646671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168646671" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168646671">Mario Carneiro (Jun 21 2019 at 00:41)</a>:</h4>
<p>The number of theorems does increase exponentially as the depth increases. If there are n theorems, then there are O(n^2) ways to compose two of them, O(n^3) ways to compose three, and so on. Even 2n theorems is a major increase; n^2 is totally intractable</p>

<a name="168646829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168646829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168646829">Tim Daly (Jun 21 2019 at 00:44)</a>:</h4>
<p>Namespaces don't implement an inheritance graph in any generality. You'd like to state the commutative axiom in one place in the graph and have it available whereever it is used.  What you really want is genreal "name polymorphism" so that the name 'factor' can have different semantics in different contexts. Using 'dotted namespace notation' forces the user to manage the namespace. This doesn't scale.</p>

<a name="168646851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168646851" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168646851">Scott Morrison (Jun 21 2019 at 00:45)</a>:</h4>
<p>Well... only a fraction of those n^2 theorems actually make sense. I wish I had a better sense of what that fraction was. I guess this could be automated. :-)</p>

<a name="168646874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168646874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168646874">Scott Morrison (Jun 21 2019 at 00:45)</a>:</h4>
<p><span class="user-mention" data-user-id="223495">@Tim Daly</span>, of course Lean does state the commutative axiom only once.</p>

<a name="168646924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168646924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168646924">Scott Morrison (Jun 21 2019 at 00:46)</a>:</h4>
<p>(Okay, twice, once for "additive" structures and once for "multiplicative", which is lame, but still, it's only 2. :-)</p>

<a name="168647408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168647408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168647408">Tim Daly (Jun 21 2019 at 00:58)</a>:</h4>
<p>How does Lean handle a Lie algebra? Lie groups are skew-symmetric and they are non-associative. So</p>
<p>x*y = -y * x and</p>
<p>x * (y  * z) = (x * y) * z + y * (x * z)</p>
<p>Do you have to "built it from nothing" using an odd naming convention for things like "algebra.lie.cross_product_skew_symmetric."?</p>
<p>Axiom, which uses something similar to Farmer/Carette "tiny theories" has 10,000 functions but a much smaller set of names.</p>

<a name="168647526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168647526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168647526">Scott Morrison (Jun 21 2019 at 01:01)</a>:</h4>
<p>As far as I'm aware no one has done anything on Lie algebras yet.</p>

<a name="168647779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168647779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168647779">Mario Carneiro (Jun 21 2019 at 01:08)</a>:</h4>
<p>We would normally use some naming convention based on the symbols in the axiom, but for core laws that have names we have a small set of name segments to describe the law. We've not dealt with these laws before, so I guess they would require a new terminology; I would use something like <code>lie_algebra.mul_anticomm</code> and <code>lie_algebra.jacobi</code> for these</p>

<a name="168647854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168647854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168647854">Mario Carneiro (Jun 21 2019 at 01:10)</a>:</h4>
<p>You should take a look at <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/naming.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/naming.md">https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/naming.md</a></p>

<a name="168647855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168647855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168647855">Scott Morrison (Jun 21 2019 at 01:10)</a>:</h4>
<p>I wonder, actually, if we'd even want to use <code>mul</code> for a Lie algebra. It's true that it distributes over addition just as a "normal" multiplication does, but otherwise has little in common.</p>

<a name="168648328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648328" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648328">Tim Daly (Jun 21 2019 at 01:23)</a>:</h4>
<p>This places the burden of finding multiplication in an algebra on the user's ability to infer names. Polymorphic names could be disambiguated by a prolog-like match algorithm. The naming convention "is what it is", of course.  But it seems to me that I have to read the original sources and "internalize" the names in my mind, which is a very small place.</p>

<a name="168648394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648394">Mario Carneiro (Jun 21 2019 at 01:24)</a>:</h4>
<p>I'm not sure what problem you are trying to solve. There are multiple theorems with the same name in different namespaces, and we take care to have them be the same or clearly analogous</p>

<a name="168648474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648474">Mario Carneiro (Jun 21 2019 at 01:26)</a>:</h4>
<p>If you have multiple theorems with the same name in scope (because you have opened multiple namespaces), it will disambiguate them based on the type</p>

<a name="168648560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648560">Andrew Ashworth (Jun 21 2019 at 01:29)</a>:</h4>
<p>isn't this tiny theory system the type class inference system in disguise?</p>

<a name="168648564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648564" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648564">Tim Daly (Jun 21 2019 at 01:29)</a>:</h4>
<p>Namespaces are a kind of type in that case. If they were all "in scope" then there is no need for namespaces?</p>

<a name="168648615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648615">Andrew Ashworth (Jun 21 2019 at 01:30)</a>:</h4>
<p>specifically the often linked "unbundled type classes" section here: <a href="https://github.com/leanprover/lean/wiki/Refactoring-structures" target="_blank" title="https://github.com/leanprover/lean/wiki/Refactoring-structures">https://github.com/leanprover/lean/wiki/Refactoring-structures</a></p>

<a name="168648616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648616">Mario Carneiro (Jun 21 2019 at 01:30)</a>:</h4>
<p>well no, namespaces are separate from types. The type system is DTT, the namespace system is just names and overloading</p>

<a name="168648617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648617">Tim Daly (Jun 21 2019 at 01:30)</a>:</h4>
<p>Disguise? It is the type class inference problem.</p>

<a name="168648639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648639">Tim Daly (Jun 21 2019 at 01:31)</a>:</h4>
<p>I admit ignorance of the full details. Further study on my part is needed.</p>

<a name="168648694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648694">Mario Carneiro (Jun 21 2019 at 01:32)</a>:</h4>
<p>You can always refer to a theorem by its full name if the file that defines it has been imported. Opening a namespace just makes the name a bit shorter to reference</p>

<a name="168653056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168653056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168653056">Adrian Chu (Jun 21 2019 at 03:35)</a>:</h4>
<p>Btw, when Lean 4 comes out one day, what will happen to mathlib?</p>

<a name="168653498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168653498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168653498">Mario Carneiro (Jun 21 2019 at 03:48)</a>:</h4>
<p>Lean 4 is already "out", but not production ready. When it is solid we will start working on a port</p>

<a name="168653519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168653519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168653519">Mario Carneiro (Jun 21 2019 at 03:49)</a>:</h4>
<p>there isn't much point working on it at scale yet because it's too unstable and unfinished, although testing out a single file might be worthwhile</p>

<a name="168653626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168653626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168653626">Adrian Chu (Jun 21 2019 at 03:52)</a>:</h4>
<p>I see, then when it's stable enough, how much manual work is needed to update mathlib?</p>

<a name="168653653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168653653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168653653">Bryan Gin-ge Chen (Jun 21 2019 at 03:53)</a>:</h4>
<p>(deleted)</p>

<a name="168653654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168653654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168653654">Mario Carneiro (Jun 21 2019 at 03:53)</a>:</h4>
<p>somewhere between "a significant endeavor" and "a total overhaul"</p>

<a name="168653715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168653715" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168653715">Mario Carneiro (Jun 21 2019 at 03:54)</a>:</h4>
<p>If we can get any refactoring tools in lean 3.5c then it may make this a lot easier. There is a lot of silly busywork like changing the naming convention</p>

<a name="168666562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168666562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168666562">Adrian Chu (Jun 21 2019 at 09:12)</a>:</h4>
<div class="codehilite"><pre><span></span>variable n : ℕ
def vec_exp1 (i : fin n) (x : vector ℕ n) (y : vector ℕ n) : ℕ :=
    (x.nth i)^(y.nth i)
def vec_exp2 (x : vector ℕ n) (y : vector ℕ n) : vector ℕ n :=
    ⟨(list.range n).map (λ i, vec_exp1 i x y), by simp⟩
</pre></div>

<a name="168666608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168666608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168666608">Adrian Chu (Jun 21 2019 at 09:13)</a>:</h4>
<p>I am trying to compute the entry-wise exponential of two n-vector. but the last line has error: the term x has type vector N n but is expected to have type fin i. what is wrong??</p>

<a name="168666669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168666669" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168666669">Adrian Chu (Jun 21 2019 at 09:14)</a>:</h4>
<p>btw if i change n to 3, it works</p>

<a name="168666781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168666781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168666781">Mario Carneiro (Jun 21 2019 at 09:17)</a>:</h4>
<p>the variable <code>n : N</code> is getting added to <code>vec_exp1</code>, so it actually takes four arguments</p>

<a name="168666785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168666785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168666785">Mario Carneiro (Jun 21 2019 at 09:17)</a>:</h4>
<p>you should make it implicit by writing it in braces</p>

<a name="168667135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168667135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168667135">Adrian Chu (Jun 21 2019 at 09:24)</a>:</h4>
<p>ah i see! but now I'm getting another error in the last line: vec_exp1 i, the term i has type \N but is expected to have type fin ?m_1. how can I fix it?</p>

<a name="168668282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168668282" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168668282">Kevin Buzzard (Jun 21 2019 at 09:48)</a>:</h4>
<p>If you hover over <code>vec_exp1</code> you can see it has type <code>vec_exp1 : Π {n : ℕ}, fin n → vector ℕ n → vector ℕ n → ℕ</code>. So it wants an input of type <code>fin n</code> and an input of type <code>vector ℕ n</code>. If you hover over <code>i</code> you see it has type <code>ℕ</code>. So now you can understand the error. How to fix it -- make the types correct ;-) Do you have a more specific question?</p>

<a name="168668574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168668574" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168668574">Kevin Buzzard (Jun 21 2019 at 09:54)</a>:</h4>
<p>Do you understand how to interpret <code>(list.range n).map</code>? Hover over <code>list.range</code>  to see it has type <code>ℕ → list ℕ</code>. So <code>list.range n</code> has type <code>list ℕ</code>. Now this clever <code>l.map</code> thing means <code>list.map l</code> and doing <code>#check list.map</code> you can see the type of that too. You can just unravel everything. Your code doesn't work because when you unravel it it doesn't make sense.</p>

<a name="168668701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168668701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168668701">Kevin Buzzard (Jun 21 2019 at 09:57)</a>:</h4>
<p>Figuring out yourself what you want to do and then the types of the functions you want which will do them is a really good exercise for Lean beginners. It gets you thinking in the "functional programming" way.</p>

<a name="168668956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168668956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168668956">Kevin Buzzard (Jun 21 2019 at 10:01)</a>:</h4>
<p>I think you would be better off using <code>vector.map</code> than <code>list.map</code> because you're dealing with vectors. I see there is no <code>vector.range</code> though. It would be a good exercise to define <code>vector.range</code> first. Its type should be this:</p>
<p><code>def vector.range : Π (n : ℕ), vector ℕ n := sorry</code></p>

<a name="168670254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168670254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168670254">Adrian Chu (Jun 21 2019 at 10:28)</a>:</h4>
<blockquote>
<p>If you hover over <code>vec_exp1</code> you can see it has type <code>vec_exp1 : Π {n : ℕ}, fin n → vector ℕ n → vector ℕ n → ℕ</code>. So it wants an input of type <code>fin n</code> and an input of type <code>vector ℕ n</code>. If you hover over <code>i</code> you see it has type <code>ℕ</code>. So now you can understand the error. How to fix it -- make the types correct ;-) Do you have a more specific question?</p>
</blockquote>
<p>yeah, i understand the error but just don't know what how to make i of type fin n. Should I use something like <code>max i n</code>? Also, why does <code>#check max 3 4</code> works while <code>#eval max 3 4</code> don't?</p>

<a name="168670266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168670266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168670266">Adrian Chu (Jun 21 2019 at 10:29)</a>:</h4>
<blockquote>
<p>I think you would be better off using <code>vector.map</code> than <code>list.map</code> because you're dealing with vectors. I see there is no <code>vector.range</code> though. It would be a good exercise to define <code>vector.range</code> first. Its type should be this:</p>
<p><code>def vector.range : Π (n : ℕ), vector ℕ n := sorry</code></p>
</blockquote>
<p>OK! i will try...</p>

<a name="168670605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168670605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168670605">Johan Commelin (Jun 21 2019 at 10:35)</a>:</h4>
<p>Actually... why do you want to work with <code>vector</code>s?</p>

<a name="168670613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168670613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168670613">Johan Commelin (Jun 21 2019 at 10:35)</a>:</h4>
<p>That's the annoying thing: you have to choose a data representation.</p>

<a name="168670617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168670617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168670617">Johan Commelin (Jun 21 2019 at 10:35)</a>:</h4>
<p>It could be <code>list</code>, or <code>vector</code> or maps from <code>fin n</code>.</p>

<a name="168670620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168670620" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168670620">Johan Commelin (Jun 21 2019 at 10:35)</a>:</h4>
<p>Possibly other choices.</p>

<a name="168670630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168670630" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168670630">Johan Commelin (Jun 21 2019 at 10:36)</a>:</h4>
<p>What is the end goal?</p>

<a name="168670670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168670670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168670670">Johan Commelin (Jun 21 2019 at 10:36)</a>:</h4>
<p>"Just goofing around" <em>is</em> a valid answer, in which case using <code>vector</code>s is totally fine.</p>

<a name="168671100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168671100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168671100">Adrian Chu (Jun 21 2019 at 10:46)</a>:</h4>
<blockquote>
<p>What is the end goal?</p>
</blockquote>
<p>The goal is simply to have an n-tuple of numbers. Now you mention it, fin n \to \N does sounds a lot more simplier. I will use this....</p>

<a name="168672315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168672315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168672315">Johan Commelin (Jun 21 2019 at 11:11)</a>:</h4>
<blockquote>
<p><code>fin n → ℕ</code> does sounds a lot more simplier.</p>
</blockquote>
<p>Depends...</p>

<a name="168672339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168672339" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168672339">Johan Commelin (Jun 21 2019 at 11:11)</a>:</h4>
<p>If you want to write down an explicit 5-tuple, I guess <code>vector</code> is easier.</p>

<a name="168675134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168675134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168675134">Adrian Chu (Jun 21 2019 at 12:02)</a>:</h4>
<blockquote>
<blockquote>
<p><code>fin n → ℕ</code> does sounds a lot more simplier.</p>
</blockquote>
<p>Depends...</p>
</blockquote>
<p>say now i have  <code>f:fin n → ℕ</code> and want to calculate f(1)+...+f(n). do I have to convert f  to a vector and use <code>.tolist_sum</code> ? or is there a more direct way?</p>

<a name="168676828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168676828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168676828">Alexander Bentkamp (Jun 21 2019 at 12:29)</a>:</h4>
<p>Try <code>finset.univ.sum</code>.</p>

<a name="168684121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168684121" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168684121">Adrian Chu (Jun 21 2019 at 14:02)</a>:</h4>
<p>i know that int.gcd can find the gcd of two numbers. how about finding the gcd of n numbers? what is the best way?</p>

<a name="168684813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168684813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168684813">Marc Huisinga (Jun 21 2019 at 14:12)</a>:</h4>
<p>since gcd is an associative function, you can foldr or foldl over the collection of numbers</p>

<a name="168688556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168688556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168688556">Kevin Buzzard (Jun 21 2019 at 14:59)</a>:</h4>
<blockquote>
<p>yeah, i understand the error but just don't know what how to make i of type fin n. Should I use something like <code>max i n</code>?</p>
</blockquote>
<p>Do you understand how to make a term of type <code>fin n</code>? By definition, a term of type <code>fin n</code> is a pair, consisting of a natural number <code>i</code> and a proof that <code>i &lt; n</code>. In your function you seem to have a random natural number <code>i</code> with no conditions at all, so it will be impossible to prove that <code>i &lt; n</code>. That was why I was encouraging you to step back a bit and think about the functions you're using and what you're doing.</p>
<blockquote>
<p>Also, why does <code>#check max 3 4</code> works while <code>#eval max 3 4</code> don't?</p>
</blockquote>
<p><code>#eval max 3 4</code> works for me. Can you post a MWE?</p>

<a name="168689946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168689946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168689946">Adrian Chu (Jun 21 2019 at 15:17)</a>:</h4>
<p>What does MWE stand for? lol</p>

<a name="168690011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168690011" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168690011">Adrian Chu (Jun 21 2019 at 15:18)</a>:</h4>
<p>And the error message for <code>#eval max 3 4</code> is "code generation failed, VM does not have code for lattice.lattice.conditionally_complete_linear_order_bot'"</p>

<a name="168690036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168690036" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168690036">Kevin Buzzard (Jun 21 2019 at 15:18)</a>:</h4>
<p>Minimal working example. I type <code>#eval max 3 4</code> and it worked fine. I was wondering exactly what you did. A MWE is something you can cut and paste so I can see the error you're seeing. Currently I can't do that becaue you're only posting the line which gave the error.</p>

<a name="168690588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168690588" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168690588">Adrian Chu (Jun 21 2019 at 15:27)</a>:</h4>
<p>Oh, I figured it out. It is because I imported ring_theory.principal_ideal_domain</p>

<a name="168697094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168697094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168697094">Adrian Chu (Jun 21 2019 at 16:49)</a>:</h4>
<p>given positive integers a and b how can we prove that the sum of a b's is ab?</p>

<a name="168697161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168697161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168697161">Kevin Buzzard (Jun 21 2019 at 16:50)</a>:</h4>
<p>How are you defining the sum of <code>a</code> <code>b</code>'s? The devil is in the detail for this one.</p>

<a name="168697177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168697177" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168697177">Reid Barton (Jun 21 2019 at 16:50)</a>:</h4>
<p>And why do you want to prove it?</p>

<a name="168697472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168697472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168697472">Reid Barton (Jun 21 2019 at 16:53)</a>:</h4>
<p>You might decide the definition of <code>a * b</code> already answers your question</p>

<a name="168697479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168697479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168697479">Reid Barton (Jun 21 2019 at 16:53)</a>:</h4>
<p>Or possibly <code>b * a</code></p>

<a name="168697546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168697546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168697546">Adrian Chu (Jun 21 2019 at 16:54)</a>:</h4>
<blockquote>
<p>How are you defining the sum of <code>a</code> <code>b</code>'s? The devil is in the detail for this one.</p>
</blockquote>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  I'm using <code>finset.univ.sum (λ i : fin a, b)</code></p>

<a name="168697685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168697685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168697685">Adrian Chu (Jun 21 2019 at 16:56)</a>:</h4>
<blockquote>
<p>And why do you want to prove it?</p>
</blockquote>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> <br>
This is a crucial lemma in a theorem I wanna prove. Specifically, I need to prove that given positive integers b, c, the sum of b (b^c)'s is b^(c+1)</p>

<a name="168697749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168697749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168697749">Reid Barton (Jun 21 2019 at 16:57)</a>:</h4>
<p>Well this statement still has the phrase "the sum of <code>x</code> <code>y</code>s" in it so I could ask the same question again</p>

<a name="168697893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168697893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168697893">Reid Barton (Jun 21 2019 at 16:59)</a>:</h4>
<p>We all know the sum of X Ys is X * Y, so why not just formalize the statement using *</p>

<a name="168697904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168697904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168697904">Adrian Chu (Jun 21 2019 at 16:59)</a>:</h4>
<blockquote>
<p>Well this statement still has the phrase "the sum of <code>x</code> <code>y</code>s" in it so I could ask the same question again</p>
</blockquote>
<p>I need to show <code>finset.univ.sum (λ i : fin a, b)=a*b</code></p>

<a name="168697933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168697933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168697933">Reid Barton (Jun 21 2019 at 16:59)</a>:</h4>
<p>OK, that's a statement that we should be able to prove</p>

<a name="168698356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168698356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168698356">Kevin Buzzard (Jun 21 2019 at 17:05)</a>:</h4>
<p>I feel like this should be in the library. Is it <code>sum_const</code> or something? <em>shrug</em></p>

<a name="168698422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168698422" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168698422">Kevin Buzzard (Jun 21 2019 at 17:06)</a>:</h4>
<p><span class="user-mention" data-user-id="218709">@Adrian Chu</span> I would be tempted to find where <code>finset.sum</code> is defined in mathlib (just right click on it in VS Code and go to the definition) and take a look at the next 50 lemmas after its definition, to see if there is anything useful there.</p>

<a name="168698549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168698549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168698549">Adrian Chu (Jun 21 2019 at 17:08)</a>:</h4>
<p>I found this</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">sum_const</span> <span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">cardinal</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">})</span> <span class="o">:</span> <span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">:</span><span class="n">ι</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="n">mk</span> <span class="n">ι</span> <span class="bp">*</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">a</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="n">exact</span>
  <span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span> <span class="bp">⟨</span><span class="n">equiv</span><span class="bp">.</span><span class="n">sigma_equiv_prod</span> <span class="bp">_</span> <span class="bp">_⟩</span>
</pre></div>


<p>in set theory/cardinal</p>

<a name="168698817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168698817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168698817">Kevin Buzzard (Jun 21 2019 at 17:12)</a>:</h4>
<p>That's the wrong kind of sum. This is exactly why the devil is in the detail.</p>

<a name="168698905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168698905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168698905">Kevin Buzzard (Jun 21 2019 at 17:14)</a>:</h4>
<p>Was there nothing near finset.sum?</p>

<a name="168699318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168699318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168699318">Adrian Chu (Jun 21 2019 at 17:21)</a>:</h4>
<p>I can't see what I want (possibly due to my own ignorance)</p>

<a name="168699536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168699536" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168699536">Kevin Buzzard (Jun 21 2019 at 17:24)</a>:</h4>
<p>Ok I'll take a look.</p>

<a name="168699569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168699569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168699569">Kevin Buzzard (Jun 21 2019 at 17:24)</a>:</h4>
<p>It is indeed <code>finset.sum_const</code></p>

<a name="168699609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168699609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168699609">Kevin Buzzard (Jun 21 2019 at 17:25)</a>:</h4>
<p>You could have just tried <code>#check finset.sum_const</code></p>

<a name="168700280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168700280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168700280">Kevin Buzzard (Jun 21 2019 at 17:35)</a>:</h4>
<p>Aah, I bet you didn't have the right import.</p>

<a name="168700339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168700339" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168700339">Kevin Buzzard (Jun 21 2019 at 17:36)</a>:</h4>
<p><code>import algebra.big_operators</code></p>

<a name="168700370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168700370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168700370">Kevin Buzzard (Jun 21 2019 at 17:36)</a>:</h4>
<p>Yeah, I don't know how to search for it if you don't have the right import. It would be nice if it was easy just to import everything temporarily.</p>

<a name="168700416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168700416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168700416">Kevin Buzzard (Jun 21 2019 at 17:37)</a>:</h4>
<p>Oh wait, but you need that import for <code>finset.sum</code>...</p>

<a name="168701698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168701698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168701698">Kenny Lau (Jun 21 2019 at 17:52)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">:</span> <span class="n">finset</span> <span class="err">$</span> <span class="n">fin</span> <span class="n">a</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_const</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_univ</span><span class="o">,</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card_fin</span><span class="o">,</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul_eq_mul</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">cast_id</span><span class="o">]</span>
</pre></div>

<a name="168702954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168702954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168702954">Kevin Buzzard (Jun 21 2019 at 18:10)</a>:</h4>
<p>That's the way (or you can use simp instead of the last couple of things, I should think)</p>

<a name="168703000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168703000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168703000">Kevin Buzzard (Jun 21 2019 at 18:11)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span>  <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="bp">=</span><span class="n">a</span><span class="bp">*</span><span class="n">b</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_const</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_univ</span><span class="o">,</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card_fin</span><span class="o">]</span>
</pre></div>

<a name="168736064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168736064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168736064">Adrian Chu (Jun 22 2019 at 04:49)</a>:</h4>
<p>Thanks guys!</p>

<a name="168741659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168741659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168741659">Adrian Chu (Jun 22 2019 at 08:01)</a>:</h4>
<p>What command should I use to define a function f(x) from N to N with two cases, namely x &gt;= some fixed n and x &lt; n?</p>

<a name="168741707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168741707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168741707">Kevin Buzzard (Jun 22 2019 at 08:02)</a>:</h4>
<p>Lean has <code>if ... then ... else</code></p>

<a name="168741737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168741737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168741737">Kevin Buzzard (Jun 22 2019 at 08:03)</a>:</h4>
<p>The tactic you need to know to introduce it is <code>split_ifs</code>.</p>

<a name="168741787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168741787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168741787">Kevin Buzzard (Jun 22 2019 at 08:04)</a>:</h4>
<p><code>if...then...else</code> is harder to use than you might think, because Lean will by default refuse to do a case split on a condition unless it knows an algorithm for deciding whether the condition is true or not. In your case this should be no trouble.</p>

<a name="168742140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168742140" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168742140">Adrian Chu (Jun 22 2019 at 08:15)</a>:</h4>
<p>given a function f : fin n -&gt; N, how can I extend it to N -&gt; N by defining it to be zero when the input is &gt;= n ?</p>

<a name="168742185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168742185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168742185">Mario Carneiro (Jun 22 2019 at 08:16)</a>:</h4>
<p><code>if h : x &lt; n then f &lt;x, h&gt; else 0</code></p>

<a name="168745111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168745111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168745111">Kevin Buzzard (Jun 22 2019 at 10:01)</a>:</h4>
<p>You shouldn't think of <code>fin n</code> as some sort of subset of nat. There's a map from <code>fin n</code> to nat which forgets part of the structure. From your recent questions you seen to think that a term of type <code>fin n</code> is a nat. It's not -- it's a pair.</p>

<a name="168745330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168745330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168745330">Adrian Chu (Jun 22 2019 at 10:09)</a>:</h4>
<blockquote>
<p>You shouldn't think of <code>fin n</code> as some sort of subset of nat. There's a map from <code>fin n</code> to nat which forgets part of the structure. From your recent questions you seen to think that a term of type <code>fin n</code> is a nat. It's not -- it's a pair.</p>
</blockquote>
<p>ya, i know, i just didn't know that we can directly write <code>if h : x &lt; n</code> instead of <code>if x&lt;n</code></p>

<a name="168745519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168745519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168745519">Adrian Chu (Jun 22 2019 at 10:14)</a>:</h4>
<p>What is the correct syntax to define such a function <code>def f (x : ℕ) : ℕ := if x &lt; 10 then x else f (x-3)</code> recursively? (since I don't want to use mod for some other reason)</p>

<a name="168747175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168747175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168747175">Kevin Buzzard (Jun 22 2019 at 11:11)</a>:</h4>
<p>You will have to prove, somehow, that your function is well-defined. One thing you could do is just use the equation compiler, but that would stink a bit in this situation. You could define f zero = 0, f 1 = 1, ..., and then f (n+10) to be f(n+7). That might work.</p>

<a name="168747238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168747238" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168747238">Mario Carneiro (Jun 22 2019 at 11:13)</a>:</h4>
<p>you only have to go up to n+3</p>

<a name="168747242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168747242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168747242">Kevin Buzzard (Jun 22 2019 at 11:13)</a>:</h4>
<p>I'm not so sure it's as easy as that, because f(7) is not f(4)</p>

<a name="168747297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168747297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168747297">Mario Carneiro (Jun 22 2019 at 11:14)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">x</span><span class="bp">@</span><span class="o">(</span><span class="n">y</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">10</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">f</span> <span class="n">y</span>
<span class="bp">|</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span>
</pre></div>

<a name="168747306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168747306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168747306">Kevin Buzzard (Jun 22 2019 at 11:15)</a>:</h4>
<p>Nice!</p>

<a name="168747308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168747308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168747308">Mario Carneiro (Jun 22 2019 at 11:15)</a>:</h4>
<p>it still has 4 cases though</p>

<a name="168747312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168747312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168747312">Kevin Buzzard (Jun 22 2019 at 11:15)</a>:</h4>
<p>I have never had to push the equation compiler to its limits, so I don't really know these tricks.</p>

<a name="168747357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168747357" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168747357">Mario Carneiro (Jun 22 2019 at 11:16)</a>:</h4>
<p>try replacing <code>3</code> with <code>100</code></p>

<a name="168748314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168748314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168748314">Adrian Chu (Jun 22 2019 at 11:48)</a>:</h4>
<p>I see... Thanks.</p>

<a name="168748654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168748654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168748654">Adrian Chu (Jun 22 2019 at 11:59)</a>:</h4>
<blockquote>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">x</span><span class="bp">@</span><span class="o">(</span><span class="n">y</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">10</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">f</span> <span class="n">y</span>
<span class="bp">|</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span>
</pre></div>


</blockquote>
<p>But can someone please explain a bit what does this means?</p>

<a name="168748701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168748701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168748701">Kevin Buzzard (Jun 22 2019 at 12:00)</a>:</h4>
<p>Have you read the section about the equation compiler in TPIL?</p>

<a name="168748716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168748716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168748716">Kevin Buzzard (Jun 22 2019 at 12:00)</a>:</h4>
<p>It says "if x = y + 3 for some other nat y then do the first thing, else do the second thing"</p>

<a name="168748785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168748785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168748785">Adrian Chu (Jun 22 2019 at 12:03)</a>:</h4>
<p>well not yet. you are right, i should read it first :)</p>

<a name="168754082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168754082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168754082">Adrian Chu (Jun 22 2019 at 14:58)</a>:</h4>
<p>Now i have read the relevant sections in TPIL. But I still got a problem: How can I check the well foundedness of</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">y</span><span class="bp">+</span><span class="mi">3</span><span class="o">,</span> <span class="n">z</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">((</span><span class="n">y</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">((</span><span class="n">z</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="k">then</span> <span class="o">(</span><span class="n">y</span><span class="bp">+</span><span class="mi">3</span><span class="o">,</span> <span class="n">z</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="k">else</span> <span class="n">f</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span>
</pre></div>


<p>?</p>

<a name="168756726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168756726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168756726">Kevin Buzzard (Jun 22 2019 at 16:22)</a>:</h4>
<p>Some hints are here: <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/well_founded_recursion.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/well_founded_recursion.md">https://github.com/leanprover-community/mathlib/blob/master/docs/extras/well_founded_recursion.md</a></p>

<a name="168774276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168774276" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168774276">Bryan Gin-ge Chen (Jun 23 2019 at 02:19)</a>:</h4>
<p>I had a go at this <a href="https://bryangingechen.github.io/lean/lean-web-editor/#code=import%20data.prod%0A%2F-%0Aset_option%20pp.all%20true%0A-%2F%0A%0Adef%20f%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%C3%97%20%E2%84%95%0A%7C%20%28y%2B3%2C%20z%2B3%29%20%3A%3D%20have%20h%20%3A%20%28y%2C%20z%29.lex%20%28%3C%29%20%28%3C%29%20%28y%2B3%2C%20z%2B3%29%20%3A%3D%20begin%0A%20%20simp%20%5Bprod.lex_def%5D%2C%0A%20%20have%20hy%20%3A%20y%20%3C%20y%20%2B%203%20%3A%3D%20nat.lt_add_of_pos_right%20%28dec_trivial%29%2C%0A%20%20exact%20or.inl%20hy%2C%0Aend%2C%0A%20%20if%20%28%28y%2B3%29%20%3C%2010%29%20%E2%88%A7%20%28%28z%2B3%29%20%3C%2010%29%20then%0A%20%20%20%20%28y%2B3%2C%20z%2B3%29%20else%20f%20%28y%2C%20z%29%0A%7C%20%28y%2C%20z%29%20%3A%3D%20%28y%2C%20z%29%0A%0Adef%20f_curry%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%C3%97%20%E2%84%95%0A%7C%20%28y%2B3%29%20%28z%2B3%29%20%3A%3D%20if%20%28%28y%2B3%29%20%3C%2010%29%20%E2%88%A7%20%28%28z%2B3%29%20%3C%2010%29%20then%0A%20%20%20%20%28y%2B3%2C%20z%2B3%29%20else%20f_curry%20y%20z%0A%7C%20y%20z%20%3A%3D%20%28y%2C%20z%29%0A%0Adef%20f'%20%28p%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%29%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%3A%3D%20f_curry%20p.1%20p.2" target="_blank" title="https://bryangingechen.github.io/lean/lean-web-editor/#code=import%20data.prod%0A%2F-%0Aset_option%20pp.all%20true%0A-%2F%0A%0Adef%20f%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%C3%97%20%E2%84%95%0A%7C%20%28y%2B3%2C%20z%2B3%29%20%3A%3D%20have%20h%20%3A%20%28y%2C%20z%29.lex%20%28%3C%29%20%28%3C%29%20%28y%2B3%2C%20z%2B3%29%20%3A%3D%20begin%0A%20%20simp%20%5Bprod.lex_def%5D%2C%0A%20%20have%20hy%20%3A%20y%20%3C%20y%20%2B%203%20%3A%3D%20nat.lt_add_of_pos_right%20%28dec_trivial%29%2C%0A%20%20exact%20or.inl%20hy%2C%0Aend%2C%0A%20%20if%20%28%28y%2B3%29%20%3C%2010%29%20%E2%88%A7%20%28%28z%2B3%29%20%3C%2010%29%20then%0A%20%20%20%20%28y%2B3%2C%20z%2B3%29%20else%20f%20%28y%2C%20z%29%0A%7C%20%28y%2C%20z%29%20%3A%3D%20%28y%2C%20z%29%0A%0Adef%20f_curry%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%E2%86%92%20%E2%84%95%20%C3%97%20%E2%84%95%0A%7C%20%28y%2B3%29%20%28z%2B3%29%20%3A%3D%20if%20%28%28y%2B3%29%20%3C%2010%29%20%E2%88%A7%20%28%28z%2B3%29%20%3C%2010%29%20then%0A%20%20%20%20%28y%2B3%2C%20z%2B3%29%20else%20f_curry%20y%20z%0A%7C%20y%20z%20%3A%3D%20%28y%2C%20z%29%0A%0Adef%20f'%20%28p%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%29%20%3A%20%E2%84%95%20%C3%97%20%E2%84%95%20%3A%3D%20f_curry%20p.1%20p.2">here (web editor link)</a>:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">prod</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">set_option pp.all true</span>
<span class="cm">-/</span>

<span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">y</span><span class="bp">+</span><span class="mi">3</span><span class="o">,</span> <span class="n">z</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span><span class="bp">.</span><span class="n">lex</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span> <span class="o">(</span><span class="bp">&lt;</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span><span class="bp">+</span><span class="mi">3</span><span class="o">,</span> <span class="n">z</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">prod</span><span class="bp">.</span><span class="n">lex_def</span><span class="o">],</span>
  <span class="k">have</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">y</span> <span class="bp">+</span> <span class="mi">3</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_add_of_pos_right</span> <span class="o">(</span><span class="n">dec_trivial</span><span class="o">),</span>
  <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">hy</span><span class="o">,</span>
<span class="kn">end</span><span class="o">,</span>
  <span class="k">if</span> <span class="o">((</span><span class="n">y</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">((</span><span class="n">z</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="k">then</span>
    <span class="o">(</span><span class="n">y</span><span class="bp">+</span><span class="mi">3</span><span class="o">,</span> <span class="n">z</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="k">else</span> <span class="n">f</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="c1">-- error here, see below</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span>
</pre></div>


<p>However, I'm not able to satisfy the equation compiler either:</p>
<div class="codehilite"><pre><span></span>failed to prove recursive application is decreasing, well founded relation
  @has_well_founded.r (ℕ × ℕ)
    (@prod.has_well_founded ℕ ℕ (@has_well_founded_of_has_sizeof ℕ nat.has_sizeof)
       (@has_well_founded_of_has_sizeof ℕ nat.has_sizeof))
Possible solutions:
  - Use &#39;using_well_founded&#39; keyword in the end of your definition to specify tactics for synthesizing well founded relations and decreasing proofs.
  - The default decreasing tactic uses the &#39;assumption&#39; tactic, thus hints (aka local proofs) can be provided using &#39;have&#39;-expressions.
The nested exception contains the failure state for the decreasing tactic.
nested exception message:
match failed
state:
f : ℕ × ℕ → ℕ × ℕ,
y z : ℕ,
h : prod.lex has_lt.lt has_lt.lt (y, z) (y + 3, z + 3)
⊢ prod.lex has_lt.lt has_lt.lt (y, z) (y + 3, z + 3)
</pre></div>


<p>(Isn't <code>h</code> the same thing as the goal? Using <code>pp.all true</code> doesn't reveal any differences either)</p>
<p>I think it's easier to define <code>f</code> by working with the curried version, like this:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">f_curry</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">y</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">((</span><span class="n">y</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">((</span><span class="n">z</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="k">then</span>
    <span class="o">(</span><span class="n">y</span><span class="bp">+</span><span class="mi">3</span><span class="o">,</span> <span class="n">z</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="k">else</span> <span class="n">f_curry</span> <span class="n">y</span> <span class="n">z</span>
<span class="bp">|</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:=</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span>

<span class="n">def</span> <span class="n">f&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">f_curry</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span>
</pre></div>

<a name="168774487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168774487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168774487">Mario Carneiro (Jun 23 2019 at 02:26)</a>:</h4>
<p>I think, from the trajectory of the questions, that <span class="user-mention" data-user-id="218709">@Adrian Chu</span> wants to know how to do general recursions, rather than breaking them down into structural recursions. It looks like this:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">×</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">10</span> <span class="bp">∧</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="mi">10</span> <span class="k">then</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">else</span>
  <span class="k">have</span> <span class="n">has_well_founded</span><span class="bp">.</span><span class="n">r</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="mi">3</span><span class="o">,</span> <span class="n">y</span> <span class="bp">-</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">),</span> <span class="k">from</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">-</span> <span class="mi">3</span><span class="o">,</span> <span class="n">y</span> <span class="bp">-</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">using_well_founded</span> <span class="o">{</span> <span class="n">dec_tac</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">assumption</span><span class="o">]</span> <span class="o">}</span>
</pre></div>


<p>You have to give a proof that <code>(x - 3, y - 3) &lt; (x, y)</code> according to some well founded relation. The default one here is lexicographic order on the natural numbers, which works in this case but may need to be replaced with something else in other examples</p>

<a name="168776942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168776942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168776942">Adrian Chu (Jun 23 2019 at 03:57)</a>:</h4>
<p>I see.. I didn't know we have `[assumption]</p>

<a name="168776998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168776998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168776998">Adrian Chu (Jun 23 2019 at 03:59)</a>:</h4>
<p>I am trying to prove the following variant of Bazout lemma:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">baz</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">coprime</span> <span class="n">a</span> <span class="n">b</span><span class="o">):</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>


<p>As pointed before, we can use <code>gcd_a</code> and <code>gcd_b</code></p>

<a name="168777157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168777157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168777157">Adrian Chu (Jun 23 2019 at 04:04)</a>:</h4>
<p>but the trouble is gcd_a, gcd_b can be negative</p>

<a name="168777167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168777167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168777167">Adrian Chu (Jun 23 2019 at 04:05)</a>:</h4>
<p>so my plan is to keep adding multiples of a*b to <code>-gcd_a a b</code> and <code>gcd_b a b</code> repsectively until they are both &gt;= 0</p>

<a name="168777217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168777217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168777217">Adrian Chu (Jun 23 2019 at 04:07)</a>:</h4>
<p>But I run into 2 problems. First, (as an example,) given a recursive function like </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span>  <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">y</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">h</span><span class="o">:(</span><span class="n">y</span><span class="bp">+</span><span class="mi">3</span><span class="bp">&lt;</span><span class="mi">10</span><span class="o">)</span> <span class="k">then</span> <span class="o">(</span><span class="n">y</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span> <span class="k">else</span> <span class="n">f</span> <span class="n">y</span>
<span class="bp">|</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">y</span>
</pre></div>


<p>how can we show that f x &lt; 10 for all x ?</p>

<a name="168777283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168777283" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168777283">Adrian Chu (Jun 23 2019 at 04:09)</a>:</h4>
<p>second, given a function f from Z to Z and a proof that f x &gt;=0 for all x, how can we define a new function F from Z to N using f?</p>

<a name="168778028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168778028" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168778028">Mario Carneiro (Jun 23 2019 at 04:35)</a>:</h4>
<p>Rather than "repeatedly adding multiples of a*b", just add <code>k*a*b</code> for some k. This avoids all the mess of determining any well founded recursion, but it leaves the question - what is k?</p>

<a name="168778068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168778068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168778068">Mario Carneiro (Jun 23 2019 at 04:36)</a>:</h4>
<p>Also <code>baz</code> is really obviously false when <code>a = b = 0</code></p>

<a name="168778069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168778069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168778069">Mario Carneiro (Jun 23 2019 at 04:36)</a>:</h4>
<p>or more generally when they aren't coprime</p>

<a name="168778286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168778286" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168778286">Adrian Chu (Jun 23 2019 at 04:44)</a>:</h4>
<blockquote>
<p>Also <code>baz</code> is really obviously false when <code>a = b = 0</code></p>
</blockquote>
<p>oops, I carelessly left out the coprime condition. now fixed</p>

<a name="168778336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168778336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168778336">Mario Carneiro (Jun 23 2019 at 04:46)</a>:</h4>
<p>If a and b are both nonzero, then <code>a*b</code> is also nonzero, so it is at least 1 and hence <code>k*a*b</code> is at least k. So you can pick k to be <code>gcd_a a b</code> and then <code>k*a*b - gcd_a a b</code> will be nonnegative</p>

<a name="168778404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168778404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168778404">Adrian Chu (Jun 23 2019 at 04:49)</a>:</h4>
<blockquote>
<p>Rather than "repeatedly adding multiples of a*b", just add <code>k*a*b</code> for some k. This avoids all the mess of determining any well founded recursion, but it leaves the question - what is k?</p>
</blockquote>
<p>Yes, I have thought of that, we can choose <code>k=max (nat_abs (nat.gcd_a x y)) (nat_abs (nat.gcd_b x y))</code></p>

<a name="168778408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168778408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168778408">Adrian Chu (Jun 23 2019 at 04:49)</a>:</h4>
<p>yes yours is simpler!</p>

<a name="168778449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168778449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168778449">Mario Carneiro (Jun 23 2019 at 04:50)</a>:</h4>
<p>You can use either <code>to_nat</code> or <code>nat_abs</code> to turn a nonnegative int into a nat</p>

<a name="168778503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168778503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168778503">Adrian Chu (Jun 23 2019 at 04:52)</a>:</h4>
<p>ok, let me try now</p>

<a name="168778787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168778787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168778787">Adrian Chu (Jun 23 2019 at 05:02)</a>:</h4>
<blockquote>
<p>If a and b are both nonzero, then <code>a*b</code> is also nonzero, so it is at least 1 and hence <code>k*a*b</code> is at least k. So you can pick k to be <code>gcd_a a b</code> and then <code>k*a*b - gcd_a a b</code> will be nonnegative</p>
</blockquote>
<p>i was mistaken. we should add <code>k*b</code> to <code>-gcd_a a b</code> and add <code>k*a</code> to <code>gcd_b a b</code></p>

<a name="168778857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168778857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168778857">Adrian Chu (Jun 23 2019 at 05:04)</a>:</h4>
<p>and take <code>k = max (nat_abs (nat.gcd_a a b)) (nat_abs (nat.gcd_b a b))</code></p>

<a name="168790463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168790463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168790463">Adrian Chu (Jun 23 2019 at 11:26)</a>:</h4>
<p>May I ask how to prove<br>
<code>theorem test (a : ℤ) (ha : a &gt;= 0) : a = nat_abs a</code> ?</p>

<a name="168790473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168790473" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168790473">Kevin Buzzard (Jun 23 2019 at 11:26)</a>:</h4>
<p>Does cases on a work?</p>

<a name="168790476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168790476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168790476">Kevin Buzzard (Jun 23 2019 at 11:26)</a>:</h4>
<p>Alternatively just use library_search.</p>

<a name="168790483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168790483" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168790483">Kevin Buzzard (Jun 23 2019 at 11:27)</a>:</h4>
<p>You might want to import data.int.basic before you search</p>

<a name="168790548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168790548" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168790548">Kevin Buzzard (Jun 23 2019 at 11:28)</a>:</h4>
<p>Here's where I'm up to: <a href="https://github.com/kbuzzard/xena/blob/cd8e0de23adf8c0e7c56d39f1b6f5a55d93bf6ef/Examples/mario_glueing.lean#L144" target="_blank" title="https://github.com/kbuzzard/xena/blob/cd8e0de23adf8c0e7c56d39f1b6f5a55d93bf6ef/Examples/mario_glueing.lean#L144">https://github.com/kbuzzard/xena/blob/cd8e0de23adf8c0e7c56d39f1b6f5a55d93bf6ef/Examples/mario_glueing.lean#L144</a></p>

<a name="168792098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168792098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168792098">Kenny Lau (Jun 23 2019 at 12:17)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">int</span>
<span class="kn">theorem</span> <span class="n">test</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">a</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>

<a name="168792143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168792143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168792143">Kenny Lau (Jun 23 2019 at 12:18)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">open</span> <span class="n">int</span>
<span class="kn">theorem</span> <span class="n">test</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">a</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">nat_abs_of_nonneg</span> <span class="n">ha</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
</pre></div>

<a name="168795776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168795776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168795776">Adrian Chu (Jun 23 2019 at 14:22)</a>:</h4>
<p>Ah, so we already have this theorem. Thanks</p>

<a name="168796607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168796607" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168796607">Adrian Chu (Jun 23 2019 at 14:50)</a>:</h4>
<p>I am proving using <code>calc</code>, the first and last expression has type <code>nat</code> but some of the intermediate steps have type <code>int</code></p>

<a name="168796623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168796623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168796623">Mario Carneiro (Jun 23 2019 at 14:51)</a>:</h4>
<p>apply <code>int.coe_nat_inj</code></p>

<a name="168796624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168796624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168796624">Adrian Chu (Jun 23 2019 at 14:51)</a>:</h4>
<p>which hence give type mismatch error</p>

<a name="168796632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168796632" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168796632">Mario Carneiro (Jun 23 2019 at 14:51)</a>:</h4>
<p>before starting the calc block</p>

<a name="168797693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168797693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168797693">Adrian Chu (Jun 23 2019 at 15:27)</a>:</h4>
<p>can someone kindly write a simple example to illustrate how a proof involving <code>int.coe_nat_inj</code> and <code>calc</code>  should look like? since I can't find this in mathlib</p>

<a name="168798063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168798063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168798063">Mario Carneiro (Jun 23 2019 at 15:40)</a>:</h4>
<p>you can't find the theorem?</p>

<a name="168798070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168798070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168798070">Mario Carneiro (Jun 23 2019 at 15:41)</a>:</h4>
<p>show me your proof and I'll fix it</p>

<a name="168798166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168798166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168798166">Mario Carneiro (Jun 23 2019 at 15:44)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_inj</span> <span class="err">$</span> <span class="k">calc</span>
   <span class="err">↑</span><span class="n">x</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:</span> <span class="n">h1</span><span class="bp">.</span><span class="n">symm</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">y</span> <span class="o">:</span> <span class="n">h2</span>
</pre></div>

<a name="168798244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168798244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168798244">Adrian Chu (Jun 23 2019 at 15:47)</a>:</h4>
<p>wow thanks.</p>

<a name="168798285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168798285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168798285">Adrian Chu (Jun 23 2019 at 15:48)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">baz</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">coprime</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)),</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">-</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">fapply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">nat_abs</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">fapply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">nat_abs</span> <span class="n">y</span><span class="o">,</span>
  <span class="k">calc</span>
    <span class="n">a</span><span class="bp">*</span><span class="o">(</span><span class="n">nat_abs</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="o">(</span><span class="n">nat_abs</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="168798287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168798287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168798287">Adrian Chu (Jun 23 2019 at 15:48)</a>:</h4>
<p>bit by bit, I'm first dealing with the last <code>sorry</code>. do you think i should use <code>int.coe_nat_inj</code> here?</p>

<a name="168798403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168798403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168798403">Mario Carneiro (Jun 23 2019 at 15:52)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">baz</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">coprime</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)),</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">-</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">nat_abs</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">nat_abs</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_inj</span><span class="o">,</span>
  <span class="k">calc</span>
    <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="o">(</span><span class="n">nat_abs</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span><span class="bp">*</span><span class="o">(</span><span class="n">nat_abs</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">hx</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">y</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">hy</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
<span class="kn">end</span>
</pre></div>

<a name="168798581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168798581" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168798581">Adrian Chu (Jun 23 2019 at 15:59)</a>:</h4>
<p>thx, i'll keep working on it</p>

<a name="168799229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168799229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168799229">Adrian Chu (Jun 23 2019 at 16:20)</a>:</h4>
<p>what should replace <code>sorry</code> in this step? +_+ why doesn't <code>left_distrib</code> works?</p>
<div class="codehilite"><pre><span></span><span class="n">a</span><span class="bp">*</span><span class="o">(</span><span class="bp">-</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">a</span><span class="bp">*</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span>
</pre></div>

<a name="168799239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168799239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168799239">Mario Carneiro (Jun 23 2019 at 16:21)</a>:</h4>
<p>it's not just <code>left_distrib</code>, you also associated + and distributed <code>-</code> over <code>*</code></p>

<a name="168799278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168799278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168799278">Mario Carneiro (Jun 23 2019 at 16:22)</a>:</h4>
<p><code>simp [mul_add]</code> should do it</p>

<a name="168799286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168799286" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168799286">Adrian Chu (Jun 23 2019 at 16:23)</a>:</h4>
<p><code>by simp [mul_add]</code> doesnt work...</p>

<a name="168799337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168799337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168799337">Mario Carneiro (Jun 23 2019 at 16:24)</a>:</h4>
<p>look at what you get, and add theorems that make them look more alike</p>

<a name="168799451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168799451" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168799451">Adrian Chu (Jun 23 2019 at 16:28)</a>:</h4>
<p>i need <code>mul_assoc</code> !!</p>

<a name="168822645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168822645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168822645">Adrian Chu (Jun 24 2019 at 05:05)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">baz</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)),</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">-</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">nat_abs</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">nat_abs</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_inj</span><span class="o">,</span>
  <span class="k">calc</span>
    <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="o">(</span><span class="n">nat_abs</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">a</span><span class="bp">*</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">a</span><span class="bp">*</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">a</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">add_neg_self</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">y</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span>
<span class="kn">end</span>
</pre></div>

<a name="168822703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168822703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168822703">Adrian Chu (Jun 24 2019 at 05:06)</a>:</h4>
<p>I have trouble to finish the last sorry (on the 5th last line)</p>

<a name="168822720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168822720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168822720">Adrian Chu (Jun 24 2019 at 05:07)</a>:</h4>
<p>I know that i should use <code>gcd_eq_gcd_ab</code>, but type problems  of Z and N keep coming up, and I don't know how to use  ↑ correctly</p>

<a name="168825903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168825903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168825903">Mario Carneiro (Jun 24 2019 at 06:34)</a>:</h4>
<p>make sure to bracket things correctly so that the work is isolated</p>

<a name="168825930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168825930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168825930">Mario Carneiro (Jun 24 2019 at 06:34)</a>:</h4>
<p>when you write <code>a+b+c+d</code> that gets associated as <code>((a+b)+c)+d</code>, so you are mixing different concerns</p>

<a name="168825960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168825960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168825960">Mario Carneiro (Jun 24 2019 at 06:36)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">baz</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)),</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">-</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">nat_abs</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">nat_abs</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_inj</span><span class="o">,</span>
  <span class="k">calc</span>
    <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="o">(</span><span class="n">nat_abs</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">a</span><span class="bp">*</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">a</span><span class="bp">*</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">gcd_eq_gcd_ab</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">a</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">add_neg_self</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">y</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span>
<span class="kn">end</span>
</pre></div>

<a name="168826122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168826122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168826122">Adrian Chu (Jun 24 2019 at 06:38)</a>:</h4>
<p>nope, this doesnt work, it has error message :</p>
<p>rewrite tactic failed, did not find instance of the pattern in the target expression<br>
  gcd ?m_4 ?m_5<br>
state:<br>
a b : ℕ,<br>
h : nat.gcd a b = 1,<br>
k : ℕ := max (nat_abs (gcd_a ↑a ↑b)) (nat_abs (gcd_b ↑a ↑b)),<br>
x : ℤ := -nat.gcd_a a b + ↑b * ↑k,<br>
y : ℤ := nat.gcd_b a b + ↑a * ↑k,<br>
hx : x = ↑(nat_abs x),<br>
hy : y = ↑(nat_abs y)<br>
⊢ -↑a * nat.gcd_a a b + ↑(nat.gcd a b) + ↑a * ↑b * ↑k =<br>
    -↑a * nat.gcd_a a b + (↑a * nat.gcd_a a b + ↑b * nat.gcd_b a b) + ↑a * ↑b * ↑k<br>
state:<br>
a b : ℕ,<br>
h : nat.gcd a b = 1,<br>
k : ℕ := max (nat_abs (gcd_a ↑a ↑b)) (nat_abs (gcd_b ↑a ↑b)),<br>
x : ℤ := -nat.gcd_a a b + ↑b * ↑k,<br>
y : ℤ := nat.gcd_b a b + ↑a * ↑k,<br>
hx : x = ↑(nat_abs x),<br>
hy : y = ↑(nat_abs y)<br>
⊢ ↑(a * nat_abs x + 1) = ↑(b * nat_abs y)</p>

<a name="168826782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168826782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168826782">Mario Carneiro (Jun 24 2019 at 06:52)</a>:</h4>
<p>this works for me:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">gcd</span>
<span class="kn">open</span> <span class="n">nat</span> <span class="n">int</span>
<span class="kn">lemma</span> <span class="n">baz</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)),</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">-</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">nat_abs</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">nat_abs</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_inj</span><span class="o">,</span>
  <span class="k">calc</span>
    <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="o">(</span><span class="n">nat_abs</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">a</span><span class="bp">*</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">a</span><span class="bp">*</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">gcd_eq_gcd_ab</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">a</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">add_neg_self</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">y</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span>
<span class="kn">end</span>
</pre></div>

<a name="168826864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168826864" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168826864">Mario Carneiro (Jun 24 2019 at 06:54)</a>:</h4>
<p>it's not clear to me what you have open, but it seems to work with <code>nat</code> and <code>int</code> open</p>

<a name="168826877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168826877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168826877">Mario Carneiro (Jun 24 2019 at 06:55)</a>:</h4>
<p>maybe you have something else imported so that <code>gcd</code> means something else?</p>

<a name="168827791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168827791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168827791">Adrian Chu (Jun 24 2019 at 07:14)</a>:</h4>
<p>I opened euclidean domain, thats why. but actually i don't need it. Thanks!</p>

<a name="168835461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168835461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168835461">Adrian Chu (Jun 24 2019 at 09:45)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">baz</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)),</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">-</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hxx</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="o">:=</span>
    <span class="k">calc</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="bp">-</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="bp">-</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)))</span>
           <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span> <span class="c1">--simp [le_max_left]</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span><span class="c1">--simp</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
</pre></div>


<p>this time is about the 2nd and 3rd <code>sorry</code>. why dont those corresponding commands (which I commented above) work?</p>

<a name="168841318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168841318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168841318">Kevin Buzzard (Jun 24 2019 at 11:32)</a>:</h4>
<p>I insert my canonical remark. [It would be easier for people like me if you could just post fully working code. I need to open things, maybe import things, etc; can you do this part of the job for me please?].</p>

<a name="168841441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168841441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168841441">Kevin Buzzard (Jun 24 2019 at 11:34)</a>:</h4>
<p>But the answer to your question might be that the first sorry won't work because <code>simp</code> is designed to prove equalities, not inequalities, and the second proof should probably be <code>rfl</code> because it looks to me like it's true by definition.</p>

<a name="168841553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168841553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168841553">Kevin Buzzard (Jun 24 2019 at 11:36)</a>:</h4>
<p>All the simplifier does is that it proves things of the form X = Y by attempting to simplify both sides into a canonical form and then checking that they're true by definition. A simp lemma is of the form A = B, and if A is a sub-term in X then the simplifier will replace A by B; that's why simp lemmas should have (complicated) = (simpler) in that order.</p>

<a name="168841913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168841913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168841913">Adrian Chu (Jun 24 2019 at 11:42)</a>:</h4>
<blockquote>
<p>I insert my canonical remark. [It would be easier for people like me if you could just post fully working code. I need to open things, maybe import things, etc; can you do this part of the job for me please?].</p>
</blockquote>
<p>ok sure!</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">gcd</span>
<span class="kn">open</span> <span class="n">nat</span> <span class="n">int</span>

<span class="kn">lemma</span> <span class="n">baz</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)),</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hxx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≥</span> <span class="mi">0</span> <span class="o">:=</span>
    <span class="k">calc</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span> <span class="c1">--simp [le_max_left]</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="n">sorry</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nat_abs_of_nonneg</span> <span class="n">hxx</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">nat_abs</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">nat_abs</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_inj</span><span class="o">,</span>
  <span class="k">calc</span>
    <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="o">(</span><span class="n">nat_abs</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">a</span><span class="bp">*</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">a</span><span class="bp">*</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">gcd_eq_gcd_ab</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">a</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">add_neg_self</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">y</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span>
<span class="kn">end</span>
</pre></div>

<a name="168842049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842049" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842049">Adrian Chu (Jun 24 2019 at 11:44)</a>:</h4>
<p>for the 3rd sorry, rfl doesnt work...</p>

<a name="168842067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842067" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842067">Adrian Chu (Jun 24 2019 at 11:44)</a>:</h4>
<blockquote>
<p>All the simplifier does is that it proves things of the form X = Y by attempting to simplify both sides into a canonical form and then checking that they're true by definition. A simp lemma is of the form A = B, and if A is a sub-term in X then the simplifier will replace A by B; that's why simp lemmas should have (complicated) = (simpler) in that order.</p>
</blockquote>
<p>ah, i see</p>

<a name="168842238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842238" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842238">Kevin Buzzard (Jun 24 2019 at 11:47)</a>:</h4>
<div class="codehilite"><pre><span></span>    <span class="k">calc</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span>
</pre></div>


<p>a=1 and b=0 is a counterexample to this. This is the problem with skipping stuff -- even if your later two sorries are fixed the code might be unusable anyway.</p>

<a name="168842349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842349">Adrian Chu (Jun 24 2019 at 11:49)</a>:</h4>
<p>no, we cant have a=1, b=0 because of the hypothesis h</p>

<a name="168842361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842361" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842361">Mario Carneiro (Jun 24 2019 at 11:49)</a>:</h4>
<p>1 and 0 are coprime</p>

<a name="168842365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842365">Kevin Buzzard (Jun 24 2019 at 11:49)</a>:</h4>
<p>The problem with the final sorry is that <code>k</code> is defined using the max on nat, and the other max is on int.</p>

<a name="168842427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842427">Adrian Chu (Jun 24 2019 at 11:50)</a>:</h4>
<p>oh no! :(</p>

<a name="168842449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842449">Adrian Chu (Jun 24 2019 at 11:50)</a>:</h4>
<p>i need to add more hypothesis then</p>

<a name="168842509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842509" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842509">Adrian Chu (Jun 24 2019 at 11:51)</a>:</h4>
<blockquote>
<p>The problem with the final sorry is that <code>k</code> is defined using the max on nat, and the other max is on int.</p>
</blockquote>
<p>how should I get around?</p>

<a name="168842683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842683" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842683">Kevin Buzzard (Jun 24 2019 at 11:54)</a>:</h4>
<p>There might be some magic tactic which does it, I've not tried those new cast tactics. If not, then you have to fix things up yourself. </p>
<p>My recommendation would be to change every single variable into an int as soon as possible, make all the problems go away, and then just prove that various things are &gt;= 0 at the end and then cast them back to nats.</p>

<a name="168842703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842703">Mario Carneiro (Jun 24 2019 at 11:54)</a>:</h4>
<p>I would keep the max on nat, because that's the definition of k</p>

<a name="168842707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842707">Kevin Buzzard (Jun 24 2019 at 11:54)</a>:</h4>
<p>You're just in the typical nat/int hell which several of my students found themselves in over the summer. In my mind, if your proof uses ints, then why even use nats at all? Just use ints with a proof that they're &gt;= 0.</p>

<a name="168842730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842730" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842730">Mario Carneiro (Jun 24 2019 at 11:55)</a>:</h4>
<p>it might help to write some up arrows because it's important to know where they are</p>

<a name="168842734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842734" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842734">Kevin Buzzard (Jun 24 2019 at 11:55)</a>:</h4>
<p>Maybe this would be a great place to test out the cast tactics. Did they get written up in the tactics docs?</p>

<a name="168842798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842798">Kevin Buzzard (Jun 24 2019 at 11:56)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md">https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md</a></p>
<p>They're right at the bottom. Maybe these can help. I've never used them though.</p>

<a name="168842833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842833">Mario Carneiro (Jun 24 2019 at 11:56)</a>:</h4>
<p>to use the cast tactics, you have to actually have a specific goal that you can use them with</p>

<a name="168842871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168842871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168842871">Mario Carneiro (Jun 24 2019 at 11:57)</a>:</h4>
<p>distributing the arrows in this case is easily enough done by simp, that's already working in the example</p>

<a name="168849016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168849016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168849016">Adrian Chu (Jun 24 2019 at 13:27)</a>:</h4>
<p>yes, i should definitely use int instead of nat. because I have to add the condition that a, b &gt;0 anyway, as you pointed out</p>

<a name="168849713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168849713" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168849713">Adrian Chu (Jun 24 2019 at 13:36)</a>:</h4>
<p>but since gcd_a and gcd_b are for nat instead of int, other troubles will arise...</p>

<a name="168853863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168853863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168853863">Adrian Chu (Jun 24 2019 at 14:24)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">gcd</span>
<span class="kn">open</span> <span class="n">nat</span> <span class="n">int</span>

<span class="kn">lemma</span> <span class="n">baz</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">max</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)),</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hxx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≥</span> <span class="mi">0</span> <span class="o">:=</span>
    <span class="k">calc</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="o">(</span><span class="n">max</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)))</span> <span class="o">:</span>
        <span class="k">by</span> <span class="n">sorry</span> <span class="c1">-- rw le_max_left</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nat_abs_of_nonneg</span> <span class="n">hxx</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">nat_abs</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">nat_abs</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_inj</span><span class="o">,</span>
  <span class="k">calc</span>
    <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="o">(</span><span class="n">nat_abs</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">a</span><span class="bp">*</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">a</span><span class="bp">*</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">gcd_eq_gcd_ab</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">a</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">add_neg_self</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">y</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span>
<span class="kn">end</span>
</pre></div>

<a name="168853912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168853912" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168853912">Adrian Chu (Jun 24 2019 at 14:25)</a>:</h4>
<p>now i have changed the definition of k so that everything should be in int. why <code>rw le_max_left </code> still doesnt work?</p>

<a name="168857486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168857486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168857486">Adrian Chu (Jun 24 2019 at 15:05)</a>:</h4>
<p>oh, i know why, its because i need a proof for <code>(b:nat)(a:int)(c:int)(a&lt;=c) : b*a &lt;= b*c</code>. i guess this is proven somewhere already?</p>

<a name="168859399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168859399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168859399">Adrian Chu (Jun 24 2019 at 15:25)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">gcd</span>
<span class="kn">open</span> <span class="n">nat</span> <span class="n">int</span>

<span class="kn">lemma</span> <span class="n">baz</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">max</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)),</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hxx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≥</span> <span class="mi">0</span> <span class="o">:=</span>
    <span class="k">calc</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span> <span class="c1">-- rw hb ...?</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="o">(</span><span class="err">↑</span><span class="n">b</span> <span class="bp">-</span> <span class="err">↑</span><span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">b</span><span class="bp">*</span><span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="bp">-</span> <span class="err">↑</span><span class="mi">1</span><span class="bp">*</span><span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span>
        <span class="o">:</span> <span class="n">sub_mul</span> <span class="o">(</span><span class="err">↑</span><span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="err">↑</span><span class="mi">1</span><span class="o">)</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">b</span><span class="bp">*</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="bp">-</span> <span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span> <span class="c1">-- ...?</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="o">(</span><span class="n">max</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)))</span> <span class="o">:</span>
        <span class="k">by</span> <span class="n">sorry</span> <span class="c1">-- rw le_max_left ...?</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nat_abs_of_nonneg</span> <span class="n">hxx</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">nat_abs</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">nat_abs</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_inj</span><span class="o">,</span>
  <span class="k">calc</span>
    <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="o">(</span><span class="n">nat_abs</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">a</span><span class="bp">*</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">a</span><span class="bp">*</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">gcd_eq_gcd_ab</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">a</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">add_neg_self</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">y</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span>
<span class="kn">end</span>
</pre></div>

<a name="168859748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168859748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168859748">Adrian Chu (Jun 24 2019 at 15:29)</a>:</h4>
<p>OK, I can finally see the end. Only 3 sorry's (the first 3) are left to be filled, which I believe can be done using existing theorems. Can someone please tell me what the right commands are? Thanks!</p>

<a name="168861621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168861621" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168861621">Kevin Buzzard (Jun 24 2019 at 15:53)</a>:</h4>
<p>Did you try library search?</p>

<a name="168862027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168862027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168862027">Adrian Chu (Jun 24 2019 at 15:58)</a>:</h4>
<p>How to do <code>library_search</code>? <span aria-label="exhausted" class="emoji emoji-1f625" role="img" title="exhausted">:exhausted:</span></p>

<a name="168862066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168862066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168862066">Reid Barton (Jun 24 2019 at 15:58)</a>:</h4>
<p>Read the documentation for <code>library_search</code>?</p>

<a name="168862199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168862199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168862199">Reid Barton (Jun 24 2019 at 16:00)</a>:</h4>
<p>in <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md">https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md</a></p>

<a name="168862716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168862716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168862716">Adrian Chu (Jun 24 2019 at 16:08)</a>:</h4>
<blockquote>
<p>Read the documentation for <code>library_search</code>?</p>
</blockquote>
<p>Ya, I just noticed this, embarrassing lol</p>

<a name="168863189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168863189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168863189">Adrian Chu (Jun 24 2019 at 16:16)</a>:</h4>
<p>library_search times out :(</p>

<a name="168863686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168863686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168863686">Kevin Buzzard (Jun 24 2019 at 16:24)</a>:</h4>
<p>So your first sorry is a proof of</p>
<div class="codehilite"><pre><span></span> 0 * nat_abs (gcd_a a b) ≤ (b - 1) * (nat_abs (gcd_a a b))
</pre></div>


<p>You wrote <code>rw hb</code>, and here <code>hb : b &gt;= 1</code>. NB that's not the canonical way to write that inequality, the canonical way is <code>1 &lt;= b</code>. Yes, it does make a difference :-/</p>
<p>But you probably know what rw really does. For <code>rw h</code> to work, <code>h</code> must really be of the form <code>A = B</code>, and then <code>rw</code> takes the A's and replaces them with B's. So this is not a rewrite at all. What it is is a theorem. It's the theorem that x &lt;= y and c &gt;= 0 then x * c &lt;= y * c. And that theorem will have a name, which you can either guess (once you understand the naming conventions), remember (once you've used Lean for a while) or look up using library-search (if it works).</p>

<a name="168863743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168863743" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168863743">Kevin Buzzard (Jun 24 2019 at 16:25)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">library_search</span> <span class="c1">-- works!</span>
</pre></div>

<a name="168864060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168864060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168864060">Kevin Buzzard (Jun 24 2019 at 16:30)</a>:</h4>
<p>Your second sorry seems to be of the form</p>
<div class="codehilite"><pre><span></span>↑b*↑(nat_abs (gcd_a a b)) - ↑1*↑(nat_abs (gcd_a a b)) ≤ b*(nat_abs (gcd_a a b)) - gcd_a a b
</pre></div>


<p>Why are you proving an inequality? It looks to me like this should be an equality. It seems to me that there are three issues here. The first is the inequality. The second is that a bunch of arrows disappeared (either because you didn't write them and they're still there really, or because you really are switching from integers to naturals). To sort that out you'll either need some cast tactic, or you should just work with integers all the way through. The final thing is the issue that you are implicitly assuming <code>1 * x = x</code>. That's a theorem, it's not true by definition, so it will have a name (I guess the name is <code>one_mul</code>), and that theorem needs to be applied somehow (by rewriting I guess) to get rid of that 1.</p>

<a name="168864547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168864547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168864547">Kevin Buzzard (Jun 24 2019 at 16:39)</a>:</h4>
<p>The third sorry is</p>
<div class="codehilite"><pre><span></span>-gcd_a a b + b*↑(nat_abs (gcd_a a b))
 ≤ -gcd_a a b + b*(max ↑(nat_abs (gcd_a a b)) ↑(nat_abs (gcd_b a b)))
</pre></div>


<p>You want to use <code>le_max_left</code> but again there are several steps which you're leaving out. As well as le_max_left there's the analogous theorem for the first sorry, but this time with conclusion <code>c * a &lt;= c * b</code> (different conclusion = different theorem name), and you're also using the fact that a &lt;= b implies c + a &lt;= c + b. I think the simplifier is not well suited for these questions -- but I might be wrong. In some sense this is the problem with calc mode. You could just enter tactic mode again with a begin end, and then do the rewriting yourself.</p>
<div class="codehilite"><pre><span></span>    <span class="k">calc</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span> <span class="c1">-- rw hb ...?</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="o">(</span><span class="err">↑</span><span class="n">b</span> <span class="bp">-</span> <span class="err">↑</span><span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">b</span><span class="bp">*</span><span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="bp">-</span> <span class="err">↑</span><span class="mi">1</span><span class="bp">*</span><span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span>
        <span class="o">:</span> <span class="n">sub_mul</span> <span class="o">(</span><span class="err">↑</span><span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="err">↑</span><span class="mi">1</span><span class="o">)</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">b</span><span class="bp">*</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="bp">-</span> <span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span> <span class="c1">-- ...?</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="o">(</span><span class="n">max</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)))</span> <span class="o">:</span>
        <span class="k">begin</span>
          <span class="n">apply</span> <span class="n">add_le_add_left</span><span class="o">,</span>
          <span class="n">apply</span> <span class="n">mul_le_mul_of_nonneg_left</span><span class="o">,</span>
            <span class="n">exact</span> <span class="n">le_max_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
          <span class="c1">-- etc</span>
          <span class="n">sorry</span>
        <span class="kn">end</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
</pre></div>


<p>Tactic mode is the best mode really. You wrote <code>rw le_max_left</code> but that doesn't even make sense; you can only rewrite equalities. You are not thinking about what is really happening. What is really happening is that you are constantly applying little lemmas. The proof of <code>c + d * a &lt;= c + d * (max a b)</code> is really not a rewrite. It is an application of several unrelated facts about inequalities, each of which has been painstakingly proved by the library creators. One of them is le_max_left but there are others.</p>

<a name="168864836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168864836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168864836">Adrian Chu (Jun 24 2019 at 16:43)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">basic</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">library_search</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">ordered_ring</span>
<span class="kn">open</span> <span class="n">nat</span> <span class="n">int</span>

<span class="kn">lemma</span> <span class="n">baz</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">max</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)),</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hg</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hb</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="err">↑</span><span class="n">b</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hxx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≥</span> <span class="mi">0</span> <span class="o">:=</span>
    <span class="k">calc</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="o">(</span><span class="err">↑</span><span class="n">b</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span>
        <span class="k">by</span> <span class="n">exact</span> <span class="n">mul_le_mul_of_nonneg_right</span> <span class="n">hb</span> <span class="n">hg</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="o">(</span><span class="err">↑</span><span class="n">b</span> <span class="bp">-</span> <span class="err">↑</span><span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">b</span><span class="bp">*</span><span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="bp">-</span> <span class="err">↑</span><span class="mi">1</span><span class="bp">*</span><span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span>
        <span class="n">sub_mul</span> <span class="o">(</span><span class="err">↑</span><span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="err">↑</span><span class="mi">1</span><span class="o">)</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="bp">-</span> <span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">b</span><span class="bp">*</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="bp">-</span> <span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="o">(</span><span class="n">max</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="err">↑</span><span class="o">(</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)))</span> <span class="o">:</span>
        <span class="k">by</span> <span class="n">sorry</span> <span class="c1">-- rw le_max_left ...?</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nat_abs_of_nonneg</span> <span class="n">hxx</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hy</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">nat_abs</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">nat_abs</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">existsi</span> <span class="n">nat_abs</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_inj</span><span class="o">,</span>
  <span class="k">calc</span>
    <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="o">(</span><span class="n">nat_abs</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">a</span><span class="bp">*</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">a</span><span class="bp">*</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">gcd_eq_gcd_ab</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">a</span><span class="bp">*</span><span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">add_neg_self</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">y</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">nat_abs</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="bp">.</span><span class="n">symm</span><span class="o">]</span>
<span class="kn">end</span>
</pre></div>

<a name="168864938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168864938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168864938">Adrian Chu (Jun 24 2019 at 16:44)</a>:</h4>
<p>This is my attempt to resolve the first sorry, but I got an enormous error message. As for the second sorry, it should be an inequality since gcd_a can be negative. I will come back to this tomorrow, its so late at night. Anyway, thanks~</p>

<a name="168865211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168865211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168865211">Kevin Buzzard (Jun 24 2019 at 16:48)</a>:</h4>
<blockquote>
<p>As for the second sorry, it should be an inequality since gcd_a can be negative.</p>
</blockquote>
<p>Oh, apologies! I thought these were the nat ones. In which case my comments apply about how things like a &lt;= b implies c - a &gt;= c - b are not immediate or automatic, they are theorems which need applying. You'll also need one_mul, and the fact that z &lt;= abs z.</p>

<a name="168865408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168865408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168865408">Kevin Buzzard (Jun 24 2019 at 16:52)</a>:</h4>
<p>The enormous error message is only enormous because Lean has expanded everything out for you to explain what the problem is. If it just said "I was expecting a proof that something was &lt;= something, and you gave me a proof that something was &lt;= something" then it would be confusing. But</p>
<div class="codehilite"><pre><span></span>type mismatch at application
  mul_le_mul_of_nonneg_right hb
term
  hb
has type
  @has_le.le nat nat.has_le 0
    (@has_sub.sub nat nat.has_sub
       (@coe nat nat (@coe_to_lift nat nat (@coe_base nat nat (@nat.cast_coe nat nat.has_zero nat.has_one nat.has_add)))
          b)
       1)
but is expected to have type
  @has_le.le int
    (@preorder.to_has_le int
       ...
</pre></div>


<p>says that <code>hb</code> has type <code>@has_le.le nat ...</code> (i.e. it's a proof that one nat is &lt;= another nat) and you attempted to insert it into a function which was expecting something of type <code>@has_le.le int ...</code> i.e. expecting a proof that one int is &lt;= another int.</p>

<a name="168865616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168865616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168865616">Kevin Buzzard (Jun 24 2019 at 16:55)</a>:</h4>
<p>replacing <code>by exact mul_le_mul_of_nonneg_right</code> with the more refined "attempt to solve the goal with this function but give me the inputs as new goals" <code>refine</code> tactic</p>
<div class="codehilite"><pre><span></span>begin refine mul_le_mul_of_nonneg_right _ _, sorry, sorry end
</pre></div>


<p>shows you what the problem is. You now need to fill in those two holes, and the results you have are not good enough because they have the wrong type. Did I mention the idea of just using integers everywhere by the way?</p>

<a name="168866030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168866030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168866030">Adrian Chu (Jun 24 2019 at 17:00)</a>:</h4>
<blockquote>
<p>Did I mention the idea of just using integers everywhere by the way?</p>
</blockquote>
<p>but gcd_a, gcd_b are defined for nat instead of int</p>

<a name="168866043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168866043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168866043">Kevin Buzzard (Jun 24 2019 at 17:00)</a>:</h4>
<p>But this issue is just a general pain in type theory. Do you understand how to use these new cast tactics? The first hole needs a resolution of this issue</p>
<div class="codehilite"><pre><span></span>hb : 0 ≤ ↑b - 1
⊢ 0 ≤ ↑b - 1
</pre></div>


<p>Here your hypothesis <code>hb</code> has an arrow in, which turns out to be a cast from <code>nat</code> to <code>nat</code>. You can see all the gory details of everything by <code>set_option pp.all true</code>. Setting this option will give you some real insight into how the computer is thinking about what you are doing. In particular you cannot cast from a nat to an int by just putting an up-arrow -- Lean doesn't know where you're casting to.</p>

<a name="168866118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168866118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168866118">Kevin Buzzard (Jun 24 2019 at 17:01)</a>:</h4>
<blockquote>
<blockquote>
<p>Did I mention the idea of just using integers everywhere by the way?</p>
</blockquote>
<p>but gcd_a, gcd_b are defined for nat instead of int</p>
</blockquote>
<p>Feed them absolute values of ints? I don't know if this is a feasible solution.</p>

<a name="168866318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168866318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168866318">Adrian Chu (Jun 24 2019 at 17:04)</a>:</h4>
<blockquote>
<blockquote>
<blockquote>
<p>Did I mention the idea of just using integers everywhere by the way?</p>
</blockquote>
<p>but gcd_a, gcd_b are defined for nat instead of int</p>
</blockquote>
<p>Feed them absolute values of ints? I don't know if this is a feasible solution.</p>
</blockquote>
<p>i will try tomorrow</p>

<a name="168866850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168866850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168866850">Kevin Buzzard (Jun 24 2019 at 17:11)</a>:</h4>
<p>I don't know if this is feasible. All I see when I look at your code though is a bunch of stuff about ints, with subtractions etc. You might well find the int analogue of the <code>gcd_a</code> functions in <code>data.int.basic</code> somewhere or maybe even in core.</p>

<a name="168867991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168867991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168867991">Kevin Buzzard (Jun 24 2019 at 17:27)</a>:</h4>
<p>Maybe now we have <code>norm_cast</code> you don't need to make everything an integer. This little lemma might be a nice test case. I just tried it on the first sorry and had positive results:</p>
<div class="codehilite"><pre><span></span>    calc (0 : ℤ) = 0 * nat_abs (gcd_a a b) : by simp
    ... ≤ (↑b - 1) * (nat_abs (gcd_a a b)) :
        begin apply mul_le_mul_of_nonneg_right,
          {norm_cast at hb ⊢, exact hb},
          {norm_cast, simp}
        end
</pre></div>

<a name="168868375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168868375" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168868375">Kevin Buzzard (Jun 24 2019 at 17:32)</a>:</h4>
<p>For the next one you need the theorem that a &lt;= b implies c - b &lt;= c - a (note how I always stick with &lt;=, otherwise there would be lots of ways of saying inequalities; there is a "canonical form" for many expressions in Lean and it is only slowly dawning on me how important this is in practice). To find that theorem you see that the conclusion is of the form "a subtraction is less than or equal to a subtraction" so I type "apply sub_le_sub" and then I press ctrl-space in VS Code and see a list of all Lean's theorems that start <code>sub_le_sub</code> and all their types too, so it's easy to find the one I want. That's another way of finding out the right name for a theorem.</p>

<a name="168875750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168875750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168875750">Patrick Massot (Jun 24 2019 at 18:57)</a>:</h4>
<p><span class="user-mention" data-user-id="218709">@Adrian Chu</span> I don't think you're going in the right direction. The first thing to understand is natural numbers are bad. You never noticed because real world always insert coercions to integers and all the coercion related lemmas. My advice is to first state and prove the integer version. Then we'll talk about deducing the evil version. Here is the exercise I propose:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">euclidean_domain</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">linarith</span>
<span class="kn">open</span> <span class="n">euclidean_domain</span>

<span class="kn">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="bp">∧</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">),</span>
  <span class="n">use</span> <span class="o">[</span><span class="bp">-</span><span class="n">u</span><span class="bp">+</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">k</span><span class="o">],</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">split</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="k">show</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span><span class="bp">*</span><span class="n">u</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">v</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="n">ring</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">suffices</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">),</span> <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span>
    <span class="c1">-- now you can `calc`</span>
    <span class="n">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="168875884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168875884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168875884">Patrick Massot (Jun 24 2019 at 18:58)</a>:</h4>
<p>each <code>calc</code> block is 4 lines long</p>

<a name="168875916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168875916" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168875916">Patrick Massot (Jun 24 2019 at 18:59)</a>:</h4>
<p>The first sorry is 20 characters (including spaces)</p>

<a name="168877209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168877209" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168877209">Patrick Massot (Jun 24 2019 at 19:16)</a>:</h4>
<p>Hmm, do we have any lemma relating <code>nat.gcd</code> and <code>euclidean_domain.gcd</code>?</p>

<a name="168877349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168877349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168877349">Patrick Massot (Jun 24 2019 at 19:19)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> maybe?</p>

<a name="168877368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168877368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168877368">Johan Commelin (Jun 24 2019 at 19:19)</a>:</h4>
<p>I'm not too familiar with that part of the lib...</p>

<a name="168877373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168877373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168877373">Patrick Massot (Jun 24 2019 at 19:19)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> ?</p>

<a name="168877439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168877439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168877439">Johan Commelin (Jun 24 2019 at 19:20)</a>:</h4>
<p>I don't know, but I think there is glue between <code>nat.gcd</code> and <code>int.gcd</code>, and then also between <code>int.gcd</code> and <code>euclidean_domain.gcd</code>...</p>

<a name="168877452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168877452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168877452">Patrick Massot (Jun 24 2019 at 19:20)</a>:</h4>
<p>Where would that be?</p>

<a name="168877481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168877481" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168877481">Johan Commelin (Jun 24 2019 at 19:21)</a>:</h4>
<p>Not sure... my memories might be wrong.</p>

<a name="168877567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168877567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168877567">Patrick Massot (Jun 24 2019 at 19:22)</a>:</h4>
<p>Going from the int version of Adrian's lemma to the evil version is trivial except for:</p>
<div class="codehilite"><pre><span></span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span>
<span class="err">⊢</span> <span class="n">gcd</span> <span class="err">↑</span><span class="n">a</span> <span class="err">↑</span><span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span>
</pre></div>

<a name="168877750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168877750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168877750">Johan Commelin (Jun 24 2019 at 19:25)</a>:</h4>
<p>Hmm... if library_search can't close that, then we probably don't have it.</p>

<a name="168877876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168877876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168877876">Patrick Massot (Jun 24 2019 at 19:27)</a>:</h4>
<p>I'm sure British people can prove this</p>

<a name="168878243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168878243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168878243">Kevin Buzzard (Jun 24 2019 at 19:32)</a>:</h4>
<p>Maybe show they both have the same universal property? ;-)</p>

<a name="168878547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168878547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168878547">Kevin Buzzard (Jun 24 2019 at 19:36)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span><span class="bp">.</span><span class="n">gcd</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span><span class="n">h</span><span class="bp">;</span> <span class="n">unfold</span> <span class="n">int</span><span class="bp">.</span><span class="n">gcd</span><span class="bp">;</span> <span class="n">congr&#39;</span>
</pre></div>

<a name="168878603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168878603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168878603">Kevin Buzzard (Jun 24 2019 at 19:38)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span><span class="bp">.</span><span class="n">gcd</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">convert</span> <span class="n">h</span>
</pre></div>

<a name="168878755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168878755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168878755">Kevin Buzzard (Jun 24 2019 at 19:39)</a>:</h4>
<p>I was slightly surprised this worked until I realised that <code>int.nat_abs (\u m) = m</code> was defeq for m a nat.</p>

<a name="168878842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168878842" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168878842">Patrick Massot (Jun 24 2019 at 19:40)</a>:</h4>
<p>Nice! This bridges to <code>int.gcd</code> but not to <code>euclidean_domain.gcd</code></p>

<a name="168879427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168879427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168879427">Patrick Massot (Jun 24 2019 at 19:49)</a>:</h4>
<p>and the <code>by convert</code> is useless...</p>

<a name="168879526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168879526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168879526">Kevin Buzzard (Jun 24 2019 at 19:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span><span class="bp">.</span><span class="n">gcd</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">h</span>
</pre></div>


<p>Oh yeah! I used <code>convert</code> because I "knew" there would be trouble with the cast to int and back.</p>

<a name="168879571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168879571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168879571">Patrick Massot (Jun 24 2019 at 19:51)</a>:</h4>
<p>but the game is to use <code>euclidean_domain.gcd</code></p>

<a name="168880379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168880379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168880379">Kevin Buzzard (Jun 24 2019 at 20:00)</a>:</h4>
<div class="codehilite"><pre><span></span>#eval euclidean_domain.gcd (-1 : ℤ) (1 : ℤ) -- -1
#eval int.gcd (-1 : ℤ) (1 : ℤ) -- +1
</pre></div>


<p>:-(</p>

<a name="168881009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881009">Kevin Buzzard (Jun 24 2019 at 20:08)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">euclidean_domain</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">int</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">gcd</span><span class="bp">.</span><span class="n">induction</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">x</span><span class="o">,</span> <span class="n">rw</span> <span class="n">gcd_zero_left</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_zero_left</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hab</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">hab</span> <span class="kn">using</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">gcd_val</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="c1">-- ⊢ int.gcd a b = int.gcd (b % a) a</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>This code (thanks, whoever wrote gcd.induction!) reduces the question to <code> int.gcd a b = int.gcd (b % a) a</code>.</p>

<a name="168881093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881093">Kevin Buzzard (Jun 24 2019 at 20:09)</a>:</h4>
<p>...which is almost a question about nat.gcd apart from the fact that one needs to relate |b%a| to |b|%|a|.</p>

<a name="168881330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881330">Patrick Massot (Jun 24 2019 at 20:13)</a>:</h4>
<p>What you are doing is not what I asked for</p>

<a name="168881361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881361" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881361">Kevin Buzzard (Jun 24 2019 at 20:13)</a>:</h4>
<p>why don't you formalise the question?</p>

<a name="168881384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881384">Patrick Massot (Jun 24 2019 at 20:13)</a>:</h4>
<p>I did!</p>

<a name="168881432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881432">Kevin Buzzard (Jun 24 2019 at 20:14)</a>:</h4>
<p>Oh -- I misunderstood the arrows.</p>

<a name="168881435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881435">Patrick Massot (Jun 24 2019 at 20:14)</a>:</h4>
<blockquote>
<p>Going from the int version of Adrian's lemma to the evil version is trivial except for:</p>
<div class="codehilite"><pre><span></span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span>
<span class="err">⊢</span> <span class="n">gcd</span> <span class="err">↑</span><span class="n">a</span> <span class="err">↑</span><span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span>
</pre></div>


</blockquote>

<a name="168881438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881438" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881438">Kevin Buzzard (Jun 24 2019 at 20:14)</a>:</h4>
<p>I thought I did that one.</p>

<a name="168881460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881460" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881460">Kevin Buzzard (Jun 24 2019 at 20:14)</a>:</h4>
<p>I have Lean code which looks like that on my screen right now, with int open :-)</p>

<a name="168881482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881482" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881482">Patrick Massot (Jun 24 2019 at 20:14)</a>:</h4>
<p>You need to open <code>euclidean_domain</code> instead</p>

<a name="168881497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881497">Kevin Buzzard (Jun 24 2019 at 20:15)</a>:</h4>
<p>you didn't post a MWE ;-)</p>

<a name="168881523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881523">Patrick Massot (Jun 24 2019 at 20:15)</a>:</h4>
<p>I did</p>

<a name="168881530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881530">Patrick Massot (Jun 24 2019 at 20:15)</a>:</h4>
<p>a few messages above</p>

<a name="168881532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881532">Patrick Massot (Jun 24 2019 at 20:15)</a>:</h4>
<p>anyway</p>

<a name="168881548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881548" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881548">Kevin Buzzard (Jun 24 2019 at 20:15)</a>:</h4>
<p>It was too minimal -- I guessed you'd opened the wrong thing :-)</p>
<p>I still propose we prove the thing I said about int. You can't use the inductive predicate for euclidean_domain.gcd on nats.</p>

<a name="168881620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881620" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881620">Kevin Buzzard (Jun 24 2019 at 20:16)</a>:</h4>
<p>So unless you want to get your hands dirty, we prove some statement which is valid for all ints (as I was in the middle of doing) and then deduce the nat thing via some dirty work.</p>

<a name="168881622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881622" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881622">Patrick Massot (Jun 24 2019 at 20:16)</a>:</h4>
<p>The context was my first message to Adrian, which included all imports and open</p>

<a name="168881667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881667">Kevin Buzzard (Jun 24 2019 at 20:17)</a>:</h4>
<p>And the best statement I could find which was true for all ints was the one I posted.</p>

<a name="168881860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168881860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168881860">Kevin Buzzard (Jun 24 2019 at 20:20)</a>:</h4>
<p>bleurgh we need (a b : int), both &gt;=0 implies euclidean_domain.gcd a b &gt;=0 :-/</p>

<a name="168883133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168883133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168883133">Kevin Buzzard (Jun 24 2019 at 20:37)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">useful</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">b</span> <span class="err">%</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="n">b</span><span class="o">)</span> <span class="err">%</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>Meh.</p>

<a name="168884494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168884494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168884494">Kevin Buzzard (Jun 24 2019 at 20:56)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">euclidean_domain</span>

<span class="kn">open</span> <span class="n">euclidean_domain</span>

<span class="kn">theorem</span> <span class="n">useful</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">b</span> <span class="err">%</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="n">b</span><span class="o">)</span> <span class="err">%</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">theorem</span> <span class="n">useful2</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≥</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≥</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">euclidean_domain</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≥</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">theorem</span> <span class="n">abs_gcd_eq_int_gcd</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">euclidean_domain</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">int</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">gcd</span><span class="bp">.</span><span class="n">induction</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">x</span><span class="o">,</span> <span class="n">rw</span> <span class="n">gcd_zero_left</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_zero_left</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hab</span><span class="o">,</span>
  <span class="n">convert</span> <span class="n">hab</span> <span class="kn">using</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">gcd_val</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="c1">--goal now : a ≠ 0 → int.gcd a b = int.gcd (b % a) a -- should be in mathlib</span>
  <span class="n">unfold</span> <span class="n">int</span><span class="bp">.</span><span class="n">gcd</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">useful</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="o">(</span><span class="n">y</span> <span class="err">%</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">x</span> <span class="k">with</span> <span class="n">x</span><span class="o">,</span> <span class="n">revert</span> <span class="n">hx</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
    <span class="n">simp</span> <span class="c1">-- nat.gcd equation lemma</span>
  <span class="o">},</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h3</span><span class="o">,</span> <span class="n">ha</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">eq_zero_of_nat_abs_eq_zero</span> <span class="n">h3</span><span class="o">),</span> <span class="c1">-- missing a trick here</span>
  <span class="n">generalize</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">generalize</span> <span class="o">:</span> <span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">B</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h</span><span class="o">,</span> <span class="n">rwa</span> <span class="err">←</span><span class="n">h3</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">patrick</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">euclidean_domain</span><span class="bp">.</span><span class="n">gcd</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">show</span> <span class="n">gcd</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">h</span><span class="o">,</span>
  <span class="k">show</span> <span class="bp">_</span> <span class="bp">=</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">abs_gcd_eq_int_gcd</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">convert</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">of_nat_nat_abs_eq_of_nonneg</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
  <span class="c1">-- ⊢ euclidean_domain.gcd ↑a ↑b ≥ 0</span>
  <span class="n">apply</span> <span class="n">useful2</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">int</span><span class="bp">.</span><span class="n">of_nat_nonneg</span> <span class="bp">_</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>Two sorries at the top. <span class="user-mention" data-user-id="110044">@Chris Hughes</span> <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> what tricks am I missing?</p>

<a name="168884513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168884513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168884513">Kevin Buzzard (Jun 24 2019 at 20:56)</a>:</h4>
<p>The goal is to prove theorem <code>patrick</code>.</p>

<a name="168887163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168887163" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168887163">Kevin Buzzard (Jun 24 2019 at 21:37)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">useful2</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≥</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≥</span> <span class="mi">0</span> <span class="bp">→</span> <span class="n">euclidean_domain</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">≥</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">gcd</span><span class="bp">.</span><span class="n">induction</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">h</span> <span class="n">hx</span><span class="o">,</span> <span class="n">rwa</span> <span class="n">gcd_zero_left</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">c</span> <span class="n">d</span> <span class="n">hcn</span> <span class="n">h</span> <span class="n">hc</span> <span class="n">hd</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">gcd_val</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h</span> <span class="bp">_</span> <span class="n">hc</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">int</span><span class="bp">.</span><span class="n">mod_nonneg</span> <span class="n">d</span> <span class="n">hcn</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="168887964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168887964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168887964">Chris Hughes (Jun 24 2019 at 21:48)</a>:</h4>
<p>Personally I would question why you want to prove that theorem?</p>

<a name="168888593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168888593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168888593">Mario Carneiro (Jun 24 2019 at 21:57)</a>:</h4>
<p>I don't see why euclidean_domain.gcd is getting involved at all if the goal is to prove adrian's original statement</p>

<a name="168889874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168889874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168889874">Kevin Buzzard (Jun 24 2019 at 22:17)</a>:</h4>
<p>Yeah I already tried that but Patrick moaned</p>

<a name="168889950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168889950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168889950">Kevin Buzzard (Jun 24 2019 at 22:18)</a>:</h4>
<p>I'm having trouble working with <code>-A % B</code> with (A B : nat) and <code>int.mod</code></p>

<a name="168889991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168889991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168889991">Kevin Buzzard (Jun 24 2019 at 22:19)</a>:</h4>
<div class="codehilite"><pre><span></span>1 goal
B : ℕ,
A : ℕ,
⊢ int.nat_abs (-↑A % ↑B) = int.nat_abs (-↑A) % B
</pre></div>

<a name="168890963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168890963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168890963">Kevin Buzzard (Jun 24 2019 at 22:34)</a>:</h4>
<p>That's the last goal but it's bedtime</p>

<a name="168891065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168891065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168891065">Kevin Buzzard (Jun 24 2019 at 22:36)</a>:</h4>
<p>The left mod is int.mod</p>

<a name="168891573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168891573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168891573">Kevin Buzzard (Jun 24 2019 at 22:45)</a>:</h4>
<p>Aargh I don't think some of these are true :-/</p>

<a name="168891593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168891593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168891593">Kevin Buzzard (Jun 24 2019 at 22:45)</a>:</h4>
<p>No wonder I was struggling :-)</p>

<a name="168891663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168891663" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168891663">Kevin Buzzard (Jun 24 2019 at 22:46)</a>:</h4>
<p>Do we have a tool which checks statements like these for a few random values of the integers in question?</p>

<a name="168891697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168891697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168891697">Mario Carneiro (Jun 24 2019 at 22:47)</a>:</h4>
<p>sure, you can use list ops to make a mini quickcheck</p>

<a name="168891798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168891798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168891798">Mario Carneiro (Jun 24 2019 at 22:49)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">eval</span> <span class="n">do</span>
  <span class="n">A</span> <span class="err">←</span> <span class="n">list</span><span class="bp">.</span><span class="n">range</span> <span class="mi">10</span><span class="o">,</span>
  <span class="n">B</span> <span class="err">←</span> <span class="n">list</span><span class="bp">.</span><span class="n">range</span> <span class="mi">10</span><span class="o">,</span>
  <span class="n">guard</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="o">(</span><span class="bp">-</span><span class="err">↑</span><span class="n">A</span> <span class="err">%</span> <span class="err">↑</span><span class="n">B</span><span class="o">)</span> <span class="bp">≠</span> <span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="o">(</span><span class="bp">-</span><span class="err">↑</span><span class="n">A</span><span class="o">)</span> <span class="err">%</span> <span class="n">B</span><span class="o">),</span>
  <span class="n">return</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">)</span>
<span class="c1">-- [(1, 3), ...]</span>
</pre></div>

<a name="168947675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168947675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168947675">Adrian Chu (Jun 25 2019 at 15:14)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="218709">Adrian Chu</span> I don't think you're going in the right direction. The first thing to understand is natural numbers are bad. You never noticed because real world always insert coercions to integers and all the coercion related lemmas. My advice is to first state and prove the integer version. Then we'll talk about deducing the evil version. Here is the exercise I propose:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">euclidean_domain</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">linarith</span>
<span class="kn">open</span> <span class="n">euclidean_domain</span>

<span class="kn">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="bp">∧</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">),</span>
  <span class="n">use</span> <span class="o">[</span><span class="bp">-</span><span class="n">u</span><span class="bp">+</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">k</span><span class="o">],</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">split</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="k">show</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span><span class="bp">*</span><span class="n">u</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">v</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="n">ring</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">suffices</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">),</span> <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span>
    <span class="c1">-- now you can `calc`</span>
    <span class="n">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>


</blockquote>
<p>So i guess i should try finishing this version of my lemma, and forget everything about nat.gcd</p>

<a name="168947873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168947873" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168947873">Patrick Massot (Jun 25 2019 at 15:17)</a>:</h4>
<p>If you can afford that then of course everything becomes much easier. I still think it's a problem that mathlib has at least three gcd with no lemmas relating them in the case of integers</p>

<a name="168947884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168947884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168947884">Patrick Massot (Jun 25 2019 at 15:17)</a>:</h4>
<p>Did you manage to fill in the sorries in my exercise?</p>

<a name="168947953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168947953" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168947953">Adrian Chu (Jun 25 2019 at 15:18)</a>:</h4>
<p>I am working on them now</p>

<a name="168948117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168948117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168948117">Patrick Massot (Jun 25 2019 at 15:20)</a>:</h4>
<p>Ok, I hope I inserted them wisely. I first wrote the full proof and then removed it to help you getting better training. Don't hesitate to ask questions if it's still too painful</p>

<a name="168950201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168950201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168950201">Adrian Chu (Jun 25 2019 at 15:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">euclidean_domain</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">linarith</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">library_search</span>
<span class="kn">open</span> <span class="n">euclidean_domain</span>

<span class="kn">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="bp">∧</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">hk</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">k</span> <span class="o">:=</span>
    <span class="k">calc</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">abs</span> <span class="n">u</span> <span class="o">:</span> <span class="n">abs_nonneg</span> <span class="n">u</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">le_max_left</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">)</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">k</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="bp">-</span><span class="n">u</span><span class="bp">+</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">k</span><span class="o">],</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">split</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="k">show</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span><span class="bp">*</span><span class="n">u</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">v</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="n">ring</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">suffices</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">),</span> <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span>
    <span class="k">calc</span> <span class="n">u</span> <span class="bp">≤</span> <span class="n">abs</span> <span class="n">u</span> <span class="o">:</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">le_max_left</span> <span class="n">u</span> <span class="o">(</span><span class="bp">-</span><span class="n">u</span><span class="o">)</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">le_max_left</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">)</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">mul_le_mul_of_nonneg_right</span> <span class="n">hb</span> <span class="n">hk</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">suffices</span> <span class="o">:</span> <span class="bp">-</span><span class="n">v</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">),</span> <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span>
    <span class="k">calc</span> <span class="bp">-</span><span class="n">v</span> <span class="bp">≤</span> <span class="n">abs</span> <span class="o">(</span><span class="bp">-</span><span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">le_max_left</span> <span class="o">(</span><span class="bp">-</span><span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="bp">-</span><span class="o">(</span><span class="bp">-</span><span class="n">v</span><span class="o">))</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">abs</span> <span class="n">v</span> <span class="o">:</span> <span class="n">abs_neg</span> <span class="n">v</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">le_max_right</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">)</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">mul_le_mul_of_nonneg_right</span> <span class="n">ha</span> <span class="n">hk</span><span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="168950242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168950242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168950242">Adrian Chu (Jun 25 2019 at 15:50)</a>:</h4>
<p>I'm not able to figure out the first sorry (with 20 characters only). i know we need to use <code>gcd_eq_gcd_ab</code> <span class="user-mention" data-user-id="110031">@Patrick Massot</span></p>

<a name="168950598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168950598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168950598">Adrian Chu (Jun 25 2019 at 15:55)</a>:</h4>
<blockquote>
<p>Personally I would question why you want to prove that theorem?</p>
</blockquote>
<p>This is a crucial lemma in a theorem i want to prove</p>

<a name="168950684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168950684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168950684">Kevin Buzzard (Jun 25 2019 at 15:57)</a>:</h4>
<blockquote>
<blockquote>
<p>Personally I would question why you want to prove that theorem?</p>
</blockquote>
<p>This is a crucial lemma in a theorem i want to prove</p>
</blockquote>
<p>I think that "that theorem" might have referred to the compatibility of the various notions of <code>gcd</code> which we have in Lean.</p>

<a name="168951452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168951452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168951452">Patrick Massot (Jun 25 2019 at 16:06)</a>:</h4>
<p>You can shorten your first calc block to</p>
<div class="codehilite"><pre><span></span><span class="k">calc</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">abs</span> <span class="n">u</span> <span class="o">:</span> <span class="n">abs_nonneg</span> <span class="n">u</span>
      <span class="bp">...</span> <span class="bp">≤</span> <span class="bp">_</span> <span class="o">:</span> <span class="n">le_max_left</span> <span class="bp">_</span> <span class="bp">_</span>
</pre></div>


<p>(or of course you can say <code>have hk : 0 ≤ k, from le_trans (abs_nonneg u) (le_max_left _ _),</code>)</p>

<a name="168951491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168951491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168951491">Patrick Massot (Jun 25 2019 at 16:06)</a>:</h4>
<p>The sorry you couldn't do is <code>h ▸ gcd_eq_gcd_ab a b</code></p>

<a name="168951572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168951572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168951572">Patrick Massot (Jun 25 2019 at 16:07)</a>:</h4>
<p>I hope you've learn a couple of tricks (those are no so easy to document)</p>

<a name="168951723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168951723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168951723">Adrian Chu (Jun 25 2019 at 16:09)</a>:</h4>
<p>wow thanks a lot!</p>

<a name="168951742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168951742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168951742">Adrian Chu (Jun 25 2019 at 16:09)</a>:</h4>
<p>i can finally move one to the second lemma, and then my main theorem :)</p>

<a name="168951744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168951744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168951744">Kevin Buzzard (Jun 25 2019 at 16:09)</a>:</h4>
<p>The triangle is term mode's version of the rewrite tactic.</p>

<a name="168955379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168955379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168955379">Adrian Chu (Jun 25 2019 at 16:53)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">euclidean_domain</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>

<span class="kn">open</span> <span class="n">euclidean_domain</span>

<span class="n">def</span> <span class="n">fin_n_to_list</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℤ</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span>

<span class="n">def</span> <span class="n">n_lcm</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="o">:=</span>
  <span class="n">list</span><span class="bp">.</span><span class="n">foldl</span> <span class="n">lcm</span> <span class="mi">1</span> <span class="o">(</span><span class="n">fin_n_to_list</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">n_lcm_coprime</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span>
  <span class="o">(</span><span class="n">coprime</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">gcd</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">gcd</span> <span class="o">(</span><span class="n">n_lcm</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>

<a name="168955506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168955506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168955506">Adrian Chu (Jun 25 2019 at 16:54)</a>:</h4>
<p>i will start to prove this lemma. is my formulation of definitions and the statement of lemma appropriate?</p>

<a name="168956553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168956553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168956553">Kevin Buzzard (Jun 25 2019 at 17:07)</a>:</h4>
<p>Why are you using maps <code>fin n -&gt; int</code> at all? You are carrying around the length of your list, but you could just read it off by looking at the length of the list.</p>

<a name="168957099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168957099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168957099">Kevin Buzzard (Jun 25 2019 at 17:13)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">euclidean_domain</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>

<span class="kn">open</span> <span class="n">euclidean_domain</span>

<span class="n">def</span> <span class="n">list</span><span class="bp">.</span><span class="n">lcm</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="o">:=</span>
  <span class="n">list</span><span class="bp">.</span><span class="n">foldl</span> <span class="n">lcm</span> <span class="mi">1</span> <span class="n">x</span>

<span class="kn">lemma</span> <span class="n">list</span><span class="bp">.</span><span class="n">lcm_coprime</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hx</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hy</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span>
  <span class="o">(</span><span class="n">coprime</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">x</span><span class="o">,</span> <span class="n">gcd</span> <span class="n">s</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">gcd</span> <span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="n">lcm</span><span class="o">)</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>


<p>No <code>n</code> in sight -- it's never needed.</p>

<a name="168957196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168957196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168957196">Kevin Buzzard (Jun 25 2019 at 17:14)</a>:</h4>
<p>Note also <code>x.lcm</code> for <code>list.lcm x</code>, it's a cool thing which I only recently understood.</p>

<a name="168957270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168957270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168957270">Kevin Buzzard (Jun 25 2019 at 17:15)</a>:</h4>
<p>The CS purists might even say that these should all be theorems about multisets not lists, because the lcm does not depend on the order, so why are you carrying that around?</p>

<a name="168998075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168998075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168998075">Adrian Chu (Jun 26 2019 at 04:04)</a>:</h4>
<p>a naive question: can a list have infinite length?</p>

<a name="168998413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168998413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168998413">Mario Carneiro (Jun 26 2019 at 04:13)</a>:</h4>
<p>No</p>

<a name="168998539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168998539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168998539">Johan Commelin (Jun 26 2019 at 04:16)</a>:</h4>
<p>Nope, they can not.</p>

<a name="168998540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168998540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168998540">Johan Commelin (Jun 26 2019 at 04:16)</a>:</h4>
<p><code>list.length</code> is defined for all lists, and it is a function to <code>nat</code>.</p>

<a name="168998541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168998541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168998541">Johan Commelin (Jun 26 2019 at 04:16)</a>:</h4>
<p>Infinite lists are usually called "streams", and they need a different implementation. Not sure if we have them in Lean.</p>

<a name="168998549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168998549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168998549">Johan Commelin (Jun 26 2019 at 04:16)</a>:</h4>
<p>Sorry... laggy internet connection...</p>

<a name="168998675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168998675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168998675">Mario Carneiro (Jun 26 2019 at 04:20)</a>:</h4>
<p>we have streams, they are just defined as <code>stream A := nat -&gt; A</code></p>

<a name="168998689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168998689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168998689">Adrian Chu (Jun 26 2019 at 04:21)</a>:</h4>
<p>i see. all I want is an n-tuple of numbers. so i will use list Z instead of fin n -&gt; Z.</p>

<a name="168998690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168998690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168998690">Mario Carneiro (Jun 26 2019 at 04:21)</a>:</h4>
<p>There are also lazy lists, which are more like haskell lists in implementation but are still finite according to the theory. But in meta land you can construct infinite lazy lists</p>

<a name="168998753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168998753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168998753">Johan Commelin (Jun 26 2019 at 04:22)</a>:</h4>
<blockquote>
<p>i see. all I want is an n-tuple of numbers. so i will use list Z instead of fin n -&gt; Z.</p>
</blockquote>
<p>The question is... is your <code>n</code> fixed? Because with a list, you don't know if it has length <code>n</code>.</p>

<a name="168998851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168998851" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168998851">Adrian Chu (Jun 26 2019 at 04:25)</a>:</h4>
<p>no, the lemma (and my main theorem) just need an arbitrary finite number of positive integers as inputs.</p>

<a name="168998894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168998894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168998894">Adrian Chu (Jun 26 2019 at 04:26)</a>:</h4>
<p>so list should be good</p>

<a name="168999684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168999684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168999684">Adrian Chu (Jun 26 2019 at 04:48)</a>:</h4>
<p>i just realized a problem. in my main theorem, i have a statement involving a^b, where a and b are positive integers. but since we are now letting a, b be int instead of nat, i cant use the default a^b function</p>

<a name="168999817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168999817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168999817">Adrian Chu (Jun 26 2019 at 04:53)</a>:</h4>
<p>well i can use (nat_abs a)^(nat_abs b). its a bit ugly, but nvm</p>

<a name="169000582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169000582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169000582">Mario Carneiro (Jun 26 2019 at 05:13)</a>:</h4>
<p>I think you should keep them as nats rather than do something like that</p>

<a name="169000589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169000589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169000589">Mario Carneiro (Jun 26 2019 at 05:13)</a>:</h4>
<p>if they are actually nats then there's nothing wrong with that</p>

<a name="169001233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169001233" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169001233">Johan Commelin (Jun 26 2019 at 05:28)</a>:</h4>
<p><span class="user-mention" data-user-id="218709">@Adrian Chu</span> You can let <code>a</code> and <code>b</code> be <code>nat</code>s but nevertheless use <code>int.gcd</code> instead of <code>nat.gcd</code>.</p>

<a name="169001234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169001234" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169001234">Johan Commelin (Jun 26 2019 at 05:28)</a>:</h4>
<p>I agree that it's quite messy.</p>

<a name="169002015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169002015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169002015">Adrian Chu (Jun 26 2019 at 05:45)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="218709">Adrian Chu</span> You can let <code>a</code> and <code>b</code> be <code>nat</code>s but nevertheless use <code>int.gcd</code> instead of <code>nat.gcd</code>.</p>
</blockquote>
<p>I don't think we can, since this gives error:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">mythm</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">r</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">coprime</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">r</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">z</span> <span class="n">s</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="169002082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169002082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169002082">Mario Carneiro (Jun 26 2019 at 05:47)</a>:</h4>
<p>what error? You may need to put some up arrows in there</p>

<a name="169002151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169002151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169002151">Adrian Chu (Jun 26 2019 at 05:49)</a>:</h4>
<p>OK, fixed</p>

<a name="169002570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169002570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169002570">Adrian Chu (Jun 26 2019 at 06:01)</a>:</h4>
<p>let x : list nat and I want to sum it. if for some reason I want to use <code>finset.univ.sum</code> instead of <code>x.sum</code>, what is the correct syntax?</p>

<a name="169002693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169002693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169002693">Adrian Chu (Jun 26 2019 at 06:04)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>

<span class="kn">variable</span> <span class="n">x</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="n">nth</span> <span class="n">i</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">x</span><span class="bp">.</span><span class="n">range</span><span class="o">,</span> <span class="n">x</span><span class="bp">.</span><span class="n">nth</span> <span class="n">i</span><span class="o">)</span>
</pre></div>


<p>this doesnt work</p>

<a name="169002715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169002715" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169002715">Johan Commelin (Jun 26 2019 at 06:05)</a>:</h4>
<p>You need to <code>range</code> of the <code>length</code> of the list.</p>

<a name="169002720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169002720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169002720">Johan Commelin (Jun 26 2019 at 06:05)</a>:</h4>
<p>Why do you want to use <code>finset.sum</code>?</p>

<a name="169002725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169002725" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169002725">Johan Commelin (Jun 26 2019 at 06:05)</a>:</h4>
<p>If so... shouldn't you be using <code>finset nat</code> instead of <code>list nat</code>?</p>

<a name="169002853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169002853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169002853">Adrian Chu (Jun 26 2019 at 06:09)</a>:</h4>
<p>well I have <code>x : list nat</code> and <code>r : list nat</code>, lists of positive integers of the same length, and i want to sum (i-th term of x)^(i-th term of r) over i</p>

<a name="169002866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169002866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169002866">Adrian Chu (Jun 26 2019 at 06:09)</a>:</h4>
<p>i thought using <code>finset.univ.sum</code> is the easiest</p>

<a name="169002917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169002917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169002917">Mario Carneiro (Jun 26 2019 at 06:10)</a>:</h4>
<p>I would do something like <code>zip_with</code> to put the powers together and <code>list.sum</code> to add them up</p>

<a name="169002928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169002928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169002928">Johan Commelin (Jun 26 2019 at 06:10)</a>:</h4>
<blockquote>
<p>well I have <code>x : list nat</code> and <code>r : list nat</code>, lists of positive integers of the same length, and i want to sum (i-th term of x)^(i-th term of r) over i</p>
</blockquote>
<p>??? why are they of the same length?</p>

<a name="169002949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169002949" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169002949">Adrian Chu (Jun 26 2019 at 06:11)</a>:</h4>
<blockquote>
<blockquote>
<p>well I have <code>x : list nat</code> and <code>r : list nat</code>, lists of positive integers of the same length, and i want to sum (i-th term of x)^(i-th term of r) over i</p>
</blockquote>
<p>??? why are they of the same length?</p>
</blockquote>
<p>by assumption</p>

<a name="169005531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169005531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169005531">Scott Morrison (Jun 26 2019 at 07:13)</a>:</h4>
<p>Can you arrange to have a <code>list (nat x nat)</code>?</p>

<a name="169006265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169006265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169006265">Adrian Chu (Jun 26 2019 at 07:29)</a>:</h4>
<blockquote>
<p>Can you arrange to have a <code>list (nat x nat)</code>?</p>
</blockquote>
<p>how will this help?</p>

<a name="169006369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169006369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169006369">Marc Huisinga (Jun 26 2019 at 07:31)</a>:</h4>
<p>it ensures that you have two lists of the same size, but is this really the easiest way to do it? why not pass a proof that the lengths are equal instead?</p>

<a name="169006384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169006384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169006384">Mario Carneiro (Jun 26 2019 at 07:31)</a>:</h4>
<p>it separates the information somewhat and generally makes the proofs harder</p>

<a name="169006472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169006472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169006472">Mario Carneiro (Jun 26 2019 at 07:32)</a>:</h4>
<p>I don't know about the direction of this thread though. What is the actual goal? I think the encoding decisions are being made without a good idea of the target theorem and that's bad news</p>

<a name="169006489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169006489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169006489">Adrian Chu (Jun 26 2019 at 07:33)</a>:</h4>
<p>okok, let me write out the complete thm</p>

<a name="169006690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169006690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169006690">Adrian Chu (Jun 26 2019 at 07:37)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>

<span class="kn">theorem</span> <span class="n">mythm</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">r</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">(</span><span class="n">coprime</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">coprime</span> <span class="o">(</span><span class="n">r</span> <span class="n">i</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="err">^</span><span class="o">(</span><span class="n">r</span> <span class="n">i</span><span class="o">))</span> <span class="bp">=</span> <span class="n">y</span><span class="err">^</span><span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>

<a name="169006696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169006696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169006696">Adrian Chu (Jun 26 2019 at 07:37)</a>:</h4>
<p>this is the original form of my theorem</p>

<a name="169006759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169006759" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169006759">Adrian Chu (Jun 26 2019 at 07:38)</a>:</h4>
<p>and we can discuss whether  (1) to use nat or int, and (2) to use fin n -&gt; nat or list nat</p>

<a name="169006867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169006867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169006867">Marc Huisinga (Jun 26 2019 at 07:40)</a>:</h4>
<p>the only adv of fin n -&gt; nat i can think of is that fin n -&gt; nat can be handy when dealing with nested inductive types</p>

<a name="169006962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169006962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169006962">Adrian Chu (Jun 26 2019 at 07:43)</a>:</h4>
<p>and I will use these 2 lemmas</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">euclidean_domain</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span>

<span class="kn">open</span> <span class="n">euclidean_domain</span>

<span class="n">def</span> <span class="n">fin_n_to_list</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span>

<span class="n">def</span> <span class="n">n_lcm</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
  <span class="n">list</span><span class="bp">.</span><span class="n">foldl</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lcm</span> <span class="mi">1</span> <span class="o">(</span><span class="n">fin_n_to_list</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">n_lcm_coprime</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">coprime</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">coprime</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nat</span><span class="bp">.</span><span class="n">coprime</span> <span class="o">(</span><span class="n">n_lcm</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="c1">-- not yet proven</span>

<span class="kn">lemma</span> <span class="n">bazout</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="bp">∧</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="c1">-- already proven</span>
</pre></div>

<a name="169007185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169007185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169007185">Mario Carneiro (Jun 26 2019 at 07:47)</a>:</h4>
<p>The statement of <code>mythm</code> looks fine, except that you can replace <code>fin n</code> with any fintype <code>A</code>, and the <code>0 &lt;= y</code> is redundant</p>

<a name="169014710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169014710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169014710">Adrian Chu (Jun 26 2019 at 09:58)</a>:</h4>
<p>no... i just tried, the conversion between int and nat is so frustrating (since my bazout lemma is using int). i want to use int in mythm. do we have a^b for a, b in int ?</p>

<a name="169014943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169014943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169014943">Mario Carneiro (Jun 26 2019 at 10:02)</a>:</h4>
<p>You want to have your bezout lemma on nat too</p>

<a name="169015511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169015511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169015511">Adrian Chu (Jun 26 2019 at 10:13)</a>:</h4>
<p>good idea, i can make a new lemma bazout2 for nat using bazout</p>

<a name="169016013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169016013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169016013">Adrian Chu (Jun 26 2019 at 10:22)</a>:</h4>
<p>my strategy now is to use a, b : nat, but use euclidean_domain.gcd (a:int) b</p>

<a name="169016523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169016523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169016523">Mario Carneiro (Jun 26 2019 at 10:30)</a>:</h4>
<p>Since you seem to already have a solution, I will show you how I would have proven your original bezout theorem:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">bezout</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">))</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">b</span><span class="bp">*</span><span class="n">k</span> <span class="bp">-</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">a</span><span class="bp">*</span><span class="n">k</span> <span class="bp">+</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">refine</span> <span class="bp">⟨</span><span class="n">int</span><span class="bp">.</span><span class="n">to_nat</span> <span class="n">x</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">to_nat</span> <span class="n">y</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_inj</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">int</span><span class="bp">.</span><span class="n">to_nat</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">int</span><span class="bp">.</span><span class="n">to_nat</span> <span class="n">y</span><span class="o">,</span> <span class="o">{</span><span class="n">simpa</span><span class="o">},</span>
  <span class="k">have</span> <span class="n">k1</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_add_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">ha&#39;</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_le</span><span class="bp">.</span><span class="mi">2</span> <span class="n">ha</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hb&#39;</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_le</span><span class="bp">.</span><span class="mi">2</span> <span class="n">hb</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">x0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">sub_nonneg</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">_</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">mul_le_mul_of_nonneg_right</span> <span class="n">hb&#39;</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_nonneg</span> <span class="n">k</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">one_mul</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">int</span><span class="bp">.</span><span class="n">le_nat_abs</span> <span class="bp">_</span><span class="o">)</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_le</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_succ_of_le</span> <span class="o">(</span><span class="n">le_max_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">y0</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">y</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">sub_le_iff_le_add</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">zero_sub</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:=</span> <span class="n">mul_le_mul_of_nonneg_right</span> <span class="n">ha&#39;</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_nonneg</span> <span class="n">k</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">one_mul</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">int</span><span class="bp">.</span><span class="n">le_nat_abs</span> <span class="bp">_</span><span class="o">)</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">int</span><span class="bp">.</span><span class="n">nat_abs_neg</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_le</span><span class="o">],</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">le_succ_of_le</span> <span class="o">(</span><span class="n">le_max_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">int</span><span class="bp">.</span><span class="n">to_nat_of_nonneg</span> <span class="n">x0</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">to_nat_of_nonneg</span> <span class="n">y0</span><span class="o">],</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd_eq_gcd_ab</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_one</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">this</span><span class="o">,</span> <span class="n">mul_sub</span><span class="o">,</span> <span class="err">←</span> <span class="n">add_assoc</span><span class="o">,</span> <span class="n">sub_add_cancel</span><span class="o">,</span> <span class="n">mul_left_comm</span><span class="o">,</span> <span class="err">←</span> <span class="n">mul_add</span><span class="o">],</span>
<span class="kn">end</span>
</pre></div>


<p>I don't think it's necessary to ban the use of nats as long as you are conscientious in your use of the up arrow. In particular if it makes you use more unusual functions with a worse interface then it's not worth it</p>

<a name="169018155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018155">Patrick Massot (Jun 26 2019 at 11:00)</a>:</h4>
<p>I think this is completely crazy. How can it be a good idea to have <code>nat.gcd</code>, <code>int.gcd</code> and <code>euclidean_domain.gcd</code> and not a single lemma relating those?</p>

<a name="169018175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018175">Mario Carneiro (Jun 26 2019 at 11:00)</a>:</h4>
<p>Of course there should be such lemmas</p>

<a name="169018192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018192">Mario Carneiro (Jun 26 2019 at 11:01)</a>:</h4>
<p>but we don't need the other gcds for this theorem</p>

<a name="169018289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018289" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018289">Patrick Massot (Jun 26 2019 at 11:02)</a>:</h4>
<p>The proof of this theorem is much nicer with <code>euclidean_domain.gcd</code>. Your proof is hideous, even if it could be nicer using <code>norm_cast</code></p>

<a name="169018308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018308">Mario Carneiro (Jun 26 2019 at 11:02)</a>:</h4>
<p>None of the proof has to do with gcd</p>

<a name="169018357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018357" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018357">Mario Carneiro (Jun 26 2019 at 11:03)</a>:</h4>
<p>It's quite possible that norm_cast can be used in a few places, but it's mostly about dealing with max and simple algebra</p>

<a name="169018368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018368">Mario Carneiro (Jun 26 2019 at 11:03)</a>:</h4>
<p>also I don't really care about calc blocks</p>

<a name="169018490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018490">Mario Carneiro (Jun 26 2019 at 11:05)</a>:</h4>
<p>Are you saying that there is a completely different proof that uses <code>euclidean_domain.gcd</code> with some different lemmas about it? I'm mostly following adrian's proof sketch here</p>

<a name="169018544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018544">Kevin Buzzard (Jun 26 2019 at 11:06)</a>:</h4>
<p>The fact that we have</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">gcd_eq_gcd_ab</span> <span class="o">:</span> <span class="o">(</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:=</span> <span class="bp">...</span>
</pre></div>


<p>and this proof is still nearly 30 lines is what is so jarring.</p>

<a name="169018563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018563" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018563">Mario Carneiro (Jun 26 2019 at 11:06)</a>:</h4>
<p>This theorem is proving something completely different</p>

<a name="169018568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018568" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018568">Kevin Buzzard (Jun 26 2019 at 11:06)</a>:</h4>
<p>Hmm, I guess gcd_a is probably an int, so there's some content getting all the signs right</p>

<a name="169018581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018581" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018581">Mario Carneiro (Jun 26 2019 at 11:07)</a>:</h4>
<p>The important part is the fact that you can shift around solutions by a multiple</p>

<a name="169018586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018586" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018586">Kevin Buzzard (Jun 26 2019 at 11:07)</a>:</h4>
<p>Right.</p>

<a name="169018603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018603">Mario Carneiro (Jun 26 2019 at 11:07)</a>:</h4>
<p>and then you have some inequalities to check</p>

<a name="169018623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018623">Patrick Massot (Jun 26 2019 at 11:07)</a>:</h4>
<p>I mean</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="bp">∧</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">let</span> <span class="n">u</span> <span class="o">:=</span> <span class="n">gcd_a</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">gcd_b</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">hk</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">abs_nonneg</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">le_max_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">),</span>
  <span class="n">use</span> <span class="o">[</span><span class="bp">-</span><span class="n">u</span><span class="bp">+</span><span class="n">b</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span> <span class="bp">+</span> <span class="n">a</span><span class="bp">*</span><span class="n">k</span><span class="o">],</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">split</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="k">show</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span><span class="bp">*</span><span class="n">u</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">v</span><span class="o">,</span> <span class="k">from</span> <span class="n">h</span> <span class="bp">▸</span> <span class="n">gcd_eq_gcd_ab</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">ring</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">suffices</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">),</span> <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span>
    <span class="k">calc</span> <span class="n">u</span> <span class="bp">≤</span> <span class="n">abs</span> <span class="n">u</span> <span class="o">:</span> <span class="n">le_abs_self</span> <span class="n">u</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">le_max_left</span> <span class="bp">_</span> <span class="bp">_</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="mi">1</span><span class="bp">*</span><span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">b</span><span class="bp">*</span><span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">mul_le_mul_of_nonneg_right</span> <span class="n">hb</span> <span class="n">hk</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">suffices</span> <span class="o">:</span> <span class="bp">-</span><span class="n">v</span> <span class="bp">≤</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">),</span> <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span>
    <span class="k">calc</span> <span class="bp">-</span><span class="n">v</span> <span class="bp">≤</span> <span class="n">abs</span> <span class="n">v</span> <span class="o">:</span> <span class="n">neg_le_abs_self</span> <span class="bp">_</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">le_max_right</span> <span class="bp">_</span> <span class="bp">_</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="mi">1</span><span class="bp">*</span><span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">le_max_right</span> <span class="o">]</span>
    <span class="bp">...</span> <span class="bp">≤</span> <span class="n">a</span><span class="bp">*</span><span class="n">max</span> <span class="o">(</span><span class="n">abs</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">abs</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">mul_le_mul_of_nonneg_right</span> <span class="n">ha</span> <span class="n">hk</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="169018666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018666">Kevin Buzzard (Jun 26 2019 at 11:08)</a>:</h4>
<p>I think our views on the meaning of the phrase "completely different" might have diverged a bit but I do take your point that more needs to be said.</p>

<a name="169018686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018686">Mario Carneiro (Jun 26 2019 at 11:08)</a>:</h4>
<p>Ah, you linarith'd</p>

<a name="169018701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018701">Patrick Massot (Jun 26 2019 at 11:08)</a>:</h4>
<p>And then, modulo relating different versions of <code>gcd</code>, the proof of the <code>nat</code> version is:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">baz</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rcases</span> <span class="n">foo</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="k">by</span> <span class="n">exact_mod_cast</span> <span class="n">ha</span><span class="o">)</span> <span class="o">(</span><span class="k">by</span> <span class="n">exact_mod_cast</span> <span class="n">hb</span><span class="o">)</span> <span class="n">sorry</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">x</span><span class="bp">.</span><span class="n">to_nat</span><span class="o">,</span> <span class="n">y</span><span class="bp">.</span><span class="n">to_nat</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="k">show</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="n">to_nat</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="o">],</span>
      <span class="k">show</span> <span class="n">y</span> <span class="bp">=</span> <span class="o">(</span><span class="n">y</span><span class="bp">.</span><span class="n">to_nat</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="o">]]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact_mod_cast</span> <span class="n">h</span>
<span class="kn">end</span>
</pre></div>

<a name="169018705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018705">Kevin Buzzard (Jun 26 2019 at 11:08)</a>:</h4>
<p>and he rung.</p>

<a name="169018815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169018815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169018815">Patrick Massot (Jun 26 2019 at 11:10)</a>:</h4>
<p>Of course I linarith, I ring, and norm_cast. I very strongly believe all this is essential for the future of proof assistants for mathematicians</p>

<a name="169019121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169019121" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169019121">Adrian Chu (Jun 26 2019 at 11:15)</a>:</h4>
<p>million thanks. i am building up the framework of the proof of mythm currently.</p>

<a name="169019829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169019829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169019829">Kevin Buzzard (Jun 26 2019 at 11:27)</a>:</h4>
<blockquote>
<p>It's quite possible that norm_cast can be used in a few places, but it's mostly about dealing with max and simple algebra</p>
</blockquote>
<p>This is just the metamath-mario trying to get out. You can see a proof from very low-level principles and so figure that this is a good way to do it. The mathematicians see the theorem for <code>int</code> and figure that the boring work is already done, and that we should just use that.</p>

<a name="169019979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169019979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169019979">Mario Carneiro (Jun 26 2019 at 11:29)</a>:</h4>
<p>I don't use a high level tactic until I understand very well how effective it is and in what circumstances it can be used. AKA "no magic"</p>

<a name="169020048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020048">Kevin Buzzard (Jun 26 2019 at 11:30)</a>:</h4>
<p>That's exactly what I'm saying. You were brought up on metamath and this has formed the way you think about how to solve goals.</p>

<a name="169020049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020049" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020049">Mario Carneiro (Jun 26 2019 at 11:30)</a>:</h4>
<p>That said there are also a few proof tricks in Patrick's proof that I missed</p>

<a name="169020062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020062" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020062">Patrick Massot (Jun 26 2019 at 11:30)</a>:</h4>
<p>We need both. We need Mario on one side, and we need Rob and Paul-Nicolas (and hopefully many more) on the other side</p>

<a name="169020089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020089">Kevin Buzzard (Jun 26 2019 at 11:31)</a>:</h4>
<p>Yes absolutely. I'm just saying that it's interesting.</p>

<a name="169020136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020136">Kevin Buzzard (Jun 26 2019 at 11:32)</a>:</h4>
<p>I think Mario wrote <code>ring</code> ;-)</p>

<a name="169020231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020231">Mario Carneiro (Jun 26 2019 at 11:33)</a>:</h4>
<p>The difference between us is I feel the pressure of the actual proof term at all times</p>

<a name="169020262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020262">Mario Carneiro (Jun 26 2019 at 11:33)</a>:</h4>
<p>If I use a complicated tactic that spews some gigantic... <em>thing</em>... in for my proof, I think it's a long and ugly proof</p>

<a name="169020277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020277" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020277">Kevin Buzzard (Jun 26 2019 at 11:33)</a>:</h4>
<p>That's an interesting comment. I have no concept of what proof terms look like.</p>

<a name="169020285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020285">Mario Carneiro (Jun 26 2019 at 11:33)</a>:</h4>
<p>even if the proof script is just <code>by magic</code></p>

<a name="169020355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020355" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020355">Mario Carneiro (Jun 26 2019 at 11:34)</a>:</h4>
<p>When I use <code>refine</code> and <code>apply</code> and <code>rw</code>, I know exactly what proof term is getting generated and how heavy that's going to be for the kernel</p>

<a name="169020373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020373">Kevin Buzzard (Jun 26 2019 at 11:35)</a>:</h4>
<p>With Olympiad training as a kid I was taught the importance of getting the solution out as quickly as possible, who cares about other stuff like elegance.</p>

<a name="169020404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020404">Kevin Buzzard (Jun 26 2019 at 11:35)</a>:</h4>
<p>I'm hoping that <code>refine</code> and <code>apply</code> don't add too much weight to the proof term! I know how to do them in term mode :-)</p>

<a name="169020413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020413">Mario Carneiro (Jun 26 2019 at 11:35)</a>:</h4>
<p>that's exactly the point</p>

<a name="169020468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020468">Patrick Massot (Jun 26 2019 at 11:36)</a>:</h4>
<p>Then we need more CS people working on the magic tactics, so that they produce nicer terms</p>

<a name="169020473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020473" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020473">Mario Carneiro (Jun 26 2019 at 11:36)</a>:</h4>
<p>You don't really need them - you could do them in term mode. They are just slight shorthands for building that proof term</p>

<a name="169020493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020493">Kevin Buzzard (Jun 26 2019 at 11:37)</a>:</h4>
<p>why do I care about the size of a proof term? It's immediately forgotten.</p>

<a name="169020494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020494">Mario Carneiro (Jun 26 2019 at 11:37)</a>:</h4>
<p>I wish that was a bigger concern in lean-land. I care about it very much, but lean fights me when it comes to proof optimization</p>

<a name="169020507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020507">Mario Carneiro (Jun 26 2019 at 11:37)</a>:</h4>
<p>It's not forgotten, it's stored and passed around and checked hundreds of time on travis and burns many CPU hours around the world</p>

<a name="169020950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020950">Patrick Massot (Jun 26 2019 at 11:45)</a>:</h4>
<p>I'm seriously thinking about buying a bigger CPU tonight</p>

<a name="169020993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169020993" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169020993">Patrick Massot (Jun 26 2019 at 11:46)</a>:</h4>
<p>I think I want more cores and more RAM, right?</p>

<a name="169021005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169021005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169021005">Kevin Buzzard (Jun 26 2019 at 11:46)</a>:</h4>
<p>gone are the days of more pixels. I remember wanting more colours once!</p>

<a name="169021016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169021016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169021016">Kevin Buzzard (Jun 26 2019 at 11:46)</a>:</h4>
<p>I upgraded from 2 to 8</p>

<a name="169021058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169021058" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169021058">Reid Barton (Jun 26 2019 at 11:47)</a>:</h4>
<p>But some of the 8 colors were different on every other pixel so it was really more like... 12</p>

<a name="169021059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169021059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169021059">Patrick Massot (Jun 26 2019 at 11:47)</a>:</h4>
<p>I think VScode doesn't use much more than 8 colors, so you should be fine now. Let's go for CPU cores instead</p>

<a name="169021066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169021066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169021066">Kevin Buzzard (Jun 26 2019 at 11:47)</a>:</h4>
<p>Is a GPU of any use?</p>

<a name="169021072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169021072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169021072">Patrick Massot (Jun 26 2019 at 11:47)</a>:</h4>
<p>Unfortunately no</p>

<a name="169021131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169021131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169021131">Patrick Massot (Jun 26 2019 at 11:48)</a>:</h4>
<p>But wait until <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> starts working on Lean 4 on GPU</p>

<a name="169021291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169021291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169021291">Kevin Buzzard (Jun 26 2019 at 11:51)</a>:</h4>
<p>This isn't really a noob question and probably deserves its own thread. My laptop has something like 4 cores and 16 gigs of ram and even if I compile mathlib I don't ever get close to those 16 gigs.</p>

<a name="169021323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169021323" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169021323">Patrick Massot (Jun 26 2019 at 11:51)</a>:</h4>
<p>I have RAM problems when I want to compile mathlib while using VScode on some other project</p>

<a name="169021366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169021366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169021366">Kevin Buzzard (Jun 26 2019 at 11:52)</a>:</h4>
<p>In particular, I wonder whether somehow there's a theorem of the form "if you have x cores, then don't buy any more than c * x gigs of ram because Lean won't use that much" for some constant c.</p>

<a name="169021394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169021394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169021394">Kevin Buzzard (Jun 26 2019 at 11:53)</a>:</h4>
<p>When I want to compile mathlib and do something else too, I see how much free ram I have and then compile from the command line with the -M flag. Occasionally the build just runs out of memory and stops, and then I just start it again.</p>

<a name="169021429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169021429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169021429">Johan Commelin (Jun 26 2019 at 11:54)</a>:</h4>
<p>I haven't compile mathlib in the last 6 weeks. <code>cache-olean</code> is quite awesome.</p>

<a name="169021474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169021474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169021474">Kevin Buzzard (Jun 26 2019 at 11:54)</a>:</h4>
<p>Using the M flag also stopped my desktop (which had no swap) from randomly crashing when Lean suddenly goes beserk and fills up all memory.</p>

<a name="169021525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169021525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169021525">Kevin Buzzard (Jun 26 2019 at 11:55)</a>:</h4>
<p>IIRC it still didn't stop Lean going crazy when invoked via VS Code, so I added some swap anyway.</p>

<a name="169021560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169021560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169021560">Patrick Massot (Jun 26 2019 at 11:55)</a>:</h4>
<p>compiling mathlib is still required when working on mathlib</p>

<a name="169026200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169026200" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169026200">Kevin Buzzard (Jun 26 2019 at 12:56)</a>:</h4>
<blockquote>
<p>It's not forgotten, it's stored and passed around and checked hundreds of time on travis and burns many CPU hours around the world</p>
</blockquote>
<p>You make it sound like I'm responsible for climate change!</p>

<a name="169026267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169026267" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169026267">Patrick Massot (Jun 26 2019 at 12:57)</a>:</h4>
<p>This is clearly what he means.</p>

<a name="169026312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169026312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169026312">Patrick Massot (Jun 26 2019 at 12:57)</a>:</h4>
<p>And now you'll make it worse by flying to Portland</p>

<a name="169037916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169037916" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169037916">Adrian Chu (Jun 26 2019 at 14:49)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">euclidean_domain</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">linarith</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">library_search</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">open</span> <span class="n">euclidean_domain</span>

<span class="n">def</span> <span class="n">fin_n_to_list</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">h</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span>

<span class="n">def</span> <span class="n">n_lcm</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
  <span class="n">list</span><span class="bp">.</span><span class="n">foldl</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lcm</span> <span class="mi">1</span> <span class="o">(</span><span class="n">fin_n_to_list</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">sum_to_mul</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span>  <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span><span class="bp">*</span><span class="n">b</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_const</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">card_univ</span><span class="o">,</span> <span class="n">fintype</span><span class="bp">.</span><span class="n">card_fin</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">n_lcm_coprime</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">coprime</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="o">(</span><span class="n">n_lcm</span> <span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="n">sorry</span> <span class="c1">-- need to prove</span>

<span class="kn">lemma</span> <span class="n">bazout_int</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="bp">∧</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">∧</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">y</span> <span class="o">:=</span>
<span class="n">sorry</span> <span class="c1">-- already proven</span>

<span class="kn">lemma</span> <span class="n">bazout_nat</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="c1">-- this is Patrick&#39;s version, or we can use mario&#39;s version above</span>
    <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">b</span><span class="bp">*</span><span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rcases</span> <span class="n">bazout_int</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="k">by</span> <span class="n">exact_mod_cast</span> <span class="n">ha</span><span class="o">)</span> <span class="o">(</span><span class="k">by</span> <span class="n">exact_mod_cast</span> <span class="n">hb</span><span class="o">)</span> <span class="n">sorry</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span><span class="o">,</span>
<span class="c1">-- need to prove</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">x</span><span class="bp">.</span><span class="n">to_nat</span><span class="o">,</span> <span class="n">y</span><span class="bp">.</span><span class="n">to_nat</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="k">show</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="n">to_nat</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="o">],</span>
      <span class="k">show</span> <span class="n">y</span> <span class="bp">=</span> <span class="o">(</span><span class="n">y</span><span class="bp">.</span><span class="n">to_nat</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hy</span><span class="o">]]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact_mod_cast</span> <span class="n">h</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">mythm</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
    <span class="o">(</span><span class="n">hn</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">r</span> <span class="n">i</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">(</span><span class="n">coprime</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="o">(</span><span class="n">r</span> <span class="n">i</span><span class="o">)</span> <span class="n">s</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
    <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
    <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">x</span> <span class="n">i</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span><span class="err">^</span><span class="o">(</span><span class="n">r</span> <span class="n">i</span><span class="o">))</span> <span class="bp">=</span> <span class="n">y</span><span class="err">^</span><span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="k">let</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">n_lcm</span> <span class="n">r</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">t_geq_1</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">≥</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>  <span class="c1">-- need to prove</span>
    <span class="k">have</span> <span class="n">ri_div_t</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">t</span> <span class="err">%</span> <span class="o">(</span><span class="n">r</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>  <span class="c1">-- need to prove</span>
    <span class="k">let</span> <span class="n">t_s_coprime</span> <span class="o">:=</span> <span class="n">n_lcm_coprime</span> <span class="n">r</span> <span class="n">s</span> <span class="n">coprime</span><span class="o">,</span>
    <span class="n">cases</span> <span class="o">(</span><span class="n">bazout_nat</span> <span class="n">t</span> <span class="n">s</span> <span class="n">t_geq_1</span> <span class="n">hs</span> <span class="n">t_s_coprime</span><span class="o">)</span> <span class="k">with</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">ha</span> <span class="k">with</span> <span class="n">b</span> <span class="n">hab</span><span class="o">,</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span><span class="err">^</span><span class="o">((</span><span class="n">a</span><span class="bp">*</span><span class="n">t</span><span class="o">)</span><span class="bp">/</span><span class="n">r</span> <span class="n">i</span><span class="o">),</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">n</span><span class="err">^</span><span class="n">b</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">trivial1</span> <span class="o">:</span> <span class="n">a</span><span class="bp">*</span><span class="n">t</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">t</span><span class="bp">*</span><span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">],</span>
    <span class="n">fapply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">fapply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">repeat</span> <span class="o">{</span><span class="n">split</span><span class="o">},</span>
    <span class="o">{</span><span class="n">intro</span> <span class="n">i</span><span class="o">,</span> <span class="n">sorry</span><span class="o">},</span> <span class="c1">-- for all i xi ≥ 1</span>
    <span class="k">calc</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span><span class="err">^</span><span class="o">((</span><span class="n">a</span><span class="bp">*</span><span class="n">t</span><span class="o">)</span><span class="bp">/</span><span class="n">r</span> <span class="n">i</span><span class="o">))</span><span class="err">^</span><span class="o">(</span><span class="n">r</span> <span class="n">i</span><span class="o">))</span>
    <span class="bp">=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span><span class="err">^</span><span class="o">(((</span><span class="n">a</span><span class="bp">*</span><span class="n">t</span><span class="o">)</span><span class="bp">/</span><span class="n">r</span> <span class="n">i</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">r</span> <span class="n">i</span><span class="o">))))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span><span class="err">^</span><span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">t</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">sorry</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">n</span><span class="bp">*</span><span class="o">(</span><span class="n">n</span><span class="err">^</span><span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">t</span><span class="o">))</span> <span class="o">:</span> <span class="n">sum_to_mul</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span><span class="err">^</span><span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">t</span><span class="o">))</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">n</span><span class="err">^</span><span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">t</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">):</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">mul_comm</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span><span class="err">^</span><span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">t</span><span class="o">))</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">n</span><span class="err">^</span><span class="o">(</span><span class="n">t</span><span class="bp">*</span><span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">pow</span> <span class="n">n</span><span class="o">)</span> <span class="n">trivial1</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">n</span><span class="err">^</span><span class="o">(</span><span class="n">s</span><span class="bp">*</span><span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">pow</span> <span class="n">n</span><span class="o">)</span> <span class="n">hab</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">n</span><span class="err">^</span><span class="o">(</span><span class="n">b</span><span class="bp">*</span><span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">exact</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="n">pow</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">mul_comm</span> <span class="n">s</span> <span class="n">b</span><span class="o">)</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">n</span><span class="err">^</span><span class="n">b</span><span class="o">)</span><span class="err">^</span><span class="n">s</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pow_mul</span> <span class="n">b</span> <span class="n">s</span> <span class="n">n</span>
<span class="kn">end</span>
</pre></div>

<a name="169038049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169038049" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169038049">Adrian Chu (Jun 26 2019 at 14:50)</a>:</h4>
<p>this is a record of my (our) progress, i am (we are) getting closer! but for me it's time to rest</p>

<a name="169038421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169038421" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169038421">Reid Barton (Jun 26 2019 at 14:54)</a>:</h4>
<p>I know Lean doesn't care, but the name is <code>bezout</code> (or even better, Bézout)</p>

<a name="169038517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169038517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169038517">Johan Commelin (Jun 26 2019 at 14:55)</a>:</h4>
<p>I'm inclined to say <em>baz…</em> (oh, well, never mind…)</p>

<a name="169041288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169041288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169041288">Patrick Massot (Jun 26 2019 at 15:25)</a>:</h4>
<p>I assumed all along this was an intentional reference to the foo, bar, baz sequence, being a variation on Bézout</p>

<a name="169041398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169041398" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169041398">Patrick Massot (Jun 26 2019 at 15:26)</a>:</h4>
<p>but maybe I was wrong and Adrian wants to also credit <a href="https://en.wikipedia.org/wiki/Claude_Gaspard_Bachet_de_M%C3%A9ziriac" target="_blank" title="https://en.wikipedia.org/wiki/Claude_Gaspard_Bachet_de_M%C3%A9ziriac">Bachet</a></p>

<a name="169070964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169070964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169070964">Kevin Kappelmann (Jun 26 2019 at 19:14)</a>:</h4>
<p>When using <code>induction t : e</code>, I get a weird inductive hypothesis. For example,</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">induction</span> <span class="n">n_eq</span> <span class="o">:</span> <span class="n">n</span> <span class="k">with</span> <span class="n">m</span> <span class="n">IH</span><span class="o">,</span>
<span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
<span class="o">{</span> <span class="n">sorry</span> <span class="o">}</span> <span class="c1">-- ill-formed IH here</span>
<span class="kn">end</span>
</pre></div>


<p>will create a goal </p>
<div class="codehilite"><pre><span></span><span class="n">case</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span>
<span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">IH</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">m</span><span class="o">,</span>
<span class="n">n_eq</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">m</span>
<span class="err">⊢</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">m</span> <span class="bp">*</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">m</span>
</pre></div>


<p>but clearly, <code>n ≠ m</code> so I cannot use the IH for my proof. Am I doing something wrong? Note: I need <code>n_eq</code> in the theorem I am actually proving, so just dropping <code>n_eq :</code> is not an option.</p>

<a name="169071507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169071507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169071507">Kevin Buzzard (Jun 26 2019 at 19:20)</a>:</h4>
<p>What does "I need <code>n_eq</code> in the theorem I am actually proving" mean? What's wrong with just <code>induction n with m IH</code>?</p>

<a name="169071577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169071577" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169071577">Johan Commelin (Jun 26 2019 at 19:21)</a>:</h4>
<p><del>Wrong thread?</del></p>

<a name="169071596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169071596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169071596">Kevin Buzzard (Jun 26 2019 at 19:21)</a>:</h4>
<p>(deleted)</p>

<a name="169071709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169071709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169071709">Kevin Buzzard (Jun 26 2019 at 19:22)</a>:</h4>
<blockquote>
<p>What does "I need <code>n_eq</code> in the theorem I am actually proving" mean? What's wrong with just <code>induction n with m IH</code>?</p>
</blockquote>
<p>I mean, what hypothesis do you actually want, if it's not what you got?</p>

<a name="169072061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072061">Kevin Buzzard (Jun 26 2019 at 19:27)</a>:</h4>
<p>But yeah something is weird there. It's as if <code>induction n_eq : n</code> will always cause you trouble.</p>

<a name="169072066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072066">Kevin Kappelmann (Jun 26 2019 at 19:27)</a>:</h4>
<p>That was ill-phrased, let me clarify. I did not want to say that I need <code>n_eq</code>, but rather, I still want to be able to refer to <code>n</code> in both cases. Basically, I want to do some work for both case nat.zero and nat.succ using <code>all_goals</code> and referring to <code>n</code> like this:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">induction</span> <span class="n">n_eq</span> <span class="o">:</span> <span class="n">n</span> <span class="k">with</span> <span class="n">m</span> <span class="n">IH</span><span class="o">,</span>
<span class="n">all_goals</span> <span class="o">{</span>
  <span class="k">have</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="n">n</span><span class="bp">.</span><span class="n">zero_le</span>
<span class="o">},</span>
<span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
<span class="o">{</span> <span class="n">sorry</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="169072149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072149">Kevin Buzzard (Jun 26 2019 at 19:28)</a>:</h4>
<p>But when you do <code>induction n</code>, doesn't <code>n</code> literally disappear from the context?</p>

<a name="169072171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072171">Kevin Kappelmann (Jun 26 2019 at 19:28)</a>:</h4>
<p>Yep, that's what I want to avoid!</p>

<a name="169072187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072187">Kevin Buzzard (Jun 26 2019 at 19:29)</a>:</h4>
<p>But isn't that how induction works?</p>

<a name="169072221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072221">Kevin Buzzard (Jun 26 2019 at 19:29)</a>:</h4>
<p>I see what you're trying to do.</p>

<a name="169072236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072236">Kevin Buzzard (Jun 26 2019 at 19:29)</a>:</h4>
<p>Why don't you just do what you want to do with n before you start on the induction?</p>

<a name="169072432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072432">Kevin Kappelmann (Jun 26 2019 at 19:32)</a>:</h4>
<p>Because then it introduces these statements as premises in my IH as well. Cf:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">have</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="n">n</span><span class="bp">.</span><span class="n">zero_le</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">m</span> <span class="n">IH</span><span class="o">,</span>
<span class="o">{</span> <span class="n">simp</span> <span class="o">},</span>
<span class="o">{</span> <span class="n">sorry</span> <span class="o">}</span> <span class="c1">-- check IH here</span>
<span class="kn">end</span>
</pre></div>

<a name="169072485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072485">Kevin Buzzard (Jun 26 2019 at 19:32)</a>:</h4>
<p>Yes you're right.</p>

<a name="169072656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072656">Kevin Buzzard (Jun 26 2019 at 19:34)</a>:</h4>
<p>It's just <code>revert</code>ing all hypotheses with an <code>n</code> in before starting the induction.</p>

<a name="169072703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072703">Kevin Buzzard (Jun 26 2019 at 19:35)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≤</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">have</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="n">n</span><span class="bp">.</span><span class="n">zero_le</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span><span class="o">,</span>
</pre></div>

<a name="169072715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072715" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072715">Kevin Buzzard (Jun 26 2019 at 19:35)</a>:</h4>
<p>It must just be what the tactic does.</p>

<a name="169072718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072718">Reid Barton (Jun 26 2019 at 19:35)</a>:</h4>
<p>I think you can use <code>set</code> to rename <code>succ m</code> to <code>n</code> if you like</p>

<a name="169072734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072734" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072734">Kevin Buzzard (Jun 26 2019 at 19:35)</a>:</h4>
<p>You can get round it by just applying the recursor directly like in the above.</p>

<a name="169072825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072825" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072825">Chris Hughes (Jun 26 2019 at 19:36)</a>:</h4>
<p>I think you want to prove something like forall t &gt; 0, n \le n * t</p>

<a name="169072836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072836">Kevin Buzzard (Jun 26 2019 at 19:36)</a>:</h4>
<p>No, my idea doesn't work either.</p>

<a name="169072858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072858" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072858">Chris Hughes (Jun 26 2019 at 19:36)</a>:</h4>
<p>And then apply it to n, and prove the case n =0 separately</p>

<a name="169072884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072884">Kevin Buzzard (Jun 26 2019 at 19:37)</a>:</h4>
<p>Chris the question is how to get <code>induction</code> not to revert facts about n which you want left alone.</p>

<a name="169072918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072918">Chris Hughes (Jun 26 2019 at 19:37)</a>:</h4>
<p><code>clear</code> first</p>

<a name="169072986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072986">Reid Barton (Jun 26 2019 at 19:38)</a>:</h4>
<p>Oh I guess I didn't really understand what you are trying to do</p>

<a name="169072987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169072987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169072987">Kevin Buzzard (Jun 26 2019 at 19:38)</a>:</h4>
<p>The question is how to get from</p>
<div class="codehilite"><pre><span></span>1 goal
n : ℕ,
this : 0 ≤ n
⊢ n ≤ n * n
</pre></div>


<p>to</p>
<div class="codehilite"><pre><span></span>2 goals
case nat.zero
this : 0 ≤ 0
⊢ 0 ≤ 0 * 0

case nat.succ
m : ℕ,
IH : m ≤ m * m,
this : 0 ≤ nat.succ m
⊢ nat.succ m ≤ nat.succ m * nat.succ m
</pre></div>

<a name="169073022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169073022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169073022">Kevin Buzzard (Jun 26 2019 at 19:39)</a>:</h4>
<p>i.e. "do cases on <code>this</code> but do induction on the goal"</p>

<a name="169073198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169073198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169073198">Chris Hughes (Jun 26 2019 at 19:41)</a>:</h4>
<p>In general that's impossible, because if it didn't put the hypothesis at the start you could prove contradictions right. Unless I misunderstand.</p>

<a name="169073203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169073203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169073203">Kevin Buzzard (Jun 26 2019 at 19:41)</a>:</h4>
<p><code>induction n with m IH</code> gives</p>
<div class="codehilite"><pre><span></span>case nat.succ
m : ℕ,
IH : 0 ≤ m → m ≤ m * m,
this : 0 ≤ nat.succ m
⊢ nat.succ m ≤ nat.succ m * nat.succ m
</pre></div>


<p>and <code>induction h : n with m IH</code> gives</p>
<div class="codehilite"><pre><span></span>case nat.succ
n : ℕ,
this : 0 ≤ n,
m : ℕ,
IH : n = m → m ≤ m * m,
h : n = nat.succ m
⊢ nat.succ m ≤ nat.succ m * nat.succ m
</pre></div>


<p>In both cases the inductive hypothesis is rendered useless because the assumption is false.</p>

<a name="169073226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169073226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169073226">Kevin Buzzard (Jun 26 2019 at 19:41)</a>:</h4>
<p>You might be right that it's impossible.</p>

<a name="169073345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169073345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169073345">Kevin Buzzard (Jun 26 2019 at 19:43)</a>:</h4>
<p><span class="user-mention" data-user-id="198376">@Kevin Kappelmann</span> That <code>n</code> really does not exist any more. This is the problem. If you have a statement which is true for all all nats, then don't prove it for <code>n</code>, prove it for all nats before the induction starts and then apply it to whatever you want to apply it to afterwards.</p>

<a name="169073386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169073386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169073386">Kevin Buzzard (Jun 26 2019 at 19:43)</a>:</h4>
<p>I think it's misleading to think that the <code>n</code> has "become succ m" in the inductive step. The <code>n</code> is meaningfully attached to both <code>m</code> and <code>succ m</code> here.</p>

<a name="169074089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169074089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169074089">Chris Hughes (Jun 26 2019 at 19:52)</a>:</h4>
<p>Here's a contradiction I can prove</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">nat</span>
<span class="kn">lemma</span> <span class="n">rubbish</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">hm</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">≠</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="n">m</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">left</span><span class="o">,</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- case nat.succ</span>
    <span class="c1">-- m : ℕ,</span>
    <span class="c1">-- hm : m ≠ 1,</span>
    <span class="c1">-- n_n : ℕ,</span>
    <span class="c1">-- n_ih : n_n = m → n_n = 0 ∨ n_n &gt; m,</span>
    <span class="c1">-- h : succ n_n = m</span>
    <span class="c1">-- ⊢ succ n_n = 0 ∨ succ n_n &gt; m</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">n_n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="n">n_n</span> <span class="bp">&gt;</span> <span class="n">m</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">subst</span> <span class="n">this</span><span class="o">,</span> <span class="n">exfalso</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hm</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="o">(</span><span class="n">lt_succ_of_lt</span> <span class="n">this</span><span class="o">)</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="n">absurd</span> <span class="o">(</span><span class="n">rubbish</span> <span class="mi">2</span> <span class="mi">2</span><span class="o">)</span> <span class="n">dec_trivial</span>
</pre></div>

<a name="169074364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169074364" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169074364">Kevin Kappelmann (Jun 26 2019 at 19:54)</a>:</h4>
<p>Alright, thanks. Using induction with this pattern <code>induction t : e</code> is pretty useless then, isn't it?</p>

<a name="169074585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169074585" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169074585">Chris Hughes (Jun 26 2019 at 19:57)</a>:</h4>
<p>Maybe for naturals. There are definitely some uses, but I can't think of any right now.</p>

<a name="169074708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169074708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169074708">Kevin Buzzard (Jun 26 2019 at 19:58)</a>:</h4>
<p><code>cases t : e</code> is surely useful.</p>

<a name="169074794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169074794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169074794">Kevin Buzzard (Jun 26 2019 at 19:59)</a>:</h4>
<p>But when it really is an induction, won't the inductive hypothesis end up contradicting another hypothesis most of the time?</p>

<a name="169074938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169074938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169074938">Chris Hughes (Jun 26 2019 at 20:00)</a>:</h4>
<p>I think all of the time, given the freely generated nature of inductive types.</p>

<a name="169074961"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169074961" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169074961">Kevin Buzzard (Jun 26 2019 at 20:00)</a>:</h4>
<p>Yeah, I'm just trying to prove <code>list.rec</code> with <code>induction h : l</code> and I don't think it can be done.</p>

<a name="169075005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169075005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169075005">Chris Hughes (Jun 26 2019 at 20:01)</a>:</h4>
<p>Maybe it would be useful for custom recursors when you do <code>induction ... using ...</code></p>

<a name="169075178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169075178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169075178">Kevin Buzzard (Jun 26 2019 at 20:03)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="c1">-- attempt to prove list.rec</span>
<span class="kn">example</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">list</span> <span class="n">T</span> <span class="bp">→</span> <span class="kt">Type</span><span class="o">},</span>
    <span class="n">C</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">tl</span> <span class="o">:</span> <span class="n">list</span> <span class="n">T</span><span class="o">),</span> <span class="n">C</span> <span class="n">tl</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">hd</span> <span class="bp">::</span> <span class="n">tl</span><span class="o">))</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">list</span> <span class="n">T</span><span class="o">),</span> <span class="n">C</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">T</span> <span class="n">C</span> <span class="n">hnil</span> <span class="n">hcons</span> <span class="n">l</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">h</span> <span class="o">:</span> <span class="n">l</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hnil</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">hcons</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">ih</span><span class="o">,</span>
  <span class="c1">-- dead</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="169075340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169075340" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169075340">Reid Barton (Jun 26 2019 at 20:05)</a>:</h4>
<p>mathlib has a fair number of uses (<code>git grep '\binduction .*:'</code>) but I didn't check whether they could be replaced by <code>cases</code></p>

<a name="169076380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169076380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169076380">Kevin Buzzard (Jun 26 2019 at 20:20)</a>:</h4>
<p>Or just search <code>\binduction .*:</code> in VS Code but switch on the <code>.*</code> option (use regular expression)</p>

<a name="169076591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169076591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169076591">Kevin Buzzard (Jun 26 2019 at 20:23)</a>:</h4>
<p>All the ones I checked, could be replaced by <code>cases</code>. There are loads in <code>data/seq</code> and I didn't check any of them.</p>

<a name="169097926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169097926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169097926">Scott Viteri (Jun 27 2019 at 02:12)</a>:</h4>
<p>Hello,<br>
Upon adding mathlib as a project dependency, searching for definitions with emacs helm errors out due to excessive memory consumption. I don't see any mentions of this in github lean-mode issues. Is this to be expected?<br>
Thanks,<br>
Scott</p>

<a name="169098105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169098105" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169098105">Reid Barton (Jun 27 2019 at 02:16)</a>:</h4>
<p>Running <code>leanpkg build</code> in your project should help</p>

<a name="169098128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169098128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169098128">Reid Barton (Jun 27 2019 at 02:16)</a>:</h4>
<p>That will build whatever parts of mathlib your project currently imports, so that later lean won't have to compile them on the fly</p>

<a name="169098192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169098192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169098192">Reid Barton (Jun 27 2019 at 02:17)</a>:</h4>
<p>If you just want to build all of mathlib, I think <code>lean --make _target/deps/mathlib/src</code> should work</p>

<a name="169098366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169098366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169098366">Scott Viteri (Jun 27 2019 at 02:20)</a>:</h4>
<p>I see -- I tried 'leanpkg build' and and still getting memory issues. I'll try building all of mathlib.</p>

<a name="169098394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169098394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169098394">Reid Barton (Jun 27 2019 at 02:21)</a>:</h4>
<p>You might need to restart the lean server after running <code>leanpkg build</code> as well</p>

<a name="169098442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169098442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169098442">Reid Barton (Jun 27 2019 at 02:22)</a>:</h4>
<p>My brain isn't in Lean mode so I forget the key</p>

<a name="169098446"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169098446" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169098446">Scott Viteri (Jun 27 2019 at 02:22)</a>:</h4>
<p>Oh, that did it</p>

<a name="169098452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169098452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169098452">Scott Viteri (Jun 27 2019 at 02:22)</a>:</h4>
<p>C-c C-r</p>

<a name="169098466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169098466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169098466">Scott Viteri (Jun 27 2019 at 02:23)</a>:</h4>
<p>Wonderful, thank you</p>

<a name="169098524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169098524" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169098524">Scott Viteri (Jun 27 2019 at 02:24)</a>:</h4>
<blockquote>
<p>My brain isn't in Lean mode so I forget the key</p>
</blockquote>
<p>If only brains could context switch with a simple M-x ...</p>

<a name="169102918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169102918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169102918">Scott Viteri (Jun 27 2019 at 04:25)</a>:</h4>
<p>Separate question -- is there a general rule of thumb of when to use the tactic mode for proofs?</p>

<a name="169102927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169102927" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169102927">Scott Viteri (Jun 27 2019 at 04:25)</a>:</h4>
<p>Or is it just a stylistic choice</p>

<a name="169102986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169102986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169102986">Mario Carneiro (Jun 27 2019 at 04:26)</a>:</h4>
<p>when it's easier</p>

<a name="169102990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169102990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169102990">Mario Carneiro (Jun 27 2019 at 04:27)</a>:</h4>
<p>or more compact</p>

<a name="169103001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169103001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169103001">Mario Carneiro (Jun 27 2019 at 04:27)</a>:</h4>
<p>The best approach is to use a combination of both and be comfortable going back and forth</p>

<a name="169103125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169103125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169103125">Scott Viteri (Jun 27 2019 at 04:30)</a>:</h4>
<p>is going from regular to tactic mode using "by"?</p>

<a name="169103139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169103139" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169103139">Scott Viteri (Jun 27 2019 at 04:31)</a>:</h4>
<p>and is the opposite direction using exact?</p>

<a name="169103190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169103190" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169103190">Mario Carneiro (Jun 27 2019 at 04:32)</a>:</h4>
<p>yes</p>

<a name="169103269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169103269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169103269">Scott Viteri (Jun 27 2019 at 04:34)</a>:</h4>
<p>yes to both directions?</p>

<a name="169103344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169103344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169103344">Scott Viteri (Jun 27 2019 at 04:36)</a>:</h4>
<p>Also I didn't realize a bit ago that you can use start begin end blocks in the middle of a proof</p>

<a name="169103509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169103509" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169103509">Scott Morrison (Jun 27 2019 at 04:40)</a>:</h4>
<p>I find that for "easy" stuff (i.e. proofs that you know ought to be easy, so you don't actually plan ahead of time what you're doing!), I always start in tactic mode, blunder about for a bit (often letting <code>tidy</code> do some of the work), then end up with a successful tactic script. Now you're only half done, and you convert all the parts of the proof that are more succinct in term mode back into term mode.</p>

<a name="169103636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169103636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169103636">Scott Viteri (Jun 27 2019 at 04:45)</a>:</h4>
<p>What is tidy?</p>

<a name="169103682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169103682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169103682">Scott Viteri (Jun 27 2019 at 04:46)</a>:</h4>
<p>I found it</p>

<a name="169103834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169103834" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169103834">Scott Viteri (Jun 27 2019 at 04:51)</a>:</h4>
<p>Is there a preference for more specificity in the proofs? Eg why not leave tidy in the proof</p>

<a name="169104004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169104004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169104004">Scott Viteri (Jun 27 2019 at 04:56)</a>:</h4>
<p>Is there a Lean analog of crush?</p>

<a name="169104007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169104007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169104007">Mario Carneiro (Jun 27 2019 at 04:56)</a>:</h4>
<p>that's tidy</p>

<a name="169104025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169104025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169104025">Mario Carneiro (Jun 27 2019 at 04:57)</a>:</h4>
<p>You don't want to leave tidy in the proof because it's slow. It's basically a meta-tactic that finds a tactic script that you should use in place of tidy</p>

<a name="169104408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169104408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169104408">Scott Viteri (Jun 27 2019 at 05:06)</a>:</h4>
<p>makes sense</p>

<a name="169104468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169104468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169104468">Scott Viteri (Jun 27 2019 at 05:08)</a>:</h4>
<p>It seems that in order to find tidy in emacs definition search I must first import it</p>

<a name="169104525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169104525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169104525">Scott Viteri (Jun 27 2019 at 05:10)</a>:</h4>
<p>which I guess is fine, I could just grep through my mathlib directory if I'm looking for something</p>

<a name="169104550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169104550" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169104550">Scott Viteri (Jun 27 2019 at 05:11)</a>:</h4>
<p>but is this expected behavior</p>

<a name="169104756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169104756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169104756">Mario Carneiro (Jun 27 2019 at 05:17)</a>:</h4>
<p>yes, this is unfortunate but unavoidable</p>

<a name="169104762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169104762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169104762">Mario Carneiro (Jun 27 2019 at 05:17)</a>:</h4>
<p>You can try importing everything if you want the searches to have good results, but that can take a lot of memory</p>

<a name="169105034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169105034" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169105034">Scott Viteri (Jun 27 2019 at 05:24)</a>:</h4>
<p>ok</p>

<a name="169105368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169105368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169105368">Scott Viteri (Jun 27 2019 at 05:33)</a>:</h4>
<p>Thanks for the help!</p>

<a name="169108348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108348">Scott Viteri (Jun 27 2019 at 06:47)</a>:</h4>
<p>Where can I find documentation for a tactic such as apply_assumption?</p>

<a name="169108453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108453">Kevin Buzzard (Jun 27 2019 at 06:49)</a>:</h4>
<p>Not at a computer right now but there's a big file in <code>docs</code> in mathlib which contains information about most tactics. Is it <code>docs/tactics.md</code> or something?</p>

<a name="169108546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108546">Scott Viteri (Jun 27 2019 at 06:51)</a>:</h4>
<p>This is useful for mathlib, thanks</p>

<a name="169108599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108599" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108599">Scott Viteri (Jun 27 2019 at 06:52)</a>:</h4>
<p>but apply_assumption is in core.lean</p>

<a name="169108603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108603">Scott Morrison (Jun 27 2019 at 06:52)</a>:</h4>
<p>You can also just type <code>apply_assumption</code> inside a <code>begin ... end</code> block, and hover the mouse over it. The tooltip that pops up should contain the doc-comment, which is usually just a slightly abbreviated version of the documentation in <code>docs/tactics.md</code>.</p>

<a name="169108617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108617">Scott Morrison (Jun 27 2019 at 06:52)</a>:</h4>
<p>Read the definition, then. :-)</p>

<a name="169108635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108635" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108635">Scott Morrison (Jun 27 2019 at 06:52)</a>:</h4>
<p>Put your cursor in <code>apply_assumption</code>, and hit F12 to jump to the definition.</p>

<a name="169108651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108651" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108651">Scott Morrison (Jun 27 2019 at 06:53)</a>:</h4>
<p>The community branch of Lean would probably accept PRs adding doc comments to any/all of these core tactics! :-)</p>

<a name="169108668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108668">Scott Morrison (Jun 27 2019 at 06:53)</a>:</h4>
<p>(Remember here that core Lean is frozen while development of Lean 4 takes place, so the community branch, which is only just getting off the ground now, is the only place we can improve the documentation of core stuff.)</p>

<a name="169108740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108740" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108740">Scott Viteri (Jun 27 2019 at 06:54)</a>:</h4>
<p>I take back what I said -- apply assumption is in mathlib/src/tactic/core.lean</p>

<a name="169108767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108767">Scott Viteri (Jun 27 2019 at 06:55)</a>:</h4>
<p>so why doesn't docs/tactics.md mention it?</p>

<a name="169108828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108828">Scott Morrison (Jun 27 2019 at 06:56)</a>:</h4>
<p>Sorry about the confusing naming. <code>src/tactic/core.lean</code> is really basic tooling stuff (mostly not used interactively). <code>src/tactic/basic.lean</code> is all the most common interactive tactics, and <code>src/tactic/default.lean</code> is the kitchen sink, importing nearly all the mathlib defined tactics.</p>

<a name="169108842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108842" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108842">Scott Morrison (Jun 27 2019 at 06:57)</a>:</h4>
<p>Probably because <code>apply_assumption</code> has been around a long time, perhaps predating <code>docs/tactics.md</code>? I'm not sure. Comment PR definitely accepted. :-)</p>

<a name="169108941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108941">Scott Viteri (Jun 27 2019 at 06:59)</a>:</h4>
<p>Where does the tooltip come from?</p>

<a name="169108992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108992" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108992">Scott Viteri (Jun 27 2019 at 07:00)</a>:</h4>
<p>Because I do get a short description this way</p>

<a name="169108995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108995">Scott Morrison (Jun 27 2019 at 07:00)</a>:</h4>
<p>The doc-comment.</p>

<a name="169108998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169108998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169108998">Scott Morrison (Jun 27 2019 at 07:00)</a>:</h4>
<p>When you make a definition, you can put a comment before it</p>

<a name="169109008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109008">Scott Morrison (Jun 27 2019 at 07:00)</a>:</h4>
<p>using the <code>/-- ... -/</code> syntax (note the double hyphen at the open comment)</p>

<a name="169109015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109015">Scott Viteri (Jun 27 2019 at 07:00)</a>:</h4>
<p>But the definition of apply_assumption has no such comment above it</p>

<a name="169109016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109016">Scott Morrison (Jun 27 2019 at 07:00)</a>:</h4>
<p>Hmm.</p>

<a name="169109038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109038">Scott Morrison (Jun 27 2019 at 07:01)</a>:</h4>
<p>Mine does?</p>

<a name="169109040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109040">Scott Viteri (Jun 27 2019 at 07:01)</a>:</h4>
<p>There are two apply_assumption s</p>

<a name="169109046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109046">Scott Viteri (Jun 27 2019 at 07:01)</a>:</h4>
<p>The one in solve_by_elim.lean has the comment</p>

<a name="169109047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109047">Scott Morrison (Jun 27 2019 at 07:01)</a>:</h4>
<p>When I hit F12 on apply_assumption, I was taken to the one in <code>solve_by_elim.lean</code>.</p>

<a name="169109072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109072">Scott Morrison (Jun 27 2019 at 07:02)</a>:</h4>
<p>Ah!</p>

<a name="169109092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109092">Scott Morrison (Jun 27 2019 at 07:02)</a>:</h4>
<p>There are very often two versions of a given tactic.</p>

<a name="169109099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109099">Scott Morrison (Jun 27 2019 at 07:02)</a>:</h4>
<p>One in the <code>tactic.interactive</code> namespace, and one in the <code>tactic</code> namespace.</p>

<a name="169109108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109108">Scott Viteri (Jun 27 2019 at 07:02)</a>:</h4>
<p>Do you often have to be careful which version of a tactic you are importing?</p>

<a name="169109110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109110">Scott Morrison (Jun 27 2019 at 07:02)</a>:</h4>
<p>The interactive one is accessible in <code>begin ... end</code> blocks, and very often does some parsing tricks so you can conveniently control it</p>

<a name="169109118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109118">Scott Morrison (Jun 27 2019 at 07:03)</a>:</h4>
<p>and non-interactive one is usually not intended for use in <code>begin ... end</code> blocks, but instead by other people writing tactics.</p>

<a name="169109121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109121" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109121">Scott Viteri (Jun 27 2019 at 07:03)</a>:</h4>
<p>ok</p>

<a name="169109122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109122">Scott Morrison (Jun 27 2019 at 07:03)</a>:</h4>
<p>Unless you know what you're doing, typically always use the interactive version.</p>

<a name="169109300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109300" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109300">Scott Viteri (Jun 27 2019 at 07:07)</a>:</h4>
<p>This did solve my original question though -- the documentation is (besides the tactics.md) in the comment above the definition. I just didn't see this because I was looking at the wrong version of the definition</p>

<a name="169109602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109602">Scott Viteri (Jun 27 2019 at 07:13)</a>:</h4>
<p>is leanprover-community/lean much different from the original?</p>

<a name="169109866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109866">Scott Morrison (Jun 27 2019 at 07:18)</a>:</h4>
<p>I don't think so. Simon Hudon is the one to ask.</p>

<a name="169109930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109930">Scott Viteri (Jun 27 2019 at 07:20)</a>:</h4>
<p>ok</p>

<a name="169109962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169109962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169109962">Kevin Buzzard (Jun 27 2019 at 07:21)</a>:</h4>
<p>It's not different enough from the original Lean to have ever made me contemplate switching.</p>

<a name="169110798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169110798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169110798">Mario Carneiro (Jun 27 2019 at 07:37)</a>:</h4>
<p>right now it's just accumulating bugfixes and little things</p>

<a name="169110806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169110806" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169110806">Mario Carneiro (Jun 27 2019 at 07:37)</a>:</h4>
<p>we'll let you know when it's ready for prime time</p>

<a name="169115569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169115569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169115569">Jesse Michael Han (Jun 27 2019 at 08:54)</a>:</h4>
<p><code>helm</code> often gives me the same error. i find it usually works again after <code>C-c C-r</code></p>

<a name="169221322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169221322" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169221322">Kevin Kappelmann (Jun 28 2019 at 12:45)</a>:</h4>
<p>What's the recommended way to use zeta-reduction at a hypothesis? E.g. going from <code>hyp : let n : ℕ := 2 in 1 + 1 = n</code> to <code>hyp : 1 + 1 = 2</code>? I know that <code>delta at hyp</code> works, but isn't this strictly speaking a zeta-reduction I am performing?<br>
edit: fix typo</p>

<a name="169221405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169221405" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169221405">Kevin Buzzard (Jun 28 2019 at 12:46)</a>:</h4>
<p>These are definitionally equal I guess, so you can just use <code>change</code>.</p>

<a name="169221483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169221483" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169221483">Kevin Kappelmann (Jun 28 2019 at 12:48)</a>:</h4>
<p>yep, sorry for the typo. I do not want to re-state the unfolded hypothesis though.</p>

<a name="169227770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169227770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169227770">Wojciech Nawrocki (Jun 28 2019 at 14:11)</a>:</h4>
<p>Why do additive monoids have scalar multiplication defined in terms of exponentiation? I found this really surprising:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">add_monoid</span><span class="bp">.</span><span class="n">smul</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">@</span><span class="n">monoid</span><span class="bp">.</span><span class="n">pow</span> <span class="o">(</span><span class="n">multiplicative</span> <span class="n">α</span><span class="o">)</span> <span class="bp">_</span> <span class="n">a</span> <span class="n">n</span>
</pre></div>

<a name="169228296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169228296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169228296">Kevin Buzzard (Jun 28 2019 at 14:17)</a>:</h4>
<p><code>multiplicative alpha</code> means "I know it's addition, but pretend it's multiplication". It's some sort of attempt to not duplicate effort.</p>

<a name="169228427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169228427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169228427">Kevin Buzzard (Jun 28 2019 at 14:18)</a>:</h4>
<p>a monoid and an additive monoid are the same, but Lean is less good than mathematicans at dealing with things like this. At least in this situation we have some automation to use.</p>

<a name="169228647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/169228647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#169228647">Wojciech Nawrocki (Jun 28 2019 at 14:20)</a>:</h4>
<p>That makes sense, but even when the monoid operation is interpreted as multiplication, is it conventional to call <code>pow</code> scalar multiplication? To me, <code>smul</code> seems to only make sense with vector spaces/modules.</p>

<a name="170529869"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170529869" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170529869">Wojciech Nawrocki (Jul 10 2019 at 10:33)</a>:</h4>
<p>Does anyone know why the strictness of when names are resolved is kind of flipped between quoted names and expressions (assuming I understand it correctly)? By this I mean that using <code> `my.name</code> the name is not resolved when parsing the tactic, while with <code> ``my.name</code> it is, so more backticks =&gt; resolve sooner. But with expressions, it's the opposite - with <code> `(expr)</code>, symbols are resolved at parse time, with <code> ``(expr)</code> partially so, and with <code> ```(expr)</code> resolving symbols is deferred to tactic runtime. EDIT: fixed backticks, thanks Johan!</p>

<a name="170530201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170530201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170530201">Johan Commelin (Jul 10 2019 at 10:39)</a>:</h4>
<p>On Zulip formatting: Use <code> more ```backticks ``to `surround ```the code</code> then the number of <code> `adjacent </code> backticks in the code.</p>

<a name="170536732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170536732" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170536732">Kevin Buzzard (Jul 10 2019 at 12:30)</a>:</h4>
<p>And use the "quote and reply" option to see exactly what Johan did :-)</p>

<a name="170555769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170555769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170555769">Scott Viteri (Jul 10 2019 at 16:21)</a>:</h4>
<p>Does the syntax</p>
<div class="codehilite"><pre><span></span>theorem perm_sort : forall l, sort l ~ l
| [] := refl
| (a::l) := ...
</pre></div>


<p>not give inductive hypotheses?</p>

<a name="170555863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170555863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170555863">Scott Viteri (Jul 10 2019 at 16:22)</a>:</h4>
<p>Right now in the second block I have proven<br>
<code>sort l ~ l</code>, and could really use a forall</p>

<a name="170556168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170556168" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170556168">Mario Carneiro (Jul 10 2019 at 16:26)</a>:</h4>
<p>use <code>perm_sort l</code> in the second block to access the IH</p>

<a name="170556269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170556269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170556269">Scott Viteri (Jul 10 2019 at 16:27)</a>:</h4>
<p>oh ok</p>

<a name="170556294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170556294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170556294">Scott Viteri (Jul 10 2019 at 16:28)</a>:</h4>
<p>Thanks</p>

<a name="170559007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170559007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170559007">Scott Viteri (Jul 10 2019 at 17:00)</a>:</h4>
<p>How do I specify which instance of a definition rw unfolds?</p>

<a name="170559042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170559042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170559042">Scott Viteri (Jul 10 2019 at 17:01)</a>:</h4>
<p>suppose I have the goal <code>rev (rev (h :: t)) = h :: t</code></p>

<a name="170559131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170559131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170559131">Scott Viteri (Jul 10 2019 at 17:02)</a>:</h4>
<p><code>rw rev</code> results in <code>rev_aux (rev (h :: t)) nil = h :: t</code></p>

<a name="170559181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170559181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170559181">Scott Viteri (Jul 10 2019 at 17:02)</a>:</h4>
<p>But I want rw to act on the inner instance of rev</p>

<a name="170559510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170559510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170559510">Scott Viteri (Jul 10 2019 at 17:06)</a>:</h4>
<p>I just found change, which seems to do the trick</p>

<a name="170561134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170561134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170561134">Jesse Michael Han (Jul 10 2019 at 17:25)</a>:</h4>
<p><code>change</code> will work if the rewrite is definitional, otherwise you can try <code>convert_to</code> which will let you supply the equality proof obligation after</p>
<p><code>conv {}</code> will let you navigate inside an expression and surgically rewrite</p>

<a name="170588333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170588333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170588333">Marc Huisinga (Jul 10 2019 at 23:16)</a>:</h4>
<p>is there a neat way to only generalize a specific variable?</p>

<a name="170588672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170588672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170588672">Yury G. Kudryashov (Jul 10 2019 at 23:22)</a>:</h4>
<p>Hi, what is the meaning of <code>@@</code>?</p>

<a name="170589627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170589627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170589627">Kevin Buzzard (Jul 10 2019 at 23:39)</a>:</h4>
<blockquote>
<p>is there a neat way to only generalize a specific variable?</p>
</blockquote>
<p>Does the dosctring for <code>generalize</code> answer your question?</p>

<a name="170589832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170589832" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170589832">Kevin Buzzard (Jul 10 2019 at 23:42)</a>:</h4>
<blockquote>
<p>Hi, what is the meaning of <code>@@</code>?</p>
</blockquote>
<p>It's explained <a href="https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#using-the-library" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#using-the-library">just above here</a> in TPIL. Searching for @@ didn't work for me but I knew it was in there.</p>

<a name="170589849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170589849" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170589849">Marc Huisinga (Jul 10 2019 at 23:43)</a>:</h4>
<p>i don't think so - i should have been more clear, sorry! i'm looking for a neat way to generalize a specific occurence of a variable, not all of them</p>

<a name="170591589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170591589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170591589">Marc Huisinga (Jul 11 2019 at 00:17)</a>:</h4>
<p>oh, i guess something along the lines of</p>
<div class="codehilite"><pre><span></span>lemma foo {α : Type*} (P : α → α → Prop) (a : α) : P a a :=
begin
  have h : ∀ b : α, P b a, sorry,
  exact h a
end
</pre></div>


<p>will do</p>

<a name="170591804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170591804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170591804">Yury G. Kudryashov (Jul 11 2019 at 00:20)</a>:</h4>
<p>Is it possible to redefine the "default constructor"? I mean, the one used by <code>⟨⟩</code> notation.</p>

<a name="170592009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170592009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170592009">Marc Huisinga (Jul 11 2019 at 00:25)</a>:</h4>
<p>afaik you can only use that notation if there is only one constructor</p>

<a name="170594239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170594239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170594239">Kevin Buzzard (Jul 11 2019 at 01:18)</a>:</h4>
<p>You can make a second structure with the constructor you like and then define a map to the first structure. If they were classes you could do this with type class inference I guess (on a good day with a following wind)</p>

<a name="170594314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170594314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170594314">Kevin Buzzard (Jul 11 2019 at 01:20)</a>:</h4>
<p>You want more than</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">foo</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">a</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">suffices</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">P</span> <span class="n">b</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>?</p>

<a name="170594353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170594353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170594353">Kevin Buzzard (Jul 11 2019 at 01:21)</a>:</h4>
<p>I am struggling a bit to imagine the syntax of what some super-precise <code>generalize</code> tactic would look like but I understand your question now (and don't know the answer)</p>

<a name="170613330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170613330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170613330">Marc Huisinga (Jul 11 2019 at 08:36)</a>:</h4>
<p>ah, suffices is a neat syntax, i forgot about that one.<br>
it turns out that for my specific use case, simply a precise generalize wouldn't do. i also needed additional assumptions about <code>b</code> (in my use-case, <code>α</code> was <code>list foo</code> and i additionally needed <code>b ⊆ a</code> to prove my lemma).<br>
it probably isn't a good idea to have tactics for use cases this concrete, and "suffices" is certainly readable enough.</p>

<a name="170631545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170631545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170631545">Wojciech Nawrocki (Jul 11 2019 at 13:17)</a>:</h4>
<p>What's the convention for defining stuff on structures that can be both mul-based and add-based, e.g. <code>semigroup</code>/<code>add_semigroup</code>? Should I define it on <code>semigroup</code> and then somehow transport to <code>add_semigroup</code> using <code>additive</code>, the other way around, or something else?</p>

<a name="170631945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170631945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170631945">Chris Hughes (Jul 11 2019 at 13:22)</a>:</h4>
<p>Define it on semigroup and transfer with <code>to_additive</code>.</p>

<a name="170632152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170632152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170632152">Wojciech Nawrocki (Jul 11 2019 at 13:25)</a>:</h4>
<p>Thanks Chris!</p>

<a name="170636720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170636720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170636720">Kevin Buzzard (Jul 11 2019 at 14:15)</a>:</h4>
<p>See <code>group_theory/quotient_group.lean</code> for an example of how this looks.</p>

<a name="170791958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170791958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170791958">Wojciech Nawrocki (Jul 13 2019 at 14:29)</a>:</h4>
<p>Can the equational lemmas for a function do something more than definitional/beta-reduction? I have a goal of the form (simplified) <code>fn1 (fn2 some_expr) = fn1 (fn2 other_expr)</code>, s.t. <code>fn1 \comp fn2</code> takes both <code>expr</code>s to the same value (and the <code>expr</code>s contain some more calls to <code>fn1/2</code>). So, this should follow from <code>refl</code>, but it doesn't. If however I do <code>repeat { rw [fn1] }, repeat { rw [fn2] }</code> first, <code>refl</code> works.</p>

<a name="170793953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170793953" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170793953">Wojciech Nawrocki (Jul 13 2019 at 15:26)</a>:</h4>
<p>A related question - is there a tactic equivalent of <code>#reduce</code>?</p>

<a name="170796103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170796103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170796103">Kevin Buzzard (Jul 13 2019 at 16:23)</a>:</h4>
<p>The equation lemmas for a function are not always definitionally true</p>

<a name="170796153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170796153" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170796153">Kevin Buzzard (Jul 13 2019 at 16:24)</a>:</h4>
<p>They're simp lemmas though so <code>simp</code> might work</p>

<a name="170798201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170798201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170798201">Wojciech Nawrocki (Jul 13 2019 at 17:23)</a>:</h4>
<p>Huh okay, that is kind of surprising - I thought they were all <code>refl</code>.  Thanks!</p>

<a name="170801612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170801612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170801612">Mario Carneiro (Jul 13 2019 at 19:06)</a>:</h4>
<p>The main time when they are not <code>rfl</code> is when well founded recursion is used. This has to do with why definitional equality is undecidable and lean's defeq is an underapproximation of the real thing</p>

<a name="170802186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170802186" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170802186">Wojciech Nawrocki (Jul 13 2019 at 19:23)</a>:</h4>
<p>Oooh yeah it is recursive - it's transitivity that's missing, right? It seemed to me like it should still reduce but is what you're saying that the <code>has_well_founded</code>s prevent it from reducing?</p>

<a name="170802295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170802295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170802295">Wojciech Nawrocki (Jul 13 2019 at 19:26)</a>:</h4>
<p>I came across this while trying to write some reflection tactics a la <code>ring2</code>, where in <code>correctness</code> you have <code>(H : horner_expr.of_csexpr r₁ = horner_expr.of_csexpr r₂)</code> by <code>rfl</code>. <code>of_csexpr</code> is defined recursively but it seems to reduce just fine, however I have something more like <code>(of_csexpr r1).eval = (of_csexpr r2).eval</code>, where <code>eval</code> is also recursive and this breaks (needs <code>simp; refl</code>).</p>

<a name="170802304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170802304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170802304">Wojciech Nawrocki (Jul 13 2019 at 19:26)</a>:</h4>
<p>I can get rid of the <code>eval</code>s so this isn't really a problem, just confusing.</p>

<a name="170802428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170802428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170802428">Mario Carneiro (Jul 13 2019 at 19:30)</a>:</h4>
<p>Structural recursion is fine, it's just when you use well founded recursion, i.e. recursion on <code>acc</code> that it gets flaky</p>

<a name="170802625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170802625" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170802625">Wojciech Nawrocki (Jul 13 2019 at 19:37)</a>:</h4>
<p>I see, I'm doing some reassociation which I think has to rely on <code>sizeof</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">reassoc</span><span class="o">:</span> <span class="n">Expr</span> <span class="bp">-&gt;</span> <span class="n">Expr</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">Mul</span> <span class="o">(</span><span class="n">Mul</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Mul</span> <span class="o">(</span><span class="n">reassoc</span> <span class="n">a</span><span class="o">)</span> <span class="err">$</span> <span class="n">reassoc</span> <span class="o">(</span><span class="n">Mul</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">e</span>
</pre></div>

<a name="170802986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170802986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170802986">Mario Carneiro (Jul 13 2019 at 19:49)</a>:</h4>
<p>Right, that's not a structural recursion, but you can rewrite it to be one</p>

<a name="170803351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/170803351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#170803351">Wojciech Nawrocki (Jul 13 2019 at 20:00)</a>:</h4>
<p>Yup, <code>refl</code>s now, thanks!</p>

<a name="171300969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/171300969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#171300969">Wojciech Nawrocki (Jul 19 2019 at 23:32)</a>:</h4>
<p>Is this assumption correct: "after compiling <code>somefile.lean</code> with <code>lean --make</code>, forall theorems in <code>somefile</code>, the resulting <code>somefile.olean</code> contains the theorems' names and types, but because they are in <code>Prop</code> and have already been typechecked, the proof terms are discarded and Lean trusts previously built modules to have correctly-typechecked definitions"?</p>

<a name="171301875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/171301875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#171301875">Wojciech Nawrocki (Jul 19 2019 at 23:54)</a>:</h4>
<p>Okay, it's partly correct and partly not. Lean keeps the proof terms (i.e. the "values" of <code>theorem</code> definitions) in <code>.olean</code> files, but they're stored with a high "trust level" value, and I <em>think</em> that when a such a high-trust definition is imported, its value is <a href="https://github.com/leanprover-community/lean/blob/master/src/kernel/inductive/inductive.h#L93" target="_blank" title="https://github.com/leanprover-community/lean/blob/master/src/kernel/inductive/inductive.h#L93">not typechecked again</a> and the type is trusted.</p>

<a name="171354736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/171354736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#171354736">Yury G. Kudryashov (Jul 21 2019 at 04:08)</a>:</h4>
<p>From <code>lean --help</code>:</p>
<div class="codehilite"><pre><span></span>  --trust=num -t     trust level (default: max) 0 means do not trust any macro,
                     and type check all imported modules
</pre></div>

<a name="171354746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/171354746" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#171354746">Yury G. Kudryashov (Jul 21 2019 at 04:09)</a>:</h4>
<p>I think, by default Lean trusts that all <code>import</code>ed <code>.olean</code> files are correct but you can tell it to double-check them.</p>

<a name="171445739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/171445739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#171445739">Lennard Henze (Jul 22 2019 at 16:32)</a>:</h4>
<p>Trying one of the excercises I am stuck with deriving A \or \not A:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">A</span> <span class="bp">↔</span> <span class="bp">¬</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">h₂</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">A</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">h₁</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">↔</span> <span class="bp">¬</span> <span class="n">A</span><span class="o">),</span>
<span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h₂</span>
        <span class="o">(</span><span class="k">assume</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span>
           <span class="k">have</span> <span class="n">h₃</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">A</span><span class="o">,</span> <span class="k">from</span> <span class="n">iff</span><span class="bp">.</span><span class="n">mp</span> <span class="n">h₁</span> <span class="n">this</span><span class="o">,</span>
            <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">h₃</span> <span class="n">this</span><span class="o">)</span>
        <span class="o">(</span><span class="k">assume</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">A</span><span class="o">,</span>
            <span class="k">have</span> <span class="n">h₃</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="k">from</span> <span class="n">iff</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">h₁</span> <span class="n">this</span><span class="o">,</span>
            <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">this</span> <span class="n">h₃</span><span class="o">)</span>
</pre></div>


<p>Can someone point me in the right direction?</p>

<a name="171446160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/171446160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#171446160">Kevin Buzzard (Jul 22 2019 at 16:38)</a>:</h4>
<p>This is just the law of the excluded middle, which is not true in constructive logic</p>

<a name="171446179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/171446179" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#171446179">Kevin Buzzard (Jul 22 2019 at 16:38)</a>:</h4>
<p>Are you allowed to use classical logic?</p>

<a name="171446189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/171446189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#171446189">Wojciech Nawrocki (Jul 22 2019 at 16:38)</a>:</h4>
<p>(See also <a href="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle">TPIL 11.6</a>)</p>

<a name="171446223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/171446223" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#171446223">Kevin Buzzard (Jul 22 2019 at 16:39)</a>:</h4>
<p>It can be done constructively I believe (but don't trust me, I am a classical guy)</p>

<a name="171446301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/171446301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#171446301">Kevin Buzzard (Jul 22 2019 at 16:40)</a>:</h4>
<p>It's something like <code>classical.em</code>, what you want</p>

<a name="171446380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/171446380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#171446380">Lennard Henze (Jul 22 2019 at 16:41)</a>:</h4>
<p>its just a task from <a href="https://leanprover.github.io/logic_and_proof/propositional_logic_in_lean.html" target="_blank" title="https://leanprover.github.io/logic_and_proof/propositional_logic_in_lean.html">https://leanprover.github.io/logic_and_proof/propositional_logic_in_lean.html</a>, i have not read anything about classical logic being forbidden</p>

<a name="171446438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/171446438" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#171446438">Kenny Lau (Jul 22 2019 at 16:42)</a>:</h4>
<p>lol</p>

<a name="171446510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/171446510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#171446510">Lennard Henze (Jul 22 2019 at 16:43)</a>:</h4>
<p>i think it is meant to be done without imports</p>

<a name="171447029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/171447029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#171447029">Wojciech Nawrocki (Jul 22 2019 at 16:49)</a>:</h4>
<p>Here is a constructive proof, adapted from <code>iff_not_self</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">A</span> <span class="bp">↔</span> <span class="bp">¬</span> <span class="n">A</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">:</span> <span class="n">A</span> <span class="bp">↔</span> <span class="bp">¬</span> <span class="n">A</span><span class="o">,</span>
<span class="k">have</span> <span class="n">hna</span><span class="o">:</span> <span class="bp">¬</span><span class="n">A</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span>
  <span class="k">assume</span> <span class="n">ha</span><span class="o">:</span> <span class="n">A</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="n">mp</span> <span class="n">ha</span><span class="o">)</span> <span class="n">ha</span><span class="o">),</span>
<span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">hna</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">hna</span><span class="o">)</span>
</pre></div>

<a name="171447327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/171447327" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#171447327">Lennard Henze (Jul 22 2019 at 16:53)</a>:</h4>
<p>nice thanks!!</p>

<a name="172516901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172516901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172516901">Gihan Marasingha (Aug 05 2019 at 16:19)</a>:</h4>
<p>Is there an escape sequence for producing french quotes in the web editor / VS Code? More generally, is there a comprehensive list of escape sequences? Ta.</p>

<a name="172516943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172516943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172516943">Kevin Buzzard (Aug 05 2019 at 16:19)</a>:</h4>
<p>Hey Gihan!</p>

<a name="172516955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172516955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172516955">Kevin Buzzard (Aug 05 2019 at 16:19)</a>:</h4>
<p>It's in some translations.json file somewhere, hang on...</p>

<a name="172517073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172517073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172517073">Kevin Buzzard (Aug 05 2019 at 16:20)</a>:</h4>
<p><a href="https://github.com/leanprover/vscode-lean/blob/master/translations.json" target="_blank" title="https://github.com/leanprover/vscode-lean/blob/master/translations.json">https://github.com/leanprover/vscode-lean/blob/master/translations.json</a></p>

<a name="172517113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172517113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172517113">Gihan Marasingha (Aug 05 2019 at 16:21)</a>:</h4>
<p>Thanks very much Kevin!</p>
<p>I see you're teaching M1F to a virtual tutee. Have you had success teaching Lean to corporeal M1F students?</p>

<a name="172517185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172517185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172517185">Kevin Buzzard (Aug 05 2019 at 16:22)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> and <span class="user-mention" data-user-id="110044">@Chris Hughes</span> are both Imperial undergraduates who have contributed far more than me to Lean's maths library.</p>

<a name="172517252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172517252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172517252">Kevin Buzzard (Aug 05 2019 at 16:23)</a>:</h4>
<p><code>\f&lt;</code> and <code>\f&gt;</code> apparently</p>

<a name="172517261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172517261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172517261">Kevin Buzzard (Aug 05 2019 at 16:23)</a>:</h4>
<p>I don't usually use them</p>

<a name="172517315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172517315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172517315">Gihan Marasingha (Aug 05 2019 at 16:24)</a>:</h4>
<p>Amazing! I'm tempted to try this at Exeter, but I'm worried that formal proof may put off the bulk of students.</p>

<a name="172517402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172517402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172517402">Kevin Buzzard (Aug 05 2019 at 16:25)</a>:</h4>
<p>I have a lot of tips. If you do it naively then definitely you can put a lot of people off. One initial tip is not to teach people new maths and Lean at the same time.</p>

<a name="172517410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172517410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172517410">Kevin Buzzard (Aug 05 2019 at 16:25)</a>:</h4>
<p>by "people" I mean "UG mathematicians"</p>

<a name="172517475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172517475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172517475">Kevin Buzzard (Aug 05 2019 at 16:26)</a>:</h4>
<p>so if it's your job to teach them new maths then it can get quite tricky finding the balance.</p>

<a name="172517542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172517542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172517542">Kevin Buzzard (Aug 05 2019 at 16:27)</a>:</h4>
<p>I'm speaking in Exeter at the end of Nov, we can maybe talk then. Unfortunately I'm giving the number theory seminar rather than a general colloquium.</p>

<a name="172517890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172517890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172517890">Gihan Marasingha (Aug 05 2019 at 16:32)</a>:</h4>
<p>OK, that would be great. I look forward to it.</p>
<p>My main issue really is how to teach proof tout court. Most written arguments I see from new students are full of non sequiturs. I thought Lean might be a way for students to determine whether their arguments were valid.</p>

<a name="172517919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172517919" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172517919">Kevin Buzzard (Aug 05 2019 at 16:32)</a>:</h4>
<p>This was one of the reasons I got interested in Lean too.</p>

<a name="172517949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172517949" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172517949">Kevin Buzzard (Aug 05 2019 at 16:33)</a>:</h4>
<p>I'm sure this sort of software has got a lot of potential to change the way undergraduate mathematics is taught.</p>

<a name="172517975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172517975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172517975">Kevin Buzzard (Aug 05 2019 at 16:33)</a>:</h4>
<p>But I'm still very much experimenting with how to do it. Patrick Massot also tried</p>

<a name="172518027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172518027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172518027">Kevin Buzzard (Aug 05 2019 at 16:34)</a>:</h4>
<p>using Lean with a bunch of UGs at Orsay in their introduction to proof course</p>

<a name="172518197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172518197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172518197">Gihan Marasingha (Aug 05 2019 at 16:36)</a>:</h4>
<p>Thanks. I've also seen Jeremy Avigad's 'Logic and Proof' notes.</p>

<a name="172518228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172518228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172518228">Kevin Buzzard (Aug 05 2019 at 16:37)</a>:</h4>
<p>Yeah, we're all trying to change the world.</p>

<a name="172518255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172518255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172518255">Kevin Buzzard (Aug 05 2019 at 16:37)</a>:</h4>
<p>An education specialist is writing a paper about my intervention, should be ready next month apparently.</p>

<a name="172518317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172518317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172518317">Kevin Buzzard (Aug 05 2019 at 16:38)</a>:</h4>
<p>She interviewed lots of M1F students</p>

<a name="172518479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172518479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172518479">Gihan Marasingha (Aug 05 2019 at 16:40)</a>:</h4>
<p>I'd be interested in reading the article. Where will it be published?</p>

<a name="172518511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172518511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172518511">Kevin Buzzard (Aug 05 2019 at 16:40)</a>:</h4>
<p>Don't know, I guess they will have some education journal ecosystem but I don't know anything about it.</p>

<a name="172518666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172518666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172518666">Gihan Marasingha (Aug 05 2019 at 16:43)</a>:</h4>
<p>Well, maybe I'll find out in November. See you then and thanks for the information.</p>

<a name="172532018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172532018" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172532018">Floris van Doorn (Aug 05 2019 at 19:44)</a>:</h4>
<p><span class="user-mention" data-user-id="233737">@Gihan Marasingha</span>: If you see a character in VSCode, and you are wondering how to input it, you can also hover your mouse over the character, and in a pop-up it will tell you how to type it.</p>

<a name="172541913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/172541913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#172541913">Gihan Marasingha (Aug 05 2019 at 21:56)</a>:</h4>
<p>Thanks!</p>

<a name="173242232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/173242232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#173242232">Kevin Kappelmann (Aug 14 2019 at 21:02)</a>:</h4>
<p>Question related to proof irrelevance: I was wondering what Lean is doing in this example:</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">test</span> <span class="o">:=</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">pos</span><span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">t1</span> <span class="n">t2</span> <span class="o">:</span> <span class="n">test</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">t1</span><span class="bp">.</span><span class="n">n</span> <span class="bp">=</span> <span class="n">t2</span><span class="bp">.</span><span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">t1</span> <span class="bp">=</span> <span class="n">t2</span>  <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">t1</span> <span class="k">with</span> <span class="n">n1</span> <span class="n">pos1</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">t2</span> <span class="k">with</span> <span class="n">n2</span> <span class="n">pos2</span><span class="o">,</span> <span class="c1">-- current goal : {n := n1, pos := pos1} = {n := n2, pos := pos2}</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="n">n1</span> <span class="bp">=</span> <span class="n">n2</span><span class="o">,</span> <span class="k">by</span> <span class="n">simpa</span> <span class="n">only</span> <span class="o">[],</span> <span class="c1">-- current goal : n1 = n2, but why?</span>
  <span class="n">exact</span> <span class="n">h</span>
<span class="kn">end</span>
</pre></div>


<p>Is simp matching the parts of the structure that live in Prop and decides that we need <code>n1 = n2</code>? How is it deciding that? Just by unification? (PS. I know that Lean auto-generates <code>test.mk.inj_eq</code>)</p>

<a name="173244750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/173244750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#173244750">Floris van Doorn (Aug 14 2019 at 21:37)</a>:</h4>
<p>Yeah, probably these <code>mk.inj_eq</code> lemmas are hard-coded to be simp lemmas, even when doing <code>simp only</code>.</p>

<a name="173245868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/173245868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#173245868">Rob Lewis (Aug 14 2019 at 21:53)</a>:</h4>
<p>The simp option <code>constructor_eq := ff</code> disables this behavior.</p>

<a name="174794053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/174794053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#174794053">Kevin Kappelmann (Sep 03 2019 at 14:32)</a>:</h4>
<p>Given a function <code>f</code> taking arguments from a set <code>S : set ℕ</code>, a number <code>n : ℕ</code>, and the knowledge that <code>n ∈ S</code>, how can I apply <code>f</code> on <code>n</code>, that is, how do I make this work:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hyp</span> <span class="o">:</span> <span class="n">n</span> <span class="err">∈</span> <span class="n">S</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">n</span> <span class="c1">-- type mismatch</span>
</pre></div>

<a name="174794427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/174794427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#174794427">Chris Hughes (Sep 03 2019 at 14:36)</a>:</h4>
<p><code>f ⟨n, hyp⟩</code></p>

<a name="174794552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/174794552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#174794552">Kevin Kappelmann (Sep 03 2019 at 14:37)</a>:</h4>
<p>Ahh, right! Thanks - you're the best!</p>

<a name="174794976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/174794976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#174794976">Patrick Massot (Sep 03 2019 at 14:42)</a>:</h4>
<p>Maybe the piece you missed is that Lean can make sense of <code>(f : S → ℕ)</code> only because it inserts a coercion of <code>S</code> to the subtype <code>{n : ℕ // n ∈ S}</code></p>

<a name="174796117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/174796117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#174796117">Kevin Kappelmann (Sep 03 2019 at 14:53)</a>:</h4>
<blockquote>
<p>Maybe the piece you missed is that Lean can make sense of <code>(f : S → ℕ)</code> only because it inserts a coercion of <code>S</code> to the subtype <code>{n : ℕ // n ∈ S}</code></p>
</blockquote>
<p>That was indeed the case :)</p>

<a name="175177305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175177305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175177305">Gihan Marasingha (Sep 08 2019 at 09:17)</a>:</h4>
<p>I tried proving a very simple result, the formula <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup><msup><mi>i</mi><mn>2</mn></msup><mo>=</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">6\sum_{i=0}^n i^2 = n(n+1)(2n+1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.113818em;vertical-align:-0.29971000000000003em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>. My Lean proof, using equational reasoning, is much longer than I anticipated (30 lines). Could someone suggest a way to shorten the proof?</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">ssquares_formula</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">6</span><span class="bp">*</span><span class="o">(</span><span class="n">ssquares</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span><span class="bp">*</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span>
<span class="n">rfl</span> <span class="c1">-- trivial base case</span>
<span class="o">(</span>
<span class="k">assume</span> <span class="n">k</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">h</span> <span class="o">:</span>  <span class="mi">6</span><span class="bp">*</span><span class="o">(</span><span class="n">ssquares</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span>
<span class="k">show</span> <span class="mi">6</span><span class="bp">*</span><span class="o">(</span><span class="n">ssquares</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">((</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="k">from</span>
<span class="k">calc</span>
<span class="mi">6</span><span class="bp">*</span><span class="o">(</span><span class="n">ssquares</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">6</span><span class="bp">*</span><span class="o">((</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">ssquares</span> <span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="mi">6</span><span class="bp">*</span><span class="o">((</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">+</span> <span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">left_distrib</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="mi">6</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span><span class="n">mul_assoc</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="mi">6</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mul_comm</span> <span class="mi">6</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="mi">6</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mul_comm</span> <span class="n">k</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">6</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">+</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">]</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">6</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">+</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span><span class="n">left_distrib</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">6</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">6</span><span class="bp">+</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">left_distrib</span> <span class="mi">6</span> <span class="n">k</span> <span class="mi">1</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">6</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">6</span><span class="bp">+</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">left_distrib</span> <span class="n">k</span> <span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span> <span class="mi">1</span><span class="o">,</span> <span class="n">mul_one</span><span class="o">]</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">((</span><span class="mi">3</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">6</span><span class="bp">+</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">6</span><span class="bp">+</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">right_distrib</span> <span class="mi">3</span> <span class="mi">3</span> <span class="n">k</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="o">(</span><span class="mi">6</span><span class="bp">+</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">))</span><span class="bp">+</span><span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">add_assoc</span><span class="o">,</span><span class="err">←</span><span class="n">add_assoc</span><span class="o">]</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">6</span><span class="o">)</span><span class="bp">+</span><span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">add_comm</span> <span class="mi">6</span> <span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">))</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="o">(</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">))</span><span class="bp">+</span><span class="mi">6</span><span class="bp">+</span><span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">add_assoc</span><span class="o">,</span><span class="err">←</span><span class="n">add_assoc</span><span class="o">]</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">6</span><span class="bp">+</span><span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">add_comm</span> <span class="o">(</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">))</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">((</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">))</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">6</span><span class="bp">+</span><span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">add_assoc</span><span class="o">,</span><span class="n">add_assoc</span><span class="o">]</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">((</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">6</span><span class="bp">+</span><span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">add_comm</span> <span class="o">(</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">))</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="o">(</span><span class="mi">6</span><span class="bp">+</span><span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">add_assoc</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">6</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">add_comm</span> <span class="mi">6</span> <span class="n">k</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="o">(</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">6</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">add_assoc</span><span class="o">,</span><span class="err">←</span><span class="n">add_assoc</span><span class="o">]</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="o">(</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="n">k</span><span class="bp">*</span><span class="mi">1</span><span class="o">)</span><span class="bp">+</span><span class="mi">6</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mul_one</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="o">(</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">6</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mul_comm</span> <span class="n">k</span> <span class="mi">1</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="o">((</span><span class="mi">3</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">6</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">right_distrib</span> <span class="mi">3</span> <span class="mi">1</span> <span class="n">k</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="o">((</span><span class="mi">2</span><span class="bp">*</span><span class="mi">2</span><span class="o">)</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">6</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">))</span><span class="bp">+</span><span class="mi">6</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mul_assoc</span> <span class="mi">2</span> <span class="mi">2</span> <span class="n">k</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">3</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">2</span><span class="bp">*</span><span class="mi">3</span><span class="o">))</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="n">k</span><span class="bp">*</span><span class="mi">3</span><span class="bp">+</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">2</span><span class="bp">*</span><span class="mi">3</span><span class="o">))</span>  <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mul_comm</span> <span class="mi">3</span> <span class="n">k</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="n">k</span><span class="bp">*</span><span class="mi">3</span><span class="bp">+</span><span class="mi">2</span><span class="bp">*</span><span class="o">((</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span><span class="bp">+</span><span class="mi">3</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span><span class="n">left_distrib</span> <span class="mi">2</span> <span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span> <span class="mi">3</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span><span class="bp">+</span><span class="mi">2</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">3</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">left_distrib</span> <span class="n">k</span> <span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">)</span> <span class="mi">3</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">((</span><span class="n">k</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">3</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span><span class="n">right_distrib</span> <span class="n">k</span> <span class="mi">2</span> <span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">3</span><span class="o">)</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">((</span><span class="n">k</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">2</span><span class="bp">*</span><span class="mi">1</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">((</span><span class="n">k</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span><span class="n">left_distrib</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">mul_assoc</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">((</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
<span class="o">)</span>
</pre></div>

<a name="175177408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175177408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175177408">Keeley Hoek (Sep 08 2019 at 09:20)</a>:</h4>
<p>What is your definition of <code>ssquares</code>?</p>

<a name="175177420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175177420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175177420">Gihan Marasingha (Sep 08 2019 at 09:21)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">ssquares</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">ssquares</span> <span class="n">n</span><span class="o">)</span>
</pre></div>

<a name="175177487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175177487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175177487">Keeley Hoek (Sep 08 2019 at 09:23)</a>:</h4>
<p>Let me introduce you to the <code>ring</code> tactic of <code>mathlib</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">def</span> <span class="n">ssquares</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">ssquares</span> <span class="n">n</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">ssquares_formula</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">6</span><span class="bp">*</span><span class="o">(</span><span class="n">ssquares</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span><span class="bp">*</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span>
<span class="n">rfl</span> <span class="c1">-- trivial base case</span>
<span class="err">$</span>
<span class="k">assume</span> <span class="n">k</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">h</span> <span class="o">:</span>  <span class="mi">6</span><span class="bp">*</span><span class="o">(</span><span class="n">ssquares</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span>
<span class="k">show</span> <span class="mi">6</span><span class="bp">*</span><span class="o">(</span><span class="n">ssquares</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">((</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="k">from</span>
<span class="k">calc</span>
<span class="mi">6</span><span class="bp">*</span><span class="o">(</span><span class="n">ssquares</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">6</span><span class="bp">*</span><span class="o">((</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">ssquares</span> <span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="mi">6</span><span class="bp">*</span><span class="o">((</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">+</span> <span class="n">k</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">left_distrib</span><span class="o">,</span> <span class="n">h</span><span class="o">]</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">((</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">*</span><span class="o">(</span><span class="mi">2</span><span class="bp">*</span><span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">ring</span>
</pre></div>

<a name="175177531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175177531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175177531">Keeley Hoek (Sep 08 2019 at 09:24)</a>:</h4>
<p>But really, <code>mathlib</code> has machinery for doing finite sums already, without starting from the beginning e.g. with your definition of <code>ssquares</code>. A place to start to look is in <code>data.finset</code>, for <code>finset.sum</code>.</p>

<a name="175177544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175177544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175177544">Gihan Marasingha (Sep 08 2019 at 09:25)</a>:</h4>
<p><span class="user-mention" data-user-id="110111">@Keeley Hoek</span> thanks so much.</p>

<a name="175177813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175177813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175177813">Keeley Hoek (Sep 08 2019 at 09:34)</a>:</h4>
<p><span class="user-mention" data-user-id="233737">@Gihan Marasingha</span> , here is also a way it could be done in tactic mode</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">def</span> <span class="n">ssquares</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">ssquares</span> <span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">ssquares_formula</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">6</span> <span class="bp">*</span> <span class="o">(</span><span class="n">ssquares</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">k</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">ssquares</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">left_distrib</span><span class="o">,</span> <span class="n">h</span><span class="o">],</span>
    <span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">k</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">),</span> <span class="c1">-- It is sad that this line is needed</span>
    <span class="n">ring</span><span class="o">,</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="175177814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175177814" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175177814">Keeley Hoek (Sep 08 2019 at 09:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, why is the commented line needed there? Is this a bug?</p>

<a name="175177865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175177865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175177865">Mario Carneiro (Sep 08 2019 at 09:37)</a>:</h4>
<p>Ring doesn't know about succ</p>

<a name="175177870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175177870" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175177870">Keeley Hoek (Sep 08 2019 at 09:37)</a>:</h4>
<p>How do we make it</p>

<a name="175177873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175177873" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175177873">Mario Carneiro (Sep 08 2019 at 09:37)</a>:</h4>
<p>I guess it is one more case in the recursion</p>

<a name="175177930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175177930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175177930">Keeley Hoek (Sep 08 2019 at 09:39)</a>:</h4>
<p>Is there any appetite for some tactic-ish thing <code>normalize</code> which does all these common rewrites? Kevin could make his <code>induction'</code> just (essentially) <code>induction &gt;&gt; normalize</code></p>

<a name="175178077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175178077" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175178077">Mario Carneiro (Sep 08 2019 at 09:45)</a>:</h4>
<p>I think the normalization is domain specific</p>

<a name="175273971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175273971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175273971">Gihan Marasingha (Sep 09 2019 at 19:19)</a>:</h4>
<p>Lean works fine on my Windows machine, but I have a couple of issues on the Mac.</p>
<p>My main problems is that VS Code doesn't seem to access the added dependencies.</p>
<p>From the Mac command line, If I move into the directory of the Lean project I've already created on Windows (and synced via OneDrive) to which I have already added mathlib as a dependency, I can execute .lean files perfectly, but I get import resolution errors when attempting the same through VS Code.</p>
<p>For example, if the file <code>tsum.lean</code> has the contents</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span>

<span class="kn">open</span> <span class="n">finset</span>

<span class="n">def</span> <span class="n">tsum</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
    <span class="n">sum</span> <span class="o">(</span><span class="n">range</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="n">tsum</span> <span class="mi">10</span>
</pre></div>


<p>then executing, at the terminal, <code>lean tsum.lean</code> produces the expected output <code>55</code>. </p>
<p>But VS Code presents me with the error messages:</p>
<div class="codehilite"><pre><span></span>file &#39;algebra/big_operators&#39; not found in the LEAN_PATH

invalid import: algebra.big_operators
could not resolve import: algebra.big_operators
</pre></div>

<a name="175275887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175275887" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175275887">Bryan Gin-ge Chen (Sep 09 2019 at 19:45)</a>:</h4>
<p>Did you open the Lean package directory in VS Code or just the file <code>tsum.lean</code>? The vscode-lean extension won't work properly unless you do the former.</p>

<a name="175279344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175279344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175279344">Gihan Marasingha (Sep 09 2019 at 20:22)</a>:</h4>
<p>Thanks so much <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> ! It wasn't a Mac problem after all. Just me not understanding how to use VS Code.</p>

<a name="175279423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175279423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175279423">Bryan Gin-ge Chen (Sep 09 2019 at 20:23)</a>:</h4>
<p>We could probably have the extension pop up a warning if it can't find a <code>leanpkg.toml</code> file.</p>

<a name="175284034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/175284034" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#175284034">Kevin Buzzard (Sep 09 2019 at 21:19)</a>:</h4>
<p><span class="user-mention" data-user-id="233737">@Gihan Marasingha</span> very early on in my Lean career I wrote a blog post about proving mathematical stuff by induction: <a href="https://xenaproject.wordpress.com/2018/03/30/proofs-by-induction/" target="_blank" title="https://xenaproject.wordpress.com/2018/03/30/proofs-by-induction/">https://xenaproject.wordpress.com/2018/03/30/proofs-by-induction/</a> . The first response in the comments is by a 1st year undergraduate giving lots of examples of how one can do various things in Lean, maybe it's helpful for you? He includes a link to his code.</p>

<a name="176148260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/176148260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#176148260">Sayantan Majumdar (Sep 19 2019 at 22:32)</a>:</h4>
<p>is there something wrong in the documentation in "prepositions and proof" in the "3.6 Examples of Prepositional Validities" when they write <br>
p \and false \iff false</p>

<a name="176148416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/176148416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#176148416">Kevin Buzzard (Sep 19 2019 at 22:35)</a>:</h4>
<p>...that <code>example : ¬(p ↔ ¬p) := sorry</code> can be done constructively? That's what people usually ask about this section ;-) Yes, it can be done constructively.</p>

<a name="176148508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/176148508" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#176148508">Sayantan Majumdar (Sep 19 2019 at 22:36)</a>:</h4>
<p>no is there something wrong with p \and false \iff false</p>

<a name="176148514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/176148514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#176148514">Kevin Buzzard (Sep 19 2019 at 22:36)</a>:</h4>
<p>I think that one is OK.</p>

<a name="176148541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/176148541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#176148541">Sayantan Majumdar (Sep 19 2019 at 22:38)</a>:</h4>
<p>how does false implies p is false?</p>

<a name="176148588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/176148588" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#176148588">Kevin Buzzard (Sep 19 2019 at 22:38)</a>:</h4>
<p><code>false</code> implies anything ;-)</p>

<a name="176148591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/176148591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#176148591">Kevin Buzzard (Sep 19 2019 at 22:38)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">false</span> <span class="bp">↔</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">assumption</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="176148603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/176148603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#176148603">Kevin Buzzard (Sep 19 2019 at 22:38)</a>:</h4>
<p><code>false</code> is an inductive type with no constructors, so the induction principle for <code>false</code>, namely <code>false.elim</code> is just <code>false -&gt; X</code> for any X.</p>

<a name="176148628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/176148628" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#176148628">Kevin Buzzard (Sep 19 2019 at 22:39)</a>:</h4>
<p>It might be easier to think of things in terms of classical logic. Then P is either true or false, and in either case we see both sides are false.</p>

<a name="176148709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/176148709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#176148709">Kevin Buzzard (Sep 19 2019 at 22:40)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">false</span> <span class="bp">↔</span> <span class="n">false</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">and</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span> <span class="n">false</span><span class="bp">.</span><span class="n">elim</span><span class="bp">⟩</span>
</pre></div>

<a name="176148996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/176148996" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#176148996">Sayantan Majumdar (Sep 19 2019 at 22:44)</a>:</h4>
<p>thanks</p>

<a name="177114367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/177114367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#177114367">Yufan Lou (Oct 02 2019 at 01:35)</a>:</h4>
<p>How do I fix this?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">modeq</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">library_search</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span><span class="err">^</span><span class="mi">2</span> <span class="bp">≡</span> <span class="n">b</span><span class="err">^</span><span class="mi">2</span> <span class="o">[</span><span class="n">MOD</span> <span class="mi">2</span><span class="o">]</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≡</span> <span class="n">b</span> <span class="o">[</span><span class="n">MOD</span> <span class="mi">2</span><span class="o">]</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">assume</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="mi">2</span> <span class="err">∣</span> <span class="n">b</span><span class="err">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">a</span><span class="err">^</span><span class="mi">2</span><span class="o">,</span> <span class="k">from</span> <span class="n">nat</span><span class="bp">.</span><span class="n">modeq</span><span class="bp">.</span><span class="n">dvd_of_modeq</span> <span class="n">hyp</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<div class="codehilite"><pre><span></span>7:29 error:
invalid type ascription, term has type
  ↑2 ∣ ↑(b ^ 2) - ↑(a ^ 2)
but is expected to have type
  2 ∣ b ^ 2 - a ^ 2
state:
2 goals
a b : ℕ,
hyp : a ^ 2 ≡ b ^ 2 [MOD 2]
⊢ 2 ∣ b ^ 2 - a ^ 2

a b : ℕ,
hyp : a ^ 2 ≡ b ^ 2 [MOD 2],
this : 2 ∣ b ^ 2 - a ^ 2
⊢ a ≡ b [MOD 2]
</pre></div>

<a name="177115336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/177115336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#177115336">Floris van Doorn (Oct 02 2019 at 02:01)</a>:</h4>
<p>Your <code>have : 2 ∣ b^2 - a^2</code> statement is probably not what you want here. The <code>b^2</code> and <code>a^2</code> are natural numbers, so <code>-</code> is subtraction between natural numbers. To make the output a natural number, so we define it as 0 when <code>a^2 &gt; b^2</code>. This "truncated" subtraction is very often not what you want to use.</p>

<a name="177115343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/177115343" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#177115343">Floris van Doorn (Oct 02 2019 at 02:01)</a>:</h4>
<p>So you want to give Lean a hint that you want to use integer subtraction:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">modeq</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">all</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span><span class="err">^</span><span class="mi">2</span> <span class="bp">≡</span> <span class="n">b</span><span class="err">^</span><span class="mi">2</span> <span class="o">[</span><span class="n">MOD</span> <span class="mi">2</span><span class="o">]</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≡</span> <span class="n">b</span> <span class="o">[</span><span class="n">MOD</span> <span class="mi">2</span><span class="o">]</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">assume</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="mi">2</span> <span class="err">∣</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span><span class="err">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">a</span><span class="err">^</span><span class="mi">2</span><span class="o">,</span> <span class="n">exact_mod_cast</span> <span class="n">nat</span><span class="bp">.</span><span class="n">modeq</span><span class="bp">.</span><span class="n">dvd_of_modeq</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="c1">-- rw [nat.modeq.modeq_iff_dvd] at hyp, norm_cast at hyp,</span>
<span class="kn">end</span>
</pre></div>

<a name="177115389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/177115389" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#177115389">Floris van Doorn (Oct 02 2019 at 02:02)</a>:</h4>
<p>I added an import, so that Lean knows about exponentiation of integers. You can alternatively also rewrite with <code>nat.modeq.modeq_iff_dvd</code> (see commented out code)</p>

<a name="177115408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/177115408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#177115408">Floris van Doorn (Oct 02 2019 at 02:03)</a>:</h4>
<p><code>norm_cast</code> and <code>exact_mod_cast</code> are useful tactics which will automatically deal with the cast from <code>nat</code> to <code>int</code>.</p>

<a name="177115411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/177115411" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#177115411">Floris van Doorn (Oct 02 2019 at 02:03)</a>:</h4>
<p>See <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md#norm_cast" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md#norm_cast">https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md#norm_cast</a></p>

<a name="177125131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/177125131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#177125131">Kevin Buzzard (Oct 02 2019 at 06:30)</a>:</h4>
<p>One very confusing point for beginners is that the natural number 2 and the integer 2 are not "equal" in Lean -- indeed it doesn't even make sense to ask that they are equal, because they don't have the same type. I would suggest that you work with integers all the way through rather than natural numbers, because what you want is true for integers. Of course then you have to change all the functions you use to the integer version :-/ Yes, this isn't like the way mathematicians treat it -- I know :-/</p>

<a name="177199648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/177199648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#177199648">Yufan Lou (Oct 02 2019 at 22:44)</a>:</h4>
<p>LOL I really overlooked that, thanks a lot</p>

<a name="177199790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/177199790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#177199790">Yufan Lou (Oct 02 2019 at 22:47)</a>:</h4>
<p>I guess it's just better to work under integer most of the time</p>

<a name="177209347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/177209347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#177209347">Reid Barton (Oct 03 2019 at 02:14)</a>:</h4>
<p>Clearly the natural numbers weren't meant to be formalized</p>

<a name="177209529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/177209529" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#177209529">Yufan Lou (Oct 03 2019 at 02:19)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span><span class="err">^</span><span class="mi">2</span> <span class="bp">≡</span> <span class="n">b</span><span class="err">^</span><span class="mi">2</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">]</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≡</span> <span class="n">b</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">]</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">assume</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="mi">2</span> <span class="err">∣</span> <span class="n">b</span><span class="err">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">a</span><span class="err">^</span><span class="mi">2</span><span class="o">,</span> <span class="k">from</span> <span class="n">int</span><span class="bp">.</span><span class="n">modeq</span><span class="bp">.</span><span class="n">modeq_iff_dvd</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="mi">2</span> <span class="err">∣</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="n">a</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">a</span><span class="o">),</span> <span class="k">by</span> <span class="n">library_search</span><span class="o">,</span>
  <span class="n">library_search</span>
<span class="kn">end</span>
</pre></div>


<p>back at it but this gives me fail, meanwhile I found this with library_search</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span><span class="err">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">b</span><span class="err">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sq_sub_sq</span> <span class="n">a</span> <span class="n">b</span>
</pre></div>


<p>How do I apply it?</p>

<a name="177209933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/177209933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#177209933">Yufan Lou (Oct 03 2019 at 02:29)</a>:</h4>
<p>nvm I was dumb XD forgot to specify <code>at</code> with <code>rw</code></p>

<a name="177210549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/177210549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#177210549">Yufan Lou (Oct 03 2019 at 02:47)</a>:</h4>
<p>ahhhh... now I have to apply the fundamental theorem of arithmetic but don't know how</p>

<a name="177212960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/177212960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#177212960">Jesse Michael Han (Oct 03 2019 at 03:57)</a>:</h4>
<p>you can do it by case exhaustion on <code>a</code> and <code>b</code>:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- requires import data.zmod.basic</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span><span class="err">^</span><span class="mi">2</span> <span class="bp">≡</span> <span class="n">b</span><span class="err">^</span><span class="mi">2</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">]</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≡</span> <span class="n">b</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">]</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">assume</span> <span class="n">hyp</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">int</span><span class="bp">.</span><span class="n">mod_two_eq_zero_or_one</span> <span class="n">a</span> <span class="k">with</span> <span class="n">H₁</span> <span class="n">H₁</span><span class="bp">;</span>
  <span class="n">cases</span> <span class="n">int</span><span class="bp">.</span><span class="n">mod_two_eq_zero_or_one</span> <span class="n">b</span> <span class="k">with</span> <span class="n">H₂</span> <span class="n">H₂</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">change</span> <span class="bp">_</span> <span class="bp">≡</span> <span class="mi">0</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">]</span> <span class="n">at</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">change</span> <span class="bp">_</span> <span class="bp">≡</span> <span class="mi">0</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">]</span> <span class="n">at</span> <span class="n">H₂</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">zmod</span><span class="bp">.</span><span class="n">eq_iff_modeq_int</span> <span class="mi">2</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">rw</span> <span class="err">←</span><span class="n">this</span> <span class="n">at</span> <span class="err">⊢</span> <span class="n">H₁</span> <span class="n">H₂</span> <span class="n">hyp</span><span class="o">,</span> <span class="n">cc</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">change</span> <span class="bp">_</span> <span class="bp">≡</span> <span class="mi">0</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">]</span> <span class="n">at</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">change</span> <span class="bp">_</span> <span class="bp">≡</span> <span class="mi">1</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">]</span> <span class="n">at</span> <span class="n">H₂</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">zmod</span><span class="bp">.</span><span class="n">eq_iff_modeq_int</span> <span class="mi">2</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">rw</span> <span class="err">←</span><span class="n">this</span> <span class="n">at</span> <span class="err">⊢</span> <span class="n">H₁</span> <span class="n">H₂</span> <span class="n">hyp</span><span class="o">,</span>
      <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">2</span><span class="o">),</span>
        <span class="k">by</span> <span class="n">simp</span><span class="bp">*</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">at</span> <span class="n">H₁</span> <span class="n">H₂</span><span class="o">,</span> <span class="n">simp</span><span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="bp">-</span><span class="n">hyp</span><span class="o">]</span> <span class="n">at</span> <span class="n">hyp</span><span class="o">,</span> <span class="n">simpa</span> <span class="kn">using</span> <span class="n">hyp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">change</span> <span class="bp">_</span> <span class="bp">≡</span> <span class="mi">1</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">]</span> <span class="n">at</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">change</span> <span class="bp">_</span> <span class="bp">≡</span> <span class="mi">0</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">]</span> <span class="n">at</span> <span class="n">H₂</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">zmod</span><span class="bp">.</span><span class="n">eq_iff_modeq_int</span> <span class="mi">2</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">rw</span> <span class="err">←</span><span class="n">this</span> <span class="n">at</span> <span class="err">⊢</span> <span class="n">H₁</span> <span class="n">H₂</span> <span class="n">hyp</span><span class="o">,</span>
      <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">2</span><span class="o">),</span>
        <span class="k">by</span> <span class="n">simp</span><span class="bp">*</span><span class="o">,</span>
      <span class="n">simp</span> <span class="n">at</span> <span class="n">H₁</span> <span class="n">H₂</span><span class="o">,</span> <span class="n">simp</span><span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="bp">-</span><span class="n">hyp</span><span class="o">]</span> <span class="n">at</span> <span class="n">hyp</span><span class="o">,</span> <span class="n">simpa</span> <span class="kn">using</span> <span class="n">hyp</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">change</span> <span class="bp">_</span> <span class="bp">≡</span> <span class="mi">1</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">]</span> <span class="n">at</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">change</span> <span class="bp">_</span> <span class="bp">≡</span> <span class="mi">1</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">]</span> <span class="n">at</span> <span class="n">H₂</span><span class="o">,</span>
      <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">zmod</span><span class="bp">.</span><span class="n">eq_iff_modeq_int</span> <span class="mi">2</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
      <span class="n">rw</span> <span class="err">←</span><span class="n">this</span> <span class="n">at</span> <span class="err">⊢</span> <span class="n">H₁</span> <span class="n">H₂</span> <span class="n">hyp</span><span class="o">,</span> <span class="n">cc</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>there's also fermat's little theorem for <code>zmod</code>, which might give a cleaner proof</p>

<a name="177214111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/177214111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#177214111">Kenny Lau (Oct 03 2019 at 04:28)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">zmod</span><span class="bp">.</span><span class="n">quadratic_reciprocity</span>

<span class="kn">theorem</span> <span class="n">frob</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">zmodp</span> <span class="n">p</span> <span class="n">hp</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="err">^</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">decidable</span><span class="bp">.</span><span class="n">by_cases</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">ha</span><span class="o">,</span> <span class="n">zero_pow</span> <span class="n">hp</span><span class="bp">.</span><span class="n">pos</span><span class="o">])</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">conv_lhs</span> <span class="o">{</span> <span class="n">congr</span><span class="o">,</span> <span class="n">skip</span><span class="o">,</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">nat</span><span class="bp">.</span><span class="n">sub_add_cancel</span> <span class="o">(</span><span class="k">show</span> <span class="n">p</span> <span class="bp">≥</span> <span class="mi">1</span><span class="o">,</span> <span class="k">from</span> <span class="n">le_of_lt</span> <span class="n">hp</span><span class="bp">.</span><span class="n">one_lt</span><span class="o">)</span> <span class="o">}</span><span class="bp">;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">pow_add</span><span class="o">,</span> <span class="n">zmodp</span><span class="bp">.</span><span class="n">fermat_little</span> <span class="n">hp</span> <span class="n">ha</span><span class="o">,</span> <span class="n">pow_one</span><span class="o">,</span> <span class="n">one_mul</span><span class="o">])</span>

<span class="kn">theorem</span> <span class="n">frob&#39;</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="err">^</span> <span class="n">p</span> <span class="bp">≡</span> <span class="n">a</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="n">p</span><span class="o">]</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">zmodp</span><span class="bp">.</span><span class="n">eq_iff_modeq_int</span> <span class="n">hp</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast_pow</span><span class="o">,</span> <span class="n">frob</span><span class="o">]</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span><span class="err">^</span><span class="mi">2</span> <span class="bp">≡</span> <span class="n">b</span><span class="err">^</span><span class="mi">2</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">])</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≡</span> <span class="n">b</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">]</span> <span class="o">:=</span>
<span class="k">calc</span>  <span class="n">a</span> <span class="bp">≡</span> <span class="n">a</span><span class="err">^</span><span class="mi">2</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">frob&#39;</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime_two</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
    <span class="bp">...</span> <span class="bp">≡</span> <span class="n">b</span><span class="err">^</span><span class="mi">2</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">]</span> <span class="o">:</span> <span class="n">h</span>
    <span class="bp">...</span> <span class="bp">≡</span> <span class="n">b</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">2</span><span class="o">]</span> <span class="o">:</span> <span class="n">frob&#39;</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime_two</span>
</pre></div>

<a name="177224238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/177224238" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#177224238">Yufan Lou (Oct 03 2019 at 08:30)</a>:</h4>
<p>Thank you both! I am understanding the proofs by tracing them step by step. I see that the key is to understand <code>zmod n</code> itself as a number type and either turning the mod congruence in <code>nat</code> into equality in <code>zmod n</code> and prove it there, or turning equality in <code>zmod n</code> into mod congruence in <code>nat</code> and apply them here. Hmm... I have a vague intuition about this from my Haskell experience, but I need to think hard about how to explain this to my maths colleagues...</p>
<p>I still don't get many intricacies in there either, like why I need to show <code>0 = 1</code> and why <code>-hyp</code> is necessary in <code>simp[*, -hyp]</code>. <code>conv_lhs</code> has not yet been documented. The first two steps <code>congr, skip</code> seems very arbitrary. Although I understand the proofs now, I can hardly imagine writing them.</p>

<a name="178501319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/178501319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#178501319">Chris B (Oct 18 2019 at 18:57)</a>:</h4>
<p>Is there a nicer way of doing this?</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">always_less</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="o">(</span><span class="k">if</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="mi">5</span> <span class="k">then</span> <span class="n">a</span> <span class="k">else</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="mi">6</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="n">decidable</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">decidable_lt</span> <span class="n">a</span> <span class="mi">5</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">hnc</span><span class="o">,</span> <span class="n">dec_trivial</span><span class="o">)</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">hc</span><span class="o">,</span> <span class="k">show</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="mi">6</span><span class="o">,</span> <span class="k">from</span> <span class="n">lt</span><span class="bp">.</span><span class="n">step</span> <span class="n">hc</span><span class="o">)</span>
</pre></div>

<a name="178506622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/178506622" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#178506622">Kenny Lau (Oct 18 2019 at 20:06)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">split_ifs</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">omega</span>

<span class="kn">lemma</span> <span class="n">always_less</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="k">if</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="mi">5</span> <span class="k">then</span> <span class="n">a</span> <span class="k">else</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="mi">6</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">split_ifs</span><span class="bp">;</span> <span class="n">omega</span>
</pre></div>

<a name="178510296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/178510296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#178510296">Chris B (Oct 18 2019 at 20:58)</a>:</h4>
<p>Rad, thanks. I didn't know about split_ifs.</p>

<a name="178510400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/178510400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#178510400">Kenny Lau (Oct 18 2019 at 21:00)</a>:</h4>
<p>I'm Kenny, but you're welcome</p>

<a name="178548786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/178548786" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#178548786">Yury G. Kudryashov (Oct 19 2019 at 14:31)</a>:</h4>
<p>How do I prove <code>∀ x : ℤ, 0 ≤ x → x ≤ 1 → x ∈ ({0, 1} : set ℤ)</code>?</p>

<a name="178548989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/178548989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#178548989">Yury G. Kudryashov (Oct 19 2019 at 14:36)</a>:</h4>
<p>Do we have something like <code>fintype {m : ℤ | a ≤ m /\ m &lt; b}</code>?</p>

<a name="178551312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/178551312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#178551312">Kevin Buzzard (Oct 19 2019 at 15:42)</a>:</h4>
<p>There was a thread about this only recently</p>

<a name="178551324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/178551324" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#178551324">Kevin Buzzard (Oct 19 2019 at 15:43)</a>:</h4>
<p>I mean the fintype</p>

<a name="178551619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/178551619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#178551619">Kevin Buzzard (Oct 19 2019 at 15:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∈</span> <span class="o">({</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">}</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">h0</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">le_iff_lt_or_eq</span> <span class="n">at</span> <span class="n">h0</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h0</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">h0</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">int</span><span class="bp">.</span><span class="n">lt_iff_add_one_le</span><span class="o">,</span> <span class="n">zero_add</span><span class="o">,</span> <span class="n">le_iff_lt_or_eq</span><span class="o">]</span> <span class="n">at</span> <span class="n">h0</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h0</span><span class="o">,</span>
    <span class="n">exfalso</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">lt_iff_not_ge</span> <span class="n">at</span> <span class="n">h0</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">h0</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">left</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h0</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="178551711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/178551711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#178551711">Kevin Buzzard (Oct 19 2019 at 15:52)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/Some.20numerology" title="#narrow/stream/116395-maths/topic/Some.20numerology">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Some.20numerology</a> That's more than you need for the fintype. As you can see, I partially PR'ed it (some nat lemmas) and then teaching started at my university and I never finished the job. Feel absolutely free to PR that stuff! I'm still snowed under until November.</p>

<a name="178551726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/178551726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#178551726">Yury G. Kudryashov (Oct 19 2019 at 15:53)</a>:</h4>
<p>Thank you for the link. I'll possibly PR it next week.</p>

<a name="178563223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/178563223" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#178563223">Patrick Massot (Oct 19 2019 at 21:00)</a>:</h4>
<p>The correct thing to do is probably to resume work on <a href="https://github.com/leanprover-community/mathlib/tree/nat_cases" target="_blank" title="https://github.com/leanprover-community/mathlib/tree/nat_cases">https://github.com/leanprover-community/mathlib/tree/nat_cases</a></p>

<a name="178601399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/178601399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#178601399">Chris B (Oct 20 2019 at 17:10)</a>:</h4>
<p>If anyone has opinions about when to prefer a decidable prop over a boolean valued function as a predicate  I'd like to read them if you get a moment. In a general context like lists, core doesn't seem to take a hard line stance either way IE <code>list.filter</code> and <code>list.partition</code> use decidable predicates whereas <code>list.all</code> and <code>list.any</code> use a boolean valued function. Mathlib often defines a function for both.</p>

<a name="178602494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/178602494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#178602494">Andrew Ashworth (Oct 20 2019 at 17:39)</a>:</h4>
<p>If you're going to still use Lean next year, I would use a bool-valued function</p>

<a name="178602525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/178602525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#178602525">Andrew Ashworth (Oct 20 2019 at 17:40)</a>:</h4>
<p>Lean 4's core library is moving towards explicit usage of boolean-valued predicates</p>

<a name="178604665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/178604665" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#178604665">Chris B (Oct 20 2019 at 18:37)</a>:</h4>
<p>Thanks, that definitely simplifies things, bool it is then.</p>

<a name="179048341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179048341" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179048341">Yury G. Kudryashov (Oct 25 2019 at 13:19)</a>:</h4>
<p>Hi, is it possible to express <code>∃ b &gt; a, p b</code> using <code>&lt;</code> only? I understand that I can write <code>∃ b  (H : a &lt; b),  p b</code> but this is less readable.</p>

<a name="179048499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179048499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179048499">Kevin Buzzard (Oct 25 2019 at 13:21)</a>:</h4>
<p>I think what you suggest (the less readable thing) is what we're supposed to be writing nowadays.</p>

<a name="179051404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179051404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179051404">Seewoo Lee (Oct 25 2019 at 13:56)</a>:</h4>
<p>Hi, here's a noob question: I'm trying to prove currying &amp; uncurrying, i.e. (p -&gt; q -&gt; r) &lt;-&gt; ((p \and q) -&gt; r). Here's my try:</p>
<div class="codehilite"><pre><span></span>theorem t3 : ((p ∧ q) → r) → (p → q → r) :=
    assume h₁ : (p ∧ q) → r,
    assume hp : p,
    assume hq : q,
    have h₂ : p ∧ q, from and.intro hp hq,
    h₁ h₂

theorem t4 : (p → q → r) → ((p ∧ q) → r) :=
    assume h₁ : p → q → r,
    assume h₂ : p ∧ q,
    have hp : p, from and.left h₂,
    have hq : q, from and.right h₂,
    have h₃ : q → r, from h₁ hp,
    have hr : r, from h₃ hq
    hr
</pre></div>


<p>t3 seems to have no problem, but t4 has. It gives an error like</p>
<div class="codehilite"><pre><span></span>function expected at
  h₃ hq
term has type
  r
</pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span>unknown identifier &#39;hr&#39;
</pre></div>


<p>but I can't find the reason. Any helps?</p>

<a name="179051601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179051601" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179051601">Seewoo Lee (Oct 25 2019 at 13:58)</a>:</h4>
<p>I forgot one: I put <code>variables p q r : Prop</code> before t3 and t4, of course.</p>

<a name="179051680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179051680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179051680">Kenny Lau (Oct 25 2019 at 13:59)</a>:</h4>
<p>because you forgot a comma</p>

<a name="179051735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179051735" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179051735">Kevin Buzzard (Oct 25 2019 at 14:00)</a>:</h4>
<p>these proofs are so hard to debug because they're not in tactic mode :-/</p>

<a name="179051752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179051752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179051752">Seewoo Lee (Oct 25 2019 at 14:00)</a>:</h4>
<p>Oh you're right, thanks!</p>

<a name="179051794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179051794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179051794">Seewoo Lee (Oct 25 2019 at 14:00)</a>:</h4>
<p>Is there any efficient way to do these? I'm still not familiar with lean's grammar.</p>

<a name="179051801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179051801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179051801">Kevin Buzzard (Oct 25 2019 at 14:01)</a>:</h4>
<p>"Don't forget the comma" occurs at least once in about the first six levels of <a href="http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/" target="_blank" title="http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/">http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/</a></p>

<a name="179051829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179051829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179051829">Kevin Buzzard (Oct 25 2019 at 14:01)</a>:</h4>
<p>because extensive testing showed that it was by far the most common error which newcomers made.</p>

<a name="179051834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179051834" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179051834">Kevin Buzzard (Oct 25 2019 at 14:01)</a>:</h4>
<p>often in bold face</p>

<a name="179051984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179051984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179051984">Kenny Lau (Oct 25 2019 at 14:02)</a>:</h4>
<blockquote>
<p>Is there any efficient way to do these? I'm still not familiar with lean's grammar.</p>
</blockquote>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kn">theorem</span> <span class="n">t3</span> <span class="o">:</span> <span class="o">((</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h₁</span> <span class="n">hp</span> <span class="n">hq</span><span class="o">,</span> <span class="n">h₁</span> <span class="bp">⟨</span><span class="n">hp</span><span class="o">,</span> <span class="n">hq</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">t4</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="o">((</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h₂</span><span class="bp">.</span><span class="mi">2</span>
</pre></div>

<a name="179052082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179052082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179052082">Seewoo Lee (Oct 25 2019 at 14:03)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span>  This is much better, thanks!</p>

<a name="179052123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179052123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179052123">Kevin Buzzard (Oct 25 2019 at 14:04)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">t4</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="o">((</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">h₁</span><span class="o">,</span> <span class="c1">-- I can see what is happening</span>
  <span class="n">intro</span> <span class="n">h₂</span><span class="o">,</span> <span class="c1">-- I can still see what is happening</span>
  <span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="c1">-- oh wow now I can see I have two goals</span>
    <span class="n">exact</span> <span class="n">and</span><span class="bp">.</span><span class="n">left</span> <span class="n">h₂</span><span class="o">,</span> <span class="c1">-- now back down to one</span>
  <span class="k">have</span> <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span> <span class="c1">-- this is so much better than what TPIL chapter 3 says</span>
    <span class="n">exact</span> <span class="n">and</span><span class="bp">.</span><span class="n">right</span> <span class="n">h₂</span><span class="o">,</span> <span class="c1">-- I wish I had read chapter 5 much earlier</span>
  <span class="k">have</span> <span class="n">h₃</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">,</span> <span class="c1">-- :D</span>
    <span class="n">exact</span> <span class="n">h₁</span> <span class="n">hp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hr</span> <span class="o">:</span> <span class="n">r</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h₃</span> <span class="n">hq</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hr</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="179052155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179052155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179052155">Kevin Buzzard (Oct 25 2019 at 14:04)</a>:</h4>
<p>Kenny's method is a pure term mode proof. To write these you need to know the trick with <code>_</code></p>

<a name="179052221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179052221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179052221">Kevin Buzzard (Oct 25 2019 at 14:05)</a>:</h4>
<p>This one was particularly easy, but in a longer one you can write something like</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">t4</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="o">((</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">h₁</span> <span class="bp">_</span> <span class="bp">_</span>
</pre></div>


<p>and hover over the <code>_</code>s to see what needs to go there.</p>

<a name="179052317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179052317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179052317">Kevin Buzzard (Oct 25 2019 at 14:06)</a>:</h4>
<p>In tactic mode you can see everything at all times, so it's better for mathematician beginners. What Kenny is saying is perhaps more appealing for CS beginners, as long as you know the <code>_</code> trick. You are just making the terms explicitly there.</p>

<a name="179052544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179052544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179052544">Seewoo Lee (Oct 25 2019 at 14:09)</a>:</h4>
<p>Yes I agree with you, and I just know what tactic mode is! Both seems great for me but tactic thing seems more intuitive.</p>

<a name="179401068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179401068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179401068">Jason Gross (Oct 30 2019 at 04:08)</a>:</h4>
<p>Question: does <code>simp</code> / <code>rewrite</code> work under binders?</p>

<a name="179401227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179401227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179401227">Kevin Buzzard (Oct 30 2019 at 04:13)</a>:</h4>
<p>not very well. Suggestions: (1) <code>erw</code> "extended rewrite" sometimes gets to places standard <code>rw</code> doesn't get to. (2) learn about conv mode: <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md">https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md</a></p>

<a name="179403776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179403776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179403776">Johan Commelin (Oct 30 2019 at 05:27)</a>:</h4>
<p>Actually <code>simp</code> usually does quite well, I think. But <code>rw</code> is really bad at this.</p>

<a name="179406739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179406739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179406739">Jason Gross (Oct 30 2019 at 06:47)</a>:</h4>
<p>Thanks</p>

<a name="179406742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179406742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179406742">Jason Gross (Oct 30 2019 at 06:47)</a>:</h4>
<p>Another question: Does <code>pp.max_depth</code> do anything?  I have it set to <code>1000000000</code> and still see <code>…</code> in my goal</p>

<a name="179429580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179429580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179429580">Floris van Doorn (Oct 30 2019 at 13:14)</a>:</h4>
<p>The <code>_</code> in your goal is likely a proof. Use <code>pp.proofs</code></p>

<a name="179468497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179468497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179468497">Jason Gross (Oct 30 2019 at 19:31)</a>:</h4>
<p><span class="user-mention" data-user-id="111080">@Floris van Doorn</span> It's not <code>_</code>, it's <code>…</code>, and my term has ~no proofs.  I see things like <code>[…, …, …, …, (… * 2 ^256, …),</code> (and then more), I don't see how these could possibly be proofs</p>

<a name="179469214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179469214" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179469214">Chris Hughes (Oct 30 2019 at 19:41)</a>:</h4>
<p>There's another pp option that does it. I don't remember what it's called.</p>

<a name="179469250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179469250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179469250">Floris van Doorn (Oct 30 2019 at 19:41)</a>:</h4>
<p>Oh, I have never encountered that. Does setting <code>pp.max_steps</code> help?</p>

<a name="179471045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179471045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179471045">Jason Gross (Oct 30 2019 at 20:00)</a>:</h4>
<p>That does seem to help, but not interactively.  I get <code>11:1: excessive memory consumption detected at 'replace' (potential solution: increase memory consumption threshold)</code>  And it takes something like 15 GB on the command line.  Here's an example:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="n">def</span> <span class="n">big</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="n">v</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">v</span>
<span class="bp">|</span> <span class="n">v</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="n">big</span> <span class="o">(</span><span class="n">v</span> <span class="bp">+</span> <span class="n">v</span><span class="o">)</span> <span class="n">c</span>

<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">max_depth</span> <span class="mi">1000000000</span>
<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">max_steps</span> <span class="mi">1000000000</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">big</span> <span class="n">v</span> <span class="mi">20</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">big</span><span class="o">]</span>
<span class="kn">end</span>
</pre></div>

<a name="179474306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179474306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179474306">Jason Gross (Oct 30 2019 at 20:36)</a>:</h4>
<p>If I get <code>kernel failed to type check declaration 'int.pow_of_nat' this is usually due to a buggy tactic or a bug in the builtin elaborator</code> on a definition I'm giving by <code>rfl</code>, is that a bug in lean?</p>

<a name="179474906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179474906" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179474906">Scott Morrison (Oct 30 2019 at 20:42)</a>:</h4>
<p>Probably not... :-) Can you minimise your example enough to post here?</p>

<a name="179476449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179476449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179476449">Jason Gross (Oct 30 2019 at 20:58)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow_nat</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℤ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span> <span class="n">b</span><span class="o">)</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span> <span class="o">(</span><span class="n">b</span> <span class="err">^</span> <span class="n">e</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">neg_succ_of_nat</span> <span class="n">b</span><span class="o">)</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">neg_succ_of_nat</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">neg_succ_of_nat</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow_nat</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">neg_succ_of_nat</span> <span class="n">b</span><span class="o">)</span> <span class="n">k</span>

<span class="kn">instance</span> <span class="n">int_has_pow_nat</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">int</span> <span class="n">nat</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">int</span><span class="bp">.</span><span class="n">pow_nat</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">b</span> <span class="err">^</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int</span><span class="bp">.</span><span class="n">neg_succ_of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_pow</span> <span class="n">int</span> <span class="n">int</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">int</span><span class="bp">.</span><span class="n">pow</span><span class="bp">⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="n">def</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow_of_nat</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">int</span><span class="bp">.</span><span class="n">pow</span> <span class="n">b</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span> <span class="o">(</span><span class="n">b</span> <span class="err">^</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="c1">-- 15:5: kernel failed to type check declaration &#39;int.pow_of_nat&#39; this is usually due to a buggy tactic or a bug in the builtin elaborator</span>
<span class="c1">-- elaborated type:</span>
<span class="c1">--   ∀ (b e : ℕ), int.pow ↑b ↑e = int.of_nat (b ^ e)</span>
<span class="c1">-- elaborated value:</span>
<span class="c1">--   λ (b e : ℕ), rfl</span>
<span class="c1">-- nested exception message:</span>
<span class="c1">-- type mismatch at definition &#39;int.pow_of_nat&#39;, has type</span>
<span class="c1">--   ∀ (b e : ℕ), int.pow ↑b ↑e = int.pow ↑b ↑e</span>
<span class="c1">-- but is expected to have type</span>
<span class="c1">--   ∀ (b e : ℕ), int.pow ↑b ↑e = int.of_nat (b ^ e)</span>
</pre></div>

<a name="179479393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179479393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179479393">Scott Morrison (Oct 30 2019 at 21:27)</a>:</h4>
<p>Looks like a bug to me... Hopefully someone who knows better will chime in soon.</p>

<a name="179479522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179479522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179479522">Jason Gross (Oct 30 2019 at 21:28)</a>:</h4>
<p>reported as <a href="https://github.com/leanprover-community/lean/issues/76" target="_blank" title="https://github.com/leanprover-community/lean/issues/76">https://github.com/leanprover-community/lean/issues/76</a></p>

<a name="179482512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179482512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179482512">Chris Hughes (Oct 30 2019 at 22:06)</a>:</h4>
<p>I don't think it is a bug. I wouldn't expect <code>rfl</code> to be able to prove that, you should have to induct on <code>e</code> first.</p>
<p>I don't think that's the usual error message, but I think that might be because it is a <code>def</code> rather than a lemma which would be more usual.</p>

<a name="179483174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179483174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179483174">Jason Gross (Oct 30 2019 at 22:15)</a>:</h4>
<p>If I do <code>def bad : true = false := rfl</code>, then I get a standard type error, without the extra words about it being possibly a bug</p>

<a name="179485582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179485582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179485582">Reid Barton (Oct 30 2019 at 22:52)</a>:</h4>
<p>It looks to me like the elaborator thought that <code>int.pow_nat (int.of_nat b) e</code> would reduce to <code>int.of_nat (b ^ e)</code>, but if you <code>#print int.pow_nat._main</code> you can see it actually won't.</p>

<a name="179485649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179485649" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179485649">Reid Barton (Oct 30 2019 at 22:53)</a>:</h4>
<p>Surprisingly to me and the elaborator (but apparently not to Chris) the equation compiler generated an outermost match on the second argument, not the first.</p>

<a name="179488091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179488091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179488091">Jason Gross (Oct 30 2019 at 23:32)</a>:</h4>
<p>If I get <code>error: deep recursion was detected at 'expression equality test' (potential solution: increase stack space in your system)</code>, how do I increase stack space?</p>

<a name="179488142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179488142" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179488142">Mario Carneiro (Oct 30 2019 at 23:34)</a>:</h4>
<p>It's a command line argument to lean</p>

<a name="179488243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179488243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179488243">Mario Carneiro (Oct 30 2019 at 23:35)</a>:</h4>
<p>but there is an adage that says that if you have to increase resource limits then you are probably doing something wrong</p>

<a name="179488271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179488271" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179488271">Mario Carneiro (Oct 30 2019 at 23:35)</a>:</h4>
<p>I hope you don't actually expect that <code>big</code> example to work, it's a term 2^20 large</p>

<a name="179488381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179488381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179488381">Jason Gross (Oct 30 2019 at 23:37)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> No, I'm getting this error on a different example, the <code>big</code> example was just creating something to exhibit the <code>...</code>.  The thing I'm trying to do is in <a href="https://github.com/mit-plv/fiat-crypto/blob/6aaf03aed733d08ff124dffded9d8e2c7f4cc25a/src-lean/fiat_crypto.lean#L405" target="_blank" title="https://github.com/mit-plv/fiat-crypto/blob/6aaf03aed733d08ff124dffded9d8e2c7f4cc25a/src-lean/fiat_crypto.lean#L405">https://github.com/mit-plv/fiat-crypto/blob/6aaf03aed733d08ff124dffded9d8e2c7f4cc25a/src-lean/fiat_crypto.lean#L405</a>, trying to get the <code>norm_num</code> tactic to finish when I change <code>open ex</code> to <code>open ex2</code> (because <code>ex</code> was just a toy example; <code>ex2</code> is the actual code I'm trying to work on)</p>

<a name="179488473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179488473" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179488473">Mario Carneiro (Oct 30 2019 at 23:39)</a>:</h4>
<p>For these kinds of big CS problems, my recommendation is to make sure you have clean inputs to the tactics</p>

<a name="179488488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179488488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179488488">Jason Gross (Oct 30 2019 at 23:39)</a>:</h4>
<p>What do you mean by "clean inputs"?</p>

<a name="179488500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179488500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179488500">Mario Carneiro (Oct 30 2019 at 23:39)</a>:</h4>
<p>If you can, use natural number equalities and known functions only to <code>norm_num</code></p>

<a name="179488564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179488564" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179488564">Mario Carneiro (Oct 30 2019 at 23:40)</a>:</h4>
<p>give <code>norm_num</code> space to decide the problem and simplify the if statement afterward</p>

<a name="179488596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179488596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179488596">Mario Carneiro (Oct 30 2019 at 23:40)</a>:</h4>
<p>you may need to write a tactic to do this, the standard interactive mode chaining is probably not sufficient</p>

<a name="179488639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179488639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179488639">Mario Carneiro (Oct 30 2019 at 23:41)</a>:</h4>
<p>You can still use the existing tactics, but you are doing something specific by unfolding some functions, targeting a particular subterm for <code>norm_num</code> simplification, then going back to the simplifier and so on</p>

<a name="179488698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179488698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179488698">Mario Carneiro (Oct 30 2019 at 23:42)</a>:</h4>
<p>the <code>norm_num</code> front end handles this by just iterating <code>norm_num1, simp, norm_num1, simp</code> until stuff stops changing but that's only a heuristic</p>

<a name="179489088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179489088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179489088">Jason Gross (Oct 30 2019 at 23:48)</a>:</h4>
<p>I mean, iterating <code>norm_num1, simp, ...</code> seems not wrong, and in fact the call I have there produces the correct output for the smaller toy example.  (I can't see if it produces correct output on a slightly larger example because I get the recursion depth error)</p>

<a name="179490084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179490084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179490084">Mario Carneiro (Oct 31 2019 at 00:06)</a>:</h4>
<p>So I looked through that fiat-crypto file, and what I see are 300 lines of definitions without any theorems, where almost every definition is marked for unfolding. This will <em>explode</em> in lean</p>

<a name="179490140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179490140" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179490140">Mario Carneiro (Oct 31 2019 at 00:07)</a>:</h4>
<p>What you want are rewrites that unfold what matters, in the cases that matter. If you have a recursive definition (defined with <code>*.rec</code>), it should <em>never</em> be directly unfolded; instead you should have a theorem for the various constructors of the inductive type that you are recursing on</p>

<a name="179490221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179490221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179490221">Mario Carneiro (Oct 31 2019 at 00:08)</a>:</h4>
<p>What is the point of the <code>let_in</code> definition? It seems plainly useless</p>

<a name="179490281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179490281" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179490281">Mario Carneiro (Oct 31 2019 at 00:09)</a>:</h4>
<p>Note that lean actually has a <code>let</code> construct</p>

<a name="179490459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179490459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179490459">Jason Gross (Oct 31 2019 at 00:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> The <code>let_in</code> definition is one of the very few definitions that should never be unfolded</p>

<a name="179490554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179490554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179490554">Jason Gross (Oct 31 2019 at 00:14)</a>:</h4>
<p>After reduction/unfolding/rewriting, the only remaining definitions which are not unfolded should be <code>*</code>, <code>+</code>, <code>%</code>, <code>/</code>, and <code>let_in</code></p>

<a name="179490603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179490603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179490603">Jason Gross (Oct 31 2019 at 00:15)</a>:</h4>
<p>I can change my definitions to not be in terms of recursors and instead be recursive themselves, but I don't see how that will fix anything.  The times to unfold them are in fact when the underlying recursor is ready to be reduced</p>

<a name="179490868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179490868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179490868">Mario Carneiro (Oct 31 2019 at 00:21)</a>:</h4>
<p>The following definitions should not be simp: <code>list.flat_map</code> (aka <code>list.bind</code>), <code>list.combine</code> (aka <code>list.zip</code>), <code>int.to_nat_bit(0/1)</code> (the if statement should be a precondition), <code>associational.eval</code>, <code>mul</code>, definitely <code>square</code>, <code>negate_snd</code>, <code>split</code>, <code>reduce</code>, definitely <code>reduce_square</code>, <code>carryterm</code>, <code>positional.from_associational</code>, <code>from_associational_cons</code>, <code>chained_carries</code>, <code>chained_carries_no_reduce</code>.</p>

<a name="179490947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179490947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179490947">Mario Carneiro (Oct 31 2019 at 00:22)</a>:</h4>
<p>You don't necessarily need to change the definition (although using the equation compiler will do some of these things automatically for you), but you should add equational lemmas in the cases where you want the definition to unfold. Asking everything to unfold all at once is asking for trouble</p>

<a name="179491071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179491071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179491071">Jason Gross (Oct 31 2019 at 00:25)</a>:</h4>
<p>Wait, why should <code>list.combine</code> not be <code>simp</code>?  It's just there so that I could make code translation easier, it literally just unfolds to <code>list.zip</code> (which I don't touch the flags of).  <code>from_associational_cons</code> is telling <code>from_associational</code> to reduce in as close a match to the case where it should that I can get (in the case where it's applied to a concrete list)</p>

<a name="179491095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179491095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179491095">Mario Carneiro (Oct 31 2019 at 00:25)</a>:</h4>
<p>For example:</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">prod</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="n">def</span> <span class="n">associational</span><span class="bp">.</span><span class="kn">eval</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">))</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="o">:=</span>
  <span class="n">list</span><span class="bp">.</span><span class="n">foldr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="mi">0</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">fst</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">snd</span> <span class="n">p</span><span class="o">)</span> <span class="n">p</span><span class="o">)</span>
</pre></div>


<p>should be</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">associational</span><span class="bp">.</span><span class="kn">eval</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">))</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="o">:=</span>
  <span class="n">list</span><span class="bp">.</span><span class="n">foldr</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="mi">0</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span><span class="o">,</span> <span class="n">fst</span> <span class="n">p</span> <span class="bp">*</span> <span class="n">snd</span> <span class="n">p</span><span class="o">)</span> <span class="n">p</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">associational</span><span class="bp">.</span><span class="n">eval_nil</span> <span class="o">:</span> <span class="n">associational</span><span class="bp">.</span><span class="kn">eval</span> <span class="o">[]</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">associational</span><span class="bp">.</span><span class="n">eval_cons</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">l</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">associational</span><span class="bp">.</span><span class="kn">eval</span> <span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">::</span> <span class="n">l</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">associational</span><span class="bp">.</span><span class="kn">eval</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>

<a name="179491145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179491145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179491145">Jason Gross (Oct 31 2019 at 00:26)</a>:</h4>
<p>Sure.  Though I will note that I don't use <code>associational.eval</code> anywhere right now, so not unfolding it is not a high priority</p>

<a name="179491160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179491160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179491160">Mario Carneiro (Oct 31 2019 at 00:27)</a>:</h4>
<p>or</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">associational</span><span class="bp">.</span><span class="kn">eval</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">ℤ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">::</span> <span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">associational</span><span class="bp">.</span><span class="kn">eval</span> <span class="n">l</span>
</pre></div>

<a name="179491184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179491184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179491184">Mario Carneiro (Oct 31 2019 at 00:27)</a>:</h4>
<p>It's an example; I can demonstrate on something else if you like</p>

<a name="179491195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179491195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179491195">Jason Gross (Oct 31 2019 at 00:27)</a>:</h4>
<p>Of the ones you listed, I use <code>list.flat_map</code>, <code>list.combine</code>, <code>mul</code>, <code>split</code>, <code>reduce</code>, <code>carryterm</code>, <code>positional.from_associational</code>, and <code>chained_carries</code></p>

<a name="179491349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179491349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179491349">Jason Gross (Oct 31 2019 at 00:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  Could you demonstrate on <code>reduce</code> (or <code>split</code>)?</p>

<a name="179491370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179491370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179491370">Jason Gross (Oct 31 2019 at 00:31)</a>:</h4>
<p>I'd also be interested in seeing <code>carryterm</code></p>

<a name="179491387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179491387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179491387">Jason Gross (Oct 31 2019 at 00:31)</a>:</h4>
<p><code>reduce</code> because I don't see how to write a simplification lemma for it; <code>carryterm</code> because the conditions under which it should reduce are complicated (namely, when <code>fst t</code> and <code>w</code> are numerals/closed terms)</p>

<a name="179491582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179491582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179491582">Mario Carneiro (Oct 31 2019 at 00:36)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">prod</span>
<span class="n">def</span> <span class="n">let_in</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">x</span>

<span class="n">def</span> <span class="n">associational</span><span class="bp">.</span><span class="n">mul</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">))</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="n">def</span> <span class="n">associational</span><span class="bp">.</span><span class="n">split</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">))</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">×</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list</span><span class="bp">.</span><span class="n">partition</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="o">(</span><span class="n">fst</span> <span class="n">t</span><span class="o">)</span> <span class="err">%</span> <span class="n">s</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">p</span> <span class="k">in</span>
<span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="o">(</span><span class="n">fst</span> <span class="n">t</span> <span class="bp">/</span> <span class="n">s</span><span class="o">,</span> <span class="n">snd</span> <span class="n">t</span><span class="o">))</span> <span class="n">a</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">associational</span><span class="bp">.</span><span class="n">split_val</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">partition</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">fst</span> <span class="n">t</span><span class="o">)</span> <span class="err">%</span> <span class="n">s</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">p</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">associational</span><span class="bp">.</span><span class="n">split</span> <span class="n">s</span> <span class="n">p</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="o">(</span><span class="n">fst</span> <span class="n">t</span> <span class="bp">/</span> <span class="n">s</span><span class="o">,</span> <span class="n">snd</span> <span class="n">t</span><span class="o">))</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">associational</span><span class="bp">.</span><span class="n">split</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">associational</span><span class="bp">.</span><span class="n">split</span><span class="o">]</span>

<span class="n">def</span> <span class="n">associational</span><span class="bp">.</span><span class="n">reduce</span> <span class="o">(</span><span class="n">s</span> <span class="n">c</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">let</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">associational</span><span class="bp">.</span><span class="n">split</span> <span class="n">s</span> <span class="n">p</span> <span class="k">in</span>
<span class="n">a</span> <span class="bp">++</span> <span class="n">associational</span><span class="bp">.</span><span class="n">mul</span> <span class="n">c</span> <span class="n">b</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">associational</span><span class="bp">.</span><span class="n">reduce_val</span> <span class="o">(</span><span class="n">s</span> <span class="n">c</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">associational</span><span class="bp">.</span><span class="n">split</span> <span class="n">s</span> <span class="n">p</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">associational</span><span class="bp">.</span><span class="n">reduce</span> <span class="n">s</span> <span class="n">c</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">++</span> <span class="n">associational</span><span class="bp">.</span><span class="n">mul</span> <span class="n">c</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">associational</span><span class="bp">.</span><span class="n">reduce</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">associational</span><span class="bp">.</span><span class="n">reduce</span><span class="o">]</span>
</pre></div>

<a name="179491684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179491684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179491684">Mario Carneiro (Oct 31 2019 at 00:39)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">associational</span><span class="bp">.</span><span class="n">carryterm</span> <span class="o">(</span><span class="n">w</span> <span class="n">fw</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span><span class="o">:</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">fst</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">w</span><span class="o">)</span>
  <span class="k">then</span> <span class="n">let_in</span> <span class="o">(</span><span class="n">snd</span> <span class="n">t</span><span class="o">)</span>         <span class="o">(</span><span class="bp">λ</span> <span class="n">t2</span><span class="o">,</span>
       <span class="n">let_in</span> <span class="o">(</span><span class="n">t2</span> <span class="bp">/</span> <span class="n">fw</span><span class="o">)</span>       <span class="o">(</span><span class="bp">λ</span> <span class="n">d2</span><span class="o">,</span>
       <span class="n">let_in</span> <span class="o">(</span><span class="n">t2</span> <span class="err">%</span> <span class="n">fw</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m2</span><span class="o">,</span>
       <span class="o">[(</span><span class="n">w</span> <span class="bp">*</span> <span class="n">fw</span><span class="o">,</span> <span class="n">d2</span><span class="o">),</span> <span class="o">(</span><span class="n">w</span><span class="o">,</span><span class="n">m2</span><span class="o">)])))</span>
  <span class="k">else</span> <span class="o">[</span><span class="n">t</span><span class="o">]</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">associational</span><span class="bp">.</span><span class="n">carryterm_pos</span> <span class="o">(</span><span class="n">w</span> <span class="n">fw</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">associational</span><span class="bp">.</span><span class="n">carryterm</span> <span class="n">w</span> <span class="n">fw</span> <span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span>
  <span class="n">let_in</span> <span class="n">b</span>               <span class="o">(</span><span class="bp">λ</span> <span class="n">t2</span><span class="o">,</span>
  <span class="n">let_in</span> <span class="o">(</span><span class="n">t2</span> <span class="bp">/</span> <span class="n">fw</span><span class="o">)</span>       <span class="o">(</span><span class="bp">λ</span> <span class="n">d2</span><span class="o">,</span>
  <span class="n">let_in</span> <span class="o">(</span><span class="n">t2</span> <span class="err">%</span> <span class="n">fw</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m2</span><span class="o">,</span>
  <span class="o">[(</span><span class="n">w</span> <span class="bp">*</span> <span class="n">fw</span><span class="o">,</span> <span class="n">d2</span><span class="o">),</span> <span class="o">(</span><span class="n">w</span><span class="o">,</span><span class="n">m2</span><span class="o">)])))</span> <span class="o">:=</span> <span class="n">if_pos</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">associational</span><span class="bp">.</span><span class="n">carryterm_neg</span> <span class="o">{</span><span class="n">w</span> <span class="n">fw</span> <span class="n">a</span> <span class="n">b</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span> <span class="n">associational</span><span class="bp">.</span><span class="n">carryterm</span> <span class="n">w</span> <span class="n">fw</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="o">[(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)]</span> <span class="o">:=</span> <span class="n">if_neg</span> <span class="n">h</span>
</pre></div>

<a name="179491760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179491760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179491760">Mario Carneiro (Oct 31 2019 at 00:41)</a>:</h4>
<p>The basic idea is to have all arguments to the functions be in weak head normal form (i.e. for a <code>list (Z x Z)</code> it should be an empty list or a cons of a pair), and additionally when there are destructuring lets or other pattern matches inside the function the results of these should be hypotheses</p>

<a name="179491839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179491839" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179491839">Mario Carneiro (Oct 31 2019 at 00:42)</a>:</h4>
<p>lean's equation compiler gives you something similar with an auxiliary function; if you print the definition of <code>associational.split</code> you will see that the destructuring let was done by creating an auxiliary that is defined by pattern matching</p>

<a name="179491868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179491868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179491868">Jason Gross (Oct 31 2019 at 00:43)</a>:</h4>
<p>And then how do I make use of these?  Do I interleave "prove side-conditions with <code>refl</code> with <code>simp</code> for <code>split_val</code>?  And it looks like rewriting with <code>associational.carryterm_pos</code> is incompatible with rewriting with <code>associational.carryterm_neg</code>; how do I get lean to pick the right one to rewrite with and prove the side-condition automatically?</p>

<a name="179491878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179491878" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179491878">Mario Carneiro (Oct 31 2019 at 00:43)</a>:</h4>
<p><code>simp</code> will do this</p>

<a name="179491941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179491941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179491941">Mario Carneiro (Oct 31 2019 at 00:44)</a>:</h4>
<p>But I should admit that lean has for a long time needed a tactic like Coq's <code>cbv</code>, for just doing evaluations like this</p>

<a name="179492026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179492026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179492026">Mario Carneiro (Oct 31 2019 at 00:46)</a>:</h4>
<p><code>simp</code> uses an auxiliary side condition discharger (that is by default <code>simp</code> to true) for using conditional rewrite lemmas</p>

<a name="179492047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179492047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179492047">Kevin Buzzard (Oct 31 2019 at 00:46)</a>:</h4>
<p>What does CBV stand for?</p>

<a name="179492052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179492052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179492052">Mario Carneiro (Oct 31 2019 at 00:47)</a>:</h4>
<p><code>norm_num</code> uses <code>norm_num</code> as the simp discharger, so it should be able to do the numeric part even inside if conditions and such</p>

<a name="179492061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179492061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179492061">Mario Carneiro (Oct 31 2019 at 00:47)</a>:</h4>
<p>call by value</p>

<a name="179492066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179492066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179492066">Mario Carneiro (Oct 31 2019 at 00:47)</a>:</h4>
<p>there is also <code>cbn</code> for call by name</p>

<a name="179492078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179492078" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179492078">Mario Carneiro (Oct 31 2019 at 00:47)</a>:</h4>
<p>it refers to the order of evaluation. It's basically treating terms as a functional program and evaluating functions according to their definitions</p>

<a name="179492131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179492131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179492131">Mario Carneiro (Oct 31 2019 at 00:48)</a>:</h4>
<p>which is what <code>rfl</code> does already, but <code>rfl</code> has to go to completion while the hypothetical <code>cbv</code> tactic would just stop when it gets stuck</p>

<a name="179492146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179492146" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179492146">Mario Carneiro (Oct 31 2019 at 00:48)</a>:</h4>
<p>right now people have to write mile-long simp invocations unfolding everything in sight</p>

<a name="179492173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179492173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179492173">Mario Carneiro (Oct 31 2019 at 00:49)</a>:</h4>
<p>or use carefully designed simp lemmas like the ones I've given above to guide the evaluation</p>

<a name="179493123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179493123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179493123">Jason Gross (Oct 31 2019 at 01:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> if I try that, <code>rw [associational.split_val]</code> gives <code>rewrite tactic failed, motive is not type correct</code> and <code>nested exception message: check failed, application type mismatch (use 'set_option trace.check true' for additional details)</code></p>

<a name="179493140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179493140" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179493140">Mario Carneiro (Oct 31 2019 at 01:09)</a>:</h4>
<p>Are you rewriting in an if statement?</p>

<a name="179493194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179493194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179493194">Jason Gross (Oct 31 2019 at 01:10)</a>:</h4>
<p>Yes</p>

<a name="179493215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179493215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179493215">Mario Carneiro (Oct 31 2019 at 01:10)</a>:</h4>
<p>If you use the suggested approach, you should never have to see an if statement, but you can also use <code>simp</code> in these situations to rewrite and also fix the dependent decidability argument</p>

<a name="179493403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179493403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179493403">Jason Gross (Oct 31 2019 at 01:14)</a>:</h4>
<p>Also, <code>associational.carryterm_neg</code> doesn't seem to be triggering when the location to rewrite is under binders?</p>

<a name="179493963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179493963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179493963">Jason Gross (Oct 31 2019 at 01:26)</a>:</h4>
<p>I am not sure if this strategy is going to work; it seems that <code>norm_num [lem1 lems]</code> fails to handle cases where <code>rw [lem1], norm_num [lems], norm_num [lems]</code> works, and <code>rw</code> doesn't really work under binders.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">norm_num</span>
<span class="kn">open</span> <span class="n">prod</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
<span class="n">def</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth_default</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">default</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">ls</span> <span class="o">:</span> <span class="n">list</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">A</span>
<span class="bp">|</span> <span class="o">[]</span>        <span class="bp">_</span>             <span class="o">:=</span> <span class="n">default</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="bp">::</span> <span class="n">xs</span><span class="o">)</span> <span class="mi">0</span>             <span class="o">:=</span> <span class="n">x</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="bp">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth_default</span> <span class="n">xs</span> <span class="n">n&#39;</span>


<span class="n">def</span> <span class="n">associational</span><span class="bp">.</span><span class="n">split</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">))</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">×</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list</span><span class="bp">.</span><span class="n">partition</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="o">(</span><span class="n">fst</span> <span class="n">t</span><span class="o">)</span> <span class="err">%</span> <span class="n">s</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">p</span> <span class="k">in</span>
  <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="o">(</span><span class="n">fst</span> <span class="n">t</span> <span class="bp">/</span> <span class="n">s</span><span class="o">,</span> <span class="n">snd</span> <span class="n">t</span><span class="o">))</span> <span class="n">a</span><span class="o">)</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">associational</span><span class="bp">.</span><span class="n">split_val</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">partition</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">fst</span> <span class="n">t</span><span class="o">)</span> <span class="err">%</span> <span class="n">s</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">p</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">associational</span><span class="bp">.</span><span class="n">split</span> <span class="n">s</span> <span class="n">p</span> <span class="bp">=</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="o">(</span><span class="n">fst</span> <span class="n">t</span> <span class="bp">/</span> <span class="n">s</span><span class="o">,</span> <span class="n">snd</span> <span class="n">t</span><span class="o">))</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">associational</span><span class="bp">.</span><span class="n">split</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">associational</span><span class="bp">.</span><span class="n">split</span><span class="o">]</span>


<span class="kn">example</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">associational</span><span class="bp">.</span><span class="n">split</span> <span class="mi">65536</span> <span class="o">[(</span><span class="mi">1</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth_default</span> <span class="mi">0</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth_default</span> <span class="mi">0</span> <span class="n">g</span> <span class="mi">0</span><span class="o">)])</span><span class="bp">.</span><span class="n">snd</span> <span class="bp">=</span> <span class="o">[]</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">associational</span><span class="bp">.</span><span class="n">split_val</span><span class="o">],</span> <span class="n">norm_num</span> <span class="o">[</span><span class="n">associational</span><span class="bp">.</span><span class="n">split_val</span><span class="o">,</span> <span class="o">(</span><span class="err">∘</span><span class="o">),</span> <span class="n">list</span><span class="bp">.</span><span class="n">filter</span><span class="o">],</span> <span class="n">norm_num</span> <span class="o">[</span><span class="n">associational</span><span class="bp">.</span><span class="n">split_val</span><span class="o">,</span> <span class="o">(</span><span class="err">∘</span><span class="o">),</span> <span class="n">list</span><span class="bp">.</span><span class="n">filter</span><span class="o">]</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">associational</span><span class="bp">.</span><span class="n">split</span> <span class="mi">65536</span> <span class="o">[(</span><span class="mi">1</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth_default</span> <span class="mi">0</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth_default</span> <span class="mi">0</span> <span class="n">g</span> <span class="mi">0</span><span class="o">)])</span><span class="bp">.</span><span class="n">snd</span> <span class="bp">=</span> <span class="o">[]</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">norm_num</span> <span class="o">[</span><span class="n">associational</span><span class="bp">.</span><span class="n">split_val</span><span class="o">,</span> <span class="o">(</span><span class="err">∘</span><span class="o">),</span> <span class="n">list</span><span class="bp">.</span><span class="n">filter</span><span class="o">]</span>
<span class="c1">-- 30:3: norm_num failed to simplify</span>
<span class="c1">-- state:</span>
<span class="c1">-- f g : list ℤ</span>
<span class="c1">-- ⊢ (associational.split 65536 [(1, list.nth_default 0 f 0 * list.nth_default 0 g 0)]).snd = list.nil</span>
<span class="kn">end</span>
</pre></div>


<p>What's going on here?</p>

<a name="179494619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179494619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179494619">Mario Carneiro (Oct 31 2019 at 01:41)</a>:</h4>
<p><code>rw</code> doesn't work under binders, <code>simp</code> does</p>

<a name="179495462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179495462" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179495462">Mario Carneiro (Oct 31 2019 at 02:03)</a>:</h4>
<p><span class="user-mention" data-user-id="241007">@Jason Gross</span> hm, you may be right. This works:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">associational</span><span class="bp">.</span><span class="n">split</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">))</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">×</span> <span class="n">list</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">×</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list</span><span class="bp">.</span><span class="n">partition</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="o">(</span><span class="n">fst</span> <span class="n">t</span><span class="o">)</span> <span class="err">%</span> <span class="n">s</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">p</span> <span class="k">in</span>
  <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">t</span><span class="o">,</span> <span class="o">(</span><span class="n">fst</span> <span class="n">t</span> <span class="bp">/</span> <span class="n">s</span><span class="o">,</span> <span class="n">snd</span> <span class="n">t</span><span class="o">))</span> <span class="n">a</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">associational</span><span class="bp">.</span><span class="n">split</span> <span class="mi">65536</span> <span class="o">[(</span><span class="mi">1</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth_default</span> <span class="mi">0</span> <span class="n">f</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth_default</span> <span class="mi">0</span> <span class="n">g</span> <span class="mi">0</span><span class="o">)])</span><span class="bp">.</span><span class="n">snd</span> <span class="bp">=</span> <span class="o">[]</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">associational</span><span class="bp">.</span><span class="n">split</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">filter</span><span class="o">],</span> <span class="n">norm_num1</span><span class="o">,</span> <span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>I've gone back to simp directly with the definition, but keeping the destructuring let, which prevents the unfolding from getting out of hand.</p>
<p>I should more seriously consider writing some equivalent to <code>cbv</code> that will do all of these things in the right order</p>

<a name="179502618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179502618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179502618">Mario Carneiro (Oct 31 2019 at 05:24)</a>:</h4>
<p><span class="user-mention" data-user-id="241007">@Jason Gross</span>  I managed to get your original <code>ex2</code> problem to compute to a value with a few modifications: <a href="https://gist.github.com/digama0/7649577d7c8af881cdbad50f9e84d81f" target="_blank" title="https://gist.github.com/digama0/7649577d7c8af881cdbad50f9e84d81f">https://gist.github.com/digama0/7649577d7c8af881cdbad50f9e84d81f</a></p>

<a name="179502848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179502848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179502848">Jason Gross (Oct 31 2019 at 05:31)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Thanks! </p>
<div class="codehilite"><pre><span></span><span class="gd">-def let_in {A : Type u} {B : Type v} (x : A) (f : A → B) := f x</span>
<span class="gi">+@[simp] def let_in {A : Type u} {B : Type v} (x : A) (f : A → B) := f x</span>
</pre></div>


<p>Uh, it's pretty important to not make this change; it results in ~exponential blowup, and in some of the examples even larger than this one, it becomes even more of a problem.  Is it essential to your way of making things work?</p>

<a name="179502898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179502898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179502898">Mario Carneiro (Oct 31 2019 at 05:32)</a>:</h4>
<p>I don't think so, it was mostly to get it out of the way for the other changes. A suitable set of other simp lemmas about let_in should suffice</p>

<a name="179502902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179502902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179502902">Mario Carneiro (Oct 31 2019 at 05:32)</a>:</h4>
<p>Lean does internally deduplicate expressions though, so it shouldn't cause exponential blowup</p>

<a name="179502914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179502914" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179502914">Mario Carneiro (Oct 31 2019 at 05:33)</a>:</h4>
<p>basically, your approach is interfering with lean's own approach to the same problem</p>

<a name="179502962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179502962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179502962">Jason Gross (Oct 31 2019 at 05:34)</a>:</h4>
<p>The issue is that the goal is to generate C code, eventually, and we don't want exponential blow-up in the C code output, so we need to not unfold let_in.  This is what all of the <code>let_in.lift*</code> lemmas at the bottom are about</p>

<a name="179502972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179502972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179502972">Mario Carneiro (Oct 31 2019 at 05:35)</a>:</h4>
<p>In that case, why is <code>let_in</code> not a constructor?</p>

<a name="179503023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503023">Jason Gross (Oct 31 2019 at 05:36)</a>:</h4>
<p>Because I didn't want to re-write a bunch of code to be in a monad</p>

<a name="179503028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503028" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503028">Jason Gross (Oct 31 2019 at 05:36)</a>:</h4>
<p>But, sure, you could make it a constructor, and sprinkle <code>bind</code> everywhere</p>

<a name="179503033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503033" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503033">Jason Gross (Oct 31 2019 at 05:36)</a>:</h4>
<p>(But then you also need a way to do <code>list (M T) -&gt; M (list T)</code>, etc)</p>

<a name="179503048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503048">Mario Carneiro (Oct 31 2019 at 05:37)</a>:</h4>
<p>The thing is that you are also trying to compute with this in lean, and in that context the let_in doesn't make any sense</p>

<a name="179503090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503090">Mario Carneiro (Oct 31 2019 at 05:38)</a>:</h4>
<p>And you can't compute a C code expression this way because <code>let_in</code> would be reduced away</p>

<a name="179503100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503100">Jason Gross (Oct 31 2019 at 05:38)</a>:</h4>
<p>The final step to get to C would be reifying or otherwise pretty-printing the code</p>

<a name="179503118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503118">Jason Gross (Oct 31 2019 at 05:39)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="gd">-  def positional.to_associational (n:ℕ) (xs:list ℤ) : list (ℤ × ℤ)</span>
<span class="gd">-    := list.combine (list.map weight (list.seq 0 n)) xs</span>
<span class="gi">+  def positional.to_associational (n:ℕ) (xs:list ℤ) : list (ℕ × ℤ)</span>
<span class="gi">+    := list.enum xs</span>
</pre></div>


<p>This seems wrong.   Did you deliberately remove <code>weight</code> here, or was it an oversight?</p>

<a name="179503124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503124" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503124">Mario Carneiro (Oct 31 2019 at 05:39)</a>:</h4>
<p>the removal of weight was an oversight</p>

<a name="179503126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503126" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503126">Mario Carneiro (Oct 31 2019 at 05:39)</a>:</h4>
<p>I wasn't sure about whether the removal of <code>n</code> was correct either</p>

<a name="179503176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503176">Mario Carneiro (Oct 31 2019 at 05:40)</a>:</h4>
<p>But if <code>n</code> is much larger than <code>xs</code> the original approach has a lot of unnecessary computation</p>

<a name="179503188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503188">Jason Gross (Oct 31 2019 at 05:41)</a>:</h4>
<p><code>n</code> is always equal to the length of <code>xs</code></p>

<a name="179503198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503198">Mario Carneiro (Oct 31 2019 at 05:41)</a>:</h4>
<p>In that case I would want to have just one loop instead of two here</p>

<a name="179503210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503210">Jason Gross (Oct 31 2019 at 05:41)</a>:</h4>
<p>Sure, that seems fine</p>

<a name="179503263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503263">Jason Gross (Oct 31 2019 at 05:42)</a>:</h4>
<p>Also, how long should I expect this to take?  The code you gave me has already been running for 14 minutes</p>

<a name="179503269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503269">Mario Carneiro (Oct 31 2019 at 05:42)</a>:</h4>
<p>my test ran 7 minutes</p>

<a name="179503291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503291">Jason Gross (Oct 31 2019 at 05:43)</a>:</h4>
<p>If I pass <code>--tstack=1000000</code>, does that make it slower?</p>

<a name="179503294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503294">Mario Carneiro (Oct 31 2019 at 05:43)</a>:</h4>
<p>I doubt it</p>

<a name="179503304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503304">Jason Gross (Oct 31 2019 at 05:43)</a>:</h4>
<p>Maybe your machine is more than 2x as fast as mine?</p>

<a name="179503354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503354">Mario Carneiro (Oct 31 2019 at 05:44)</a>:</h4>
<p>let me fix the bugs and try again to make sure I posted the right file</p>

<a name="179503368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503368">Jason Gross (Oct 31 2019 at 05:45)</a>:</h4>
<p>(Seems doubtful that you're twice as fast as me; my cpu is 3.6 GHz...)</p>

<a name="179503430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503430">Jason Gross (Oct 31 2019 at 05:46)</a>:</h4>
<p>What does <code>by exact _match l</code> do in <code>| (a::l) := positional.carry_reduce n s c a (by exact _match l)</code>?  (What's <code>_match</code>, and why are you doing it this way?)</p>

<a name="179503680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503680">Mario Carneiro (Oct 31 2019 at 05:53)</a>:</h4>
<p>Unfortunately lean does not have Coq's <code>fix</code> constructor for making a recursive definition in the middle of a term. It has <code>match</code> for invoking the equation compiler, but it doesn't expose the name of the recursive function so you can make a recursive call. However it is exposed in tactics with the name <code>_match</code></p>

<a name="179503752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503752">Mario Carneiro (Oct 31 2019 at 05:54)</a>:</h4>
<p>An equivalent approach would be:</p>
<div class="codehilite"><pre><span></span>    <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">positional</span><span class="bp">.</span><span class="n">chained_carries_aux</span> <span class="o">(</span><span class="n">n</span> <span class="n">s</span> <span class="n">c</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">→</span> <span class="n">list</span> <span class="bp">ℤ</span>
    <span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">p</span>
    <span class="bp">|</span> <span class="o">(</span><span class="n">a</span><span class="bp">::</span><span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">positional</span><span class="bp">.</span><span class="n">carry_reduce</span> <span class="n">n</span> <span class="n">s</span> <span class="n">c</span> <span class="n">a</span> <span class="o">(</span><span class="n">positional</span><span class="bp">.</span><span class="n">chained_carries_aux</span> <span class="n">l</span><span class="o">)</span>

    <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">positional</span><span class="bp">.</span><span class="n">chained_carries</span> <span class="o">(</span><span class="n">n</span> <span class="n">s</span> <span class="n">c</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">idxs</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span>
    <span class="n">positional</span><span class="bp">.</span><span class="n">chained_carries_aux</span> <span class="n">n</span> <span class="n">s</span> <span class="n">c</span> <span class="n">p</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">reverse</span> <span class="n">idxs</span><span class="o">)</span>
</pre></div>

<a name="179503837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503837">Reid Barton (Oct 31 2019 at 05:56)</a>:</h4>
<p>It's really annoying too when <code>apply</code> notices that this funny <code>_match</code> thing has the same type as the goal (imagine that)</p>

<a name="179503848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503848">Reid Barton (Oct 31 2019 at 05:56)</a>:</h4>
<p>Er, maybe not <code>apply</code> but things that try <code>assumption</code></p>

<a name="179503924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179503924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179503924">Mario Carneiro (Oct 31 2019 at 05:58)</a>:</h4>
<p>oh, I think I know what might be the difference: when I first tested it, I ran the <code>norm_num</code> invocation with <code>carry_mulmod ... = sorry</code>, and it finished after 7 minutes with the goal <code>[0, 0, 0, 0, 0] = sorry</code>. The version I put on the gist has the <code>[0,0,0,0,0]</code> edited in, which means that this also includes the kernel typechecking time</p>

<a name="179505704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179505704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179505704">Jason Gross (Oct 31 2019 at 06:41)</a>:</h4>
<p>If it finishes with <code>[0,0,0,0,0]</code>, that's a bug (perhaps the removal of <code>weight</code> that I mentioned?).  It's not supposed to reduce to a numeral, it's supposed to reduce to a bunch of <code>let_in</code>s expressing arithmetic about elements of <code>f</code> and <code>g</code>, followed by a list of bound variables</p>

<a name="179505779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179505779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179505779">Mario Carneiro (Oct 31 2019 at 06:42)</a>:</h4>
<p>When I take out the <code>let_in</code> simplification, it blocks on a function that takes a list, being passed a <code>let_in</code> applied to a list literal</p>

<a name="179506591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179506591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179506591">Mario Carneiro (Oct 31 2019 at 07:02)</a>:</h4>
<p>Also, for the record this looks to be a tad bit abusive of <code>simp</code> and regular functions. I have a better idea of what you are trying to do now, and I think that all of these functions should be tactics. They will run a lot faster, and you can still produce proofs along the way</p>

<a name="179565408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179565408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179565408">Jason Gross (Oct 31 2019 at 19:04)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Indeed, it blocks on a function taking a list, and that is what the lemmas like <code>let_in.lift_map</code> are for, to unblock reduction without inlining things</p>

<a name="179565457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179565457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179565457">Jason Gross (Oct 31 2019 at 19:05)</a>:</h4>
<p>Which functions should be tactics?  The definitions on lists, or the reduction and let-lifting?</p>

<a name="179597945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179597945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179597945">Mario Carneiro (Nov 01 2019 at 03:54)</a>:</h4>
<p><span class="user-mention" data-user-id="241007">@Jason Gross</span> It's not quite clear to me how many of the functions on lists should be converted to tactics, but the basic idea would be to have all the stuff you actually want in the output (notably the <code>let_in</code> constructs) as <code>expr</code>s, with most of the list functions being functions that manipulate lists of <code>expr</code>s and such, so that you can evaluate them in the VM instead of all the simping.</p>
<p>What isn't clear to me is what you want to assert about the resulting let lifted expression. As it is (assuming the <code>simp</code> stuff can be made to work), you end up with a proof that asserts something like <code>carry_mulmod ... = let_in (f 1 * g 1) (\lam x, let_in ...)</code>, but as a theorem this doesn't appear particularly valuable since <code>carry_mulmod</code> is just a function that computes the thing on the right. Presumably you have some semantics about mulmod that you actually care about, and this should be what you want to prove a relation to. Or maybe you don't want to prove it is anything in particular, you just want the expression on the right, in which case it can be done a lot faster in the VM.</p>

<a name="179598106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179598106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179598106">Jason Gross (Nov 01 2019 at 03:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> The theorem I want to prove is that <code>associational.eval (positional.to_associational (carry_mulmod f g)) = (eval f * eval g) % (s - associational.eval c)</code>.  (Where <code>def asociational.eval (p) := list.foldr (+) 0 (list.map (\lambda (w, v), w * v) p)</code>.)  Each of the list definitions has a corresponding lemma about what it does under <code>eval</code>, c.f. <a href="https://github.com/mit-plv/fiat-crypto/blob/master/src/Arithmetic/Core.v" target="_blank" title="https://github.com/mit-plv/fiat-crypto/blob/master/src/Arithmetic/Core.v">https://github.com/mit-plv/fiat-crypto/blob/master/src/Arithmetic/Core.v</a></p>

<a name="179598188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179598188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179598188">Jason Gross (Nov 01 2019 at 04:01)</a>:</h4>
<p>Then I can combine this theorem with the <code>carry_mulmod ... = let_in ...</code> theorem to get a theorem about the evaluation of the final expression</p>

<a name="179606785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179606785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179606785">Mario Carneiro (Nov 01 2019 at 08:05)</a>:</h4>
<p><span class="user-mention" data-user-id="241007">@Jason Gross</span> I don't think I can help you with this one. I've tried several methods, but I think lean's kernel evaluation just isn't up to the task - it's abysmally slow at just about every approach to this that doesn't involve a complete rewrite. (It doesn't help that the algorithm itself is not super efficient; I can see that this would probably evaluate well enough in Coq but the Coq kernel evaluator is more efficient than lean's.) The fact that it's not completely a refl proof but has embedded subproofs makes this evaluation significantly more elaborate than it otherwise would be, and the constant allocation of new variables and lifting the term is also a performance bottleneck. This is possibly a good test case for lean 4.</p>

<a name="179607861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179607861" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179607861">Jason Gross (Nov 01 2019 at 08:31)</a>:</h4>
<p>I appreciate all the help you've provided; thank you.  And feel free to take it as a test case for lean 4.  I will note that Coq only performs adequately if I rewrite the entire thing in CPS (so no term lifting needs to be done to reduce), make all the things that don't get unfolded axioms, and then run it in the vm.  Coq's rewriting tactics perform more slowly than Lean's (by a factor of 6, in the one case I could test).  Getting reasonable performance on this benchmark has been my PhD project for the last year or two, sort-of, and required writing a reflective rewriter mixed with NbE to be run in vm compute, and I'm currently in the process of writing this up in a paper for PLDI</p>

<a name="179609507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179609507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179609507">Mario Carneiro (Nov 01 2019 at 09:05)</a>:</h4>
<p>I updated the gist with my latest version: <a href="https://gist.github.com/digama0/7649577d7c8af881cdbad50f9e84d81f" target="_blank" title="https://gist.github.com/digama0/7649577d7c8af881cdbad50f9e84d81f">https://gist.github.com/digama0/7649577d7c8af881cdbad50f9e84d81f</a></p>
<p>I put it in a monad after all:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">let_bound</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">base</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">let_bound</span>
<span class="bp">|</span> <span class="n">dlet</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">ℤ</span> <span class="bp">→</span> <span class="n">let_bound</span><span class="o">)</span> <span class="bp">→</span> <span class="n">let_bound</span>
<span class="bp">|</span> <span class="n">mlet</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="o">(</span><span class="n">β</span> <span class="bp">→</span> <span class="n">let_bound</span><span class="o">)</span> <span class="bp">→</span> <span class="n">let_bound</span>
</pre></div>


<p>The meaning is that <code>dlet</code> is the constructor for <code>let_in</code>, and <code>mlet</code> is a subgoal that should be solved by <code>norm_num</code>. In theory, you should be able to take the <code>(carry_mulmod ...).eval</code> term, and then successively normalize it (by whnf) to <code>(mlet x f).eval</code> which rewrites to <code>(f y).eval</code> after figuring out <code>x ~&gt; y</code> by other tactics, and <code>(dlet x f).eval</code> which rewrites to <code>let_in x (\lam a, (f a).eval)</code>and work continues inside the lambda.</p>

<a name="179609606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179609606" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179609606">Mario Carneiro (Nov 01 2019 at 09:07)</a>:</h4>
<p>In practice, it seems to take about 1 sec per let binding, plus my tactics for doing the reduction are super janky</p>

<a name="179684072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684072">Jason Gross (Nov 02 2019 at 04:02)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Neat, thanks!  Is that 1 second per internal let-binder (including mlet), or 1 second per emitted dlet?  I will note that real examples range from a couple dozen dlets at the small end to about 3800 dlets (possibly more for some of the code we don't build routinely) at the large end.</p>

<a name="179684134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684134">Mario Carneiro (Nov 02 2019 at 04:05)</a>:</h4>
<p>I think what I was seeing was mlets. In ex2 there are about a dozen of them (solving stupidly large goals like <code>to_bool (1 % &lt;big number&gt; = 0)</code>) before you get to the first dlet</p>

<a name="179684179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684179" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684179">Jason Gross (Nov 02 2019 at 04:06)</a>:</h4>
<p>Ah, yes, there are a lot of those</p>

<a name="179684479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684479">Jason Gross (Nov 02 2019 at 04:16)</a>:</h4>
<blockquote>
<p>solving stupidly large goals like <code>to_bool (1 % &lt;big number&gt; = 0)</code></p>
</blockquote>
<p>Shouldn't solving this be fast/easy, because <code>1 % &lt;big number&gt;</code> is always <code>1</code>, and the division computation should be relatively fast because the numerator is small?</p>

<a name="179684709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684709">Jason Gross (Nov 02 2019 at 04:22)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I tried running your code, but it seems to fail with ~no progress after 77 seconds?</p>
<div class="codehilite"><pre><span></span>$ /usr/bin/time -f &quot;$@ (real: %e, user: %U, sys: %S, mem: %M ko)&quot; lean fiat-test.lean
to_bool (weight machine_wordsize 1 0 * weight machine_wordsize 1 0 % s = 0)
2 goals
f g : ℕ → ℤ,
a : ℤ
⊢ let_bound.eval
      (let_bound.bind (positional.carry_reduce (… 1) n s c 1)
         ((λ (x : ℤ), let_bound.bind (… s c 0) ((λ (x : ℤ), let_bound.map … (… …)) x)) a)) =
    ?m_1 a

f g : ℕ → ℤ
⊢ ℤ → list ℤ
to_bool (weight machine_wordsize 1 0 = weight machine_wordsize 1 0)
f g : ℕ → ℤ,
a a_1 : ℤ
⊢ let_bound.eval
      (let_bound.bind (positional.carry_reduce (… 1) n s c 1)
         ((λ (x : ℤ),
             let_bound.bind (λ (a : list ℤ), let x : list … := … a in … …)
               ((λ (x : ℤ), let_bound.bind … (… x)) x))
            a_1)) =
    ?m_1 a_1
f g : ℕ → ℤ,
a a_1 a_2 : ℤ
⊢ let_bound.eval
      (let_bound.bind (positional.carry_reduce (… 1) n s c 1)
         ((λ (x : ℤ),
             let_bound.bind (λ (a : list ℤ), let x : list … := … a in … …)
               ((λ (x : ℤ), let_bound.bind … (… x)) x))
            a_2)) =
    ?m_1 a_2
/home/jgross/Documents/repos/fiat-lean-test/fiat-test.lean:345:2: error: convert tactic failed, there are unsolved goals
state:
f g : ℕ → ℤ,
a a_1 a_2 : ℤ
⊢ let_bound.eval
      (let_bound.bind (positional.carry_reduce (… 1) n s c 1)
         ((λ (x : ℤ),
             let_bound.bind (λ (a : list ℤ), let x : list … := … a in … …)
               ((λ (x : ℤ), let_bound.bind … (… x)) x))
            a_2)) =
    ?m_1 a_2
Command exited with non-zero status 1
 (real: 76.88, user: 76.73, sys: 0.24, mem: 396720 ko)
</pre></div>

<a name="179684727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684727" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684727">Mario Carneiro (Nov 02 2019 at 04:22)</a>:</h4>
<p>it probably doesn't work</p>

<a name="179684729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684729">Jason Gross (Nov 02 2019 at 04:22)</a>:</h4>
<p>(Maybe I am misreading the output, though...)</p>

<a name="179684741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684741">Mario Carneiro (Nov 02 2019 at 04:23)</a>:</h4>
<p>if you can find some use for the code, great, but it comes with no warranty</p>

<a name="179684787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684787">Mario Carneiro (Nov 02 2019 at 04:24)</a>:</h4>
<p>the tactic itself is extremely experimental</p>

<a name="179684795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684795">Jason Gross (Nov 02 2019 at 04:24)</a>:</h4>
<p>Okay.  I think I'm not yet sufficiently experienced with Lean to extract value from the tactic code, and I've satisfied my curiosity about how good Lean's features are out-of-the-box at solving this sort of goal.</p>

<a name="179684796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684796">Mario Carneiro (Nov 02 2019 at 04:24)</a>:</h4>
<p>it got a bit hard to test because everything takes forever</p>

<a name="179684813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684813">Mario Carneiro (Nov 02 2019 at 04:25)</a>:</h4>
<p>This is definitely not something anyone has attempted to do before in lean</p>

<a name="179684818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684818">Jason Gross (Nov 02 2019 at 04:25)</a>:</h4>
<blockquote>
<p>it got a bit hard to test because everything takes forever</p>
</blockquote>
<p>That's the story of my PhD.  I've probably spent 80% of my time trying to figure out how to work around performance issues in Coq</p>

<a name="179684861"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684861" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684861">Mario Carneiro (Nov 02 2019 at 04:26)</a>:</h4>
<p>My instincts say "fix the algorithm"</p>

<a name="179684867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684867">Jason Gross (Nov 02 2019 at 04:26)</a>:</h4>
<p>What do you mean "fix the algorithm"?</p>

<a name="179684877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684877">Mario Carneiro (Nov 02 2019 at 04:26)</a>:</h4>
<p>There is a ton of list manipulation code in here that seems to be unnecessary</p>

<a name="179684893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684893">Mario Carneiro (Nov 02 2019 at 04:27)</a>:</h4>
<p>I mean, if it's a benchmark then that's fine, but I think you can obtain equivalent results with another approach that doesn't involve all these let bindings</p>

<a name="179684951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684951" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684951">Mario Carneiro (Nov 02 2019 at 04:28)</a>:</h4>
<p>and what's with all this back and forth between positional and associational representations?</p>

<a name="179684973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179684973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179684973">Jason Gross (Nov 02 2019 at 04:29)</a>:</h4>
<p>The ultimate goal is to produce code like this: <a href="https://github.com/mit-plv/fiat-crypto/blob/5a51b7a2f9fc8aad46963f0d9bbe64047de0704f/curve25519_64.c#L96-L154" target="_blank" title="https://github.com/mit-plv/fiat-crypto/blob/5a51b7a2f9fc8aad46963f0d9bbe64047de0704f/curve25519_64.c#L96-L154">https://github.com/mit-plv/fiat-crypto/blob/5a51b7a2f9fc8aad46963f0d9bbe64047de0704f/curve25519_64.c#L96-L154</a></p>

<a name="179685040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685040">Mario Carneiro (Nov 02 2019 at 04:31)</a>:</h4>
<p>I would write a tactic that produces that, and a simultaneously proof of the semantics of it</p>

<a name="179685098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685098">Mario Carneiro (Nov 02 2019 at 04:32)</a>:</h4>
<p>Z would never show up in the algorithm</p>

<a name="179685108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685108">Mario Carneiro (Nov 02 2019 at 04:32)</a>:</h4>
<p>(except in the tactic code itself)</p>

<a name="179685174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685174">Jason Gross (Nov 02 2019 at 04:34)</a>:</h4>
<p>The back-and-forth between positional and associational is because some algorithms are easy to express and prove in the associational representation (addition of numbers is just list concatenation, multiplication is just all the ways of combining pairs of elements of the lists with <code>*</code>), while positional is the format that is actually used to store the numbers in memory / transmit them on the wire.  But you're right, there's a lot of unnecessary back-and-forth in <code>chained_carries</code>, which could probably benefit from being moved to <code>associational</code>.</p>

<a name="179685253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685253" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685253">Mario Carneiro (Nov 02 2019 at 04:36)</a>:</h4>
<p>The point is to separate the parts of the algorithm that actually need to be executed, and the parts that are actually the output (creating the list of let bindings)</p>

<a name="179685264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685264">Mario Carneiro (Nov 02 2019 at 04:36)</a>:</h4>
<p>the part that gets executed can happen in the VM (fast and untrusted), and the part that is output is term creation with a proof of correctness</p>

<a name="179685276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685276" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685276">Mario Carneiro (Nov 02 2019 at 04:37)</a>:</h4>
<p>Right now <em>everything</em> is happening as term manipulation, so it's all slow</p>

<a name="179685379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685379">Jason Gross (Nov 02 2019 at 04:40)</a>:</h4>
<p>Maybe I don't understand what you mean by a tactic that produces both the term and the proof.  e.g., what would this look like for <code>associational.carryterm</code>, whose spec is <code>associational.eval (associational.carryterm w fw t) = associational.eval [t]</code> (Coq proof <a href="https://github.com/mit-plv/fiat-crypto/blob/5a51b7a2f9fc8aad46963f0d9bbe64047de0704f/src/Arithmetic/Core.v#L476-L483" target="_blank" title="https://github.com/mit-plv/fiat-crypto/blob/5a51b7a2f9fc8aad46963f0d9bbe64047de0704f/src/Arithmetic/Core.v#L476-L483">here</a>)</p>

<a name="179685462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685462" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685462">Jason Gross (Nov 02 2019 at 04:41)</a>:</h4>
<p>(The proof is pretty simple: it's basically just the spec of div and mod, plus ring)</p>

<a name="179685528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685528" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685528">Jason Gross (Nov 02 2019 at 04:43)</a>:</h4>
<p>Do you mean something like, a tactic that builds a sigma type <code>{ ct : list (Z * Z) | associational.eval ct = associational.eval [t] }</code>?</p>

<a name="179685532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685532">Jason Gross (Nov 02 2019 at 04:43)</a>:</h4>
<p>or, er, maybe it is all inside the let monad</p>

<a name="179685581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685581" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685581">Mario Carneiro (Nov 02 2019 at 04:44)</a>:</h4>
<p>You have a tactic called <code>carryterm (...) : tactic (term x expr)</code>, which is given some inputs and produces a pair of a term and a proof of <code>associational.eval t' = associational.eval [t]</code> (where <code>t'</code> is the reification of the returned term)</p>

<a name="179685657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685657">Mario Carneiro (Nov 02 2019 at 04:46)</a>:</h4>
<p>yes, you could also view it as a sigma type, although you want <code>ct</code> here to be a concrete list, not an arbitrary term of type <code>list (Z * Z)</code></p>

<a name="179685667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685667">Jason Gross (Nov 02 2019 at 04:46)</a>:</h4>
<p>Yes, a concrete list, but it's under let binders</p>

<a name="179685675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685675">Mario Carneiro (Nov 02 2019 at 04:47)</a>:</h4>
<p>which is why it is returned as a <code>term</code> (which is some inductive type you define that specifies the valid constructions, in this case a list under let binders)</p>

<a name="179685702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685702">Mario Carneiro (Nov 02 2019 at 04:47)</a>:</h4>
<p>I suspect that you actually should be keeping the let binders on the side though; that is, you have some growing context of let binders and your monad allows you to add to it</p>

<a name="179685755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685755">Jason Gross (Nov 02 2019 at 04:48)</a>:</h4>
<p>Hm, but the proofs are invalid if you don't know the values of the binders.  I get the evaluation for the proofs looks things up from the binders on the side?</p>

<a name="179685761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685761" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685761">Mario Carneiro (Nov 02 2019 at 04:49)</a>:</h4>
<p>Yes, you would be passing it as another argument to eval in that case</p>

<a name="179685781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685781">Jason Gross (Nov 02 2019 at 04:49)</a>:</h4>
<p>Okay, so I see how I could produce the term, but I don't see how producing the proof on the fly every time I call carryterm is going to be any faster.  It seems like it can only possibly be slower, because now not only are you computing equality of list manipulation, you're also computing equality of <code>associational.eval</code></p>

<a name="179685868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685868">Jason Gross (Nov 02 2019 at 04:51)</a>:</h4>
<p>Oh, I see, at least for carryterm, you don't need to worry about what the bool computes you, you just produce a proof of one side or the other</p>

<a name="179685877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685877">Jason Gross (Nov 02 2019 at 04:52)</a>:</h4>
<p>(I still think the proof is going to be expensive here, because you're calling ring)</p>

<a name="179685917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685917">Mario Carneiro (Nov 02 2019 at 04:52)</a>:</h4>
<p>Both parts are produced by application of theorems like those I mentioned earlier. You aren't "computing" anything in the DTT sense; you are applying theorems that build up eval equalities about these reified terms</p>

<a name="179685920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685920">Mario Carneiro (Nov 02 2019 at 04:52)</a>:</h4>
<p>You actually don't need to call <code>ring</code> at all this way</p>

<a name="179685922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685922">Mario Carneiro (Nov 02 2019 at 04:52)</a>:</h4>
<p>That's the main benefit</p>

<a name="179685939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179685939" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179685939">Mario Carneiro (Nov 02 2019 at 04:53)</a>:</h4>
<p>If you have something like <code>if a % s = 0 then ... else ...</code> in the algorithm, that's fine, it runs in the VM and uses a bignum library</p>

<a name="179686014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179686014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179686014">Mario Carneiro (Nov 02 2019 at 04:55)</a>:</h4>
<p>The only reason you need to run <code>norm_num</code> is if you needed that fact <code>a % s = 0</code> in order to produce the correctness proof, but with this approach it's easy to run it and provide the input where it is needed</p>

<a name="179686076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179686076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179686076">Jason Gross (Nov 02 2019 at 04:57)</a>:</h4>
<p>Hm, this is interesting, I'll have to think more about this approach</p>

<a name="179686081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179686081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179686081">Jason Gross (Nov 02 2019 at 04:58)</a>:</h4>
<p>(And, indeed, in <code>associational.split</code>, we need a proof of <code>a % s = 0</code> for the <code>then</code> branch, but don't need to know anything in the <code>else</code> branch)</p>

<a name="179686143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179686143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179686143">Mario Carneiro (Nov 02 2019 at 04:59)</a>:</h4>
<p>Additionally, you can easily shortcut the computation by applying a theorem with the alternate hypothesis <code>a = 0</code>, or <code>a = s</code>, or <code>a = k * s</code> where you precompute what <code>k</code> should be</p>

<a name="179686349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179686349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179686349">Jason Gross (Nov 02 2019 at 05:04)</a>:</h4>
<p>Presumably I still need <code>norm_num</code> to prove <code>a = k * s</code>, though, right?  Because of <a href="https://webcache.googleusercontent.com/search?q=cache:tVeSAlPEQN4J:https://github.com/leanprover/lean/issues/1799+&amp;cd=2&amp;hl=en&amp;ct=clnk&amp;gl=us" target="_blank" title="https://webcache.googleusercontent.com/search?q=cache:tVeSAlPEQN4J:https://github.com/leanprover/lean/issues/1799+&amp;cd=2&amp;hl=en&amp;ct=clnk&amp;gl=us">https://webcache.googleusercontent.com/search?q=cache:tVeSAlPEQN4J:https://github.com/leanprover/lean/issues/1799+&amp;cd=2&amp;hl=en&amp;ct=clnk&amp;gl=us</a></p>

<a name="179686365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179686365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179686365">Jason Gross (Nov 02 2019 at 05:05)</a>:</h4>
<p>(Did someone delete all the issues on leanprover/lean?  There's no issue page anymore, and all the pre-existing issues give 404 now...)</p>

<a name="179686790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179686790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179686790">Mario Carneiro (Nov 02 2019 at 05:17)</a>:</h4>
<p>What the... It appears Leo <a href="https://github.com/leanprover/lean/commit/72a965986fa5aeae54062e98efb3140b2c4e79fd" target="_blank" title="https://github.com/leanprover/lean/commit/72a965986fa5aeae54062e98efb3140b2c4e79fd">simplified the readme</a> and <em>deleted</em> the entire issues page for leanprover/lean. I didn't even know that was possible, but I hope we can get the history migrated to the community version</p>

<a name="179686909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179686909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179686909">Mario Carneiro (Nov 02 2019 at 05:21)</a>:</h4>
<p>Yes, you would want to use <code>norm_num</code> to prove the <code>a = k * s</code> side goal.</p>

<a name="179686966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179686966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179686966">Mario Carneiro (Nov 02 2019 at 05:23)</a>:</h4>
<p>Indeed, the approach I am describing is basically what <code>norm_num</code> does itself, for arithmetic goals</p>

<a name="179687196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179687196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179687196">Jason Gross (Nov 02 2019 at 05:30)</a>:</h4>
<p>Is there any chance I can get Lean to manage the context for me, or do I have to do it myself and reason about, e.g., uniqueness of names and context-lookup, etc?</p>

<a name="179687268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179687268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179687268">Jason Gross (Nov 02 2019 at 05:32)</a>:</h4>
<p>There's a checkbox under "options" of a github repository to enable/disable issues.  I could believe that when you disable issues, github just makes them inaccessible to non-admins or something.  (I could also believe it deletes them)</p>

<a name="179687317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179687317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179687317">Jason Gross (Nov 02 2019 at 05:34)</a>:</h4>
<p>Yeah, when you uncheck the issues box, github makes all issues be 404s.  When you recheck it, they all come back</p>

<a name="179687321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179687321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179687321">Bryan Gin-ge Chen (Nov 02 2019 at 05:34)</a>:</h4>
<p>Indeed, according to <a href="https://help.github.com/en/github/managing-your-work-on-github/disabling-issues" target="_blank" title="https://help.github.com/en/github/managing-your-work-on-github/disabling-issues">this page</a> re-enabling the issues would make the old ones accessible again. I could only find <a href="https://help.github.com/en/github/managing-your-work-on-github/transferring-an-issue-to-another-repository" target="_blank" title="https://help.github.com/en/github/managing-your-work-on-github/transferring-an-issue-to-another-repository">this page</a> on migrating single open issues, and it didn't look too promising. Maybe github support could work some magic though.</p>

<a name="179687335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179687335" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179687335">Jason Gross (Nov 02 2019 at 05:35)</a>:</h4>
<p>It's definitely possible to mass-migrate issues, though you might need to write a tool to do it using the github api (and get Leo to re-enable issues temporarily)</p>

<a name="179687342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179687342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179687342">Jason Gross (Nov 02 2019 at 05:35)</a>:</h4>
<p>Coq migrated all of it's issues from bugzilla to github, mostly preserving issue numbers (but they all show as authored by coqbot, unfortunately)</p>

<a name="179687403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179687403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179687403">Jason Gross (Nov 02 2019 at 05:37)</a>:</h4>
<p><a href="https://github.com/IQAndreas/github-issues-import" target="_blank" title="https://github.com/IQAndreas/github-issues-import">https://github.com/IQAndreas/github-issues-import</a></p>

<a name="179687464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179687464" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179687464">Jason Gross (Nov 02 2019 at 05:39)</a>:</h4>
<p>Also, <a href="http://www.alexhadik.com/blog/2016/5/26/migrating-github-repositories-with-gitmover" target="_blank" title="http://www.alexhadik.com/blog/2016/5/26/migrating-github-repositories-with-gitmover">http://www.alexhadik.com/blog/2016/5/26/migrating-github-repositories-with-gitmover</a></p>

<a name="179707726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179707726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179707726">Andrew Ashworth (Nov 02 2019 at 16:03)</a>:</h4>
<p>you're going to want my fork: <a href="https://github.com/alashworth/github-issues-import" target="_blank" title="https://github.com/alashworth/github-issues-import">https://github.com/alashworth/github-issues-import</a></p>

<a name="179707736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179707736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179707736">Andrew Ashworth (Nov 02 2019 at 16:03)</a>:</h4>
<p>also you will need to speak to github admin to whitelist your account, otherwise you'll get autobanned for spamming</p>

<a name="179707739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/179707739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#179707739">Andrew Ashworth (Nov 02 2019 at 16:03)</a>:</h4>
<p>(went through this in march)</p>

<a name="180375447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/180375447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#180375447">Gihan Marasingha (Nov 10 2019 at 19:11)</a>:</h4>
<p>(deleted)</p>

<a name="180375510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/180375510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#180375510">Gihan Marasingha (Nov 10 2019 at 19:12)</a>:</h4>
<p>(deleted)</p>

<a name="180920850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/180920850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#180920850">Reuben Rowe (Nov 16 2019 at 17:35)</a>:</h4>
<p>If I have an instance <code>denumerable α</code> and two values <code>x y : α</code>, is there a way to be able to write <code>if x = y then ...</code> rather than <code>if (encodable.encode x) = (encodable.encode y) then ...</code>. That is, how to I get Lean to infer <code>decidable (x = y)</code>?</p>

<a name="180920960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/180920960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#180920960">Mario Carneiro (Nov 16 2019 at 17:38)</a>:</h4>
<p>you want to assume <code>decidable_eq A</code> too</p>

<a name="180921040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/180921040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#180921040">Reuben Rowe (Nov 16 2019 at 17:40)</a>:</h4>
<p>Great, thanks - but it seemed to me that this can be derived from denumerability. Why should I have to assume it separately?</p>

<a name="180921045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/180921045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#180921045">Mario Carneiro (Nov 16 2019 at 17:41)</a>:</h4>
<p>because the implementation might be different</p>

<a name="180921049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/180921049" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#180921049">Reuben Rowe (Nov 16 2019 at 17:41)</a>:</h4>
<p>Derived from denumerability, given that equality on \Nat is decidable</p>

<a name="180921067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/180921067" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#180921067">Mario Carneiro (Nov 16 2019 at 17:41)</a>:</h4>
<p>it's not usually the best way to decide equality</p>

<a name="180921299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/180921299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#180921299">Reuben Rowe (Nov 16 2019 at 17:47)</a>:</h4>
<p>OK, sure. Thanks!</p>

<a name="184491409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/184491409" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#184491409">Bryan Gin-ge Chen (Dec 30 2019 at 18:40)</a>:</h4>
<p>How does <code>rcases</code> / <code>rintro</code> with <code>rfl</code> in the pattern work? I couldn't find it documented anywhere.</p>

<a name="184491982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/184491982" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#184491982">Johan Commelin (Dec 30 2019 at 18:49)</a>:</h4>
<p>I you have some expression of the form <code>x = a</code>, then the <code>rfl</code> pattern works as if you just wrote <code>h</code>, and followed the <code>rcases</code>/<code>rintro</code> with a <code>subst h</code>.</p>

<a name="185168184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185168184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185168184">Greg Langmead (Jan 08 2020 at 23:15)</a>:</h4>
<p>Any tips on defining the unit sphere in Euclidean space? I'm using <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> 's definition <code>def euclidean_space (n : ℕ) : Type := (fin n → ℝ)</code> and can't figure out how to form the summation of the squares <code>def unit_sphere (n : ℕ) := { x : euclidean_space n // ...}</code></p>

<a name="185168392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185168392" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185168392">Kevin Buzzard (Jan 08 2020 at 23:18)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">def</span> <span class="n">euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span>

<span class="n">def</span> <span class="n">unit_sphere</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">euclidean_space</span> <span class="n">n</span> <span class="bp">//</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="err">^</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">}</span>
</pre></div>

<a name="185168426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185168426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185168426">Kevin Buzzard (Jan 08 2020 at 23:19)</a>:</h4>
<p>Maybe <code>def unit_sphere (n : ℕ) := { x : euclidean_space n // finset.univ.sum (λ i, (x i) ^ 2) = 1}</code> is a bit nicer.</p>

<a name="185168551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185168551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185168551">Kevin Buzzard (Jan 08 2020 at 23:22)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">finset.sum : Π {α : Type u_1} {β : Type u_2} [_inst_1 : add_comm_monoid β], finset α → (α → β) → β</span>
<span class="cm">-/</span>
</pre></div>


<p><code>finset.sum</code> eats a finite subset of alpha, and a function from alpha to a commutative monoid beta, and spits out the sum of this function over the given finite subset of alpha.</p>

<a name="185168826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185168826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185168826">Kevin Buzzard (Jan 08 2020 at 23:26)</a>:</h4>
<p><code>finset.univ</code> is all of the set alpha (which Lean figures out must be <code>fin n</code> by "unification"), and Lean also figures out that alpha is a finite type (by "type class inference")</p>

<a name="185170969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185170969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185170969">Nicholas Talin (Jan 08 2020 at 23:59)</a>:</h4>
<p>What would be the best introductory book on analysis if I wanted to use Lean to formalize its statements and solve exercises along the way?</p>

<a name="185175076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185175076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185175076">Greg Langmead (Jan 09 2020 at 01:11)</a>:</h4>
<p>Thank you Kevin, that works great. I will need to stare longer at <code>finset.univ</code>. Now I'll work towards proving these are smooth manifolds!</p>

<a name="185175386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185175386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185175386">Yury G. Kudryashov (Jan 09 2020 at 01:17)</a>:</h4>
<p><span class="user-mention" data-user-id="111038">@Greg Langmead</span> Would it be convenient to have the implicit function theorem first?</p>

<a name="185175487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185175487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185175487">Yury G. Kudryashov (Jan 09 2020 at 01:19)</a>:</h4>
<p>Then we would be able to prove that a smooth function defines a submanifold. Or you prefer to have some explicit set of charts (e.g., two stereographic projections)?</p>

<a name="185176362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185176362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185176362">Greg Langmead (Jan 09 2020 at 01:38)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> I'm planning on doing it both ways, i.e. with explicit charts, and then proving various more general things. I'm thinking along the lines of an introductory differential geometry text that is also an introduction to formalization.</p>

<a name="185184801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185184801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185184801">Andrew Ashworth (Jan 09 2020 at 05:29)</a>:</h4>
<p><span class="user-mention" data-user-id="256795">@Nicholas Talin</span> Several people have used Tao's Analysis 1 + 2; it's quite formal for an introductory text. You are on your own converting the lemmas and definitions to work with mathlib though, since it uses set theory as its foundations</p>

<a name="185186838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185186838" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185186838">Kevin Buzzard (Jan 09 2020 at 06:26)</a>:</h4>
<p>I dunno about "on your own" -- I for one would be very happy to help. And set theory/type theory hopefully shouldn't make too much of a difference here. I've proved basic analysis results about series/sequences etc in Lean, I think <span class="user-mention" data-user-id="110064">@Kenny Lau</span> proved Bolzano-Weierstrass somewhere, etc.</p>

<a name="185267588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185267588" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185267588">Yury G. Kudryashov (Jan 09 2020 at 23:22)</a>:</h4>
<p><span class="user-mention" data-user-id="111038">@Greg Langmead</span> I have a branch with  inverse function theorem (mostly done). I'm going to make a PR in a few days.</p>

<a name="185641416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185641416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185641416">Spencer Peters (Jan 14 2020 at 21:18)</a>:</h4>
<p>Hi everyone! I just got introduced to Lean through the natural number game, and I started playing around with writing up the first homework from a discrete math class I TA'd recently. In that homework, students were supposed to define a sudoku puzzle as a function f: {1, 2, ..., 9} x {1, 2, ..., 9} -&gt; {1, 2, ..., 9}. So I defined the subtype</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">nine</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">//</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="mi">9</span><span class="o">}</span>
</pre></div>


<p>Now I have two questions. First, although I can coerce a subtype of nat to nat, I can't seem to coerce a "nine" to a nat. What I mean is that this works:</p>
<div class="codehilite"><pre><span></span><span class="kn">constant</span> <span class="n">x</span> <span class="o">:</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">//</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="mi">9</span><span class="o">}</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="err">↑</span><span class="n">x</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span>
</pre></div>


<p>But this produces an error:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">nine</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">//</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">9</span><span class="o">}</span>
<span class="kn">constant</span> <span class="n">y</span> <span class="o">:</span> <span class="n">nine</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="err">↑</span><span class="n">y</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span>
</pre></div>


<p>Is there a line I can add which will cause all the typeclass instances of {x : ℕ // x &lt; 9} to carry over to the new type nine?<br>
My second question has to do with sets in Lean. In our discrete math class obviously we work with sets, not inductive types. So I would like the students to be able to work with something like (edited, set nine changed to set nat)</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">nine_set</span> <span class="o">:</span> <span class="n">set</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">}</span>
</pre></div>


<p>But if I then try to define a function from nine_set to nine_set, I run into the issue that nine_set is not a Type! I'm guessing that there isn't any way around this, but I thought I'd ask.</p>

<a name="185641729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185641729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185641729">Bryan Gin-ge Chen (Jan 14 2020 at 21:21)</a>:</h4>
<p>Welcome! You might find <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/theories/sets.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/theories/sets.md">this doc on "set-like objects" in mathlib</a> useful. I'll take a look at the more detailed questions later if no one else has gotten to them.</p>

<a name="185646746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185646746" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185646746">Kevin Buzzard (Jan 14 2020 at 22:15)</a>:</h4>
<p>We already have a type <code>fin 9</code>. You might be better off sticking with that.</p>
<p>You can add the coercion manually:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">nine</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">{</span><span class="n">v</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">//</span> <span class="n">v</span> <span class="bp">&lt;</span> <span class="mi">9</span><span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="n">nine</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span><span class="bp">.</span><span class="mi">1</span><span class="bp">⟩</span>

<span class="kn">constant</span> <span class="n">y</span> <span class="o">:</span> <span class="n">nine</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="c1">-- works</span>
</pre></div>


<p>The switch from finite sets to types will be painful. I constantly tell the student that a term of type <code>fin 9</code> is a pair consisting of a number and a proof, and eventually this will dawn on them.</p>

<a name="185652123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185652123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185652123">Spencer Peters (Jan 14 2020 at 23:17)</a>:</h4>
<p>Thanks Bryan! The mathlib doc was useful. And thank you Kevin! It's interesting that <code>fin 9</code> also has no coercion to nat by default, e.g. the following doesn't work:</p>
<div class="codehilite"><pre><span></span>constant z : fin 9
#check (↑z : ℕ)
</pre></div>


<p>That the switch will be painful doesn't surprise me--I also had some difficulty wrapping my head around the definition of a subtype. For context, I want to improve an introductory class for computer science majors who don't, by and large, have any background in formal math. My goal is to use Lean to help students understand formal math via their familiarity with programming. In my experience, students understand what it means for code to compile/not compile, but they don't understand as clearly what it means for a proof to be valid/invalid. In principle, Lean seems like a great way to bridge the gap, although in practice I'm not sure owing to the overhead of things like sets vs. inductive types. I'm also interested in using Lean as (or as the basis for) an interactive development environment for proofs, as an alternative to pencil and paper or TeX.</p>

<a name="185652335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185652335" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185652335">Kevin Buzzard (Jan 14 2020 at 23:20)</a>:</h4>
<p>Have you seen Avigad's <a href="https://leanprover.github.io/logic_and_proof/index.html" target="_blank" title="https://leanprover.github.io/logic_and_proof/index.html">Logic and proof</a>? Perhaps his students are similar to yours? I usually deal with mathematicians so have different problems -- they might well have some idea what a proof is, but have never seen a functional language or type theory before.</p>

<a name="185678659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185678659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185678659">Spencer Peters (Jan 15 2020 at 08:46)</a>:</h4>
<p>Yes, thanks for the pointer! This curriculum is similar to what I'd like to teach, although I can't afford to spend quite as much time on natural deduction and logic. In the course I'm working from (<a href="https://courses.cs.cornell.edu/cs2800/wiki/index.php/CS_2800_Fall_2019" target="_blank" title="https://courses.cs.cornell.edu/cs2800/wiki/index.php/CS_2800_Fall_2019">https://courses.cs.cornell.edu/cs2800/wiki/index.php/CS_2800_Fall_2019</a>), we have to quickly cover a lot of topics relevant to computer science, starting from sets, functions and relations. I'm hoping that I can set up something that will let students start working right away without detailed knowledge of the logical foundations (like the natural number game).</p>

<a name="185693188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185693188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185693188">Kevin Buzzard (Jan 15 2020 at 12:38)</a>:</h4>
<p>I did functions and relations in my course last term.Here are the example sheets:</p>
<p><a href="https://github.com/ImperialCollegeLondon/M40001_lean" target="_blank" title="https://github.com/ImperialCollegeLondon/M40001_lean">https://github.com/ImperialCollegeLondon/M40001_lean</a></p>

<a name="185697326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185697326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185697326">Kevin Buzzard (Jan 15 2020 at 13:34)</a>:</h4>
<p><span class="user-mention" data-user-id="243312">@Jason KY.</span> have you formalised some of the lecture notes in some form? Maybe Spencer would be interested.</p>

<a name="185698313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185698313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185698313">Jason KY. (Jan 15 2020 at 13:47)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="243312">Jason KY.</span> have you formalised some of the lecture notes in some form? Maybe Spencer would be interested.</p>
</blockquote>
<p>Emm, well I've formalised the first part of the intro module and am currently working on analysis but I've not written any comments for those parts.<br>
They are all here if anyone is interested :) <br>
<a href="https://github.com/JasonKYi/M4000x_LEAN_formalisation" target="_blank" title="https://github.com/JasonKYi/M4000x_LEAN_formalisation">https://github.com/JasonKYi/M4000x_LEAN_formalisation</a></p>

<a name="185698561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185698561" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185698561">Kevin Buzzard (Jan 15 2020 at 13:50)</a>:</h4>
<p>Spencer -- feel free to build on this stuff if it's of any use to you. Jason is one of my undergraduates; he took my class.</p>

<a name="185756654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185756654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185756654">Spencer Peters (Jan 15 2020 at 23:44)</a>:</h4>
<p>Thank you! I'll dig into these. Much appreciated :)</p>

<a name="185833027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185833027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185833027">Anton Lorenzen (Jan 16 2020 at 16:40)</a>:</h4>
<p>Do you know how I can tell Lean that for c, d, e in Prop and c decidable, "c -&gt; d" and "c -&gt; ite c d e" are the same type? Or lift a value of the first type to a value of the second? (This is my first post here, so I hope this is the right place to ask that)</p>

<a name="185835672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185835672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185835672">Joe (Jan 16 2020 at 17:04)</a>:</h4>
<p>Both of them have the type <code>Prop</code>. I guess you want to prove the following?</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">c</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">c</span> <span class="bp">→</span> <span class="n">d</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">c</span> <span class="bp">→</span> <span class="k">if</span> <span class="n">c</span> <span class="k">then</span> <span class="n">d</span> <span class="k">else</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span>
</pre></div>

<a name="185836033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185836033" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185836033">Anton Lorenzen (Jan 16 2020 at 17:08)</a>:</h4>
<p><span class="user-mention" data-user-id="127148">@Joe</span> Yes</p>

<a name="185836376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185836376" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185836376">Kevin Buzzard (Jan 16 2020 at 17:11)</a>:</h4>
<p>It's called something like <code>ifpos</code> [edit: <code>if_pos</code>]</p>

<a name="185836955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185836955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185836955">Joe (Jan 16 2020 at 17:17)</a>:</h4>
<p>Can you use tactics?</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">foo</span> <span class="o">(</span><span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">c</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">c</span> <span class="bp">→</span> <span class="n">d</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">c</span> <span class="bp">→</span> <span class="k">if</span> <span class="n">c</span> <span class="k">then</span> <span class="n">d</span> <span class="k">else</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">iff</span><span class="bp">.</span><span class="n">intro</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span> <span class="n">hc</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">hc</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="n">hc</span> <span class="o">})</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span> <span class="n">hc</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">hc</span><span class="o">,</span> <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">hc</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">})</span>
</pre></div>

<a name="185837091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/185837091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#185837091">Anton Lorenzen (Jan 16 2020 at 17:18)</a>:</h4>
<p>Got this with <code>if_pos</code>. Looks good!</p>
<div class="codehilite"><pre><span></span>lemma foo (c d e : Prop) [decidable c] : (c → d) ↔ (c → if c then d else e) :=
  iff.intro (λ f c, eq.mp (eq.symm (if_pos c)) (f c)) (λ f c, eq.mp (if_pos c) (f c))
</pre></div>

<a name="186586097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186586097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186586097">Greg Langmead (Jan 25 2020 at 19:48)</a>:</h4>
<p>I'm having trouble working with continuous functions on subsets of euclidean space. I think I lack some idiom. The first proof below is working for all of ℝ but the second gives an error because it needs some sort of coercion maybe?</p>
<div class="codehilite"><pre><span></span>import geometry.manifold.real_instances

lemma certain_func_is_continuous : continuous (λ x:ℝ, 4 * (x:ℝ)) :=
begin
  apply continuous.mul _ _,
  apply_instance,
  exact continuous_const,
  exact continuous_id,
end

def real_gt_one := {x: ℝ | x &gt; 1}

lemma certain_func_is_continuous_gtone : continuous (λ x:real_gt_one, 4 * (x:ℝ)) :=
begin
  apply continuous.mul _ _,
  apply_instance,
  exact continuous_const,
  exact continuous_id,
end
</pre></div>


<p>the error is</p>
<div class="codehilite"><pre><span></span>invalid type ascription, term has type
  continuous id
but is expected to have type
  continuous (λ (x : ↥real_gt_one), ↑x)
</pre></div>


<p>My short term goal is to define functions that are only continuous on the subset like 1/(1-x).</p>

<a name="186586405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186586405" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186586405">Alex J. Best (Jan 25 2020 at 19:58)</a>:</h4>
<p>Your function is from <code>real_gt_one</code> to <code>ℝ</code>, is that what you want? In this case your function at the end is not <code>id</code> the identity function but rather <code>coe</code> the coercion from <code>real_gt_one</code> to <code>ℝ</code>.</p>

<a name="186586410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186586410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186586410">Yury G. Kudryashov (Jan 25 2020 at 19:58)</a>:</h4>
<p>I guess you need <code>continuous_subtype_val</code></p>

<a name="186586414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186586414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186586414">Alex J. Best (Jan 25 2020 at 19:58)</a>:</h4>
<p>If you run <code>dsimp</code> before your last line lean simplifies your expression to show that the goal is <code>continuous coe</code> really.</p>

<a name="186586504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186586504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186586504">Yury G. Kudryashov (Jan 25 2020 at 20:01)</a>:</h4>
<p>BTW, I wonder if the following will work in most cases to automatically prove continuity: (1) mark many lemmas with <code>@[continuity]</code>, and (2) make a<code>continuity</code> tactic to be a shorthand for <code>apply_rules [continuity]</code>.</p>

<a name="186586551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186586551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186586551">Yury G. Kudryashov (Jan 25 2020 at 20:02)</a>:</h4>
<p>I have no time do give it a try in the next week or two.</p>

<a name="186586751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186586751" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186586751">Kevin Buzzard (Jan 25 2020 at 20:09)</a>:</h4>
<p>There was some talk about the continuity tactic in Pittsburgh</p>

<a name="186587797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186587797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186587797">Greg Langmead (Jan 25 2020 at 20:39)</a>:</h4>
<p>Thanks, dsimp and continuous_subtype_val helped. I am defining various real-valued functions so definitely want values in ℝ. Eventually I'll bring this back to stereographic projection which is my first mini-project.</p>
<p>With regard to making continuity easier to prove, it seems to me (disclaimer: a noob) that it's a heavy-handed paradigm to edit all the other files to mark various lemmas that might be useful. It feels like the wrong separation of concerns. I'm not sure what the alternative is, but is it possible to build up my own personal collections of often-used lemmas (and wildcard lemmas like "continuous*"), and have some tactic search among those?</p>

<a name="186588386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186588386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186588386">Greg Langmead (Jan 25 2020 at 20:56)</a>:</h4>
<p>To partially answer my own question, I see I can make a local attribute and add things to it per the <code>apply_rules</code> docs <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md">https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md</a>.</p>

<a name="186588843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186588843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186588843">Greg Langmead (Jan 25 2020 at 21:10)</a>:</h4>
<p>To keep running with this, if I define <code>my_continuity_lemmas : user_attribute</code> then I can do <code>apply_rules [my_continuity_lemmas]</code> but this won't prove my new lemmas by itself, I also need other tactics like <code>apply_instance</code>. Can I package up <code>apply_rules [my_continuity_lemmas]</code> as a tactic <code>apply_my_continuity_lemmas</code> so I could then do <code>chain [apply_instance, apply_my_continuity_lemmas]</code>? I have a sinking feeling I'm starting to talk nonsense.</p>

<a name="186592237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186592237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186592237">Yury G. Kudryashov (Jan 25 2020 at 22:58)</a>:</h4>
<p>Yes, you can create your own attribute. I was talking about a way to handle this everywhere in <code>mathlib</code>.</p>

<a name="186592248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186592248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186592248">Yury G. Kudryashov (Jan 25 2020 at 22:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Could you please tell me some details?</p>

<a name="186592391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186592391" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186592391">Kevin Buzzard (Jan 25 2020 at 23:03)</a>:</h4>
<p>I don't understand things well enough to be able to say anything coherent.</p>

<a name="186592624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186592624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186592624">Yury G. Kudryashov (Jan 25 2020 at 23:10)</a>:</h4>
<p>Then you can tag one of those who discussed this.</p>

<a name="186592626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186592626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186592626">Kevin Buzzard (Jan 25 2020 at 23:10)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> made some comments at some point...</p>

<a name="186592684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186592684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186592684">Joe (Jan 25 2020 at 23:12)</a>:</h4>
<p>I think that would work, except that tactics such as <code>apply</code> <code>refine</code> <code>exact</code> won't stop on the simplest cases. <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span></p>

<a name="186592689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186592689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186592689">Joe (Jan 25 2020 at 23:12)</a>:</h4>
<p>Here is an example I discovered a long time ago, where using <code>apply' continuous_tan'</code> on <code>continuous (λx, sin x)</code> results in a timeout. The root of this problem is <code>exact</code>, so I guess there is nothing you can do. Though I think there must be a way to make things irreducible or something, so that unifying mismatched expressions can end quickly.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">exponential</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">tidy</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">apply</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">apply_fun</span>

<span class="kn">namespace</span> <span class="n">real</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">)</span>
<span class="n">include</span> <span class="n">hf</span>

<span class="kn">lemma</span> <span class="n">continuous_tan&#39;</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">a</span><span class="o">,</span> <span class="n">cos</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span><span class="n">a</span><span class="o">,</span> <span class="n">tan</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">show</span> <span class="n">continuous</span> <span class="o">((</span><span class="n">tan</span> <span class="err">∘</span> <span class="bp">@</span><span class="n">subtype</span><span class="bp">.</span><span class="n">val</span> <span class="n">ℝ</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">cos</span> <span class="n">x</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">))</span> <span class="err">∘</span> <span class="bp">λ</span><span class="n">a</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">f</span> <span class="n">a</span><span class="o">,</span> <span class="n">h</span> <span class="n">a</span><span class="bp">⟩</span><span class="o">),</span>
  <span class="k">from</span> <span class="n">continuous</span><span class="bp">.</span><span class="n">comp</span> <span class="n">continuous_tan</span> <span class="o">(</span><span class="n">continuous_subtype_mk</span> <span class="bp">_</span> <span class="n">hf</span><span class="o">)</span>

<span class="kn">end</span> <span class="n">real</span>

<span class="kn">open</span> <span class="n">real</span>

<span class="kn">lemma</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,</span> <span class="n">sin</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">continuous_tan&#39;</span> <span class="n">ℝ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">this</span><span class="o">,</span>
  <span class="c1">-- apply&#39; this,</span>
  <span class="c1">-- refine this,</span>
  <span class="c1">-- apply this,</span>
<span class="kn">end</span>
</pre></div>

<a name="186593645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186593645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186593645">Reid Barton (Jan 25 2020 at 23:45)</a>:</h4>
<p>Yes, probably a case of excessive (and fruitless) definitional unfolding.</p>

<a name="186593915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186593915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186593915">Chris Hughes (Jan 25 2020 at 23:51)</a>:</h4>
<p>You can just set <code>tactic.apply</code> to only unfold reducibles right?</p>

<a name="186594496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186594496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186594496">Joe (Jan 26 2020 at 00:07)</a>:</h4>
<p>I don't know if that would work because <code>apply</code> is bugged. Even applying <code>continuous_sin'</code> to <code>continuous (λx, sin x)</code> fails.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">exponential</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">apply</span>

<span class="kn">namespace</span> <span class="n">real</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">)</span>
<span class="n">include</span> <span class="n">hf</span>

<span class="kn">lemma</span> <span class="n">continuous_sin&#39;</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span><span class="n">a</span><span class="o">,</span> <span class="n">sin</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">end</span> <span class="n">real</span>

<span class="kn">open</span> <span class="n">real</span>

<span class="kn">lemma</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,</span> <span class="n">sin</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">continuous_sin&#39;</span><span class="o">,</span>  <span class="c1">-- fails</span>
<span class="kn">end</span>
</pre></div>

<a name="186594570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186594570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186594570">Chris Hughes (Jan 26 2020 at 00:09)</a>:</h4>
<p>There's <code>apply'</code> which fixes the bug.</p>

<a name="186594571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186594571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186594571">Joe (Jan 26 2020 at 00:09)</a>:</h4>
<p>On the other hand, if you look at the source code of <code>apply'</code>, it tries <code>exact</code> first:</p>
<div class="codehilite"><pre><span></span><span class="kn">private</span> <span class="n">meta</span> <span class="n">def</span> <span class="n">retry_apply_aux</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">cfg</span> <span class="o">:</span> <span class="n">apply_cfg</span><span class="o">),</span> <span class="n">list</span> <span class="o">(</span><span class="n">bool</span> <span class="bp">×</span> <span class="n">name</span> <span class="bp">×</span>  <span class="n">expr</span><span class="o">)</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">list</span> <span class="o">(</span><span class="n">name</span> <span class="bp">×</span> <span class="n">expr</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">e</span> <span class="n">cfg</span> <span class="n">gs</span> <span class="o">:=</span>
<span class="n">focus1</span> <span class="o">(</span><span class="n">do</span> <span class="o">{</span>
     <span class="n">tgt</span> <span class="o">:</span> <span class="n">expr</span> <span class="err">←</span> <span class="n">target</span><span class="o">,</span> <span class="n">t</span> <span class="err">←</span> <span class="n">infer_type</span> <span class="n">e</span><span class="o">,</span>
     <span class="n">unify</span> <span class="n">t</span> <span class="n">tgt</span><span class="o">,</span>                             <span class="c1">-- apply&#39; is already stuck here</span>
     <span class="n">exact</span> <span class="n">e</span><span class="o">,</span>
     <span class="n">gs&#39;</span> <span class="err">←</span> <span class="n">get_goals</span><span class="o">,</span>
     <span class="k">let</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">reorder_goals</span> <span class="n">gs</span> <span class="n">cfg</span><span class="bp">.</span><span class="n">new_goals</span><span class="o">,</span>
     <span class="n">set_goals</span> <span class="o">(</span><span class="n">gs&#39;</span> <span class="bp">++</span> <span class="n">r</span><span class="bp">.</span><span class="n">map</span> <span class="n">prod</span><span class="bp">.</span><span class="n">snd</span><span class="o">),</span>
     <span class="n">return</span> <span class="n">r</span> <span class="o">})</span> <span class="bp">&lt;|&gt;</span>
<span class="n">do</span> <span class="o">(</span><span class="n">expr</span><span class="bp">.</span><span class="n">pi</span> <span class="n">n</span> <span class="n">bi</span> <span class="n">d</span> <span class="n">b</span><span class="o">)</span> <span class="err">←</span> <span class="n">infer_type</span> <span class="n">e</span> <span class="bp">&gt;&gt;=</span> <span class="n">whnf</span> <span class="bp">|</span> <span class="n">apply_core</span> <span class="n">e</span> <span class="n">cfg</span><span class="o">,</span>  <span class="c1">-- so it will never get here</span>
   <span class="n">v</span> <span class="err">←</span> <span class="n">mk_meta_var</span> <span class="n">d</span><span class="o">,</span>
   <span class="k">let</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">b</span><span class="bp">.</span><span class="n">has_var</span><span class="o">,</span>
   <span class="n">e</span> <span class="err">←</span> <span class="n">head_beta</span> <span class="err">$</span> <span class="n">e</span> <span class="n">v</span><span class="o">,</span>
   <span class="n">retry_apply_aux</span> <span class="n">e</span> <span class="n">cfg</span> <span class="o">((</span><span class="n">b</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="bp">::</span> <span class="n">gs</span><span class="o">)</span>
</pre></div>

<a name="186633171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186633171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186633171">Greg Langmead (Jan 26 2020 at 18:55)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> I was suggesting that instead of sprinkling @[continuity] hints around mathlib, there could be one file with packages of continuity lemmas being exported under various names. That seems more general than deciding in a one-size-fits-all fashion at the point where the lemma is defined.</p>

<a name="186633268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186633268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186633268">Greg Langmead (Jan 26 2020 at 18:58)</a>:</h4>
<p>Now I'm trying to define continuity of a function of two variables and I can't get <code>continuous_snd</code> to work with my subset of ℝ×ℝ:</p>
<div class="codehilite"><pre><span></span>lemma certain_twovar_func_continuous : continuous (λx:real_gt_one × real_gt_one, (x.1:ℝ) * (1 - (x.2:ℝ)⁻¹)) :=
begin
  apply continuous.mul _ _,
  apply_instance,
  sorry, -- writing &quot;apply continuous_snd&quot; here gives: invalid apply tactic, failed to unify continuous (λ (x : ↥real_gt_one × ↥real_gt_one), ↑(x.fst)) with continuous prod.snd
  apply continuous.sub,
  apply continuous_const,
  apply real.continuous.inv _ sorry,
  sorry,
end
</pre></div>

<a name="186633285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186633285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186633285">Greg Langmead (Jan 26 2020 at 18:59)</a>:</h4>
<p>I have an instance that indicates real_gt_one is a topological_space but somehow continous_snd is not type matching. Is it because I am using a lambda?</p>

<a name="186633427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186633427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186633427">Joe (Jan 26 2020 at 19:03)</a>:</h4>
<p>Looking at the error message. it seems that you should apply <code>continuous_fst</code>?</p>

<a name="186633576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186633576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186633576">Joe (Jan 26 2020 at 19:07)</a>:</h4>
<p>Also there is a coercion sign, so perhaps you can try <code>refine continuous.comp _ _</code> and see what comes out.</p>

<a name="186633962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186633962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186633962">Greg Langmead (Jan 26 2020 at 19:18)</a>:</h4>
<p>Sorry yes continuous_fst is what I should be using, and gives me the error, and I prepared my post with _snd by mistake.</p>
<div class="codehilite"><pre><span></span>invalid apply tactic, failed to unify continuous (λ (x : ↥real_gt_one × ↥real_gt_one), ↑(x.fst)) with continuous prod.snd
</pre></div>


<p>I didn't succeed yet with continuous.comp, will keep trying.</p>

<a name="186634222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186634222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186634222">Alex J. Best (Jan 26 2020 at 19:24)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">certain_twovar_func_continuous</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">:</span><span class="n">real_gt_one</span> <span class="bp">×</span> <span class="n">real_gt_one</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">:</span><span class="n">ℝ</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">-</span> <span class="o">(</span><span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="o">:</span><span class="n">ℝ</span><span class="o">)</span><span class="bp">⁻¹</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">continuous</span><span class="bp">.</span><span class="n">mul</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">apply_instance</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">continuous</span><span class="bp">.</span><span class="n">comp</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">continuous_subtype_val</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">continuous_fst</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">continuous</span><span class="bp">.</span><span class="n">sub</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">continuous_const</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">real</span><span class="bp">.</span><span class="n">continuous</span><span class="bp">.</span><span class="n">inv</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">intros</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:=</span> <span class="n">a</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="n">intro</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">continuous</span><span class="bp">.</span><span class="n">comp</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">continuous_subtype_val</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">continuous_snd</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>now I got stuck proving that <code>a.snd.val \ne 0</code></p>

<a name="186634383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186634383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186634383">Joe (Jan 26 2020 at 19:28)</a>:</h4>
<p><span class="user-mention" data-user-id="111038">@Greg Langmead</span> I guess you can take a look at how <code>nnreal</code> is defined?</p>

<a name="186634394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186634394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186634394">Joe (Jan 26 2020 at 19:29)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="n">nnreal</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">nnreal</span><span class="bp">.</span><span class="n">continuous_coe</span>
</pre></div>

<a name="186684775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186684775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186684775">Greg Langmead (Jan 27 2020 at 14:15)</a>:</h4>
<p><span class="user-mention" data-user-id="127136">@Alex J. Best</span> I'm stuck there too. I'm having trouble getting from being an element of <code>real_gt_one</code> to being <code>&gt; 1</code>. All <code>real_gt_one</code> is is a function to <code>Prop</code> and I can't discover the paradigm for accessing the values for which that Prop is true.</p>

<a name="186685967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186685967" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186685967">Kevin Buzzard (Jan 27 2020 at 14:27)</a>:</h4>
<p><code>real_gt_one</code> gets promoted to a type here, because you have terms of that type. So it's not a function to Prop when you use it (there is probably a little up-arrow next to it indicating the promotion). If x has type <code>real_gt_one</code> then <code>x.2</code> will be a proof that <code>x.1&gt;1</code>.</p>

<a name="186686143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186686143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186686143">Alex J. Best (Jan 27 2020 at 14:29)</a>:</h4>
<p>Yeah I ended up getting stuck with <code>x.1</code> vs <code>x.val</code> vs <code>\u x</code> or some other silliness, that exact mod cast didn't want to blast through for me.</p>

<a name="186686640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186686640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186686640">Johan Commelin (Jan 27 2020 at 14:34)</a>:</h4>
<p>Those should all be definitionally equal...</p>

<a name="186686706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186686706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186686706">Johan Commelin (Jan 27 2020 at 14:34)</a>:</h4>
<p>Can you paste code?</p>

<a name="186687367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186687367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186687367">Kevin Buzzard (Jan 27 2020 at 14:41)</a>:</h4>
<div class="codehilite"><pre><span></span>  <span class="k">have</span> <span class="o">:=</span> <span class="n">a</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span><span class="o">,</span>
    <span class="n">change</span> <span class="o">(</span><span class="n">a</span><span class="bp">.</span><span class="n">snd</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="mi">1</span> <span class="n">at</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">linarith</span> <span class="o">},</span>
</pre></div>

<a name="186713430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186713430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186713430">Jonathan Sejr (Jan 27 2020 at 18:54)</a>:</h4>
<p>Hi, I am working on the natural numbers game (great stuff btw), and am currently stuck at advanced addition world l. 13. I am having trouble manipulating the expressions when my goal is <code>false</code>. My code so far is <br>
<code>python
  intro h,
  rw succ_eq_add_one at h,
  rw ← zero_add(n) at h,
  rw add_comm at h,
  rw ← add_comm(0) at h,
  rw add_assoc at h,
  rw zero_add(n+1) at h,
  rw ← add_comm(1) at h,
  rw one_eq_succ_zero at h,
  </code><br>
 Leaving me with <code>n : mynat, h : 0 + n = succ 0 + n ⊢ false</code> I want to use <code>add_right_cancel</code> to get <code>0=succ 0</code> and then finish off the goal. But I cannot <code>apply add_right_cancel</code>because the goal is just a false proposition. <br>
I am really lost on how to manipulate a false goal, so any tips are appreciated.</p>

<a name="186713715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186713715" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186713715">Kevin Buzzard (Jan 27 2020 at 18:57)</a>:</h4>
<p><code>add_right_cancel</code> is a theorem of the form "if m+p=n+p then m=n"</p>

<a name="186713789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186713789" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186713789">Kevin Buzzard (Jan 27 2020 at 18:58)</a>:</h4>
<p>so it's actually a function which eats a proof of m+p=n+p and spits out a proof of m=n</p>

<a name="186713814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186713814" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186713814">Kevin Buzzard (Jan 27 2020 at 18:58)</a>:</h4>
<p>so instead of manipulating the goal, you can make a new hypothesis</p>

<a name="186713979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186713979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186713979">Kevin Buzzard (Jan 27 2020 at 19:00)</a>:</h4>
<p><code>have h2 := add_right_cancel _ _ _ h,</code> would give you <code>h2 : 0 = 1</code></p>

<a name="186714000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186714000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186714000">Kevin Buzzard (Jan 27 2020 at 19:00)</a>:</h4>
<p>oh great and then you can use zero_ne_succ</p>

<a name="186714628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186714628" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186714628">Jonathan Sejr (Jan 27 2020 at 19:07)</a>:</h4>
<p>I was actually trying have, but didn't get that I should tag an h at the end thanks! And now I am unsure how to finish it, <code>h2 : 0 = 1</code>should now be a false statement so I should be able to finish with <code>exact h2</code>, but that doesn't work. <br>
Edit: One finishes off with<br>
<code>have h3 := zero_ne_succ _ h2,
  exact h3,</code><br>
because <code>h3</code> will be <code>false </code>.</p>

<a name="186719188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186719188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186719188">Kevin Buzzard (Jan 27 2020 at 19:57)</a>:</h4>
<p>Remember that lots of things are functions</p>

<a name="186719252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186719252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186719252">Kevin Buzzard (Jan 27 2020 at 19:58)</a>:</h4>
<p>A not= B is the same as (A=B) -&gt; false</p>

<a name="186719371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186719371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186719371">Kevin Buzzard (Jan 27 2020 at 19:59)</a>:</h4>
<p>You can probably just do <code>exact zero_ne_succ _ h2</code></p>

<a name="186719395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186719395" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186719395">Kevin Buzzard (Jan 27 2020 at 19:59)</a>:</h4>
<p>And you can probably go a step further back</p>

<a name="186789519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186789519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186789519">Alex Kontorovich (Jan 28 2020 at 14:52)</a>:</h4>
<p>Hi all, I'm a mathematician, completely new to Lean. Finally followed Kevin's advice and joined here (so I don't have to bug him directly for help). To get started, I want to formalize that the square of an odd number is odd. Here's what I came up with for a statement:</p>
<p>lemma square_of_odd_is_odd : ∀ n : ℕ, (∃ k : ℕ, n=2<em>k+1) -&gt; (∃ l : ℕ, n</em>n = 2*l+1) :=<br>
begin<br>
    intro n,<br>
    intro p,</p>
<p>At this point I'm stuck. How do I tell it to use <em>that</em> k and stick it in to n?</p>

<a name="186789576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186789576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186789576">Kenny Lau (Jan 28 2020 at 14:52)</a>:</h4>
<div class="codehilite"><pre><span></span>```lean
[some lean code]
```
</pre></div>

<a name="186789611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186789611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186789611">Kenny Lau (Jan 28 2020 at 14:53)</a>:</h4>
<p>you can do <code>cases p</code></p>

<a name="186789971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186789971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186789971">Alex Kontorovich (Jan 28 2020 at 14:56)</a>:</h4>
<p>Ok great, thanks! Then  </p>
<p>use 2*p_w^2+2*p_w,</p>
<p>Then how do I apply p_h?</p>

<a name="186790384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186790384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186790384">Johan Commelin (Jan 28 2020 at 15:00)</a>:</h4>
<p>I would suggest <code>cases p with k p</code></p>

<a name="186790391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186790391" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186790391">Johan Commelin (Jan 28 2020 at 15:00)</a>:</h4>
<p>To get nicer names</p>

<a name="186790429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186790429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186790429">Johan Commelin (Jan 28 2020 at 15:01)</a>:</h4>
<p>After that, you are looking for <code>rw p_h</code> (or <code>rw p</code>, if you change the <code>cases</code>)</p>

<a name="186790564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186790564" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186790564">Johan Commelin (Jan 28 2020 at 15:02)</a>:</h4>
<p>Alternative: <code>subst n</code>. This will look for <code>n = ...</code> in you context, and replace all occurences of <code>n</code> with <code>...</code></p>

<a name="186790567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186790567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186790567">Alex Kontorovich (Jan 28 2020 at 15:02)</a>:</h4>
<p>Ah yes, rw! Thanks. Now shouldn't simp do the algebra for me and finish? </p>
<p>Let's see if this works:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">square_of_odd_is_odd</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">n</span><span class="bp">=</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">l</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">n</span><span class="bp">*</span><span class="n">n</span> <span class="bp">=</span> <span class="mi">2</span><span class="bp">*</span><span class="n">l</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">p</span> <span class="k">with</span> <span class="n">k</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">use</span> <span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="err">^</span><span class="mi">2</span><span class="bp">+</span><span class="mi">2</span><span class="bp">*</span><span class="n">k</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="186790644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186790644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186790644">Johan Commelin (Jan 28 2020 at 15:03)</a>:</h4>
<p>I don't think <code>simp</code> will do that for you. But <code>ring</code> should.</p>

<a name="186790671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186790671" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186790671">Alex Kontorovich (Jan 28 2020 at 15:03)</a>:</h4>
<p>Yes! Works! Thanks that's great!</p>

<a name="186790688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186790688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186790688">Johan Commelin (Jan 28 2020 at 15:03)</a>:</h4>
<p>You might need <code>import tactic</code> at the top of your file.</p>

<a name="186799301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186799301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186799301">Sam Stites (Jan 28 2020 at 16:31)</a>:</h4>
<p>Super dumb question (I've never touched a theorem prover before, just going through the lean book now -- apologies in advance). I'm wondering if lean4 (or maybe even in lean3) you can construct objects via a C/C++ FFI. This was a feature that I noticed in other theorem provers, but haven't seen anywhere in the lean docs.</p>

<a name="186799373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186799373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186799373">Johan Commelin (Jan 28 2020 at 16:32)</a>:</h4>
<p>Lean 3, not really<br>
Lean 4, yep, that's the plan</p>

<a name="186799549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186799549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186799549">Sam Stites (Jan 28 2020 at 16:34)</a>:</h4>
<p>very cool! could you give a rough idea of when we can expect lean4?</p>

<a name="186799636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186799636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186799636">Johan Commelin (Jan 28 2020 at 16:34)</a>:</h4>
<p>Not really... maybe end of this year. Maybe next year...</p>

<a name="186799672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186799672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186799672">Johan Commelin (Jan 28 2020 at 16:34)</a>:</h4>
<p>It's open source. Some parts are already usable.</p>

<a name="186799714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186799714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186799714">Johan Commelin (Jan 28 2020 at 16:35)</a>:</h4>
<p>But the tactic framework isn't there yet. So for maths (my field) it isn't really usable yet.</p>

<a name="186800048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186800048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186800048">Sam Stites (Jan 28 2020 at 16:37)</a>:</h4>
<p>that's a good enough estimate for me!</p>

<a name="186800120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186800120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186800120">Sam Stites (Jan 28 2020 at 16:38)</a>:</h4>
<p><del>Would the google groups be the best way to track progress? or perhaps the releases on github?</del> nevermind! just going to do both. Thanks!</p>

<a name="186859552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186859552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186859552">ROCKY KAMEN-RUBIO (Jan 29 2020 at 06:28)</a>:</h4>
<p>Hi everyone, I'm a new Lean user and trying to work through some of the code in Kevin's lecture tutorial. I'm trying to define is_even using the inductive type like he does, but keep getting this error. Does anyone know what's causing this? Thanks! <a href="/user_uploads/3121/egU32wKRgssM-qiK5EW73T7-/Screen-Shot-2020-01-29-at-1.26.38-AM.png" target="_blank" title="Screen-Shot-2020-01-29-at-1.26.38-AM.png">Screen-Shot-2020-01-29-at-1.26.38-AM.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/egU32wKRgssM-qiK5EW73T7-/Screen-Shot-2020-01-29-at-1.26.38-AM.png" target="_blank" title="Screen-Shot-2020-01-29-at-1.26.38-AM.png"><img src="/user_uploads/3121/egU32wKRgssM-qiK5EW73T7-/Screen-Shot-2020-01-29-at-1.26.38-AM.png"></a></div>

<a name="186859734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186859734" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186859734">Alex J. Best (Jan 29 2020 at 06:33)</a>:</h4>
<p>I think you are missing the bar character <code>|</code> at the start of each line</p>

<a name="186859738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186859738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186859738">Alex J. Best (Jan 29 2020 at 06:33)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">is_even</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">is_even</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">step</span> <span class="o">{</span><span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_even</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">is_even</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span>
</pre></div>

<a name="186947981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186947981" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186947981">Nicholas Talin (Jan 30 2020 at 01:42)</a>:</h4>
<p>Are there versioned tarball releases of Mathlib? I made an XBPS template for Lean itself and would like to make one for Mathlib too. It looks like the latest releases in the repo are from 2019.</p>

<a name="186948092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186948092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186948092">Bryan Gin-ge Chen (Jan 30 2020 at 01:44)</a>:</h4>
<p>The <a href="https://github.com/leanprover-community/mathlib-nightly/releases" target="_blank" title="https://github.com/leanprover-community/mathlib-nightly/releases">mathlib-nightly releases</a> may have what you want.</p>

<a name="186958670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186958670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186958670">Johan Commelin (Jan 30 2020 at 06:38)</a>:</h4>
<p><span class="user-mention" data-user-id="256795">@Nicholas Talin</span> Cool! I'm also using Void. Haven't yet looked into making XBPS templates though. Thanks for doing this. It might be useful to create a template for the supporting tools <code>cache-olean</code> and <code>update-mathlib</code>. Because if you have 10 Lean projects you might want them to depend on 10 different versions of mathlib. In practice a global mathlib install isn't used very much by most people in the community.</p>

<a name="186966397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186966397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186966397">Nicholas Talin (Jan 30 2020 at 09:23)</a>:</h4>
<p>Since it looks like both scripts are in PyPI's mathlibtools, I guess the Lean template is all that's needed.</p>

<a name="186967699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186967699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186967699">Nicholas Talin (Jan 30 2020 at 09:44)</a>:</h4>
<p>Should I be using 3.4.2 instead of 3.5.0?</p>

<a name="186968915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186968915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186968915">Johan Commelin (Jan 30 2020 at 10:00)</a>:</h4>
<p>We are in the middle of a transition to 3.5c</p>

<a name="186968968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/186968968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#186968968">Johan Commelin (Jan 30 2020 at 10:01)</a>:</h4>
<p><span class="user-mention" data-user-id="256795">@Nicholas Talin</span> So I think you're good when you stick with that.</p>

<a name="187010867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187010867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187010867">Mason Marche (Jan 30 2020 at 17:43)</a>:</h4>
<p>Is there a stream for troubleshooting installation? I'm having an issue with the mathlib</p>

<a name="187010994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187010994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187010994">Scott Morrison (Jan 30 2020 at 17:44)</a>:</h4>
<p>Right here!</p>

<a name="187011175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187011175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187011175">Kevin Buzzard (Jan 30 2020 at 17:46)</a>:</h4>
<p>Are you following <a href="https://github.com/leanprover-community/mathlib#installation" target="_blank" title="https://github.com/leanprover-community/mathlib#installation">https://github.com/leanprover-community/mathlib#installation</a> ?</p>

<a name="187011235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187011235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187011235">Mason Marche (Jan 30 2020 at 17:47)</a>:</h4>
<p>Right now I'm on macos and it looks like I've done everything correctly to install and build mathlib, but for some reason, VScode gives me the error 'Unknown Identifier Q' whenever I type \Q</p>

<a name="187011272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187011272" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187011272">Kevin Buzzard (Jan 30 2020 at 17:47)</a>:</h4>
<p>Did you import <code>data.rat</code> or <code>data.rat.basic</code> or whatever it's called now?</p>

<a name="187011390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187011390" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187011390">Kevin Buzzard (Jan 30 2020 at 17:48)</a>:</h4>
<p>(probably either work now)</p>

<a name="187011397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187011397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187011397">Mason Marche (Jan 30 2020 at 17:48)</a>:</h4>
<p>That fixed it, thanks!</p>

<a name="187011447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187011447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187011447">Kevin Buzzard (Jan 30 2020 at 17:49)</a>:</h4>
<p>If that worked then you're almost certainly up and running.</p>

<a name="187011509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187011509" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187011509">Mason Marche (Jan 30 2020 at 17:49)</a>:</h4>
<p>It looks like I am</p>

<a name="187045896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187045896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187045896">Mason Marche (Jan 31 2020 at 00:15)</a>:</h4>
<p>Second dumb question, what's the library I need to import to access real numbers (ℝ)?</p>

<a name="187045974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187045974" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187045974">Yury G. Kudryashov (Jan 31 2020 at 00:16)</a>:</h4>
<p>data.real.basic</p>

<a name="187045998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187045998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187045998">Mason Marche (Jan 31 2020 at 00:16)</a>:</h4>
<p>thank you</p>

<a name="187046307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187046307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187046307">Chris B (Jan 31 2020 at 00:22)</a>:</h4>
<p>Is the implementation of <code>nat.sqrt</code>/<code>nat.sqrt_aux</code> in mathlib original or is there somewhere I can read about it? I don't interact with bitwise stuff very frequently and I'm curious why it works the way it does.</p>

<a name="187049207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187049207" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187049207">Daniel Keys (Jan 31 2020 at 01:16)</a>:</h4>
<p>Just starting chapter 4 in "Theorem proving with Lean". How does one produce an arbitrary element of type <code>α</code> in this example (among the exercises)?</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kn">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kn">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intro</span> <span class="n">pr</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="bp">_</span> <span class="n">pr</span>
<span class="kn">end</span>
</pre></div>

<a name="187049488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187049488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187049488">Jeremy Avigad (Jan 31 2020 at 01:22)</a>:</h4>
<p>If the exercise doesn't give t to you, it is a mistake: you need something like <code>variable a : α</code> in the assumptions. In Lean, types can be empty.</p>

<a name="187049522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187049522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187049522">Daniel Keys (Jan 31 2020 at 01:23)</a>:</h4>
<p>There is a <code>variable a : α</code>, but how can I make use of it inside the example?</p>

<a name="187049637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187049637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187049637">Chris B (Jan 31 2020 at 01:26)</a>:</h4>
<p>If you have <code>variable a : α</code> somewhere, you need to put <code>include &lt;variable name&gt;</code> above the term if you want to use variables in tactic blocks (between the <code>begin</code> and <code>end</code>)</p>
<div class="codehilite"><pre><span></span>variable α : Type
variable r : Prop
variable a : α

include a
example : r → (∃ x : α, r) :=
begin
    intro pr,
    exact exists.intro a pr
end
</pre></div>

<a name="187049671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187049671" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187049671">Chris B (Jan 31 2020 at 01:26)</a>:</h4>
<p>But in the snippet you only have <code>variable α : Type</code>.</p>

<a name="187049697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187049697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187049697">Bryan Gin-ge Chen (Jan 31 2020 at 01:27)</a>:</h4>
<p>You can also refer to <code>a</code> if you write the proof in term mode:</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="kn">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kn">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">hr</span><span class="o">,</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">a</span> <span class="n">hr</span>
</pre></div>

<a name="187049784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187049784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187049784">Daniel Keys (Jan 31 2020 at 01:29)</a>:</h4>
<p>Thanks! Including <code>a</code>, this is what I was missing! I edited the snippet and added <code>a</code> to the variables.</p>

<a name="187049866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187049866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187049866">Chris B (Jan 31 2020 at 01:31)</a>:</h4>
<p>There's some more detail and some stuff explaining why you actually need the include/omit bits in the Lean reference manual at the bottom of p. 37.</p>

<a name="187050300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187050300" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187050300">Bryan Gin-ge Chen (Jan 31 2020 at 01:41)</a>:</h4>
<p>There's a discussion in <a href="https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#more-on-sections" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#more-on-sections">6.2</a> of TPiL as well.</p>

<a name="187072741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187072741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187072741">Mario Carneiro (Jan 31 2020 at 10:45)</a>:</h4>
<blockquote>
<p>Is the implementation of <code>nat.sqrt</code>/<code>nat.sqrt_aux</code> in mathlib original or is there somewhere I can read about it? I don't interact with bitwise stuff very frequently and I'm curious why it works the way it does.</p>
</blockquote>
<p><span class="user-mention" data-user-id="228466">@Chris B</span>  I think I am the one responsible for the current implementation of <code>nat.sqrt</code>. I am pretty sure I got it from a wikipedia article, and I think it is the "iterative algorithm" mentioned <a href="https://en.wikipedia.org/wiki/Integer_square_root#Using_bitwise_operations" target="_blank" title="https://en.wikipedia.org/wiki/Integer_square_root#Using_bitwise_operations">here</a>.</p>

<a name="187072894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187072894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187072894">Mario Carneiro (Jan 31 2020 at 10:47)</a>:</h4>
<p>I'm not finding the description I originally worked from, the ones I can find all look different</p>

<a name="187073046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187073046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187073046">Mario Carneiro (Jan 31 2020 at 10:50)</a>:</h4>
<p>Aha, it is the <code>isqrt()</code> function given here: <a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Example_3" target="_blank" title="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Example_3">Methods of computing square roots</a></p>

<a name="187075297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187075297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187075297">Kevin Buzzard (Jan 31 2020 at 11:30)</a>:</h4>
<p>Aah, the old "bring digits down two at a time" method -- this is the method my father taught me for computing square roots by hand, although he used base 10.</p>

<a name="187215771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187215771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187215771">Daniel Keys (Feb 02 2020 at 18:58)</a>:</h4>
<p>Hi all, is there a way to write the lambda expression I'm using below in more of a tactics mode style? </p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kn">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kn">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="n">include</span> <span class="n">a</span>
<span class="kn">theorem</span> <span class="n">T10L</span> <span class="o">:</span> <span class="o">((</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intros</span> <span class="n">Axpx_r</span><span class="o">,</span>
    <span class="n">cases</span> <span class="o">(</span> <span class="n">em</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">)</span> <span class="k">with</span> <span class="n">Axpx</span> <span class="n">nAxpx</span><span class="o">,</span>
    <span class="o">{</span> <span class="c1">-- case ax</span>
        <span class="n">exact</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">a</span> <span class="o">(</span> <span class="bp">λ</span> <span class="n">w</span><span class="o">,</span> <span class="n">Axpx_r</span> <span class="n">Axpx</span> <span class="o">)</span>
    <span class="o">},</span>
    <span class="o">{</span> <span class="n">sorry</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="187217011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187217011" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187217011">Kevin Buzzard (Feb 02 2020 at 19:39)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">T10L</span> <span class="o">:</span> <span class="o">((</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intros</span> <span class="n">Axpx_r</span><span class="o">,</span>
    <span class="n">cases</span> <span class="o">(</span> <span class="n">em</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">)</span> <span class="k">with</span> <span class="n">Axpx</span> <span class="n">nAxpx</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">use</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">w</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">Axpx_r</span><span class="o">,</span>
      <span class="n">assumption</span>
    <span class="o">},</span>
    <span class="o">{</span> <span class="n">sorry</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>But <code>use</code> is a lean tactic from the maths library so you'll need <code>import tactic</code> at the top of your file (and mathlib).</p>
<p>Without mathlib you can just write <code>existsi</code> instead of <code>use</code>, but <code>existsi</code> doesn't work so well as an introduction rule for more complicated existential statements.</p>

<a name="187217142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187217142" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187217142">Daniel Keys (Feb 02 2020 at 19:43)</a>:</h4>
<p>Thanks Kevin! I did see similar things in the number game, but apparently I need some more work before it sinks.</p>

<a name="187217158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187217158" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187217158">Kevin Buzzard (Feb 02 2020 at 19:43)</a>:</h4>
<p>This software has a huge learning curve.</p>

<a name="187217201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187217201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187217201">Kevin Buzzard (Feb 02 2020 at 19:44)</a>:</h4>
<p>It's worth the climb though ;-)</p>

<a name="187217502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187217502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187217502">Daniel Keys (Feb 02 2020 at 19:53)</a>:</h4>
<p>I'm having a very good time learning it, too bad I can basically only use the weekends. The community is very helpful though!</p>

<a name="187459101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187459101" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187459101">Paul van Wamelen (Feb 05 2020 at 14:45)</a>:</h4>
<p>Ultra noob question: Why can't I prove that x^2 = x * x over the integers?</p>
<div class="codehilite"><pre><span></span>variable x : ℤ
#reduce x + (-6)^2

example (x : ℤ) : x = x := by refl

example (x : ℤ) : x^2 = x * x := by simp
</pre></div>


<p>Gives <code>simplify tactic failed to simplify</code>. Actually with <code>import data.int.basic</code> the -6 doesn't even reduce. Using <code>import data.zmod.basic</code> reduces -6, but not (apparently) x^2. What am I missing? Any clues would be greatly appreciated!</p>

<a name="187459584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187459584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187459584">Kevin Buzzard (Feb 05 2020 at 14:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group_power</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span><span class="err">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">library_search</span>
<span class="c1">-- exact pow_two x</span>
</pre></div>

<a name="187459655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187459655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187459655">Kevin Buzzard (Feb 05 2020 at 14:51)</a>:</h4>
<p>and indeed <code>pow_two</code> hasn't been tagged with the <code>simp</code> attribute, so <code>simp</code> doesn't know about this lemma.</p>

<a name="187460015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187460015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187460015">Kevin Buzzard (Feb 05 2020 at 14:55)</a>:</h4>
<p>If you only import <code>data.int.basic</code> then you don't get the function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">a^b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">a\in\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">b\in\mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span>. This is because the definition of the power function is made for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> in an arbitrary monoid and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">b\in\mathbb{N}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span>, so you have to import some group theory library to get it, not the integer library!</p>

<a name="187461882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187461882" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187461882">Paul van Wamelen (Feb 05 2020 at 15:14)</a>:</h4>
<p>Got it! Thanks! I think I'm going to have some follow up questions though :)</p>

<a name="187462184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187462184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187462184">Kevin Buzzard (Feb 05 2020 at 15:17)</a>:</h4>
<p>I've been having followup questions since 2017 ;-)</p>

<a name="187462241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187462241" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187462241">Kevin Buzzard (Feb 05 2020 at 15:18)</a>:</h4>
<p>it turns out that some stuff that mathematicians think of as "should be straightforward" is actually an interesting research project in the formal proof verification community.</p>

<a name="187462593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187462593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187462593">Kevin Buzzard (Feb 05 2020 at 15:21)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group_power</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">pow_two</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span><span class="err">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span>
</pre></div>


<p>I am not 100% clear about why <code>pow_two</code> is not tagged with <code>simp</code>, but <code>simp</code>-tagging is a subtle issue best left to those who know a lot more computer science than me -- I don't really understand the algorithm. All I know is that tagging everything with <code>simp</code> is a bad idea.</p>

<a name="187462738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187462738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187462738">Chris Hughes (Feb 05 2020 at 15:22)</a>:</h4>
<p><code>by ring</code> should work here, or perhaps <code>by abel</code> if it has been updated to deal with multiplicative monoids.</p>

<a name="187469288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187469288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187469288">JDM (Feb 05 2020 at 16:28)</a>:</h4>
<p>Hi people, it's been a while since I have done anything concerning Lean but I am back with renewed interest. Back when I took notice there was no real way to get it working with Windows and I didn't have a reasonble option to use Linux, but now I do. So as a complete and utter noob with building things on Linux: how do I go about this?</p>

<a name="187469342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187469342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187469342">Patrick Massot (Feb 05 2020 at 16:28)</a>:</h4>
<p>Don't build it.</p>

<a name="187469396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187469396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187469396">JDM (Feb 05 2020 at 16:29)</a>:</h4>
<p>Okay, in that case, are there detailed installation instructions?</p>

<a name="187469428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187469428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187469428">Johan Commelin (Feb 05 2020 at 16:29)</a>:</h4>
<p>Yes, see github readme</p>

<a name="187469445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187469445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187469445">Johan Commelin (Feb 05 2020 at 16:29)</a>:</h4>
<p>Lemme fetch the link</p>

<a name="187469533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187469533" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187469533">Johan Commelin (Feb 05 2020 at 16:30)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib#installation" target="_blank" title="https://github.com/leanprover-community/mathlib#installation">https://github.com/leanprover-community/mathlib#installation</a></p>

<a name="187469592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187469592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187469592">JDM (Feb 05 2020 at 16:31)</a>:</h4>
<p>Oh, that's great, thanks a lot!</p>

<a name="187469613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187469613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187469613">Johan Commelin (Feb 05 2020 at 16:31)</a>:</h4>
<p>We actually went through a transition to a new version of Lean <em>today</em></p>

<a name="187469637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187469637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187469637">Johan Commelin (Feb 05 2020 at 16:31)</a>:</h4>
<p>For the first time in ~ 2 years</p>

<a name="187469657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187469657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187469657">JDM (Feb 05 2020 at 16:31)</a>:</h4>
<p>Seems like a good time to get started then</p>

<a name="187469675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187469675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187469675">Johan Commelin (Feb 05 2020 at 16:31)</a>:</h4>
<p>So let's hope the instructions still work</p>

<a name="187469691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187469691" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187469691">JDM (Feb 05 2020 at 16:31)</a>:</h4>
<p>That's a good point :-D</p>

<a name="187469797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187469797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187469797">Johan Commelin (Feb 05 2020 at 16:32)</a>:</h4>
<p>If anything goes wrong, please report here <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>

<a name="187469884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187469884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187469884">JDM (Feb 05 2020 at 16:33)</a>:</h4>
<p>Will do, I'm absolutely thrilled in any case :-)</p>

<a name="187469885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187469885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187469885">Rob Lewis (Feb 05 2020 at 16:33)</a>:</h4>
<blockquote>
<p>For the first time in ~ 2 years</p>
</blockquote>
<p>That's not really true, 3.4.2 moved some stuff from core to mathlib and that was done about a year ago. But this is the first time we're pointing to a version of Lean off the official leanprover site, and the first time with a lot of the supporting tools.</p>

<a name="187470030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187470030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187470030">Johan Commelin (Feb 05 2020 at 16:35)</a>:</h4>
<p>Ok, maybe I was exagerating. Your explanation is more exciting anyway <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p>

<a name="187543560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187543560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187543560">Matt E (Feb 06 2020 at 12:31)</a>:</h4>
<p>is there a way to "unfold" what a tactic is doing in a particular case? for example I can prove <code>x \in {x}</code> by <code>finish</code> (which is how <code>set.mem_singleton</code> is defined), but I'm a bit curious what's going on there</p>

<a name="187544991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187544991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187544991">Cerek Hillen (he) (W2'20) (Feb 06 2020 at 12:53)</a>:</h4>
<p>Not sure if this is exactly what you want, but you could do <code>#check</code> on the theorem that includes it?</p>

<a name="187549813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187549813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187549813">Daniel Keys (Feb 06 2020 at 14:01)</a>:</h4>
<p>You can use <code>#print</code>, which gives you the whole proof. Many times that will be more than you want.</p>

<a name="187550144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187550144" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187550144">Cerek Hillen (he) (W2'20) (Feb 06 2020 at 14:05)</a>:</h4>
<p>Sorry, mixed up my macros--meant <code>#print</code> haha</p>

<a name="187550513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187550513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187550513">Daniel Keys (Feb 06 2020 at 14:09)</a>:</h4>
<p>Is there anyone who can help me with advice on how to embed Lean code in LaTex? There are lines of code in the <code>mathlib-paper</code> in section 4.2 for example, but I couldn't make that look not nearly as nicely myself. Verbatim doesn't work because of the UTF characters, even with additional packages. I can hack text to look like Lean code by using <code>\texttt</code> and isolating math characters, but that's a lot of tedious work. If someone has a sample <code>document.tex</code> file with Lean code to attach (like the <code>mathlib-paper.tex</code> stripped down, for example) it would help a lot.</p>

<a name="187550750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187550750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187550750">Anne Baanen (Feb 06 2020 at 14:13)</a>:</h4>
<p>You can use the <code>lstlean.tex</code> file available here: <a href="https://github.com/leanprover-community/lean/tree/master/extras/latex" target="_blank" title="https://github.com/leanprover-community/lean/tree/master/extras/latex">https://github.com/leanprover-community/lean/tree/master/extras/latex</a></p>

<a name="187551212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187551212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187551212">Daniel Keys (Feb 06 2020 at 14:18)</a>:</h4>
<p>Works great, thank you!</p>

<a name="187551798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187551798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187551798">Matt E (Feb 06 2020 at 14:25)</a>:</h4>
<p><span class="user-mention" data-user-id="259186">@Daniel Keys</span> <span class="user-mention" data-user-id="259240">@Cerek Hillen (he) (W2'20)</span> perfect thanks</p>

<a name="187558256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187558256" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187558256">Kevin Buzzard (Feb 06 2020 at 15:34)</a>:</h4>
<p>Note that the <code>simp</code> and <code>tidy</code> and <code>library_search</code> tactics have options where they can print out what they did. With <code>simp</code> you have to run <code>squeeze_simp</code> instead -- I think for the other two it just works automatically.</p>
<p>As for Lean code in LaTeX, when I tried this when I wrote my article for the LMS newsletter, some stuff came out really poorly, and when I asked <span class="user-mention" data-user-id="110596">@Rob Lewis</span> he suggested that I had a super-old version of <code>lstlean.tex</code> and he sent me a newer one. I think the super-old version is the one which Anne has linked to. I had problems with some unicode characters IIRC.</p>

<a name="187558743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187558743" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187558743">Johan Commelin (Feb 06 2020 at 15:39)</a>:</h4>
<p>If that is the case, we should update that link.</p>

<a name="187558785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187558785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187558785">Rob Lewis (Feb 06 2020 at 15:39)</a>:</h4>
<p>I'll update it to my current version in a bit.</p>

<a name="187560751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187560751" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187560751">Daniel Keys (Feb 06 2020 at 16:01)</a>:</h4>
<p>Yes indeed, several of the Unicode characters in <code>sample.tex</code> seem to give me quite some trouble.</p>

<a name="187561065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187561065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187561065">Mario Carneiro (Feb 06 2020 at 16:04)</a>:</h4>
<p>You have to include a package for unicode characters, or else all the lean unicode characters will be garbled in tex</p>

<a name="187561173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187561173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187561173">Mario Carneiro (Feb 06 2020 at 16:05)</a>:</h4>
<p>I think it is <code>\usepackage[utf8]{inputenc}</code></p>

<a name="187561247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187561247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187561247">Daniel Keys (Feb 06 2020 at 16:06)</a>:</h4>
<p>Also some symbols, like <code>$\mathbb{C}$</code> are not listed, and trying to use math mode in <code>\lstinline</code> doesn't work.<br>
<span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Yes, that package is included in the preamble.</p>

<a name="187561280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187561280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187561280">Mario Carneiro (Feb 06 2020 at 16:06)</a>:</h4>
<p>or possibly <code>\usepackage[utf8x]{inputenc}</code></p>

<a name="187561368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187561368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187561368">Mario Carneiro (Feb 06 2020 at 16:07)</a>:</h4>
<p>Math mode doesn't work inside <code>\lstinline</code>. I think there is a way to set the escape character so this works though</p>

<a name="187561524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187561524" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187561524">Rob Lewis (Feb 06 2020 at 16:08)</a>:</h4>
<p>The package requirements are mentioned in the md file in the directory Anne linked.</p>

<a name="187561527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187561527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187561527">Mario Carneiro (Feb 06 2020 at 16:08)</a>:</h4>
<p>If a symbol is not listed, you can add it to <code>lstlean.tex</code>. (This is why Floris, and Rob, and I, all have uncommitted modifications to <code>lstlean.tex</code> since the last version some 3 years ago)</p>

<a name="187561823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187561823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187561823">Rob Lewis (Feb 06 2020 at 16:11)</a>:</h4>
<p><a href="https://github.com/leanprover-community/lean/pull/110" target="_blank" title="https://github.com/leanprover-community/lean/pull/110">https://github.com/leanprover-community/lean/pull/110</a></p>

<a name="187561928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187561928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187561928">Rob Lewis (Feb 06 2020 at 16:12)</a>:</h4>
<p>Probably a bunch more keywords could be removed, since they're mostly used in tactic mode and it's weird to highlight them there.</p>

<a name="187564581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187564581" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187564581">Daniel Keys (Feb 06 2020 at 16:38)</a>:</h4>
<p>Since the Unicode characters are quite difficult to copy/paste and most of us are used to LaTex math symbols, it would be helpful if anyone knew how to use (escape into) math mode inside <code>\lstinline</code>.</p>

<a name="187564976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187564976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187564976">Mario Carneiro (Feb 06 2020 at 16:43)</a>:</h4>
<p>The majority of lean snippets in tex papers I get by copying from a real lean file</p>

<a name="187565014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187565014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187565014">Mario Carneiro (Feb 06 2020 at 16:43)</a>:</h4>
<p>which of course has much better facilities for producing unicode</p>

<a name="187565178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187565178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187565178">Mario Carneiro (Feb 06 2020 at 16:45)</a>:</h4>
<p>There is a <code>mathescape=</code> option in <code>lstlean.tex</code> that you can set to <code>true</code> if you want <code>$foo$</code> to enter math mode. This interferes with lean's use of <code>$</code>, though, so it's usually turned off</p>

<a name="187565217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187565217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187565217">Mario Carneiro (Feb 06 2020 at 16:45)</a>:</h4>
<p>I think you can also set these options directly in your preamble</p>

<a name="187565467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187565467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187565467">Mario Carneiro (Feb 06 2020 at 16:48)</a>:</h4>
<p>You can of course always write everything in tex if you want to do that, i.e. <code>$\mathtt{\color{blue}{inductive} foo (\alpha : Type) : Type}$</code></p>

<a name="187733373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187733373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187733373">Daniel Keys (Feb 08 2020 at 22:11)</a>:</h4>
<p>Anyone can show me how to construct a <code>finset ℤ</code> from <code>range n</code>, where <code>n : ℕ</code> and every member is the negative of one of the elements in the <code>range</code>? Some kind of mapping should be possible.</p>

<a name="187733798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187733798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187733798">Patrick Massot (Feb 08 2020 at 22:26)</a>:</h4>
<p><code>finset.image (λ m : ℕ, -(m : ℤ)) (finset.range n)</code></p>

<a name="187733803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187733803" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187733803">Patrick Massot (Feb 08 2020 at 22:27)</a>:</h4>
<p>I have <em>no idea</em> why <code>finset.map</code> is <em>not</em> what you were looking for.</p>

<a name="187733853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187733853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187733853">Chris Hughes (Feb 08 2020 at 22:29)</a>:</h4>
<p>Also <code>finset.Ico_ℤ</code></p>

<a name="187733953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187733953" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187733953">Daniel Keys (Feb 08 2020 at 22:32)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110031">@Patrick Massot</span> <span class="user-mention" data-user-id="110044">@Chris Hughes</span> <br>
 I don't know how to use <code>finset.map</code> yet. For example, I tried to get the same entries (not the negatives) with <code>finset.map int.of_nat (range 5)</code>, but that doesn't work. The symbol used in <code>finset.lean</code> for the mapping function is new to me at this point (the "curved" arrow).</p>

<a name="187734013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187734013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187734013">Chris Hughes (Feb 08 2020 at 22:35)</a>:</h4>
<p>You can do it with <code>map</code> like this</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">finset</span><span class="bp">.</span><span class="n">map</span> <span class="bp">⟨</span><span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span><span class="o">,</span> <span class="bp">@</span><span class="n">int</span><span class="bp">.</span><span class="n">of_nat</span><span class="bp">.</span><span class="n">inj</span><span class="bp">⟩</span>
  <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span>
</pre></div>


<p><code>map</code> only works with injective functions, the curly arrow is an <code>embedding</code>, a pair of a function, and a proof that it's injective.</p>
<p><code>map</code> is faster for computation since it doesn't erase duplicates.</p>

<a name="187734068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187734068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187734068">Patrick Massot (Feb 08 2020 at 22:37)</a>:</h4>
<p>Why isn't called <code>fast_map</code> or <code>inj_map</code> then? It would leave the canonical name for the canonical operation.</p>

<a name="187734109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187734109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187734109">Patrick Massot (Feb 08 2020 at 22:38)</a>:</h4>
<p>Daniel, you can use "jump to definition" in VScode also on symbols.</p>

<a name="187765009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765009">Sayantan Majumdar (Feb 09 2020 at 16:49)</a>:</h4>
<p>How do I get the proofs for simple things like n + n = 2 * n or 1 &lt; 2? How do I prove 1 &lt; 2? I was expecting these proofs would already be in the library and not hiding from the user</p>

<a name="187765063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765063">Patrick Massot (Feb 09 2020 at 16:50)</a>:</h4>
<p><code>ring</code> and <code>norm_num</code> would do these for you.</p>

<a name="187765068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765068">Patrick Massot (Feb 09 2020 at 16:50)</a>:</h4>
<p>Assuming you use mathlib.</p>

<a name="187765177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765177" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765177">Sayantan Majumdar (Feb 09 2020 at 16:54)</a>:</h4>
<p>in chapter 8... haven't been introduced to these yet</p>

<a name="187765196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765196">Patrick Massot (Feb 09 2020 at 16:55)</a>:</h4>
<p>You need to give us more context then. Are you doing a specific exercise in TPIL?</p>

<a name="187765237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765237">Sayantan Majumdar (Feb 09 2020 at 16:56)</a>:</h4>
<p>In 8.4, the second last example. trying to solve the sorry</p>

<a name="187765247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765247">Sayantan Majumdar (Feb 09 2020 at 16:57)</a>:</h4>
<p>nat_to_bin</p>

<a name="187765297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765297">Patrick Massot (Feb 09 2020 at 16:59)</a>:</h4>
<p>I don't think this is meant as an exercise. I think Jeremy didn't want to distract readers with details of this proof.</p>

<a name="187765356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765356">Daniel Keys (Feb 09 2020 at 17:00)</a>:</h4>
<p><span class="user-mention" data-user-id="214077">@Sayantan Majumdar</span> Here is a slightly more complex proof. Something like you want is part of it, see the <code>have h1</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">sumUpToN_1</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">range</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="bp">.</span><span class="n">sum</span> <span class="n">id</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">sum_range_succ</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_add</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hd</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">id</span><span class="bp">.</span><span class="n">def</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_eq_add_one</span><span class="o">,</span>
  <span class="c1">---------- can get the goal thus</span>
  <span class="n">rw</span> <span class="n">add_assoc</span> <span class="n">d</span> <span class="mi">1</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_eq_add_one</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span> <span class="n">add_mul</span> <span class="mi">2</span> <span class="n">d</span> <span class="o">(</span><span class="n">d</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">,</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_comm</span> <span class="mi">2</span> <span class="n">d</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_comm</span> <span class="o">(</span><span class="n">d</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span>
  <span class="c1">------------ or simply by:</span>
  <span class="c1">-- ring,</span>
<span class="kn">end</span>
</pre></div>

<a name="187765414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765414">Kevin Buzzard (Feb 09 2020 at 17:02)</a>:</h4>
<p>Daniel -- instead of rewriting h1, which is true by definition, you can use the <code>change</code> tactic to just rewrite the goal to what you want it to be</p>

<a name="187765419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765419">Sayantan Majumdar (Feb 09 2020 at 17:03)</a>:</h4>
<p>I understand the h1, 1 &lt;  2 seems far too complicated to prove.  It would be easier to shift to Coq</p>

<a name="187765428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765428">Patrick Massot (Feb 09 2020 at 17:03)</a>:</h4>
<p>Again, <code>norm_num</code> proves it. What else do you want?</p>

<a name="187765468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765468">Patrick Massot (Feb 09 2020 at 17:04)</a>:</h4>
<p>How can a proof be simpler than a single tactic invocation?</p>

<a name="187765480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765480">Daniel Keys (Feb 09 2020 at 17:05)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Yes, Patrick, but we beginners need to learn the basics of expressing ourselves in Lean.</p>

<a name="187765488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765488">Sayantan Majumdar (Feb 09 2020 at 17:05)</a>:</h4>
<p>So, how do I prove it with norm_num?</p>

<a name="187765527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765527">Patrick Massot (Feb 09 2020 at 17:06)</a>:</h4>
<p><code>example  : 1 &lt; 2 := by norm_num</code></p>

<a name="187765528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765528" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765528">Daniel Keys (Feb 09 2020 at 17:06)</a>:</h4>
<p><span class="user-mention" data-user-id="214077">@Sayantan Majumdar</span> Here is a proof for your initial quest:</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span>
<span class="kn">theorem</span> <span class="n">twoEqOneOne</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="mi">1</span><span class="o">,</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_eq_add_one</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_mul</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">one_mul</span><span class="o">,</span> <span class="n">done</span>
<span class="kn">end</span>
</pre></div>

<a name="187765540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765540">Sayantan Majumdar (Feb 09 2020 at 17:07)</a>:</h4>
<p>thanks. How did you find the succ_eq_add_one? is there a good way of searching for these?</p>

<a name="187765591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765591">Kevin Buzzard (Feb 09 2020 at 17:09)</a>:</h4>
<p>Here is another proof:</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span>
<span class="kn">theorem</span> <span class="n">twoEqOneOne</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="k">show</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_mul</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">one_mul</span>
<span class="kn">end</span>
</pre></div>

<a name="187765592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765592">Patrick Massot (Feb 09 2020 at 17:09)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span><span class="bp">*</span><span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">ring</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span><span class="bp">*</span><span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">library_search</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="187765598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765598">Daniel Keys (Feb 09 2020 at 17:09)</a>:</h4>
<p>I had all those problems you have before going through the natural number game. Kevin Buzzard did a great job with that! It can get you started.</p>

<a name="187765641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765641" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765641">Patrick Massot (Feb 09 2020 at 17:10)</a>:</h4>
<p>Again, either you want to suffer because you think this is a good exercise, and then I don't understand what you are complaining about. Or you can use the answers I provided one minute after you asked.</p>

<a name="187765663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765663" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765663">Kevin Buzzard (Feb 09 2020 at 17:11)</a>:</h4>
<p><span class="user-mention" data-user-id="214077">@Sayantan Majumdar</span> certain lemmas you just end up learning because they come up a lot. You can use <code>library_search</code> to find them. </p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">variable</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="kn">theorem</span> <span class="n">what_is_this_called</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">library_search</span> <span class="c1">-- we learn it is true by definition</span>
<span class="kn">end</span>
</pre></div>

<a name="187765664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765664" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765664">Daniel Keys (Feb 09 2020 at 17:11)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Kevin, does <code>change</code> need <code>import tactic</code>?</p>

<a name="187765668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765668">Kevin Buzzard (Feb 09 2020 at 17:12)</a>:</h4>
<p><code>show</code> certainly doesn't. I prefer <code>change</code> because it works on hypotheses as well as goals so it's easier for the beginner.</p>

<a name="187765717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765717">Kevin Buzzard (Feb 09 2020 at 17:13)</a>:</h4>
<p><span class="user-mention" data-user-id="214077">@Sayantan Majumdar</span> there is also a naming convention which we stick to in Lean, meaning that most users can after a while <em>guess</em> that <code>succ n = n + 1</code> will be called <code>succ_eq_add_one</code>. But it takes a while to learn the conventions.</p>

<a name="187765762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765762">Sayantan Majumdar (Feb 09 2020 at 17:14)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  <span class="user-mention" data-user-id="259186">@Daniel Keys</span>  was looking for a better way to find all the proofs available. I was using the naming convention and using print and relying on vscode intelligence</p>

<a name="187765771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765771">Kevin Buzzard (Feb 09 2020 at 17:15)</a>:</h4>
<p>I have no reason to believe that this is any harder in Lean than in Coq or any other theorem prover. There will be naming conventions, and tactics for people who don't know the names but want to get the job done.</p>

<a name="187765816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765816" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765816">Kevin Buzzard (Feb 09 2020 at 17:16)</a>:</h4>
<p>The best way to get information about this sort of thing is to ask here. The existence of this chat room is one thing which makes learning Lean easier than learning all the other systems -- for the other systems you have to ask on a mailing list or stackoverflow.</p>

<a name="187765819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765819">Patrick Massot (Feb 09 2020 at 17:17)</a>:</h4>
<p>He asked, by then decided to ignore the answer and start writing he should use Coq.</p>

<a name="187765866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765866">Daniel Keys (Feb 09 2020 at 17:18)</a>:</h4>
<p>Here's a chat newbie question, how do you get a reply box to look reddish instead of white?</p>

<a name="187765868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765868">Patrick Massot (Feb 09 2020 at 17:18)</a>:</h4>
<p>Mention some name using @</p>

<a name="187765871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765871">Patrick Massot (Feb 09 2020 at 17:18)</a>:</h4>
<p>That person will see a reddish box</p>

<a name="187765872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765872">Sayantan Majumdar (Feb 09 2020 at 17:18)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span>  I have to use theorems that I have already proved to proof this, I can't use rings and norm_num because I haven't reached there yet</p>

<a name="187765885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765885">Patrick Massot (Feb 09 2020 at 17:19)</a>:</h4>
<p>Again, I think you misunderstood the status of this theorem. It's not an exercise. And if you want to make it an exercise, then why shouldn't you learn how to search properly?</p>

<a name="187765887"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765887" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765887">Mario Carneiro (Feb 09 2020 at 17:20)</a>:</h4>
<p><code>1 &lt; 2</code> can also be proven by <code>dec_trivial</code></p>

<a name="187765995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765995">Daniel Keys (Feb 09 2020 at 17:22)</a>:</h4>
<p><span class="user-mention" data-user-id="214077">@Sayantan Majumdar</span> Have a look at this, it involves an inequality:</p>
<p><a href="https://stackoverflow.com/questions/59669492/how-to-switch-types-in-lean-theorem-prover-when-constants-are-involved#comment105499922_59669492" target="_blank" title="https://stackoverflow.com/questions/59669492/how-to-switch-types-in-lean-theorem-prover-when-constants-are-involved#comment105499922_59669492">https://stackoverflow.com/questions/59669492/how-to-switch-types-in-lean-theorem-prover-when-constants-are-involved#comment105499922_59669492</a></p>

<a name="187765997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187765997" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187765997">Patrick Massot (Feb 09 2020 at 17:22)</a>:</h4>
<p><code>library_search</code> would have solved both your goals.</p>

<a name="187766005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766005">Mario Carneiro (Feb 09 2020 at 17:23)</a>:</h4>
<p>If you are working from the absolute basics, <code>1 &lt; 2</code> is <code>nat.le_refl 2</code>, where <code>nat.le_refl</code> is proven by induction</p>

<a name="187766135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766135">Kevin Buzzard (Feb 09 2020 at 17:27)</a>:</h4>
<p>But I think Patrick is right -- I don't think there is enough in TPIL for the learner working through the book to easily remove that sorry. It is trivial to remove using the machinery that mathlib provides but because TPIL is about Lean not mathlib, Jeremy leaves it there. If you're trying to remove it then you're moving away from the carefully chosen basic examples in TPIL and the real world of actual mathematical formalisation. mathlib has solved all your problems in lots of different ways but you have to learn mathlb like you have to learn Lean.</p>

<a name="187766190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766190" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766190">Mario Carneiro (Feb 09 2020 at 17:28)</a>:</h4>
<p><code>two_mul</code> has a proof using commutativity to turn it inro <code>n*2</code> which is defeq to <code>0+n+n</code></p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">eq</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">mul_comm</span> <span class="mi">2</span> <span class="n">n</span><span class="o">)</span> <span class="err">$</span>
<span class="n">congr_arg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="bp">+</span> <span class="n">n</span><span class="o">)</span> <span class="err">$</span> <span class="n">zero_add</span> <span class="bp">_</span>
</pre></div>


<p>But this is a really low level proof. Just use the theorems, or better yet, the general tactics to kill this goal.</p>

<a name="187766196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766196">Patrick Massot (Feb 09 2020 at 17:29)</a>:</h4>
<p>For the record, the full sorry can be replaced by <code>by rw nat.div_lt_iff_lt_mul ; linarith,</code></p>

<a name="187766199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766199">Kevin Buzzard (Feb 09 2020 at 17:29)</a>:</h4>
<p><span class="user-mention" data-user-id="214077">@Sayantan Majumdar</span> Mario's proof probably works without mathlib :-)</p>

<a name="187766241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766241" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766241">Patrick Massot (Feb 09 2020 at 17:30)</a>:</h4>
<p>(after  being disappointed by <code>omega</code> <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span>)</p>

<a name="187766246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766246">Kevin Buzzard (Feb 09 2020 at 17:30)</a>:</h4>
<p><code>omega</code> doesn't do it??</p>

<a name="187766249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766249">Patrick Massot (Feb 09 2020 at 17:30)</a>:</h4>
<p><code>omega</code> doesn't like me. It never does what I ask it to do.</p>

<a name="187766259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766259">Mario Carneiro (Feb 09 2020 at 17:31)</a>:</h4>
<p>This works for me:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">omega</span>
</pre></div>

<a name="187766261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766261">Kevin Buzzard (Feb 09 2020 at 17:31)</a>:</h4>
<p>it's because you were too rude about nat subtraction a year ago</p>

<a name="187766263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766263">Patrick Massot (Feb 09 2020 at 17:31)</a>:</h4>
<p>This is not the full thing, Mario.</p>

<a name="187766265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766265">Kevin Buzzard (Feb 09 2020 at 17:31)</a>:</h4>
<p>Patrick is proving (n+2)/2&lt;n+2</p>

<a name="187766268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766268">Kevin Buzzard (Feb 09 2020 at 17:31)</a>:</h4>
<p>that's the sorry in TPIL</p>

<a name="187766269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766269">Mario Carneiro (Feb 09 2020 at 17:31)</a>:</h4>
<p>aha</p>

<a name="187766310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766310">Mario Carneiro (Feb 09 2020 at 17:32)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span><span class="bp">/</span><span class="mi">2</span><span class="bp">&lt;</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span> <span class="o">:=</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">div_lt_self</span> <span class="n">dec_trivial</span> <span class="n">dec_trivial</span>
</pre></div>

<a name="187766318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766318">Kevin Buzzard (Feb 09 2020 at 17:33)</a>:</h4>
<p>this is the problem when people know the libraries too well ;-)</p>

<a name="187766319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766319">Mario Carneiro (Feb 09 2020 at 17:33)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span><span class="bp">/</span><span class="mi">2</span><span class="bp">&lt;</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">div_lt_iff_lt_mul</span><span class="bp">;</span> <span class="n">omega</span>
</pre></div>

<a name="187766345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766345">Mario Carneiro (Feb 09 2020 at 17:34)</a>:</h4>
<p>I'm not sure what omega's status is wrt integer division</p>

<a name="187766361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766361" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766361">Kevin Buzzard (Feb 09 2020 at 17:34)</a>:</h4>
<p>so <code>omega</code> just hates Patrick personally</p>

<a name="187766366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766366">Patrick Massot (Feb 09 2020 at 17:34)</a>:</h4>
<p>No, I meant <code>by omega</code> alone.</p>

<a name="187766368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766368">Patrick Massot (Feb 09 2020 at 17:35)</a>:</h4>
<p>No rewriting first.</p>

<a name="187766379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766379">Kevin Buzzard (Feb 09 2020 at 17:35)</a>:</h4>
<p>So I guess division is beyond the capabilities of <code>omega</code> is the concluson</p>

<a name="187766419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766419">Rob Lewis (Feb 09 2020 at 17:36)</a>:</h4>
<p>FYI, <a href="https://github.com/leanprover-community/mathlib/issues/1484#issuecomment-561260385" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/1484#issuecomment-561260385">https://github.com/leanprover-community/mathlib/issues/1484#issuecomment-561260385</a></p>

<a name="187766421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766421" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766421">Rob Lewis (Feb 09 2020 at 17:36)</a>:</h4>
<p>Although <a href="https://github.com/leanprover-community/mathlib/issues/1748" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/1748">#1748</a> definitely needs to be finished first.</p>

<a name="187766601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187766601" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187766601">Patrick Massot (Feb 09 2020 at 17:43)</a>:</h4>
<p>Thanks Rob!</p>

<a name="187769322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187769322" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187769322">Paul van Wamelen (Feb 09 2020 at 19:11)</a>:</h4>
<p>Oh! I figured out what TPIL stands for :). Can I suggest a small improvement to TPIL? (see, I can even use it in a sentence):<br>
In exercise 1 at the end of chapter 3, as one of the many "other properties", the reader is asked to prove <code>¬(p ↔ ¬p)</code>, but then this is also broken out as exercise 3. As exercise 2 is all about <code>classical</code> the assumption is that exercise 1 should be without it. Exercise 3 is certainly interesting enough that breaking it out seems justified. I would suggest removing it from exercise 1.</p>

<a name="187769419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187769419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187769419">Kevin Buzzard (Feb 09 2020 at 19:14)</a>:</h4>
<p><code>¬(p ↔ ¬p)</code> can be proved without LEM, but it's tricky.</p>

<a name="187770488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187770488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187770488">Paul van Wamelen (Feb 09 2020 at 19:50)</a>:</h4>
<p>Right, and exercise 3 asks the reader to do it without LEM. But even in exercise 1 the assumption/implication is that they should be done without LEM. I'm just saying the duplication should probably be removed. I was stuck on exercise 1 for a long time until I noticed that I was essentially already working on exercise 3. By the time I was through with exercise 2, I could (finally) work through 3.</p>

<a name="187774132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187774132" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187774132">Sayantan Majumdar (Feb 09 2020 at 21:49)</a>:</h4>
<p>Anyone have an idea how to solve this e I have</p>

<a name="187774137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187774137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187774137">Sayantan Majumdar (Feb 09 2020 at 21:49)</a>:</h4>
<div class="codehilite"><pre><span></span>
</pre></div>

<a name="187774204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187774204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187774204">Sayantan Majumdar (Feb 09 2020 at 21:50)</a>:</h4>
<div class="codehilite"><pre><span></span>example (n  : \N) ( h : 1 * (n + 2) &lt; 2 * (n + 2)) : (n + 2) &lt; 2 * (n + 2)
</pre></div>

<a name="187774580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187774580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187774580">Sayantan Majumdar (Feb 09 2020 at 21:59)</a>:</h4>
<p>I was wondering if someone could help me out with this simple proof</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span>  <span class="o">:</span> <span class="err">\</span><span class="n">N</span><span class="o">)</span> <span class="o">(</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span>
</pre></div>

<a name="187775643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187775643" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187775643">Kevin Buzzard (Feb 09 2020 at 22:17)</a>:</h4>
<p>you can rewrite <code>one_mul</code> at <code>h</code>. After a while you'll be able to guess that <code>one_mul</code> is the name of the theorem which says <code>1*x=x</code>.</p>

<a name="187776017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187776017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187776017">Sayantan Majumdar (Feb 09 2020 at 22:26)</a>:</h4>
<p>the rewrite will only work will = not &lt;</p>

<a name="187776023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187776023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187776023">Sayantan Majumdar (Feb 09 2020 at 22:26)</a>:</h4>
<p>*with = not &lt;</p>

<a name="187776317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187776317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187776317">Reid Barton (Feb 09 2020 at 22:36)</a>:</h4>
<p>Don't rewrite using h, rewrite h itself: <code>rw one_mul at h</code></p>

<a name="187776555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187776555" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187776555">Sayantan Majumdar (Feb 09 2020 at 22:43)</a>:</h4>
<p>thanks</p>

<a name="187777453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187777453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187777453">Sayantan Majumdar (Feb 09 2020 at 23:04)</a>:</h4>
<p>Anybody got any suggestions for this</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">((</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span>
</pre></div>


<p>was thinking about using div_lt_of_mul_lt_of_pos but there seems to be an issue</p>

<a name="187777612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187777612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187777612">Kevin Buzzard (Feb 09 2020 at 23:06)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">((</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">div_lt_iff_lt_mul</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h₂</span>
<span class="kn">end</span>
</pre></div>

<a name="187777644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187777644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187777644">Kevin Buzzard (Feb 09 2020 at 23:07)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">div_lt_of_mul_lt_of_pos</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">div_lt_of_mul_lt_of_pos :</span>
<span class="cm">  ∀ {α : Type u_1} [_inst_1 : linear_ordered_field α] {a b c : α}, c &gt; 0 → b &lt; a * c → b / c &lt; a</span>
<span class="cm">  -/</span>
</pre></div>


<p><code>div_lt_of_mul_lt_of_pos</code> is a theorem about linearly ordered fields.</p>

<a name="187777691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187777691" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187777691">Kevin Buzzard (Feb 09 2020 at 23:08)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">((</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">div_lt_iff_lt_mul</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h₁</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">h₂</span>
</pre></div>

<a name="187777699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187777699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187777699">Kevin Buzzard (Feb 09 2020 at 23:09)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">((</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">div_lt_iff_lt_mul</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">assumption</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">assumption</span><span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="187778294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187778294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187778294">Kevin Buzzard (Feb 09 2020 at 23:21)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">((</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="mi">2</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rwa</span> <span class="n">nat</span><span class="bp">.</span><span class="n">div_lt_iff_lt_mul</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h₁</span>
</pre></div>

<a name="187911569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187911569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187911569">Matt E (Feb 11 2020 at 13:38)</a>:</h4>
<p>I have a function producing <code>Prop</code>s a bit like the following (but in general there can be any finite number of disjuncts)</p>
<div class="codehilite"><pre><span></span>def g (p q r s : ℕ) : Prop := (p = q) ∨ (r = s) ∨ false
</pre></div>


<p>now I suppose these should be decidable and hence printable, which is my aim. I have read a bit about decidable props but can't quite figure out how to reduce an application of g to a <code>true</code> or <code>false</code></p>

<a name="187911950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187911950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187911950">Rob Lewis (Feb 11 2020 at 13:43)</a>:</h4>
<p>Depending on the exact structure of your function, Lean can probably infer that it's decidable already. You need either <code>@[reducible] def g</code> or <code>@[derive decidable] def g</code> (the latter will only work with mathlib). Then you can <code>#eval to_bool (g 1 2 3 4)</code>.</p>

<a name="187914523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187914523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187914523">Matt E (Feb 11 2020 at 14:14)</a>:</h4>
<p><span class="user-mention" data-user-id="110596">@Rob Lewis</span> thanks. actually my Prop was set membership, so I had to stipulate <code>finset</code> but then this works. at some point I will need to understand better what is going on with this "attribute" business but for now...</p>

<a name="187915498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/187915498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#187915498">Rob Lewis (Feb 11 2020 at 14:23)</a>:</h4>
<p>By default, Lean won't unfold the definition of <code>g</code> to see if it's decidable, because this gets very expensive. <code>@[reducible]</code> says "go ahead and unfold this anyway," and <code>@[derive decidable]</code> says "unfold this temporarily to check that it's decidable, and add an instance to the environment."</p>

<a name="188015695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188015695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188015695">Matt E (Feb 12 2020 at 14:44)</a>:</h4>
<p>is there an isomorphism <code>Type x Type</code> with <code>Type</code>? I have two endofunctors on <code>Type</code> and it would seem nice to be able to see their product as again being (via isomorphism) another such endofunctor. perhaps this is nonsense</p>

<a name="188016004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188016004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188016004">Yury G. Kudryashov (Feb 12 2020 at 14:48)</a>:</h4>
<p>You clearly have <code>Type × Type → Type</code>. How do you want to construct <code>Type → Type × Type</code>?</p>

<a name="188016024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188016024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188016024">Yury G. Kudryashov (Feb 12 2020 at 14:48)</a>:</h4>
<p>Disclaimer: I'm not an expert in category theory.</p>

<a name="188016819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188016819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188016819">Matt E (Feb 12 2020 at 14:56)</a>:</h4>
<p>well, it can just be the diagonal, but if we say <code>def f : Type ⥤ (Type × Type) := λx, x × x</code>, it does not typecheck</p>

<a name="188017533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188017533" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188017533">Anne Baanen (Feb 12 2020 at 15:02)</a>:</h4>
<p>So I understand the question better: what is the inverse of <code>(ℕ, ℝ)</code> supposed to be under <code>f</code>?</p>

<a name="188018097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188018097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188018097">Yury G. Kudryashov (Feb 12 2020 at 15:09)</a>:</h4>
<p>A functor is more than a map.</p>

<a name="188018129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188018129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188018129">Yury G. Kudryashov (Feb 12 2020 at 15:09)</a>:</h4>
<p>You need at least <code>{obj := ..., map := ...}</code> if I remember field names correctly.</p>

<a name="188018323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188018323" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188018323">Yury G. Kudryashov (Feb 12 2020 at 15:11)</a>:</h4>
<p>You can define functors <code>diag : Type ⥤ (Type × Type)</code> and <code>prod : (Type × Type) ⥤ Type</code>. What relations on these functors do you want?</p>

<a name="188018925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188018925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188018925">Matt E (Feb 12 2020 at 15:18)</a>:</h4>
<p>yes, excuse me. I mean, I think clearly this does not work in the naive sense. So let me rephrase, why should <code>N x N : Type</code>? I think you can say something like type formation applies to types of a particular universe and not on that universe itself. But this typechecking example seems to indicate that we shoil be able to view any product of types as itself a Type. Am I hopelessly confused?</p>

<a name="188019371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188019371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188019371">Anne Baanen (Feb 12 2020 at 15:23)</a>:</h4>
<p>You can view <code>(×)</code> as a function <code>prod : Type → Type → Type</code>, Thus, <code>ℕ : Type</code> implies <code>prod ℕ ℕ : Type</code>, just like <code>mul : ℕ → ℕ → ℕ</code> implies that <code>mul 1 2 : ℕ</code>. Does that help?</p>

<a name="188020635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188020635" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188020635">Matt E (Feb 12 2020 at 15:35)</a>:</h4>
<p>thanks. I'm not sure now how this "thought" got off the ground at all, will press on</p>

<a name="188026877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188026877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188026877">Kevin Buzzard (Feb 12 2020 at 16:31)</a>:</h4>
<blockquote>
<p>is there an isomorphism <code>Type x Type</code> with <code>Type</code>? I have two endofunctors on <code>Type</code> and it would seem nice to be able to see their product as again being (via isomorphism) another such endofunctor. perhaps this is nonsense</p>
</blockquote>
<p>To do that you don't need an identification of <code>Type x Type</code> with <code>Type</code> -- you just compose the endofunctors, right?</p>

<a name="188026905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188026905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188026905">Kevin Buzzard (Feb 12 2020 at 16:31)</a>:</h4>
<p>There will be <code>functor.comp</code> or something like that.</p>

<a name="188062821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188062821" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188062821">Matt E (Feb 12 2020 at 23:15)</a>:</h4>
<blockquote>
<p>There will be <code>functor.comp</code> or something like that.</p>
</blockquote>
<p>I really needed their categorial <em>product</em>, not comp, but I have realized now that my mistake is that I want their product in the functor category <code>Fun(Type, Type)</code> (which is "calculated pointwise"), not their product in the category <code>Type</code> (which is what <code>functor.prod</code> gives, essentially)...</p>
<p>In defense of the idea that we might identify <code>Type</code> with <code>Type × Type</code>, it is the difference between whether there are only (types of) things in the world or if pairs (of types) of things are distinct, and not themselves (types of) things. In other words, I was thinking that if <code>Type</code> is sort of like a "universe of sets", and we thought that "everything is a set" then a pair of sets should itself be a set. Again, naively this doesn't work but I thought there might be some kind of "universe trick" or the like... something like the following (although this fails):</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="n">f</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="err">⥤</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kn">variable</span> <span class="n">g</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span> <span class="err">⥤</span> <span class="kt">Type</span> <span class="n">w</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">functor</span><span class="bp">.</span><span class="n">prod</span> <span class="n">f</span> <span class="n">g</span>
 <span class="c1">-- functor.prod f g : Type u × Type w ⥤ Type u × Type w</span>

<span class="n">def</span> <span class="n">dummy</span> <span class="o">(</span><span class="n">fg</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">w</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="err">⥤</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">w</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)))</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">dummy</span> <span class="o">(</span><span class="n">functor</span><span class="bp">.</span><span class="n">prod</span> <span class="n">f</span> <span class="n">g</span><span class="o">)</span>  <span class="c1">-- fails</span>
</pre></div>

<a name="188062940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188062940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188062940">Kevin Buzzard (Feb 12 2020 at 23:17)</a>:</h4>
<p>It's just not true that Type = Type x Type -- does this help?</p>

<a name="188062954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188062954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188062954">Kevin Buzzard (Feb 12 2020 at 23:17)</a>:</h4>
<p>This equality says that given a set there is some nice way to get two sets from it.</p>

<a name="188063063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188063063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188063063">Kevin Buzzard (Feb 12 2020 at 23:18)</a>:</h4>
<p>You can certainly bundle together two types to get a new type, but there's no natural inverse map from Type to Type x Type because most types are not two other types bundled together.</p>

<a name="188063100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188063100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188063100">Kevin Buzzard (Feb 12 2020 at 23:19)</a>:</h4>
<p>BTW if you write <code> ```lean </code> instead of just <code> ``` </code> at the top of your quoted code then you get syntax highlighting :-)</p>

<a name="188063172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188063172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188063172">Matt E (Feb 12 2020 at 23:20)</a>:</h4>
<p>no argument there</p>

<a name="188063212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188063212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188063212">Kevin Buzzard (Feb 12 2020 at 23:21)</a>:</h4>
<blockquote>
<p>In other words, I was thinking that if Type is sort of like a "universe of sets", and we thought that "everything is a set" then a pair of sets should itself be a set. </p>
</blockquote>
<p>This part is fine -- that's going from Type x Type to Type.</p>

<a name="188063297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188063297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188063297">Kevin Buzzard (Feb 12 2020 at 23:22)</a>:</h4>
<p>This is called <code>sum</code> in Lean, with notation <code>⊕</code> (in VS Code it's <code>\oplus</code>)</p>

<a name="188063429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188063429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188063429">Chris Hughes (Feb 12 2020 at 23:24)</a>:</h4>
<p>I'm not sure it's fine in the sense that it was meant, there's some natural functions <code>Type x Type</code> to <code>Type</code>, but I can't just give Lean a pair of types when it expects a <code>Type</code>.</p>

<a name="188063558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188063558" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188063558">Chris Hughes (Feb 12 2020 at 23:26)</a>:</h4>
<p>sums of Types are not pairs of Types.</p>

<a name="188063593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188063593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188063593">Kevin Buzzard (Feb 12 2020 at 23:26)</a>:</h4>
<p>Oh of course you're right.</p>

<a name="188063929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188063929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188063929">Kevin Buzzard (Feb 12 2020 at 23:31)</a>:</h4>
<p>so it's hard to get <code>dummy</code> to typecheck because given a pair of types I can manufacture a type, but I can't go the other way, so I can't construct a functor Type -&gt; Type from a functor Type^2 -&gt; Type^2</p>

<a name="188064537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188064537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188064537">Chris Hughes (Feb 12 2020 at 23:40)</a>:</h4>
<p>And even though in ZFC, a pair of sets is a set, this is a useless construction categorically, since it's always just a set with two elements I think.</p>

<a name="188329094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188329094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188329094">Daniel Keys (Feb 16 2020 at 15:33)</a>:</h4>
<p>Is there a simple way to obtain the truth value of a <code>Prop</code>? Here is what I mean: when doing <code>#reduce tt &amp;&amp; (0=0)</code>, output is <code>tt</code>. Obviously Lean evaluates the truth value of <code>(0=0) : Prop</code> and produces a <code>bool</code>. But if one tries <code>#reduce 0 = 0</code>, the output is not a <code>bool</code>. I can evaluate the <code>Prop</code> by something like <code>def is_tt : bool := 0 = 0</code> and then <code>#reduce is_tt</code>, but there should be a more straightforward way that Lean itself appears to use and I couldn't find.</p>

<a name="188329135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188329135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188329135">Kevin Buzzard (Feb 16 2020 at 15:34)</a>:</h4>
<p>There is <code>to_bool</code>. Is this what you're after?</p>

<a name="188329240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188329240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188329240">Daniel Keys (Feb 16 2020 at 15:39)</a>:</h4>
<p>That is it! Somehow I couldn't find it, although I did find something like <code>to_bool_true_eq_tt</code> which didn't immediately help. Thanks!</p>

<a name="188329836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188329836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188329836">Kevin Buzzard (Feb 16 2020 at 15:59)</a>:</h4>
<p>Don't expect to learn your way around immediately. It took me years. Tools are getting better for you to solve many problems on your own nowadays, but sometimes asking is more effective.</p>

<a name="188395198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188395198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188395198">PolyB (Feb 17 2020 at 17:29)</a>:</h4>
<p>I've written:</p>
<div class="codehilite"><pre><span></span>inductive type_with (v : Type → Type)
| mk (α : Type) : v α → α → with_

def f : list (type_with has_to_string) → string := ....
</pre></div>


<p>Is there a way to write something equivalent without having to use a "helper" type ?<br>
If it's not possible, does <code>type_with</code> already exists in lean standard library/mathlib ?</p>

<a name="188398475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188398475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188398475">Yury G. Kudryashov (Feb 17 2020 at 18:27)</a>:</h4>
<p>If you write <code>lean</code> after opening a code block, then you get syntax highlighting. Are you looking for <code>Σ  α : Type, has_to_string α</code>?</p>

<a name="188398640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188398640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188398640">Andrew Ashworth (Feb 17 2020 at 18:30)</a>:</h4>
<p>you might want to look at <a href="https://github.com/leanprover/lean/blob/ceacfa7445953cbc8860ddabc55407430a9ca5c3/library/init/data/rbmap/basic.lean" target="_blank" title="https://github.com/leanprover/lean/blob/ceacfa7445953cbc8860ddabc55407430a9ca5c3/library/init/data/rbmap/basic.lean">https://github.com/leanprover/lean/blob/ceacfa7445953cbc8860ddabc55407430a9ca5c3/library/init/data/rbmap/basic.lean</a> line 60</p>

<a name="188398664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188398664" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188398664">Andrew Ashworth (Feb 17 2020 at 18:31)</a>:</h4>
<p>that line defines a string representation for a red-black tree</p>

<a name="188399450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188399450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188399450">PolyB (Feb 17 2020 at 18:45)</a>:</h4>
<p>Thanks for the responses,<br>
sigma looks almost equivalent to my <code>type_with</code> , but it looks like I loose instance inference</p>

<a name="188401295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188401295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188401295">Reid Barton (Feb 17 2020 at 19:20)</a>:</h4>
<p>I'm not sure what instance inference you have with <code>type_with</code>...?</p>

<a name="188402025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188402025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188402025">Gabriel Ruiz (Feb 17 2020 at 19:33)</a>:</h4>
<p>Hi everyone! I'm beginning my journey in Lean, and I'm following along the tutorial here: <br>
<a href="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html">https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html</a></p>
<p>Why is it that when you input <code>#check Type</code> to lean's interpreter(?), you're returned <code>Type 1</code> instead of <code>Type 0</code>?</p>

<a name="188402255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188402255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188402255">Reid Barton (Feb 17 2020 at 19:37)</a>:</h4>
<p><code>Type 0</code> is the same as <code>Type</code>. If we had <code>Type : Type</code>, then the system would be logically inconsistent (you could encode Cantor's paradox or something).</p>

<a name="188402323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188402323" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188402323">Reid Barton (Feb 17 2020 at 19:38)</a>:</h4>
<p><code>Type 1</code> is a "bigger universe" which can contain things like <code>Type = Type 0</code>, and <code>Type 1</code> is itself a type that lives in the next larger universe <code>Type 2</code>, and so on</p>

<a name="188402719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188402719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188402719">Yury G. Kudryashov (Feb 17 2020 at 19:46)</a>:</h4>
<p><span class="user-mention" data-user-id="110025">@Andrew Ashworth</span> You can write <code>def bundle_to_string (α : Type) [h : has_to_string α]  : Σ α : Type, has_to_string α := ⟨α, h⟩</code> (didn't test).</p>

<a name="188402851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188402851" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188402851">Reid Barton (Feb 17 2020 at 19:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/188402323" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/188402323">said</a>:</p>
<blockquote>
<p><code>Type 1</code> is a "bigger universe" which can contain things like <code>Type = Type 0</code>, and <code>Type 1</code> is itself a type that lives in the next larger universe <code>Type 2</code>, and so on</p>
</blockquote>
<p>I realize now I pretty much explained just the same thing it already says in <a href="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#types-as-objects" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#types-as-objects">https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#types-as-objects</a></p>

<a name="188402929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188402929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188402929">Gabriel Ruiz (Feb 17 2020 at 19:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> I'm following, and now I'm starting to see my confusion. What then does <code>#check</code> do?</p>

<a name="188402938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188402938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188402938">Reid Barton (Feb 17 2020 at 19:51)</a>:</h4>
<p><code>#check</code> tells you the type of something</p>

<a name="188402950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188402950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188402950">Reid Barton (Feb 17 2020 at 19:51)</a>:</h4>
<p>e.g. <code>#check 3</code> will print something like <code>3 : nat</code></p>

<a name="188403127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188403127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188403127">Gabriel Ruiz (Feb 17 2020 at 19:54)</a>:</h4>
<p>Right, which is why I'm perplexed that it doesn't actually return <code>Type 0</code>  when I put in <code>#check Type 0</code>. I understand that it's <em>also</em> of <code>Type 1</code>, but why does it tell me that instead of its actual type: <code>Type 0</code>?</p>

<a name="188403141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188403141" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188403141">Johan Commelin (Feb 17 2020 at 19:54)</a>:</h4>
<p>Because that is not its type</p>

<a name="188403154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188403154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188403154">Johan Commelin (Feb 17 2020 at 19:55)</a>:</h4>
<p>You can't be your own type</p>

<a name="188403156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188403156" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188403156">Gabriel Ruiz (Feb 17 2020 at 19:55)</a>:</h4>
<p>Ohhhhhhhhhhhhhhhh</p>

<a name="188403170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188403170" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188403170">Gabriel Ruiz (Feb 17 2020 at 19:55)</a>:</h4>
<p>That clicked, thank you!</p>

<a name="188403224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188403224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188403224">Johan Commelin (Feb 17 2020 at 19:56)</a>:</h4>
<p>Similarly, <code>Type 1</code> will have type <code>Type 2</code>, and <code>Type 2</code> will have type ...</p>

<a name="188404676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188404676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188404676">Paul van Wamelen (Feb 17 2020 at 20:25)</a>:</h4>
<p>How would one do:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">lol</span> <span class="o">:</span> <span class="o">(</span><span class="n">real</span><span class="bp">.</span><span class="n">sqrt</span> <span class="mi">3</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">real</span><span class="bp">.</span><span class="n">sqrt</span> <span class="mi">3</span> <span class="bp">/</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p><code>by ring</code> manages in <code>ℝ</code>, should I use some <code>coe</code> is injective?</p>

<a name="188407423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188407423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188407423">Floris van Doorn (Feb 17 2020 at 21:21)</a>:</h4>
<p>The tactic <code>norm_cast</code> will help you with anything <code>coe</code>-related:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">lemma</span> <span class="n">lol</span> <span class="o">:</span> <span class="o">(</span><span class="n">real</span><span class="bp">.</span><span class="n">sqrt</span> <span class="mi">3</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">real</span><span class="bp">.</span><span class="n">sqrt</span> <span class="mi">3</span> <span class="bp">/</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">norm_cast</span><span class="o">,</span> <span class="n">ring</span>
<span class="kn">end</span>
</pre></div>

<a name="188409176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188409176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188409176">Paul van Wamelen (Feb 17 2020 at 21:58)</a>:</h4>
<p>Thanks!<br>
I thought maybe the <code>real.sqrt 3</code> was confusing things, so I tried to prove</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">lol&#39;</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">/</span> <span class="mi">2</span>
</pre></div>


<p>first. I finally got this</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">lol&#39;</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">/</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="k">begin</span>
   <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">div_eq_mul_inv</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_assoc</span><span class="o">,</span>
  <span class="n">rw</span> <span class="bp">@</span><span class="n">complex</span><span class="bp">.</span><span class="n">mul_inv_cancel</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">),</span>
  <span class="n">rw</span> <span class="n">mul_one</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">norm_cast</span> <span class="n">at</span> <span class="n">h</span>
<span class="kn">end</span>
</pre></div>


<p>(I was trying <code>exact absurd h dec_trivial</code>, which wasn't working, where there is now a <code>norm_cast</code>, thanks again! :)).<br>
Is it really this hard? Why doesn't <code>dec_trivial</code> work here (it worked in very similar circumstances before)</p>

<a name="188409388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188409388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188409388">Kevin Buzzard (Feb 17 2020 at 22:03)</a>:</h4>
<p><code>dec_trivial</code> won't prove anything about the complexes, because the complexes don't have decidable equality.</p>

<a name="188409434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188409434" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188409434">Kevin Buzzard (Feb 17 2020 at 22:04)</a>:</h4>
<p><code>dec_trivial</code> works for naturals, integers and rationals, not for reals, complexes or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>-adics.</p>

<a name="188409658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188409658" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188409658">Kevin Buzzard (Feb 17 2020 at 22:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">lemma</span> <span class="n">lol&#39;</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">/</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">field_simp</span><span class="o">,</span>
  <span class="n">ring</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="188409754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188409754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188409754">Paul van Wamelen (Feb 17 2020 at 22:11)</a>:</h4>
<p><code>field_simp</code>!!!!!!</p>

<a name="188409824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188409824" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188409824">Kevin Buzzard (Feb 17 2020 at 22:13)</a>:</h4>
<p><code>ring</code> doesn't always work when you have denominators, for obvious reasons. <code>field_simp</code> is, I think, some kind of denominator tactic. It's the first time I ever used it; I remembered people talking about it a month or two ago and I just looked it up in <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md">the tactic list</a>.</p>

<a name="188409899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188409899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188409899">Paul van Wamelen (Feb 17 2020 at 22:14)</a>:</h4>
<p>Thanks for the <code>dec_trivial</code> explanation. I had <code>h : 2 = 0</code> but couldn't figure out in which ring 2 and 0 were. Is there a <code>#print</code> setting that will show me?</p>

<a name="188409926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188409926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188409926">Kevin Buzzard (Feb 17 2020 at 22:14)</a>:</h4>
<p>You can <code>set_option pp.all true</code> before your proof. Then you'll see what Lean is actually doing behind the scenes. Be warned though, it's not a pretty sight sometimes.</p>

<a name="188409946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188409946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188409946">Paul van Wamelen (Feb 17 2020 at 22:15)</a>:</h4>
<p>:) Thanks!</p>

<a name="188410022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188410022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188410022">Kevin Buzzard (Feb 17 2020 at 22:16)</a>:</h4>
<p>Maybe you could try <code>set_option pp.numerals false</code> instead but I'm not sure what will happen then.</p>

<a name="188410142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188410142" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188410142">Rob Lewis (Feb 17 2020 at 22:19)</a>:</h4>
<blockquote>
<p><code>lemma lol' (x : ℂ) : x = 2 * x / 2</code></p>
</blockquote>
<p>This should be provable by <code>ring</code> alone -- notice it works if you change C to R. IIRC there's something in the C++ <code>norm_num</code> that looks for an order instance unnecessarily when it does denominator cancellation. Probably fixable in 3.5c.</p>

<a name="188414786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188414786" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188414786">Matt E (Feb 18 2020 at 00:14)</a>:</h4>
<p>I am defining a type of automata (DFA). Initially I had something like:</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">DFA</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">Alphabet</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">State</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>  <span class="o">(</span><span class="n">initialState</span> <span class="o">:</span> <span class="n">Q</span><span class="o">)</span>  <span class="o">(</span><span class="n">AcceptingStates</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">δ</span> <span class="o">:</span> <span class="n">State</span> <span class="bp">→</span> <span class="n">Alphabet</span> <span class="bp">→</span> <span class="n">State</span><span class="o">)</span>
</pre></div>


<p>this works ok for a while, I can define some enumerated type for an alphabet and so on. but then for some applications, it would be really useful to be able to <code>map</code> <code>δ</code> over all of the letters of the alphabet. So it has to be a list,</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="kn">structure</span> <span class="n">DFA</span> <span class="o">:=</span>
 <span class="o">(</span><span class="n">Alphabet</span> <span class="o">:</span> <span class="n">list</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">State</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">initialState</span> <span class="o">:</span> <span class="n">Q</span><span class="o">)</span>  <span class="o">(</span><span class="n">AcceptingStates</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">δ</span> <span class="o">:</span> <span class="n">State</span> <span class="bp">→</span> <span class="n">Alphabet</span> <span class="bp">→</span> <span class="n">State</span><span class="o">)</span>
</pre></div>


<p>but of course now we have bad syntax at <code>δ</code> because <code>Alphabet</code> has become a term. I can change it to <code>δ : forall a \in Alphabet, State → State)</code>, say, but then it seems like I have to provide proofs of membership all the time. Of course there is the basic solution <code>δ : Q → list β → Q</code>, but this is not a very expressive type since we do not want any old <code>list  β</code>. Is there another possibility I've missed?</p>

<a name="188415257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188415257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188415257">Matt E (Feb 18 2020 at 00:29)</a>:</h4>
<p>the other possibility is my original structure is good and my desire to <code>map</code> is a hangover from other languages. Actually, maybe I can use <code>rec</code> on my alphabets qua enumerated types instead... will see if that can give the intended effect tomorrow.</p>

<a name="188417768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188417768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188417768">Chris B (Feb 18 2020 at 01:40)</a>:</h4>
<p><span class="user-mention" data-user-id="247064">@Matt E</span> There's a thing called <code>fintype</code> in mathlib that might be what you want for the alphabet, or at least be a good jumping off point. It's sort of secretly a list (the hierarchy for its definition is fintype -&gt; finset -&gt; multiset -&gt; quotient of list A over list permutation). It looks like there are functions <code>fintype.to_finset</code> and then <code>finset.map</code>, or you might be able to use coercions to get what you want. For the membership stuff I would assume there are helpful lemmas in those modules. Someone more knowledgeable can probably give details.</p>

<a name="188438419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188438419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188438419">Kevin Buzzard (Feb 18 2020 at 10:13)</a>:</h4>
<blockquote>
<p>IIRC there's something in the C++ <code>norm_num</code> that looks for an order instance unnecessarily when it does denominator cancellation. </p>
</blockquote>
<p>The point being that the order instance guarantees injectivity of any ring hom from int, rat or real, so is a cheap way of checking nonzero denominators</p>

<a name="188438649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188438649" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188438649">Kevin Buzzard (Feb 18 2020 at 10:17)</a>:</h4>
<blockquote>
<p>it would be really useful to be able to <code>map</code> <code>δ</code> over all of the letters of the alphabet. So it has to be a list</p>
</blockquote>
<p>Lean has all sorts of <code>map</code>s, as well as things like <code>set.image</code>. What exactly do you need? Lists are lists and if you feel like your mental model isn't a list then maybe you need something else.</p>

<a name="188438678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188438678" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188438678">Kevin Buzzard (Feb 18 2020 at 10:17)</a>:</h4>
<p>Maybe it's as simple as using <code>set.range</code>?</p>

<a name="188453690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188453690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188453690">Matt E (Feb 18 2020 at 14:17)</a>:</h4>
<p><span class="user-mention" data-user-id="228466">@Chris B</span> that is indeed probably what I want. so I can put <code>structure DFA (α : Type) [fintype α] := ...</code> so far so good. now let</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">decidable_eq</span><span class="o">]</span>
<span class="kn">inductive</span> <span class="n">α</span> <span class="bp">|</span> <span class="n">A</span> <span class="bp">|</span> <span class="n">B</span> <span class="bp">|</span> <span class="n">C</span>
</pre></div>


<p>now I need an instance of fintype, but I'm stuck at:</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">α_fin</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="n">refine</span> <span class="o">{</span><span class="n">elems</span> <span class="o">:=</span> <span class="o">{</span><span class="n">α</span><span class="bp">.</span><span class="n">A</span><span class="o">,</span> <span class="n">α</span><span class="bp">.</span><span class="n">B</span><span class="o">,</span> <span class="n">α</span><span class="bp">.</span><span class="n">C</span><span class="o">},</span> <span class="n">complete</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">},</span>
  <span class="n">intro</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="188453958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188453958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188453958">Kevin Buzzard (Feb 18 2020 at 14:20)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">α_fin</span> <span class="o">:</span> <span class="n">fintype</span> <span class="n">α</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="n">refine</span> <span class="o">{</span><span class="n">elems</span> <span class="o">:=</span> <span class="o">{</span><span class="n">α</span><span class="bp">.</span><span class="n">A</span><span class="o">,</span> <span class="n">α</span><span class="bp">.</span><span class="n">B</span><span class="o">,</span> <span class="n">α</span><span class="bp">.</span><span class="n">C</span><span class="o">},</span> <span class="n">complete</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">},</span>
  <span class="n">intro</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="188454010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188454010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188454010">Kevin Buzzard (Feb 18 2020 at 14:21)</a>:</h4>
<p><code>cases</code> is your friend here. Given <code>x : α</code> where <code>α</code> is any inductive type, <code>cases</code> will split into a case for each constructor.</p>

<a name="188454107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188454107" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188454107">Matt E (Feb 18 2020 at 14:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/188438678" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/188438678">said</a>:</p>
<blockquote>
<p>Maybe it's as simple as using <code>set.range</code>?</p>
</blockquote>
<p>that might work once I have this fintype stuff working, the real block is having something that is finite, decidable etc.</p>

<a name="188454126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188454126" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188454126">Matt E (Feb 18 2020 at 14:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/188454010" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/188454010">said</a>:</p>
<blockquote>
<p><code>cases</code> is your friend here. Given <code>x : α</code> where <code>α</code> is any inductive type, <code>cases</code> will split into a case for each constructor.</p>
</blockquote>
<p>perfect, thanks!</p>

<a name="188454176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188454176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188454176">Kevin Buzzard (Feb 18 2020 at 14:23)</a>:</h4>
<p>Using tactic mode to define data is something I instinctively avoid doing. It is probably not an issue here, but my instinct would be <code>instance α_fin : fintype α := {elems := {α.A, α.B, α.C}, complete := λ x, by cases x; simp}</code>.</p>

<a name="188454288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188454288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188454288">Kevin Buzzard (Feb 18 2020 at 14:24)</a>:</h4>
<p>The logic is that some tactics make terrifying terms which mean that it becomes hard to reason about the objects you've defined. I strongly suspect that <code>refine</code> is not one of them, but I am never sure. I do know that <code>rw</code> can really make things scary.</p>

<a name="188454376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188454376" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188454376">Kevin Buzzard (Feb 18 2020 at 14:25)</a>:</h4>
<blockquote>
<p>that might work once I have this fintype stuff working, the real block is having something that is finite, decidable etc.</p>
</blockquote>
<p>Is your alphabet finite and decidable? You can just add these as assumptions of course.</p>

<a name="188459255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188459255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188459255">Matt E (Feb 18 2020 at 15:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/188454376" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/188454376">said</a>:</p>
<blockquote>
<p>Is your alphabet finite and decidable? You can just add these as assumptions of course.</p>
</blockquote>
<p>not exactly sure what you mean</p>

<a name="188459388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188459388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188459388">Matt E (Feb 18 2020 at 15:20)</a>:</h4>
<p>that sounds like it would suffice to prove some things abstractly, but I am working with particular alphabets</p>

<a name="188463924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188463924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188463924">Kevin Buzzard (Feb 18 2020 at 16:10)</a>:</h4>
<p>I just meant <code>(Alphabet : Type) [decidable_eq Alphabet] [fintype Alphabet]</code></p>

<a name="188539816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188539816" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188539816">Matt E (Feb 19 2020 at 12:32)</a>:</h4>
<p>if I have a quotient on type <code>X</code> and a <code>myset : set X</code>, is there a way to turn the latter into a <code>set X/~</code>? Is <code>quotient.lift myset ...</code> on the right track?</p>

<a name="188541491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188541491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188541491">Sebastien Gouezel (Feb 19 2020 at 12:58)</a>:</h4>
<p>You want to take the image of a set under a function. This is done with the notation <code>''</code>, which is a shortcut for <code>set.image</code>.</p>

<a name="188783047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188783047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188783047">Chris B (Feb 21 2020 at 23:04)</a>:</h4>
<p>Is there a simple-ish answer for what Lean does internally with attributes? Also are there any community docs on how to define attributes? That part of the reference manual is blank. There's a one-liner in mathlib's <code>commands.md</code> doc that shows the literal syntax for defining a local attribute but that's about it.</p>

<a name="188788972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188788972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188788972">Kevin Buzzard (Feb 22 2020 at 00:45)</a>:</h4>
<p>There aren't that many attributes. A <code>simp</code> tag means "<code>simp</code> can use this", I think <code>refl_lemna</code> means <code>dsimp</code> can use it, <code>ext</code> means <code>ext</code> can use it, <code>to_additive</code> means that lean will try and generate an additive version of this multiplicative definition, there are some <code>cast</code>y ones to do with <code>norm_cast</code> tactic and these are explained in the tactics doc, and I think that's most of the ones I know about</p>

<a name="188789035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188789035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188789035">Kevin Buzzard (Feb 22 2020 at 00:47)</a>:</h4>
<p><code>refl</code> and<code>symm</code> and <code>trans</code>mean that the associated tactic can use them and they can also be used in <code>calc</code> proofs</p>

<a name="188789128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188789128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188789128">Mario Carneiro (Feb 22 2020 at 00:48)</a>:</h4>
<p>You can list all the attributes, there are a lot you don't know about</p>

<a name="188789142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188789142" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188789142">Mario Carneiro (Feb 22 2020 at 00:49)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">print</span> <span class="n">attributes</span>
</pre></div>

<a name="188789220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188789220" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188789220">Kevin Buzzard (Feb 22 2020 at 00:50)</a>:</h4>
<p>Are most of them not for human consumption though? It's not as if I see these all over mathlib</p>

<a name="188789237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188789237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188789237">Mario Carneiro (Feb 22 2020 at 00:51)</a>:</h4>
<p>I'm sure they are zipf distributed</p>

<a name="188790998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188790998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188790998">Bryan Gin-ge Chen (Feb 22 2020 at 01:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110596">@Rob Lewis</span> 's <a href="https://github.com/leanprover-community/mathlib/pull/1963" target="_blank" title="https://github.com/leanprover-community/mathlib/pull/1963">doc PR</a> will put all documentation for custom attributes into a new file. The header for that file is still WIP in the corresponding doc-gen PR <a href="https://github.com/leanprover-community/doc-gen/pull/11/files#diff-8b934aba0acb01944938f124f5c7a9c8R555" target="_blank" title="https://github.com/leanprover-community/doc-gen/pull/11/files#diff-8b934aba0acb01944938f124f5c7a9c8R555">here</a>, and that would be a good spot to add info about how attributes work.</p>

<a name="188845582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188845582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188845582">Chris B (Feb 23 2020 at 03:00)</a>:</h4>
<p>I meant more like "what does Lean do internally when it encounters an attribute" as opposed to what a particular attribute does, but looking closer at how they're defined in mathlib's tactics module it looks like it's pretty involved meta stuff, so I think therein lies my answer.</p>

<a name="188857903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188857903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188857903">Kevin Buzzard (Feb 23 2020 at 08:09)</a>:</h4>
<p>Attributes are just ways of tagging a definition and <code>simp</code> is written in C++ so in some cases it can be C++ code not Lean code which is using those tags</p>

<a name="188898048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188898048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188898048">Rocky Kamen-Rubio (Feb 24 2020 at 04:17)</a>:</h4>
<p>I keep getting these errors when I try to define a matrix. I have mathlib installed and working and already did <code>import data.matrix.basic</code> and <code>import data.matrix.pequiv</code>. I feel like I'm missing something obvious <a href="/user_uploads/3121/DWz5s-U1nM1EyKseZH0CKRwu/Screen-Shot-2020-02-23-at-11.14.34-PM.png" target="_blank" title="Screen-Shot-2020-02-23-at-11.14.34-PM.png">Screen-Shot-2020-02-23-at-11.14.34-PM.png</a> <a href="/user_uploads/3121/NlA-v6zJheFsLg9m0ruJPiWn/Screen-Shot-2020-02-23-at-11.14.24-PM.png" target="_blank" title="Screen-Shot-2020-02-23-at-11.14.24-PM.png">Screen-Shot-2020-02-23-at-11.14.24-PM.png</a> </p>
<div class="message_inline_image"><a href="/user_uploads/3121/DWz5s-U1nM1EyKseZH0CKRwu/Screen-Shot-2020-02-23-at-11.14.34-PM.png" target="_blank" title="Screen-Shot-2020-02-23-at-11.14.34-PM.png"><img src="/user_uploads/3121/DWz5s-U1nM1EyKseZH0CKRwu/Screen-Shot-2020-02-23-at-11.14.34-PM.png"></a></div><div class="message_inline_image"><a href="/user_uploads/3121/NlA-v6zJheFsLg9m0ruJPiWn/Screen-Shot-2020-02-23-at-11.14.24-PM.png" target="_blank" title="Screen-Shot-2020-02-23-at-11.14.24-PM.png"><img src="/user_uploads/3121/NlA-v6zJheFsLg9m0ruJPiWn/Screen-Shot-2020-02-23-at-11.14.24-PM.png"></a></div><div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">m</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="o">{{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},{</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">}}</span>
</pre></div>

<a name="188898243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188898243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188898243">Alex J. Best (Feb 24 2020 at 04:22)</a>:</h4>
<p>Did you copy this from <a href="#narrow/stream/113488-general/topic/Notation.20for.20matrices.20and.20vectors" title="#narrow/stream/113488-general/topic/Notation.20for.20matrices.20and.20vectors">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation.20for.20matrices.20and.20vectors</a> ? I don't think this way of defining matrices is standard at all.</p>

<a name="188899263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188899263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188899263">Scott Morrison (Feb 24 2020 at 04:53)</a>:</h4>
<p>(I'd recommend not using screenshots: it's worth your effort, and everyone's here, to prepare minimum working examples of the problems you're having. Generally, at least half the time while I'm trying to prepare an example to post here for help, the process of minimising makes me realise what  I'm doing wrong.)</p>

<a name="188904859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188904859" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188904859">Kevin Buzzard (Feb 24 2020 at 07:23)</a>:</h4>
<p>Yeah, screenshots are much harder to view on mobile. Post code!</p>

<a name="188949915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188949915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188949915">Rocky Kamen-Rubio (Feb 24 2020 at 18:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/188899263" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/188899263">said</a>:</p>
<blockquote>
<p>(I'd recommend not using screenshots: it's worth your effort, and everyone's here, to prepare minimum working examples of the problems you're having. Generally, at least half the time while I'm trying to prepare an example to post here for help, the process of minimising makes me realise what  I'm doing wrong.)</p>
</blockquote>
<p>I'll keep that in mind going forward. I did post the code below the screenshot as well, but maybe got hidden because it was only one line. I do think I've relied maybe a little too heavily on screenshots here so I will be more conscientious of that. Thank you!</p>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/188898243" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/188898243">said</a>:</p>
<blockquote>
<p>Did you copy this from <a href="#narrow/stream/113488-general/topic/Notation.20for.20matrices.20and.20vectors" title="#narrow/stream/113488-general/topic/Notation.20for.20matrices.20and.20vectors">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Notation.20for.20matrices.20and.20vectors</a> ? I don't think this way of defining matrices is standard at all.</p>
</blockquote>
<p>I did! Looking back at that post I'm realizing that initially I thought that notation was standard and the post was about defining new notation for other operations. I got it to work using functions, but am still wondering if there's a better way to define a matrix with arbitrary values than defining a function like this</p>
<div class="codehilite"><pre><span></span><span class="c1">--Lambda definition. This seems ok if there&#39;s a functional relationship between the values x and y and the element at position (x,y)</span>
<span class="n">def</span> <span class="n">m</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">5</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">5</span><span class="o">)</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">5</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">5</span><span class="o">),</span> <span class="o">(</span><span class="mi">10</span><span class="bp">*</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">))</span>

<span class="c1">--inconvenient function definition. I know I could condense this down to a single lambda statement, but it still doesn&#39;t seem great if I have a list of values I want to turn into a matrix. Is this a necessary consequence of functional programming? I&#39;m not seeing a more convenient &quot;constructor &quot; in mathlib/src/data/matrix</span>

<span class="n">def</span> <span class="n">r1</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">))</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="k">then</span> <span class="mi">2</span> <span class="k">else</span>
  <span class="mi">3</span>

<span class="n">def</span> <span class="n">r2</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)):</span> <span class="bp">ℕ</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">then</span> <span class="mi">4</span> <span class="k">else</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="k">then</span> <span class="mi">5</span> <span class="k">else</span>
  <span class="mi">6</span>

<span class="n">def</span> <span class="n">r3</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)):</span> <span class="bp">ℕ</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">then</span> <span class="mi">7</span> <span class="k">else</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">)</span> <span class="k">then</span> <span class="mi">8</span> <span class="k">else</span>
  <span class="mi">9</span>

<span class="n">def</span> <span class="n">c</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">r1</span> <span class="k">else</span>
<span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">2</span> <span class="k">then</span> <span class="n">r2</span> <span class="k">else</span>
<span class="n">r3</span>

<span class="n">def</span> <span class="n">myMatrix</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">c</span>

<span class="c1">--EDIT: somewhat better way of representing a matrix but this still doesn&#39;t seem great.</span>
<span class="n">def</span> <span class="n">myMatrix2</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">3</span><span class="o">),</span>
<span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span>
  <span class="k">if</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span>
  <span class="k">if</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">2</span> <span class="k">then</span> <span class="mi">2</span> <span class="k">else</span>
  <span class="mi">3</span>
<span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">2</span> <span class="k">then</span>
  <span class="k">if</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">4</span> <span class="k">else</span>
  <span class="k">if</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">2</span> <span class="k">then</span> <span class="mi">5</span> <span class="k">else</span>
  <span class="mi">6</span>
<span class="k">else</span>
  <span class="k">if</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">7</span> <span class="k">else</span>
  <span class="k">if</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">2</span> <span class="k">then</span> <span class="mi">8</span> <span class="k">else</span>
  <span class="mi">9</span>
</pre></div>

<a name="188951206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188951206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188951206">Bryan Gin-ge Chen (Feb 24 2020 at 18:16)</a>:</h4>
<p>Do you know about <a href="https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html#pattern-matching" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html#pattern-matching">pattern-matching syntax</a>?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">r1</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">3</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="mi">2</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="o">:=</span> <span class="mi">2</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="mi">3</span>
</pre></div>

<a name="188953287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188953287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188953287">Alex J. Best (Feb 24 2020 at 18:42)</a>:</h4>
<p>You could define a little helper function like this:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span><span class="bp">.</span><span class="n">defs</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">α</span><span class="o">]</span>

<span class="n">def</span> <span class="n">list_of_list_to_mat</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">ll</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="o">(</span><span class="n">ll</span><span class="bp">.</span><span class="n">inth</span> <span class="o">(</span><span class="err">↑</span><span class="n">x</span><span class="o">))</span><span class="bp">.</span><span class="n">inth</span> <span class="o">(</span><span class="err">↑</span><span class="n">y</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="o">(</span><span class="n">list_of_list_to_mat</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">]]</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">ℤ</span><span class="o">)</span>  <span class="mi">1</span> <span class="mi">0</span>
</pre></div>

<a name="188962767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/188962767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#188962767">Rocky Kamen-Rubio (Feb 24 2020 at 20:29)</a>:</h4>
<p>Cool! This seems useful. Thank you!</p>

<a name="189395405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189395405" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189395405">Ethan Horsfall (Feb 29 2020 at 16:07)</a>:</h4>
<p>for the logic and proof tutorial, when i run the code in visual studios it sometimes doesn't run and instead  just says 'updating' indefinitely.  This has happened on a few examples. The current one is <br>
variables A B : Prop</p>
<p>example : A ∧ ¬ B → ¬ B ∧ A :=<br>
assume h : A ∧ ¬ B,<br>
show ¬ B ∧ A, from and.intro (and.right h) (and.left h)</p>
<p>While on my RHS under 'Lean messages' it says 'Updating'</p>

<a name="189395578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189395578" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189395578">Johan Commelin (Feb 29 2020 at 16:12)</a>:</h4>
<p>Pro tip:</p>
<div class="codehilite"><pre><span></span>```lean
code like this gets highlighted
```
</pre></div>

<a name="189395588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189395588" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189395588">Johan Commelin (Feb 29 2020 at 16:12)</a>:</h4>
<p>Concerning your question: how have you installed Lean?</p>

<a name="189396573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189396573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189396573">Ethan Horsfall (Feb 29 2020 at 16:44)</a>:</h4>
<p>I followed the instructions from 'logical verification in lean' and then enabled the extension in VS studios. When doing that one of the steps I think didn't work (or, I messed it up, which is probably the case as I have never used vs studios before). Some of the code is running however. I can always use the online browser tool for the moment</p>

<a name="189397010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189397010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189397010">Kevin Buzzard (Feb 29 2020 at 16:58)</a>:</h4>
<p>NB it's supposed to say "updating" indefinitely. This just means "if you press a button, I'll update"</p>

<a name="189397072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189397072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189397072">Patrick Massot (Feb 29 2020 at 17:00)</a>:</h4>
<p>We really <em>really</em> need to rephrase that "Updating". Every newbie gets confused by this message.</p>

<a name="189397150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189397150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189397150">Kevin Buzzard (Feb 29 2020 at 17:03)</a>:</h4>
<p>How about "ready"?</p>

<a name="189398804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189398804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189398804">Bryan Gin-ge Chen (Feb 29 2020 at 17:56)</a>:</h4>
<p>Maybe "Active" or "Live" makes more sense since Lean may or may not be busy processing stuff? </p>
<p>The intention of that button is to be able to pause / unpause the updating of the info view. This is useful if you're making changes to a slow proof and you want to keep the info view from refreshing over and over while you refer to something in the context.</p>

<a name="189401737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189401737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189401737">Patrick Massot (Feb 29 2020 at 19:15)</a>:</h4>
<p>Maybe the clearest thing would be to name the button rather than describing state. For instance "Freeze display"/"Unfreeze display"</p>

<a name="189402183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189402183" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189402183">Kevin Buzzard (Feb 29 2020 at 19:27)</a>:</h4>
<p>The issue is not when expert users are editing a slow proof, the issue is when beginners think that Lean has hung because (a) it doesn't seem to be doing anything [because everything is working] and (b) it says "updating" in the top right [which makes it sound a lot like Lean is doing something]. This can happen in particular if a user has managed to click on the "display messages" button rather than the "display goal" button -- if all is well then "display messages" can be empty, so Lean just "sits there updating".</p>
<p>If we're in the business of changing stuff like this, can we also change the "Lean Messages" title of the "Display Goal" view to "Lean Goal"?</p>

<a name="189402410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189402410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189402410">Bryan Gin-ge Chen (Feb 29 2020 at 19:33)</a>:</h4>
<p>I agree completely. I'll make a PR later with some changes.</p>

<a name="189403135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189403135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189403135">Bryan Gin-ge Chen (Feb 29 2020 at 19:54)</a>:</h4>
<p>Would it actually even be better if we just removed the text next to the button altogether? The button already has a tooltip assigned to it that says "Stop updating" / "Continue updating", which I can change to "Freeze display" / "Unfreeze display".</p>

<a name="189405092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189405092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189405092">Kevin Buzzard (Feb 29 2020 at 20:55)</a>:</h4>
<p>Kids these days all speak some universal language of symbols, and that pause button symbol is certainly one of the standard symbols in this language, as is the green triangle which appears when you click it.</p>

<a name="189405098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189405098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189405098">Patrick Massot (Feb 29 2020 at 20:55)</a>:</h4>
<p>Yes, maybe removing the words would be enough.</p>

<a name="189405453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189405453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189405453">Bryan Gin-ge Chen (Feb 29 2020 at 21:06)</a>:</h4>
<p><span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>
<p>PR: <a href="https://github.com/leanprover/vscode-lean/pull/145" target="_blank" title="https://github.com/leanprover/vscode-lean/pull/145">https://github.com/leanprover/vscode-lean/pull/145</a></p>

<a name="189408266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189408266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189408266">Reid Barton (Feb 29 2020 at 22:35)</a>:</h4>
<p>you don't press ctrl-S to freeze the info window, and ctrl-Q to unfreeze it?</p>

<a name="189408270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189408270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189408270">Reid Barton (Feb 29 2020 at 22:35)</a>:</h4>
<p>Kids these days</p>

<a name="189408384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189408384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189408384">Bryan Gin-ge Chen (Feb 29 2020 at 22:39)</a>:</h4>
<p>Haha, you could bind both ctrl+S and ctrl+Q to <code>lean.infoView.toggleUpdating</code> for that old-school feel if you really wanted.</p>

<a name="189460298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189460298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189460298">Bobby Lindsey (Mar 02 2020 at 03:21)</a>:</h4>
<p>Hey guys, hoping I can contribute to this project. But having a hard time figuring out where (other than "issues" list in GitHub). E.g. this page of list of theorems that have been proved lead to 404 errors: <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/theories.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/theories.md">https://github.com/leanprover-community/mathlib/blob/master/docs/theories.md</a>. Recommendations for good places to start?</p>

<a name="189460398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189460398" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189460398">Yury G. Kudryashov (Mar 02 2020 at 03:24)</a>:</h4>
<p>Which area of mathematics do you prefer?</p>

<a name="189460403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189460403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189460403">Yury G. Kudryashov (Mar 02 2020 at 03:24)</a>:</h4>
<p>There are plenty of holes in any area.</p>

<a name="189460420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189460420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189460420">Yury G. Kudryashov (Mar 02 2020 at 03:26)</a>:</h4>
<p>By "holes" I mean "not yet formalized definitions/theorems".</p>

<a name="189460459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189460459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189460459">Bobby Lindsey (Mar 02 2020 at 03:26)</a>:</h4>
<p>Probability, stats, or linear algebra. But not sure if all undergrad theorems/lemma have been implemented already... I only have a M.S. in math. I'd be happy to attempt to contribute elsewhere though if need be</p>

<a name="189460641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189460641" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189460641">Yury G. Kudryashov (Mar 02 2020 at 03:32)</a>:</h4>
<p>We have some linear algebra and measure theory. There should be quite a few holes in our linear algebra library but I notice them only when I need them, so let's wait for someone who has better understanding of the current state of <code>src/linear_algebra</code>.</p>

<a name="189460717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189460717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189460717">Mario Carneiro (Mar 02 2020 at 03:35)</a>:</h4>
<p>Not sure what's up with the broken links. <span class="user-mention" data-user-id="110032">@Reid Barton</span> you were the last one to touch this file, where have the <code>functions.md</code> et al files gone?</p>

<a name="189460763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189460763" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189460763">Reid Barton (Mar 02 2020 at 03:36)</a>:</h4>
<p>The topology one isn't broken <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>

<a name="189460765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189460765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189460765">Bobby Lindsey (Mar 02 2020 at 03:36)</a>:</h4>
<p>Other than cross referencing linear algebra theorems/lemmas with those mentioned in textbooks, is there any better way to enumerate these holes? Better yet, an index of what has been proven would go a long way... perhaps this documentation is something I can help out with as well</p>

<a name="189460780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189460780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189460780">Mario Carneiro (Mar 02 2020 at 03:37)</a>:</h4>
<p>The enumeration of holes is difficult because the set of holes in mathlib is cofinite</p>

<a name="189460886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189460886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189460886">Mario Carneiro (Mar 02 2020 at 03:40)</a>:</h4>
<p>As for what has been proven, there are of course the source files themselves, which take some getting used to but are not an unreasonable way to familiarize yourself with the contents. But the <a href="https://leanprover-community.github.io/mathlib_docs/linear_algebra/basic.html" target="_blank" title="https://leanprover-community.github.io/mathlib_docs/linear_algebra/basic.html">mathlib docs</a> are a less intimidating view on the source files</p>

<a name="189460942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189460942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189460942">Yury G. Kudryashov (Mar 02 2020 at 03:42)</a>:</h4>
<p>If you see a theorem that has a name, then adding a docstring with this name is definitely worth a PR.</p>

<a name="189461125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189461125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189461125">Bobby Lindsey (Mar 02 2020 at 03:48)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> , I'll check those docs out. And thanks <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> for the suggestion. I'll start combing through the linear_algebra module and cross-referencing its contents with theorems/lemmas in some textbooks I have, and try to fill in any documentation and missing theorems/lemmas along the way. Thanks guys :)</p>

<a name="189511138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189511138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189511138">Sam Stites (Mar 02 2020 at 16:59)</a>:</h4>
<p>I'm trying to say the following lemma: Let A be a ring with the following properties: for all rings R, there exists a unique homomorphism A → R. Then A ≅ ℤ.</p>
<p>I have a few attempts, but could someone help me formulate this? My first attempt looks like the following (It's basically how I would do this in haskell):</p>
<div class="codehilite"><pre><span></span>import algebra.ring
import logic.unique

variables (A : ring Type) (R : ring Type)
lemma lemma03_v0 : A → (∀ R → unique (A → R)) → (A ≅ ℤ) := sorry
</pre></div>


<p>Things that I think are wrong: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi></mrow><annotation encoding="application/x-tex">\forall</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span></span></span></span> should be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi></mrow><annotation encoding="application/x-tex">\exists</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∃</span></span></span></span> and maybe there should only be one  → before A ≅ ℤ? I still get a lot of unexpected tokens or invalid expressions, though.</p>

<a name="189511383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189511383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189511383">Anne Baanen (Mar 02 2020 at 17:01)</a>:</h4>
<p>To say "A is a ring", you can write <code>variables (A : Type*) [ring A]</code>. In Haskell terms, <code>[ring A]</code> can be interpreted as the typeclass constraint <code>(Ring A) =&gt; ...</code></p>

<a name="189511584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189511584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189511584">Anne Baanen (Mar 02 2020 at 17:03)</a>:</h4>
<p>The next error is <code>∀ R → ...</code>: the <code>→</code> should be a <code>,</code> (something that I still mess up continually, coming from Agda)</p>

<a name="189511929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189511929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189511929">Reid Barton (Mar 02 2020 at 17:07)</a>:</h4>
<p>This kind of thing is easier using the bundled/category theory approach</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">category</span><span class="bp">.</span><span class="n">CommRing</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">})</span>
<span class="kn">lemma</span> <span class="n">lemma03_v0</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">Ring</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}),</span> <span class="n">unique</span> <span class="o">(</span><span class="n">A</span> <span class="err">⟶</span> <span class="n">R</span><span class="o">))</span> <span class="bp">→</span> <span class="o">(</span><span class="n">A</span> <span class="err">≅</span> <span class="n">Ring</span><span class="bp">.</span><span class="n">of</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>

<a name="189512999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189512999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189512999">Reid Barton (Mar 02 2020 at 17:17)</a>:</h4>
<p>otherwise, I think it's</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">A</span><span class="o">]</span>
<span class="kn">lemma</span> <span class="n">lemma03_v0</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">],</span> <span class="k">by</span> <span class="n">exactI</span> <span class="n">unique</span> <span class="o">(</span><span class="n">ring_hom</span> <span class="n">A</span> <span class="n">R</span><span class="o">))</span> <span class="bp">→</span> <span class="o">(</span><span class="n">A</span> <span class="err">≃</span><span class="bp">+*</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>

<a name="189513225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189513225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189513225">Patrick Massot (Mar 02 2020 at 17:18)</a>:</h4>
<p>Why would you use the Pi notation instead of forall here? I know they are the same to Lean, I'm asking about psychology</p>

<a name="189513296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189513296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189513296">Reid Barton (Mar 02 2020 at 17:19)</a>:</h4>
<p>Well, <code>unique</code> is data. Really it should be <code>def</code> too, and not <code>lemma</code></p>

<a name="189513392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189513392" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189513392">Patrick Massot (Mar 02 2020 at 17:20)</a>:</h4>
<p>Oh. I would have never suspected <code>unique</code> to be data.</p>

<a name="189513458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189513458" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189513458">Johan Commelin (Mar 02 2020 at 17:20)</a>:</h4>
<p>Yeah, I should have called it <code>cunique</code>...</p>

<a name="189513488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189513488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189513488">Johan Commelin (Mar 02 2020 at 17:21)</a>:</h4>
<p>But now you have a chance to PR <code>discrete_unique</code>. Doesn't that make you feel happy?</p>

<a name="189513724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189513724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189513724">Sam Stites (Mar 02 2020 at 17:23)</a>:</h4>
<p>cool!  thanks for all of this -- I'm running into some weird compilation stuff right now (probably need to clean up this experiment-repo).</p>

<a name="189513824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189513824" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189513824">Patrick Massot (Mar 02 2020 at 17:24)</a>:</h4>
<p>The version without category stuff doesn't read nice, but I guess this is fair: the lemma is really category theoretic in flavor.</p>

<a name="189513857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189513857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189513857">Patrick Massot (Mar 02 2020 at 17:24)</a>:</h4>
<p>Sam, do you understand what <code>exactI</code> is doing?</p>

<a name="189514110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189514110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189514110">Sam Stites (Mar 02 2020 at 17:27)</a>:</h4>
<p>not at the moment (I was going to wait for matlib to rebuild before examining in depth). I am also wondering what the longer arrow is in your unique (A --&gt; R) is.</p>

<a name="189514150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189514150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189514150">Patrick Massot (Mar 02 2020 at 17:27)</a>:</h4>
<p>Why are you rebuilding mathlib?</p>

<a name="189514227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189514227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189514227">Patrick Massot (Mar 02 2020 at 17:28)</a>:</h4>
<p>Reid's longer arrow is Hom in the category library.</p>

<a name="189514228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189514228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189514228">Sam Stites (Mar 02 2020 at 17:28)</a>:</h4>
<p>Oh! it's a tactic? I was about to start reading that chapter next.</p>

<a name="189514247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189514247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189514247">Sam Stites (Mar 02 2020 at 17:28)</a>:</h4>
<p>cool</p>

<a name="189514267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189514267" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189514267">Patrick Massot (Mar 02 2020 at 17:28)</a>:</h4>
<p>Yes, <code>exactI</code> is a tactic, and not the easiest one to understand.</p>

<a name="189514314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189514314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189514314">Patrick Massot (Mar 02 2020 at 17:28)</a>:</h4>
<p>But first we need to make sure you don't need to rebuild mathlib. Why do you think you need to do that?</p>

<a name="189514564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189514564" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189514564">Sam Stites (Mar 02 2020 at 17:31)</a>:</h4>
<p>ehh... it's a little silly -- I am using emacs for the first time (normally I use vim) and flycheck seems to be maxing out on errors. I think it's a caching issue since I was trying to use some certigrad files.</p>

<a name="189514650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189514650" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189514650">Patrick Massot (Mar 02 2020 at 17:31)</a>:</h4>
<p>Lean is already difficult, don't add emacs difficulty on top of it if you are not a emacs user.</p>

<a name="189514735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189514735" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189514735">Patrick Massot (Mar 02 2020 at 17:32)</a>:</h4>
<p>Why don't you use VScode?</p>

<a name="189514751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189514751" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189514751">Sam Stites (Mar 02 2020 at 17:32)</a>:</h4>
<p>ah, it's working out fine, actually! that's not my main concern : )</p>

<a name="189514811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189514811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189514811">Sam Stites (Mar 02 2020 at 17:33)</a>:</h4>
<p>Yeah, so I've cleaned up the repo and rebuilt with <code>leanpkg build</code> -- the flycheck seems to be working perfectly fine now</p>

<a name="189514936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189514936" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189514936">Sam Stites (Mar 02 2020 at 17:34)</a>:</h4>
<p>I'm at the point in my programming career where it's quite painful not to use vim and emacs has good support for this via spacemacs. It's self-inflicted pain, no need to worry about it!</p>

<a name="189514965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189514965" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189514965">Johan Commelin (Mar 02 2020 at 17:34)</a>:</h4>
<p>VScode has a vim plugin</p>

<a name="189514976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189514976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189514976">Johan Commelin (Mar 02 2020 at 17:34)</a>:</h4>
<p>Both Patrick and I use it.</p>

<a name="189515031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189515031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189515031">Johan Commelin (Mar 02 2020 at 17:35)</a>:</h4>
<p>It doesn't have <em>all</em> the goodies of regular vim, but it's quite close.</p>

<a name="189515064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189515064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189515064">Sam Stites (Mar 02 2020 at 17:35)</a>:</h4>
<p>okay! I'll check it out as well</p>

<a name="189515143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189515143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189515143">Patrick Massot (Mar 02 2020 at 17:36)</a>:</h4>
<p>I still strongly advise you to use VScode. But let's go back to <code>exactI</code> because I have very little time before leaving my office (Paris time-zone). So the issue is <code>ring_hom A R</code> expects to find a (semi)-ring structure on <code>A</code> and <code>R</code> by type class search. The one on <code>A</code> will be found without problem, because it's there from the beginning. The one on <code>R</code> is mentioned too late in the game to be picked up if you don't ask Lean to search. That's what <code>exactI</code> is doing (asking Lean).</p>

<a name="189515288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189515288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189515288">Patrick Massot (Mar 02 2020 at 17:37)</a>:</h4>
<p>If you want to avoid that <code>exactI</code> you'll need to tell Lean to forget about how this semi-ring structure was meant to be found, and provide it yourself. This would be:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">lemma03_v0&#39;</span> <span class="o">:</span>
<span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span> <span class="n">hR</span> <span class="o">:</span> <span class="n">ring</span> <span class="n">R</span><span class="o">),</span> <span class="bp">∃!</span> <span class="n">φ</span> <span class="o">:</span> <span class="bp">@</span><span class="n">ring_hom</span> <span class="n">A</span> <span class="n">R</span> <span class="bp">_</span> <span class="n">hR</span><span class="bp">.</span><span class="n">to_semiring</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">A</span> <span class="err">≃</span><span class="bp">+*</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>


<p>which also has a silly way of saying there exists a unique <code>φ</code> with type <code>@ring_hom A R _ hR.to_semiring</code>.</p>

<a name="189515340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189515340" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189515340">Patrick Massot (Mar 02 2020 at 17:38)</a>:</h4>
<p>Now I need to go. Have fun!</p>

<a name="189515397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189515397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189515397">Sam Stites (Mar 02 2020 at 17:38)</a>:</h4>
<p>thank you!</p>

<a name="189518730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189518730" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189518730">Kevin Buzzard (Mar 02 2020 at 18:10)</a>:</h4>
<p>If you move the universal hypothesis before the colon, you don't need all this exactI stuff:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">A</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">lemma03_v0&#39;</span> <span class="o">(</span><span class="n">huniv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">],</span> <span class="bp">∃!</span> <span class="n">φ</span> <span class="o">:</span> <span class="n">ring_hom</span> <span class="n">A</span> <span class="n">R</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="err">≃</span><span class="bp">+*</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>

<a name="189520450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189520450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189520450">Kevin Buzzard (Mar 02 2020 at 18:29)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">A</span><span class="o">]</span>

<span class="n">noncomputable</span> <span class="kn">lemma</span> <span class="n">lemma03_v0&#39;</span> <span class="o">(</span><span class="n">huniv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">],</span> <span class="bp">∃!</span> <span class="n">φ</span> <span class="o">:</span> <span class="n">ring_hom</span> <span class="n">A</span> <span class="n">R</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="err">≃</span><span class="bp">+*</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="o">(</span><span class="n">huniv</span> <span class="bp">ℤ</span><span class="o">))</span><span class="bp">.</span><span class="n">to_fun</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- what&#39;s the map from ℤ to an arbitrary ring?</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="o">(</span><span class="n">huniv</span> <span class="bp">ℤ</span><span class="o">))</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span>
  <span class="n">map_add&#39;</span> <span class="o">:=</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="o">(</span><span class="n">huniv</span> <span class="bp">ℤ</span><span class="o">))</span><span class="bp">.</span><span class="n">map_add</span> <span class="o">}</span>
</pre></div>


<p>Once I figure out the name of the canonical map from the integers to an arbitrary ring, I think we're nearly done (the ring hom A -&gt; A must be the identity by uniqueness).</p>

<a name="189520662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189520662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189520662">Kevin Buzzard (Mar 02 2020 at 18:31)</a>:</h4>
<p>Oh -- I hadn't seen the <code>unique</code> trick, that makes it cleaner.</p>

<a name="189520688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189520688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189520688">Reid Barton (Mar 02 2020 at 18:31)</a>:</h4>
<p>I hadn't realized the "left of the colon" would work that way in this context, thanks.</p>

<a name="189520789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189520789" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189520789">Kevin Buzzard (Mar 02 2020 at 18:32)</a>:</h4>
<p>Funnily enough, I realised this myself just the other day when I was trying to formalise the assertion that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>×</mo><mi>Y</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\times Y\to Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> was always closed then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> was compact.</p>

<a name="189520886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189520886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189520886">Kevin Buzzard (Mar 02 2020 at 18:33)</a>:</h4>
<p>Another thing I noticed was that if I restricted to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> in the same universe as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> then the result was actually stronger not weaker -- universe monomorphism FTW. The same is going on in here (possibly unintentionally)</p>

<a name="189521038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521038">Kevin Buzzard (Mar 02 2020 at 18:34)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">A</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">lemma03_v0&#39;</span> <span class="o">(</span><span class="n">huniv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">],</span> <span class="n">unique</span> <span class="o">(</span><span class="n">ring_hom</span> <span class="n">A</span> <span class="n">R</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="err">≃</span><span class="bp">+*</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="o">(</span><span class="n">huniv</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">.</span><span class="n">default</span><span class="bp">.</span><span class="n">to_fun</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- what&#39;s the map from ℤ to an arbitrary ring?</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="o">(</span><span class="n">huniv</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">.</span><span class="n">default</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span>
  <span class="n">map_add&#39;</span> <span class="o">:=</span> <span class="o">(</span><span class="n">huniv</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">.</span><span class="n">default</span><span class="bp">.</span><span class="n">map_add</span> <span class="o">}</span>
</pre></div>

<a name="189521070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521070">Yury G. Kudryashov (Mar 02 2020 at 18:34)</a>:</h4>
<p>I don't think that it's stronger because you can't say "for all <code>Y</code> from all universes"</p>

<a name="189521122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521122">Kevin Buzzard (Mar 02 2020 at 18:35)</a>:</h4>
<p>Yes but this is an input, not an output, so if I know it for all Y in all universes, I can deduce it for all Y in the same universe as X, which is all I need.</p>

<a name="189521133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521133">Yury G. Kudryashov (Mar 02 2020 at 18:35)</a>:</h4>
<p>So, if you use <code>(X : Type u) (Y : Type v)</code>, then it says "if for all <code>Y</code> from some universe <code>v</code> (possibly not <code>u</code>), then ..."</p>

<a name="189521298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521298">Kevin Buzzard (Mar 02 2020 at 18:37)</a>:</h4>
<p>Yes.</p>

<a name="189521335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521335" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521335">Yury G. Kudryashov (Mar 02 2020 at 18:37)</a>:</h4>
<p>And this does not immediately imply "for all <code>Y : Type u</code>"</p>

<a name="189521347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521347">Kevin Buzzard (Mar 02 2020 at 18:37)</a>:</h4>
<p>Yes.</p>

<a name="189521402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521402">Kevin Buzzard (Mar 02 2020 at 18:38)</a>:</h4>
<p>But u might equal v</p>

<a name="189521419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521419">Kevin Buzzard (Mar 02 2020 at 18:38)</a>:</h4>
<p>so in this case, I win (and I agree that usually I lose)</p>

<a name="189521461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521461">Yury G. Kudryashov (Mar 02 2020 at 18:38)</a>:</h4>
<p>So, the result with <code>(X : Type u) (Y : Type v)</code> is stronger.</p>

<a name="189521471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521471">Kevin Buzzard (Mar 02 2020 at 18:38)</a>:</h4>
<p>No</p>

<a name="189521485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521485">Kevin Buzzard (Mar 02 2020 at 18:39)</a>:</h4>
<p>because I am demanding more from my input and only getting the same for my output</p>

<a name="189521597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521597">Kevin Buzzard (Mar 02 2020 at 18:40)</a>:</h4>
<p>The point is exactly that this is not <code>def f (X : Type u) (Y : Type v) ...</code></p>

<a name="189521736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521736">Kevin Buzzard (Mar 02 2020 at 18:41)</a>:</h4>
<p>I'm saying "assume that something is true for all Y in the same universe as X. Then P(X)", which is a better thing to do than saying "assume that something is true for all Y in all universes, including X's and others. Then P(X)"</p>

<a name="189521739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521739">Yury G. Kudryashov (Mar 02 2020 at 18:41)</a>:</h4>
<p>Try this:</p>
<div class="codehilite"><pre><span></span><span class="n">universes</span> <span class="n">v</span> <span class="n">u</span>
<span class="kn">constant</span> <span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kn">axiom</span> <span class="n">L1</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">X</span> <span class="n">Y</span>
<span class="kn">lemma</span> <span class="n">L2</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">X</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">L1</span> <span class="n">X</span> <span class="n">Y</span>
</pre></div>

<a name="189521755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521755">Kevin Buzzard (Mar 02 2020 at 18:42)</a>:</h4>
<p>Your examples are not a good mirror of what is going on here.</p>

<a name="189521831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521831">Kevin Buzzard (Mar 02 2020 at 18:42)</a>:</h4>
<p>Read the statement of the lemma.</p>

<a name="189521883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521883" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521883">Yury G. Kudryashov (Mar 02 2020 at 18:43)</a>:</h4>
<p>OK, which lemma are we talking about?</p>

<a name="189521928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189521928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189521928">Kevin Buzzard (Mar 02 2020 at 18:43)</a>:</h4>
<p><code>lemma lemma03_v0' (A : Type) [ring A]  (huniv : ∀ (R : Type) [ring R], unique (ring_hom A R)) : (A ≃+* ℤ) := ...</code></p>

<a name="189522000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189522000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189522000">Kevin Buzzard (Mar 02 2020 at 18:44)</a>:</h4>
<p>If I let <code>R : Type u</code> then <code>huniv</code> is harder to verify, but the result is still the same.</p>

<a name="189522076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189522076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189522076">Kevin Buzzard (Mar 02 2020 at 18:45)</a>:</h4>
<p>So it seems to be a weird case where less polymorphism is better. I noticed this last week when I was proving that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>×</mo><mi>Y</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\times Y\to Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> is closed for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> is compact.</p>

<a name="189522090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189522090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189522090">Yury G. Kudryashov (Mar 02 2020 at 18:45)</a>:</h4>
<p>Ah, it should be</p>
<div class="codehilite"><pre><span></span><span class="n">universes</span> <span class="n">v</span> <span class="n">u</span>
<span class="kn">constant</span> <span class="n">p</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kn">constant</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kn">axiom</span> <span class="n">L1</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">,</span> <span class="n">p</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="n">X</span>
<span class="kn">lemma</span> <span class="n">L2</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span> <span class="n">p</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="n">X</span> <span class="o">:=</span> <span class="n">L1</span> <span class="n">X</span> <span class="n">H</span>
</pre></div>

<a name="189522261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189522261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189522261">Kevin Buzzard (Mar 02 2020 at 18:46)</a>:</h4>
<p>I was trying to prove this for all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> in all universes, and then I ran into some issue with universes, so then I thought "crap I am going to have to restrict to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> in the same universe as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>" and then I thought "oh wait, that's a <em>stronger</em> result!"</p>

<a name="189522372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189522372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189522372">Kevin Buzzard (Mar 02 2020 at 18:47)</a>:</h4>
<p>wait -- so you're still saying I'm wrong? :-/</p>

<a name="189522952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189522952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189522952">Yury G. Kudryashov (Mar 02 2020 at 18:53)</a>:</h4>
<p>Actually <code>L1</code> is not one axiom but a series of axioms enumerated by <code>v</code> and <code>u</code>.</p>

<a name="189523336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189523336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189523336">Kevin Buzzard (Mar 02 2020 at 18:56)</a>:</h4>
<p>I completely see that your code compiles. However what is wrong with the argument that says the following: I have X and I want to prove <code>q X</code>. Now <code>X</code> is in a universe <code>u</code>. Would I rather prove <code>H X Y</code> for all <code>Y</code> in all universes <code>v</code>, or would I rather prove <code>H X Y</code> in the easier case that <code>Y</code> is in universe <code>u</code> as well? Clearly I would rather stick to <code>Y</code> in universe <code>u</code>, so <code>L2</code> is a more useful lemma than <code>L1</code> because it applies more widely.</p>

<a name="189523452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189523452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189523452">Reid Barton (Mar 02 2020 at 18:57)</a>:</h4>
<p>Kevin you're comparing <code>L2</code> with a hypothetical <code>L2'</code> that can't be expressed in Lean, but would look something like <code>(X : Type u) (H : forall v (Y : Type v), p X Y) -&gt; q X</code></p>

<a name="189523489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189523489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189523489">Reid Barton (Mar 02 2020 at 18:58)</a>:</h4>
<p>And you're correct that <code>L2</code> is stronger than <code>L2'</code></p>

<a name="189523547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189523547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189523547">Johan Commelin (Mar 02 2020 at 18:58)</a>:</h4>
<p>Apparently in Lean it's not <code>forall v</code> but <code>exists v</code></p>

<a name="189523553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189523553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189523553">Kevin Buzzard (Mar 02 2020 at 18:58)</a>:</h4>
<p>L1?</p>

<a name="189523562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189523562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189523562">Reid Barton (Mar 02 2020 at 18:58)</a>:</h4>
<p>Yury's <code>L1</code> becomes <code>L2</code> when you specialize it to <code>v = u</code></p>

<a name="189523564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189523564" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189523564">Johan Commelin (Mar 02 2020 at 18:58)</a>:</h4>
<p>Unless you require <code>v = u</code></p>

<a name="189523623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189523623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189523623">Reid Barton (Mar 02 2020 at 18:59)</a>:</h4>
<p>Probably <code>L1</code> is false in this setting if you allow <code>v &lt; u</code>. You would only be able to show compactness for <code>v</code>-sized filters, roughly</p>

<a name="189523810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189523810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189523810">Reid Barton (Mar 02 2020 at 19:00)</a>:</h4>
<p>The other thing going on here is that in the implication in the other direction, you can state it for all <code>v</code> (because now <code>v</code> is at the outer level) and it is true.</p>

<a name="189523858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189523858" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189523858">Reid Barton (Mar 02 2020 at 19:01)</a>:</h4>
<p>So for <code>X : Top.{u}</code>, you have "<code>X</code> is <code>u</code>-universally closed" =&gt; "<code>X</code> is compact" =&gt; "for any <code>v</code>, <code>X</code> is <code>v</code>-universally closed"</p>

<a name="189523868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189523868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189523868">Reid Barton (Mar 02 2020 at 19:01)</a>:</h4>
<p>and in that sense you've proved a stronger statement than you expected</p>

<a name="189524363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189524363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189524363">Kevin Buzzard (Mar 02 2020 at 19:06)</a>:</h4>
<p>No wonder I was having trouble proving it in the fully polymorphic setting! I wanted to let Y be this <code>option X</code> with a filter topology.</p>

<a name="189524615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189524615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189524615">Reid Barton (Mar 02 2020 at 19:08)</a>:</h4>
<p>To take a slightly silly extreme case, it's clearly not true if you only allow <code>Y</code> to range over <code>Prop</code>/subsingletons</p>

<a name="189524699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189524699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189524699">Kevin Buzzard (Mar 02 2020 at 19:09)</a>:</h4>
<p>That was surprisingly interesting/insightful. So back to the original question -- if we make the construction fully universe polymorphic then it seems to me that things get a bit more tedious because I have to start using <code>ulift</code> to get the map from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span> to <code>A</code></p>

<a name="189524992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189524992" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189524992">Reid Barton (Mar 02 2020 at 19:12)</a>:</h4>
<p>Yeah, I stuck to <code>Type 0</code> in order to avoid this <code>ulift</code> stuff. In the "category theory" version it will appear already in the statement, but even in the unbundled version it will appear in the proof.</p>

<a name="189527214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189527214" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189527214">Kevin Buzzard (Mar 02 2020 at 19:31)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group_power</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">A</span><span class="o">]</span>

<span class="n">open_locale</span> <span class="n">add_group</span> <span class="c1">-- breakthrough</span>

<span class="kn">lemma</span> <span class="n">lemma03_v0&#39;</span> <span class="o">(</span><span class="n">huniv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">],</span> <span class="n">unique</span> <span class="o">(</span><span class="n">ring_hom</span> <span class="n">A</span> <span class="n">R</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="err">≃</span><span class="bp">+*</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="o">(</span><span class="n">huniv</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">.</span><span class="n">default</span><span class="bp">.</span><span class="n">to_fun</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="err">•</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="o">(</span><span class="n">huniv</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">.</span><span class="n">default</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span>
  <span class="n">map_add&#39;</span> <span class="o">:=</span> <span class="o">(</span><span class="n">huniv</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">.</span><span class="n">default</span><span class="bp">.</span><span class="n">map_add</span> <span class="o">}</span>
</pre></div>

<a name="189527980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189527980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189527980">Kevin Buzzard (Mar 02 2020 at 19:39)</a>:</h4>
<p>Is this not a thing in mathlib?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">of_int</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">A</span><span class="o">]</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→+*</span> <span class="n">A</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="err">•</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">map_one&#39;</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span><span class="o">,</span>
  <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">show</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="err">•</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span><span class="bp">=</span> <span class="n">x</span> <span class="err">•</span> <span class="mi">1</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="err">•</span> <span class="mi">1</span><span class="o">),</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">gsmul_eq_mul</span><span class="o">],</span>
  <span class="n">map_zero&#39;</span> <span class="o">:=</span> <span class="n">zero_gsmul</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">map_add&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">add_gsmul</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">}</span>
</pre></div>

<a name="189537884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189537884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189537884">Mario Carneiro (Mar 02 2020 at 21:17)</a>:</h4>
<p>That's <code>int.cast</code></p>

<a name="189537902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189537902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189537902">Mario Carneiro (Mar 02 2020 at 21:17)</a>:</h4>
<p>not sure if it's been bundled yet</p>

<a name="189537986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189537986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189537986">Kevin Buzzard (Mar 02 2020 at 21:18)</a>:</h4>
<p>Thanks. I was pretty sure I'd seen it before.</p>

<a name="189538029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189538029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189538029">Mario Carneiro (Mar 02 2020 at 21:18)</a>:</h4>
<p>also known as the coercion from int to a ring</p>

<a name="189542182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189542182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189542182">Kevin Buzzard (Mar 02 2020 at 22:00)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group_power</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">A</span><span class="o">]</span>

<span class="n">def</span> <span class="n">of_int</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→+*</span> <span class="n">A</span> <span class="o">:=</span> <span class="n">ring_hom</span><span class="bp">.</span><span class="n">of</span> <span class="n">coe</span>

<span class="kn">theorem</span> <span class="n">eq_of_int</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→+*</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">φ</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">int</span><span class="bp">.</span><span class="n">induction_on&#39;</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">φ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span> <span class="n">a</span> <span class="mi">0</span>
   <span class="n">φ</span><span class="bp">.</span><span class="n">map_zero</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">k</span> <span class="bp">_</span> <span class="n">hk</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">φ</span><span class="bp">.</span><span class="n">map_add</span><span class="o">,</span> <span class="n">hk</span><span class="o">,</span> <span class="n">φ</span><span class="bp">.</span><span class="n">map_one</span><span class="o">])</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">k</span> <span class="bp">_</span> <span class="n">hk</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">φ</span><span class="bp">.</span><span class="n">map_sub</span><span class="o">,</span> <span class="n">hk</span><span class="o">,</span> <span class="n">φ</span><span class="bp">.</span><span class="n">map_one</span><span class="o">])</span>

<span class="kn">lemma</span> <span class="n">eq_int_of_unique_hom</span> <span class="o">(</span><span class="n">huniv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">],</span> <span class="n">unique</span> <span class="o">(</span><span class="n">ring_hom</span> <span class="n">A</span> <span class="n">R</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="err">≃</span><span class="bp">+*</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="o">(</span><span class="n">huniv</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">.</span><span class="n">default</span><span class="o">,</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="n">of_int</span> <span class="n">A</span><span class="o">,</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">show</span> <span class="bp">_</span> <span class="bp">=</span> <span class="o">(</span><span class="n">ring_hom</span><span class="bp">.</span><span class="n">id</span> <span class="n">A</span><span class="o">)</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="o">(</span><span class="n">huniv</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">uniq</span> <span class="o">(</span><span class="n">ring_hom</span><span class="bp">.</span><span class="n">id</span> <span class="n">A</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">h2</span> <span class="o">:=</span> <span class="o">(</span><span class="n">huniv</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">uniq</span> <span class="o">((</span><span class="n">of_int</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">huniv</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">.</span><span class="n">default</span><span class="o">),</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">h1</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">h2</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">eq_of_int</span> <span class="o">((</span><span class="n">huniv</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">.</span><span class="n">default</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">of_int</span> <span class="n">A</span><span class="o">))</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="o">(</span><span class="n">huniv</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">.</span><span class="n">default</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span>
  <span class="n">map_add&#39;</span> <span class="o">:=</span> <span class="o">(</span><span class="n">huniv</span> <span class="bp">ℤ</span><span class="o">)</span><span class="bp">.</span><span class="n">default</span><span class="bp">.</span><span class="n">map_add</span> <span class="o">}</span>
</pre></div>

<a name="189542738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189542738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189542738">Kevin Buzzard (Mar 02 2020 at 22:05)</a>:</h4>
<p>I hadn't found the coercion earlier because I didn't have the right import. Kind of annoying that I don't know how to say "hey Lean, I want a coercion from int to a ring, go find me one in mathlib". All I knew was that when I tried it, it didn't work.</p>

<a name="189542889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189542889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189542889">Kevin Buzzard (Mar 02 2020 at 22:06)</a>:</h4>
<p>I thought data.equiv.algebra would give me everything ringy, but it was in data.int.basic. I guess this just shows that I don't understand the import tree well enough. I would have guessed integers were more fundamental than ring stuff (probably because I learnt them earlier in my mathematical education)</p>

<a name="189549948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189549948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189549948">Bobby Lindsey (Mar 02 2020 at 23:48)</a>:</h4>
<p>How are we using Kolmogorov axioms for probability theorems? For example, what would lean code look like for P(empty set) = 0. Do we have to appeal to measury theory instead? Sorry, still trying to find my way around this project... but I'm trying to write all probability and stats theorems/lemmas in an undergrad textbook with lean.</p>

<a name="189550091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189550091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189550091">Yury G. Kudryashov (Mar 02 2020 at 23:50)</a>:</h4>
<p>As far as I understand, we don't plan to have a separate probability theory. Just deal with a measure space of total measure one.</p>

<a name="189550227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189550227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189550227">Bobby Lindsey (Mar 02 2020 at 23:52)</a>:</h4>
<p>Would anyone think it'd be useful? I know I would have loved to have something like this while going through probability theory as a student - if anything just to exercise proof-solving skills. But many students who take probability theory don't go on to take measure theory (unless they're math majors).</p>

<a name="189550769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189550769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189550769">Bryan Gin-ge Chen (Mar 03 2020 at 00:00)</a>:</h4>
<p>We're not currently suffering from an overabundance of expository Lean files (to say the least), so yes, I think it'd be very useful!</p>

<a name="189550938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189550938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189550938">Bobby Lindsey (Mar 03 2020 at 00:03)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> :) any suggestions for where to put it in the mathlib project? Like maybe src/probability_theory? Or should expository stuff go somewhere else</p>

<a name="189551029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189551029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189551029">Scott Morrison (Mar 03 2020 at 00:04)</a>:</h4>
<p>Well... it's not exactly clear what place there is for purely "expository" stuff at all.</p>

<a name="189551050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189551050" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189551050">Scott Morrison (Mar 03 2020 at 00:05)</a>:</h4>
<p>We do have the <code>docs/tutorial/</code> folder, which I think is a great place to show people how to do "standard" / "undergraduate" stuff using the highbrow API that Lean tends to provide.</p>

<a name="189551314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189551314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189551314">Bobby Lindsey (Mar 03 2020 at 00:10)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Cool, thanks for the suggestion. Now to figure out how to create all these axioms and whatnot...</p>

<a name="189551548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189551548" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189551548">Bryan Gin-ge Chen (Mar 03 2020 at 00:15)</a>:</h4>
<p>It really depends what you end up formalizing. Stuff that will be useful for future developments shouldn't (only) be in <code>docs/tutorial</code> and should go in something like <code>src/probability_theory</code>. I wouldn't worry about it too much now though.</p>

<a name="189553251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189553251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189553251">Bobby Lindsey (Mar 03 2020 at 00:50)</a>:</h4>
<p>Sooo.. I might be out of my depth here. I'm trying to figure out how to define a sample space to start building Kolmogorov axioms but have no idea how to fit this into LEAN's type theory. I'm afraid I've bit off more than I can chew :( How did you experts bootstrap this learning curve?</p>

<a name="189553690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189553690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189553690">Mario Carneiro (Mar 03 2020 at 00:56)</a>:</h4>
<p>I think it might help to focus your question a bit more. What did you try and how did you get stuck?</p>

<a name="189553811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189553811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189553811">Mario Carneiro (Mar 03 2020 at 00:58)</a>:</h4>
<p>Regarding probability theory, I think we have some things about <code>measure_space</code> and possibly <code>probability_space</code> if <span class="user-mention" data-user-id="116448">@Koundinya Vajjha</span> PR'd his stuff</p>

<a name="189553927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189553927" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189553927">Mario Carneiro (Mar 03 2020 at 01:00)</a>:</h4>
<p>If you look at the definition of <code>outer_measure</code>, <code>measure</code> and <code>measure_space</code> you will get an idea how we do things like <code>P(empty set) = 0</code>. (hint: we write <code>P ∅ = 0</code>)</p>

<a name="189556943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189556943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189556943">Scott Morrison (Mar 03 2020 at 02:03)</a>:</h4>
<p>You might also tell us your background: have you tried formalising anything simpler yet? Have you played the natural numbers game, and/or read some of Theorem Proving in Lean?</p>

<a name="189557835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189557835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189557835">Bobby Lindsey (Mar 03 2020 at 02:24)</a>:</h4>
<p>Haven't formalized anything simple yet - currently working through the natural numbers game. Love it so far. I'm probably getting ahead of myself though which is why looking at formalizing Kolmogorov axioms seems so daunted to me atm :/.</p>

<a name="189596844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189596844" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189596844">Bobby Lindsey (Mar 03 2020 at 14:27)</a>:</h4>
<p>How would I go about defining a probability space in LEAN? This would be some probability triple but what data type would a sample space belong to? I started trying to define the first axioms like <code>def prob_event_nonnegative (E: set ℝ) := { x : ℝ | x ≥ 0}</code> and <code>def prob_sample_space_is_one (Ω: ??) := </code> but I soon realized I don't have a probability space defined. Not sure if I'm on the right track or not, just trying to get to a point where I can start writing prob 101 theorems and solving them</p>

<a name="189598308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189598308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189598308">Johan Commelin (Mar 03 2020 at 14:41)</a>:</h4>
<p>I'm not a probability theorist, so I don't know the maths definitions. Is a probability space just a measure space such that the measure of the total space is 1?</p>

<a name="189599052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189599052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189599052">Bobby Lindsey (Mar 03 2020 at 14:49)</a>:</h4>
<p>Yeah, that's right. I'd like to define it separately so as to assume no knowledge of measure theory though, but having a hard time as to how it should be typed.</p>

<a name="189599531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189599531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189599531">Reid Barton (Mar 03 2020 at 14:53)</a>:</h4>
<p>Do you know about <code>structure</code>s in general?</p>

<a name="189600415"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189600415" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189600415">Bobby Lindsey (Mar 03 2020 at 15:00)</a>:</h4>
<p>I do not. Just found it in the docs though :)</p>

<a name="189600475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189600475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189600475">Reid Barton (Mar 03 2020 at 15:01)</a>:</h4>
<p>If the definitions of measure space and probability space have 90% overlap, then someone interested in probability spaces cannot really have no knowledge of measure theory</p>

<a name="189600728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189600728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189600728">Reid Barton (Mar 03 2020 at 15:03)</a>:</h4>
<p>quite aside from the practical advantages of reusing the existing formalization (no reinvention of wheels, near-duplication of proofs, etc)</p>

<a name="189601161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189601161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189601161">Reid Barton (Mar 03 2020 at 15:08)</a>:</h4>
<p>Of course if your goal is to reinvent wheels and reformalize proofs for learning purposes, that's another matter</p>

<a name="189601613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189601613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189601613">Bobby Lindsey (Mar 03 2020 at 15:13)</a>:</h4>
<p>It's mostly for learning purposes. I'm taking the viewpoint of a student who takes probability theory, like an engineer, but does not go on to taking measure theory.</p>

<a name="189603822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189603822" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189603822">Reid Barton (Mar 03 2020 at 15:33)</a>:</h4>
<p>There is "measure theory" and then there is the definition of a measure space. A student who missed the lecture on the axiom "the probability of the whole space is 1" knows the definition of a measure space. (Okay, maybe not quite since a measure can also take the value <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">+\infty</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span>.)</p>

<a name="189605270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189605270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189605270">Arjun Pitchanathan (Mar 03 2020 at 15:50)</a>:</h4>
<p>Maybe it would be interesting to formalize the proofs of the Markov and Chebyshev inequalities. As far as I can tell they don't exist in mathlib already.</p>

<a name="189655940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/189655940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#189655940">Koundinya Vajjha (Mar 04 2020 at 02:47)</a>:</h4>
<p>I have the Markov+Chebyshev inequalities proven in another repository. I really should PR them. Feel free to build off of these, in any case. </p>
<p><a href="https://github.com/jtristan/stump-learnable/blob/21358ffd6746d838f76b6d1a275d361d5ea66125/src/lib/attributed/to_mathlib.lean#L154" target="_blank" title="https://github.com/jtristan/stump-learnable/blob/21358ffd6746d838f76b6d1a275d361d5ea66125/src/lib/attributed/to_mathlib.lean#L154">https://github.com/jtristan/stump-learnable/blob/21358ffd6746d838f76b6d1a275d361d5ea66125/src/lib/attributed/to_mathlib.lean#L154</a></p>

<a name="190448367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190448367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190448367">Daniel Keys (Mar 12 2020 at 21:37)</a>:</h4>
<p>Here's a stripped-down version of some proofs I need:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="n">n</span><span class="err">^</span><span class="mi">2</span> <span class="bp">&lt;</span> <span class="mi">10</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">Xexplicit</span> <span class="o">:</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="err">⊆</span> <span class="n">X</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">dsimp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="mi">1</span> <span class="err">^</span><span class="mi">2</span> <span class="bp">&lt;</span> <span class="mi">10</span><span class="o">,</span> <span class="n">norm_num</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>While it's trivial to prove all the elements in the enumerated set satisfy the condition for <code>X</code>-membership, as shown for <code>1</code>, how does one put things like these together to obtain the result? Do I need to revert to something simpler, like <code>n ∈ X \iff n = 0 \or n = 1 \or ...</code>?  In that case things can get a little ugly for larger sets.</p>

<a name="190448507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190448507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190448507">Kevin Buzzard (Mar 12 2020 at 21:39)</a>:</h4>
<p>I'm not sure this is true, because I think <code>⊂</code> means <code>⊆</code> but not <code>=</code></p>

<a name="190448855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190448855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190448855">Kevin Buzzard (Mar 12 2020 at 21:43)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">def</span> <span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">n</span> <span class="bp">|</span> <span class="n">n</span><span class="err">^</span><span class="mi">2</span> <span class="bp">&lt;</span> <span class="mi">10</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">Xexplicit</span> <span class="o">:</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="err">⊆</span> <span class="n">X</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">X</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_def</span><span class="o">],</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">cases</span> <span class="n">hx</span><span class="o">}</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">dec_trivial</span>
<span class="kn">end</span>
</pre></div>

<a name="190448857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190448857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190448857">Daniel Keys (Mar 12 2020 at 21:43)</a>:</h4>
<p>Actually I need that to prove equality, so I need inclusion both sides.</p>

<a name="190448888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190448888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190448888">Daniel Keys (Mar 12 2020 at 21:43)</a>:</h4>
<p>I edited to have <code>\subseteq</code>.</p>

<a name="190448972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190448972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190448972">Daniel Keys (Mar 12 2020 at 21:44)</a>:</h4>
<p>Thank you!</p>

<a name="190449011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190449011" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190449011">Kevin Buzzard (Mar 12 2020 at 21:45)</a>:</h4>
<p>Confession: <span class="user-mention" data-user-id="110044">@Chris Hughes</span> suggested the first line, but then wanted to finish with <code>finish</code> and we couldn't get it to work, hence the hack</p>

<a name="190449136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190449136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190449136">Daniel Keys (Mar 12 2020 at 21:46)</a>:</h4>
<p>Anyway much shorter than what I was contemplating.</p>

<a name="190458934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190458934" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190458934">Yury G. Kudryashov (Mar 13 2020 at 00:04)</a>:</h4>
<p>BTW, what do you think about using subsetneq instead of subset?</p>

<a name="190459014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190459014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190459014">Yury G. Kudryashov (Mar 13 2020 at 00:06)</a>:</h4>
<p>This will make statements more readable</p>

<a name="190459331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190459331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190459331">Kevin Buzzard (Mar 13 2020 at 00:12)</a>:</h4>
<p>I never use <code>⊂</code> (<code>\ssub</code>) in my work or my lectures, because it is one of these ambiguous symbols used by some people to mean one thing, and used by others to mean something else. But then again I never use <code>\nat</code> either, for the same reason. The counter-argument is that if mathlib decides to stick to a convention and advertises that in some sort of "notation" page, this would perhaps suffice. I don't think <code>→ₗ</code>, <code>⋙</code> etc are particularly readable either (but this is a little different because perhaps there is no standard notation for them?)</p>

<a name="190465744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190465744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190465744">Mario Carneiro (Mar 13 2020 at 02:34)</a>:</h4>
<p>I think you can do better than that:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">Xexplicit</span> <span class="o">:</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="err">⊆</span> <span class="n">X</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">X</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">insert_subset</span><span class="o">]</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">dec_trivial</span>
</pre></div>

<a name="190465754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190465754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190465754">Mario Carneiro (Mar 13 2020 at 02:35)</a>:</h4>
<p><code>insert_subset</code> should just be a simp lemma, I don't think there are any downsides to triggering it</p>

<a name="190613461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190613461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190613461">Daniel Keys (Mar 14 2020 at 20:41)</a>:</h4>
<p>Trying some basic analysis stuff on my own:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">unbounded_above</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">a</span>
</pre></div>


<p>then I want to prove, among others, <code>unbounded_above ℕ</code>. So I need to coerce the whole of <code>nat</code> as set of <code>real</code>. Can that be done?</p>

<a name="190613510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190613510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190613510">Kevin Buzzard (Mar 14 2020 at 20:42)</a>:</h4>
<p>I guess it would be something like <code>coe '' nat</code> and you'll need <code>import data.set.basic</code></p>

<a name="190613514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190613514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190613514">Kevin Buzzard (Mar 14 2020 at 20:42)</a>:</h4>
<p>wait that's not quite right</p>

<a name="190613522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190613522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190613522">Kevin Buzzard (Mar 14 2020 at 20:43)</a>:</h4>
<p><code>set.range (coe : nat -&gt; real)</code></p>

<a name="190613587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190613587" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190613587">Kevin Buzzard (Mar 14 2020 at 20:44)</a>:</h4>
<p>Why not just <code>∀ x : ℝ,  ∃ a ∈ A, x &lt; a</code>?</p>

<a name="190613912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190613912" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190613912">Daniel Keys (Mar 14 2020 at 20:52)</a>:</h4>
<p>Yeap, this works:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">nats_unbounded_above</span> <span class="o">:</span> <span class="n">unbounded_above</span> <span class="o">(</span> <span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">-&gt;</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>Thank you! Agreed, I could get rid of the <code>x&gt;0</code> here; trying to show equivalence with a version of the Archimedes principle where that will be helpful though (keep 1/x in the nats instead of ints).</p>

<a name="190613929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190613929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190613929">Kevin Buzzard (Mar 14 2020 at 20:53)</a>:</h4>
<p>You could also use <code>{x : ℝ | ∃ n : ℕ, x = n}</code></p>

<a name="190613988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190613988" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190613988">Kevin Buzzard (Mar 14 2020 at 20:54)</a>:</h4>
<p>the equality is between two terms of different types. Lean reads the left hand side first and decides this is an equality between reals, and then coerces the natural automatically</p>

<a name="190613999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190613999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190613999">Daniel Keys (Mar 14 2020 at 20:54)</a>:</h4>
<p>Oh wait! That's exactly the same thing, right?</p>

<a name="190614008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190614008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190614008">Kevin Buzzard (Mar 14 2020 at 20:55)</a>:</h4>
<p><code>{x : ℝ | ∃ n : ℕ, x = ↑n}</code> also works. They're the same sets in the sense that they have the same elements, and they might well be defeq</p>

<a name="190614026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190614026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190614026">Kevin Buzzard (Mar 14 2020 at 20:55)</a>:</h4>
<p>oh apparently they're not :-/</p>

<a name="190614092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190614092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190614092">Kevin Buzzard (Mar 14 2020 at 20:57)</a>:</h4>
<p>the range is defeq to <code>{x : ℝ | ∃ n : ℕ, (n : ℝ) = x}</code></p>

<a name="190623146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190623146" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190623146">Daniel Keys (Mar 15 2020 at 01:10)</a>:</h4>
<p>Can someone help me at this stage? </p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="n">def</span> <span class="n">unboundedAbove</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">a</span>
<span class="n">def</span> <span class="n">archimPrinciple</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span>  <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">x</span>
<span class="kn">lemma</span> <span class="n">nats_unboundedAbove</span> <span class="o">:</span>
    <span class="n">unboundedAbove</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}</span> <span class="bp">↔</span> <span class="n">archimPrinciple</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">unb</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">set</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}</span> <span class="k">with</span> <span class="n">hA</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h1x</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="n">x</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="k">from</span> <span class="n">one_div_pos_of_pos</span> <span class="n">hx</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">unb</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="n">x</span><span class="o">)</span> <span class="n">h1x</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">nx</span> <span class="n">hnx</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hnx</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
    <span class="c1">-- existsi nx,  -- this won&#39;t work because nx is real, although it should be nat as well</span>
    <span class="c1">-- but I don&#39;t know how to get that from h1</span>
<span class="kn">end</span>
</pre></div>

<a name="190624091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190624091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190624091">Chris Hughes (Mar 15 2020 at 01:42)</a>:</h4>
<p>You can use <code>ceil nx</code> to find the next natural number after <code>nx</code></p>

<a name="190624143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190624143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190624143">Mario Carneiro (Mar 15 2020 at 01:45)</a>:</h4>
<p>I think that trivializes the statement though</p>

<a name="190624145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190624145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190624145">Bryan Gin-ge Chen (Mar 15 2020 at 01:45)</a>:</h4>
<p>I think you want something like this?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="n">def</span> <span class="n">unboundedAbove</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">a</span>
<span class="n">def</span> <span class="n">archimPrinciple</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span>  <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">x</span>
<span class="kn">lemma</span> <span class="n">nats_unboundedAbove</span> <span class="o">:</span>
  <span class="n">unboundedAbove</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}</span> <span class="bp">↔</span> <span class="n">archimPrinciple</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">unb</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">set</span> <span class="n">A</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}</span> <span class="k">with</span> <span class="n">hA</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h1x</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="n">x</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="k">from</span> <span class="n">one_div_pos_of_pos</span> <span class="n">hx</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">unb</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="n">x</span><span class="o">)</span> <span class="n">h1x</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">h1</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">nx</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">n</span><span class="o">,</span> <span class="n">hn</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h2</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">n</span><span class="o">,</span>
    <span class="n">sorry</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span><span class="o">,</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>

<a name="190624194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190624194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190624194">Mario Carneiro (Mar 15 2020 at 01:47)</a>:</h4>
<p>you can use <code>rfl</code> instead of <code>hn</code></p>

<a name="190624197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190624197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190624197">Daniel Keys (Mar 15 2020 at 01:47)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>  Right, I didn't know how to work with the set membership relation to get it.</p>

<a name="190624238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190624238" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190624238">Daniel Keys (Mar 15 2020 at 01:48)</a>:</h4>
<p>Thank you!</p>

<a name="190651750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190651750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190651750">Daniel Keys (Mar 15 2020 at 15:22)</a>:</h4>
<p>Another little bump in the other direction apparently. Does anyone see a nice way to go past that <code>existsi</code> line in a nice way that wouldn't need a proof for <code>h2n</code>?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">def</span> <span class="n">unboundedAbove</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">a</span>
<span class="n">def</span> <span class="n">archimPrinciple</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">→</span>  <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="n">n</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">x</span>
<span class="kn">lemma</span> <span class="n">nats_unboundedAbove_eq_arc</span> <span class="o">:</span>
    <span class="n">unboundedAbove</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">n</span><span class="o">}</span> <span class="bp">↔</span> <span class="n">archimPrinciple</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="c1">-- left-right implication</span>
    <span class="o">{</span><span class="n">sorry</span><span class="o">,</span> <span class="c1">-- this works</span>
    <span class="o">},</span>
    <span class="c1">-- right-left implication</span>
    <span class="n">intros</span> <span class="n">arc</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h1x</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="n">x</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="k">from</span> <span class="n">one_div_pos_of_pos</span> <span class="n">hx</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">arc</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="n">x</span><span class="o">)</span> <span class="n">h1x</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">n</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>
    <span class="n">existsi</span> <span class="n">n</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>      <span class="c1">-- any nice solution from here?</span>
    <span class="n">set</span> <span class="n">xn</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="err">↑</span><span class="n">n</span> <span class="k">with</span> <span class="n">hxn</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h2n</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">xn</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span><span class="o">,</span>    <span class="c1">-- without a need for this h2n?</span>
    <span class="n">exact</span> <span class="n">lt_of_one_div_lt_one_div</span> <span class="n">h2n</span> <span class="n">hn</span><span class="o">,</span>    <span class="c1">-- wants h2n with xn, not ↑n --??</span>
    <span class="n">done</span>
<span class="kn">end</span>
</pre></div>

<a name="190653250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190653250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190653250">Kevin Buzzard (Mar 15 2020 at 15:59)</a>:</h4>
<p>I don't think the goal is solvable. n can be zero.</p>

<a name="190653252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190653252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190653252">Kevin Buzzard (Mar 15 2020 at 15:59)</a>:</h4>
<p>1/0=0 in Lean</p>

<a name="190656234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190656234" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190656234">Daniel Keys (Mar 15 2020 at 17:04)</a>:</h4>
<p>You're right. I need to restrict my naturals to <code>&gt;=1</code> only, for this to work.</p>

<a name="190656814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190656814" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190656814">Kevin Buzzard (Mar 15 2020 at 17:17)</a>:</h4>
<p>Aah, the good old British naturals.</p>

<a name="190657660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190657660" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190657660">Daniel Keys (Mar 15 2020 at 17:37)</a>:</h4>
<p>Also the ones I grew up with. Base case for proof by induction was <code>n=1</code> in my young years.</p>

<a name="190688045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190688045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190688045">Viktoriya Malyasova (Mar 16 2020 at 06:52)</a>:</h4>
<p>Hi everyone! I've worked through first 7 chapters of "Theorem proving in lean", but can't understand how pattern matching works, e.g. how to solve the first exercise in chapter 8. How do you pattern-match an expression like ∀ (b : β), ∃ (a : α), f a = b? Can I find some similar examples somewhere? In the chapter there are no examples with a universal quantifier.</p>

<a name="190688155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190688155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190688155">Kenny Lau (Mar 16 2020 at 06:55)</a>:</h4>
<p><code>bnot_bnot</code> is an example with a universal quantifier</p>

<a name="190713594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190713594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190713594">jack (Mar 16 2020 at 12:17)</a>:</h4>
<p>Is anybody familiar with first order login in LEAN?</p>

<a name="190713624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190713624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190713624">Johan Commelin (Mar 16 2020 at 12:17)</a>:</h4>
<p>See Flypitch</p>

<a name="190713636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190713636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190713636">Johan Commelin (Mar 16 2020 at 12:17)</a>:</h4>
<p><a href="https://github.com/flypitch/flypitch" target="_blank" title="https://github.com/flypitch/flypitch">https://github.com/flypitch/flypitch</a></p>

<a name="190713684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190713684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190713684">Johan Commelin (Mar 16 2020 at 12:18)</a>:</h4>
<p>Corollary: <span class="user-mention" data-user-id="111080">@Floris van Doorn</span> and <span class="user-mention" data-user-id="116045">@Jesse Michael Han</span> are familiar with FOL in Lean</p>

<a name="190713705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190713705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190713705">Johan Commelin (Mar 16 2020 at 12:18)</a>:</h4>
<p>(There might be others <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span>)</p>

<a name="190713747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190713747" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190713747">jack (Mar 16 2020 at 12:18)</a>:</h4>
<p>Thanks Johan, but im doing my homework :(</p>

<a name="190713778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190713778" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190713778">Johan Commelin (Mar 16 2020 at 12:19)</a>:</h4>
<p>Aha... so what is your question?</p>

<a name="190713782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190713782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190713782">jack (Mar 16 2020 at 12:19)</a>:</h4>
<p>How to prove ¬ (∀ x, P x) → (∃ y, ¬ P y) :=</p>

<a name="190713835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190713835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190713835">jack (Mar 16 2020 at 12:19)</a>:</h4>
<p>I'm stucking at how to deal with <code>\not \forall</code>.</p>

<a name="190713841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190713841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190713841">Johan Commelin (Mar 16 2020 at 12:19)</a>:</h4>
<p>Do you have mathlib?</p>

<a name="190713892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190713892" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190713892">jack (Mar 16 2020 at 12:20)</a>:</h4>
<p>nope</p>

<a name="190713940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190713940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190713940">Johan Commelin (Mar 16 2020 at 12:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="272189">jack</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/190713835" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/190713835">said</a>:</p>
<blockquote>
<p>I'm stucking at how to deal with <code>\not \forall</code>.</p>
</blockquote>
<p>Aha, there must be a lemma called just like that <code>not_forall</code>.</p>

<a name="190713971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190713971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190713971">Johan Commelin (Mar 16 2020 at 12:20)</a>:</h4>
<p>Does <code>#check classical.not_forall</code> give you output?</p>

<a name="190714139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190714139" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190714139">jack (Mar 16 2020 at 12:22)</a>:</h4>
<div class="codehilite"><pre><span></span>open classical
#check classical.not_forall
</pre></div>


<p>gives me unknown identifier 'classical.not_forall'</p>

<a name="190714167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190714167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190714167">Johan Commelin (Mar 16 2020 at 12:22)</a>:</h4>
<p>Hmmm, that's probably already mathlib</p>

<a name="190714219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190714219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190714219">jack (Mar 16 2020 at 12:23)</a>:</h4>
<p>I'm writing my homework at <code>https://leanprover.github.io/live/latest/</code></p>

<a name="190714285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190714285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190714285">jack (Mar 16 2020 at 12:23)</a>:</h4>
<p>Noob for LEAN.</p>

<a name="190714700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190714700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190714700">Johan Commelin (Mar 16 2020 at 12:27)</a>:</h4>
<p>Have you tried to use <code>classical.by_contradiction</code>?</p>

<a name="190715221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190715221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190715221">jack (Mar 16 2020 at 12:31)</a>:</h4>
<p>I'm supposed to use that, from the description of the question.</p>

<a name="190715303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190715303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190715303">jack (Mar 16 2020 at 12:32)</a>:</h4>
<p>Actually I have no idea how to use it.</p>

<a name="190715383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190715383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190715383">Johan Commelin (Mar 16 2020 at 12:33)</a>:</h4>
<p>Are you allowed to use tactic mode?</p>

<a name="190715403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190715403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190715403">Johan Commelin (Mar 16 2020 at 12:33)</a>:</h4>
<p><code>begin ... end</code> blocks?</p>

<a name="190715452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190715452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190715452">Johan Commelin (Mar 16 2020 at 12:33)</a>:</h4>
<p>Or are you forced to hand in term-mode proofs?</p>

<a name="190715467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190715467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190715467">jack (Mar 16 2020 at 12:33)</a>:</h4>
<p>yes!</p>

<a name="190715560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190715560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190715560">Johan Commelin (Mar 16 2020 at 12:34)</a>:</h4>
<p>Yes to what?</p>

<a name="190715575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190715575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190715575">jack (Mar 16 2020 at 12:34)</a>:</h4>
<p>In the first saw I was thinking that such a LEAN is so stupid, because I have to write the proof by hand.</p>

<a name="190715587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190715587" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190715587">jack (Mar 16 2020 at 12:34)</a>:</h4>
<p>yes with begin..end</p>

<a name="190715650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190715650" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190715650">Johan Commelin (Mar 16 2020 at 12:35)</a>:</h4>
<p>Ok, so</p>
<div class="codehilite"><pre><span></span>  <span class="k">assume</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">classical</span><span class="bp">.</span><span class="n">by_contradiction</span><span class="o">,</span>
</pre></div>

<a name="190715657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190715657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190715657">Johan Commelin (Mar 16 2020 at 12:35)</a>:</h4>
<p>That should get you started.</p>

<a name="190715797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190715797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190715797">Johan Commelin (Mar 16 2020 at 12:37)</a>:</h4>
<p>Just follow your nose. If you get stuck, write</p>
<div class="codehilite"><pre><span></span>  <span class="n">apply</span> <span class="n">classical</span><span class="bp">.</span><span class="n">by_contradiction</span><span class="o">,</span>
</pre></div>

<a name="190715854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190715854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190715854">Johan Commelin (Mar 16 2020 at 12:37)</a>:</h4>
<p>If you have the feeling that you are going in circles, follow your other nose <span aria-label="stuck out tongue wink" class="emoji emoji-1f61c" role="img" title="stuck out tongue wink">:stuck_out_tongue_wink:</span></p>

<a name="190716024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190716024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190716024">jack (Mar 16 2020 at 12:39)</a>:</h4>
<p>But I still have no idea how to use <code>apply ...</code>. I have never seen that before in the class.</p>

<a name="190716061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190716061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190716061">jack (Mar 16 2020 at 12:39)</a>:</h4>
<p>Actually the question is quite stupid..</p>

<a name="190716138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190716138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190716138">Johan Commelin (Mar 16 2020 at 12:40)</a>:</h4>
<p>Aah, so maybe they don't use <code>begin ... end</code> in class?</p>

<a name="190716196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190716196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190716196">Johan Commelin (Mar 16 2020 at 12:40)</a>:</h4>
<p>Because after <code>assume/intro</code> I would think that <code>apply</code> is the next tactic that you learn.</p>

<a name="190716247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190716247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190716247">jack (Mar 16 2020 at 12:41)</a>:</h4>
<p>Just begin a section and then end that.</p>

<a name="190716311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190716311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190716311">Johan Commelin (Mar 16 2020 at 12:42)</a>:</h4>
<p>Ok, so no tactic mode.</p>

<a name="190716312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190716312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190716312">jack (Mar 16 2020 at 12:42)</a>:</h4>
<p>I remember it's <code>section..end</code> not <code>begin..end</code>. Sorry my fault.</p>

<a name="190716326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190716326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190716326">Johan Commelin (Mar 16 2020 at 12:42)</a>:</h4>
<p>In that case, start with</p>
<div class="codehilite"><pre><span></span><span class="k">assume</span> <span class="n">H</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">by_contradiction</span> <span class="err">$</span>
<span class="bp">_</span>
</pre></div>

<a name="190716358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190716358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190716358">Johan Commelin (Mar 16 2020 at 12:43)</a>:</h4>
<p>Put your cursor on the <code>_</code> to see the updated goal state.</p>

<a name="190716645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190716645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190716645">jack (Mar 16 2020 at 12:45)</a>:</h4>
<p>It always complains<br>
 ```<br>
type mismatch, term<br>
  λ (s1 : ¬∀ (x : U), P x) (a : U) (s2 : ¬P a), by_contradiction ?m_2[s1, a, s2]<br>
has type<br>
  Π (s1 : ¬∀ (x : U), P x) (a : U) (s2 : ¬P a), ?m_1[s1, a, s2]<br>
but is expected to have type<br>
  (¬∀ (x : U), P x) → (∃ (y : U), ¬P y)</p>
<div class="codehilite"><pre><span></span>
</pre></div>

<a name="190716782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190716782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190716782">jack (Mar 16 2020 at 12:47)</a>:</h4>
<p>I guess the fist step must be <code>assume h : ¬ ∀ x, P x</code></p>

<a name="190716791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190716791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190716791">Johan Commelin (Mar 16 2020 at 12:47)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">y</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">P</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">by_contradiction</span> <span class="err">$</span>
<span class="bp">_</span>
</pre></div>


<p>Doesn't complain for me.</p>

<a name="190717267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190717267" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190717267">jack (Mar 16 2020 at 12:51)</a>:</h4>
<p>Then I want assume <code>(¬∃ (y : U), ¬P y)</code> <span aria-label="anguished" class="emoji emoji-1f627" role="img" title="anguished">:anguished:</span> just next line ?</p>

<a name="190717296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190717296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190717296">Johan Commelin (Mar 16 2020 at 12:52)</a>:</h4>
<p><code>assume h', _</code></p>

<a name="190717447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190717447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190717447">jack (Mar 16 2020 at 12:53)</a>:</h4>
<p>type mismatch, term<br>
  λ (h : ¬∀ (x : U), P x), by_contradiction<br>
has type<br>
  Π (h : ¬∀ (x : U), P x), (¬?m_1[h] → false) → ?m_1[h]<br>
but is expected to have type<br>
  (¬∀ (x : U), P x) → (∃ (y : U), ¬P y)</p>

<a name="190717506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190717506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190717506">Johan Commelin (Mar 16 2020 at 12:53)</a>:</h4>
<p>Please post your code</p>

<a name="190717563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190717563" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190717563">Johan Commelin (Mar 16 2020 at 12:54)</a>:</h4>
<p>You have a syntax error, but I can't guess it from here</p>

<a name="190717584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190717584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190717584">Reid Barton (Mar 16 2020 at 12:54)</a>:</h4>
<p><code>by_contradiction</code> needs an argument. You can put <code>_</code> for now</p>

<a name="190718029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718029">jack (Mar 16 2020 at 12:58)</a>:</h4>
<p>It gives out</p>

<a name="190718031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718031">jack (Mar 16 2020 at 12:58)</a>:</h4>
<div class="codehilite"><pre><span></span>h : ¬∀ (x : X), P x
⊢ (¬∃ (y : X), ¬P y) → false
</pre></div>


<p>So what's next <span aria-label="cold sweat" class="emoji emoji-1f630" role="img" title="cold sweat">:cold_sweat:</span></p>

<a name="190718099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718099">Johan Commelin (Mar 16 2020 at 12:59)</a>:</h4>
<p>No</p>

<a name="190718109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718109">Johan Commelin (Mar 16 2020 at 12:59)</a>:</h4>
<p>Post all your code</p>

<a name="190718117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718117">Johan Commelin (Mar 16 2020 at 12:59)</a>:</h4>
<p>Not the goal state</p>

<a name="190718125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718125">Johan Commelin (Mar 16 2020 at 12:59)</a>:</h4>
<p>I already told you what is next</p>

<a name="190718136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718136">jack (Mar 16 2020 at 12:59)</a>:</h4>
<div class="codehilite"><pre><span></span>example {X} (P : X → Prop) : ¬ (∀ x, P x) → (∃ y, ¬ P y) :=
assume h, classical.by_contradiction $
_
</pre></div>

<a name="190718173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718173">Johan Commelin (Mar 16 2020 at 12:59)</a>:</h4>
<p>Replace the <code>_</code> with</p>
<div class="codehilite"><pre><span></span><span class="k">assume</span> <span class="n">H</span><span class="o">,</span> <span class="bp">_</span>
</pre></div>

<a name="190718272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718272" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718272">Johan Commelin (Mar 16 2020 at 13:00)</a>:</h4>
<p>After that, put your cursor on the <code>_</code> and see what the goal state is.</p>

<a name="190718295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718295">Johan Commelin (Mar 16 2020 at 13:00)</a>:</h4>
<p>(By the way, which course is this?)</p>

<a name="190718310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718310">jack (Mar 16 2020 at 13:00)</a>:</h4>
<p>OK I got you. One question please, what does <code>$</code> mean?</p>

<a name="190718356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718356">Johan Commelin (Mar 16 2020 at 13:01)</a>:</h4>
<p><code>foo $ bar x y z</code> is the same as <code>foo (bar x y z)</code></p>

<a name="190718362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718362">Johan Commelin (Mar 16 2020 at 13:01)</a>:</h4>
<p>It saves you some parentheses</p>

<a name="190718367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718367">jack (Mar 16 2020 at 13:01)</a>:</h4>
<p>Logic and Computation</p>

<a name="190718383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718383">Johan Commelin (Mar 16 2020 at 13:01)</a>:</h4>
<p>Uni?</p>

<a name="190718393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718393">jack (Mar 16 2020 at 13:01)</a>:</h4>
<p>Birmingham</p>

<a name="190718401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718401">Johan Commelin (Mar 16 2020 at 13:01)</a>:</h4>
<p><del>Which?</del></p>

<a name="190718539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718539">jack (Mar 16 2020 at 13:03)</a>:</h4>
<p>So difficult to me :(, especially the LEAN part.</p>

<a name="190718591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718591">Johan Commelin (Mar 16 2020 at 13:03)</a>:</h4>
<p>So, what does the next goal state say?</p>

<a name="190718657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718657">jack (Mar 16 2020 at 13:04)</a>:</h4>
<div class="codehilite"><pre><span></span>h1 : ¬∀ (x : X), P x,
h2 : ¬∃ (y : X), ¬P y
⊢ false
</pre></div>

<a name="190718676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718676">Johan Commelin (Mar 16 2020 at 13:04)</a>:</h4>
<p>Great, so what do you do?</p>

<a name="190718714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718714">jack (Mar 16 2020 at 13:04)</a>:</h4>
<p>assume t : X and specify h2?</p>

<a name="190718758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718758">Johan Commelin (Mar 16 2020 at 13:05)</a>:</h4>
<p>Nope, you can't assume at this point</p>

<a name="190718802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718802" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718802">Johan Commelin (Mar 16 2020 at 13:05)</a>:</h4>
<p>You've got the <code>h2</code> by contradiction, so using that right now would undo all the hard work</p>

<a name="190718813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718813">jack (Mar 16 2020 at 13:05)</a>:</h4>
<p>~Why not?~</p>

<a name="190718922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718922">Johan Commelin (Mar 16 2020 at 13:06)</a>:</h4>
<p>Because <code>assume</code> only works if your goal is of the form <code>X -&gt; Y</code></p>

<a name="190718943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190718943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190718943">Johan Commelin (Mar 16 2020 at 13:06)</a>:</h4>
<p>But <code>false</code> isn't like that.</p>

<a name="190719022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719022">jack (Mar 16 2020 at 13:07)</a>:</h4>
<p>Then what about <code>exists.intro</code>?</p>

<a name="190719074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719074" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719074">Johan Commelin (Mar 16 2020 at 13:07)</a>:</h4>
<p>No, that only works if your goal is of the form <code>\exists x, ...</code></p>

<a name="190719093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719093">Johan Commelin (Mar 16 2020 at 13:07)</a>:</h4>
<p>You need to build a term of type <code>false</code>.</p>

<a name="190719162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719162">Johan Commelin (Mar 16 2020 at 13:08)</a>:</h4>
<p>So if you have a function of the form <code>h1 : foobar -&gt; false</code>, then you could use that.</p>

<a name="190719202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719202" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719202">Johan Commelin (Mar 16 2020 at 13:08)</a>:</h4>
<p>You happen to have exactly such an <code>h1</code> in you list of assumptions, only the <code>-&gt; false</code> is hidden by notation.</p>

<a name="190719248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719248">jack (Mar 16 2020 at 13:09)</a>:</h4>
<p>Teacher says <code>¬ A is A → false</code></p>

<a name="190719264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719264">Johan Commelin (Mar 16 2020 at 13:09)</a>:</h4>
<p>So I suggest that you write <code>h1 $ _</code> in place of the final underscore.</p>

<a name="190719274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719274">Johan Commelin (Mar 16 2020 at 13:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="272189">jack</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/190719248" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/190719248">said</a>:</p>
<blockquote>
<p>Teacher says <code>¬ A is A → false</code></p>
</blockquote>
<p>Exactly!</p>

<a name="190719426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719426">jack (Mar 16 2020 at 13:10)</a>:</h4>
<p>The goal moves to <code>∀ (x : X), P x</code>. Does that mean I can assume <code>t : X</code> now?</p>

<a name="190719507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719507">Johan Commelin (Mar 16 2020 at 13:11)</a>:</h4>
<p>Yep, now you are in good shape!</p>

<a name="190719545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719545">Johan Commelin (Mar 16 2020 at 13:11)</a>:</h4>
<p>Replace the final underscore by <code>assume x, _</code></p>

<a name="190719605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719605">Johan Commelin (Mar 16 2020 at 13:12)</a>:</h4>
<p>After that, you'll need to build a term of type <code>P x</code>.</p>

<a name="190719618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719618">Johan Commelin (Mar 16 2020 at 13:12)</a>:</h4>
<p>Or <code>P t</code>, if you wrote <code>assume t</code></p>

<a name="190719651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719651" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719651">jack (Mar 16 2020 at 13:12)</a>:</h4>
<p>Now I should elim exists..</p>

<a name="190719679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719679" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719679">Johan Commelin (Mar 16 2020 at 13:12)</a>:</h4>
<p>How?</p>

<a name="190719691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719691" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719691">jack (Mar 16 2020 at 13:13)</a>:</h4>
<p><a href="/user_uploads/3121/NZS5MgdPpc_qVDxj4xgKbauT/image.png" target="_blank" title="image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/NZS5MgdPpc_qVDxj4xgKbauT/image.png" target="_blank" title="image.png"><img src="/user_uploads/3121/NZS5MgdPpc_qVDxj4xgKbauT/image.png"></a></div>

<a name="190719737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719737">Johan Commelin (Mar 16 2020 at 13:13)</a>:</h4>
<p>That only works if you have <code>h2' : \exists y, ...</code> as an assumption. But you don't.</p>

<a name="190719785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719785">Johan Commelin (Mar 16 2020 at 13:13)</a>:</h4>
<p>Your <code>h2</code> has a <code>\not</code> in front of the exists.</p>

<a name="190719796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719796">jack (Mar 16 2020 at 13:14)</a>:</h4>
<p>I have <code>\not \exists ...</code>, just like <code>h1</code> in the example.</p>

<a name="190719875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719875">Johan Commelin (Mar 16 2020 at 13:14)</a>:</h4>
<p>Sure, but the example doesn't use <code>exists.elim</code> either.</p>

<a name="190719923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190719923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190719923">jack (Mar 16 2020 at 13:15)</a>:</h4>
<p>Then it must be <code>exists.intro</code> <span aria-label="yum" class="emoji emoji-1f60b" role="img" title="yum">:yum:</span></p>

<a name="190720020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720020">Johan Commelin (Mar 16 2020 at 13:15)</a>:</h4>
<p>Well.... that works if the <em>goal</em> is of the form <code>\exists y, ...</code>. Which it isn't.</p>

<a name="190720088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720088">Johan Commelin (Mar 16 2020 at 13:16)</a>:</h4>
<p>To summarise... you're about as stuck as you were at the beginning of your proof.</p>

<a name="190720100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720100">Johan Commelin (Mar 16 2020 at 13:16)</a>:</h4>
<p>What did you do to get unstuck?</p>

<a name="190720141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720141" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720141">jack (Mar 16 2020 at 13:16)</a>:</h4>
<p>by_contradiction!</p>

<a name="190720418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720418">jack (Mar 16 2020 at 13:19)</a>:</h4>
<p>Then type error again...</p>

<a name="190720426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720426">jack (Mar 16 2020 at 13:19)</a>:</h4>
<div class="codehilite"><pre><span></span>example {X} (P : X → Prop) : ¬ (∀ x, P x) → (∃ y, ¬ P y) :=
assume h1, classical.by_contradiction $
assume h2,
h1
(
assume x,
assume h3, classical.by_contradiction $
_
)
</pre></div>

<a name="190720537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720537">Johan Commelin (Mar 16 2020 at 13:20)</a>:</h4>
<p>Sure, <code>assume h3</code> gives the error</p>

<a name="190720586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720586" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720586">Johan Commelin (Mar 16 2020 at 13:20)</a>:</h4>
<p>In the beginning of your proof you didn't get stuck at the 1st step. Only at the 2nd...</p>

<a name="190720624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720624">Johan Commelin (Mar 16 2020 at 13:21)</a>:</h4>
<p>So you shouldn't copy the <code>assume ..</code> from the beginning of the proof. Only the <code>by_contra</code></p>

<a name="190720647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720647">jack (Mar 16 2020 at 13:21)</a>:</h4>
<p>If i remove the assume, it comes to <code>¬P x → false</code></p>

<a name="190720686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720686">Johan Commelin (Mar 16 2020 at 13:21)</a>:</h4>
<p>Progress!</p>

<a name="190720706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720706">jack (Mar 16 2020 at 13:22)</a>:</h4>
<p>Then write a h2 to make the form -&gt; false</p>

<a name="190720756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720756">Johan Commelin (Mar 16 2020 at 13:22)</a>:</h4>
<p>Not so fast</p>

<a name="190720776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720776">Johan Commelin (Mar 16 2020 at 13:22)</a>:</h4>
<p><code>h2</code> only works if your goal is <code>false</code></p>

<a name="190720795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720795">Johan Commelin (Mar 16 2020 at 13:22)</a>:</h4>
<p>But your goal is of the form <code>X -&gt; Y</code></p>

<a name="190720811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720811">jack (Mar 16 2020 at 13:23)</a>:</h4>
<p>Ok now we assume.</p>

<a name="190720836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720836">Johan Commelin (Mar 16 2020 at 13:23)</a>:</h4>
<p><code>assume hPx</code></p>

<a name="190720987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190720987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190720987">jack (Mar 16 2020 at 13:24)</a>:</h4>
<p>.. and write a h2</p>

<a name="190721239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190721239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190721239">jack (Mar 16 2020 at 13:26)</a>:</h4>
<p>..and then <code>exists.intro</code>Oh my god !</p>

<a name="190721294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190721294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190721294">jack (Mar 16 2020 at 13:27)</a>:</h4>
<p>Thank you very much !  Appreciate your help!</p>

<a name="190721366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190721366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190721366">jack (Mar 16 2020 at 13:27)</a>:</h4>
<p>Very kind of you!</p>

<a name="190721452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190721452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190721452">jack (Mar 16 2020 at 13:28)</a>:</h4>
<p>Are you the developer of LEAN?</p>

<a name="190721482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190721482" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190721482">Johan Commelin (Mar 16 2020 at 13:28)</a>:</h4>
<p>Nope, lol</p>

<a name="190721495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190721495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190721495">Johan Commelin (Mar 16 2020 at 13:28)</a>:</h4>
<p>Just a random user</p>

<a name="190721755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190721755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190721755">jack (Mar 16 2020 at 13:30)</a>:</h4>
<p>I've no idea whether I can get the credit using such advanced grammar.</p>

<a name="190721774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190721774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190721774">Johan Commelin (Mar 16 2020 at 13:30)</a>:</h4>
<p>But you didn't right?</p>

<a name="190721806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190721806" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190721806">Johan Commelin (Mar 16 2020 at 13:31)</a>:</h4>
<p>Without <code>by_contra</code> you can't do this</p>

<a name="190721945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190721945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190721945">jack (Mar 16 2020 at 13:32)</a>:</h4>
<p>Yes, thats why exactly it does not mention <code>intuitionistic logic</code> in this question.</p>

<a name="190722082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190722082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190722082">jack (Mar 16 2020 at 13:33)</a>:</h4>
<p>I'm sure there must be sth. wrong with my hand-made provement.</p>

<a name="190722229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190722229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190722229">jack (Mar 16 2020 at 13:34)</a>:</h4>
<p>One more question, is classical.by_contradiction equivalent to <code>A &lt;-&gt; ~~A</code>?</p>

<a name="190722396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190722396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190722396">Johan Commelin (Mar 16 2020 at 13:36)</a>:</h4>
<p>Yup</p>

<a name="190722435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190722435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190722435">Johan Commelin (Mar 16 2020 at 13:36)</a>:</h4>
<p>Which results from <code>classical.*</code> were you allowed to use?</p>

<a name="190722525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190722525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190722525">jack (Mar 16 2020 at 13:37)</a>:</h4>
<p>I have very very few examples in the class.</p>

<a name="190722571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190722571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190722571">jack (Mar 16 2020 at 13:37)</a>:</h4>
<p><a href="https://gist.github.com/benediktahrens/a52dc0137db2e845bb96b5f67645bad7" target="_blank" title="https://gist.github.com/benediktahrens/a52dc0137db2e845bb96b5f67645bad7">https://gist.github.com/benediktahrens/a52dc0137db2e845bb96b5f67645bad7</a></p>

<a name="190722718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190722718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190722718">Johan Commelin (Mar 16 2020 at 13:38)</a>:</h4>
<p><a href="https://gist.github.com/benediktahrens/a52dc0137db2e845bb96b5f67645bad7#file-lec9-lean-L250" target="_blank" title="https://gist.github.com/benediktahrens/a52dc0137db2e845bb96b5f67645bad7#file-lec9-lean-L250">https://gist.github.com/benediktahrens/a52dc0137db2e845bb96b5f67645bad7#file-lec9-lean-L250</a></p>

<a name="190722723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190722723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190722723">jack (Mar 16 2020 at 13:38)</a>:</h4>
<p>So i have no idea how to deal with \not at all.</p>

<a name="190722731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190722731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190722731">Johan Commelin (Mar 16 2020 at 13:38)</a>:</h4>
<p>uses <code>by_contradiction</code></p>

<a name="190722843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190722843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190722843">jack (Mar 16 2020 at 13:39)</a>:</h4>
<p>Yeah. But I still don't know how to use is ... until NOW.</p>

<a name="190722925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190722925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190722925">Johan Commelin (Mar 16 2020 at 13:40)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="n">classical</span><span class="bp">.</span><span class="n">by_contradiction</span>
<span class="c1">-- classical.by_contradiction : (¬?M_1 → false) → ?M_1</span>
</pre></div>

<a name="190722943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190722943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190722943">Johan Commelin (Mar 16 2020 at 13:40)</a>:</h4>
<p>Does that help?</p>

<a name="190722950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190722950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190722950">jack (Mar 16 2020 at 13:40)</a>:</h4>
<p>Thanks again for your kindly help.</p>

<a name="190723041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190723041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190723041">Johan Commelin (Mar 16 2020 at 13:41)</a>:</h4>
<p>So it is exactly: "prove <code>A</code> by proving <code>\not \not A</code>"</p>

<a name="190723069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190723069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190723069">jack (Mar 16 2020 at 13:41)</a>:</h4>
<p>Actually I ve no idea about the type signature, i.e. ?M_</p>

<a name="190723210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190723210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190723210">jack (Mar 16 2020 at 13:42)</a>:</h4>
<p>I thought it is just lambda calculus, that's all. The goal is really really helpful.</p>

<a name="190723242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190723242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190723242">jack (Mar 16 2020 at 13:42)</a>:</h4>
<p>But still, the error message is quite confusing, especially for beginners.</p>

<a name="190723254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190723254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190723254">Johan Commelin (Mar 16 2020 at 13:42)</a>:</h4>
<p><code>?M_1</code> is just a weird way of writing <code>A</code> or <code>P</code></p>

<a name="190723272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190723272" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190723272">Johan Commelin (Mar 16 2020 at 13:43)</a>:</h4>
<p>It's a "metavariable"</p>

<a name="190723548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190723548" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190723548">jack (Mar 16 2020 at 13:45)</a>:</h4>
<p>Are u a     mathematician <span class="user-mention" data-user-id="112680">@Johan Commelin</span> ?</p>

<a name="190723605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190723605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190723605">Bryan Gin-ge Chen (Mar 16 2020 at 13:45)</a>:</h4>
<p>It looks nicer if you write <code>#check @classical.by_contradiction</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">classical</span><span class="bp">.</span><span class="n">by_contradiction</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="o">(</span><span class="bp">¬</span><span class="n">p</span> <span class="bp">→</span> <span class="n">false</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p</span>
</pre></div>


<p>The <code>@</code> tells Lean to make all arguments explicit. Along the way the metavariables get nicer names.</p>

<a name="190723723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190723723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190723723">jack (Mar 16 2020 at 13:46)</a>:</h4>
<p>Thank u guys!</p>

<a name="190725576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190725576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190725576">Donald Sebastian Leung (Mar 16 2020 at 14:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="272189">jack</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/190723548" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/190723548">said</a>:</p>
<blockquote>
<p>Are u a     mathematician <span class="user-mention silent" data-user-id="112680">Johan Commelin</span> ?</p>
</blockquote>
<p>Yes - in fact, he is one of the three mathematicians (the other two being Kevin Buzzard and Patrick Massot) who formalized perfectoid spaces in Lean</p>
<p>(Correct me if I am wrong)</p>

<a name="190726623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190726623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190726623">jack (Mar 16 2020 at 14:10)</a>:</h4>
<p>WOW My pleasure!</p>

<a name="190728883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190728883" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190728883">Viktoriya Malyasova (Mar 16 2020 at 14:28)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/190688155" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/190688155">said</a>:</p>
<blockquote>
<p><code>bnot_bnot</code> is an example with a universal quantifier</p>
</blockquote>
<p>Okay, okay, I'm wrong, still, can I see any other examples somewhere? I don't want to do case analysis on b like in the example, I want to do the analogue of intros b.</p>

<a name="190730465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190730465" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190730465">Viktoriya Malyasova (Mar 16 2020 at 14:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="272035">Виктория Малясова</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/190728883" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/190728883">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/190688155" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/190688155">said</a>:</p>
<blockquote>
<p><code>bnot_bnot</code> is an example with a universal quantifier</p>
</blockquote>
<p>Okay, okay, I'm wrong, still, can I see any other examples somewhere? I don't want to do case analysis on b like in the example, I want to do the analogue of intros b.</p>
</blockquote>
<p>Never mind, figured it out.</p>

<a name="190769612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190769612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190769612">Yury G. Kudryashov (Mar 16 2020 at 19:36)</a>:</h4>
<p><span class="user-mention" data-user-id="272035">@Виктория Малясова</span> What exactly do you want to do: do you want to apply a hypothesis with a universal qualifier, or to prove a goal? BTW, if you'll transliterate your nickname, more people will be able to read it, and it'll be easier to tag you in a reply.</p>

<a name="190769635"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190769635" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190769635">Yury G. Kudryashov (Mar 16 2020 at 19:36)</a>:</h4>
<p>BTW, welcome to the club.</p>

<a name="190769818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190769818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190769818">Yury G. Kudryashov (Mar 16 2020 at 19:38)</a>:</h4>
<p>If you want to use <code>h : ∀ b, ∃ x, ...</code>, then you can use something like <code>let ⟨x, hx⟩ := h b in ...</code>.</p>

<a name="190769874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190769874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190769874">Yury G. Kudryashov (Mar 16 2020 at 19:38)</a>:</h4>
<p>If you want to prove <code>∀ b, ∃ x, P x</code>, then you can use something like <code>assume b, ⟨x, hx⟩</code></p>

<a name="190769900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190769900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190769900">Yury G. Kudryashov (Mar 16 2020 at 19:39)</a>:</h4>
<p>(or <code>λ b</code> instead of <code>assume b</code>)</p>

<a name="190787548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190787548" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190787548">Daniel Keys (Mar 16 2020 at 22:23)</a>:</h4>
<p>Can anyone please point me to where the (proof of the) division algorithm <code>a = b  * q + r </code> is hiding?</p>

<a name="190787682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190787682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190787682">Mario Carneiro (Mar 16 2020 at 22:25)</a>:</h4>
<p>I guess that would be a combination of the definition of <code>nat.div</code> and <code>nat.mod</code>, and <code>nat.mod_add_div</code></p>

<a name="190787814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190787814" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190787814">Daniel Keys (Mar 16 2020 at 22:26)</a>:</h4>
<p>Thanks! OK, so we don't have a stand-alone proof of it? That explains why I was searching in vain.</p>

<a name="190788526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190788526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190788526">Daniel Keys (Mar 16 2020 at 22:34)</a>:</h4>
<p>Although <code>nat</code> is strange, since I expected it to be an <code>int</code> thing.</p>

<a name="190788672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190788672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190788672">Mario Carneiro (Mar 16 2020 at 22:36)</a>:</h4>
<p>there is an int version too, but most int theorems reduce to nat counterparts</p>

<a name="190788722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190788722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190788722">Mario Carneiro (Mar 16 2020 at 22:37)</a>:</h4>
<p>the int version is more complicated because the modulus can be negative and conventions differ on what to do about that</p>

<a name="190846317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190846317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190846317">Shing Tak Lam (Mar 17 2020 at 13:25)</a>:</h4>
<p>Hello, I'm struggling with getting rewrite to do what I want it to do, I have (extra goals removed)</p>
<div class="codehilite"><pre><span></span><span class="n">hn2</span> <span class="o">:</span> <span class="n">n</span> <span class="err">%</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span>
<span class="err">⊢</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span>
</pre></div>


<p>and I want to rewrite it to</p>
<div class="codehilite"><pre><span></span><span class="err">⊢</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="err">%</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span>
</pre></div>


<p>But if I use <code>rw &lt;-hn2</code> it gives me</p>
<div class="codehilite"><pre><span></span><span class="err">⊢</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="err">%</span> <span class="mi">2</span> <span class="bp">+</span> <span class="n">bit0</span> <span class="o">(</span><span class="n">n</span> <span class="err">%</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">/</span> <span class="n">bit0</span> <span class="o">(</span><span class="n">n</span> <span class="err">%</span> <span class="mi">2</span><span class="o">))</span>
</pre></div>


<p>as it replaces <code>2</code> with <code>bit0 (n % 2)</code></p>
<p>Thank you!</p>

<a name="190846834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190846834" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190846834">Kevin Buzzard (Mar 17 2020 at 13:29)</a>:</h4>
<p>ha ha! This is happening because of the way numerals are internally stored (2 = bit0 1). There are ways around this.</p>

<a name="190847094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190847094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190847094">Kevin Buzzard (Mar 17 2020 at 13:31)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hn2</span> <span class="o">:</span> <span class="n">n</span> <span class="err">%</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">conv</span> <span class="k">begin</span>
    <span class="c1">-- entering &quot;conv mode&quot; where we can pull terms off the goal</span>
    <span class="n">to_rhs</span><span class="o">,</span>
    <span class="n">congr</span><span class="o">,</span>
    <span class="c1">-- now we have the 1</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">hn2</span><span class="o">,</span> <span class="c1">-- rewrite succeeds</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="c1">-- done</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="190847241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190847241" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190847241">Kevin Buzzard (Mar 17 2020 at 13:32)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md">here</a> is more information about <code>conv</code>.</p>

<a name="190847500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190847500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190847500">Kevin Buzzard (Mar 17 2020 at 13:34)</a>:</h4>
<p>Here is a more direct approach:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hn2</span> <span class="o">:</span> <span class="n">n</span> <span class="err">%</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">conv</span> <span class="k">in</span> <span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="k">begin</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">hn2</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="190847536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190847536" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190847536">Shing Tak Lam (Mar 17 2020 at 13:34)</a>:</h4>
<p>Yeah I see. So numerals are stored in binary in reverse order? That seems fascinating and I remember playing around with that in Haskell. Makes sense that Lean would use that. </p>
<p>Anyways, this seemed to work</p>
<div class="codehilite"><pre><span></span><span class="k">have</span> <span class="n">hnm&#39;</span><span class="o">:</span> <span class="mi">1</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="n">n</span> <span class="err">%</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">hn2</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">hnm&#39;</span><span class="o">,</span>
</pre></div>


<p>Thanks a lot!</p>

<a name="190847759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190847759" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190847759">Kevin Buzzard (Mar 17 2020 at 13:36)</a>:</h4>
<p>Yes, your approach should also work. Nice!</p>
<p>Yes, Lean internally stores numerals as <code>bit0 (bit1 (bit1 (...)))</code>. You can see what's going on internally with the option <code>set_option pp.numerals false</code>.</p>

<a name="190871484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190871484" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190871484">Shing Tak Lam (Mar 17 2020 at 16:10)</a>:</h4>
<p>Alright, thanks a lot.</p>
<p>Another question, is there a way to paste the highlighted value from <code>Ctrl-P #</code> to the location of the cursor? For example with a lemma that has a long name (such as <code>div_le_div_of_le_of_pos</code>), after finding it I press enter to go to the file and I copy the name from there. Is there a quicker way?</p>
<p>Thanks!</p>

<a name="190872744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190872744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190872744">Bryan Gin-ge Chen (Mar 17 2020 at 16:18)</a>:</h4>
<p>Not at the moment, but that's an interesting feature request. Please open an issue <a href="https://github.com/leanprover/vscode-lean/issues" target="_blank" title="https://github.com/leanprover/vscode-lean/issues">here</a>.</p>

<a name="190872803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190872803" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190872803">Shing Tak Lam (Mar 17 2020 at 16:19)</a>:</h4>
<p>Alright thanks. Will do.</p>

<a name="190874844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190874844" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190874844">Kevin Buzzard (Mar 17 2020 at 16:32)</a>:</h4>
<p>If you find the lemma by typing <code>div_le_div</code> and then pressing ctrl-space and scrolling down the options with the arrow keys then you can complete with tab and there it is</p>

<a name="190874936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190874936" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190874936">Kevin Buzzard (Mar 17 2020 at 16:32)</a>:</h4>
<p>Press ctrl-space a second time to see the full types</p>

<a name="190941065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190941065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190941065">Shing Tak Lam (Mar 18 2020 at 05:48)</a>:</h4>
<p>Alright thanks. That doesn't work all the time for me though, but I think it's an issue with my VSCode installation rather than with the Lean extension.</p>

<a name="190941216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190941216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190941216">Shing Tak Lam (Mar 18 2020 at 05:52)</a>:</h4>
<p>Another question, how do I prove this?</p>
<p>(<code>r</code> is a <code>nat</code>)</p>
<div class="codehilite"><pre><span></span><span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">r</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="err">%</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span>
</pre></div>


<p>I've found a few things that are interesting in <code>int.</code>, but nothing came up when looking in <code>nat</code>, and searching for combinations of <code>add</code>, <code>mul</code> and <code>mod</code> didn't give anything. I guess what I'm looking for is </p>
<div class="codehilite"><pre><span></span><span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span> <span class="err">%</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span>
</pre></div>

<a name="190941217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190941217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190941217">Bryan Gin-ge Chen (Mar 18 2020 at 05:52)</a>:</h4>
<p>The VS Code extension queries Lean for autocomplete information and sadly Lean doesn't always provide anything useful at a given position in a file. If you have some specific examples we can take a look.</p>

<a name="190941636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190941636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190941636">Bryan Gin-ge Chen (Mar 18 2020 at 06:04)</a>:</h4>
<p>This is what I get after trying <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md#suggest" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md#suggest">suggest</a>:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
<span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">-&gt;</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span> <span class="err">%</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="n">refine</span> <span class="n">norm_num</span><span class="bp">.</span><span class="n">nat_mod_helper</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="n">n</span> <span class="n">a</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">ring</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>Surely there's a way to do this without pulling in something written for <code>norm_num</code> though.</p>

<a name="190943400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190943400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190943400">Mario Carneiro (Mar 18 2020 at 06:48)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span> <span class="err">%</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_comm</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_mul_mod_self_left</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">mod_eq_of_lt</span> <span class="n">h</span><span class="o">]</span>
</pre></div>

<a name="190943475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190943475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190943475">Kenny Lau (Mar 18 2020 at 06:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">norm_num</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">r</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="err">%</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add_comm</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_mul_mod_self_left</span><span class="o">]</span><span class="bp">;</span> <span class="n">norm_num</span>
</pre></div>

<a name="190943477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190943477" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190943477">Kenny Lau (Mar 18 2020 at 06:50)</a>:</h4>
<p>lol you're faster</p>

<a name="190943749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/190943749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#190943749">Shing Tak Lam (Mar 18 2020 at 06:57)</a>:</h4>
<p>Thank you all!</p>

<a name="191290025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191290025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191290025">Daniel Keys (Mar 20 2020 at 19:18)</a>:</h4>
<p>Could someone please help with the last <code>sorry</code> in this proof? I expect I need <code>revert</code> or maybe <code>generalize</code>. I don't know how to move along with either, though!</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">def</span> <span class="n">sum_of_sets</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">proposition_2_6</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1A</span> <span class="o">:</span> <span class="n">A</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">h1B</span> <span class="o">:</span> <span class="n">B</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h2A</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2B</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">is_lub</span> <span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">is_lub</span> <span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">sum_of_sets</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">hA</span> <span class="n">hB</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">sorry</span><span class="o">,</span>  <span class="c1">-- this side works</span>
  <span class="o">},</span>
  <span class="c1">-- now prove that (a+b) is the least upper bound</span>
  <span class="n">intros</span> <span class="n">S</span> <span class="n">hS</span><span class="o">,</span>
  <span class="n">change</span> <span class="bp">∀</span> <span class="n">xab</span> <span class="err">∈</span> <span class="o">(</span><span class="n">sum_of_sets</span> <span class="n">A</span> <span class="n">B</span><span class="o">),</span> <span class="n">xab</span> <span class="bp">≤</span> <span class="n">S</span> <span class="n">at</span> <span class="n">hS</span><span class="o">,</span>
  <span class="c1">--cases h1A with ya hya,</span>
  <span class="n">cases</span> <span class="n">h1B</span> <span class="k">with</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">sum_of_sets</span> <span class="n">A</span> <span class="n">B</span><span class="o">),</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">sum_of_sets</span><span class="o">,</span>
    <span class="n">existsi</span> <span class="n">y</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">hy</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">z</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">hz</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">S</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hS</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H1</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">S</span> <span class="bp">-</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H3a</span> <span class="o">:=</span> <span class="n">H2</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">linarith</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H4</span> <span class="o">:</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-</span> <span class="n">z</span><span class="o">)</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">A</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H3</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H5</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-</span> <span class="n">z</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">H13A</span> <span class="o">:=</span> <span class="n">hA</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h13</span> <span class="o">:=</span> <span class="n">H13A</span> <span class="n">H4</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h13</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H6</span> <span class="o">:</span> <span class="n">z</span> <span class="bp">≤</span> <span class="n">S</span> <span class="bp">-</span> <span class="n">a</span><span class="o">,</span> <span class="n">linarith</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H7</span> <span class="o">:</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">B</span><span class="o">,</span>  <span class="c1">-- got stuck here</span>
    <span class="c1">--revert z,</span>
    <span class="c1">--does generalize work? How?</span>
   <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="191291077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191291077" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191291077">Kevin Buzzard (Mar 20 2020 at 19:27)</a>:</h4>
<p>z is now a fixed real number in B. In particular you only know that t &lt;= S - a for one particular t in B, namely t = z. You can make progress in the proof with <code>intros t ht</code>, but that is basically your only next move. You can't use z to prove the goal.</p>

<a name="191292007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191292007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191292007">Daniel Keys (Mar 20 2020 at 19:35)</a>:</h4>
<p>I thought I could move on by reverting z. So I'm wrong there?</p>

<a name="191292506"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191292506" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191292506">Daniel Keys (Mar 20 2020 at 19:40)</a>:</h4>
<p>I should be able to use the fact that the initial <code>z</code> was chosen arbitrarily. I also thought about starting with <code>forall z</code> at the very top, but am just trying to follow one of the standard proofs - and learn some more Lean in the process!</p>

<a name="191293074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191293074" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191293074">Kevin Buzzard (Mar 20 2020 at 19:45)</a>:</h4>
<p>But z is not arbitrary, z is one specific element of B which is the witness to the non-emptiness of B.</p>

<a name="191293294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191293294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191293294">Kevin Buzzard (Mar 20 2020 at 19:46)</a>:</h4>
<p><code>h1B</code> is like saying "this specific constant real number z is an element of B". It's no different to saying "assume <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\pi\in B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>". You can prove whatever you like about <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span> now, but you won't be able to deduce anything about an arbitrary element of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>.</p>

<a name="191293380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191293380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191293380">Daniel Keys (Mar 20 2020 at 19:47)</a>:</h4>
<p>OK. So I'm not supposed to be thinking about it as arbitrary? Then I need to rewrite from the start I guess.</p>

<a name="191293406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191293406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191293406">Kevin Buzzard (Mar 20 2020 at 19:47)</a>:</h4>
<p>Yes it's definitely not arbitrary, it's some fixed constant.</p>

<a name="191293776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191293776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191293776">Kevin Buzzard (Mar 20 2020 at 19:50)</a>:</h4>
<p><code>hB</code> has, buried within it, a statement about an arbitrary element of B.</p>

<a name="191294275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191294275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191294275">Kevin Buzzard (Mar 20 2020 at 19:54)</a>:</h4>
<p>I set this question in an undergraduate exam in 2018 and <span class="user-mention" data-user-id="130500">@Abhimanyu Pallavi Sudhir</span> <a href="https://github.com/ImperialCollegeLondon/M1F-exam-may-2018" target="_blank" title="https://github.com/ImperialCollegeLondon/M1F-exam-may-2018">formalised the solutions</a>. <span class="user-mention" data-user-id="110064">@Kenny Lau</span> sat the exam and his written solution was constructive and could be basically cut and pasted into Lean. It was funny reading it. He kept writing <code>assume</code> :-)</p>

<a name="191294523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191294523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191294523">Kevin Buzzard (Mar 20 2020 at 19:56)</a>:</h4>
<p>You need to be proving things like this:</p>
<div class="codehilite"><pre><span></span>  <span class="k">have</span> <span class="n">H2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">S</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hS</span><span class="o">,</span> <span class="n">use</span> <span class="n">y</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span> <span class="n">use</span> <span class="n">hy</span><span class="o">,</span> <span class="n">use</span> <span class="n">z</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span> <span class="n">use</span> <span class="n">hz</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
</pre></div>

<a name="191294539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191294539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191294539">Kevin Buzzard (Mar 20 2020 at 19:56)</a>:</h4>
<p>sorry for ugly proof, just got to run</p>

<a name="191295511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191295511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191295511">Daniel Keys (Mar 20 2020 at 20:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191294523" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191294523">said</a>:</p>
<blockquote>
<p>You need to be proving things like this:</p>
<div class="codehilite"><pre><span></span>  <span class="k">have</span> <span class="n">H2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">S</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hS</span><span class="o">,</span> <span class="n">use</span> <span class="n">y</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span> <span class="n">use</span> <span class="n">hy</span><span class="o">,</span> <span class="n">use</span> <span class="n">z</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span> <span class="n">use</span> <span class="n">hz</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
</pre></div>


</blockquote>
<p>Right. This is what I meant by starting over. Thanks again for the help! Hopefully I get there in another day or so -:)</p>

<a name="191299357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191299357" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191299357">Kevin Buzzard (Mar 20 2020 at 20:39)</a>:</h4>
<p><code>  have H2 : ∀ y ∈ A, ∀ z ∈ B, (y + z) ≤ S := λ y hy z hz, hS _ ⟨y, hy, z, hz, rfl⟩,</code></p>

<a name="191300274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191300274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191300274">Daniel Keys (Mar 20 2020 at 20:47)</a>:</h4>
<p>Yes, I have changed all that and now I get stuck here:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- now prove that (a+b) is the least upper bound</span>
  <span class="n">intros</span> <span class="n">S</span> <span class="n">hS</span><span class="o">,</span>
  <span class="n">change</span> <span class="bp">∀</span> <span class="n">xab</span> <span class="err">∈</span> <span class="o">(</span><span class="n">sum_of_sets</span> <span class="n">A</span> <span class="n">B</span><span class="o">),</span> <span class="n">xab</span> <span class="bp">≤</span> <span class="n">S</span> <span class="n">at</span> <span class="n">hS</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">sum_of_sets</span> <span class="n">A</span> <span class="n">B</span><span class="o">),</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">sum_of_sets</span><span class="o">,</span>
    <span class="n">existsi</span> <span class="n">y</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">hy</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">z</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">hz</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">S</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hS</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H1</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">S</span> <span class="bp">-</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H3a</span> <span class="o">:=</span> <span class="n">H2</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">linarith</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h21B</span> <span class="o">:=</span> <span class="n">hB</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span> <span class="k">have</span> <span class="n">h22B</span> <span class="o">:=</span> <span class="n">hB</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
  <span class="n">change</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">z</span> <span class="bp">≤</span> <span class="n">b</span> <span class="n">at</span> <span class="n">h22B</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-</span> <span class="n">z</span><span class="o">)</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">A</span><span class="o">,</span> <span class="c1">--!</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H4a</span> <span class="o">:=</span> <span class="n">h22B</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H4b</span> <span class="o">:=</span> <span class="n">H3</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">change</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-</span> <span class="n">z</span><span class="o">),</span>   <span class="c1">-- exact H4b doesn&#39;t do it</span>
</pre></div>

<a name="191300576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191300576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191300576">Kevin Buzzard (Mar 20 2020 at 20:50)</a>:</h4>
<p>The <code>y : ℝ</code> is a constant. Your goal has a variable y in.</p>

<a name="191300652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191300652" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191300652">Daniel Keys (Mar 20 2020 at 20:50)</a>:</h4>
<p>Failing to see the same thing again, huh?</p>

<a name="191300705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191300705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191300705">Kevin Buzzard (Mar 20 2020 at 20:51)</a>:</h4>
<p>Your H4 has a superfluous y in</p>

<a name="191300718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191300718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191300718">Kevin Buzzard (Mar 20 2020 at 20:51)</a>:</h4>
<p>the conclusion of H4 doesn't mention y, so you're still on track</p>

<a name="191300878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191300878" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191300878">Kevin Buzzard (Mar 20 2020 at 20:52)</a>:</h4>
<p>yeah this is fine, your H4 is just not correctly stated.</p>

<a name="191301302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191301302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191301302">Daniel Keys (Mar 20 2020 at 20:56)</a>:</h4>
<p>OK, that helped. I'm past it now.</p>

<a name="191301984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191301984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191301984">Kevin Buzzard (Mar 20 2020 at 21:02)</a>:</h4>
<div class="codehilite"><pre><span></span>  <span class="n">intros</span> <span class="n">S</span> <span class="n">hS</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">S</span> <span class="bp">-</span> <span class="n">z</span> <span class="o">:=</span>
    <span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span> <span class="n">le_sub_right_of_add_le</span> <span class="err">$</span> <span class="n">hS</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">z</span><span class="o">,</span> <span class="n">hz</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
</pre></div>


<p>Here's how I would skip H1 and H2 and prove H3 in term mode.</p>

<a name="191302156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191302156" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191302156">Kevin Buzzard (Mar 20 2020 at 21:03)</a>:</h4>
<p><code>have h21B := hB.right, have h22B := hB.left,</code> could just be <code>cases hB with h22B h21B,</code>, although note that the latter destroys <code>hB</code>.</p>

<a name="191302372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191302372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191302372">Kevin Buzzard (Mar 20 2020 at 21:05)</a>:</h4>
<p>Try commenting out all the lines which mention <code>change</code>. Interesting, huh?</p>

<a name="191303731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191303731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191303731">Daniel Keys (Mar 20 2020 at 21:17)</a>:</h4>
<p>Yes - it's still useful for me at this stage to see things explicitly. <br>
You were right, setting up your own problems teaches you a lot! If you also get some help...</p>
<p>Now here's where I'm right now, I literally have it - but Lean doesn't think so!</p>
<div class="codehilite"><pre><span></span><span class="n">intros</span> <span class="n">S</span> <span class="n">hS</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">sum_of_sets</span> <span class="n">A</span> <span class="n">B</span><span class="o">),</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">sum_of_sets</span><span class="o">,</span>
    <span class="n">existsi</span> <span class="n">y</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">hy</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">z</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">hz</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">S</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hS</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H1</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">S</span> <span class="bp">-</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H3a</span> <span class="o">:=</span> <span class="n">H2</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">linarith</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h21B</span> <span class="o">:=</span> <span class="n">hB</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span> <span class="k">have</span> <span class="n">h22B</span> <span class="o">:=</span> <span class="n">hB</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
  <span class="c1">--change ∀ z ∈ B, z ≤ b at h22B,</span>
  <span class="k">have</span> <span class="n">H4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-</span> <span class="n">z</span><span class="o">)</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">A</span><span class="o">,</span> <span class="c1">--!</span>
    <span class="n">intros</span> <span class="n">z</span> <span class="n">hz</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">H3</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H5</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-</span> <span class="n">z</span><span class="o">),</span>
    <span class="n">intros</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H13A</span> <span class="o">:=</span> <span class="n">hA</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
    <span class="n">change</span> <span class="bp">∀</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">A</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">u</span> <span class="n">at</span> <span class="n">H13A</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H5a</span> <span class="o">:=</span> <span class="n">H4</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>   <span class="c1">-- can&#39;t get to use H13A at all</span>
</pre></div>

<a name="191303844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191303844" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191303844">Daniel Keys (Mar 20 2020 at 21:18)</a>:</h4>
<p>Oh, wait</p>

<a name="191303894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191303894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191303894">Daniel Keys (Mar 20 2020 at 21:19)</a>:</h4>
<p>Done.</p>

<a name="191303915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191303915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191303915">Kevin Buzzard (Mar 20 2020 at 21:19)</a>:</h4>
<p>proof script or it didn't happen</p>

<a name="191303954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191303954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191303954">Patrick Massot (Mar 20 2020 at 21:19)</a>:</h4>
<p>What is this proving?</p>

<a name="191304016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191304016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191304016">Kevin Buzzard (Mar 20 2020 at 21:20)</a>:</h4>
<p>sup S + sup T = sup (S+T)</p>

<a name="191304056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191304056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191304056">Patrick Massot (Mar 20 2020 at 21:20)</a>:</h4>
<p>I mean: what is the Lean statement?</p>

<a name="191304089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191304089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191304089">Kevin Buzzard (Mar 20 2020 at 21:20)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sum_of_sets</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">}</span>
<span class="kn">lemma</span> <span class="n">proposition_2_6</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1A</span> <span class="o">:</span> <span class="n">A</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">h1B</span> <span class="o">:</span> <span class="n">B</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h2A</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2B</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">is_lub</span> <span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">is_lub</span> <span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_lub</span> <span class="o">(</span><span class="n">sum_of_sets</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
</pre></div>

<a name="191304178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191304178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191304178">Patrick Massot (Mar 20 2020 at 21:21)</a>:</h4>
<p>The proof can't possibly start with <code>intros S hS</code></p>

<a name="191304249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191304249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191304249">Daniel Keys (Mar 20 2020 at 21:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191303915" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191303915">said</a>:</p>
<blockquote>
<p>proof script or it didn't happen</p>
</blockquote>
<p>I have <code>H5 : ∀ z ∈ B, a ≤ (S - z)</code>. Still a little ways to go.</p>

<a name="191304259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191304259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191304259">Kevin Buzzard (Mar 20 2020 at 21:22)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="k">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">hA</span> <span class="n">hB</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">sorry</span><span class="o">,</span>  <span class="c1">-- this side works</span>
  <span class="o">},</span>
  <span class="c1">-- now prove that (a+b) is the least upper bound</span>
</pre></div>

<a name="191304296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191304296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191304296">Kevin Buzzard (Mar 20 2020 at 21:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="259186">Daniel Keys</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191304249" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191304249">said</a>:</p>
<blockquote>
<p>I have <code>H5 : ∀ z ∈ B, a ≤ (S - z)</code>. Still a little ways to go.</p>
</blockquote>
<p>Oh! I'm rooting for you :-)</p>

<a name="191304324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191304324" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191304324">Kevin Buzzard (Mar 20 2020 at 21:22)</a>:</h4>
<p>I'm making some other proofs</p>

<a name="191304475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191304475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191304475">Kevin Buzzard (Mar 20 2020 at 21:24)</a>:</h4>
<p>Patrick, we're just talking about this part:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">proposition_2_6&#39;&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1A</span> <span class="o">:</span> <span class="n">A</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">h1B</span> <span class="o">:</span> <span class="n">B</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h2A</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2B</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">lower_bounds</span> <span class="o">(</span><span class="n">upper_bounds</span> <span class="o">(</span><span class="n">sum_of_sets</span> <span class="n">A</span> <span class="n">B</span><span class="o">))</span> <span class="o">:=</span>
</pre></div>

<a name="191304669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191304669" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191304669">Patrick Massot (Mar 20 2020 at 21:26)</a>:</h4>
<p>How can it be that complicated?</p>

<a name="191304790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191304790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191304790">Kevin Buzzard (Mar 20 2020 at 21:27)</a>:</h4>
<p>He's a beginner!</p>

<a name="191304837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191304837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191304837">Kevin Buzzard (Mar 20 2020 at 21:28)</a>:</h4>
<p>We're going to refactor after.</p>

<a name="191304879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191304879" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191304879">Patrick Massot (Mar 20 2020 at 21:28)</a>:</h4>
<p>Ok, I should go to the PR and issues lists.</p>

<a name="191305463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191305463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191305463">Daniel Keys (Mar 20 2020 at 21:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191303915" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191303915">said</a>:</p>
<blockquote>
<p>proof script or it didn't happen</p>
</blockquote>
<p>OK now, this is the finish. Uncountable thanks, Kevin!</p>
<div class="codehilite"><pre><span></span><span class="k">have</span> <span class="n">H5</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-</span> <span class="n">z</span><span class="o">),</span>
    <span class="n">intros</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H13A</span> <span class="o">:=</span> <span class="n">hA</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
    <span class="n">change</span> <span class="bp">∀</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">A</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">u</span> <span class="n">at</span> <span class="n">H13A</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H5a</span> <span class="o">:=</span> <span class="n">H4</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">H13A</span> <span class="o">(</span><span class="n">S</span><span class="bp">-</span><span class="n">z</span><span class="o">)</span> <span class="n">H5a</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H6</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">z</span> <span class="bp">≤</span> <span class="n">S</span> <span class="bp">-</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H6a</span> <span class="o">:=</span> <span class="n">H5</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span> <span class="n">linarith</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H7</span> <span class="o">:</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">B</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H6</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H8</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">S</span><span class="bp">-</span><span class="n">a</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">H13B</span> <span class="o">:=</span> <span class="n">hB</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
    <span class="n">change</span> <span class="bp">∀</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">B</span><span class="o">,</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">u</span> <span class="n">at</span> <span class="n">H13B</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">H13B</span> <span class="o">(</span><span class="n">S</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="n">H7</span><span class="o">,</span>
  <span class="n">linarith</span><span class="o">,</span> <span class="n">done</span>
</pre></div>

<a name="191305486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191305486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191305486">Kevin Buzzard (Mar 20 2020 at 21:34)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">proposition_2_6&#39;&#39;&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">lower_bounds</span> <span class="o">(</span><span class="n">upper_bounds</span> <span class="o">(</span><span class="n">sum_of_sets</span> <span class="n">A</span> <span class="n">B</span><span class="o">))</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">S</span> <span class="n">hS</span><span class="o">,</span> <span class="n">add_le_of_le_sub_left</span> <span class="err">$</span> <span class="n">hB</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span> <span class="n">le_sub</span><span class="bp">.</span><span class="mi">1</span> <span class="err">$</span> <span class="n">hA</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span> <span class="n">le_sub_right_of_add_le</span> <span class="err">$</span> <span class="n">hS</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">z</span><span class="o">,</span> <span class="n">hz</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>
</pre></div>

<a name="191305573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191305573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191305573">Daniel Keys (Mar 20 2020 at 21:35)</a>:</h4>
<p>Still need to work on term mode. On my to do list.</p>

<a name="191305595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191305595" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191305595">Kevin Buzzard (Mar 20 2020 at 21:35)</a>:</h4>
<p>So do you want to refactor your proof to make it much shorter?</p>

<a name="191305672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191305672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191305672">Daniel Keys (Mar 20 2020 at 21:36)</a>:</h4>
<p>Meaning?</p>

<a name="191305774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191305774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191305774">Kevin Buzzard (Mar 20 2020 at 21:37)</a>:</h4>
<p>do you want me to show you how to think about your proof so that the next time you have to write such a proof it will come out better, shorter, and will compile quicker?</p>

<a name="191305802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191305802" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191305802">Kevin Buzzard (Mar 20 2020 at 21:37)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">proposition_2_6&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1A</span> <span class="o">:</span> <span class="n">A</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">h1B</span> <span class="o">:</span> <span class="n">B</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h2A</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2B</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">lower_bounds</span> <span class="o">(</span><span class="n">upper_bounds</span> <span class="o">(</span><span class="n">sum_of_sets</span> <span class="n">A</span> <span class="n">B</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">S</span> <span class="n">hS</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">sum_of_sets</span> <span class="n">A</span> <span class="n">B</span><span class="o">),</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">sum_of_sets</span><span class="o">,</span>
    <span class="n">existsi</span> <span class="n">y</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">hy</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">z</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">hz</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">S</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hS</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H1</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">S</span> <span class="bp">-</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H3a</span> <span class="o">:=</span> <span class="n">H2</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">linarith</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h21B</span> <span class="o">:=</span> <span class="n">hB</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span> <span class="k">have</span> <span class="n">h22B</span> <span class="o">:=</span> <span class="n">hB</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
  <span class="c1">--change ∀ z ∈ B, z ≤ b at h22B,</span>
  <span class="k">have</span> <span class="n">H4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-</span> <span class="n">z</span><span class="o">)</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">A</span><span class="o">,</span> <span class="c1">--!</span>
    <span class="n">intros</span> <span class="n">z</span> <span class="n">hz</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">H3</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H5</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-</span> <span class="n">z</span><span class="o">),</span>
    <span class="n">intros</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H13A</span> <span class="o">:=</span> <span class="n">hA</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
    <span class="n">change</span> <span class="bp">∀</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">A</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">u</span> <span class="n">at</span> <span class="n">H13A</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H5a</span> <span class="o">:=</span> <span class="n">H4</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">H13A</span> <span class="o">(</span><span class="n">S</span><span class="bp">-</span><span class="n">z</span><span class="o">)</span> <span class="n">H5a</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H6</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">z</span> <span class="bp">≤</span> <span class="n">S</span> <span class="bp">-</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H6a</span> <span class="o">:=</span> <span class="n">H5</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span> <span class="n">linarith</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H7</span> <span class="o">:</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">B</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H6</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H8</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">S</span><span class="bp">-</span><span class="n">a</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">H13B</span> <span class="o">:=</span> <span class="n">hB</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
    <span class="n">change</span> <span class="bp">∀</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">B</span><span class="o">,</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">u</span> <span class="n">at</span> <span class="n">H13B</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">H13B</span> <span class="o">(</span><span class="n">S</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="n">H7</span><span class="o">,</span>
  <span class="n">linarith</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="191305848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191305848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191305848">Daniel Keys (Mar 20 2020 at 21:37)</a>:</h4>
<p>Of course.</p>

<a name="191305948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191305948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191305948">Kevin Buzzard (Mar 20 2020 at 21:38)</a>:</h4>
<p>That's your proof currently. I tidied up the beginning -- I removed the sorry and I did the intro and cases (I changed the goal a bit so hA and hB are now hypotheses and I changed the conclusion so it was just the goal you were working on)</p>

<a name="191305991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191305991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191305991">Daniel Keys (Mar 20 2020 at 21:39)</a>:</h4>
<p>Right, I did see that.</p>

<a name="191306020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306020">Kevin Buzzard (Mar 20 2020 at 21:39)</a>:</h4>
<p>So the thing I like least about your proof is the <code>linarith</code>s</p>

<a name="191306119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306119">Kevin Buzzard (Mar 20 2020 at 21:40)</a>:</h4>
<p>I mean, it's great that <code>linarith</code> exists and can do all sorts of linear inequalities, but when you use it you're using a sledgehammer to crack a nut.</p>

<a name="191306137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306137">Daniel Keys (Mar 20 2020 at 21:40)</a>:</h4>
<p>OK, I did those since I know how to deal with those goals.</p>

<a name="191306171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306171">Kevin Buzzard (Mar 20 2020 at 21:40)</a>:</h4>
<p>The first time you use it is about 11 lines into your proof.</p>

<a name="191306173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306173">Daniel Keys (Mar 20 2020 at 21:40)</a>:</h4>
<p>But I agree with you.</p>

<a name="191306198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306198">Kevin Buzzard (Mar 20 2020 at 21:41)</a>:</h4>
<p>Your local context is</p>
<div class="codehilite"><pre><span></span>...
H3a : y + z ≤ S
⊢ y ≤ S - z
</pre></div>

<a name="191306209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306209" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306209">Kevin Buzzard (Mar 20 2020 at 21:41)</a>:</h4>
<p>and you solve this with <code>linarith</code></p>

<a name="191306245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306245">Kevin Buzzard (Mar 20 2020 at 21:41)</a>:</h4>
<p>So I look at that and think "that is a completely standard fact so it's going to be in the library"</p>

<a name="191306312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306312">Daniel Keys (Mar 20 2020 at 21:42)</a>:</h4>
<p>Yes, agreed. Just lazy, there were bigger fish...</p>

<a name="191306362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306362">Kevin Buzzard (Mar 20 2020 at 21:42)</a>:</h4>
<p>The problem is, I don't know whether it's going to be  <code>y + z ≤ S -&gt;  y ≤ S - z</code> or <code> y ≤ S - z &lt;-&gt;  y ≤ S - z</code> in the library, and I don't know the name of the lemma either.</p>

<a name="191306398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306398" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306398">Kevin Buzzard (Mar 20 2020 at 21:43)</a>:</h4>
<p>But if you know the tricks, you can sort this out really easily.</p>

<a name="191306440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306440">Daniel Keys (Mar 20 2020 at 21:43)</a>:</h4>
<p><code>library_search</code>? I also browse through files many times.</p>

<a name="191306457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306457">Kevin Buzzard (Mar 20 2020 at 21:43)</a>:</h4>
<p>You don't need anything like that</p>

<a name="191306538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306538" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306538">Kevin Buzzard (Mar 20 2020 at 21:44)</a>:</h4>
<p>you can do this just with VS Code tricks. Your goal is y &lt;= S - z and so the Lean name for the theorem you want will start <code>le_sub</code></p>

<a name="191306564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306564" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306564">Kevin Buzzard (Mar 20 2020 at 21:44)</a>:</h4>
<p>so you can replace that first <code>linarith</code> with <code>exact le_sub</code> but we're not finished yet</p>

<a name="191306576"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306576" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306576">Daniel Keys (Mar 20 2020 at 21:44)</a>:</h4>
<p><code>sub</code> for subtraction here?</p>

<a name="191306638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306638">Kevin Buzzard (Mar 20 2020 at 21:45)</a>:</h4>
<p>Right. There's a code which you eventually pick up. <code>≤</code> is <code>le</code>, <code>&lt;</code> is <code>lt</code> etc</p>

<a name="191306682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306682">Daniel Keys (Mar 20 2020 at 21:45)</a>:</h4>
<p>I saw lots of these in NNG, but there was no <code>sub</code> there. So this one's new.</p>

<a name="191306732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306732" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306732">Kevin Buzzard (Mar 20 2020 at 21:46)</a>:</h4>
<p>If I delete that first <code>linarith</code> and replace it with <code>exact le_sub</code> then VS Code immediately gives me a list of possible completions. Does that work for you?</p>

<a name="191306826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306826">Kevin Buzzard (Mar 20 2020 at 21:47)</a>:</h4>
<p>If it doesn't, try <code>exact le_sub</code> and then hit ctrl-space. This is a really important trick to learn.</p>

<a name="191306831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306831">Daniel Keys (Mar 20 2020 at 21:47)</a>:</h4>
<p>Yes, five options. Thanks for the hint!</p>

<a name="191306885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306885">Kevin Buzzard (Mar 20 2020 at 21:47)</a>:</h4>
<p>and you can scroll up and down with the arrow keys and see what all the suggestions are.</p>

<a name="191306963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191306963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191306963">Kevin Buzzard (Mar 20 2020 at 21:48)</a>:</h4>
<p>and <code>le_sub_right_of_add_le</code> is exactly what you want.</p>

<a name="191307042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307042">Kevin Buzzard (Mar 20 2020 at 21:49)</a>:</h4>
<p>so you can hit <code>tab</code> and it will complete for you, and you can change that <code>linarith</code> to <code>    exact le_sub_right_of_add_le H3a,</code></p>

<a name="191307067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307067" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307067">Patrick Massot (Mar 20 2020 at 21:49)</a>:</h4>
<p><code>library_search</code> would have been faster.</p>

<a name="191307097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307097">Kevin Buzzard (Mar 20 2020 at 21:49)</a>:</h4>
<p>You'd have to revert H3 or something.</p>

<a name="191307111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307111">Patrick Massot (Mar 20 2020 at 21:49)</a>:</h4>
<p>Why?</p>

<a name="191307154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307154">Kevin Buzzard (Mar 20 2020 at 21:50)</a>:</h4>
<p>Oh you don't have to?</p>

<a name="191307178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307178">Patrick Massot (Mar 20 2020 at 21:50)</a>:</h4>
<p>Don't underestimate the power of <code>library_search</code></p>

<a name="191307207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307207" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307207">Kevin Buzzard (Mar 20 2020 at 21:50)</a>:</h4>
<p>For the second one we have </p>
<div class="codehilite"><pre><span></span>H6a : a ≤ S - z
⊢ z ≤ S - a
</pre></div>


<p>Let's try <code>library_search</code></p>

<a name="191307227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307227">Patrick Massot (Mar 20 2020 at 21:50)</a>:</h4>
<p>Go back watching Gabriel's talk in Pittsburgh.</p>

<a name="191307280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307280">Kevin Buzzard (Mar 20 2020 at 21:51)</a>:</h4>
<p>library_search doesn't give the optimal answer for the second one: <code>exact le_sub.mp (H5 z hz)</code></p>

<a name="191307381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307381">Daniel Keys (Mar 20 2020 at 21:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191307227" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191307227">said</a>:</p>
<blockquote>
<p>Go back watching Gabriel's talk in Pittsburgh.</p>
</blockquote>
<p>Is that a video you're talking about, Patrick?</p>

<a name="191307493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307493">Kevin Buzzard (Mar 20 2020 at 21:52)</a>:</h4>
<p>If I try <code>exact le_sub</code> I see that <code>le_sub</code> is pretty much nearly what we want, except that it's an if and only if</p>

<a name="191307554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307554">Kevin Buzzard (Mar 20 2020 at 21:53)</a>:</h4>
<p>and you can pull out one way of an if and only if with a <code>.1</code>, so </p>
<div class="codehilite"><pre><span></span>    have H6a := H5 z hz, exact le_sub.1 H6a,
</pre></div>

<a name="191307613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307613">Kevin Buzzard (Mar 20 2020 at 21:54)</a>:</h4>
<p>The third one is on the last line of the script, and it's</p>
<div class="codehilite"><pre><span></span>H8 : b ≤ S - a
⊢ a + b ≤ S
</pre></div>

<a name="191307655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307655">Kevin Buzzard (Mar 20 2020 at 21:54)</a>:</h4>
<p>and again <code>library_search</code> gives a terrifying answer</p>

<a name="191307711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307711">Kevin Buzzard (Mar 20 2020 at 21:55)</a>:</h4>
<p>but I'm going to change it to <code>  exact add_le_of_le_sub_left H8,</code></p>

<a name="191307728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307728">Kevin Buzzard (Mar 20 2020 at 21:55)</a>:</h4>
<p>so now we have this:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">proposition_2_6&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1A</span> <span class="o">:</span> <span class="n">A</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">h1B</span> <span class="o">:</span> <span class="n">B</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h2A</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2B</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">lower_bounds</span> <span class="o">(</span><span class="n">upper_bounds</span> <span class="o">(</span><span class="n">sum_of_sets</span> <span class="n">A</span> <span class="n">B</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">S</span> <span class="n">hS</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="err">∈</span> <span class="o">(</span><span class="n">sum_of_sets</span> <span class="n">A</span> <span class="n">B</span><span class="o">),</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">sum_of_sets</span><span class="o">,</span>
    <span class="n">existsi</span> <span class="n">y</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">hy</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">z</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">hz</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">S</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hS</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H1</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">S</span> <span class="bp">-</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H3a</span> <span class="o">:=</span> <span class="n">H2</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">le_sub_right_of_add_le</span> <span class="n">H3a</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h21B</span> <span class="o">:=</span> <span class="n">hB</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span> <span class="k">have</span> <span class="n">h22B</span> <span class="o">:=</span> <span class="n">hB</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span>
  <span class="c1">--change ∀ z ∈ B, z ≤ b at h22B,</span>
  <span class="k">have</span> <span class="n">H4</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-</span> <span class="n">z</span><span class="o">)</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">A</span><span class="o">,</span> <span class="c1">--!</span>
    <span class="n">intros</span> <span class="n">z</span> <span class="n">hz</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">H3</span> <span class="n">y</span> <span class="n">hy</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
<span class="k">have</span> <span class="n">H5</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-</span> <span class="n">z</span><span class="o">),</span>
    <span class="n">intros</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H13A</span> <span class="o">:=</span> <span class="n">hA</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
    <span class="n">change</span> <span class="bp">∀</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">A</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">u</span> <span class="n">at</span> <span class="n">H13A</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H5a</span> <span class="o">:=</span> <span class="n">H4</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">H13A</span> <span class="o">(</span><span class="n">S</span><span class="bp">-</span><span class="n">z</span><span class="o">)</span> <span class="n">H5a</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H6</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">B</span><span class="o">,</span> <span class="n">z</span> <span class="bp">≤</span> <span class="n">S</span> <span class="bp">-</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">H6a</span> <span class="o">:=</span> <span class="n">H5</span> <span class="n">z</span> <span class="n">hz</span><span class="o">,</span> <span class="n">exact</span> <span class="n">le_sub</span><span class="bp">.</span><span class="mi">1</span> <span class="n">H6a</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H7</span> <span class="o">:</span> <span class="o">(</span><span class="n">S</span> <span class="bp">-</span> <span class="n">a</span><span class="o">)</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">B</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H6</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H8</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="o">(</span><span class="n">S</span><span class="bp">-</span><span class="n">a</span><span class="o">),</span>
    <span class="k">have</span> <span class="n">H13B</span> <span class="o">:=</span> <span class="n">hB</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
    <span class="n">change</span> <span class="bp">∀</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">B</span><span class="o">,</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">u</span> <span class="n">at</span> <span class="n">H13B</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">H13B</span> <span class="o">(</span><span class="n">S</span><span class="bp">-</span><span class="n">a</span><span class="o">)</span> <span class="n">H7</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">add_le_of_le_sub_left</span> <span class="n">H8</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="191307748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307748">Kevin Buzzard (Mar 20 2020 at 21:55)</a>:</h4>
<p>and now our proof uses only really basic tactics so it's in a really good form to play with.</p>

<a name="191307820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307820" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307820">Kevin Buzzard (Mar 20 2020 at 21:56)</a>:</h4>
<p>Next thing: did you know that <code>change</code> doesn't really do anything? It's necessary for rewrites, but not for stuff like apply and intro.</p>

<a name="191307844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307844" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307844">Daniel Keys (Mar 20 2020 at 21:56)</a>:</h4>
<p>Thanks Kevin, for taking all this time! Yes, I know about <code>change</code>.</p>

<a name="191307875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307875">Kevin Buzzard (Mar 20 2020 at 21:57)</a>:</h4>
<p>actually let's leave these. Let me get to the bombshell.</p>

<a name="191307889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307889">Daniel Keys (Mar 20 2020 at 21:57)</a>:</h4>
<p>These are supposed to be readable by students, once I get up standing myself.</p>

<a name="191307912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307912" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307912">Kevin Buzzard (Mar 20 2020 at 21:57)</a>:</h4>
<p>The bombshell is that your proof is twice as long as it needs to be, because you wrote it in a direction which a mathematician would call "forwards"</p>

<a name="191307919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307919" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307919">Patrick Massot (Mar 20 2020 at 21:57)</a>:</h4>
<p><a href="https://www.youtube.com/watch?v=WydyJJYKyTs&amp;list=PLlF-CfQhukNkWwZt45vkNfWfuO-tBBqPN&amp;index=16&amp;t=0s" target="_blank" title="https://www.youtube.com/watch?v=WydyJJYKyTs&amp;list=PLlF-CfQhukNkWwZt45vkNfWfuO-tBBqPN&amp;index=16&amp;t=0s">https://www.youtube.com/watch?v=WydyJJYKyTs&amp;list=PLlF-CfQhukNkWwZt45vkNfWfuO-tBBqPN&amp;index=16&amp;t=0s</a> explains how powerfull is library_search</p>
<div class="youtube-video message_inline_image"><a data-id="WydyJJYKyTs" href="https://www.youtube.com/watch?v=WydyJJYKyTs&amp;list=PLlF-CfQhukNkWwZt45vkNfWfuO-tBBqPN&amp;index=16&amp;t=0s" target="_blank" title="https://www.youtube.com/watch?v=WydyJJYKyTs&amp;list=PLlF-CfQhukNkWwZt45vkNfWfuO-tBBqPN&amp;index=16&amp;t=0s"><img src="https://i.ytimg.com/vi/WydyJJYKyTs/default.jpg"></a></div>

<a name="191307973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191307973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191307973">Kevin Buzzard (Mar 20 2020 at 21:58)</a>:</h4>
<p>and which a computer scientist would call "the wrong way around"</p>

<a name="191308007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308007">Kevin Buzzard (Mar 20 2020 at 21:58)</a>:</h4>
<p>You prove 8 sub-theorems H1 to H8 and then finished the job</p>

<a name="191308014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308014">Kevin Buzzard (Mar 20 2020 at 21:58)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="110031">@Patrick Massot</span></p>

<a name="191308031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308031">Kevin Buzzard (Mar 20 2020 at 21:58)</a>:</h4>
<p>And each H(n+1) followed from Hn</p>

<a name="191308066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308066">Kevin Buzzard (Mar 20 2020 at 21:59)</a>:</h4>
<p>and at the end of it your local context looks like this:</p>
<div class="codehilite"><pre><span></span>1 goal
A B : set ℝ,
h1A : set.nonempty A,
h1B : set.nonempty B,
h2A : bdd_above A,
h2B : bdd_above B,
a b : ℝ,
hA : is_lub A a,
hB : is_lub B b,
S : ℝ,
hS : S ∈ upper_bounds (sum_of_sets A B),
H1 : ∀ (y : ℝ), y ∈ A → ∀ (z : ℝ), z ∈ B → y + z ∈ sum_of_sets A B,
H2 : ∀ (y : ℝ), y ∈ A → ∀ (z : ℝ), z ∈ B → y + z ≤ S,
H3 : ∀ (y : ℝ), y ∈ A → ∀ (z : ℝ), z ∈ B → y ≤ S - z,
h21B : b ∈ lower_bounds (upper_bounds B),
h22B : b ∈ upper_bounds B,
H4 : ∀ (z : ℝ), z ∈ B → S - z ∈ upper_bounds A,
H5 : ∀ (z : ℝ), z ∈ B → a ≤ S - z,
H6 : ∀ (z : ℝ), z ∈ B → z ≤ S - a,
H7 : S - a ∈ upper_bounds B,
H8 : b ≤ S - a
⊢ a + b ≤ S
</pre></div>

<a name="191308110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308110">Kevin Buzzard (Mar 20 2020 at 21:59)</a>:</h4>
<p>You proved H1 -&gt; H2 -&gt; H3 -&gt; H4 -&gt; H5 -&gt; H6 -&gt; H7 -&gt; H8</p>

<a name="191308122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308122">Kevin Buzzard (Mar 20 2020 at 21:59)</a>:</h4>
<p>and H8 -&gt; goal</p>

<a name="191308203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308203">Kevin Buzzard (Mar 20 2020 at 22:00)</a>:</h4>
<p>Let's now write exactly the same proof, but backwards.</p>

<a name="191308238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308238" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308238">Daniel Keys (Mar 20 2020 at 22:00)</a>:</h4>
<p>You mean using <code>apply</code>?</p>

<a name="191308259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308259">Kevin Buzzard (Mar 20 2020 at 22:01)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">proposition_2_6&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1A</span> <span class="o">:</span> <span class="n">A</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">h1B</span> <span class="o">:</span> <span class="n">B</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h2A</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2B</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">lower_bounds</span> <span class="o">(</span><span class="n">upper_bounds</span> <span class="o">(</span><span class="n">sum_of_sets</span> <span class="n">A</span> <span class="n">B</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">S</span> <span class="n">hS</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>The goal is <code>⊢ a + b ≤ S</code></p>

<a name="191308429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308429">Kevin Buzzard (Mar 20 2020 at 22:02)</a>:</h4>
<p>and the last line of our current proof is <code>exact add_le_of_le_sub_left H8,</code> so let's make the first line of our new proof be <code>apply add_le_of_le_sub_left,</code></p>

<a name="191308438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308438" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308438">Kevin Buzzard (Mar 20 2020 at 22:02)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">proposition_2_6&#39;&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1A</span> <span class="o">:</span> <span class="n">A</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span> <span class="o">(</span><span class="n">h1B</span> <span class="o">:</span> <span class="n">B</span><span class="bp">.</span><span class="n">nonempty</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h2A</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">h2B</span> <span class="o">:</span> <span class="n">bdd_above</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hA</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hB</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">lower_bounds</span> <span class="o">(</span><span class="n">upper_bounds</span> <span class="o">(</span><span class="n">sum_of_sets</span> <span class="n">A</span> <span class="n">B</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">S</span> <span class="n">hS</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">add_le_of_le_sub_left</span><span class="o">,</span>
  <span class="n">sorry</span> <span class="c1">-- goal is ⊢ b ≤ S - a</span>
<span class="kn">end</span>
</pre></div>

<a name="191308456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308456">Kevin Buzzard (Mar 20 2020 at 22:02)</a>:</h4>
<p>and now our goal is <code>H8</code></p>

<a name="191308467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308467">Daniel Keys (Mar 20 2020 at 22:02)</a>:</h4>
<p>OK. Let me take it from here.</p>

<a name="191308487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308487">Kevin Buzzard (Mar 20 2020 at 22:03)</a>:</h4>
<p>Go for it! I did it, it's really good fun :-)</p>

<a name="191308530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308530">Daniel Keys (Mar 20 2020 at 22:03)</a>:</h4>
<p>I have to go now, but will definitely try it later. Will haul back for help if needed.</p>

<a name="191308533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308533" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308533">Kevin Buzzard (Mar 20 2020 at 22:03)</a>:</h4>
<p>Note that H7 and H6 are exactly the same goal!</p>

<a name="191308536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308536" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308536">Patrick Massot (Mar 20 2020 at 22:03)</a>:</h4>
<p>I don't think you need to do backwards to make it shorter.</p>

<a name="191308542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308542">Kevin Buzzard (Mar 20 2020 at 22:03)</a>:</h4>
<p>so you can skip H7</p>

<a name="191308608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308608">Kevin Buzzard (Mar 20 2020 at 22:04)</a>:</h4>
<p>Patrick did you see my one line term proof? I made that by turning Daniel's proof backwards and then termifying it</p>

<a name="191308614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308614">Daniel Keys (Mar 20 2020 at 22:04)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191308536" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191308536">said</a>:</p>
<blockquote>
<p>I don't think you need to do backwards to make it shorter.</p>
</blockquote>
<p>Either way is good practice for me.</p>

<a name="191308645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308645">Patrick Massot (Mar 20 2020 at 22:04)</a>:</h4>
<p>No, I haven't seen your proof term.</p>

<a name="191308659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308659">Patrick Massot (Mar 20 2020 at 22:05)</a>:</h4>
<p>But I guess it's hard to read.</p>

<a name="191308672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308672">Kevin Buzzard (Mar 20 2020 at 22:05)</a>:</h4>
<p><a href="#narrow/stream/113489-new-members/topic/noob.20question%28s%29/near/191305486" title="#narrow/stream/113489-new-members/topic/noob.20question%28s%29/near/191305486">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/noob.20question%28s%29/near/191305486</a></p>

<a name="191308696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308696">Kevin Buzzard (Mar 20 2020 at 22:05)</a>:</h4>
<p>It's the same as <span class="user-mention" data-user-id="259186">@Daniel Keys</span> 's proof :-)</p>

<a name="191308707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308707">Patrick Massot (Mar 20 2020 at 22:05)</a>:</h4>
<p>It looks has I expected...</p>

<a name="191308780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308780">Patrick Massot (Mar 20 2020 at 22:06)</a>:</h4>
<p>My advice for Daniel is: try to get a clearer mathematical picture.</p>

<a name="191308807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308807">Kevin Buzzard (Mar 20 2020 at 22:06)</a>:</h4>
<p>It is super-satisfying to turn this proof backwards</p>

<a name="191308834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308834" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308834">Mario Carneiro (Mar 20 2020 at 22:06)</a>:</h4>
<p>If you break that term mode proof into a couple <code>apply</code>s and <code>intro</code>s it should be plenty readable</p>

<a name="191308838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191308838" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191308838">Daniel Keys (Mar 20 2020 at 22:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191308780" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191308780">said</a>:</p>
<blockquote>
<p>My advice for Daniel is: try to get a clearer mathematical picture.</p>
</blockquote>
<p>Why exactly, Patrick?</p>

<a name="191309016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309016">Patrick Massot (Mar 20 2020 at 22:08)</a>:</h4>
<p>I would start with</p>
<div class="codehilite"><pre><span></span>  <span class="n">intros</span> <span class="n">S</span> <span class="n">hS</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="n">S</span> <span class="bp">-</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">B</span><span class="o">,</span>
    <span class="n">sorry</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H2</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">-</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">A</span><span class="o">,</span>
    <span class="n">sorry</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span>
</pre></div>


<p>where each sorry is at most three lines long.</p>

<a name="191309047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309047">Patrick Massot (Mar 20 2020 at 22:09)</a>:</h4>
<p>I claim this is a readable outline of the proof.</p>

<a name="191309143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309143">Kevin Buzzard (Mar 20 2020 at 22:10)</a>:</h4>
<p>I think it's interesting that I set this question to about 250 students and out of all of them, only one person proved it constructively.</p>

<a name="191309170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309170" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309170">Patrick Massot (Mar 20 2020 at 22:10)</a>:</h4>
<p>And this does not come through Lean mastery, it's the mathematical understanding.</p>

<a name="191309221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309221">Mario Carneiro (Mar 20 2020 at 22:11)</a>:</h4>
<p>what's up with these unbracketed indented blocks after <code>have</code>? This isn't python</p>

<a name="191309242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309242">Kevin Buzzard (Mar 20 2020 at 22:11)</a>:</h4>
<p>Everyone said that if some upper bound was less than a+b then you could find some element of A which was within epsilon/2 of the upper bound for A etc.</p>

<a name="191309288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309288">Kevin Buzzard (Mar 20 2020 at 22:12)</a>:</h4>
<p>indented blocks: I thought that TPIL said that this was OK. Doesn't it?</p>

<a name="191309303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309303">Patrick Massot (Mar 20 2020 at 22:12)</a>:</h4>
<p>Mario, I can tell you very precisely where they come from.</p>

<a name="191309339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309339" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309339">Mario Carneiro (Mar 20 2020 at 22:12)</a>:</h4>
<p>they have the same problem as unbracketed blocks elsewhere</p>

<a name="191309369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309369">Mario Carneiro (Mar 20 2020 at 22:13)</a>:</h4>
<p>tactics can end up doing too much and messing up other branches of the proof</p>

<a name="191309385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309385">Kevin Buzzard (Mar 20 2020 at 22:13)</a>:</h4>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/tactics.html?highlight=indent#basic-tactics" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/tactics.html?highlight=indent#basic-tactics">https://leanprover.github.io/theorem_proving_in_lean/tactics.html?highlight=indent#basic-tactics</a></p>

<a name="191309410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309410">Patrick Massot (Mar 20 2020 at 22:13)</a>:</h4>
<p>Last year I taught curly brackets to my undergrads. But they were unable to balance them properly. And then Lean stopped displaying anything, or wrote very confusing error messages (which means any error message for my students). This year I taught indented blocks, and Lean became easy.</p>

<a name="191309500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309500">Kevin Buzzard (Mar 20 2020 at 22:14)</a>:</h4>
<p>unbalanced bracket = really really horrible errors. You either get <code>sync</code> or you just get literally nothing. No display at any point in your proof.</p>

<a name="191309514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309514">Kevin Buzzard (Mar 20 2020 at 22:14)</a>:</h4>
<p>Really hard to debug</p>

<a name="191309515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309515">Patrick Massot (Mar 20 2020 at 22:14)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191309385" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191309385">said</a>:</p>
<blockquote>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/tactics.html?highlight=indent#basic-tactics" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/tactics.html?highlight=indent#basic-tactics">https://leanprover.github.io/theorem_proving_in_lean/tactics.html?highlight=indent#basic-tactics</a></p>
</blockquote>
<p>And Mario adds one line to his "When he won't be my advisor anymore" notebook.</p>

<a name="191309556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309556">Mario Carneiro (Mar 20 2020 at 22:15)</a>:</h4>
<p>Does anyone want to teach python to lean? I agree the error messages are terrible</p>

<a name="191309601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309601" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309601">Kevin Buzzard (Mar 20 2020 at 22:15)</a>:</h4>
<p>A lot of the kids know python anyway, at least mathematicians do, they are taught it at my university</p>

<a name="191309607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309607" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309607">Mario Carneiro (Mar 20 2020 at 22:15)</a>:</h4>
<p>I think coq uses some kind of markdown list thing</p>

<a name="191309720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309720">Patrick Massot (Mar 20 2020 at 22:17)</a>:</h4>
<p>I like Lean's <code>{</code>/<code>}</code>, but my teaching taught me bad habits.</p>

<a name="191309866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191309866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191309866">Patrick Massot (Mar 20 2020 at 22:18)</a>:</h4>
<p>I need to go, so I'll post spoilers for Daniel:<br>
.<br>
.<br>
.<br>
.<br>
.<br>
.<br>
.<br>
.<br>
.<br>
.<br>
.<br>
.</p>
<div class="codehilite"><pre><span></span>  <span class="n">intros</span> <span class="n">S</span> <span class="n">hS</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">A</span><span class="o">,</span> <span class="n">S</span> <span class="bp">-</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">B</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">≤</span> <span class="n">S</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span> <span class="c1">-- by rwa le_sub_iff_add_le&#39;,</span>
    <span class="n">exact</span> <span class="n">hS</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">H2</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">-</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">upper_bounds</span> <span class="n">A</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">suffices</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">S</span> <span class="bp">-</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span> <span class="c1">-- by rwa le_sub,</span>
    <span class="n">exact</span> <span class="n">hB</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">H1</span> <span class="n">x</span> <span class="n">hx</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">linarith</span> <span class="o">[</span><span class="n">hA</span><span class="bp">.</span><span class="mi">2</span> <span class="n">H2</span><span class="o">],</span> <span class="c1">--exact le_sub_iff_add_le.mp (hA.2 H2),</span>
</pre></div>


<p>The commented our version are only for Kevin's pleasure. I don't see any point in learning those lemmas.</p>

<a name="191310436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191310436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191310436">Kevin Buzzard (Mar 20 2020 at 22:24)</a>:</h4>
<p>I was going to see if I could take Daniel to the full term proof, and there they're important; we don't enter tactic mode at all there, so you can really see that the proof is just a function. This is kind of a startling revelation to a mathematician.</p>

<a name="191311932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191311932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191311932">Kevin Buzzard (Mar 20 2020 at 22:43)</a>:</h4>
<blockquote>
<p>I don't see any point in learning those lemmas.</p>
</blockquote>
<p>Another reason for showing the ctrl-space technique is that even though of course you're right that <code>linarith</code> will prove all of them, it is generally a very important technique, especially when you're in situations like trying to figure out how to prove <code>a \in {a}</code>, where what I explained is exactly how a beginner should find that proof (<code>mem_singleton-ctrl-space</code>)</p>

<a name="191320510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191320510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191320510">Stephanie Zhou (Mar 21 2020 at 00:57)</a>:</h4>
<p>How do I use e (as in Euler's number) in lean?</p>

<a name="191324041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191324041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191324041">Mario Carneiro (Mar 21 2020 at 02:29)</a>:</h4>
<p>I don't think <code>e</code> has been defined, but you can use <code>real.exp 1</code> if you import <code>data.complex.exponential</code></p>

<a name="191357401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191357401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191357401">Paul van Wamelen (Mar 21 2020 at 17:41)</a>:</h4>
<p>The following:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">gcd</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">*</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_eq_gcd_ab</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span>
<span class="kn">end</span>
</pre></div>


<p>fails at the <code>rw</code> because lean can't match <code>↑(2 * a)</code> with <code>2 * ↑a</code>. I can do:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">*</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="k">let</span> <span class="n">a2</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">change</span> <span class="mi">1</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a2</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">*</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd_a</span> <span class="n">a2</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">nat</span><span class="bp">.</span><span class="n">gcd_b</span> <span class="n">a2</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">nat</span><span class="bp">.</span><span class="n">gcd_eq_gcd_ab</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span>
<span class="kn">end</span>
</pre></div>


<p>Is there a better way? (I should probably ask: <em>what</em> is the better way <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span> )</p>

<a name="191357487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191357487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191357487">Kevin Buzzard (Mar 21 2020 at 17:43)</a>:</h4>
<p>One question might be: if you're interested in integers, why are you using naturals at all?</p>

<a name="191357550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191357550" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191357550">Kevin Buzzard (Mar 21 2020 at 17:44)</a>:</h4>
<p>But there is a tactic which can help called <code>norm_cast</code> if you really want to mix your types like this</p>

<a name="191357583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191357583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191357583">Kevin Buzzard (Mar 21 2020 at 17:45)</a>:</h4>
<p>I would imagine that norm_cast will turn <code>\u(2*a)</code> into <code>2*\u a</code></p>

<a name="191358465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191358465" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191358465">Paul van Wamelen (Mar 21 2020 at 18:00)</a>:</h4>
<p>Ugh, I should have been able to do that myself. <code>norm_cast</code> works. Thanks!!<br>
Is there an <code>int</code> version of <code>gcd_eq_gcd_ab</code>? Well, even <code>gcd_eq_gcd_ab</code> is in an <code>int</code> file. Oh, the more general statement is probably an <code>euclidean_domain</code> thing. I'll find it.</p>

<a name="191359591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359591">Daniel Keys (Mar 21 2020 at 18:25)</a>:</h4>
<p>I have this in my context:</p>
<div class="codehilite"><pre><span></span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">h51</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">,</span>
<span class="n">h6b</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">≤</span> <span class="n">m</span> <span class="bp">-</span> <span class="mi">1</span>
<span class="err">⊢</span> <span class="n">false</span>
</pre></div>


<p>but am not able to satisfy the goal; <code>linarith</code>, <code>dec_trivial</code>, <code>norm_num</code> and everything else I tried all fail. I suppose this may be due to a type conversion problem, as <code>m-1</code> may be seen as an integer by Lean. Any hint on how to proceed appreciated!</p>

<a name="191359642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359642">Kevin Buzzard (Mar 21 2020 at 18:26)</a>:</h4>
<p>You can't solve that goal :-(</p>

<a name="191359647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359647">Kevin Buzzard (Mar 21 2020 at 18:26)</a>:</h4>
<p>If <code>m = 0</code> then all the hypotheses are true</p>

<a name="191359660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359660" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359660">Kevin Buzzard (Mar 21 2020 at 18:27)</a>:</h4>
<p><code>#eval (0 : ℕ) - 1 -- 0</code></p>

<a name="191359666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359666">Kevin Buzzard (Mar 21 2020 at 18:27)</a>:</h4>
<p>It's Patrick's favourite Lean fact.</p>

<a name="191359739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359739">Patrick Stevens (Mar 21 2020 at 18:29)</a>:</h4>
<p>There's a good reason every introductory text I've ever seen to Peano arithmetic defines <code>-</code> with a superscript dot, because it's very much not the same as <code>-</code> :P really it's the Billion Dollar Mistake again, we (= the world) shouldn't pun between N and Maybe N in this way</p>

<a name="191359750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359750">Kevin Buzzard (Mar 21 2020 at 18:29)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">print</span> <span class="n">has_sub</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">@[class]</span>
<span class="cm">structure has_sub : Type u → Type u</span>
<span class="cm">fields:</span>
<span class="cm">has_sub.sub : Π {α : Type u} [c : has_sub α], α → α → α</span>
<span class="cm">-/</span>
</pre></div>


<p>The subtraction typeclass in Lean is a notation typeclass, and subtraction itself has type <code>α → α → α</code> which means that whatever you're subtracting, the two inputs and the output <em>have</em> to have the same type. So there's no way around it, if you want subtraction on the naturals then it has to return a natural.</p>

<a name="191359810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359810">Kevin Buzzard (Mar 21 2020 at 18:30)</a>:</h4>
<p>I have pushed in the past for <code>0 - 1</code> to be <code>37</code> but the idea never gained any traction.</p>

<a name="191359829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359829">Daniel Keys (Mar 21 2020 at 18:31)</a>:</h4>
<p>But things would change if I switched to <code>int</code> instead, right?</p>

<a name="191359870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359870" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359870">Kevin Buzzard (Mar 21 2020 at 18:32)</a>:</h4>
<p>Indeed</p>

<a name="191359873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359873" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359873">Patrick Stevens (Mar 21 2020 at 18:32)</a>:</h4>
<p>The Real Problem (tm) is that <code>-</code> just doesn't (morally) have type N -&gt; N -&gt; N; is there a good reason why it has that type in Lean?</p>

<a name="191359875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359875">Kevin Buzzard (Mar 21 2020 at 18:32)</a>:</h4>
<p>I would not be arguing that the integer 0-1 should be 37</p>

<a name="191359885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359885">Kevin Buzzard (Mar 21 2020 at 18:32)</a>:</h4>
<p>The answer used to be "because it's in core and we can't change core"</p>

<a name="191359895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359895" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359895">Kevin Buzzard (Mar 21 2020 at 18:33)</a>:</h4>
<p>but even now it could be changed in theory, the CS people won't let you change it because they read the same books on Peano arithmetic that you did and they liked it</p>

<a name="191359962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359962">Patrick Stevens (Mar 21 2020 at 18:34)</a>:</h4>
<p>There are many places where I have strong opinions but recognise that reasonable people may reasonably differ; but this is not one of them</p>

<a name="191359964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359964">Kevin Buzzard (Mar 21 2020 at 18:34)</a>:</h4>
<p>A subtraction of the form <code>A -&gt; A -&gt; B</code> would probably cause a lot more problems than it solved.</p>

<a name="191359975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359975">Kevin Buzzard (Mar 21 2020 at 18:35)</a>:</h4>
<p>For example if you wanted to prove <code>a - b + b = a</code> then there are problems because suddenly <code>a -b</code> has type B (or int or whatever) so now when you add b (which has type nat) you will have to coerce, and now you end up with the integer a</p>

<a name="191359984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359984">Marc Huisinga (Mar 21 2020 at 18:35)</a>:</h4>
<p>i think that this is actually a pretty common theme in lean. requiring functions to be partial often results in needing lots of plumbing. instead we just define those functions to be some arbitrary value and demand some extra hypothesis in proofs to ensure that the case doesn't happen.</p>

<a name="191359985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359985" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359985">Daniel Keys (Mar 21 2020 at 18:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191359964" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191359964">said</a>:</p>
<blockquote>
<p>A subtraction of the form <code>A -&gt; A -&gt; B</code> would probably cause a lot more problems than it solved.</p>
</blockquote>
<p>OK that makes sense - thanks a lot!</p>

<a name="191359987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359987">Kevin Buzzard (Mar 21 2020 at 18:35)</a>:</h4>
<p>As a mathematician I want to believe that these coercions don't exist, but they are there and they cause problems for the CS people.</p>

<a name="191359989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191359989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191359989">Patrick Stevens (Mar 21 2020 at 18:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191359964" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191359964">said</a>:</p>
<blockquote>
<p>A subtraction of the form <code>A -&gt; A -&gt; B</code> would probably cause a lot more problems than it solved.</p>
</blockquote>
<p>To me, it's "completely obvious" that if you can prove a &lt; b, then you should be using something of type <code>(a b : N) -&gt; (a &lt;= b) -&gt; N</code>, and otherwise you should be using <code>(a b : N) -&gt; Maybe N</code></p>

<a name="191360040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191360040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191360040">Kevin Buzzard (Mar 21 2020 at 18:36)</a>:</h4>
<p>right -- that would be another approach, and when I started here I thought that this was manifestly the correct approach and all the CS people were crazy</p>

<a name="191360055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191360055" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191360055">Kevin Buzzard (Mar 21 2020 at 18:37)</a>:</h4>
<p>but then I tried it in practice. When I started here there was no <code>real.sqrt</code> and I was teaching it in my class so I defined it in Lean and I my definition took as input a real number r and a proof that it was &gt;= 0, and then it defined the square root to be some sup</p>

<a name="191360062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191360062" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191360062">Kevin Buzzard (Mar 21 2020 at 18:37)</a>:</h4>
<p>and then a passing computer scientist came along and said "ha ha look at the silly mathematician, he is asking for an input to his function and then he never uses the input!"</p>

<a name="191360072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191360072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191360072">Kevin Buzzard (Mar 21 2020 at 18:37)</a>:</h4>
<p>and indeed, you could just remove the hypothesis as an input and the definition compiled just fine</p>

<a name="191360114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191360114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191360114">Kevin Buzzard (Mar 21 2020 at 18:38)</a>:</h4>
<p>and when I started thinking about it that way, I started having doubts</p>

<a name="191360128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191360128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191360128">Patrick Stevens (Mar 21 2020 at 18:38)</a>:</h4>
<p>But that's why God gave us the notion of irrelevance :P for when you need to tell things to the compiler which it would be annoying to express in any other way</p>

<a name="191360134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191360134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191360134">Kevin Buzzard (Mar 21 2020 at 18:38)</a>:</h4>
<p>and then when I started formalising all my problem sheet questions, and every time I even wrote the square root I had to prove that something was non-negative, so I would constantly be proving that 2&gt;=0 when working with sqrt(2)</p>

<a name="191360162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191360162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191360162">Kevin Buzzard (Mar 21 2020 at 18:39)</a>:</h4>
<p>and in the end I got so sick of proving 2&gt;=0 (this was before the days of <code>norm_num</code> so it wasn't even that easy) that I gave up and I dropped the hypothesis in the definition of sqrt, and instead I just put the hypothesis in the theorem statements</p>

<a name="191360210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191360210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191360210">Kevin Buzzard (Mar 21 2020 at 18:40)</a>:</h4>
<p>because the square root of every negative integer was coming out to be 37 so I needed it in the theorem statements</p>

<a name="191360214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191360214" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191360214">Kevin Buzzard (Mar 21 2020 at 18:40)</a>:</h4>
<p>(well OK, it was coming out to be 0)</p>

<a name="191360220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191360220" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191360220">Kevin Buzzard (Mar 21 2020 at 18:40)</a>:</h4>
<p>but I was having to prove 2&gt;=0 an order of magnitude fewer times this way</p>

<a name="191360225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191360225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191360225">Patrick Stevens (Mar 21 2020 at 18:40)</a>:</h4>
<p>Fair enough, though I weep to hear that things might simply have to be this way</p>

<a name="191360227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191360227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191360227">Kevin Buzzard (Mar 21 2020 at 18:40)</a>:</h4>
<p>and then I just realised that I had defined a square root with a dot on it</p>

<a name="191360230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191360230" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191360230">Kevin Buzzard (Mar 21 2020 at 18:41)</a>:</h4>
<p>and somehow that made me feel a bit better</p>

<a name="191360246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191360246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191360246">Daniel Keys (Mar 21 2020 at 18:42)</a>:</h4>
<p>It is interesting to see how these very simple textbook problems (in this case, I was trying to prove a positive real number has a floor and a ceiling in the naturals) lead to such discussions and insight.</p>

<a name="191360342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191360342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191360342">Marc Huisinga (Mar 21 2020 at 18:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="117987">Patrick Stevens</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191360225" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191360225">said</a>:</p>
<blockquote>
<p>Fair enough, though I weep to hear that things might simply have to be this way</p>
</blockquote>
<p>it's a fun experiment to define something new and carry around some invariant together with data! i think that even something as simple as Maybe will quickly lead to headaches.<br>
that being said, there are cases where the invariant is carefully maintained by the library, and you won't have to deal with the pain if what you want is in the library.<br>
e.g. <a href="https://github.com/leanprover-community/mathlib/blob/master/src/data/finset.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/data/finset.lean">https://github.com/leanprover-community/mathlib/blob/master/src/data/finset.lean</a></p>

<a name="191361648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191361648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191361648">Johan Commelin (Mar 21 2020 at 19:16)</a>:</h4>
<p><span class="user-mention" data-user-id="117987">@Patrick Stevens</span> I know exactly how you feel. It's really quite crazy.</p>

<a name="191361684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191361684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191361684">Johan Commelin (Mar 21 2020 at 19:18)</a>:</h4>
<p>In the end it boils, I've come to realise that it boils down to a pragmatic usability argument.<br>
And like Kevin said. Just imagine that there is a little dot written above almost every function that you see...</p>

<a name="191361733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191361733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191361733">Johan Commelin (Mar 21 2020 at 19:18)</a>:</h4>
<p><code>/</code>, and <code>^-1</code> (inversion) and <code>sqrt</code> etc... they are all cheating on inputs where mathematicians would say they are undefined.</p>

<a name="191363334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191363334" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191363334">Patrick Stevens (Mar 21 2020 at 20:03)</a>:</h4>
<p>I don't reeeallly mind the cheating - I have aesthetic objections, but really the thing I actually care about is "will this lead me to make mistakes", and I'm liable to make lots of mistakes if the types don't constrain me :P</p>

<a name="191363534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191363534" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191363534">Daniel Keys (Mar 21 2020 at 20:08)</a>:</h4>
<p>Still having trouble even with <code>int</code>, shouldn't this goal follow from <code>h6</code> below?</p>
<div class="codehilite"><pre><span></span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span>
<span class="n">m</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span>
<span class="n">h6</span> <span class="o">:</span> <span class="err">↑</span><span class="o">(</span><span class="n">m</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">x</span>
<span class="err">⊢</span> <span class="err">↑</span><span class="n">m</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">x</span>
</pre></div>


<p>Where can a type mismatch arise from here? Trying <code>exact h6</code> I get:</p>
<div class="codehilite"><pre><span></span>invalid type ascription, term has type
  ↑(m - 1) ≤ x
but is expected to have type
  ↑m - 1 ≤ x
</pre></div>

<a name="191364539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191364539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191364539">Kevin Buzzard (Mar 21 2020 at 20:35)</a>:</h4>
<p>The problem is that it's not exactly h6 :-)</p>

<a name="191364590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191364590" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191364590">Kevin Buzzard (Mar 21 2020 at 20:36)</a>:</h4>
<p>The order of the subtraction and the coercion are different, right? The brackets are in different places</p>

<a name="191364604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191364604" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191364604">Kevin Buzzard (Mar 21 2020 at 20:37)</a>:</h4>
<p>Just do <code>convert h6</code>. That will probably change the goal to the assertion that the coercion commutes with subtraction</p>

<a name="191364608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191364608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191364608">Kevin Buzzard (Mar 21 2020 at 20:37)</a>:</h4>
<p>Then you can probably use <code>norm_cast</code> to finish the job</p>

<a name="191364656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191364656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191364656">Kevin Buzzard (Mar 21 2020 at 20:38)</a>:</h4>
<p>Or perhaps norm_cast will change either the goal into the hypothesis or vice versa</p>

<a name="191364692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191364692" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191364692">Daniel Keys (Mar 21 2020 at 20:39)</a>:</h4>
<p>It worked! I had tried some 20 other ways.</p>

<a name="191366283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191366283" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191366283">Johan Commelin (Mar 21 2020 at 21:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="117987">Patrick Stevens</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191363334" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191363334">said</a>:</p>
<blockquote>
<p>I don't reeeallly mind the cheating - I have aesthetic objections, but really the thing I actually care about is "will this lead me to make mistakes", and I'm liable to make lots of mistakes if the types don't constrain me :P</p>
</blockquote>
<p>Well, the first thing that you do after your definition, is prove a lemma that under the assumption that the input makes sense, the definition behaves the way it should. Once you've proven that lemma, you can't really make mistakes.</p>

<a name="191366341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191366341" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191366341">Patrick Massot (Mar 21 2020 at 21:22)</a>:</h4>
<p>Even before that you  cannot really make a mistake in a sense. As worse you can state and prove something which is not what you have in mind.</p>

<a name="191366360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191366360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191366360">Johan Commelin (Mar 21 2020 at 21:23)</a>:</h4>
<p>Well, that depends on what you mean with mistake...</p>

<a name="191366373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191366373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191366373">Johan Commelin (Mar 21 2020 at 21:23)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">fermat_last_thm</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">trivial</span>
</pre></div>


<p>is a mistake, in my book.</p>

<a name="191366436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191366436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191366436">Patrick Massot (Mar 21 2020 at 21:24)</a>:</h4>
<p>This is completely independent from our discussion</p>

<a name="191366457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191366457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191366457">Patrick Massot (Mar 21 2020 at 21:25)</a>:</h4>
<p>You can write:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span><span class="bp">/</span><span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span>
</pre></div>


<p>and call it a mistake or a misunderstanding of the statement, depending on your point of view.</p>

<a name="191367952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191367952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191367952">Kevin Buzzard (Mar 21 2020 at 22:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="mi">1</span> <span class="bp">/</span> <span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="mi">0</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>
</pre></div>


<p>This is an example which every mathematician would say was false, but there's a proof.</p>

<a name="191374044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191374044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191374044">Stephanie Zhou (Mar 22 2020 at 01:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191324041" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191324041">said</a>:</p>
<blockquote>
<p>I don't think <code>e</code> has been defined, but you can use <code>real.exp 1</code> if you import <code>data.complex.exponential</code></p>
</blockquote>
<p>I can't import either of those, as lean says "not found in the LEAN_PATH". Actually, I'm getting this issue for "import standard" and a lot of other common import statements. Would you know how to resolve this?</p>

<a name="191374142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191374142" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191374142">Mario Carneiro (Mar 22 2020 at 01:28)</a>:</h4>
<p><code>import standard</code> doesn't exist AFAIK, but if <code>import data.complex.exponential</code> doesn't work then you most likely don't have mathlib installed. Could someone with <code>leanproject</code> experience give setup advice here?</p>

<a name="191374152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191374152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191374152">Kenny Lau (Mar 22 2020 at 01:28)</a>:</h4>
<p><a href="#narrow/stream/113489-new-members/topic/Inequality.20World/near/190568509" title="#narrow/stream/113489-new-members/topic/Inequality.20World/near/190568509">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Inequality.20World/near/190568509</a></p>

<a name="191374216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191374216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191374216">Mario Carneiro (Mar 22 2020 at 01:30)</a>:</h4>
<p><span class="user-mention" data-user-id="117987">@Patrick Stevens</span> By the way, there is a function called <code>nat.psub : nat -&gt; nat -&gt; option nat</code> that actually returns <code>none</code> when it's not supposed to be defined. You have to write funny monadic code if you want to compose it with other operations though.</p>

<a name="191383881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191383881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191383881">Alex Mathers (Mar 22 2020 at 07:00)</a>:</h4>
<p>I'm looking at the files defining submonoids, and I'm trying to understand some Lean notation. I see the following</p>
<div class="codehilite"><pre><span></span><span class="n">instance</span> <span class="n">has_mul</span> <span class="p">:</span> <span class="n">has_mul</span> <span class="n">S</span> <span class="p">:</span><span class="o">=</span> <span class="err">⟨</span><span class="n">λ</span> <span class="n">a</span> <span class="n">b</span><span class="p">,</span> <span class="err">⟨</span><span class="n">a</span><span class="o">.</span><span class="mi">1</span> <span class="o">*</span> <span class="n">b</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">mul_mem</span> <span class="n">a</span><span class="o">.</span><span class="mi">2</span> <span class="n">b</span><span class="o">.</span><span class="mi">2</span><span class="err">⟩⟩</span>
</pre></div>


<p>and I'm trying to understand what the <code>a.1</code> and <code>a.2</code> mean. When I try to evaluate to see what these mean here is what I see:</p>
<div class="codehilite"><pre><span></span><span class="n">variables</span> <span class="p">(</span><span class="n">S</span> <span class="p">:</span> <span class="n">submonoid</span> <span class="n">M</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span> <span class="p">:</span> <span class="n">S</span><span class="p">)</span>
<span class="c1">#check a     --- a : ↥S</span>
<span class="c1">#check a.1     --- a.val : M</span>
<span class="c1">#check a.2     --- a.property : (λ (x : M), x ∈ has_coe_t_aux.coe (set M) S) (a.val)</span>
</pre></div>


<p>so I take it it has to do with the coercion from S to M. But what is really happening here?</p>

<a name="191383981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191383981" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191383981">Mario Carneiro (Mar 22 2020 at 07:03)</a>:</h4>
<p><code>a</code> has type <code>↥S</code>, which is actually <code>{x : M // x \in S}</code>. So <code>a</code> is a pair of an element of <code>M</code> and a proof that that element is in <code>S</code></p>

<a name="191384044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191384044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191384044">Mario Carneiro (Mar 22 2020 at 07:05)</a>:</h4>
<p>You can also write <code>\u a</code> instead of <code>a.1</code> to produce the element of <code>M</code></p>

<a name="191384048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191384048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191384048">Mario Carneiro (Mar 22 2020 at 07:05)</a>:</h4>
<p>or just <code>a</code>, since the coercion is implicitly inserted</p>

<a name="191384049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191384049" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191384049">Alex Mathers (Mar 22 2020 at 07:05)</a>:</h4>
<p>I see! Thanks.</p>

<a name="191384054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191384054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191384054">Mario Carneiro (Mar 22 2020 at 07:05)</a>:</h4>
<p>the idea with all the notations is to try to make this act as much like a subset as possible</p>

<a name="191417068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191417068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191417068">Daniel Keys (Mar 22 2020 at 21:28)</a>:</h4>
<p>Does anyone know a short way to obtain a contradiction here, or should I dig further into where uniqueness of the supremum, <code>lub</code>, resides?</p>
<div class="codehilite"><pre><span></span><span class="n">D</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">A</span> <span class="mi">3</span><span class="o">,</span>
<span class="n">E</span> <span class="o">:</span> <span class="n">is_lub</span> <span class="n">A</span> <span class="mi">0</span>
<span class="err">⊢</span> <span class="n">false</span>
</pre></div>

<a name="191417185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191417185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191417185">Daniel Keys (Mar 22 2020 at 21:30)</a>:</h4>
<p>Oh, I got it. It is in the same file, <code>bounds.lean</code>. Can easily use <code>eq_of_is_lub_of_is_lub</code>.</p>

<a name="191417189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191417189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191417189">Kevin Buzzard (Mar 22 2020 at 21:30)</a>:</h4>
<p>It looks to me like it would be worth proving the lemma that if A has two least upper bounds then they are equal, or (if your definition of <code>is_lub</code> is from the library and not home-rolled) using the result in mathlib (assuming it's there, which it surely will be). If you're using mathlib's <code>is_lub</code> (assuming it has one) then just take a look at the 100 lines of code after the definition.</p>

<a name="191417204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191417204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191417204">Kevin Buzzard (Mar 22 2020 at 21:31)</a>:</h4>
<p>The rule is: if it's a standard result about a definition in the library, then it's proved in the library, probably not too far after the definition.</p>

<a name="191513843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191513843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191513843">Stephanie Zhou (Mar 23 2020 at 18:07)</a>:</h4>
<p>Does lean support trig functions and power series?</p>

<a name="191514101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191514101" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191514101">Johan Commelin (Mar 23 2020 at 18:09)</a>:</h4>
<p>Trig functions: yes. Power series: to some extent.</p>

<a name="191514375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191514375" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191514375">Patrick Massot (Mar 23 2020 at 18:11)</a>:</h4>
<p>Note that the question is not quite right. Lean itself virtually supports any mathematics, and actually knows very little. Then formalizations written in Lean know some stuff. The big one is mathlib, which is meant to be the base for all other mathematics developments, and this is what Johan's answer refer to.</p>

<a name="191515078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191515078" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191515078">Stephanie Zhou (Mar 23 2020 at 18:16)</a>:</h4>
<p>What is the command for sin and cos?</p>

<a name="191515191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191515191" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191515191">Patrick Massot (Mar 23 2020 at 18:17)</a>:</h4>
<p>Do you have a working Lean project together with a compiled mathlib?</p>

<a name="191515310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191515310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191515310">Stephanie Zhou (Mar 23 2020 at 18:18)</a>:</h4>
<p>Yes</p>

<a name="191515472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191515472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191515472">Patrick Massot (Mar 23 2020 at 18:19)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">exponential</span>
<span class="kn">open</span> <span class="n">complex</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">sin</span>
</pre></div>

<a name="191519054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191519054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191519054">Reed Mullanix (Mar 23 2020 at 18:47)</a>:</h4>
<p>Hey all, stupid question: Does lean have some analog to agda's interactive holes?</p>

<a name="191519595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191519595" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191519595">Alex J. Best (Mar 23 2020 at 18:51)</a>:</h4>
<p>I don't  know agda, but from a quick google, it sounds like <code>_</code> is the replacement of agda's <code>?</code>, in that you can write terms with <code>_</code> to see what the type of <code>_</code> should be and then fill it in.</p>

<a name="191519647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191519647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191519647">Bryan Gin-ge Chen (Mar 23 2020 at 18:51)</a>:</h4>
<p>Lean does support <a href="https://leanprover-community.github.io/mathlib_docs/hole_commands.html" target="_blank" title="https://leanprover-community.github.io/mathlib_docs/hole_commands.html">"hole commands"</a> but they're not as easy to use as Agda's. I don't think we have anything like Agda's Auto, for instance. (**Edit: on second thought <code>library_search</code> is kind of like Auto.)</p>

<a name="191519738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191519738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191519738">Reed Mullanix (Mar 23 2020 at 18:52)</a>:</h4>
<p>Hmm, I tried that, and it looks like the typechecker got stuck</p>
<div class="codehilite"><pre><span></span> types.lean    42  95 error           type mismatch, term
   congr_fun ?m_5 ?m_6
 has type
   ?m_3 ?m_2 = ?m_4 ?m_2
 but is expected to have type
   σ.app Y (F.map f x) = G.map f (σ.app X x) (lean-checker)
</pre></div>

<a name="191519810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191519810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191519810">Alex J. Best (Mar 23 2020 at 18:52)</a>:</h4>
<p>What were you trying to do?</p>

<a name="191520076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191520076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191520076">Reed Mullanix (Mar 23 2020 at 18:54)</a>:</h4>
<p>I'm just messing around with some existing proofs to try to get a better feel on how to use the system :)</p>
<p>For context, the proof in question is</p>
<div class="codehilite"><pre><span></span>lemma naturality (f : X ⟶ Y) (x : F.obj X) : σ.app Y ((F.map f) x) = (G.map f) (σ.app X x) := congr_fun _ _
</pre></div>


<p>From mathlib's <code>category_theory/types.lean</code></p>

<a name="191520765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191520765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191520765">Alex J. Best (Mar 23 2020 at 18:59)</a>:</h4>
<p>I guess there are too many implicit things in that example, if you just write<br>
<code>lemma naturality (f : X ⟶ Y) (x : F.obj X) : σ.app Y ((F.map f) x) = (G.map f) (σ.app X x) := congr_fun _ x</code><br>
you get to see what the type of <code>_</code> should be</p>

<a name="191520979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191520979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191520979">Reed Mullanix (Mar 23 2020 at 19:01)</a>:</h4>
<p>Yeah, it barfs about not being able to synthesize a placeholder context, which isn't _super_ suprising, it's a pretty gnarly unification problem</p>

<a name="191530729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191530729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191530729">Kevin Buzzard (Mar 23 2020 at 20:19)</a>:</h4>
<p>If you write @f instead of f you can fill in some of the unification holes yourself</p>

<a name="191548005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191548005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191548005">Reed Mullanix (Mar 23 2020 at 22:53)</a>:</h4>
<p>More silly questions: I'm trying to use the rewrite tactic, and it's complaining that it can't find an instance of the pattern, even though there obviously is one:</p>
<div class="codehilite"><pre><span></span> braided.lean    45   3 error           rewrite tactic failed, did not find instance of the pattern in the target expression
   (λ_ (X ⊗ 𝟙_ C)).hom ≫ (braid X (𝟙_ C)).hom
 state:
 C : Type u,
 _inst_1 : category C,
 _inst_2 : monoidal_category C,
 𝒞 : braided_category C,
 X : C
 ⊢ (((braid X (𝟙_ C)).hom ⊗ 𝟙 (𝟙_ C)) ≫ (α_ (𝟙_ C) X (𝟙_ C)).hom ≫ (λ_ (X ⊗ 𝟙_ C)).hom) ≫
       (braid X (𝟙_ C)).hom =
     ((ρ_ X).hom ⊗ 𝟙 (𝟙_ C)) ≫ (braid X (𝟙_ C)).hom (lean-checker)
</pre></div>

<a name="191548174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191548174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191548174">Alex J. Best (Mar 23 2020 at 22:54)</a>:</h4>
<p>Can you post full code? A minimal working example</p>

<a name="191548245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191548245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191548245">Reed Mullanix (Mar 23 2020 at 22:55)</a>:</h4>
<p>Of course! This is what I've got so far:</p>
<div class="codehilite"><pre><span></span>import category_theory.monoidal.category
import category_theory.natural_isomorphism

open category_theory

universes v u

namespace category_theory


class braided_category (C : Type u) [category.{v} C] [𝒞 : monoidal_category.{v} C] :=
(braid : Π X Y : C, (X ⊗ Y) ≅ (Y ⊗ X))
(braid_naturality&#39; :
  ∀ {X₁ X₂ Y₁ Y₂} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂),
  (f₁ ⊗ f₂) ≫ (braid Y₁ Y₂).hom = (braid X₁ X₂).hom ≫ (f₂ ⊗ f₁) . obviously)
-- first hexagon identity:
(hexagon&#39; : ∀ X Y Z : C,
  (α_ X Y Z).hom ≫ (braid X (Y ⊗ Z)).hom ≫ (α_ Y Z X).hom
  = ((braid X Y).hom ⊗ (𝟙 Z)) ≫ (α_ Y X Z).hom ≫ ((𝟙 Y) ⊗ (braid X Z).hom) . obviously)
-- second hexagon identity:
(hexagon_inv&#39; : ∀ X Y Z : C,
  (α_ X Y Z).inv ≫ (braid (X ⊗ Y) Z).hom ≫ (α_ Z X Y).inv
  = ((𝟙 X) ⊗ (braid Y Z).hom) ≫ (α_ X Z Y).inv ≫ ((braid X Z).hom ⊗ (𝟙 Y)) . obviously)

restate_axiom braided_category.braid_naturality&#39;
restate_axiom braided_category.hexagon&#39;
restate_axiom braided_category.hexagon_inv&#39;

open monoidal_category
open braided_category

namespace braided_category

variables {C : Type u} [category.{v} C] [monoidal_category.{v} C] [𝒞 : braided_category.{v} C]
include 𝒞

section

lemma braid_coherence {X : C} :
  ((braid X (𝟙_ C)).hom ⊗ 𝟙 (𝟙_ C)) ≫ ((left_unitor X).hom ⊗ 𝟙 (𝟙_ C)) = ((right_unitor X).hom ⊗ 𝟙 (𝟙_ C)) :=
begin
  apply (cancel_mono (braid X (𝟙_ C)).hom).1,
  rw [←left_unitor_tensor, ←left_unitor_naturality C (braid X (𝟙_ C)).hom],
  sorry
end

end

end braided_category

end category_theory
</pre></div>

<a name="191548519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191548519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191548519">Reed Mullanix (Mar 23 2020 at 22:58)</a>:</h4>
<p>I suspect that it may have something to do with associativity actually, missed a pair of parens <span aria-label="face palm" class="emoji emoji-1f926" role="img" title="face palm">:face_palm:</span></p>

<a name="191548779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191548779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191548779">Alex J. Best (Mar 23 2020 at 23:00)</a>:</h4>
<p>Ah okay, does that fix it then?</p>

<a name="191548853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191548853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191548853">Alex J. Best (Mar 23 2020 at 23:01)</a>:</h4>
<p>In general if rw is having trouble you can use <code>simp only [your_eq]</code> or use <code>conv</code> to isolate the part you want to rewrite.</p>

<a name="191548928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191548928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191548928">Reed Mullanix (Mar 23 2020 at 23:02)</a>:</h4>
<p>Mucking about to figure out how to get <code>assoc</code> into scope, but I suspect that will do it. Thanks for the help <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p>

<a name="191550020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191550020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191550020">Kevin Buzzard (Mar 23 2020 at 23:14)</a>:</h4>
<p><code>\gg</code> is right associative:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">category_theory</span><span class="bp">.</span><span class="n">functor</span>

<span class="bp">#</span><span class="kn">print</span> <span class="kn">notation</span> <span class="err">≫</span>
<span class="c1">-- _ `≫`:80 _:79 := category_theory.category_struct.comp #1 #0</span>
</pre></div>


<p>80&gt;79</p>

<a name="191550069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191550069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191550069">Kevin Buzzard (Mar 23 2020 at 23:15)</a>:</h4>
<p><span class="user-mention" data-user-id="266262">@Reed Mullanix</span> if you post code with <code> ```lean </code> at the top then you get syntax highlighting.</p>

<a name="191692541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191692541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191692541">Alex Mathers (Mar 25 2020 at 01:14)</a>:</h4>
<p>How are powers of elements (say elements in a monoid or group) defined in Lean? In this file  (<a href="https://github.com/leanprover-community/mathlib/blob/master/src/group_theory/submonoid.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/group_theory/submonoid.lean">https://github.com/leanprover-community/mathlib/blob/master/src/group_theory/submonoid.lean</a>) where submonoids are defined, they use expressions like x^n but searching around I don't see where this notation is first implemented. When I try to type it into Lean myself it looks like it's notation for <code>has_pow M ℕ</code>, so were monoids at some point endowed with this <code>has_pow</code> attribute and I just don't see where?</p>

<a name="191692672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191692672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191692672">Shing Tak Lam (Mar 25 2020 at 01:17)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/24b82c91583843597e8cfeb7928d446dec776456/src/algebra/group_power.lean#L20" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/24b82c91583843597e8cfeb7928d446dec776456/src/algebra/group_power.lean#L20">https://github.com/leanprover-community/mathlib/blob/24b82c91583843597e8cfeb7928d446dec776456/src/algebra/group_power.lean#L20</a></p>
<p>(the docs link below is probably better)</p>

<a name="191692716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191692716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191692716">Alex J. Best (Mar 25 2020 at 01:18)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/algebra/group_power.html#monoid.has_pow" target="_blank" title="https://leanprover-community.github.io/mathlib_docs/algebra/group_power.html#monoid.has_pow">https://leanprover-community.github.io/mathlib_docs/algebra/group_power.html#monoid.has_pow</a></p>

<a name="191692732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191692732" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191692732">Alex J. Best (Mar 25 2020 at 01:18)</a>:</h4>
<p>Too quick for me ;)</p>

<a name="191692771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191692771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191692771">Shing Tak Lam (Mar 25 2020 at 01:19)</a>:</h4>
<p>I just <code>Ctrl-P</code> <code>monoid.pow</code> and I had <code>mathlib</code> open on GitHub already :) The docs link is probably the better one though.</p>

<a name="191692854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191692854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191692854">Alex Mathers (Mar 25 2020 at 01:21)</a>:</h4>
<p>Not sure how I missed that there's an entire file titled group_power! Thanks</p>

<a name="191692860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191692860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191692860">Shing Tak Lam (Mar 25 2020 at 01:21)</a>:</h4>
<p>Are you on VSCode?</p>

<a name="191692913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191692913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191692913">Alex J. Best (Mar 25 2020 at 01:22)</a>:</h4>
<p>Yeah I just run a search in vscode for <code>instance.*monoid.*has_pow</code></p>

<a name="191693437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191693437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191693437">Alex Mathers (Mar 25 2020 at 01:32)</a>:</h4>
<p>I am on VSCode, I had no idea I could do that</p>

<a name="191693533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191693533" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191693533">Shing Tak Lam (Mar 25 2020 at 01:34)</a>:</h4>
<p>Or you can just press <code>Ctrl-P</code> then type in <code>#</code> in the search bar. It searches for whatever comes after the <code>#</code> in mathlib. So I just searched for <code>monoid.pow</code>. You could have also (probably a better idea) searched for <code>monoid.has_pow</code>.</p>

<a name="191693653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191693653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191693653">Alex Mathers (Mar 25 2020 at 01:37)</a>:</h4>
<p>This is definitely good information I was lacking. Thank you both!</p>

<a name="191702054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191702054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191702054">Miguel Raz Guzmán Macedo (Mar 25 2020 at 05:11)</a>:</h4>
<p>Hey all, I screwed up the basic install on fedora and lean in VSCODE says <code>file topology/basic not found in teh LEAN_PATH</code></p>

<a name="191702055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191702055" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191702055">Miguel Raz Guzmán Macedo (Mar 25 2020 at 05:11)</a>:</h4>
<p>Any help?</p>

<a name="191702180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191702180" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191702180">Yury G. Kudryashov (Mar 25 2020 at 05:14)</a>:</h4>
<p>Which instructions did you follow? Are you editing a file in <code>mathlib</code>, or using it as a dependency?</p>

<a name="191702787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191702787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191702787">Miguel Raz Guzmán Macedo (Mar 25 2020 at 05:34)</a>:</h4>
<p><span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> I tried the <code>pip3 install mathlibtools</code> for installing the <code>leanproject</code>, but it didn't seem to install.<br>
I can use <code>lean</code> and <code>leanpkg</code> just fine, they've been updated to 3.7 no problem.</p>

<a name="191706395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191706395" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191706395">Bryan Gin-ge Chen (Mar 25 2020 at 07:09)</a>:</h4>
<p>Not sure if this is the problem, since you haven't answered Yury's second question, but note that you should not open a single Lean file in VS Code, you need to open a directory containing a Lean project. Check the instructions <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/install/project.md" title="https://github.com/leanprover-community/mathlib/blob/master/docs/install/project.md">here</a> if you haven't already.</p>

<a name="191773348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191773348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191773348">Patrick Massot (Mar 25 2020 at 16:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243947">Miguel Raz Guzmán Macedo</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191702787" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191702787">said</a>:</p>
<blockquote>
<p>I tried the <code>pip3 install mathlibtools</code> for installing the <code>leanproject</code>, but it didn't seem to install.</p>
</blockquote>
<p>There is no way anyone could help you based on such vague information.</p>

<a name="191774442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191774442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191774442">Johan Commelin (Mar 25 2020 at 16:32)</a>:</h4>
<p><span class="user-mention" data-user-id="243947">@Miguel Raz Guzmán Macedo</span> As user or as root? Maybe prepend <code>sudo</code> or use <code>pip3 install --user</code>.</p>

<a name="191775988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191775988" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191775988">Patrick Massot (Mar 25 2020 at 16:43)</a>:</h4>
<p>Johan, you are trying to guess too much. Maybe install worked but leanproject is not in the PATH. We can't know without further information;</p>

<a name="191784998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191784998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191784998">Miguel Raz Guzmán Macedo (Mar 25 2020 at 17:43)</a>:</h4>
<p>Thanks for the replies !<br>
<span class="user-mention" data-user-id="112680">@Johan Commelin</span> I tried both already. I found <code>leanproject.py</code> in my <code>/usr/local/lib/python3.7/site-packages-mathlibtools/leanproject.py</code>, but the Installation instructions didn't say anything about adding that manually to the path, so lemme try that.</p>

<a name="191785294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191785294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191785294">Patrick Massot (Mar 25 2020 at 17:44)</a>:</h4>
<p>You should not add that to your path</p>

<a name="191785382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191785382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191785382">Kevin Buzzard (Mar 25 2020 at 17:45)</a>:</h4>
<p>We are still keen to see the error message.</p>

<a name="191785566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191785566" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191785566">Kevin Buzzard (Mar 25 2020 at 17:46)</a>:</h4>
<p>and your answer to Yury's second question.</p>

<a name="191785919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191785919" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191785919">Miguel Raz Guzmán Macedo (Mar 25 2020 at 17:48)</a>:</h4>
<p>I am not trying to edit a file in mathlib, I am just trying to run the tutorial <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/install/project.md" title="https://github.com/leanprover-community/mathlib/blob/master/docs/install/project.md">here</a> (the <code>topological_space</code> check)</p>

<a name="191785973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191785973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191785973">Miguel Raz Guzmán Macedo (Mar 25 2020 at 17:49)</a>:</h4>
<p>Thank you all for your time and patience by the way, it means a lot to help on-ramping beginners <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>

<a name="191786007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191786007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191786007">Patrick Massot (Mar 25 2020 at 17:49)</a>:</h4>
<p>How did you create a project?</p>

<a name="191786056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191786056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191786056">Miguel Raz Guzmán Macedo (Mar 25 2020 at 17:49)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> if I run <code>sudo pip3 install mathlibtools</code>, it says all of the requirements for all the packages are satisfied.</p>

<a name="191786160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191786160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191786160">Miguel Raz Guzmán Macedo (Mar 25 2020 at 17:50)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> I had used <code>leanpkg</code> instead of <code>leanproject</code>, I am trying to use <code>leanproject</code> now.</p>

<a name="191786216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191786216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191786216">Patrick Massot (Mar 25 2020 at 17:51)</a>:</h4>
<p>Can you run leanproject now? (without adding weird things to your path)</p>

<a name="191786234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191786234" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191786234">Mario Carneiro (Mar 25 2020 at 17:51)</a>:</h4>
<p>Hey, now that we have control over lean, we should REALLY remove that misleading error message that says "add this to your LEAN_PATH"</p>

<a name="191786409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191786409" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191786409">Miguel Raz Guzmán Macedo (Mar 25 2020 at 17:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191786216" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191786216">said</a>:</p>
<blockquote>
<p>Can you run leanproject now? (without adding weird things to your path)</p>
</blockquote>
<p>No, in a new terminal <code>leanproject</code> does  says<br>
<code>fish: leanproject command not found</code></p>

<a name="191786662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191786662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191786662">Miguel Raz Guzmán Macedo (Mar 25 2020 at 17:54)</a>:</h4>
<p>I am guessing <code>leanproject</code> should have been installed when I did <code>sudo pip3 install mathlibtools</code>?</p>

<a name="191786909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191786909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191786909">Patrick Massot (Mar 25 2020 at 17:56)</a>:</h4>
<p>Yes, it should be in <code>/usr/local/bin/leanproject</code> (at least assuming a Debian-like OS)</p>

<a name="191787213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191787213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191787213">Miguel Raz Guzmán Macedo (Mar 25 2020 at 17:58)</a>:</h4>
<p>Sorry, there's no <code>leanproject</code> there :(</p>

<a name="191787572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191787572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191787572">Miguel Raz Guzmán Macedo (Mar 25 2020 at 18:00)</a>:</h4>
<p>If I try to do <code>pip3 install --user mathlibtools</code> I get this error at the end - </p>
<div class="codehilite"><pre><span></span>PermissionError: [Errno 13] Permission denied: &#39;/usr/local/lib64/python3.7/site-packages/wrapt-1.12.1-py3.7.egg-info&#39;
</pre></div>

<a name="191787607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191787607" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191787607">Miguel Raz Guzmán Macedo (Mar 25 2020 at 18:01)</a>:</h4>
<p>And it is entirely possible I may have bungled up my entire environment, so suggestions are welcome.</p>

<a name="191787679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191787679" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191787679">Patrick Massot (Mar 25 2020 at 18:01)</a>:</h4>
<p>It very much looks like your python environment is destroyed. What is your OS/distrib?</p>

<a name="191787702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191787702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191787702">Miguel Raz Guzmán Macedo (Mar 25 2020 at 18:01)</a>:</h4>
<p>fedora latest.</p>

<a name="191788321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191788321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191788321">Miguel Raz Guzmán Macedo (Mar 25 2020 at 18:06)</a>:</h4>
<p>I tried to <code>chmod -R au+x ..../site-packages/</code> and now I get <br>
<code>Permission denied: '/usr/local/lib/python3.7/site-packages/tqdm-4.43.0.dist-info'</code></p>

<a name="191788793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191788793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191788793">Patrick Massot (Mar 25 2020 at 18:10)</a>:</h4>
<p>You shouldn't randomly change permissions in /usr/local</p>

<a name="191788844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191788844" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191788844">Miguel Raz Guzmán Macedo (Mar 25 2020 at 18:10)</a>:</h4>
<p>Oh.</p>

<a name="191788900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191788900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191788900">Miguel Raz Guzmán Macedo (Mar 25 2020 at 18:11)</a>:</h4>
<p>:S</p>

<a name="191789423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191789423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191789423">Miguel Raz Guzmán Macedo (Mar 25 2020 at 18:15)</a>:</h4>
<p>Well now <code>pip3 install --user mathlibtools</code> works, and all requirements are already satisfied :D</p>

<a name="191792766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191792766" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191792766">Miguel Raz Guzmán Macedo (Mar 25 2020 at 18:41)</a>:</h4>
<p>Aha, it seems I needed to add <code>~/.local/bin</code> to path, uninstalling and installing seems to have suggested that and <code>leanproject new leanjl</code> now works. Thank you all for the help on that.</p>

<a name="191793471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191793471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191793471">Miguel Raz Guzmán Macedo (Mar 25 2020 at 18:44)</a>:</h4>
<p>Well, <code>import topology.basic</code> still says <code>file 'init' not found in the LEAN_PATH</code></p>

<a name="191793553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191793553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191793553">Miguel Raz Guzmán Macedo (Mar 25 2020 at 18:45)</a>:</h4>
<div class="codehilite"><pre><span></span>test.lean:1:0: error
file &#39;init&#39; not found in the LEAN_PATH
test.lean:1:0: error
invalid import: init
could not resolve import: init
test.lean:1:0: error
invalid import: topology.basic
/home/mrg/deps/lean/mathlib/src/topology/basic.lean:48:25: error: unexpected token
</pre></div>

<a name="191794872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191794872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191794872">Kevin Buzzard (Mar 25 2020 at 18:54)</a>:</h4>
<p>So now you need to answer the question about whether you opened the project directory with the Open Folder command, or just a random file.</p>

<a name="191794896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191794896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191794896">Miguel Raz Guzmán Macedo (Mar 25 2020 at 18:55)</a>:</h4>
<p>Ah, sorry.</p>

<a name="191795053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191795053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191795053">Kevin Buzzard (Mar 25 2020 at 18:56)</a>:</h4>
<p>You need to open the root directory of the project in VS code. You're nearly there</p>

<a name="191795070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191795070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191795070">Miguel Raz Guzmán Macedo (Mar 25 2020 at 18:56)</a>:</h4>
<p>I did <code>leanproject new leanjl</code> to start a new project, opened it with VSCode via <code>code leanjl</code>, and added a file in <code>src</code></p>

<a name="191795106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191795106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191795106">Miguel Raz Guzmán Macedo (Mar 25 2020 at 18:56)</a>:</h4>
<p>just called <code>test.lean</code>.</p>

<a name="191795490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191795490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191795490">Miguel Raz Guzmán Macedo (Mar 25 2020 at 18:59)</a>:</h4>
<p>and that's where I put the </p>
<div class="codehilite"><pre><span></span>import topology.basic

#check topological_space
</pre></div>

<a name="191799001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191799001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191799001">Kevin Buzzard (Mar 25 2020 at 19:26)</a>:</h4>
<p>I can't reproduce. I just did exactly that and I get <code>topological_space : Type u_1 → Type u_1</code></p>

<a name="191799152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191799152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191799152">Kevin Buzzard (Mar 25 2020 at 19:27)</a>:</h4>
<p><a href="/user_uploads/3121/reAhsdi37YhVW7F0oHQKDoek/leanjl.png" title="leanjl.png">leanjl.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/reAhsdi37YhVW7F0oHQKDoek/leanjl.png" title="leanjl.png"><img src="/user_uploads/3121/reAhsdi37YhVW7F0oHQKDoek/leanjl.png"></a></div>

<a name="191799478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191799478" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191799478">Kevin Buzzard (Mar 25 2020 at 19:29)</a>:</h4>
<p>VS Code <code>View</code> -&gt; <code>Terminal</code> followed by  <code>lean --version</code> gives me <code>Lean (version 3.7.2, commit 44fb9f994d0f, Release)</code> . My leanpkg.path is</p>
<div class="codehilite"><pre><span></span>builtin_path
path _target/deps/mathlib/src
path ./src
</pre></div>


<p>and my leanpkg.toml is</p>
<div class="codehilite"><pre><span></span>[package]
name = &quot;leanjl&quot;
version = &quot;0.1&quot;
lean_version = &quot;leanprover-community/lean:3.7.2&quot;
path = &quot;src&quot;

[dependencies]
mathlib = {git = &quot;https://github.com/leanprover-community/mathlib&quot;, rev = &quot;24b82c91583843597e8cfeb7928d446dec776456&quot;}
</pre></div>

<a name="191800737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191800737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191800737">Miguel Raz Guzmán Macedo (Mar 25 2020 at 19:39)</a>:</h4>
<p>Thanks a lot for the follow - through <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> .<br>
I get the exact same configs down to the hashes for lean 3.7.2 and mathlib and both files are identical.</p>

<a name="191801324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191801324" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191801324">Kevin Buzzard (Mar 25 2020 at 19:43)</a>:</h4>
<p>cool</p>

<a name="191801385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191801385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191801385">Kevin Buzzard (Mar 25 2020 at 19:44)</a>:</h4>
<p>you beat the system</p>

<a name="191801536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191801536" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191801536">Miguel Raz Guzmán Macedo (Mar 25 2020 at 19:45)</a>:</h4>
<p>If I had a penny...</p>

<a name="191801940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191801940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191801940">Kevin Buzzard (Mar 25 2020 at 19:48)</a>:</h4>
<p>Are you absolutely sure that your VS Code looks exactly the same as my screenshot?</p>

<a name="191801956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191801956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191801956">Miguel Raz Guzmán Macedo (Mar 25 2020 at 19:48)</a>:</h4>
<p>VSCode is maybe picking up a previous install of lean:<br>
I get this error there as well:</p>
<div class="codehilite"><pre><span></span>invalid import: topology.basic
/home/mrg/deps/lean/mathlib/src/topology/basic.lean:48:25: error: unexpected token
</pre></div>

<a name="191802041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802041">Kevin Buzzard (Mar 25 2020 at 19:49)</a>:</h4>
<p>That is definitely not the mathlib you are looking for</p>

<a name="191802137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802137">Miguel Raz Guzmán Macedo (Mar 25 2020 at 19:50)</a>:</h4>
<p>imma nuke it brb.</p>

<a name="191802189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802189">Kevin Buzzard (Mar 25 2020 at 19:50)</a>:</h4>
<p>the mathlib you're supposed to be using is in <code>_target</code> in your project folder</p>

<a name="191802265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802265">Kevin Buzzard (Mar 25 2020 at 19:51)</a>:</h4>
<p>If you had posted that error much earlier then life would have been a bit easier. Can you post all the details of every error which you are currently experiencing?</p>

<a name="191802300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802300" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802300">Kevin Buzzard (Mar 25 2020 at 19:51)</a>:</h4>
<p>Exit VS Code and start it again and post all errors which occur anywhere.</p>

<a name="191802377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802377" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802377">Miguel Raz Guzmán Macedo (Mar 25 2020 at 19:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243947">Miguel Raz Guzmán Macedo</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191793553" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191793553">said</a>:</p>
<blockquote>
<div class="codehilite"><pre><span></span>test.lean:1:0: error
file &#39;init&#39; not found in the LEAN_PATH
test.lean:1:0: error
invalid import: init
could not resolve import: init
test.lean:1:0: error
invalid import: topology.basic
/home/mrg/deps/lean/mathlib/src/topology/basic.lean:48:25: error: unexpected token
</pre></div>


</blockquote>
<p>I did post it earler - I should have read more closely.</p>

<a name="191802396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802396">Kevin Buzzard (Mar 25 2020 at 19:52)</a>:</h4>
<p>Where are you seeing this error?</p>

<a name="191802437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802437">Kevin Buzzard (Mar 25 2020 at 19:53)</a>:</h4>
<p>Do you have a LEAN_PATH variable set? If so, nuke it.</p>

<a name="191802537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802537">Kevin Buzzard (Mar 25 2020 at 19:53)</a>:</h4>
<p><code>unset LEAN_PATH</code></p>

<a name="191802600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802600">Kevin Buzzard (Mar 25 2020 at 19:54)</a>:</h4>
<p>then restart VS Code and see if the error has changed</p>

<a name="191802643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802643" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802643">Kevin Buzzard (Mar 25 2020 at 19:54)</a>:</h4>
<p>(from the same terminal where you nuked LEAN_PATH)</p>

<a name="191802712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802712">Miguel Raz Guzmán Macedo (Mar 25 2020 at 19:55)</a>:</h4>
<p>DING DING DING</p>

<a name="191802751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802751" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802751">Miguel Raz Guzmán Macedo (Mar 25 2020 at 19:55)</a>:</h4>
<p>I had monkey-patched an earlier version of LEAN_PATH in my configs and it was polluting the env.</p>

<a name="191802790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802790">Miguel Raz Guzmán Macedo (Mar 25 2020 at 19:55)</a>:</h4>
<p>I now get a very happy <code>topological_space : Type u_1 → Type u_1</code></p>

<a name="191802853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802853">Kevin Buzzard (Mar 25 2020 at 19:56)</a>:</h4>
<p>That's great to know. That one was a real toughie. LEAN_PATH was something which you had to worry about in 2018.</p>

<a name="191802908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802908" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802908">Miguel Raz Guzmán Macedo (Mar 25 2020 at 19:56)</a>:</h4>
<p>Huh, yeah, I think that was my first install attempt or so.</p>

<a name="191802963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802963">Kevin Buzzard (Mar 25 2020 at 19:57)</a>:</h4>
<p>So it will be rare that users run into this problem but perhaps not impossible. Assuming you rebooted your computer in the past few years you might want to try and figure out what is setting LEAN_PATH.</p>

<a name="191802998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191802998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191802998">Kevin Buzzard (Mar 25 2020 at 19:57)</a>:</h4>
<p>(unless you were setting it yourself)</p>

<a name="191803031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191803031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191803031">Miguel Raz Guzmán Macedo (Mar 25 2020 at 19:57)</a>:</h4>
<p>Thank you all a lot <span class="user-mention" data-user-id="112680">@Johan Commelin</span> <span class="user-mention" data-user-id="110031">@Patrick Massot</span> and <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> , that was very attentive of all of you.</p>

<a name="191803079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191803079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191803079">Kevin Buzzard (Mar 25 2020 at 19:57)</a>:</h4>
<p>The perfectoid project team -- installing mathlib on a computer near you.</p>

<a name="191803087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191803087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191803087">Miguel Raz Guzmán Macedo (Mar 25 2020 at 19:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191802963" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191802963">said</a>:</p>
<blockquote>
<p>So it will be rare that users run into this problem but perhaps not impossible. Assuming you rebooted your computer in the past few years you might want to try and figure out what is setting LEAN_PATH.</p>
</blockquote>
<p>Nope, all me and my footguns.</p>

<a name="191803319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191803319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191803319">Kevin Buzzard (Mar 25 2020 at 19:59)</a>:</h4>
<p>Wherever did you read about LEAN_PATH? We should nuke the reference</p>

<a name="191803491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191803491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191803491">Kevin Buzzard (Mar 25 2020 at 20:00)</a>:</h4>
<p>By the way I think you just accidentally created a new stream. Usually we talk in threads in the streams we already have.</p>

<a name="191808931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191808931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191808931">Bryan Gin-ge Chen (Mar 25 2020 at 20:48)</a>:</h4>
<blockquote>
<p>Wherever did you read about LEAN_PATH? </p>
</blockquote>
<p>Whenever Lean is unable to find an imported file, it says "error: file 'does/not/exist' not found in the LEAN_PATH". People might read this and think they need to set LEAN_PATH, when that's rarely the right thing to do.</p>

<a name="191809021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191809021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191809021">Bryan Gin-ge Chen (Mar 25 2020 at 20:49)</a>:</h4>
<p>It wouldn't be hard to change the message. Any suggestions?</p>

<a name="191809712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191809712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191809712">Kevin Buzzard (Mar 25 2020 at 20:55)</a>:</h4>
<p>"error: file 'does/not/exist' not found" would already be strictly better, given what we just went through.</p>

<a name="191809805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191809805" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191809805">Kevin Buzzard (Mar 25 2020 at 20:56)</a>:</h4>
<p>The moment you mention <code>leanpkg.path</code> we'll have people changing that.</p>

<a name="191809829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191809829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191809829">Kevin Buzzard (Mar 25 2020 at 20:56)</a>:</h4>
<p>which is also rarely the right thing to do.</p>

<a name="191809846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191809846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191809846">Mario Carneiro (Mar 25 2020 at 20:56)</a>:</h4>
<p>How about "lean file does.not.exist not found. We searched: &lt;print result of lean --path&gt;"</p>

<a name="191809894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191809894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191809894">Kevin Buzzard (Mar 25 2020 at 20:57)</a>:</h4>
<p>Now that might even be a helpful message!</p>

<a name="191809972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191809972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191809972">Kevin Buzzard (Mar 25 2020 at 20:57)</a>:</h4>
<p>Actually on looking at the output</p>
<div class="codehilite"><pre><span></span>{
  &quot;is_user_leanpkg_path&quot;: true,
  &quot;leanpkg_path_file&quot;: &quot;/home/buzzard/.lean/leanpkg.path&quot;,
  &quot;path&quot;: [
    &quot;/home/buzzard/.elan/toolchains/stable/bin/../library&quot;,
    &quot;/home/buzzard/.elan/toolchains/stable/bin/../lib/lean/library&quot;
  ]
}
</pre></div>


<p>I am suddenly less sure.</p>

<a name="191810063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191810063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191810063">Mario Carneiro (Mar 25 2020 at 20:58)</a>:</h4>
<p>Well, <code>lean --path</code> is json formatted for no good reason</p>

<a name="191810097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191810097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191810097">Mario Carneiro (Mar 25 2020 at 20:58)</a>:</h4>
<p>we can print the same info in a more human readable way</p>

<a name="191810295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191810295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191810295">Mario Carneiro (Mar 25 2020 at 21:00)</a>:</h4>
<p>It might be sufficient to just focus on (1) whether a <code>leanpkg.path</code> file could be found, and (2) what the location and contents of the path file are</p>

<a name="191810361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191810361" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191810361">Kevin Buzzard (Mar 25 2020 at 21:00)</a>:</h4>
<div class="codehilite"><pre><span></span>{
  &quot;is_user_leanpkg_path&quot;: false,
  &quot;leanpkg_path_file&quot;: &quot;/home/buzzard/lean-projects/lean-perfectoid-spaces/leanpkg.path&quot;,
  &quot;path&quot;: [
    &quot;/home/buzzard/.elan/toolchains/leanprover-community-lean-3.5.1/bin/../library&quot;,
    &quot;/home/buzzard/.elan/toolchains/leanprover-community-lean-3.5.1/bin/../lib/lean/library&quot;,
    &quot;/home/buzzard/lean-projects/lean-perfectoid-spaces/_target/deps/mathlib/src&quot;,
    &quot;/home/buzzard/lean-projects/lean-perfectoid-spaces/./src&quot;
  ]
}
</pre></div>


<p>Here's a more accurate representation (I ran <code>lean --path</code> in a project). I still think it's a risk mentioning <code>leanpkg.path</code> but perhaps that vector of paths is something worth printing out?</p>

<a name="191810412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191810412" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191810412">Mario Carneiro (Mar 25 2020 at 21:01)</a>:</h4>
<p>the idea here is to get the low level information about where lean is looking</p>

<a name="191810445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191810445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191810445">Kevin Buzzard (Mar 25 2020 at 21:01)</a>:</h4>
<p>why is it not a user leanpkg path?</p>

<a name="191810467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191810467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191810467">Mario Carneiro (Mar 25 2020 at 21:01)</a>:</h4>
<p>we can also include more suggestive comments about checking their toml file and so on</p>

<a name="191810524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191810524" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191810524">Kevin Buzzard (Mar 25 2020 at 21:01)</a>:</h4>
<p>When I tried not in a project I got <code>is_user_leanpkg_path true</code> and in a project I get that it's false?</p>

<a name="191810603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191810603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191810603">Mario Carneiro (Mar 25 2020 at 21:02)</a>:</h4>
<p>I think <code>is_user_leanpkg_path</code> means it is using the global <code>leanpkg.path</code> file in your home directory</p>

<a name="191819616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191819616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191819616">Bryan Gin-ge Chen (Mar 25 2020 at 22:37)</a>:</h4>
<p>One wrinkle is that Lean currently spits out a separate message for each file it can't find, so we may need to change the error handling somehow so that we don't repeat the same helpful message over and over.</p>

<a name="191831114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191831114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191831114">Stephanie Zhou (Mar 26 2020 at 01:19)</a>:</h4>
<p>How does one use imaginary numbers in lean?</p>

<a name="191836123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191836123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191836123">Yury G. Kudryashov (Mar 26 2020 at 03:07)</a>:</h4>
<p>Complex numbers are defined in <code>data.complex</code>. What do you want to prove about them?</p>

<a name="191849802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191849802" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191849802">Alex Mathers (Mar 26 2020 at 08:10)</a>:</h4>
<p>Can anybody tell me the problem with some code? for the purposes of practicing some things I have defined subgroups in the "bundled" way and am trying to define the intersection of a family of subgroups (really just the underlying set at this point) but I'm getting a lot of unexpected error messages. My code looks like this</p>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Inf</span> <span class="p">{</span><span class="n">ι</span> <span class="p">:</span> <span class="n">Type</span><span class="o">*</span><span class="p">}</span> <span class="p">(</span><span class="n">s</span> <span class="p">:</span> <span class="n">ι</span> <span class="err">→</span> <span class="n">subgrp</span> <span class="n">G</span><span class="p">)</span> <span class="p">:</span> <span class="n">subgrp</span> <span class="n">G</span> <span class="p">:</span><span class="o">=</span>
<span class="p">{</span><span class="n">carrier</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="err">∩</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="n">i</span><span class="p">),</span>
<span class="n">mult_mem</span><span class="s1">&#39; := sorry,</span>
<span class="n">inv_mem</span><span class="s1">&#39; := sorry</span>
<span class="p">}</span>
</pre></div>


<p>and the error messages that come up are:</p>
<div class="codehilite"><pre><span></span><span class="n">grps</span><span class="o">.</span><span class="n">lean</span><span class="p">:</span><span class="mi">221</span><span class="p">:</span><span class="mi">15</span><span class="p">:</span> <span class="n">error</span>
<span class="n">unknown</span> <span class="n">identifier</span> <span class="s1">&#39;i&#39;</span>
<span class="n">grps</span><span class="o">.</span><span class="n">lean</span><span class="p">:</span><span class="mi">221</span><span class="p">:</span><span class="mi">16</span><span class="p">:</span> <span class="n">error</span>
<span class="n">invalid</span> <span class="n">expression</span><span class="p">,</span> <span class="err">`</span><span class="p">)</span><span class="err">`</span> <span class="n">expected</span>
<span class="n">grps</span><span class="o">.</span><span class="n">lean</span><span class="p">:</span><span class="mi">221</span><span class="p">:</span><span class="mi">20</span><span class="p">:</span> <span class="n">error</span>
<span class="n">invalid</span> <span class="n">structure</span> <span class="n">instance</span><span class="p">,</span> <span class="s1">&#39;:=&#39;</span> <span class="n">expected</span>
<span class="n">grps</span><span class="o">.</span><span class="n">lean</span><span class="p">:</span><span class="mi">221</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">error</span>
<span class="n">invalid</span> <span class="n">structure</span> <span class="n">instance</span><span class="p">,</span> <span class="s1">&#39;}&#39;</span> <span class="n">expected</span>
<span class="n">grps</span><span class="o">.</span><span class="n">lean</span><span class="p">:</span><span class="mi">221</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span> <span class="n">error</span>
<span class="n">command</span> <span class="n">expected</span>
</pre></div>


<p>edit: also as some extra comments, I'm basing the omission of any kind of explicit <code>i \in \io</code> off of what I've seen in mathlib, and adding it doesn't seem to change anything. And I have the coercion set up so that Lean understands it is really taking the intersection of the underlying "carrier" sets, so I don't think the issue is there.</p>

<a name="191850771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191850771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191850771">Mario Carneiro (Mar 26 2020 at 08:21)</a>:</h4>
<p>I think you have the wrong intersection symbol</p>

<a name="191850793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191850793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191850793">Johan Commelin (Mar 26 2020 at 08:21)</a>:</h4>
<p>Try <code>\bigcap</code></p>

<a name="191850981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191850981" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191850981">Alex Mathers (Mar 26 2020 at 08:23)</a>:</h4>
<p>That fixed it. So is <code>\cap</code> for two things and <code>\bigcap</code> for arbitrary intersections?</p>

<a name="191881355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191881355" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191881355">Stephanie Zhou (Mar 26 2020 at 13:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="214703">Yury G. Kudryashov</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191836123" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/191836123">said</a>:</p>
<blockquote>
<p>Complex numbers are defined in <code>data.complex</code>. What do you want to prove about them?</p>
</blockquote>
<p>I'm trying to prove Euler's formula using polar coordinates, so I wanted to use i.</p>

<a name="191881488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191881488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191881488">Johan Commelin (Mar 26 2020 at 13:12)</a>:</h4>
<p>Have you found it?</p>

<a name="191881502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191881502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191881502">Kevin Buzzard (Mar 26 2020 at 13:12)</a>:</h4>
<p>Is that theorem already in Lean? You should check the docs.</p>

<a name="191881531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191881531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191881531">Kevin Buzzard (Mar 26 2020 at 13:12)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/" title="https://leanprover-community.github.io/mathlib_docs/">https://leanprover-community.github.io/mathlib_docs/</a></p>

<a name="191882029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191882029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191882029">Kevin Buzzard (Mar 26 2020 at 13:16)</a>:</h4>
<p>I found it -- it's <a href="https://leanprover-community.github.io/mathlib_docs/data/complex/exponential.html#complex.exp_mul_I" title="https://leanprover-community.github.io/mathlib_docs/data/complex/exponential.html#complex.exp_mul_I">here</a></p>
<div class="codehilite"><pre><span></span> theorem complex.exp_mul_I (x : ℂ) :
(x * complex.I).exp = x.cos + x.sin * complex.I
</pre></div>


<p>I can live with <code>complex.I</code> but do we really want <code>x.cos</code> rather than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\cos(x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> in the docs? Can we have maths mode docs?</p>

<a name="191882109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191882109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191882109">Kevin Buzzard (Mar 26 2020 at 13:16)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> how does that work?</p>

<a name="191882239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191882239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191882239">Kevin Buzzard (Mar 26 2020 at 13:17)</a>:</h4>
<p>And where does the <a href="https://en.wikipedia.org/wiki/Euler%27s_formula" title="https://en.wikipedia.org/wiki/Euler%27s_formula">Wikipedia link to Euler's formula</a> fit into the docs?</p>

<a name="191882259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191882259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191882259">Kevin Buzzard (Mar 26 2020 at 13:17)</a>:</h4>
<p><span class="user-mention" data-user-id="110596">@Rob Lewis</span> ?</p>

<a name="191882439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191882439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191882439">Mario Carneiro (Mar 26 2020 at 13:19)</a>:</h4>
<p>presumably on the relevant formula...?</p>

<a name="191882528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191882528" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191882528">Mario Carneiro (Mar 26 2020 at 13:20)</a>:</h4>
<p>there is no rule saying you can't put doc strings on theorems, that's just systematic laziness on our part</p>

<a name="191883026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191883026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191883026">Kevin Buzzard (Mar 26 2020 at 13:23)</a>:</h4>
<p>Can a docstring have a URL?</p>

<a name="191883197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191883197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191883197">Rob Lewis (Mar 26 2020 at 13:24)</a>:</h4>
<p>Sure, just put it in angle brackets. <code>&lt;www.kevin.com&gt;</code></p>

<a name="191883205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191883205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191883205">Kevin Buzzard (Mar 26 2020 at 13:24)</a>:</h4>
<p>I just want the docstring to  say "&lt;link&gt;Euler's formula&lt;/link&gt;. The statement that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mrow><mi>i</mi><mi>θ</mi></mrow></msup><mo>=</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e^{i\theta}=\cos(\theta)+i\sin(\theta)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>"</p>

<a name="191883242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191883242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191883242">Rob Lewis (Mar 26 2020 at 13:25)</a>:</h4>
<p>Or <code>[Euler's formula](www.kevin.com)</code></p>

<a name="191883275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191883275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191883275">Kevin Buzzard (Mar 26 2020 at 13:25)</a>:</h4>
<p>Can we get the docs to display maths mode somehow?</p>

<a name="191883322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191883322" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191883322">Kevin Buzzard (Mar 26 2020 at 13:25)</a>:</h4>
<p>I want <span class="user-mention" data-user-id="263862">@Stephanie Zhou</span> to solve her problem herself by just going to the docs and typing "Euler's formula" into the search box.</p>

<a name="191883370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191883370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191883370">Kevin Buzzard (Mar 26 2020 at 13:26)</a>:</h4>
<p>Note that there are about ten Euler's formulas.</p>

<a name="191883437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191883437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191883437">Rob Lewis (Mar 26 2020 at 13:26)</a>:</h4>
<p>They do, you asked for this a while back. <code>$...$</code> inline, <code>$$...$$</code> block, but there are potential bad interactions with markdown so don't put anything in math mode that's also valid markdown.</p>

<a name="191883646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191883646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191883646">Kevin Buzzard (Mar 26 2020 at 13:28)</a>:</h4>
<p>But then I think <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> complained that he didn't want to see <code>$</code> signs cluttering up his docstrings when one could just as easily write <code>eⁱᶿ = cos(θ) + i sin (θ)</code> in unicode.</p>

<a name="191883697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/191883697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#191883697">Kevin Buzzard (Mar 26 2020 at 13:29)</a>:</h4>
<p>and I just look at that rendering and think "OMG it's Microsoft Word all over again"</p>

<a name="192126784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192126784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192126784">David Wärn (Mar 28 2020 at 14:54)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>Does this theorem have a name? library_search didn't succeed</p>

<a name="192126850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192126850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192126850">Kevin Buzzard (Mar 28 2020 at 14:56)</a>:</h4>
<p>I guess you can prove it with <code>nat.find</code> but I don't know the name.</p>

<a name="192126863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192126863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192126863">Kevin Buzzard (Mar 28 2020 at 14:57)</a>:</h4>
<p>there's probably a one-liner with some clever application of a well-ordering principle</p>

<a name="192127064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192127064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192127064">David Wärn (Mar 28 2020 at 15:02)</a>:</h4>
<p>Yes, it follows from well-foundedness of <code>f a &lt; f b</code> and the fact that a nonempty well-founded type has a minimal element. But I also couldn't find this latter fact...</p>

<a name="192127097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192127097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192127097">David Wärn (Mar 28 2020 at 15:03)</a>:</h4>
<p>I guess that's "find" for general well-orders</p>

<a name="192127748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192127748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192127748">Kevin Buzzard (Mar 28 2020 at 15:20)</a>:</h4>
<p>Maybe <a href="https://leanprover-community.github.io/mathlib_docs/order/basic.html#well_founded.has_min" title="https://leanprover-community.github.io/mathlib_docs/order/basic.html#well_founded.has_min">this</a> and nearby stuff in <code>order.basic</code> are useful?</p>

<a name="192128164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192128164" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192128164">Kenny Lau (Mar 28 2020 at 15:30)</a>:</h4>
<p>what on earth is this mode? I keep learning new stuff about github</p>

<a name="192128317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192128317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192128317">Kenny Lau (Mar 28 2020 at 15:34)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">order</span><span class="bp">.</span><span class="n">complete_lattice</span>

<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">lattice</span><span class="bp">.</span><span class="n">has_Inf</span> <span class="bp">ℕ</span><span class="o">)</span>
</pre></div>

<a name="192128318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192128318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192128318">Kenny Lau (Mar 28 2020 at 15:34)</a>:</h4>
<p>why is there no such instance</p>

<a name="192128340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192128340" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192128340">Kenny Lau (Mar 28 2020 at 15:34)</a>:</h4>
<p>oh because it doesn't have a top element</p>

<a name="192128342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192128342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192128342">Kenny Lau (Mar 28 2020 at 15:34)</a>:</h4>
<p>lattice is confusing</p>

<a name="192128427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192128427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192128427">Kevin Buzzard (Mar 28 2020 at 15:37)</a>:</h4>
<p>It's probably a semilattice_sup_bot or something</p>

<a name="192128479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192128479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192128479">David Wärn (Mar 28 2020 at 15:38)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">b</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">well_founded</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="n">b</span><span class="o">),</span> <span class="k">from</span> <span class="n">measure_wf</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">set</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">well_founded</span><span class="bp">.</span><span class="n">has_min</span> <span class="n">this</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ_nonempty</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="kn">using</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>This seems to work</p>

<a name="192128487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192128487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192128487">Kevin Buzzard (Mar 28 2020 at 15:38)</a>:</h4>
<p>ooh they're not going to like that non-terminal simp</p>

<a name="192128494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192128494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192128494">Kevin Buzzard (Mar 28 2020 at 15:38)</a>:</h4>
<p>Can you use <code>simpa</code> somehow?</p>

<a name="192128558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192128558" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192128558">David Wärn (Mar 28 2020 at 15:40)</a>:</h4>
<p>Better now?</p>

<a name="192128559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192128559" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192128559">Kevin Buzzard (Mar 28 2020 at 15:40)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">nonempty</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">a</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">f</span> <span class="n">b</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">well_founded</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="n">b</span><span class="o">),</span> <span class="k">from</span> <span class="n">measure_wf</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">simpa</span> <span class="kn">using</span> <span class="n">well_founded</span><span class="bp">.</span><span class="n">has_min</span> <span class="n">this</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ_nonempty</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="192128566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192128566" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192128566">Kevin Buzzard (Mar 28 2020 at 15:40)</a>:</h4>
<p>you beat me to it :-)</p>

<a name="192213428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192213428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192213428">Alex Mathers (Mar 30 2020 at 05:44)</a>:</h4>
<p>Is there any difference in practice between the following:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">unique_factorization_domain</span> <span class="p">(</span><span class="n">α</span> <span class="p">:</span> <span class="n">Type</span><span class="o">*</span><span class="p">)</span> <span class="p">[</span><span class="n">integral_domain</span> <span class="n">α</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span>
<span class="p">(</span><span class="n">factors</span> <span class="p">:</span> <span class="n">α</span> <span class="err">→</span> <span class="o">...</span> <span class="p">)</span>
<span class="p">(</span><span class="n">factors_prod</span> <span class="p">:</span> <span class="o">...</span> <span class="p">)</span>
<span class="p">(</span><span class="n">prime_factors</span> <span class="p">:</span> <span class="o">...</span> <span class="p">)</span>
</pre></div>


<p>and</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">unique_factorization_domain</span> <span class="p">(</span><span class="n">α</span> <span class="p">:</span> <span class="n">Type</span><span class="o">*</span><span class="p">)</span> <span class="n">extends</span> <span class="n">integral_domain</span> <span class="n">α</span> <span class="p">:</span><span class="o">=</span>
<span class="p">(</span><span class="n">factors</span> <span class="p">:</span> <span class="n">α</span> <span class="err">→</span> <span class="o">...</span> <span class="p">)</span>
<span class="p">(</span><span class="n">factors_prod</span> <span class="p">:</span> <span class="o">...</span> <span class="p">)</span>
<span class="p">(</span><span class="n">prime_factors</span> <span class="p">:</span> <span class="o">...</span> <span class="p">)</span>
</pre></div>


<p>Just curious because I saw the former in a mathlib file whereas I'm used to seeing things like the latter</p>

<a name="192214503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192214503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192214503">Mario Carneiro (Mar 30 2020 at 06:08)</a>:</h4>
<p>Yes; while they basically perform the same function, there are a number of issues that come into play regarding which is better, mostly to do with how type class inference works</p>

<a name="192214535"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192214535" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192214535">Mario Carneiro (Mar 30 2020 at 06:09)</a>:</h4>
<p>The advice I usually give is to use <code>extends</code> unless the number of type arguments goes up (as in <code>module</code> which has two type arguments)</p>

<a name="192214863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192214863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192214863">Alex Mathers (Mar 30 2020 at 06:17)</a>:</h4>
<p>Perfect, I'll blindly stick to this then</p>

<a name="192339796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192339796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192339796">Alex Mathers (Mar 31 2020 at 02:24)</a>:</h4>
<p>what's this mean? or more importantly I guess, how do I "increase the setting option" as described?</p>
<div class="codehilite"><pre><span></span>maximum class-instance resolution depth has been reached (the limit can be increased by setting option &#39;class.instance_max_depth&#39;) (the class-instance resolution trace can be visualized by setting option &#39;trace.class_instances&#39;)
</pre></div>

<a name="192339809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192339809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192339809">Bryan Gin-ge Chen (Mar 31 2020 at 02:25)</a>:</h4>
<p>e.g. <code>set_option class.instance_max_depth 100</code></p>

<a name="192339876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192339876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192339876">Alex Mathers (Mar 31 2020 at 02:26)</a>:</h4>
<p>Sweet. Should I be concerned or is this a normal adjustment to have to make?</p>

<a name="192339904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192339904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192339904">Bryan Gin-ge Chen (Mar 31 2020 at 02:27)</a>:</h4>
<p>It depends. If you share your code, we can make suggestions.</p>

<a name="192352254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192352254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192352254">Kevin Buzzard (Mar 31 2020 at 07:18)</a>:</h4>
<p>In my experience, the bug sometimes means "you have asked the type class inference system to do something super-complicated, which can be fixed with the set_option suggestion above" or "you have accidentally asked the type class inference system to do something impossible, your code is wrong and this error is a super-unhelpful way of informing you of this". Earlier you were getting errors about Lean not being able to find instances; this one might mean "you asked me to find an instance which is hard or impossible to find and I'm just getting confused".</p>

<a name="192401647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192401647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192401647">Reid Barton (Mar 31 2020 at 15:04)</a>:</h4>
<p>Yes, this is probably the second least predictive error message, after <code>(deterministic) timeout</code></p>

<a name="192499871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192499871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192499871">Miroslav Olšák (Apr 01 2020 at 09:00)</a>:</h4>
<p>I wanted to add some <code>show</code>s to my code, and I am getting an error. Why is the <code>show</code> tactic failing in the following example? I thought it should succeed when I just copy the goal.</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">l</span><span class="bp">.</span><span class="n">sum</span> <span class="bp">≥</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">l</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">list</span><span class="bp">.</span><span class="n">sum</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">≥</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="192499962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192499962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192499962">Johan Commelin (Apr 01 2020 at 09:01)</a>:</h4>
<p>It doesn't know what type of lists you want</p>

<a name="192500017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192500017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192500017">Johan Commelin (Apr 01 2020 at 09:02)</a>:</h4>
<p>Try <code>show list.sum (list.nil : list int) ≥ 0</code></p>

<a name="192500047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192500047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192500047">Johan Commelin (Apr 01 2020 at 09:02)</a>:</h4>
<p>In fact, it will see the <code>0</code> at the RHS, and by default assume that this is <code>(0 : nat)</code></p>

<a name="192500067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192500067" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192500067">Johan Commelin (Apr 01 2020 at 09:02)</a>:</h4>
<p>Unless you already convinced it that you were talking about a different type.</p>

<a name="192503340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192503340" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192503340">Miroslav Olšák (Apr 01 2020 at 09:38)</a>:</h4>
<p>Ah, the integers, thanks. <code>show [].sum ≥ (0:ℤ)</code> is working.</p>

<a name="192960665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192960665" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192960665">Shing Tak Lam (Apr 05 2020 at 13:55)</a>:</h4>
<p>Is there a tactic that would solve goals like this? I tried <code>hint</code>, but that suggested <code>ring</code>, which didn't simplify things much (or at all).</p>
<div class="codehilite"><pre><span></span><span class="o">(</span><span class="mi">2</span> <span class="err">^</span> <span class="mi">2</span> <span class="err">^</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="err">^</span> <span class="mi">2</span> <span class="err">^</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="err">^</span> <span class="mi">2</span> <span class="err">^</span> <span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span>
</pre></div>

<a name="192960823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192960823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192960823">Patrick Massot (Apr 05 2020 at 13:59)</a>:</h4>
<p>try <code>ring_exp</code></p>

<a name="192960900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192960900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192960900">Kevin Buzzard (Apr 05 2020 at 14:00)</a>:</h4>
<p>Oh it's bloody nat subtraction again</p>

<a name="192960914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192960914" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192960914">Kevin Buzzard (Apr 05 2020 at 14:00)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>

<span class="o">(</span><span class="mi">2</span> <span class="err">^</span> <span class="mi">2</span> <span class="err">^</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="err">^</span> <span class="mi">2</span> <span class="err">^</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="err">^</span> <span class="mi">2</span> <span class="err">^</span> <span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pow_succ</span><span class="o">},</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pow_mul</span><span class="o">},</span>
  <span class="n">generalize</span> <span class="o">:</span> <span class="mi">2</span> <span class="err">^</span> <span class="mi">2</span> <span class="err">^</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">t</span><span class="o">,</span>
  <span class="c1">-- ⊢ (t ^ 2 + 1) * (t ^ 2 - 1) = (t ^ 2) ^ 2 - 1</span>
  <span class="n">ring</span><span class="o">,</span> <span class="c1">-- fails</span>
</pre></div>

<a name="192961080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192961080" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192961080">Kevin Buzzard (Apr 05 2020 at 14:04)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="mi">2</span> <span class="err">^</span> <span class="mi">2</span> <span class="err">^</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="err">^</span> <span class="mi">2</span> <span class="err">^</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="err">^</span> <span class="mi">2</span> <span class="err">^</span> <span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pow_succ</span><span class="o">},</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pow_mul</span><span class="o">},</span>
  <span class="n">generalize</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="err">^</span> <span class="mi">2</span> <span class="err">^</span> <span class="n">n</span><span class="o">)</span> <span class="err">^</span> <span class="mi">2</span><span class="bp">=</span> <span class="n">t</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">t</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">succ_eq_add_one</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_sub_cancel</span><span class="o">],</span>
  <span class="n">ring</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p><span class="user-mention" data-user-id="266440">@Shing Tak Lam</span> the problem with a tactic is that you need to somehow insert the assertion that the subtraction doesn't give a junk answer. <code>omega</code> is good at this with very simple goals but this might be hard in general.</p>

<a name="192961153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192961153" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192961153">Kevin Buzzard (Apr 05 2020 at 14:06)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">open</span> <span class="n">nat</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">((</span><span class="mi">2</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="err">^</span> <span class="mi">2</span> <span class="err">^</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="err">^</span> <span class="mi">2</span> <span class="err">^</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="err">^</span> <span class="mi">2</span> <span class="err">^</span> <span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">-</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pow_succ</span><span class="o">},</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">pow_mul</span><span class="o">},</span>
  <span class="n">ring</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>Note the coercion in the statement: it's now a theorem about integers.</p>

<a name="192961772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192961772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192961772">Shing Tak Lam (Apr 05 2020 at 14:22)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/192960900" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/192960900">said</a>:</p>
<blockquote>
<p>Oh it's bloody nat subtraction again</p>
</blockquote>
<p>I know... Seems like everything I formalise I come across nat subtraction... Anyways, at least for this part (yes it's another random STEP question that I've come across), I think it's the same if I do it in the <code>nat</code>s versus the <code>int</code>s, so I guess I can just change it to <code>int</code>. Although I might need <code>data.nat.prime</code> later on, so there may be issues if I switch.</p>
<p>I guess <code>2 ^ 2 ^ succ n &gt; 1</code> is something that is obvious to me, but not obvious to lean.</p>

<a name="192963902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/192963902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#192963902">Kevin Buzzard (Apr 05 2020 at 15:14)</a>:</h4>
<p>It's not hard to prove, maybe even the monotonicity tactic will prove 2^2^(succ n)&gt;2^2^0 or something</p>

<a name="193034240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193034240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193034240">Asger Hautop Drewsen (Apr 06 2020 at 12:35)</a>:</h4>
<p>At least in the "Natural number game" the "ring" tactic doesn't seem to be able to prove that</p>
<div class="codehilite"><pre><span></span>succ (a + b) = succ a + b
</pre></div>


<p>for <code>a b : mynat</code>.</p>
<p>Why is this?</p>

<a name="193034461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193034461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193034461">Kevin Buzzard (Apr 06 2020 at 12:37)</a>:</h4>
<p><code>ring</code> will only work once it knows that the structure is a semiring. Once it knows that, it will only work on terms which only involve functions which rings have, and <code>succ</code> isn't one of these. If Lean already knows the natural numbers are a semiring then you could rewrite <code>succ_eq_add_one</code> and it should work.</p>

<a name="193034498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193034498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193034498">Kenny Lau (Apr 06 2020 at 12:37)</a>:</h4>
<p>proposal to add <code>succ_eq_add_one</code> into <code>ring</code></p>

<a name="193034544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193034544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193034544">Kevin Buzzard (Apr 06 2020 at 12:37)</a>:</h4>
<p>what about <code>mynat.succ_eq_add_one</code>?</p>

<a name="193034602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193034602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193034602">Kevin Buzzard (Apr 06 2020 at 12:38)</a>:</h4>
<p>because I suspect that's the one we're talking about here.</p>

<a name="193034641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193034641" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193034641">Kenny Lau (Apr 06 2020 at 12:38)</a>:</h4>
<p>fair enough</p>

<a name="193034677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193034677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193034677">Asger Hautop Drewsen (Apr 06 2020 at 12:38)</a>:</h4>
<p>Ah, that makes sense, this works:</p>
<div class="codehilite"><pre><span></span>repeat {rw succ_eq_add_one}, ring,
</pre></div>

<a name="193034746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193034746" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193034746">Donald Sebastian Leung (Apr 06 2020 at 12:39)</a>:</h4>
<p>Perhaps related: the <code>omega</code> tactic (a tactic specific to the natural numbers / integers, based on a fragment of Peano arithmetic called Presburger arithmetic) should be able to solve this. You probably won't be able to use it in the NNG, but in an actual Lean development, you can require it with <code>import tactic</code> (given that you have installed mathlib)</p>

<a name="193034932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193034932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193034932">Kevin Buzzard (Apr 06 2020 at 12:41)</a>:</h4>
<p>I don't know if it's possible to make <code>omega</code> work on <code>mynat</code>. One should be able to give <code>omega</code> a term of type <code>X \equiv+* nat</code> and then it would work on X by magic :-)</p>

<a name="193071626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193071626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193071626">Stephanie Zhou (Apr 06 2020 at 17:07)</a>:</h4>
<p>How would I write out sin and cos as an infinite series? I can't seem to find infinite series in the docs</p>

<a name="193071732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193071732" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193071732">Kevin Buzzard (Apr 06 2020 at 17:08)</a>:</h4>
<p>Did you find the definition of <code>sin</code>?</p>

<a name="193072116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193072116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193072116">Stephanie Zhou (Apr 06 2020 at 17:11)</a>:</h4>
<p>Ah, this?<br>
def sin (z : ℂ) : ℂ := ((exp (-z * I) - exp (z * I)) * I) / 2</p>

<a name="193072154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193072154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193072154">Kevin Buzzard (Apr 06 2020 at 17:11)</a>:</h4>
<p>Right. And can you find the definition of <code>exp</code>?</p>

<a name="193072228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193072228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193072228">Kevin Buzzard (Apr 06 2020 at 17:12)</a>:</h4>
<p>if you have mathlib open at <code>sin</code> then you might be able to right click on <code>exp</code> and jump to it.</p>

<a name="193072564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193072564" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193072564">Kevin Buzzard (Apr 06 2020 at 17:14)</a>:</h4>
<p>although having done this myself now, I see that you don't have to jump very far.</p>

<a name="193077012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193077012" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193077012">Stephanie Zhou (Apr 06 2020 at 17:48)</a>:</h4>
<p>Okay, would I define sin and cos in this way at the beginning to get lean to rewrite this way?</p>

<a name="193077293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193077293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193077293">Kevin Buzzard (Apr 06 2020 at 17:50)</a>:</h4>
<p>I don't really understand the question. Mathlib has defined them that way, so if you want to use mathlib's sin and cos then you'll have to use their definitions. But <code>exp</code> is defined as a power series so you could mimic that if you wanted to define <code>sin</code> as a power series.</p>

<a name="193127997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193127997" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193127997">Brandon B (Apr 07 2020 at 03:23)</a>:</h4>
<p>I'm trying to understand the difference between the theorem I wrote and the one that's in the Lean book to prove that, assuming <code>p</code>, one can prove <code>p or q</code> :</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kn">theorem</span> <span class="n">t1</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">intro_left</span> <span class="n">q</span> <span class="n">hp</span>      <span class="c1">--mine</span>
<span class="kn">theorem</span> <span class="n">t2</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">or</span><span class="bp">.</span><span class="n">intro_left</span> <span class="n">q</span> <span class="n">hp</span>      <span class="c1">--in the book</span>
</pre></div>


<p>I thought that a definition's (therefore theorem's) type should indicate the  theorem to be proved, which should be "p -&gt; p v q" not just "p v q" as in t2.</p>

<a name="193128273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193128273" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193128273">Donald Sebastian Leung (Apr 07 2020 at 03:29)</a>:</h4>
<p>In <code>t2</code>, <code>hp : p</code> is already introduced as a hypothesis in the theorem statement so there's no need to add another <code>p →</code> in front of <code>p ∨ q</code></p>

<a name="193128708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193128708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193128708">Brandon B (Apr 07 2020 at 03:38)</a>:</h4>
<p>I see, thanks</p>

<a name="193195089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193195089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193195089">Lynn (Apr 07 2020 at 14:25)</a>:</h4>
<p>Is there some way to <code>check</code> expressions inside a tactics block? I'd like to write something like</p>
<div class="codehilite"><pre><span></span>example (a b : Prop) : a ∨ b → b ∨ a :=
begin
  intro H,
  check H,
  ...
</pre></div>


<p>but this is not allowed (<code>invalid tactic expression</code>).</p>

<a name="193195303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193195303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193195303">Johan Commelin (Apr 07 2020 at 14:26)</a>:</h4>
<p>What would you like to happen?</p>

<a name="193195369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193195369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193195369">Johan Commelin (Apr 07 2020 at 14:27)</a>:</h4>
<p>If you use an editor like VScode, you can open the "Goal window" and it will show you the type of <code>H</code></p>

<a name="193195575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193195575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193195575">Patrick Massot (Apr 07 2020 at 14:28)</a>:</h4>
<p>In this case Johan is right, but I think we still need a tactic doing that. This was discussed recently, did we do anything in the end?</p>

<a name="193195678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193195678" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193195678">Lynn (Apr 07 2020 at 14:29)</a>:</h4>
<p>I would like to see <code>H : a ∨ b</code> printed to the console. It would be useful to insert <code>check</code> lines into some of the proofs in <a href="https://leanprover.github.io/tutorial" title="https://leanprover.github.io/tutorial">https://leanprover.github.io/tutorial</a> so I can see what they're doing</p>

<a name="193195750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193195750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193195750">Johan Commelin (Apr 07 2020 at 14:29)</a>:</h4>
<p>The intended usage is that you open the tutorial in VScode</p>

<a name="193195917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193195917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193195917">Patrick Massot (Apr 07 2020 at 14:30)</a>:</h4>
<p>Arg, this is a very old tutorial!</p>

<a name="193195957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193195957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193195957">Patrick Massot (Apr 07 2020 at 14:30)</a>:</h4>
<p>This is not even Lean 3.</p>

<a name="193195996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193195996" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193195996">Patrick Massot (Apr 07 2020 at 14:31)</a>:</h4>
<p>We really need to get rid of this trap.</p>

<a name="193196020"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193196020" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193196020">Marc Huisinga (Apr 07 2020 at 14:31)</a>:</h4>
<p>is it still linked somewhere or did you find it via google?</p>

<a name="193196106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193196106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193196106">Johan Commelin (Apr 07 2020 at 14:31)</a>:</h4>
<p><span class="user-mention" data-user-id="247532">@Lynn</span> Thanks for finding this! Please tell us how you found it, so that we can help the internet to unfind it.</p>

<a name="193196235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193196235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193196235">Lynn (Apr 07 2020 at 14:32)</a>:</h4>
<p>I suppose a clunky alternative is commenting out some suffix of the proof, to inspect the hypotheses and subgoals at that point.<br>
I found it via Google (I probably looked for <code>lean tutorial</code>)</p>

<a name="193196316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193196316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193196316">Kevin Buzzard (Apr 07 2020 at 14:33)</a>:</h4>
<p>If you have Lean installed using VS Code then all this information is available for you in a window.</p>

<a name="193196449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193196449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193196449">Kevin Buzzard (Apr 07 2020 at 14:34)</a>:</h4>
<p><a href="/user_uploads/3121/O2xJPmnqejNWwPfifH2VQqXY/code.png" title="code.png">code.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/O2xJPmnqejNWwPfifH2VQqXY/code.png" title="code.png"><img src="/user_uploads/3121/O2xJPmnqejNWwPfifH2VQqXY/code.png"></a></div>

<a name="193196619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193196619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193196619">Kevin Buzzard (Apr 07 2020 at 14:35)</a>:</h4>
<p>The Lean 2 tutorial is the <a href="https://github.com/leanprover-community/mathlib/issues/1" title="https://github.com/leanprover-community/mathlib/issues/1">#1</a> hit on duckduckgo if you search for lean tutorial</p>

<a name="193196665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193196665" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193196665">Marc Huisinga (Apr 07 2020 at 14:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193196619" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193196619">said</a>:</p>
<blockquote>
<p>The Lean 2 tutorial is the <a href="https://github.com/leanprover-community/mathlib/issues/1" title="https://github.com/leanprover-community/mathlib/issues/1">#1</a> hit on duckduckgo if you search for lean tutorial</p>
</blockquote>
<p>oh no</p>

<a name="193196710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193196710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193196710">Alex J. Best (Apr 07 2020 at 14:35)</a>:</h4>
<p>Yeah I just tried a number of variations on googling "lean tutorial" or just "lean prover" that page is listed very highly. Can we (<span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> ) move that git repo to "lean-2-tutorial" perhaps, or should we have something to replace it first?</p>

<a name="193196824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193196824" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193196824">Kevin Buzzard (Apr 07 2020 at 14:36)</a>:</h4>
<p>The Lean 2 links directly to a Lean 3 tutorial and there's also a warning</p>

<a name="193196835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193196835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193196835">Rob Lewis (Apr 07 2020 at 14:36)</a>:</h4>
<p>To be fair, the tutorial says about as explicitly as it can that it's out of date and links to the new one.</p>

<a name="193196866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193196866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193196866">Lynn (Apr 07 2020 at 14:36)</a>:</h4>
<p>I will try VS Code! I was enjoying the in-browser Lean environment, and the way it lets me play around without needing to install anything yet. Though I see <a href="https://leanprover.github.io/live" title="https://leanprover.github.io/live">https://leanprover.github.io/live</a> offers the same functionality</p>

<a name="193196921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193196921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193196921">Kevin Buzzard (Apr 07 2020 at 14:36)</a>:</h4>
<p>That's the old in-browser lean environment :-)</p>

<a name="193196950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193196950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193196950">Patrick Massot (Apr 07 2020 at 14:37)</a>:</h4>
<p>The Lean 3 tutorial it links too is also badly outdated, right?</p>

<a name="193196971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193196971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193196971">Alex J. Best (Apr 07 2020 at 14:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110596">Rob Lewis</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193196835" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193196835">said</a>:</p>
<blockquote>
<p>To be fair, the tutorial says about as explicitly as it can that it's out of date and links to the new one.</p>
</blockquote>
<p>Sure, but its still weird that the old tutorial is coming up so highly on search engines.</p>

<a name="193196972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193196972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193196972">Kevin Buzzard (Apr 07 2020 at 14:37)</a>:</h4>
<p>leanprover is dead (actually, it's just resting), long live <a href="https://leanprover-community.github.io/" title="https://leanprover-community.github.io/">leanprover-community</a></p>

<a name="193197040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193197040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193197040">Kevin Buzzard (Apr 07 2020 at 14:37)</a>:</h4>
<p><a href="https://leanprover-community.github.io/lean-web-editor/" title="https://leanprover-community.github.io/lean-web-editor/">This</a> version of the web editor has an up to date Lean and an up to date mathlib.</p>

<a name="193197056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193197056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193197056">Lynn (Apr 07 2020 at 14:37)</a>:</h4>
<p>My hasty reading of the warning:</p>
<blockquote>
<p>Please note that this is the tutorial for Lean 2, which allows the use of homotopy type theory (HoTT). It is not the tutorial for the current version of Lean.</p>
</blockquote>
<p>made me think the “current version of Lean” was _not yet_ Lean 2, and that this was an experimental tutorial for a new “Lean 2”.  (It doesn't mention that the current version is Lean 3, rather than Lean 1.)</p>

<a name="193197101"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193197101" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193197101">Johan Commelin (Apr 07 2020 at 14:38)</a>:</h4>
<p>It would be really nice if <code>leanprover.github.io</code> would just show a message</p>
<blockquote>
<p>Hi! We're really busy developing Lean 4.</p>
<p>In the mean time, please take a look at <a href="https://leanprover-community.github.io" title="https://leanprover-community.github.io">https://leanprover-community.github.io</a>.</p>
</blockquote>

<a name="193197234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193197234" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193197234">Johan Commelin (Apr 07 2020 at 14:39)</a>:</h4>
<p><span class="user-mention" data-user-id="247532">@Lynn</span> Thanks! These bug reports are helpful! (We tend to gloss over them as more experienced users...)</p>

<a name="193197236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193197236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193197236">Kevin Buzzard (Apr 07 2020 at 14:39)</a>:</h4>
<p>I don't see any reason why a newcomer would know whether the current version of Lean is Lean 2 or Lean 4 or whatever. Thanks for this observation Lynn.</p>

<a name="193197284"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193197284" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193197284">Lynn (Apr 07 2020 at 14:39)</a>:</h4>
<p>Specifying “which allows the use of homotopy type theory (HoTT)” sounds like the “current version of Lean” doesn't allow that, so Lean 2 must be surely more featureful, so the “current version” must be &lt;2  <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p>

<a name="193197329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193197329" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193197329">Patrick Massot (Apr 07 2020 at 14:39)</a>:</h4>
<p>Makes sense (when you don't know the story).</p>

<a name="193197899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193197899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193197899">Marc Huisinga (Apr 07 2020 at 14:43)</a>:</h4>
<p>i think the recommended ways to get into the current version of lean (lean 3) are either "theorem proving in lean" (<a href="https://leanprover.github.io/theorem_proving_in_lean/index.html" title="https://leanprover.github.io/theorem_proving_in_lean/index.html">https://leanprover.github.io/theorem_proving_in_lean/index.html</a>) or kevin's natural number game (<a href="https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/" title="https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/">https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/</a>).<br>
theorem proving in lean (TPIL) explains things from first principles and (optionally) uses the in-browser lean environment. if you've got experience with functional programming, cs in general or other theorem provers, this might be up your alley, either as a reference or a tutorial, depending on how much you already know.<br>
the natural number game (NNG) jumps right into proving things with tactics for natural numbers. people coming from mathematics seem to love it.</p>
<p>lastly, there's the new hitchhiker's guide to logical verification (<a href="https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf" title="https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf">https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf</a>), which i haven't read yet, but i'm sure it's great.</p>

<a name="193198326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193198326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193198326">Lynn (Apr 07 2020 at 14:46)</a>:</h4>
<p>I played through the “natural number game” a few months ago and really liked it <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span> I should probably go through it again to jog my memory.</p>

<a name="193211188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193211188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193211188">Ryan Lahfa (Apr 07 2020 at 16:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193197329" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193197329">said</a>:</p>
<blockquote>
<p>Makes sense (when you don't know the story).</p>
</blockquote>
<p>I'm interested in the story for removing HoTT, it was not useful enough? Or too difficult to keep it in the Lean codebase?</p>

<a name="193211472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193211472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193211472">Kevin Buzzard (Apr 07 2020 at 16:10)</a>:</h4>
<p>Leo just decided he wasn't going to support it. My guess is that he wasn't hearing any particular need to support it from the parts of the CS community which he listens to.</p>

<a name="193211640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193211640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193211640">Kevin Buzzard (Apr 07 2020 at 16:11)</a>:</h4>
<p>What I've learnt from the HoTT chat is there are still a lot of foundational questions which one has to answer after deciding to have some kind of univalence principle, and I'm not sure you can please all of the people all of the time.</p>

<a name="193211733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193211733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193211733">Ryan Lahfa (Apr 07 2020 at 16:11)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193211640" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193211640">said</a>:</p>
<blockquote>
<p>What I've learnt from the HoTT chat is there are still a lot of foundational questions which one has to answer after deciding to have some kind of univalence principle, and I'm not sure you can please all of the people all of the time.</p>
</blockquote>
<p>Makes sense</p>

<a name="193218608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193218608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193218608">Michael J. Curry (Apr 07 2020 at 17:05)</a>:</h4>
<p>I'm a machine learning person who's been hearing a lot about theorem provers recently (like many other people just started trying out the natural numbers game). I think it might be neat to see if it's possible to use Lean to prove some simple theorems that might be of interest in an ML setting. For example, Markov's inequality for random variables, or bounds on the range of a Lipschitz function. These seem very simple and like they might be fun to prove -- would it be possible? Or is Lean still mainly meant to be used for much more foundational stuff than that?</p>

<a name="193218748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193218748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193218748">Ryan Lahfa (Apr 07 2020 at 17:06)</a>:</h4>
<p><span class="user-mention silent" data-user-id="266106">Michael J. Curry</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193218608" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193218608">said</a>:</p>
<blockquote>
<p>I'm a machine learning person who's been hearing a lot about theorem provers recently (like many other people just started trying out the natural numbers game). I think it might be neat to see if it's possible to use Lean to prove some simple theorems that might be of interest in an ML setting. For example, Markov's inequality for random variables, or bounds on the range of a Lipschitz function. These seem very simple and like they might be fun to prove -- would it be possible? Or is Lean still mainly meant to be used for much more foundational stuff than that?</p>
</blockquote>
<p>It's definitely possible to prove both of what you mentioned.<br>
It is just that some stuff requires integrals / derivation which is currently being built in <code>mathlib</code></p>

<a name="193218944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193218944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193218944">Patrick Massot (Apr 07 2020 at 17:07)</a>:</h4>
<p><span class="user-mention" data-user-id="116448">@Koundinya Vajjha</span> will tell you about <a href="https://arxiv.org/abs/1911.00385" title="https://arxiv.org/abs/1911.00385">https://arxiv.org/abs/1911.00385</a></p>

<a name="193219186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193219186" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193219186">Alex J. Best (Apr 07 2020 at 17:09)</a>:</h4>
<p>There was also <span class="user-mention" data-user-id="230999">@Daniel Selsam</span> et al.'s <a href="http://proceedings.mlr.press/v70/selsam17a/selsam17a.pdf" title="http://proceedings.mlr.press/v70/selsam17a/selsam17a.pdf">http://proceedings.mlr.press/v70/selsam17a/selsam17a.pdf</a></p>

<a name="193219777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193219777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193219777">Andrew Ashworth (Apr 07 2020 at 17:14)</a>:</h4>
<p>it is possible, if you have the correct background. For me, as an engineer, the difficulty is in getting to grips with the formal definitions of everything; measure-theoretic probability is not taught at all in the standard curriculum so you kind of have to teach yourself all the background material before can even state results that you take for granted</p>

<a name="193219833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193219833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193219833">Michael J. Curry (Apr 07 2020 at 17:15)</a>:</h4>
<p>thanks, those are both fantastic things to start looking at! the second paper in particular looks like it has some way of defining integrals and expectation operators that can be formally manipulated without actually having to worry about defining integration in a rigorous way.</p>

<a name="193244315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193244315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193244315">Koundinya Vajjha (Apr 07 2020 at 20:38)</a>:</h4>
<p>Markov's inequality and Chebyshev's Inequality were low hanging fruit since mathlib's measure theory library is very mature. So I proved those without too much hassle in a different repository.</p>

<a name="193244572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193244572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193244572">Yury G. Kudryashov (Apr 07 2020 at 20:40)</a>:</h4>
<p>One version of Chebyshev's inequality is now in <code>mathlib</code>, see <a href="https://leanprover-community.github.io/mathlib_docs/measure_theory/integration.html#measure_theory.mul_volume_ge_le_lintegral" title="https://leanprover-community.github.io/mathlib_docs/measure_theory/integration.html#measure_theory.mul_volume_ge_le_lintegral">docs</a></p>

<a name="193244614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193244614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193244614">Yury G. Kudryashov (Apr 07 2020 at 20:41)</a>:</h4>
<p>I factored out its proof from the next lemma while refactoring Borel spaces</p>

<a name="193245061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193245061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193245061">Patrick Massot (Apr 07 2020 at 20:45)</a>:</h4>
<p>But this features the weird <code> ∫⁻</code></p>

<a name="193245614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193245614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193245614">Yury G. Kudryashov (Apr 07 2020 at 20:47)</a>:</h4>
<p>AFAIK, for a non-negative function Bochner integral equals <code>lintegral</code>.</p>

<a name="193245925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193245925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193245925">Yury G. Kudryashov (Apr 07 2020 at 20:48)</a>:</h4>
<p>And formalizing Chebyshev's inequality was not my goal.</p>

<a name="193246022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193246022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193246022">Patrick Massot (Apr 07 2020 at 20:49)</a>:</h4>
<p>I'm not complaining, I'm pointing out it's still hard to recognize.</p>

<a name="193260974"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193260974" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193260974">Scott Morrison (Apr 07 2020 at 23:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="116448">Koundinya Vajjha</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193244315" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193244315">said</a>:</p>
<blockquote>
<p>Markov's inequality and Chebyshev's Inequality were low hanging fruit since mathlib's measure theory library is very mature. So I proved those without too much hassle in a different repository.</p>
</blockquote>
<p>Please make a PR!</p>

<a name="193262004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193262004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193262004">Brandon B (Apr 07 2020 at 23:45)</a>:</h4>
<p>Why can we create a pi type using the pi symbol \Pi but \Sigma doesn't work and instead we have to use <a href="http://sigma.mk" title="http://sigma.mk">sigma.mk</a>  or is there another command ?</p>

<a name="193262216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193262216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193262216">Yury G. Kudryashov (Apr 07 2020 at 23:48)</a>:</h4>
<p>When you <em>declare</em> a pi type, you use <code>Π i, α i</code>. When you <em>define a variable</em> of a pi type, you use <code>λ i, f i</code>.</p>

<a name="193262266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193262266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193262266">Yury G. Kudryashov (Apr 07 2020 at 23:49)</a>:</h4>
<p>When you <em>declare</em> a sigma type, you can use <code>Σ i, α i</code>. When you <em>define a variable</em> of a sigma type, you use either <code>sigma.mk</code> or <code>⟨i, y⟩</code>.</p>

<a name="193265703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193265703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193265703">Brandon B (Apr 08 2020 at 00:44)</a>:</h4>
<p>ahh; thank you</p>

<a name="193310651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193310651" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193310651">Niclas Kupper (Apr 08 2020 at 12:23)</a>:</h4>
<p>How can you rewrite the RHS of an equation? when I write <code>rw add_comm at h</code> for my equality h it always only rewrites the LHS. Thanks</p>

<a name="193310972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193310972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193310972">Kevin Buzzard (Apr 08 2020 at 12:26)</a>:</h4>
<p>It rewrites the first occurrence of a+b it runs into</p>

<a name="193311040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193311040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193311040">Kevin Buzzard (Apr 08 2020 at 12:27)</a>:</h4>
<p>Try <code>rw add_comm X Y</code> if you want to change X+Y into Y+X</p>

<a name="193311084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193311084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193311084">Kevin Buzzard (Apr 08 2020 at 12:27)</a>:</h4>
<p>Or just <code>rw add_comm X</code> if you want to change the first X+something</p>

<a name="193311507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193311507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193311507">Niclas Kupper (Apr 08 2020 at 12:31)</a>:</h4>
<p>That worked, thanks!</p>

<a name="193315813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193315813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193315813">Scott Morrison (Apr 08 2020 at 13:02)</a>:</h4>
<p>Also try <code>conv</code>.</p>

<a name="193319563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193319563" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193319563">Johan Commelin (Apr 08 2020 at 13:30)</a>:</h4>
<p><span class="user-mention" data-user-id="283896">@Niclas Kupper</span> <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md" title="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md">https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md</a></p>

<a name="193323042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193323042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193323042">Matt Watson (Apr 08 2020 at 13:55)</a>:</h4>
<p>Complete noob question. Working on the natural numbers game and I want to use <code>rw add_comm</code> on <code>t + t * b</code>  in <code>t * n + t * b + t = t * n + t + t * b</code> but I don't know how to apply it to <code>t * b</code> rather than just a naked variable</p>

<a name="193323330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193323330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193323330">Victor Ahlquist (Apr 08 2020 at 13:57)</a>:</h4>
<p><span class="user-mention silent" data-user-id="283846">Matt Watson</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193323042" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193323042">said</a>:</p>
<blockquote>
<p>Complete noob question. Working on the natural numbers game and I want to use <code>rw add_comm</code> on <code>t + t * b</code>  in <code>t * n + t * b + t = t * n + t + t * b</code> but I don't know how to apply it to <code>t * b</code> rather than just a naked variable</p>
</blockquote>
<p>Try enclosing t<em>b in parentheses like this: rw add_comm t  (t</em>b),</p>

<a name="193323669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193323669" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193323669">Victor Ahlquist (Apr 08 2020 at 13:59)</a>:</h4>
<p>I'm currently also doing the natural number game and I am stuck on level 9 in advanced proposition world. Is it possible to solve the problem without using either of cc, tauto and exfalso? Exfalso is introduced in the next problem, hence my question.</p>

<a name="193324245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193324245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193324245">Matt Watson (Apr 08 2020 at 14:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="282867">Victor Ahlquist</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193323330" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193323330">said</a>:</p>
<div class="codehilite"><pre><span></span>Try enclosing t*b in parentheses like this: rw add_comm t  (t*b),
</pre></div>


<p>It didn't work for t and  <code>t*b</code>, I think my problem was making assumptions about associativity. But knowing for sure that parenthesis worked helped solve it. Thankyou</p>

<a name="193324519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193324519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193324519">Kevin Buzzard (Apr 08 2020 at 14:05)</a>:</h4>
<p>Yes <code>a+b+c</code> in Lean means <code>(a+b)+c</code></p>

<a name="193324523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193324523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193324523">Mario Carneiro (Apr 08 2020 at 14:05)</a>:</h4>
<p>you need <code>add_right_comm</code> here</p>

<a name="193324637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193324637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193324637">Kevin Buzzard (Apr 08 2020 at 14:06)</a>:</h4>
<p>I'm not sure we prove that at all</p>

<a name="193324682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193324682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193324682">Kevin Buzzard (Apr 08 2020 at 14:06)</a>:</h4>
<p>I can't remember, I think I just went for the stuff that made <code>simp</code> work</p>

<a name="193324773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193324773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193324773">Mario Carneiro (Apr 08 2020 at 14:07)</a>:</h4>
<p><code>simp</code> only needs <code>add_left_comm</code> because it likes right associating addition</p>

<a name="193324810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193324810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193324810">Kevin Buzzard (Apr 08 2020 at 14:07)</a>:</h4>
<p>Advanced prop world level 9 I think someone else pointed out that they wanted to use exfalso. I'll take a look at this today</p>

<a name="193324829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193324829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193324829">Mario Carneiro (Apr 08 2020 at 14:07)</a>:</h4>
<p>which is too bad since the pretty printer prefers left associated</p>

<a name="193324841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193324841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193324841">Kevin Buzzard (Apr 08 2020 at 14:07)</a>:</h4>
<p>You can look at my solutions in the repo</p>

<a name="193324924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193324924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193324924">Mario Carneiro (Apr 08 2020 at 14:08)</a>:</h4>
<p>you could make <code>+</code> right associative...</p>

<a name="193325080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193325080" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193325080">Victor Ahlquist (Apr 08 2020 at 14:09)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193324810" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193324810">said</a>:</p>
<blockquote>
<p>Advanced prop world level 9 I think someone else pointed out that they wanted to use exfalso. I'll take a look at this today</p>
</blockquote>
<p>Very nice, thanks.</p>

<a name="193326519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193326519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193326519">Matt Watson (Apr 08 2020 at 14:19)</a>:</h4>
<p>Does the page use local storage, or have I lost my entire game if I crashed the tab?</p>

<a name="193326560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193326560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193326560">Kevin Buzzard (Apr 08 2020 at 14:19)</a>:</h4>
<p>you can just go to any level at any time</p>

<a name="193326653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193326653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193326653">Kevin Buzzard (Apr 08 2020 at 14:20)</a>:</h4>
<p>all you lose is the colouring in dots</p>

<a name="193326709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193326709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193326709">Johan Commelin (Apr 08 2020 at 14:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> You should ask for some help with improving the machinery of the game on that reddit page</p>

<a name="193326741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193326741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193326741">Kenny Lau (Apr 08 2020 at 14:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193326560" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193326560">said</a>:</p>
<blockquote>
<p>you can just go to any level at any time</p>
</blockquote>
<p>the levels are a lie</p>

<a name="193326742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193326742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193326742">Johan Commelin (Apr 08 2020 at 14:20)</a>:</h4>
<p>Probably lots of people over there that would love to add a "use local storage" feature</p>

<a name="193326791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193326791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193326791">Johan Commelin (Apr 08 2020 at 14:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110064">Kenny Lau</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193326741" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193326741">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193326560" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193326560">said</a>:</p>
<blockquote>
<p>you can just go to any level at any time</p>
</blockquote>
<p>the levels are a lie</p>
</blockquote>
<p>There are no levels... you only imagine them</p>

<a name="193326818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193326818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193326818">Bryan Gin-ge Chen (Apr 08 2020 at 14:21)</a>:</h4>
<p>I think the progress is saved using cookies rather than local storage.</p>

<a name="193326855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193326855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193326855">Kenny Lau (Apr 08 2020 at 14:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="112680">Johan Commelin</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193326742" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193326742">said</a>:</p>
<blockquote>
<p>Probably lots of people over there that would love to add a "use local storage" feature</p>
</blockquote>
<p>like this game i enjoyed from many years ago: <a href="https://alf.nu/RegexGolf" title="https://alf.nu/RegexGolf">https://alf.nu/RegexGolf</a></p>

<a name="193327116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193327116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193327116">Andrew Ashworth (Apr 08 2020 at 14:23)</a>:</h4>
<p>wow i'm irrationally annoyed at the levels beyond classic</p>

<a name="193327443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193327443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193327443">Kenny Lau (Apr 08 2020 at 14:25)</a>:</h4>
<p>why?</p>

<a name="193328069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193328069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193328069">Andrew Ashworth (Apr 08 2020 at 14:29)</a>:</h4>
<p>i'm remembering a specific set of exam questions in my compilers class that "pure" regex (dfas) cannot be used to count and quantify, and getting them to do it is a hack.  of course regular people use regex for this all the time, so maybe i was just insufficiently traumatized by my instructor</p>

<a name="193328607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193328607" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193328607">Marc Huisinga (Apr 08 2020 at 14:33)</a>:</h4>
<p>regexp with backtracking can also lead to exponential blowup iirc</p>

<a name="193328746"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193328746" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193328746">Marc Huisinga (Apr 08 2020 at 14:34)</a>:</h4>
<p>so i think there are good reasons to restrict yourself to a regular subset when using regexes</p>

<a name="193329657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193329657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193329657">Marc Huisinga (Apr 08 2020 at 14:41)</a>:</h4>
<p>ah, this site was down for a while, but this is the post that i read years ago: <a href="https://swtch.com/~rsc/regexp/regexp1.html" title="https://swtch.com/~rsc/regexp/regexp1.html">https://swtch.com/~rsc/regexp/regexp1.html</a></p>

<a name="193330371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193330371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193330371">Matt Watson (Apr 08 2020 at 14:47)</a>:</h4>
<p>Not only that, but having to support a non-regular language makes a language slower when dealing with expressions that are regular.</p>

<a name="193332466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193332466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193332466">Scott Morrison (Apr 08 2020 at 15:01)</a>:</h4>
<p>That is an incredibly unfortunate story. :-(</p>

<a name="193333865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193333865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193333865">Johan Commelin (Apr 08 2020 at 15:10)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110025">Andrew Ashworth</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193328069" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193328069">said</a>:</p>
<blockquote>
<p>of course regular people use regex for this all the time,</p>
</blockquote>
<p>Sure, <em>regular</em> people do... but what about <em>expressive</em> people?</p>

<a name="193334431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193334431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193334431">Niclas Kupper (Apr 08 2020 at 15:14)</a>:</h4>
<p>I'm currently on the first advanced multiplication world level in the natural number game and I used <code>cases</code> and my equation got a term <code>zero</code> instead of <code>0</code>, which I can not manipulate with the usual proofs. What can I do now?</p>

<a name="193334473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193334473" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193334473">Niclas Kupper (Apr 08 2020 at 15:14)</a>:</h4>
<p>It might be because I tried to define a lemma in the proof</p>

<a name="193334581"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193334581" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193334581">Matt Watson (Apr 08 2020 at 15:15)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>  Or push down automatons?</p>

<a name="193334694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193334694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193334694">Johan Commelin (Apr 08 2020 at 15:16)</a>:</h4>
<p><span class="user-mention" data-user-id="283896">@Niclas Kupper</span> Trying to define a lemma in a proof seems like it cannot work...</p>

<a name="193334754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193334754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193334754">Johan Commelin (Apr 08 2020 at 15:17)</a>:</h4>
<p>Can you copy paste all the code the entire code block (starting with <code>lemma ... until ... end</code></p>

<a name="193334791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193334791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193334791">Johan Commelin (Apr 08 2020 at 15:17)</a>:</h4>
<div class="codehilite"><pre><span></span>```lean
put code here
```
</pre></div>

<a name="193334826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193334826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193334826">Niclas Kupper (Apr 08 2020 at 15:17)</a>:</h4>
<div class="codehilite"><pre><span></span>intro p1,
intro p2,
intro k,
induction b with d hd,
rw mul_zero a at k,
exact p2 k,
lemma pos_mul (a b : mynat) : a * b = 0 → a = 0 ∨ b = 0 :=
begin
  intro k,
  cases a with d,
  ```
</pre></div>

<a name="193334969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193334969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193334969">Niclas Kupper (Apr 08 2020 at 15:18)</a>:</h4>
<p>This is where the problem appeared, I assume that normally I would put a lemma like that in its own file?</p>

<a name="193336643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193336643" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193336643">Andrew Ashworth (Apr 08 2020 at 15:30)</a>:</h4>
<p>use the <code>have</code> keyword / tactic</p>

<a name="193336703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193336703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193336703">Andrew Ashworth (Apr 08 2020 at 15:31)</a>:</h4>
<p>if you want to do it inside a proof; normally such a fundamental fact would be broken out separately though, as you say</p>

<a name="193336876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193336876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193336876">Niclas Kupper (Apr 08 2020 at 15:32)</a>:</h4>
<p>How do I want to use <code>have</code>?</p>

<a name="193337049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193337049" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193337049">Andrew Ashworth (Apr 08 2020 at 15:33)</a>:</h4>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/propositions_and_proofs.html#introducing-auxiliary-subgoals" title="https://leanprover.github.io/theorem_proving_in_lean/propositions_and_proofs.html#introducing-auxiliary-subgoals">https://leanprover.github.io/theorem_proving_in_lean/propositions_and_proofs.html#introducing-auxiliary-subgoals</a></p>

<a name="193337181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193337181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193337181">Niclas Kupper (Apr 08 2020 at 15:34)</a>:</h4>
<p>Thanks!</p>

<a name="193338672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193338672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193338672">Victor Ahlquist (Apr 08 2020 at 15:44)</a>:</h4>
<p>Will using cases with a mynat always separate into cases zero and successor?</p>

<a name="193338811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193338811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193338811">Donald Sebastian Leung (Apr 08 2020 at 15:44)</a>:</h4>
<p>Yes</p>

<a name="193338886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193338886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193338886">Victor Ahlquist (Apr 08 2020 at 15:45)</a>:</h4>
<p>Thanks</p>

<a name="193340355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193340355" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193340355">Kevin Buzzard (Apr 08 2020 at 15:55)</a>:</h4>
<p>Using cases with any inductive type separates into the constructors for that type. For nat this is zero / succ, for <code>P \or Q</code> this is a proof of P / a proof of Q etc.</p>

<a name="193340818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193340818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193340818">Victor Ahlquist (Apr 08 2020 at 15:59)</a>:</h4>
<p>Thanks, googling some of those terms brought up a nice page. I'll be sure to read the entire "Theorem proving in Lean" once I'm done with the game.</p>

<a name="193341488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193341488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193341488">Matt Watson (Apr 08 2020 at 16:03)</a>:</h4>
<p>Why are propositions distinct from inhabitation of types?</p>

<a name="193341711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193341711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193341711">Matt Watson (Apr 08 2020 at 16:05)</a>:</h4>
<p>Or am I importing half-understood ideas from a different type theory?</p>

<a name="193341889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193341889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193341889">Kevin Buzzard (Apr 08 2020 at 16:06)</a>:</h4>
<p>The Prop universe is proof irrelevant which means that if P : Prop and a b : P then a = b definitionally.</p>

<a name="193341966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193341966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193341966">Kevin Buzzard (Apr 08 2020 at 16:07)</a>:</h4>
<p>This makes some type theory people unhappy but it seems to make mathematicians happy</p>

<a name="193349680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193349680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193349680">Victor Ahlquist (Apr 08 2020 at 17:05)</a>:</h4>
<p>Is there any reason why proof of contrapositive reasoning is not added to theorem list after advanced proposition world?</p>

<a name="193350455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193350455" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193350455">Kevin Buzzard (Apr 08 2020 at 17:11)</a>:</h4>
<p>I guess I just randomly wrote a load of worlds and didn't particularly plan anything in some coherent way. What do you suggest I do? I'm going to make some minor updates later on today.</p>

<a name="193351361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193351361" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193351361">Victor Ahlquist (Apr 08 2020 at 17:18)</a>:</h4>
<p>Well I have no particular suggestion. Having to "redo" a proof backwards has been useful in learning how to use lean. I was just wondering if this was intended or not.</p>

<a name="193351454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193351454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193351454">Victor Ahlquist (Apr 08 2020 at 17:19)</a>:</h4>
<p>I really appreciate the work you have done with the game. This is a really exciting way to study mathematics.</p>

<a name="193351745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193351745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193351745">Kevin Buzzard (Apr 08 2020 at 17:21)</a>:</h4>
<p>Oh -- are you saying I failed to add it to some list which it should be on? Sorry, I misunderstood. Probably the answer is that the current version of the Lean game maker forces me to do some things twice -- once in Lean and once in a comment so that it's registered by the system to add to a list, and maybe I failed to do it here. This was what caused the pow_succ fail: the theorem list had an incorrect version of pow_succ because of a copy paste fail.</p>

<a name="193352029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193352029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193352029">Victor Ahlquist (Apr 08 2020 at 17:23)</a>:</h4>
<p>Oh I see. I have been using the list of theorems to the right as a kind of "Allowed theorems to use" list(which is also handy because the list has the names), which is why I wondered.</p>

<a name="193356893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193356893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193356893">Matt Watson (Apr 08 2020 at 18:05)</a>:</h4>
<p>Piece of feedback: I seem to alternate between feeling completely lost, and like the body text is spoiling the answer.<br>
Perhaps the more direct instructions could be hidden behind a spoiler tag so we can struggle on our own a bit?</p>

<a name="193357542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193357542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193357542">Kevin Buzzard (Apr 08 2020 at 18:09)</a>:</h4>
<p>I absolutely agree. Firstly, I need a competent editor -- I waffle and waffle. Secondly, unfortunately, the infrastructure is not there yet for me to be able to implement the spoiler tag stuff, but I can add it as an issue to Mohammad's game maker -- I had independently thought of this recently.</p>

<a name="193363174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193363174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193363174">Matt Watson (Apr 08 2020 at 18:53)</a>:</h4>
<p>If you add something like this to editor.main.css</p>
<div class="codehilite"><pre><span></span>.hover-item {
    color: #fff;
}

.hover-item:hover {
    color: #000;
}
</pre></div>


<p>and then wrap the spoiler in &lt;span class="hover-item"&gt; it should work</p>

<a name="193363210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193363210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193363210">Matt Watson (Apr 08 2020 at 18:54)</a>:</h4>
<p>I can see about writing an extension to showdown to make it a little more erganomic</p>

<a name="193363418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193363418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193363418">Kevin Buzzard (Apr 08 2020 at 18:55)</a>:</h4>
<p>Yeah but I don't know what a css file is -- you could maybe put some comment on <a href="https://github.com/mpedramfar/Lean-game-maker/issues/5" title="https://github.com/mpedramfar/Lean-game-maker/issues/5">the issue I opened</a> on Mohammad's repo (he is about to defend his thesis viva so we might not hear from him for a few days)</p>

<a name="193363422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193363422" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193363422">Matt Watson (Apr 08 2020 at 18:55)</a>:</h4>
<p>(showdown doesn't touch the span tags, adding them to the js objects worked but I'm not sure if lean will eat them)</p>

<a name="193363602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193363602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193363602">Kevin Buzzard (Apr 08 2020 at 18:57)</a>:</h4>
<p>If you want to make some PR and tell me how to change <a href="https://github.com/ImperialCollegeLondon/natural_number_game" title="https://github.com/ImperialCollegeLondon/natural_number_game">my repo</a> I would be interested.</p>

<a name="193363889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193363889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193363889">Matt Watson (Apr 08 2020 at 18:59)</a>:</h4>
<p>It looks like you're pulling the relevant file in during the build/deploy process, so I can send the PR to Mohammad's repo.</p>

<a name="193364004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193364004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193364004">Kevin Buzzard (Apr 08 2020 at 19:00)</a>:</h4>
<p>but then presumably I have to indicate which part of the Lean file should be folded, somehow?</p>

<a name="193364125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193364125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193364125">Matt Watson (Apr 08 2020 at 19:01)</a>:</h4>
<p>Yeah, the thing I proposed would be a fast/simple but not great way of doing it.</p>
<p>More correct would be to write an extension for the markdown formatter (called showdown), then you'd just wrap the hidden section in something like &gt;! Text to hide &lt;</p>

<a name="193364213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193364213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193364213">Matt Watson (Apr 08 2020 at 19:02)</a>:</h4>
<p>That's one common syntax. Another is [spoiler]  [/spoiler]</p>

<a name="193364602"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193364602" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193364602">Matt Watson (Apr 08 2020 at 19:05)</a>:</h4>
<p>I'll look into doing it properly (if you don't hear from me in a couple of days it means I got sidetracked). In the interim, here is other formatting syntax that should work with what you're already running if you were not already aware of it <a href="http://demo.showdownjs.com/" title="http://demo.showdownjs.com/">http://demo.showdownjs.com/</a></p>

<a name="193370073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193370073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193370073">Matt Watson (Apr 08 2020 at 19:49)</a>:</h4>
<p>How do I make rw happen on a hypothesis?<br>
Specifically I have</p>
<div class="codehilite"><pre><span></span>a b u : mynat,
ht : a + u = b + u → a = b,
h : a + succ u = b + succ u
⊢ a + u = b + u
</pre></div>


<p>and I'm trying to use <code>rw add_succ</code> on both sides of h, but I keep getting 'did not find instance of pattern'</p>

<a name="193370437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193370437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193370437">Anas Himmi (Apr 08 2020 at 19:52)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">rw</span> <span class="o">[</span><span class="n">add_succ</span><span class="o">,</span><span class="n">add</span><span class="o">,</span><span class="n">succ</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span>
</pre></div>

<a name="193370500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193370500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193370500">Matt Watson (Apr 08 2020 at 19:53)</a>:</h4>
<p>Thanks</p>

<a name="193394784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193394784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193394784">Brandon B (Apr 09 2020 at 00:19)</a>:</h4>
<p>What exactly is a tactic under the hood? Is it just syntactic sugar for function composition? Is it a macro?</p>

<a name="193395147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193395147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193395147">Bryan Gin-ge Chen (Apr 09 2020 at 00:25)</a>:</h4>
<p>They're functions / programs that manipulate the "tactic state". You can read more <a href="https://leanprover-community.github.io/mathlib_docs/tactic_writing.html" title="https://leanprover-community.github.io/mathlib_docs/tactic_writing.html">in the tactic writing tutorial</a>.</p>

<a name="193399406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193399406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193399406">Scott Morrison (Apr 09 2020 at 01:52)</a>:</h4>
<p>I found <a href="https://doi.org/10.1145/3110278" title="https://doi.org/10.1145/3110278">https://doi.org/10.1145/3110278</a>  really helpful.</p>

<a name="193456429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193456429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193456429">Victor Ahlquist (Apr 09 2020 at 14:20)</a>:</h4>
<p>The link from <a href="https://github.com/ImperialCollegeLondon/natural_number_game/blob/master/WHATS_NEXT.md" title="https://github.com/ImperialCollegeLondon/natural_number_game/blob/master/WHATS_NEXT.md">https://github.com/ImperialCollegeLondon/natural_number_game/blob/master/WHATS_NEXT.md</a> to the lean web editor seems to be broken.</p>

<a name="193457623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193457623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193457623">Bryan Gin-ge Chen (Apr 09 2020 at 14:29)</a>:</h4>
<p>The correct link is <a href="https://github.com/kbuzzard/xena/tree/master/Maths_Challenges/README.md" title="https://github.com/kbuzzard/xena/tree/master/Maths_Challenges/README.md">https://github.com/kbuzzard/xena/tree/master/Maths_Challenges/README.md</a> . I'll open a PR if there isn't one already.</p>
<p><strong>edit</strong>: <a href="https://github.com/ImperialCollegeLondon/natural_number_game/issues/66" title="https://github.com/ImperialCollegeLondon/natural_number_game/issues/66">ImperialCollegeLondon/natural_number_game#66</a></p>

<a name="193462044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193462044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193462044">Victor Ahlquist (Apr 09 2020 at 15:01)</a>:</h4>
<p>Thanks, I haven't really used Github before so wasn't sure how to report it.</p>

<a name="193462280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193462280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193462280">Victor Ahlquist (Apr 09 2020 at 15:03)</a>:</h4>
<p>Going to read up on the lean documentation now at least. This seems like a productive thing to use my free time on.</p>

<a name="193463885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193463885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193463885">Will P (Apr 09 2020 at 15:14)</a>:</h4>
<p>Hi, thanks for all the work put into lean. I'm having a go at the natural numbers game and I got stuck at level 10 on the advanced addition.  I'm not sure exactly how to use  not equals during a proof.  My current attempt is </p>
<div class="codehilite"><pre><span></span><span class="n">cases</span> <span class="n">b</span> <span class="k">with</span> <span class="n">d</span><span class="o">,</span>
<span class="n">refl</span><span class="o">,</span>
<span class="n">exfalso</span> <span class="o">,</span>
<span class="n">rw</span> <span class="n">add_succ</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
<span class="k">have</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">succ_ne_zero</span><span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="n">at</span> <span class="n">H</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">H</span> <span class="n">at</span> <span class="n">q</span><span class="o">,</span>

<span class="n">a</span> <span class="n">d</span> <span class="o">:</span> <span class="n">mynat</span><span class="o">,</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">succ</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
<span class="n">q</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≠</span> <span class="mi">0</span>
<span class="err">⊢</span> <span class="n">false</span>
</pre></div>


<p>I've got 0 /=0 but no way of making that false</p>

<a name="193464619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193464619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193464619">Kenny Lau (Apr 09 2020 at 15:17)</a>:</h4>
<p>hint: use the following code to enable syntax highlighting:</p>
<div class="codehilite"><pre><span></span>```lean
[your code here]
```
</pre></div>

<a name="193464753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193464753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193464753">Kenny Lau (Apr 09 2020 at 15:18)</a>:</h4>
<p>Also, please copy the tactic state after the final comma.</p>

<a name="193466089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193466089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193466089">Victor Ahlquist (Apr 09 2020 at 15:28)</a>:</h4>
<p>Nothing seems to happen when I'm using the lean web editor. I pressed the first "try it!" button here: <a href="https://leanprover.github.io/theorem_proving_in_lean/introduction.html" title="https://leanprover.github.io/theorem_proving_in_lean/introduction.html">https://leanprover.github.io/theorem_proving_in_lean/introduction.html</a> , but I can't see the current goal only the block of code.</p>

<a name="193466259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193466259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193466259">Marc Huisinga (Apr 09 2020 at 15:29)</a>:</h4>
<p>that proof is in term mode, so it won't have a goal view</p>

<a name="193466429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193466429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193466429">Kevin Buzzard (Apr 09 2020 at 15:30)</a>:</h4>
<p><a href="https://leanprover-community.github.io/lean-web-editor/" title="https://leanprover-community.github.io/lean-web-editor/">The community web editor</a> is better.</p>

<a name="193466479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193466479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193466479">Marc Huisinga (Apr 09 2020 at 15:30)</a>:</h4>
<p>chapter 5 introduces tactics, <a href="https://leanprover.github.io/live/3.4.1/#code=theorem%20test%20(p%20q%20:%20Prop)%20(hp%20:%20p)%20(hq%20:%20q)%20:%20p%20%E2%88%A7%20q%20%E2%88%A7%20p%20:=%0Abegin%0A%20%20apply%20and.intro,%0A%20%20exact%20hp,%0A%20%20apply%20and.intro,%0A%20%20exact%20hq,%0A%20%20exact%20hp%0Aend" title="https://leanprover.github.io/live/3.4.1/#code=theorem%20test%20(p%20q%20:%20Prop)%20(hp%20:%20p)%20(hq%20:%20q)%20:%20p%20%E2%88%A7%20q%20%E2%88%A7%20p%20:=%0Abegin%0A%20%20apply%20and.intro,%0A%20%20exact%20hp,%0A%20%20apply%20and.intro,%0A%20%20exact%20hq,%0A%20%20exact%20hp%0Aend">here's one example</a></p>

<a name="193466692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193466692" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193466692">Victor Ahlquist (Apr 09 2020 at 15:32)</a>:</h4>
<p>Ah thanks</p>

<a name="193466786"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193466786" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193466786">Kenny Lau (Apr 09 2020 at 15:32)</a>:</h4>
<p><span class="user-mention" data-user-id="284434">@Will P</span> change your last two lines to:</p>
<div class="codehilite"><pre><span></span><span class="n">apply</span> <span class="n">succ_ne_zero</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">d</span><span class="o">),</span>
<span class="n">exact</span> <span class="n">H</span><span class="o">,</span>
</pre></div>

<a name="193467092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193467092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193467092">Marc Huisinga (Apr 09 2020 at 15:35)</a>:</h4>
<p>(deleted)</p>

<a name="193467236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193467236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193467236">Victor Ahlquist (Apr 09 2020 at 15:36)</a>:</h4>
<p>About Will P's question: I also had some times when doing the natural number game when it would have been great to get a "trivial" hypothesis such as 0=0. I tried the have command, but it did not work. Is there any other way to get an equality?</p>

<a name="193467309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193467309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193467309">Kenny Lau (Apr 09 2020 at 15:37)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
<span class="n">refl</span><span class="o">,</span>
</pre></div>

<a name="193467360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193467360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193467360">Kevin Buzzard (Apr 09 2020 at 15:37)</a>:</h4>
<p>If you have </p>
<div class="codehilite"><pre><span></span>q : 0 ≠ 0
⊢ false
</pre></div>


<p>then you can <code>apply q</code> and then <code>refl</code> because <code>q</code> is <code>0 = 0 -&gt; false</code></p>

<a name="193467751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193467751" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193467751">Victor Ahlquist (Apr 09 2020 at 15:40)</a>:</h4>
<p>Ah, I tried have h := 0=0, which only gave me a h: Prop. Thanks for the answers</p>

<a name="193467837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193467837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193467837">Kenny Lau (Apr 09 2020 at 15:41)</a>:</h4>
<p><code>h := 0=0</code> means <code>h</code> is defined to be <code>0=0</code>, which is a <code>Prop</code></p>

<a name="193468166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193468166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193468166">Victor Ahlquist (Apr 09 2020 at 15:43)</a>:</h4>
<p>I see, hopefully all of this will make more sense after reading the book.</p>

<a name="193469189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193469189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193469189">Kevin Buzzard (Apr 09 2020 at 15:50)</a>:</h4>
<p>Be clear about the difference between a Proposition (a true/false statement) and its proof. In mathematics we are very vague about this, we have our own conventions which seem to work fine but don't stand up to scrutiny. When we say "by theorem 10" we mean "by the fact that we proved theorem 10"; theorem 10 is just a statement. A true/false statement, otherwise known as a Proposition in Lean, is <code>P : Prop</code>. It's proof is <code>h : P</code>. For example <code>injective f : Prop := \forall x y, f x = f y -&gt; x = y</code> is the definition of injectivity. There is no proof here, it's a definition of a true/false statement, and its truth value depends on what f is. But <code>h : injective succ := &lt;proof that succ is injective&gt;</code> is a proof. The propositions are types, and the proofs are terms. Be clear about what level you are working at.</p>

<a name="193478552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193478552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193478552">Victor Ahlquist (Apr 09 2020 at 16:56)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193469189" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193469189">said</a>:</p>
<blockquote>
<p>Be clear about the difference between a Proposition (a true/false statement) and its proof. In mathematics we are very vague about this, we have our own conventions which seem to work fine but don't stand up to scrutiny. When we say "by theorem 10" we mean "by the fact that we proved theorem 10"; theorem 10 is just a statement. A true/false statement, otherwise known as a Proposition in Lean, is <code>P : Prop</code>. It's proof is <code>h : P</code>. For example <code>injective f : Prop := \forall x y, f x = f y -&gt; x = y</code> is the definition of injectivity. There is no proof here, it's a definition of a true/false statement, and its truth value depends on what f is. But <code>h : injective succ := &lt;proof that succ is injective&gt;</code> is a proof. The propositions are types, and the proofs are terms. Be clear about what level you are working at.</p>
</blockquote>
<p>Thanks for the elaborate reply, now it is very clear why h : 0=0 ,is used</p>

<a name="193491872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193491872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193491872">Victor Ahlquist (Apr 09 2020 at 18:37)</a>:</h4>
<p>By the way, a project of "perfectoid spaces" was mentioned after finishing the game. It said you needed a "whole lot of commutative algebra" to do that.  Does this mean PhD level?</p>

<a name="193492687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193492687" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193492687">Marc Huisinga (Apr 09 2020 at 18:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="282867">Victor Ahlquist</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193491872" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193491872">said</a>:</p>
<blockquote>
<p>By the way, a project of "perfectoid spaces" was mentioned after finishing the game. It said you needed a "whole lot of commutative algebra" to do that.  Does this mean PhD level?</p>
</blockquote>
<p><a href="https://arxiv.org/abs/1910.12320" title="https://arxiv.org/abs/1910.12320">https://arxiv.org/abs/1910.12320</a></p>

<a name="193493059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193493059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193493059">Victor Ahlquist (Apr 09 2020 at 18:47)</a>:</h4>
<p>Looks like a yes then.</p>

<a name="193515957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193515957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193515957">Filip Szczepański (Apr 09 2020 at 22:10)</a>:</h4>
<p>Is there anything I can do when the Lean interpreter on the Natural Number Game gets stuck, besides refreshing the page and losing my progress?</p>

<a name="193516202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193516202" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193516202">Kevin Buzzard (Apr 09 2020 at 22:13)</a>:</h4>
<p>no progress is kept. You can go to any level at any time.</p>

<a name="193516316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193516316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193516316">Bryan Gin-ge Chen (Apr 09 2020 at 22:14)</a>:</h4>
<p>What's causing the interpreter to get stuck? Is it something you can reproduce?</p>

<a name="193516328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193516328" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193516328">Filip Szczepański (Apr 09 2020 at 22:14)</a>:</h4>
<p>That's true. I appreciate seeing how far I've gotten, though</p>

<a name="193516380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193516380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193516380">Filip Szczepański (Apr 09 2020 at 22:15)</a>:</h4>
<p>One time I got it stuck with <code>repeat { rw add_comm }</code>, and this time it was something else with repeat</p>

<a name="193516424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193516424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193516424">Kevin Buzzard (Apr 09 2020 at 22:15)</a>:</h4>
<p>You can get a tactic block which loops, but in VS Code this isn't a problem. Is it a problem in NNG?</p>

<a name="193516483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193516483" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193516483">Filip Szczepański (Apr 09 2020 at 22:16)</a>:</h4>
<p>Yeah, just on the NNG website</p>

<a name="193516543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193516543" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193516543">Filip Szczepański (Apr 09 2020 at 22:17)</a>:</h4>
<p>I wouldn't mind going through NNG in vscode, but it seems the website is the recommended way? Also vscode doesn't list the tactics and theorems</p>

<a name="193516575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193516575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193516575">Kevin Buzzard (Apr 09 2020 at 22:17)</a>:</h4>
<p>You're right, and I don't really know how to solve this.</p>

<a name="193516671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193516671" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193516671">Bryan Gin-ge Chen (Apr 09 2020 at 22:18)</a>:</h4>
<p>I can't seem to get the web editor to loop. If you run into another loop, please paste the full code so I can take a look.</p>

<a name="193516678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193516678" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193516678">Kevin Buzzard (Apr 09 2020 at 22:18)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> try going to advanced addition world at <a href="http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/" title="http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/">http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/</a> , level 5, and then try <code>repeat {rw add_comm}</code>. This loops. Unsurprisingly, you get "Lean is busy...". But it doesn't go away</p>

<a name="193516711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193516711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193516711">Filip Szczepański (Apr 09 2020 at 22:19)</a>:</h4>
<p>Obviously, the interpreter can just keep going between <code>a+b</code> and <code>b+a</code> forever</p>

<a name="193516758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193516758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193516758">Kevin Buzzard (Apr 09 2020 at 22:19)</a>:</h4>
<p>Right. But in VS Code if you just delete the line <code>repeat {rw add_comm}</code> everything goes back to normal.</p>

<a name="193516827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193516827" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193516827">Kevin Buzzard (Apr 09 2020 at 22:20)</a>:</h4>
<p>In NNG it seems that this breaks the game forever, you can go back to the overworld and then click on another world and any level and Lean is still busy</p>

<a name="193517221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193517221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193517221">Kevin Buzzard (Apr 09 2020 at 22:25)</a>:</h4>
<p><a href="https://github.com/mpedramfar/Lean-game-maker/issues/6" title="https://github.com/mpedramfar/Lean-game-maker/issues/6">https://github.com/mpedramfar/Lean-game-maker/issues/6</a></p>

<a name="193517644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193517644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193517644">Bryan Gin-ge Chen (Apr 09 2020 at 22:29)</a>:</h4>
<p>Interesting. my wild guess would be because the web editor runs single-threaded (?) and so nothing is able to interrupt the loop. For the NNG, maybe you could wrap <code>repeat</code> in <code>try_for 100000</code> to protect users from this.</p>

<a name="193517748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193517748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193517748">Bryan Gin-ge Chen (Apr 09 2020 at 22:30)</a>:</h4>
<p>Well, I'm not sure what numbers would be good to use in <code>try_for</code>, maybe 100000 is still too low.</p>

<a name="193518435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193518435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193518435">Filip Szczepański (Apr 09 2020 at 22:38)</a>:</h4>
<p>I think the Lean interpreter is running in something like a web worker, otherwise I'd expect the whole tab to freeze up</p>

<a name="193518515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193518515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193518515">Scott Morrison (Apr 09 2020 at 22:39)</a>:</h4>
<p>My son did exactly this, and it really upset him when he lost his progress. :-) It was a good life lesson...</p>

<a name="193520762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193520762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193520762">Bryan Gin-ge Chen (Apr 09 2020 at 23:05)</a>:</h4>
<p>Yep, there's one web worker for the Lean server and one worker for Monaco (the text editor).</p>

<a name="193567509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193567509" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193567509">Victor Ahlquist (Apr 10 2020 at 13:14)</a>:</h4>
<p>The link to "2 add 2 isn't 5" from here <a href="https://github.com/kbuzzard/xena/blob/master/Maths_Challenges/README.md" title="https://github.com/kbuzzard/xena/blob/master/Maths_Challenges/README.md">https://github.com/kbuzzard/xena/blob/master/Maths_Challenges/README.md</a> is broken</p>

<a name="193567552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193567552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193567552">Victor Ahlquist (Apr 10 2020 at 13:15)</a>:</h4>
<p>Actually all of the links except the first two appears to be broken</p>

<a name="193568037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193568037" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193568037">Kevin Buzzard (Apr 10 2020 at 13:21)</a>:</h4>
<p>Nobody ever does these challenges, I don't think I've ever got any feedback from them. Thanks for letting me know.</p>

<a name="193568162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193568162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193568162">Victor Ahlquist (Apr 10 2020 at 13:23)</a>:</h4>
<p>Oh, the first two were nice to do after NNG. Guess I'll look for other things to do.</p>

<a name="193568202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193568202" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193568202">Kevin Buzzard (Apr 10 2020 at 13:23)</a>:</h4>
<p>They'll all be fixed in 5 minutes :-)</p>

<a name="193568217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193568217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193568217">Victor Ahlquist (Apr 10 2020 at 13:23)</a>:</h4>
<p>Nice, thanks :)</p>

<a name="193568687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193568687" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193568687">Kevin Buzzard (Apr 10 2020 at 13:29)</a>:</h4>
<p>Links to questions should now all work, I'll check hints and solutions. Thanks again.</p>

<a name="193569118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193569118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193569118">Victor Ahlquist (Apr 10 2020 at 13:34)</a>:</h4>
<p>Thanks, they're working now</p>

<a name="193569379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193569379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193569379">Victor Ahlquist (Apr 10 2020 at 13:38)</a>:</h4>
<p>By the way, I saw you mentioned in an old reddit thread that there still was some undergrad math that needed to be done in Lean. Is this still the case?</p>

<a name="193569876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193569876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193569876">Kevin Buzzard (Apr 10 2020 at 13:43)</a>:</h4>
<p>3rd year undergraduate maths there's lots.</p>

<a name="193569911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193569911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193569911">Kevin Buzzard (Apr 10 2020 at 13:43)</a>:</h4>
<p>1st and 2nd year we're basically covered apart from contour integrals</p>

<a name="193570002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193570002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193570002">Kevin Buzzard (Apr 10 2020 at 13:44)</a>:</h4>
<p>3rd year undergrad we have most of a basic number theory course but as far as I know we don't have any of: ideals in a number field factor uniquely into prime ideals, finiteness of class group, rank of unit group.</p>

<a name="193570058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193570058" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193570058">Kevin Buzzard (Apr 10 2020 at 13:45)</a>:</h4>
<p>we have a bunch of commutative algebra but no homological algebra</p>

<a name="193570066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193570066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193570066">Johan Commelin (Apr 10 2020 at 13:45)</a>:</h4>
<p>Well... some people are working on combinatorics/probability theory/graph theory... but there are huge holes there.</p>

<a name="193570171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193570171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193570171">Kevin Buzzard (Apr 10 2020 at 13:46)</a>:</h4>
<p>Oh here's a list of random things we don't have: <a href="https://github.com/kbuzzard/xena/blob/master/many_maths_challenges.txt" title="https://github.com/kbuzzard/xena/blob/master/many_maths_challenges.txt">https://github.com/kbuzzard/xena/blob/master/many_maths_challenges.txt</a></p>

<a name="193570288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193570288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193570288">Victor Ahlquist (Apr 10 2020 at 13:48)</a>:</h4>
<p>Oh, some of those topics definitely sound approachable. I'm a 2nd year undergrad, but in Swedish school system so not sure how things translate. I'll have a lot of free time this summer and some free time the weeks until then so I'll definitely start looking into this.</p>

<a name="193570370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193570370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193570370">Victor Ahlquist (Apr 10 2020 at 13:48)</a>:</h4>
<p>Thanks for the list!</p>

<a name="193570432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193570432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193570432">Patrick Massot (Apr 10 2020 at 13:49)</a>:</h4>
<p>homological algebra is coming, I've seen many PRs about this recently</p>

<a name="193570435"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193570435" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193570435">Kevin Buzzard (Apr 10 2020 at 13:49)</a>:</h4>
<p>I'm working with a bunch of 2nd year undergraduates on stuff this summer, it was all going to happen at Imperial College but now it's probably going to happen online, you'd be welcome to join us -- most people will be beginners.</p>

<a name="193570548"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193570548" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193570548">Kevin Buzzard (Apr 10 2020 at 13:50)</a>:</h4>
<p>homological algebra has in some sense been coming for some time. Another way of looking at it is that a mathematician writes "let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋯</mo><mo>→</mo><msub><mi>M</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>M</mi><mi>n</mi></msub><mo>→</mo><msub><mi>M</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots\to M_{n-1}\to M_n\to M_{n+1}\to \cdots</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span> be an exact sequence of abelian groups, and then we spend months trying to figure out how best to say that in Lean without getting caught up in type theory issues.</p>

<a name="193570620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193570620" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193570620">Kevin Buzzard (Apr 10 2020 at 13:51)</a>:</h4>
<p>or category theory issues</p>

<a name="193570795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193570795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193570795">Victor Ahlquist (Apr 10 2020 at 13:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193570435" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193570435">said</a>:</p>
<blockquote>
<p>I'm working with a bunch of 2nd year undergraduates on stuff this summer, it was all going to happen at Imperial College but now it's probably going to happen online, you'd be welcome to join us -- most people will be beginners.</p>
</blockquote>
<p>Wow that would be great. What would the mathematical prerequisites be?</p>

<a name="193570818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193570818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193570818">Kevin Buzzard (Apr 10 2020 at 13:53)</a>:</h4>
<p>2nd year undergrad?</p>

<a name="193570830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193570830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193570830">Kevin Buzzard (Apr 10 2020 at 13:53)</a>:</h4>
<p>Whatever you show up with, really.</p>

<a name="193571296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193571296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193571296">Victor Ahlquist (Apr 10 2020 at 13:58)</a>:</h4>
<p>Neat, I'll just practice using lean until then in that case.</p>

<a name="193571324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193571324" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193571324">Victor Ahlquist (Apr 10 2020 at 13:58)</a>:</h4>
<p>It is really impressing that there's already so much math formalized in lean.</p>

<a name="193571668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193571668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193571668">Kevin Buzzard (Apr 10 2020 at 14:01)</a>:</h4>
<p>In 2017 there was nothing.</p>

<a name="193571757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193571757" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193571757">Kevin Buzzard (Apr 10 2020 at 14:01)</a>:</h4>
<p>Definitions of rings, groups, top spaces, basic stuff about compact spaces, hardly any theorems about anything else. Loads and loads and loads of theorems about lists finite sets though, which turn out to be really important.</p>

<a name="193571828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193571828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193571828">Victor Ahlquist (Apr 10 2020 at 14:02)</a>:</h4>
<p>I'm looking forward to seeing how this will influence mathematics</p>

<a name="193571857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193571857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193571857">Kevin Buzzard (Apr 10 2020 at 14:02)</a>:</h4>
<p>Most stuff written by Mario Carneiro and Johannes Hoelzl, who have a computer science background. Then mathematicians started to get involved and the focus of the library changed much more to undergraduate level mathematics</p>

<a name="193571937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193571937" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193571937">Victor Ahlquist (Apr 10 2020 at 14:03)</a>:</h4>
<p>Ah I see. It is nice that there's some cooperation between different subjects going on.</p>

<a name="193571945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193571945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193571945">Kevin Buzzard (Apr 10 2020 at 14:03)</a>:</h4>
<p>I should say that Mario almost certainly would not say there was nothing -- there was a ton of stuff in late 2017 which was of foundational importance.</p>

<a name="193571981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193571981" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193571981">Kevin Buzzard (Apr 10 2020 at 14:03)</a>:</h4>
<p>But if you look at what there was and compare with the things taught to maths undergraduates, there was very little.</p>

<a name="193572122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193572122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193572122">Kevin Buzzard (Apr 10 2020 at 14:04)</a>:</h4>
<p>Because we don't teach them that the union of two finite sets is finite, this doesn't need a proof as far as we are concerned :-) In Lean this sort of thing needs to be proved, and then you have to decide what the definition of a finite set is, and then suddenly you are wrestling with foundational type theory issues.</p>

<a name="193572145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193572145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193572145">Patrick Massot (Apr 10 2020 at 14:05)</a>:</h4>
<p>Even at that time there was much more general topology than what we teach undergrads.</p>

<a name="193572250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193572250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193572250">Kevin Buzzard (Apr 10 2020 at 14:06)</a>:</h4>
<p>Yes that is true, it was some weird outlier.</p>

<a name="193572272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193572272" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193572272">Kevin Buzzard (Apr 10 2020 at 14:06)</a>:</h4>
<p>Probably all the results in my 2nd year topology course were there.</p>

<a name="193572344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193572344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193572344">Kevin Buzzard (Apr 10 2020 at 14:07)</a>:</h4>
<p>But I am pretty sure there was no first isomorphism theorem for groups or rank-nullity for vector spaces in 2017.</p>

<a name="193572440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193572440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193572440">Patrick Massot (Apr 10 2020 at 14:08)</a>:</h4>
<p>Note there was a lot of topology but no normed space.</p>

<a name="193572483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193572483" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193572483">Victor Ahlquist (Apr 10 2020 at 14:08)</a>:</h4>
<p>I guess some maths is easier to formalize than others?</p>

<a name="193572522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193572522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193572522">Victor Ahlquist (Apr 10 2020 at 14:09)</a>:</h4>
<p>Although that's a wild guess from my side.</p>

<a name="193572907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193572907" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193572907">Filip Szczepański (Apr 10 2020 at 14:13)</a>:</h4>
<p>What happens when I write <code>have foo := bar,</code> and there was already something with the name foo in scope?</p>

<a name="193573217"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193573217" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193573217">Donald Sebastian Leung (Apr 10 2020 at 14:16)</a>:</h4>
<p>You get two <code>foo</code>s in your context, and IIRC the latest <code>foo</code> shadows the earlier one (so later tactics referring to <code>foo</code> would only see the latest one)</p>

<a name="193573236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193573236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193573236">Filip Szczepański (Apr 10 2020 at 14:16)</a>:</h4>
<p>Ok, that's fairly convenient. Thanks.</p>

<a name="193573371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193573371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193573371">Donald Sebastian Leung (Apr 10 2020 at 14:17)</a>:</h4>
<p>This is one of the things that sometimes gets me in Lean, but doesn't happen in Coq. Does anyone know the rationale behind this design decision?</p>

<a name="193573454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193573454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193573454">Patrick Massot (Apr 10 2020 at 14:18)</a>:</h4>
<p>Honestly I also wish Lean would rise at least a warning in this situation.</p>

<a name="193573512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193573512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193573512">Patrick Massot (Apr 10 2020 at 14:18)</a>:</h4>
<p>Here Lean feels very pythonic we're-all-consenting-adults.</p>

<a name="193576513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193576513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193576513">Filip Szczepański (Apr 10 2020 at 14:47)</a>:</h4>
<p>I finally finished mul_left_cancel</p>

<a name="193576524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193576524" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193576524">Filip Szczepański (Apr 10 2020 at 14:47)</a>:</h4>
<p>I bet my proof is overcomplicated</p>

<a name="193576657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193576657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193576657">Kevin Buzzard (Apr 10 2020 at 14:48)</a>:</h4>
<p><a href="https://github.com/ImperialCollegeLondon/natural_number_game/blob/master/src/game/world9/level4.lean" title="https://github.com/ImperialCollegeLondon/natural_number_game/blob/master/src/game/world9/level4.lean">My proof looks pretty long</a></p>

<a name="193576936"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193576936" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193576936">Filip Szczepański (Apr 10 2020 at 14:51)</a>:</h4>
<p><a href="https://gist.github.com/FreeFull/01d57489ac996db3ea2f8e31254d466c" title="https://gist.github.com/FreeFull/01d57489ac996db3ea2f8e31254d466c">https://gist.github.com/FreeFull/01d57489ac996db3ea2f8e31254d466c</a> This is mine. I didn't use <code>assumption</code> because  I didn't know about it</p>

<a name="193576971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193576971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193576971">Filip Szczepański (Apr 10 2020 at 14:51)</a>:</h4>
<p>Not too nicely formatted either</p>

<a name="193587263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193587263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193587263">Victor Ahlquist (Apr 10 2020 at 16:19)</a>:</h4>
<p>I tried downloading and installing leanprover and commands like #eval 1+1 work without trouble. However when I try importing things such as import data.finset algebra.big_operators tactic.ring, I get a file not found error. Any idea what could be causing this?</p>

<a name="193591075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193591075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193591075">Bryan Gin-ge Chen (Apr 10 2020 at 16:54)</a>:</h4>
<p>Did you follow all the instructions for your OS <a href="https://github.com/leanprover-community/mathlib#installation" title="https://github.com/leanprover-community/mathlib#installation">here</a> and then follow the instructions to create a project <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/install/project.md" title="https://github.com/leanprover-community/mathlib/blob/master/docs/install/project.md">here</a>?</p>

<a name="193593572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193593572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193593572">Kevin Buzzard (Apr 10 2020 at 17:15)</a>:</h4>
<blockquote>
<p>Note however that you cannot use mathlib, and in particular any imports, in the file test.lean created above. To use mathlib you will need to set up or download a Lean project. You should now read instructions about creating and working on Lean projects.</p>
</blockquote>
<p>What is your OS? Does this comment (at the bottom of the install files) apply to you?</p>

<a name="193606575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193606575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193606575">Victor Ahlquist (Apr 10 2020 at 19:13)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193591075" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193591075">said</a>:</p>
<blockquote>
<p>Did you follow all the instructions for your OS <a href="https://github.com/leanprover-community/mathlib#installation" title="https://github.com/leanprover-community/mathlib#installation">here</a> and then follow the instructions to create a project <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/install/project.md" title="https://github.com/leanprover-community/mathlib/blob/master/docs/install/project.md">here</a>?</p>
</blockquote>
<p>Ah no, I did not follow the instructions to create a project only the instructions on the install page. I'll try this</p>

<a name="193607833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193607833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193607833">Victor Ahlquist (Apr 10 2020 at 19:26)</a>:</h4>
<p>Great,  now it works perfectly! Thanks for the help</p>

<a name="193608622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193608622" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193608622">Victor Ahlquist (Apr 10 2020 at 19:34)</a>:</h4>
<p>Not sure how I managed to miss that last message</p>

<a name="193609473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193609473" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193609473">Kevin Buzzard (Apr 10 2020 at 19:42)</a>:</h4>
<p>I specially put it into the docs a couple of weeks ago because people keep asking this :-)</p>

<a name="193609491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193609491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193609491">Kevin Buzzard (Apr 10 2020 at 19:43)</a>:</h4>
<p>Maybe I'll put it in flashing red letters :-)</p>

<a name="193609527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193609527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193609527">Victor Ahlquist (Apr 10 2020 at 19:43)</a>:</h4>
<p>Haha, as you posted it I can recall reading it and then promptly forgetting about it.</p>

<a name="193611770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193611770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193611770">Victor Ahlquist (Apr 10 2020 at 20:05)</a>:</h4>
<p>Chapter 2 was an interesting but tough read, reminds me of my course in Java programming</p>

<a name="193611794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193611794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193611794">Kevin Buzzard (Apr 10 2020 at 20:05)</a>:</h4>
<p>Chapter 2 of the installation instructions?</p>

<a name="193611904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193611904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193611904">Filip Szczepański (Apr 10 2020 at 20:06)</a>:</h4>
<p>I have <code>hb : b = b + d + c</code> and I'm wondering if there's a more straightforward way to get to <code>0 = d + c</code> than going through ← add_zero, add_assoc and add_left_cancel</p>

<a name="193611942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193611942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193611942">Victor Ahlquist (Apr 10 2020 at 20:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193611794" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193611794">said</a>:</p>
<blockquote>
<p>Chapter 2 of the installation instructions?</p>
</blockquote>
<p>Haha no, chapter 2 of theorem proving in lean.</p>

<a name="193612673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193612673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193612673">Victor Ahlquist (Apr 10 2020 at 20:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284527">Filip Szczepański</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193611904" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193611904">said</a>:</p>
<blockquote>
<p>I have <code>hb : b = b + d + c</code> and I'm wondering if there's a more straightforward way to get to <code>0 = d + c</code> than going through ← add_zero, add_assoc and add_left_cancel</p>
</blockquote>
<p>I'm new to Lean so this is probably wrong, but perhaps you could leave out add_zero.</p>

<a name="193630117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193630117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193630117">Mario Carneiro (Apr 10 2020 at 23:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="264734">Donald Sebastian Leung</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193573217" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193573217">said</a>:</p>
<blockquote>
<p>You get two <code>foo</code>s in your context, and IIRC the latest <code>foo</code> shadows the earlier one (so later tactics referring to <code>foo</code> would only see the latest one)</p>
</blockquote>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193573454" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193573454">said</a>:</p>
<blockquote>
<p>Honestly I also wish Lean would rise at least a warning in this situation.</p>
</blockquote>
<p>Actually lean does raise a warning in this situation, at least in some cases, especially after a tactic fails; it will suggest that you run the <code>dedup</code> tactic</p>

<a name="193630451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193630451" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193630451">Mario Carneiro (Apr 10 2020 at 23:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="264734">Donald Sebastian Leung</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193573371" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193573371">said</a>:</p>
<blockquote>
<p>This is one of the things that sometimes gets me in Lean, but doesn't happen in Coq.</p>
</blockquote>
<p>What does Coq do in this situation? It seems to me that if we gave a warning on every name shadowing we would get a ridiculous number of false positives, especially because <code>have := ...</code> is deliberately reusing and shadowing the <code>this</code> variable</p>

<a name="193642736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193642736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193642736">Filip Szczepański (Apr 11 2020 at 04:59)</a>:</h4>
<p>Having some trouble figuring out how to get started on <code>le_total</code> in the natural number game. I'm guessing this is the next level that people tend to get stuck on, after <code>mul_left_cancel</code>?</p>

<a name="193644247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193644247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193644247">Victor Ahlquist (Apr 11 2020 at 05:51)</a>:</h4>
<p>I can't recall exactly how I did but I think I started with induction on b</p>

<a name="193644372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193644372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193644372">Shing Tak Lam (Apr 11 2020 at 05:55)</a>:</h4>
<p>I think you need to <code>revert a</code> first.</p>

<a name="193644550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193644550" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193644550">Shing Tak Lam (Apr 11 2020 at 06:00)</a>:</h4>
<p>So my proof starts with</p>
<div class="codehilite"><pre><span></span>  <span class="n">revert</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">b</span> <span class="k">with</span> <span class="n">b</span> <span class="n">IH</span><span class="o">,</span>
</pre></div>

<a name="193645155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193645155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193645155">Filip Szczepański (Apr 11 2020 at 06:22)</a>:</h4>
<p>Thanks, the revert certainly seems handy</p>

<a name="193645256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193645256" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193645256">Donald Sebastian Leung (Apr 11 2020 at 06:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193630451" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193630451">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="264734">Donald Sebastian Leung</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193573371" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193573371">said</a>:</p>
<blockquote>
<p>This is one of the things that sometimes gets me in Lean, but doesn't happen in Coq.</p>
</blockquote>
<p>What does Coq do in this situation? It seems to me that if we gave a warning on every name shadowing we would get a ridiculous number of false positives, especially because <code>have := ...</code> is deliberately reusing and shadowing the <code>this</code> variable</p>
</blockquote>
<p>Coq simply prevents you from reusing hypothesis names by raising an error. On the other hand, if you don't explicitly name your hypotheses in Coq then Coq just auto-generates gibberish hypothesis names instead of (re-using) a nice name such as <code>this</code></p>

<a name="193646177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193646177" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193646177">Mario Carneiro (Apr 11 2020 at 06:58)</a>:</h4>
<p>One thing we could do is make <code>have</code> have the same behavior as <code>replace</code>, that is, if the name would collide then the old version is deleted</p>

<a name="193646202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193646202" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193646202">Mario Carneiro (Apr 11 2020 at 06:59)</a>:</h4>
<p>however this could still break some proofs because you can refer to shadowed variables using <code>assumption</code> and other things that enumerate the local context</p>

<a name="193646745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193646745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193646745">Victor Ahlquist (Apr 11 2020 at 07:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="266440">Shing Tak Lam</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193644372" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193644372">said</a>:</p>
<blockquote>
<p>I think you need to <code>revert a</code> first.</p>
</blockquote>
<p>What's the purpose of revert in this case? Will it lead to a shorter proof?</p>

<a name="193646809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193646809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193646809">Victor Ahlquist (Apr 11 2020 at 07:18)</a>:</h4>
<div class="codehilite"><pre><span></span>induction b with b IH,
right,
exact zero_le a,
cases IH with p q,
left,
exact le_succ a b p,
cases q with c,
cases c,
use succ(0),
rw q_h,
refl,
right,
use c,
rw q_h,
rw succ_add,
rw add_succ,
refl,
</pre></div>


<p>I redid it and got this.</p>

<a name="193646859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193646859" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193646859">Victor Ahlquist (Apr 11 2020 at 07:20)</a>:</h4>
<p>Actually the second last line is redundant.</p>

<a name="193646864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193646864" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193646864">Shing Tak Lam (Apr 11 2020 at 07:21)</a>:</h4>
<p>This is my proof with <code>revert a</code></p>
<div class="codehilite"><pre><span></span>  <span class="n">revert</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">b</span> <span class="k">with</span> <span class="n">b</span> <span class="n">IH</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">right</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">zero_le</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">a</span> <span class="k">with</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">left</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">zero_le</span> <span class="bp">_</span><span class="o">,</span>
      <span class="n">cases</span> <span class="o">(</span><span class="n">IH</span> <span class="n">a</span><span class="o">),</span>
        <span class="n">left</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">succ_le_succ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">right</span><span class="o">,</span>
        <span class="n">exact</span> <span class="n">succ_le_succ</span> <span class="n">b</span> <span class="n">a</span> <span class="n">h</span><span class="o">,</span>
</pre></div>


<p>So it's a bit shorter?</p>

<a name="193646865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193646865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193646865">Donald Sebastian Leung (Apr 11 2020 at 07:21)</a>:</h4>
<p><span class="user-mention silent" data-user-id="282867">Victor Ahlquist</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193646745" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193646745">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="266440">Shing Tak Lam</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193644372" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193644372">said</a>:</p>
<blockquote>
<p>I think you need to <code>revert a</code> first.</p>
</blockquote>
<p>What's the purpose of revert in this case? Will it lead to a shorter proof?</p>
</blockquote>
<p>Notice the difference in your IH with and without <code>revert</code>.</p>

<a name="193646922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193646922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193646922">Shing Tak Lam (Apr 11 2020 at 07:23)</a>:</h4>
<p>But the main reason was to do with the induction hypothesis. The IH after using <code>revert a</code> is much easier to use than the one without.</p>

<a name="193646976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193646976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193646976">Kevin Buzzard (Apr 11 2020 at 07:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="284527">Filip Szczepański</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193611904" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193611904">said</a>:</p>
<blockquote>
<p>I have <code>hb : b = b + d + c</code> and I'm wondering if there's a more straightforward way to get to <code>0 = d + c</code> than going through ← add_zero, add_assoc and add_left_cancel</p>
</blockquote>
<p>If you're working with usual Lean naturals then the <code>omega</code> tactic will solve this for you:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">d</span> <span class="bp">+</span> <span class="n">c</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">omega</span>
</pre></div>


<p>But if you're working with home-grown naturals like <code>mynat</code> then you might have to work harder.</p>

<a name="193646981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193646981" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193646981">Victor Ahlquist (Apr 11 2020 at 07:24)</a>:</h4>
<p>Ah I see, it does look like a more powerful hypothesis.</p>

<a name="193647041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193647041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193647041">Victor Ahlquist (Apr 11 2020 at 07:27)</a>:</h4>
<p>Guess I'm just scared of quantifiers in Lean</p>

<a name="193660769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193660769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193660769">Victor Ahlquist (Apr 11 2020 at 13:33)</a>:</h4>
<p>There's not much explanation of this in the book, but why does a list have Type u \r Type u as it's type?</p>

<a name="193660832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193660832" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193660832">Kenny Lau (Apr 11 2020 at 13:34)</a>:</h4>
<p>Given a type <code>\a</code>, <code>list \a</code> is a type</p>

<a name="193660849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193660849" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193660849">Kenny Lau (Apr 11 2020 at 13:34)</a>:</h4>
<p>So <code>list</code> itself sends types to types</p>

<a name="193660874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193660874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193660874">Victor Ahlquist (Apr 11 2020 at 13:35)</a>:</h4>
<p>Ah right, that makes sense thanks.</p>

<a name="193670800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193670800" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193670800">Grayson Burton (Apr 11 2020 at 17:34)</a>:</h4>
<p>Why don't interactive theorem provers (including Lean to my knowledge) provide a recursor for <code>Type</code>? Does it cause ""fun"" I'm not noticing in my few minutes' consideration?</p>

<a name="193670866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193670866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193670866">Johan Commelin (Apr 11 2020 at 17:35)</a>:</h4>
<p>What would that look like?</p>

<a name="193671144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193671144" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193671144">Grayson Burton (Apr 11 2020 at 17:41)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">wacky</span><span class="o">:</span> <span class="kt">Type</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="bp">|</span> <span class="o">(</span><span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ulift</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">string</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ulift</span> <span class="n">string</span>
<span class="bp">|</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">ulift</span> <span class="n">α</span>
</pre></div>


<p>Something like this?</p>

<a name="193671197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193671197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193671197">Grayson Burton (Apr 11 2020 at 17:42)</a>:</h4>
<p>Obviously a contrived example :)</p>

<a name="193671213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193671213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193671213">Kenny Lau (Apr 11 2020 at 17:43)</a>:</h4>
<p><code>Type</code> is not inductive.</p>

<a name="193671221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193671221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193671221">Kenny Lau (Apr 11 2020 at 17:43)</a>:</h4>
<p>you can use <code>if then else</code> instead.</p>

<a name="193671297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193671297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193671297">Grayson Burton (Apr 11 2020 at 17:45)</a>:</h4>
<p>Oh, right. Of course, thanks.</p>

<a name="193674540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193674540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193674540">David Wärn (Apr 11 2020 at 19:03)</a>:</h4>
<p>Isn't <code>(ℕ → ℕ) ≠ (string → ℕ)</code> unprovable? If so you'd have little hope of being able to functions as above</p>

<a name="193675222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193675222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193675222">Reid Barton (Apr 11 2020 at 19:20)</a>:</h4>
<p>For anything like this you'd actually want to do, you'd probably want to use classes instead.</p>

<a name="193683771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193683771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193683771">Mario Carneiro (Apr 11 2020 at 22:57)</a>:</h4>
<p>Assuming you want an actual recursor and not just pick off a few cases, it's not consistent. Because there are types you can construct using choice that are provably different from every "constructable" type (since there are countably many constructable types and so there is some aleph less than aleph_(aleph_1) that was missed)</p>

<a name="193684464"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193684464" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193684464">Brandon B (Apr 11 2020 at 23:20)</a>:</h4>
<p>So I see one aim of Lean would be to implement as much of modern mathematics into it as possible, starting with all of undergrad math as Kevin Buzzard is doing so that research level math can eventually be done.  My question is, if we already have a bunch of theorems that have been proved with paper and pencil, why can't we just add them in as constants (basically assuming they're true w/o explicit construction of a proof) and build from there?</p>

<a name="193684527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193684527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193684527">Andrew Ashworth (Apr 11 2020 at 23:23)</a>:</h4>
<p>the exact formal statement of a mathematical theorem can be extremely subtle, at times</p>

<a name="193684593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193684593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193684593">Andrew Ashworth (Apr 11 2020 at 23:24)</a>:</h4>
<p>using them all over the place defeats the purpose of formalization, in terms of checking correctness of proofs</p>

<a name="193684596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193684596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193684596">Mario Carneiro (Apr 11 2020 at 23:24)</a>:</h4>
<p>I think this is fine in limited quantities</p>

<a name="193684601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193684601" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193684601">Mario Carneiro (Apr 11 2020 at 23:24)</a>:</h4>
<p>FAbstracts is using essentially this method</p>

<a name="193684613"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193684613" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193684613">Andrew Ashworth (Apr 11 2020 at 23:25)</a>:</h4>
<p>i don't think there's any getting around using them here and there, especially for results that depend on a whole bunch of other material</p>

<a name="193684670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193684670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193684670">Mario Carneiro (Apr 11 2020 at 23:26)</a>:</h4>
<p>Maybe I'm not looking at the right theorems, but it's not very often I see a theorem where the statement is tractable but the proof is not, that I want to assume for something else</p>

<a name="193684674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193684674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193684674">Mario Carneiro (Apr 11 2020 at 23:26)</a>:</h4>
<p>most of the time the theorem would be some work but not unreasonably so</p>

<a name="193684681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193684681" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193684681">Mario Carneiro (Apr 11 2020 at 23:27)</a>:</h4>
<p>and I feel much better about the result afterwards</p>

<a name="193684689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193684689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193684689">Mario Carneiro (Apr 11 2020 at 23:27)</a>:</h4>
<p>or else the statement of the theorem is already hopeless requiring some big library development that doesn't yet exist</p>

<a name="193684734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193684734" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193684734">Mario Carneiro (Apr 11 2020 at 23:28)</a>:</h4>
<p>after all, it's not enough just to state the theorem, you also have to be able to prove the basic consequences of all the definitions used in the theorem if you expect to build on top of an assumption with that statement</p>

<a name="193685145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193685145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193685145">Scott Morrison (Apr 11 2020 at 23:40)</a>:</h4>
<p>Note in Mario's statement the all-important clause "that I want to assume for something else". FLT would be a great counterexample to his claim otherwise, but actually fits perfectly. :-) We are very far from being able to state the "actual usable theorems" associated to FLT.</p>

<a name="193685499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193685499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193685499">Brandon B (Apr 11 2020 at 23:51)</a>:</h4>
<p>On another note - is there a way to compose functions left to right in Lean? e.g. it gets tiresome doing h(g(f(x))) when I'd rather do something like x&gt;f&gt;g&gt;h</p>

<a name="193685611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193685611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193685611">Mario Carneiro (Apr 11 2020 at 23:54)</a>:</h4>
<p>I recall seeing isabelle using the <code>|&gt;</code> notation for this, although we will have to take that notation back from the useless <code>option.lhoare</code></p>

<a name="193685625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193685625" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193685625">Mario Carneiro (Apr 11 2020 at 23:55)</a>:</h4>
<p>You can use <code>h $ g $ f $ x</code> to make the chain more linear but that doesn't resolve the order</p>

<a name="193685628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193685628" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193685628">Mario Carneiro (Apr 11 2020 at 23:55)</a>:</h4>
<p>Oh wait, I just remembered that we already did this</p>

<a name="193685631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193685631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193685631">Mario Carneiro (Apr 11 2020 at 23:55)</a>:</h4>
<p>it's <code>$&lt;</code></p>

<a name="193685633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193685633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193685633">Mario Carneiro (Apr 11 2020 at 23:55)</a>:</h4>
<p>in one of the mathlib files</p>

<a name="193685639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193685639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193685639">Andrew Ashworth (Apr 11 2020 at 23:55)</a>:</h4>
<p>... I wish it was |&gt;, that's the pipeline operator in multiple fp languages, not just isabelle</p>

<a name="193685684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193685684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193685684">Mario Carneiro (Apr 11 2020 at 23:56)</a>:</h4>
<p>now that we've taken over core we can delete those notations</p>

<a name="193685690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193685690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193685690">Mario Carneiro (Apr 11 2020 at 23:56)</a>:</h4>
<p>which have been used literally zero times</p>

<a name="193685698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193685698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193685698">Mario Carneiro (Apr 11 2020 at 23:57)</a>:</h4>
<p>even the functions they abbreviate  are never used</p>

<a name="193688429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193688429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193688429">Anas Himmi (Apr 12 2020 at 01:27)</a>:</h4>
<p>how to prove this?</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">nat</span><span class="bp">.</span><span class="n">rec_on_sup</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span> <span class="n">i</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span><span class="o">:</span><span class="n">n</span> <span class="bp">≥</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hi</span><span class="o">:</span> <span class="n">C</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">C</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:</span> <span class="n">C</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>when i do a proof by induction like this:</p>
<div class="codehilite"><pre><span></span><span class="k">begin</span>
<span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
<span class="o">{</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">eq_bot_iff</span><span class="bp">.</span><span class="n">mpr</span> <span class="n">hp</span><span class="o">]</span> <span class="n">at</span> <span class="n">hi</span><span class="o">},</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>i get this goal state:</p>
<div class="codehilite"><pre><span></span><span class="mi">1</span> <span class="n">goal</span>
<span class="n">case</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span>
<span class="n">C</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">i</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">hi</span> <span class="o">:</span> <span class="n">C</span> <span class="n">i</span><span class="o">,</span>
<span class="n">hr</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">C</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">),</span>
<span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">hn</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">C</span> <span class="n">n</span><span class="o">,</span>
<span class="n">hp</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">i</span>
<span class="err">⊢</span> <span class="n">C</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span>
</pre></div>


<p>so i can't access <code>hn</code></p>

<a name="193699650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193699650" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193699650">Kevin Buzzard (Apr 12 2020 at 07:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="243102">Brandon B</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193684464" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193684464">said</a>:</p>
<blockquote>
<p>starting with all of undergrad math as Kevin Buzzard is doing </p>
</blockquote>
<p>I might have been one of the people who thought it was a good idea to focus on undergraduate mathematics, but when it comes to <em>doing</em> it, much of the community is involved and I am only playing an extremely small part. For example the basic theory of multivariable calculus, manifolds etc is (a) undoubtedly undergraduate mathematics (b) <em>extremely</em> subtle to do in a theorem prover (c) something I have had absolutely nothing to do with and (d) currently making <em>huge</em> progress thanks to people like <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> and <span class="user-mention" data-user-id="110031">@Patrick Massot</span> and <span class="user-mention" data-user-id="214703">@Yury G. Kudryashov</span> and others. I am the loud Lean public relations guy with access to a mathematical audience and this plays some role, but this is not "my project" in any way: it is the project I am passionate about, but that's something different.</p>

<a name="193708751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193708751" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193708751">Jason KY. (Apr 12 2020 at 11:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="272823">Anas Himmi</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193688429" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193688429">said</a>:</p>
<blockquote>
<p>how to prove this?</p>
</blockquote>
<p>I solved it by taking the cases of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i \le n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> then doing an induction on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i &lt; n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">lemma</span> <span class="n">nat</span><span class="bp">.</span><span class="n">rec_on_sup</span>
<span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span> <span class="n">i</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hi</span> <span class="o">:</span> <span class="n">C</span> <span class="n">i</span><span class="o">)</span>
<span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">C</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">C</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:</span> <span class="n">C</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">lt_or_eq_of_le</span> <span class="n">hp</span><span class="o">,</span>
    <span class="o">{</span><span class="n">induction</span> <span class="n">h</span> <span class="k">with</span> <span class="n">k</span> <span class="n">hle</span> <span class="n">ht</span><span class="o">,</span>
      <span class="o">{</span><span class="n">exact</span> <span class="n">hr</span> <span class="n">i</span> <span class="n">hi</span><span class="o">},</span>
      <span class="n">replace</span> <span class="n">hle</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">≤</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">hle</span><span class="o">,</span>
      <span class="n">refine</span> <span class="n">hr</span> <span class="n">k</span> <span class="o">(</span><span class="n">ht</span> <span class="err">$</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_succ</span> <span class="n">i</span><span class="o">)</span> <span class="n">hle</span><span class="o">)},</span>
    <span class="n">rwa</span> <span class="err">←</span><span class="n">h</span>
<span class="kn">end</span>
</pre></div>

<a name="193708928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193708928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193708928">Anas Himmi (Apr 12 2020 at 11:23)</a>:</h4>
<p>Woow thank you!</p>

<a name="193709072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193709072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193709072">Kevin Buzzard (Apr 12 2020 at 11:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193684670" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193684670">said</a>:</p>
<blockquote>
<p>Maybe I'm not looking at the right theorems, but it's not very often I see a theorem where the statement is tractable but the proof is not, that I want to assume for something else</p>
</blockquote>
<p>So in more serious mathematics this phenomenon shows up a lot -- I would say it's more the rule than the exception. But the point remains that at the level I'm talking about we cannot currently state the results we are interested in because we don't have the definitions in mathlib. Cheating on a definition has far more serious consequences than cheating on a proof -- indeed IIRC someone once posted an example where if you cheated on a definition then you got a proof for free, which isn't ideal because then when someone fills in the actual definition, the proof breaks.</p>

<a name="193709138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193709138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193709138">Kevin Buzzard (Apr 12 2020 at 11:29)</a>:</h4>
<p><span class="user-mention" data-user-id="243102">@Brandon B</span> I am hoping that once we have a ton of meaty definitions, e.g. in algebraic geometry, then there will be a lot of scope for stating interesting theorems and skipping proofs (not in mathlib, but in another place where one is concentrating on e.g. making search for mathematicians)</p>

<a name="193709206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193709206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193709206">Kevin Buzzard (Apr 12 2020 at 11:31)</a>:</h4>
<p>Unfortunately, there are a bunch of interesting theorems in mathematics about etale cohomology of Noetherian schemes, and it is going to take a whole bunch of category theory to even define etale cohomology. Maybe one cheap definition uses derived functors on an abelian category, but we don't even have abelian categories yet.</p>

<a name="193709291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193709291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193709291">Mario Carneiro (Apr 12 2020 at 11:33)</a>:</h4>
<blockquote>
<p>So in more serious mathematics this phenomenon shows up a lot -- I would say it's more the rule than the exception. But the point remains that at the level I'm talking about we cannot currently state the results we are interested in because we don't have the definitions in mathlib.</p>
</blockquote>
<p>Right, I certainly get the impression that deep theorems abound in higher mathematics, but most of these theorems are not in an accessible place from the point of view of definitions. You spent a bunch of time and effort on perfectoid spaces -- can we state the tilting lemma now? Can we prove basic (and I mean really basic) properties about perfectoid spaces?</p>

<a name="193709342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193709342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193709342">Kevin Buzzard (Apr 12 2020 at 11:34)</a>:</h4>
<p>We can't state Scholze's tilting theorem yet because we still need a load more machinery.</p>

<a name="193709357"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193709357" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193709357">Mario Carneiro (Apr 12 2020 at 11:35)</a>:</h4>
<p>Do you know any place where we would get a lot of mileage out of assuming a hard theorem that we can state today?</p>

<a name="193709362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193709362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193709362">Kevin Buzzard (Apr 12 2020 at 11:35)</a>:</h4>
<p>This might sound like a stupid thing to say, but I'm not sure there are any basic theorems about perfectoid spaces. I know that in UG maths you make a new object e.g. a ring, and then all of a sudden you can ask if the product of rings is a ring or whatever, but life is not like that on the mountains.</p>

<a name="193709401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193709401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193709401">Mario Carneiro (Apr 12 2020 at 11:36)</a>:</h4>
<p>I can imagine that something like that could unlock complex analysis</p>

<a name="193709405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193709405" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193709405">Kevin Buzzard (Apr 12 2020 at 11:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193709357" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193709357">said</a>:</p>
<blockquote>
<p>Do you know any place where we would get a lot of mileage out of assuming a hard theorem that we can state today?</p>
</blockquote>
<p>No. FLT is useless.</p>

<a name="193709411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193709411" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193709411">Kevin Buzzard (Apr 12 2020 at 11:36)</a>:</h4>
<p>For complex analysis there is still the issue of figuring out what we're going to integrate around and I would imagine that we'd need a bunch of API for whatever it turns out to be before we can get going</p>

<a name="193709804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193709804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193709804">Filip Szczepański (Apr 12 2020 at 11:48)</a>:</h4>
<p><code>not_succ_le_self</code> in the NNG mentions <code>conv begin</code>, but I'm not sure how one would actually use it. My solution ended up just doing a simple induction on a and is only seven lines, and I don't see where conv could be slotted in</p>

<a name="193709823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193709823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193709823">Kevin Buzzard (Apr 12 2020 at 11:49)</a>:</h4>
<p>Oh that's great. I can quite believe that my solutions aren't optimal.</p>

<a name="193709870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193709870" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193709870">Kevin Buzzard (Apr 12 2020 at 11:50)</a>:</h4>
<p>The <code>conv</code> thing is just a very poorly-explained description of how to rewrite on only one side of an expression.</p>

<a name="193710773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193710773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193710773">Filip Szczepański (Apr 12 2020 at 12:17)</a>:</h4>
<p>It doesn't seem like either of the solutions for it in the NNG repo uses conv either</p>

<a name="193710816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193710816" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193710816">Kevin Buzzard (Apr 12 2020 at 12:18)</a>:</h4>
<p>I thought I just checked that the "official" one (in src/game) did</p>

<a name="193711140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193711140" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193711140">Filip Szczepański (Apr 12 2020 at 12:30)</a>:</h4>
<p>Ah, right, I was looking at the old ones</p>

<a name="193711182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193711182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193711182">Filip Szczepański (Apr 12 2020 at 12:30)</a>:</h4>
<p>My solution ended up just being</p>
<div class="codehilite"><pre><span></span><span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">c</span> <span class="n">h</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">a</span> <span class="k">with</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">succ_add</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">zero_ne_succ</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span>

  <span class="n">rw</span> <span class="n">succ_add</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">ha</span><span class="o">(</span><span class="n">succ_inj</span> <span class="n">h</span><span class="o">),</span>
</pre></div>

<a name="193711237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193711237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193711237">Filip Szczepański (Apr 12 2020 at 12:32)</a>:</h4>
<p>I think my job just ended up being a lot easier because I did the <code>cases</code> before the <code>induction</code> instead of after?</p>

<a name="193712258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193712258" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193712258">Victor Ahlquist (Apr 12 2020 at 13:01)</a>:</h4>
<p>Any idea why this doesn't work? </p>
<div class="codehilite"><pre><span></span>example : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) := iff.intro
    (assume h : (p ∨ q) → r,

        have f1 : p → r, from
            assume h1 : p,
            h (or.intro_left q h1),
        have f2 : q → r, from
            assume h1 : q,
            h (or.intro_right p h1),
        and.intro f1 f2,
    )
</pre></div>

<a name="193712306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193712306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193712306">Victor Ahlquist (Apr 12 2020 at 13:02)</a>:</h4>
<p>I get error message</p>
<div class="codehilite"><pre><span></span>type mismatch at application
  prod.mk _
term
  λ (h : p ∨ q → r),
    have f1 : p → r, from λ (h1 : p), h (or.intro_left q h1),
    have f2 : q → r, from λ (h1 : q), h (or.intro_right p h1),
    ⟨f1, f2⟩
has type
  (p ∨ q → r) → (p → r) ∧ (q → r) : Prop
but is expected to have type
  ?m_1 : Type ?
Additional information:
c:\Users\Victor\Desktop\LeanMath\my_project\src\test.lean:139:4: context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    (?m_3, ?m_4)
  has type
    ?m_1 × ?m_2 : Type (max ? ?)
  but is expected to have type
    (p ∨ q → r) → (p → r) ∧ (q → r) : Prop
</pre></div>

<a name="193712346"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193712346" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193712346">Victor Ahlquist (Apr 12 2020 at 13:03)</a>:</h4>
<p>Nvm just an extra comma.</p>

<a name="193712444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193712444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193712444">Kevin Buzzard (Apr 12 2020 at 13:05)</a>:</h4>
<p>Commas are a nightmare to track down in this verbose term mode.</p>

<a name="193712493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193712493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193712493">Kevin Buzzard (Apr 12 2020 at 13:06)</a>:</h4>
<p>Start like this:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_⟩</span>
</pre></div>


<p>and go on from there, you're always in control then.</p>

<a name="193712497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193712497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193712497">Reid Barton (Apr 12 2020 at 13:07)</a>:</h4>
<p>I'm surprised you didn't get some kind of parse error</p>

<a name="193712502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193712502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193712502">Reid Barton (Apr 12 2020 at 13:07)</a>:</h4>
<p>Is <code>(a, )</code> a tuple section (<code>prod.mk a</code>) or something?</p>

<a name="193712609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193712609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193712609">Kevin Buzzard (Apr 12 2020 at 13:09)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">⟨λ</span> <span class="n">h</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">h1</span><span class="o">,</span> <span class="n">h</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">intro_left</span> <span class="n">q</span> <span class="n">h1</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="bp">_⟩</span>
</pre></div>


<p>etc</p>

<a name="193712754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193712754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193712754">Filip Szczepański (Apr 12 2020 at 13:13)</a>:</h4>
<p>Would it make sense to replace the solutions in the repo with simpler ones where viable?</p>

<a name="193712859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193712859" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193712859">Kevin Buzzard (Apr 12 2020 at 13:16)</a>:</h4>
<p>I don't really ever explicitly link to the repo but I guess there would be no harm in doing so in the future.</p>

<a name="193713175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193713175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193713175">Victor Ahlquist (Apr 12 2020 at 13:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193712493" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193712493">said</a>:</p>
<blockquote>
<p>Start like this:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_⟩</span>
</pre></div>


<p>and go on from there, you're always in control then.</p>
</blockquote>
<p>Looks like a good way to do it. Starting from the bottom.</p>

<a name="193716814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193716814" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193716814">Victor Ahlquist (Apr 12 2020 at 15:08)</a>:</h4>
<p>Any advice on how to complete:</p>
<div class="codehilite"><pre><span></span>example : ¬(p ↔ ¬p) :=
</pre></div>


<p>without law of the excluded middle?</p>

<a name="193716829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193716829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193716829">Kevin Buzzard (Apr 12 2020 at 15:09)</a>:</h4>
<p>congratulations on being the 1000th person to ask this question on the chat :-) Yeah, that's a great question! It's in TPIL right?</p>

<a name="193716832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193716832" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193716832">Kevin Buzzard (Apr 12 2020 at 15:09)</a>:</h4>
<p>It can be done :-)</p>

<a name="193716896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193716896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193716896">Victor Ahlquist (Apr 12 2020 at 15:11)</a>:</h4>
<p>This was a tough one, I'll have to think a bit more then</p>

<a name="193716941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193716941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193716941">Victor Ahlquist (Apr 12 2020 at 15:12)</a>:</h4>
<p>And yes, it is in TPIL chapter 3</p>

<a name="193717151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193717151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193717151">Bryan Gin-ge Chen (Apr 12 2020 at 15:18)</a>:</h4>
<p>I once wrote a relatively detailed post on how to prove that one via "chasing underscores". <a href="#narrow/stream/113489-new-members/topic/basics/near/185070320" title="#narrow/stream/113489-new-members/topic/basics/near/185070320">See here to get "spoiled"</a>, though it should be written in a way where you can stop and try things out for yourself at each step.</p>

<a name="193717451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193717451" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193717451">Victor Ahlquist (Apr 12 2020 at 15:27)</a>:</h4>
<p>Might have an idea</p>

<a name="193717457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193717457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193717457">Victor Ahlquist (Apr 12 2020 at 15:27)</a>:</h4>
<p>Is it possible to use other examples you've proved?</p>

<a name="193717633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193717633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193717633">Bryan Gin-ge Chen (Apr 12 2020 at 15:32)</a>:</h4>
<p>The beginning of that post links to <a href="#narrow/stream/113489-new-members/topic/.60or.60.20implication/near/184439048" title="#narrow/stream/113489-new-members/topic/.60or.60.20implication/near/184439048">this example</a>. I also apparently did <a href="#narrow/stream/113489-new-members/topic/Logic.20in.20LEAN/near/136958565" title="#narrow/stream/113489-new-members/topic/Logic.20in.20LEAN/near/136958565">an exercise from Logic &amp; Proof</a> this way.</p>

<a name="193717739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193717739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193717739">Victor Ahlquist (Apr 12 2020 at 15:35)</a>:</h4>
<p>Well I don't want any spoilers. I just mean if it is possible in lean to reference a proof you have done earlier as an example.</p>

<a name="193717803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193717803" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193717803">Victor Ahlquist (Apr 12 2020 at 15:37)</a>:</h4>
<p>The proof I wanted to reference was quite short so I just copied now, but would be good to know for future use.</p>

<a name="193717884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193717884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193717884">Bryan Gin-ge Chen (Apr 12 2020 at 15:39)</a>:</h4>
<p>Oh, sorry, I misinterpreted "you" in that reply. No, to reference a previous result it has to be a named <code>theorem</code> or <code>lemma</code> or <code>def</code>.</p>

<a name="193717940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193717940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193717940">Victor Ahlquist (Apr 12 2020 at 15:40)</a>:</h4>
<p>I see, I guess that's quite logical.</p>

<a name="193717941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193717941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193717941">Kevin Buzzard (Apr 12 2020 at 15:40)</a>:</h4>
<p><span class="user-mention" data-user-id="282867">@Victor Ahlquist</span> there's a canonical hint, if you want it.</p>

<a name="193717945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193717945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193717945">Victor Ahlquist (Apr 12 2020 at 15:41)</a>:</h4>
<p>I managed to solve it btw, posting here for anyone interested in my messy solution</p>

<a name="193717948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193717948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193717948">Victor Ahlquist (Apr 12 2020 at 15:41)</a>:</h4>
<div class="codehilite"><pre><span></span>example : ¬(p ↔ ¬p) :=
    (assume h : p ↔ ¬p,
        have h1 : p → ¬p, from iff.elim_left h,
        have h2 : ¬p → p, from iff.elim_right h,
        have h3 : p → false, from
            (assume f : p,
                h1 f f
            ),
        h3 (h2 h3)
    )
</pre></div>

<a name="193717951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193717951" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193717951">Kevin Buzzard (Apr 12 2020 at 15:41)</a>:</h4>
<p>Also, I <a href="https://www.youtube.com/watch?v=POHVMMG7pqE" title="https://www.youtube.com/watch?v=POHVMMG7pqE">made a video</a> about how I would prove your earlier question <code>((p ∨ q) → r) ↔ (p → r) ∧ (q → r)</code>.</p>
<div class="youtube-video message_inline_image"><a data-id="POHVMMG7pqE" href="https://www.youtube.com/watch?v=POHVMMG7pqE" title="https://www.youtube.com/watch?v=POHVMMG7pqE"><img src="https://i.ytimg.com/vi/POHVMMG7pqE/default.jpg"></a></div>

<a name="193717958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193717958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193717958">Kevin Buzzard (Apr 12 2020 at 15:42)</a>:</h4>
<p>Yeah, the hint is "prove <code>not p</code>"</p>

<a name="193718003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193718003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193718003">Kevin Buzzard (Apr 12 2020 at 15:42)</a>:</h4>
<p>Now watch my video and learn how to prove stuff like this without all this assume have stuff :-)</p>

<a name="193718008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193718008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193718008">Victor Ahlquist (Apr 12 2020 at 15:42)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193718003" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193718003">said</a>:</p>
<blockquote>
<p>Now watch my video and learn how to prove stuff like this without all this assume have stuff :-)</p>
</blockquote>
<p>I definitely will :)</p>

<a name="193718022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193718022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193718022">Victor Ahlquist (Apr 12 2020 at 15:43)</a>:</h4>
<p>Just need a minute to wrap my mind around what I just did, felt like a bunch of symbol pushing</p>

<a name="193718224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193718224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193718224">Bryan Gin-ge Chen (Apr 12 2020 at 15:49)</a>:</h4>
<p>Well, <code>assume</code> is just long-hand for <code> λ</code>. I wouldn't avoid using <code>have</code>, though I'm used to using "<code>:=</code>" instead of "<code>, from</code>".</p>

<a name="193718301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193718301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193718301">Victor Ahlquist (Apr 12 2020 at 15:51)</a>:</h4>
<p>Now that you say it, I remember that the notation in NNG was indeed := not from</p>

<a name="193718314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193718314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193718314">Victor Ahlquist (Apr 12 2020 at 15:51)</a>:</h4>
<p>I'm going through TPIL so I'm copying the notation from there.</p>

<a name="193718378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193718378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193718378">Kevin Buzzard (Apr 12 2020 at 15:53)</a>:</h4>
<p>TPIL gets on to tactic mode in chapter 5 and for mathematicians tactic mode is far less painful than all this assume stuff.</p>

<a name="193718381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193718381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193718381">Kevin Buzzard (Apr 12 2020 at 15:53)</a>:</h4>
<p>The natural number game is 100% tactic mode</p>

<a name="193718610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193718610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193718610">Bryan Gin-ge Chen (Apr 12 2020 at 15:59)</a>:</h4>
<p>Hmm, for some reason I thought the syntax <code>have h, from blah</code> only worked in term mode, but apparently it can be used in tactic mode as well.</p>

<a name="193718684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193718684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193718684">Victor Ahlquist (Apr 12 2020 at 16:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193718378" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193718378">said</a>:</p>
<blockquote>
<p>TPIL gets on to tactic mode in chapter 5 and for mathematicians tactic mode is far less painful than all this assume stuff.</p>
</blockquote>
<p>Yeah tactic mode is nicer for getting an overview of the proof and what needs to be done. I'm still intimated by all the lambda notation in term mode as you might have noticed from my code.</p>

<a name="193718969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193718969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193718969">Victor Ahlquist (Apr 12 2020 at 16:09)</a>:</h4>
<p>For me writing all the "assume" makes the code more understandable, but I guess that will change as I get more familiar with Lean.</p>

<a name="193719243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193719243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193719243">Bryan Gin-ge Chen (Apr 12 2020 at 16:17)</a>:</h4>
<p>Now that you've solved it, did you have a look at the "spoiler" posts I linked? Presumably your thought process was not too different from what I described there.</p>
<p>I think it's good that proving simple logical propositions like this feels like symbol pushing. To me it's like getting used to arithmetic or solving algebraic equations in school. Once you're at the stage where these calculations are "just symbol pushing", you can move on to letting a calculator or computer do it for you. In Lean, there are various clever tactics like <a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#cc%20(congruence%20closure)" title="https://leanprover-community.github.io/mathlib_docs/tactics.html#cc%20(congruence%20closure)"><code>cc</code></a> which can solve goals like these automatically.</p>

<a name="193719376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193719376" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193719376">Victor Ahlquist (Apr 12 2020 at 16:21)</a>:</h4>
<p>Ah sorry forgot about the link. Will check it out after dinner.</p>

<a name="193719457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193719457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193719457">PV (Apr 12 2020 at 16:23)</a>:</h4>
<p>Thanks for linking those posts.  It helped get a better feel for not being in tactic mode, but having the same strategy for building out the proof.</p>

<a name="193719699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193719699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193719699">Bryan Gin-ge Chen (Apr 12 2020 at 16:29)</a>:</h4>
<p>Yeah, once I learned to read and use the error messages, term mode became a lot less intimidating. I think in principle we could hack Lean to show info in the goal window when putting your cursor in a term mode proof, but that's beyond my abilities. For example, a while back, <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  showed a neat trick where you insert <code>by {}; exact</code> somewhere in a term mode proof and then putting your cursor inside <code>{}</code> shows the context.</p>

<a name="193721002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721002">Victor Ahlquist (Apr 12 2020 at 17:05)</a>:</h4>
<p>That was a nice method with the underscores, will probably come in handy in the future. When I did the problem I noticed that p \r p\r false is the same as p \and p \r false which simplifies to p \r false.</p>

<a name="193721216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721216">Alex Mira (Apr 12 2020 at 17:11)</a>:</h4>
<p>Hey, this thread is for noob members right? I've spent the last few days playing around with lean, I finished the Nat Num game, and yesterday I downloaded elan to my computer.  There's a lotta things I don't understand rn, but currently I'm just wondering how much the base version of Lean knows? It seems to have a \nat type that works well, and an \int type as well but I'm not sure if that one works. It just evaluated 5 - 7 to 0? I've heard there are libraries I could download, but I'd also like the practice of building up to the real numbers myself, if that's possible. Anyway, I'm mostly looking for a place to start, can anyone help me out?</p>

<a name="193721344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721344">Patrick Massot (Apr 12 2020 at 17:15)</a>:</h4>
<p>Numbers 5 and 7 are interpreted as natural numbers by default, so Lean used nat subtraction which has type <code>nat -&gt; nat -&gt; nat</code>. Then read <a href="#narrow/stream/113489-new-members/topic/integer.20subtraction.20.2F.20rational.20division/near/192901989" title="#narrow/stream/113489-new-members/topic/integer.20subtraction.20.2F.20rational.20division/near/192901989">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/integer.20subtraction.20.2F.20rational.20division/near/192901989</a></p>

<a name="193721354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721354">Patrick Massot (Apr 12 2020 at 17:15)</a>:</h4>
<p>Defining real numbers from core library only is way too ambitious as a beginner goal. But you can play with mathlib real numbers.</p>

<a name="193721402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721402">Kevin Buzzard (Apr 12 2020 at 17:16)</a>:</h4>
<p>What's your background <span class="user-mention" data-user-id="284744">@Alex Mira</span> ? Maths/CS/other?</p>

<a name="193721427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721427">Bryan Gin-ge Chen (Apr 12 2020 at 17:16)</a>:</h4>
<p>If you haven't already, follow the instructions <a href="https://github.com/leanprover-community/mathlib#installation" title="https://github.com/leanprover-community/mathlib#installation">here</a> for your OS to install <code>leanproject</code> and to set up a Lean project that depends on mathlib.</p>

<a name="193721437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721437">Kevin Buzzard (Apr 12 2020 at 17:17)</a>:</h4>
<p>Took the words out of my mouth :-)</p>

<a name="193721489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721489">Alex Mira (Apr 12 2020 at 17:18)</a>:</h4>
<p>Alright, I'll definitely do that then. My background is in math, I'm an undergrad at U of T</p>

<a name="193721491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721491">Kevin Buzzard (Apr 12 2020 at 17:18)</a>:</h4>
<p>Core Lean knows basic definitions of e.g. a group. Lean's maths library <code>mathlib</code> knows e.g. the theorems a 1st year undergraduate math group theory course, I think it knows one but not all of Sylow's theorems?</p>

<a name="193721493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721493">Bryan Gin-ge Chen (Apr 12 2020 at 17:18)</a>:</h4>
<p>There are some nice resources under "Learn Lean" <a href="https://leanprover-community.github.io/links/" title="https://leanprover-community.github.io/links/">on the "Lean Links" page</a>.</p>

<a name="193721505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721505">Kevin Buzzard (Apr 12 2020 at 17:19)</a>:</h4>
<p>Actually isn't there some link on the docs page where I summarised what mathlib knew last Dec?</p>

<a name="193721513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721513">Kevin Buzzard (Apr 12 2020 at 17:19)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/overview.html" title="https://leanprover-community.github.io/mathlib_docs/overview.html">https://leanprover-community.github.io/mathlib_docs/overview.html</a></p>

<a name="193721515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721515">Alex Mira (Apr 12 2020 at 17:19)</a>:</h4>
<p>I'm interested though, what Lean calls a Group, it wouldn't technically be the same thing that I think of as a group right? Namely, I'm trying to figure out just how much I can treat Types like they're sets.</p>

<a name="193721521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721521">Kevin Buzzard (Apr 12 2020 at 17:20)</a>:</h4>
<p>What Lean thinks a group is is <em>absolutely</em> the same as what you think a group is.</p>

<a name="193721564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721564" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721564">Kevin Buzzard (Apr 12 2020 at 17:20)</a>:</h4>
<p>Here's a question for you. Let G be a group. Let g be an element of G. What is g? Is it a set?</p>

<a name="193721567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721567">Kevin Buzzard (Apr 12 2020 at 17:20)</a>:</h4>
<p>For sure G is a set. But what is g?</p>

<a name="193721568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721568" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721568">Patrick Massot (Apr 12 2020 at 17:20)</a>:</h4>
<p>This is a natural feeling. You simply need to unlearn the lie that people told you you are using set theory.</p>

<a name="193721572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721572">Alex Mira (Apr 12 2020 at 17:20)</a>:</h4>
<p>Heh, I figured the answer would be something like that.</p>

<a name="193721583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721583">Kevin Buzzard (Apr 12 2020 at 17:21)</a>:</h4>
<p>If you set up mathematics in ZFC set theory then <em>everything</em> is a set. This is great for G, which you really want to be a set, but it is not great for g, because you want g to be an "atom" of some kind.</p>

<a name="193721584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721584">Patrick Massot (Apr 12 2020 at 17:21)</a>:</h4>
<p>Type theory is exactly maths the way you think about them, except that you are <em>very</em> good at inserting inclusion maps and isomorphisms, and computer are not quite there yet (but they try really hard).</p>

<a name="193721587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721587" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721587">Kevin Buzzard (Apr 12 2020 at 17:21)</a>:</h4>
<p>In Type theory, G is a Type, and g is a term. They're different things. g doesn't have elements or anything -- it doesn't even make sense to ask what is inside g. g is an atom.</p>

<a name="193721590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721590" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721590">Kenny Lau (Apr 12 2020 at 17:21)</a>:</h4>
<p>I can imagine a parallel universe where one needs to instead unlearn the lie that we are using type theory; my question is, then what are we using that is somehow an abstracted version of type theory and set theory? or is the foundation separate from the maths?</p>

<a name="193721629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721629" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721629">Patrick Massot (Apr 12 2020 at 17:22)</a>:</h4>
<p>And now is dinner time, so I'll let the IC team continue this explanation.</p>

<a name="193721633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721633">Kevin Buzzard (Apr 12 2020 at 17:22)</a>:</h4>
<p>I think you're absolutely right Kenny -- I don't think Gauss was using either type theory or set theory</p>

<a name="193721640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721640">Kenny Lau (Apr 12 2020 at 17:22)</a>:</h4>
<p>so all this nonsense about foundations and two solutions to Russell's Paradox -- what is the point?</p>

<a name="193721641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721641" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721641">Kevin Buzzard (Apr 12 2020 at 17:22)</a>:</h4>
<p><span class="user-mention" data-user-id="284744">@Alex Mira</span> which U of T? There are several :-)</p>

<a name="193721642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721642">Alex Mira (Apr 12 2020 at 17:22)</a>:</h4>
<p>Toronto</p>

<a name="193721650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721650" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721650">Kevin Buzzard (Apr 12 2020 at 17:23)</a>:</h4>
<p>Russell's Paradox has a profound effect on foundations but a mathematician like Poincare will have heard about it and will have realised that it did not affect him in any way whatsoever</p>

<a name="193721703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721703">Kevin Buzzard (Apr 12 2020 at 17:24)</a>:</h4>
<p>The problem with Lean's type theory, as far as mathematicians are concerned, is that if G and H are different types, then there can be no term x of type G and of type H: distinct types are disjoint by definition.</p>

<a name="193721704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721704">Alex Mira (Apr 12 2020 at 17:24)</a>:</h4>
<p>Alright, sounds like my goal rn is to set up a Lean Project, and from there...what are some good goals to set myself if I want to get familiar with the software?</p>

<a name="193721709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721709">Kevin Buzzard (Apr 12 2020 at 17:25)</a>:</h4>
<p>You could try working on some undergrad problems, that's how I learnt Lean</p>

<a name="193721726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721726">Kevin Buzzard (Apr 12 2020 at 17:25)</a>:</h4>
<p>Try proving that the composite of two injective functions is injective.</p>

<a name="193721793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721793">Kenny Lau (Apr 12 2020 at 17:26)</a>:</h4>
<p>just like how you would learn a natural language: you pick it up by using / reading it a lot</p>

<a name="193721804"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721804" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721804">Kenny Lau (Apr 12 2020 at 17:26)</a>:</h4>
<p>and asking us a lot of questions</p>

<a name="193721811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721811">Kenny Lau (Apr 12 2020 at 17:27)</a>:</h4>
<p>with MWEs (Minimal Working Examples)</p>

<a name="193721812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721812" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721812">Kevin Buzzard (Apr 12 2020 at 17:27)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>

<span class="n">def</span> <span class="n">injective</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span>

<span class="kn">lemma</span> <span class="n">injective_comp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">Z</span><span class="o">),</span>
  <span class="n">injective</span> <span class="n">f</span> <span class="bp">∧</span> <span class="n">injective</span> <span class="n">g</span> <span class="bp">→</span> <span class="n">injective</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="193721830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721830">Kevin Buzzard (Apr 12 2020 at 17:27)</a>:</h4>
<p>Note I write <code>a b : X</code> instead of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">a,b\in X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> because I'm using the type theory conventions. <code>a : X</code> means "a is a term of type X" which is just the type theory way of saying "a is an element of the set X"</p>

<a name="193721872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721872">Bryan Gin-ge Chen (Apr 12 2020 at 17:28)</a>:</h4>
<p>I think people often work through <a href="https://leanprover.github.io/theorem_proving_in_lean/" title="https://leanprover.github.io/theorem_proving_in_lean/">Theorem Proving in Lean</a> next. The <a href="https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf" title="https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf">"Hitchhiker's Guide"</a> is a new book that I like too.</p>

<a name="193721876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721876">Kevin Buzzard (Apr 12 2020 at 17:28)</a>:</h4>
<p>And now you can forget that you're doing type theory and just think of it all in set theory because at this sort of level they are the same theory.</p>

<a name="193721879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721879" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721879">Kevin Buzzard (Apr 12 2020 at 17:28)</a>:</h4>
<p>TPIL is a great way to find out more about type theory in this context.</p>

<a name="193721881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721881">Alex Mira (Apr 12 2020 at 17:28)</a>:</h4>
<p>Heh, I already did that, and the surjective one. Those were the challenges that didn't require imports I think. Thanks so much!</p>

<a name="193721883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721883" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721883">Alex Mira (Apr 12 2020 at 17:28)</a>:</h4>
<p>TPIL?</p>

<a name="193721888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721888">Alex Mira (Apr 12 2020 at 17:29)</a>:</h4>
<p>Oh</p>

<a name="193721891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721891" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721891">Kevin Buzzard (Apr 12 2020 at 17:29)</a>:</h4>
<p>I am always in more of a hurry to recommend it to CS people than maths people.</p>

<a name="193721898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721898">Kevin Buzzard (Apr 12 2020 at 17:29)</a>:</h4>
<p>Do you know Florian Herzig Alex?</p>

<a name="193721903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721903">Alex Mira (Apr 12 2020 at 17:29)</a>:</h4>
<p>I do! I'm in his Algebra class!</p>

<a name="193721906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721906" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721906">Bryan Gin-ge Chen (Apr 12 2020 at 17:29)</a>:</h4>
<p>We're still waiting on Kevin to write his book on Lean for Generic Mathematicians... <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p>

<a name="193721909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721909">Kenny Lau (Apr 12 2020 at 17:29)</a>:</h4>
<p>you might not be able to build the theory of real numbers completely; but you'll be sure to learn a lot on the way</p>

<a name="193721926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721926">Kevin Buzzard (Apr 12 2020 at 17:30)</a>:</h4>
<p>Yeah, I'm still working on it.</p>

<a name="193721956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721956">Kevin Buzzard (Apr 12 2020 at 17:30)</a>:</h4>
<p>Books are so 20th century though :-/</p>

<a name="193721964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721964">Kevin Buzzard (Apr 12 2020 at 17:30)</a>:</h4>
<p>Florian works in the same area as me.</p>

<a name="193721983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721983" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721983">Kevin Buzzard (Apr 12 2020 at 17:31)</a>:</h4>
<p>Part of the reason he has tenure at UT is that I wrote him a nice reference letter :-)</p>

<a name="193721989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193721989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193721989">Bryan Gin-ge Chen (Apr 12 2020 at 17:31)</a>:</h4>
<p>I think you can still call it a book even if it has a bunch of interactive bells and whistles.</p>

<a name="193722336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193722336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193722336">Kevin Buzzard (Apr 12 2020 at 17:40)</a>:</h4>
<p><span class="user-mention" data-user-id="284744">@Alex Mira</span> if you have got leanproject working on your computer then you can clone the <a href="https://github.com/ImperialCollegeLondon/group-theory-game" title="https://github.com/ImperialCollegeLondon/group-theory-game">group theory game</a> and open it in VS Code and then fill in the sorrys in src/group/level01.lean</p>

<a name="193722338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193722338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193722338">Kevin Buzzard (Apr 12 2020 at 17:40)</a>:</h4>
<p>This is a work in progress</p>

<a name="193722405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193722405" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193722405">Kevin Buzzard (Apr 12 2020 at 17:42)</a>:</h4>
<div class="codehilite"><pre><span></span>leanproject get ImperialCollegeLondon/group-theory-game
</pre></div>


<p>and then in VS Code go to "open folder" and then open the <code>group-theory-game</code> folder which just appeared in the directory where you were when you ran <code>leanproject</code>.</p>

<a name="193722467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193722467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193722467">Kevin Buzzard (Apr 12 2020 at 17:44)</a>:</h4>
<p>It's really hard to get started with the group theory game, because I only give you the minimal axioms needed for a group. Proving <code>mul_one</code> and <code>mul_right_inv</code> is a bit of a challenge. Then it gets much easier.</p>

<a name="193722556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193722556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193722556">Alex Mira (Apr 12 2020 at 17:46)</a>:</h4>
<p>Sounds fun! Ill definitely try it out.</p>

<a name="193724631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193724631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193724631">Victor Ahlquist (Apr 12 2020 at 18:38)</a>:</h4>
<p>Is there a tactic that applies a function to both sides of an equality?</p>

<a name="193724745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193724745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193724745">Kenny Lau (Apr 12 2020 at 18:41)</a>:</h4>
<p><code>replace h := congr_arg f h</code></p>

<a name="193724875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193724875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193724875">Victor Ahlquist (Apr 12 2020 at 18:44)</a>:</h4>
<p>thanks</p>

<a name="193725045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725045">Kevin Buzzard (Apr 12 2020 at 18:48)</a>:</h4>
<p>This is something which mathematicians frequently want to do -- did <span class="user-mention" data-user-id="110031">@Patrick Massot</span> ever write a tactic to do this?</p>

<a name="193725070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725070">Bryan Gin-ge Chen (Apr 12 2020 at 18:49)</a>:</h4>
<p><a href="https://leanprover-community.github.io/mathlib_docs/tactics.html#apply_fun" title="https://leanprover-community.github.io/mathlib_docs/tactics.html#apply_fun">https://leanprover-community.github.io/mathlib_docs/tactics.html#apply_fun</a></p>

<a name="193725131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725131">Kevin Buzzard (Apr 12 2020 at 18:50)</a>:</h4>
<p><code>apply_fun f at h</code> is a better answer to this question nowadays. It feels more natural.</p>

<a name="193725154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725154">Bryan Gin-ge Chen (Apr 12 2020 at 18:51)</a>:</h4>
<p>We should have a tactic named <code>have_fun</code>.</p>

<a name="193725564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725564" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725564">Victor Ahlquist (Apr 12 2020 at 19:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193725131" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193725131">said</a>:</p>
<blockquote>
<p><code>apply_fun f at h</code> is a better answer to this question nowadays. It feels more natural.</p>
</blockquote>
<p>Yeah it does. Now the second problem is: How do I make a function</p>

<a name="193725610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725610">Victor Ahlquist (Apr 12 2020 at 19:02)</a>:</h4>
<p>I guess I shouldn't start defining things carelessly. I just want a function that multiplies by an element from left/right in the group theory game.</p>

<a name="193725612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725612">Kenny Lau (Apr 12 2020 at 19:02)</a>:</h4>
<p>wait, what is the group theory game?</p>

<a name="193725614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725614">Kevin Buzzard (Apr 12 2020 at 19:02)</a>:</h4>
<p>it doesn't exist yet</p>

<a name="193725622"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725622" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725622">Kevin Buzzard (Apr 12 2020 at 19:03)</a>:</h4>
<p><a href="https://github.com/ImperialCollegeLondon/group-theory-game" title="https://github.com/ImperialCollegeLondon/group-theory-game">https://github.com/ImperialCollegeLondon/group-theory-game</a></p>

<a name="193725678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725678" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725678">Kenny Lau (Apr 12 2020 at 19:04)</a>:</h4>
<p>multiplication on the left by <code>g</code> is <code>((*)g)</code></p>

<a name="193725679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725679" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725679">Kevin Buzzard (Apr 12 2020 at 19:04)</a>:</h4>
<p><code>apply_fun (λ x, g * x) at h,</code></p>

<a name="193725681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725681" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725681">Kenny Lau (Apr 12 2020 at 19:04)</a>:</h4>
<p>multiplication on the right by <code>g</code> is <code>(*g)</code></p>

<a name="193725689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725689">Kevin Buzzard (Apr 12 2020 at 19:04)</a>:</h4>
<p>the power of lambda.</p>

<a name="193725767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725767">Victor Ahlquist (Apr 12 2020 at 19:06)</a>:</h4>
<p>Thanks, I'll try to learn to handle the lambdas</p>

<a name="193725777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725777">Kevin Buzzard (Apr 12 2020 at 19:07)</a>:</h4>
<p><code>λ x, y</code> just means <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>↦</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x\mapsto y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></p>

<a name="193725783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725783">Kevin Buzzard (Apr 12 2020 at 19:07)</a>:</h4>
<p>It's a way of defining a function without giving it a name</p>

<a name="193725789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725789" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725789">Victor Ahlquist (Apr 12 2020 at 19:07)</a>:</h4>
<p>Yeah I know, I'm just not used to the notation. Chapter 2 of TPIL had a lot of lambda functions</p>

<a name="193725849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725849" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725849">Victor Ahlquist (Apr 12 2020 at 19:08)</a>:</h4>
<p>Is it possible to use the apply_fun to a goal?</p>

<a name="193725851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725851" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725851">Kevin Buzzard (Apr 12 2020 at 19:08)</a>:</h4>
<p>no</p>

<a name="193725854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725854">Kevin Buzzard (Apr 12 2020 at 19:08)</a>:</h4>
<p>If I had to prove x=y and I was allowed to multiply both sides by 0, I'd be in very good shape</p>

<a name="193725855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725855">Victor Ahlquist (Apr 12 2020 at 19:09)</a>:</h4>
<p>Haha that's true.</p>

<a name="193725860"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725860" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725860">Victor Ahlquist (Apr 12 2020 at 19:09)</a>:</h4>
<p>Hmm but wait that wouldn't work anyway.</p>

<a name="193725863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725863">Kevin Buzzard (Apr 12 2020 at 19:09)</a>:</h4>
<p>Your question is "if f(x)=f(y) then does x=y?"</p>

<a name="193725865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725865">Kevin Buzzard (Apr 12 2020 at 19:09)</a>:</h4>
<p>and the answer is "only if f is injective"</p>

<a name="193725910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725910">Kevin Buzzard (Apr 12 2020 at 19:10)</a>:</h4>
<p>applying it a hypothesis, the question is "if x = y, does f(x)=f(y)" which is a rather different question</p>

<a name="193725939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193725939" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193725939">Victor Ahlquist (Apr 12 2020 at 19:11)</a>:</h4>
<p>Ah right.</p>

<a name="193726003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726003">Kevin Buzzard (Apr 12 2020 at 19:13)</a>:</h4>
<p>Changing the goal is working backwards.</p>

<a name="193726004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726004">Victor Ahlquist (Apr 12 2020 at 19:13)</a>:</h4>
<p>But wait</p>

<a name="193726050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726050" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726050">Kevin Buzzard (Apr 12 2020 at 19:14)</a>:</h4>
<p>If your goal is <code>f x = f y</code> you can change it to <code>x = y</code> with <code>apply congr_arg</code></p>

<a name="193726052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726052">Victor Ahlquist (Apr 12 2020 at 19:14)</a>:</h4>
<p>Say I had goal a *1 = a <em>1, and for some reason I do not use refl immediately. Then wouldn't it be possible to do something like apply apply_fun (\lambda x. a</em>x), to get 1=1 instead</p>

<a name="193726057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726057" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726057">Victor Ahlquist (Apr 12 2020 at 19:14)</a>:</h4>
<p>Yeah that's what I want</p>

<a name="193726064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726064">Kevin Buzzard (Apr 12 2020 at 19:15)</a>:</h4>
<p>No, because <code>apply_fun</code> does not work on goals.</p>

<a name="193726069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726069">Kevin Buzzard (Apr 12 2020 at 19:15)</a>:</h4>
<p>The fact that it is logically sometimes true doesn't mean that the tactic will ever work.</p>

<a name="193726070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726070">Victor Ahlquist (Apr 12 2020 at 19:15)</a>:</h4>
<p>Yea happly_fun was a placeholder for another similar function</p>

<a name="193726073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726073">Kenny Lau (Apr 12 2020 at 19:15)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193726050" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193726050">said</a>:</p>
<blockquote>
<p>If your goal is <code>f x = f y</code> you can change it to <code>x = y</code> with <code>apply congr_arg</code></p>
</blockquote>
<p><code>congr' 1</code></p>

<a name="193726074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726074" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726074">Kevin Buzzard (Apr 12 2020 at 19:15)</a>:</h4>
<p>Right</p>

<a name="193726119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726119">Kevin Buzzard (Apr 12 2020 at 19:16)</a>:</h4>
<p>You have to write <code> `a * 1` </code> or else Zulip thinks you're trying to put something in italics.</p>

<a name="193726129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726129">Victor Ahlquist (Apr 12 2020 at 19:16)</a>:</h4>
<p>Ah ok</p>

<a name="193726135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726135">Kevin Buzzard (Apr 12 2020 at 19:17)</a>:</h4>
<p>You can't get from <code>a * x = a * y</code> to <code>x = y</code> because <code>a</code> could be 0.</p>

<a name="193726146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726146" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726146">Victor Ahlquist (Apr 12 2020 at 19:17)</a>:</h4>
<p>Not in a group</p>

<a name="193726180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726180" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726180">Kevin Buzzard (Apr 12 2020 at 19:18)</a>:</h4>
<p>Sure</p>

<a name="193726186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726186" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726186">Kevin Buzzard (Apr 12 2020 at 19:18)</a>:</h4>
<p>Can you prove it in a group though?</p>

<a name="193726187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726187">Victor Ahlquist (Apr 12 2020 at 19:18)</a>:</h4>
<p>Do I specify the function after congr_arg?</p>

<a name="193726206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726206">Victor Ahlquist (Apr 12 2020 at 19:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193726186" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193726186">said</a>:</p>
<blockquote>
<p>Can you prove it in a group though?</p>
</blockquote>
<p>Yep just did :)</p>

<a name="193726214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726214" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726214">Kevin Buzzard (Apr 12 2020 at 19:18)</a>:</h4>
<p><code>#check @congr_arg</code> to see what you have to specify</p>

<a name="193726225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726225">Victor Ahlquist (Apr 12 2020 at 19:19)</a>:</h4>
<p>Doing the mul_one now, which is why I asked the above question. Then I realized I would need mul_one to use that tactic but still good to know the answer.</p>

<a name="193726229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726229">Victor Ahlquist (Apr 12 2020 at 19:19)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193726214" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193726214">said</a>:</p>
<blockquote>
<p><code>#check @congr_arg</code> to see what you have to specify</p>
</blockquote>
<p>Thanks</p>

<a name="193726843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193726843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193726843">Kevin Buzzard (Apr 12 2020 at 19:37)</a>:</h4>
<p><code>apply</code> is a clever tactic. It unifies the conclusion of what you're applying with the goal and then solves the corresponding puzzle</p>

<a name="193727902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193727902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193727902">Victor Ahlquist (Apr 12 2020 at 20:04)</a>:</h4>
<p>That was a short and sweet game :)</p>

<a name="193727913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193727913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193727913">Kevin Buzzard (Apr 12 2020 at 20:05)</a>:</h4>
<p>It's not finished yet :-)</p>

<a name="193727919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193727919" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193727919">Kevin Buzzard (Apr 12 2020 at 20:05)</a>:</h4>
<p>So here's something I don't know how to do</p>

<a name="193727920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193727920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193727920">Victor Ahlquist (Apr 12 2020 at 20:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193726843" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193726843">said</a>:</p>
<blockquote>
<p><code>apply</code> is a clever tactic. It unifies the conclusion of what you're applying with the goal and then solves the corresponding puzzle</p>
</blockquote>
<p>I usually like apply, but now I managed without using it a single time</p>

<a name="193727978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193727978" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193727978">Kevin Buzzard (Apr 12 2020 at 20:06)</a>:</h4>
<p>In the natural number game, you prove <code>add_left_cancel</code> and <code>add_assoc</code> and <code>add_comm</code> and you tag them all with <code>simp</code> and then you can prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mo stretchy="false">(</mo><mi>c</mi><mo>+</mo><mi>d</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>d</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>c</mi><mo>+</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a+(b+(c+d)))=(d+b)+(c+a)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span> by <code>simp</code></p>

<a name="193727983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193727983" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193727983">Kevin Buzzard (Apr 12 2020 at 20:06)</a>:</h4>
<p>I am a bit unclear about what the analogous story is for groups</p>

<a name="193727991"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193727991" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193727991">Kevin Buzzard (Apr 12 2020 at 20:06)</a>:</h4>
<p>and I am even more unclear about what the story is for proving implications</p>

<a name="193727995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193727995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193727995">Kevin Buzzard (Apr 12 2020 at 20:06)</a>:</h4>
<p>i.e. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>h</mi><mo>=</mo><mi>g</mi><mi>k</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>h</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">gh=gk\implies h=k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></p>

<a name="193728005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193728005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193728005">Kevin Buzzard (Apr 12 2020 at 20:07)</a>:</h4>
<p>My gut feeling is that you should prove a few of them and then let AI take over</p>

<a name="193728016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193728016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193728016">Kevin Buzzard (Apr 12 2020 at 20:07)</a>:</h4>
<p>but the analogous story for rings is the theory of Groebner bases</p>

<a name="193728077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193728077" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193728077">Kevin Buzzard (Apr 12 2020 at 20:08)</a>:</h4>
<p>There was a discussion <a href="#narrow/stream/113488-general/topic/.60group.60.20tactic" title="#narrow/stream/113488-general/topic/.60group.60.20tactic">here</a></p>

<a name="193728082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193728082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193728082">Kevin Buzzard (Apr 12 2020 at 20:09)</a>:</h4>
<p>but I knew a bit less about confluent rewrites back then</p>

<a name="193728106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193728106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193728106">Reid Barton (Apr 12 2020 at 20:09)</a>:</h4>
<p>Groebner bases are for commutative rings. For groups this is the word problem, and it is undecidable in general.</p>

<a name="193728167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193728167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193728167">Kevin Buzzard (Apr 12 2020 at 20:10)</a>:</h4>
<p>For implications it's simpler than that</p>

<a name="193728206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193728206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193728206">Kevin Buzzard (Apr 12 2020 at 20:11)</a>:</h4>
<p><a href="https://www3.nd.edu/~andyp/notes/OneRelator.pdf" title="https://www3.nd.edu/~andyp/notes/OneRelator.pdf">https://www3.nd.edu/~andyp/notes/OneRelator.pdf</a></p>

<a name="193728255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193728255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193728255">Reid Barton (Apr 12 2020 at 20:12)</a>:</h4>
<p>The statement <code>forall G (a b c ... z : G), eqn1 -&gt; eqn2 -&gt; ... -&gt; eqnN</code> is the same as asking whether <code>eqnN</code> holds in the free group presented by the assumptions.</p>

<a name="193728258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193728258" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193728258">Reid Barton (Apr 12 2020 at 20:12)</a>:</h4>
<p>Okay yes, for a single assumption</p>

<a name="193728272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193728272" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193728272">Kevin Buzzard (Apr 12 2020 at 20:12)</a>:</h4>
<p>The non-obvious thing we ran into was <code>a * b * c * d = 1 -&gt; d * a * b * c = 1</code></p>

<a name="193728349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193728349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193728349">Kevin Buzzard (Apr 12 2020 at 20:14)</a>:</h4>
<p><a href="#narrow/stream/113488-general/topic/.60group.60.20tactic/near/191541928" title="#narrow/stream/113488-general/topic/.60group.60.20tactic/near/191541928">Patrick's <code>group</code> tactic</a> seems to use a finite list of theorems</p>

<a name="193728364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193728364" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193728364">Kenny Lau (Apr 12 2020 at 20:15)</a>:</h4>
<p>can Section 3 (the solution to the word problem for one-relator groups) be formalized (easily)?</p>

<a name="193728410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193728410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193728410">Victor Ahlquist (Apr 12 2020 at 20:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193728272" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193728272">said</a>:</p>
<blockquote>
<p>The non-obvious thing we ran into was <code>a * b * c * d = 1 -&gt; d * a * b * c = 1</code></p>
</blockquote>
<p>Non-trivial for a computer to solve?</p>

<a name="193728712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193728712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193728712">Bryan Gin-ge Chen (Apr 12 2020 at 20:24)</a>:</h4>
<blockquote>
<p>can Section 3 (the solution to the word problem for one-relator groups) be formalized (easily)?</p>
</blockquote>
<p>How do we express "the word problem is solvable" in Lean? Theorem 2.1 looks like a good first target in any case.</p>

<a name="193728903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193728903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193728903">Kenny Lau (Apr 12 2020 at 20:30)</a>:</h4>
<p>decidable_eq</p>

<a name="193733229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193733229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193733229">Jalex Stark (Apr 12 2020 at 22:29)</a>:</h4>
<p>what's the name of the obvious term of type <code>inhabited \a \to \a</code> ?</p>

<a name="193733308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193733308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193733308">Reid Barton (Apr 12 2020 at 22:31)</a>:</h4>
<p>you should find it either by jump-to-definition to <code>inhabited</code> and look nearby, or <code>inhabited.&lt;completion&gt;</code></p>

<a name="193733363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193733363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193733363">Jalex Stark (Apr 12 2020 at 22:33)</a>:</h4>
<p>Thanks for the advice! I think the term is <code>default</code><br>
oh, more accurate is that if <code>q: inhabited \a</code> then <code>q.default:\a</code></p>

<a name="193735377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193735377" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193735377">Mario Carneiro (Apr 12 2020 at 23:35)</a>:</h4>
<p><span class="user-mention silent" data-user-id="123965">Bryan Gin-ge Chen</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193718610" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193718610">said</a>:</p>
<blockquote>
<p>Hmm, for some reason I thought the syntax <code>have h, from blah</code> only worked in term mode, but apparently it can be used in tactic mode as well.</p>
</blockquote>
<p>This is due to some clever tricks in tactic parsing. <code>have</code> allows you to omit any of its pieces and it makes a subgoal if you skip the proof of the <code>have</code>, so <code>have h : foo,</code> will make a subgoal proving <code>|- foo</code>, and <code>have h,</code> will make a subgoal proving <code>?m_1</code>. The comma splits this into two tactics, and the second part is <code>from blah</code>, so <code>from</code> needs to be a tactic. So I made it an alias for <code>exact</code>, and then <code>from blah</code> will make <code>blah</code> the proof of <code>?m_1</code> and then the type gets determined and everything else works out.</p>

<a name="193735662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193735662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193735662">Bryan Gin-ge Chen (Apr 12 2020 at 23:44)</a>:</h4>
<p>That's great! Thanks for the explanation.</p>

<a name="193735680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193735680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193735680">Mario Carneiro (Apr 12 2020 at 23:45)</a>:</h4>
<p>I try to only use <code>from</code> after <code>have</code>, but it's one character shorter and I sometimes see Kenny using it for code golfing :)</p>

<a name="193735891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193735891" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193735891">Reid Barton (Apr 12 2020 at 23:52)</a>:</h4>
<p>In French you could save two more characters</p>

<a name="193736025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193736025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193736025">Mario Carneiro (Apr 12 2020 at 23:57)</a>:</h4>
<p>Are we going to localize lean then?</p>

<a name="193736081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193736081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193736081">Mario Carneiro (Apr 12 2020 at 23:58)</a>:</h4>
<p>I never really understood why non-english programmers were content to just use english programming languages</p>

<a name="193736302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193736302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193736302">Andrew Ashworth (Apr 13 2020 at 00:05)</a>:</h4>
<p>unicode support is still terrible in lots of mainstream languages</p>

<a name="193736366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193736366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193736366">Andrew Ashworth (Apr 13 2020 at 00:06)</a>:</h4>
<p>documentation tends to be written in english, it makes it easier to search stackoverflow if you use english terminology</p>

<a name="193736383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193736383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193736383">Andrew Ashworth (Apr 13 2020 at 00:07)</a>:</h4>
<p>for a lot of domain-specific software technology, there is no translation of the terminology</p>

<a name="193737668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193737668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193737668">Scott Morrison (Apr 13 2020 at 00:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="282867">Victor Ahlquist</span> <a href="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193717945" title="#narrow/stream/113489-new-members/topic/noob.20question(s)/near/193717945">said</a>:</p>
<blockquote>
<p>I managed to solve it btw, posting here for anyone interested in my messy solution</p>
</blockquote>
<p>Here's a cute proof, observing that <code>tidy</code> can follow the hint:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="k">have</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span><span class="o">,</span> <span class="n">tidy</span><span class="o">,</span> <span class="o">}</span>
</pre></div>

<a name="193748512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/193748512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#193748512">Chris M (Apr 13 2020 at 06:30)</a>:</h4>
<p>How do we do syntax highlighting for Lean in zulipchat? I've tried triple grave accent followed by <code>lean</code>, but it doesn't work?</p>
<div class="codehilite"><pre><span></span><span class="kn">axiom</span> <span class="n">test</span> <span class="o">:</span> <span class="err">\</span><span class="n">forallx</span><span class="o">,</span> <span class="n">x</span><span class="bp">=</span><span class="n">x</span>
</pre></div>


<p>edit: ok it only didn't work in "Drafts"</p>


{% endraw %}

{% include archive_update.html %}