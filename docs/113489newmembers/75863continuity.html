---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/75863continuity.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html">continuity</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="186892636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/186892636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#186892636">Greg Langmead (Jan 29 2020 at 14:58)</a>:</h4>
<p>I am trying to construct unit n-spheres and prove they are smooth manifolds. I'm stuck at proving that stereographic projection is continuous. The chat room has already helped me prove continuity of a similar function on a subset of <code>ℝ×ℝ</code> (over in 'noob questions') but adding fin to the mix has me lost again. The function now has two arguments: a point on the sphere and the fin from the codomain of euclidean space, hence <code>continuous.mul</code> does not apply directly ("does not unify"). (Meta: I feel like I'm lacking some general principles to get myself unstuck in these situations!)</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">geometry</span><span class="bp">.</span><span class="n">manifold</span><span class="bp">.</span><span class="n">real_instances</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="c1">-- note: def euclidean_space (n : ℕ) : Type := (fin n → ℝ)</span>

<span class="c1">-- Unit sphere of dimension n, inside euclidean space of dimension n + 1</span>
<span class="n">def</span> <span class="n">unit_sphere</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">//</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="err">^</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">}</span>
<span class="kn">instance</span> <span class="n">sphere_top_space</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">unit_sphere</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">topological_space</span>
<span class="kn">instance</span> <span class="n">sphere_has_coe_to_euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">unit_sphere</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="n">coe_subtype</span>

<span class="c1">-- The unit sphere minus its north pole will be a coordinate chart via stereographic projection</span>
<span class="n">def</span> <span class="n">unit_sphere_minus_north_pole</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">unit_sphere</span> <span class="n">n</span> <span class="bp">//</span> <span class="o">((</span><span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="n">n</span><span class="o">)</span> <span class="bp">≤</span> <span class="mi">1</span> <span class="o">}</span>
<span class="kn">instance</span> <span class="n">sphere_minus_np_top_space</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">unit_sphere_minus_north_pole</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">topological_space</span>
<span class="kn">instance</span> <span class="n">sphere_minus_np_has_coe_to_sphere</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">unit_sphere_minus_north_pole</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">unit_sphere</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">coe_subtype</span>
<span class="kn">instance</span> <span class="n">sphere_minus_np_has_coe_to_euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">unit_sphere_minus_north_pole</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="n">def</span> <span class="n">stereographic_projection_north</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">unit_sphere_minus_north_pole</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">→</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">sphere</span> <span class="n">i</span><span class="o">,</span> <span class="o">((</span><span class="n">sphere</span> <span class="o">:</span> <span class="n">euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">-</span> <span class="o">((</span><span class="n">sphere</span> <span class="o">:</span> <span class="n">euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">))</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span><span class="bp">⁻¹</span>

<span class="kn">lemma</span> <span class="n">continuous_sp_north</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="n">stereographic_projection_north</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">unfold</span> <span class="n">stereographic_projection_north</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">continuous</span><span class="bp">.</span><span class="n">mul</span><span class="o">,</span> <span class="c1">-- fails to unify</span>
<span class="kn">end</span>
</pre></div>

<a name="186904808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/186904808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#186904808">Sebastien Gouezel (Jan 29 2020 at 16:51)</a>:</h4>
<p>Currently, there is only one explicit example of a smooth manifold in <code>mathlib</code>. It is the closed interval, endowed with a manifold with boundary structure, in the file <code>real_instances.lean</code>. You could take this as an example to see how things go. To define a smooth manifold structure, you need two things: an atlas (i.e., a set of local homeomorphisms between parts of your space and parts of euclidean space), and then a proof that the change of coordinates of member of this atlas are smooth. So, the first thing you need is the atlas.</p>
<p>An atlas is made of local homeos, called charts. For the closed interval, the first chart is defined at <a href="https://github.com/leanprover-community/mathlib/blob/b36831204c0db0c18b35918b56ffd3df55707c9e/src/geometry/manifold/real_instances.lean#L202" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/b36831204c0db0c18b35918b56ffd3df55707c9e/src/geometry/manifold/real_instances.lean#L202">https://github.com/leanprover-community/mathlib/blob/b36831204c0db0c18b35918b56ffd3df55707c9e/src/geometry/manifold/real_instances.lean#L202</a> . There, you can see that there is a subtlety in the definition of local homeos: to avoid subtype problems that you are running into, they are not defined on subtypes of the space, but on subsets (and then the function defining your local homeo is defined everywhere, not only on your subset, but the values outside of it are just garbage). So, you should change your code to define <code>unit_sphere_minus_north_pole</code> as a subset of the sphere (which means that you can avoid some instances you are declaring). Of course, the functions will only be continuous on the subset where they make sense, which means that you will use <code>continuous_on</code> instead of <code>continuous</code> in most your proofs.</p>
<p>Here is a skeleton of what your construction might look like, with a lot of sorries that you would need to fill in:</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>

<span class="n">def</span> <span class="n">unit_sphere</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">//</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="err">^</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">}</span>
<span class="kn">instance</span> <span class="n">sphere_top_space</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">unit_sphere</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">topological_space</span>
<span class="kn">instance</span> <span class="n">sphere_has_coe_to_euclidean_space</span> <span class="o">:</span> <span class="n">has_coe</span> <span class="o">(</span><span class="n">unit_sphere</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="n">coe_subtype</span>

<span class="c1">-- The unit sphere minus its north pole will be a coordinate chart via stereographic projection</span>
<span class="n">def</span> <span class="n">unit_sphere_minus_north_pole</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">unit_sphere</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">1</span><span class="o">}</span>

<span class="n">def</span> <span class="n">stereographic_projection_north_local_equiv</span> <span class="o">:</span> <span class="n">local_equiv</span> <span class="o">(</span><span class="n">unit_sphere</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">source</span> <span class="o">:=</span> <span class="n">unit_sphere_minus_north_pole</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">target</span> <span class="o">:=</span> <span class="n">univ</span><span class="o">,</span>
  <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">sphere</span><span class="o">,</span> <span class="o">(</span><span class="bp">λ</span><span class="n">i</span><span class="o">,</span> <span class="o">((</span><span class="n">sphere</span> <span class="o">:</span> <span class="n">euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="n">i</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">-</span> <span class="o">((</span><span class="n">sphere</span> <span class="o">:</span> <span class="n">euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span><span class="bp">⁻¹</span><span class="o">),</span>
  <span class="n">inv_fun</span> <span class="o">:=</span> <span class="bp">λ</span><span class="n">x</span><span class="o">,</span> <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- put the formula for the element of the sphere which is the inverse of</span>
    <span class="c1">-- x under the stereographic projection</span>
  <span class="n">map_source</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- all these fields say that the functions `to_fun` and `inv_fun` are inverse</span>
  <span class="n">map_target</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span> <span class="c1">-- to each other on the sets `source` and `target`</span>
  <span class="n">left_inv</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">right_inv</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">stereographic_projection_north</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="o">(</span><span class="n">unit_sphere</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>
  <span class="bp">..</span><span class="n">stereographic_projection_north_local_equiv</span> <span class="n">n</span> <span class="o">}</span>
</pre></div>


<p>If you put your cursor in vscode on the opening brace of <code>stereographic_projection_north</code>, you will see that there are fields in <code>local_homeomorph</code> that I have not mentioned but that need filling (i.e., <code>open_source</code>, <code>open_target</code>, <code>continuous_to_fun</code>, <code>continuous_inv_fun</code>). But before trying to do the continuity proofs, I think you should try to complete the definition of the local equivalence, i.e., give the formula for the inverse of the stereographic projection and check that you indeed have a bijection.</p>

<a name="186908230"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/186908230" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#186908230">Yury G. Kudryashov (Jan 29 2020 at 17:25)</a>:</h4>
<p>BTW, why do we need the atlas? Why not say "for any point its chart satisfies" instead of "for any member of the atlas"?</p>

<a name="186909822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/186909822" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#186909822">Sebastien Gouezel (Jan 29 2020 at 17:44)</a>:</h4>
<p>Right now, we have an atlas, and for each point <code>x</code> in the manifold we have a chosen member of the atlas that contains <code>x</code> in its domain, and that we call <code>chart_at x</code>. We could definitely replace the atlas by the set of all <code>chart_at x</code> for <code>x</code> in the manifold, and it wouldn't change anything (essentially no gain or no loss from what I could tell). The usual math approach is to have an atlas, though, so I decided to stick with it just for familiarity reasons.</p>

<a name="186911893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/186911893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#186911893">Patrick Massot (Jan 29 2020 at 18:04)</a>:</h4>
<p>Let me write once again that our current definition of <code>manifold</code> is nothing familiar to mathematicians, and should be called <code>charted_space</code> so I'd be open to modifying the definition if Yuri thinks it would make things simpler.</p>

<a name="186912457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/186912457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#186912457">Sebastien Gouezel (Jan 29 2020 at 18:10)</a>:</h4>
<p>I would agree to rename it <code>charted_space</code>. But still, I would keep the atlas to help mathematicians.</p>

<a name="186916498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/186916498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#186916498">Johan Commelin (Jan 29 2020 at 18:55)</a>:</h4>
<p>Will that change implicitly mean that there will typically be infinitely many charts?</p>

<a name="186916564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/186916564" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#186916564">Johan Commelin (Jan 29 2020 at 18:56)</a>:</h4>
<p>If so, I would prefer to keep the atlas. For some definitions it is important to have a finite atlas.</p>

<a name="186916590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/186916590" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#186916590">Johan Commelin (Jan 29 2020 at 18:56)</a>:</h4>
<p>(And to be able to talk about this finiteness)</p>

<a name="186920550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/186920550" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#186920550">Sebastien Gouezel (Jan 29 2020 at 19:36)</a>:</h4>
<p>Many points can have the same chart, so no it does not imply that there are typically infinitely many charts. But in any case this kind of discussion is easier to do with the atlas, so this is one more reason to keep it.</p>

<a name="186936618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/186936618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#186936618">Yury G. Kudryashov (Jan 29 2020 at 22:42)</a>:</h4>
<p>Then I propose to add a constructor setting atlas to be there range of chart_at</p>

<a name="186941400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/186941400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#186941400">Yury G. Kudryashov (Jan 29 2020 at 23:52)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Is it not "manifold" because we fix the best chart for each point or because of something else?</p>

<a name="186951764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/186951764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#186951764">Yury G. Kudryashov (Jan 30 2020 at 03:12)</a>:</h4>
<p>Then I propose to add a constructor setting atlas to be there range of chart_at</p>

<a name="186963205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/186963205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#186963205">Patrick Massot (Jan 30 2020 at 08:25)</a>:</h4>
<p>The best chart function is a tiny implementation detail that is not visible in the real world where we simply choose a chart whenever we need one. The reason mathlib <code>manifold</code> is not a manifold structure is much deeper. There is no maximality condition on the atlas (and no equivalence class of atlases). Adding a compatible chart to a mathlib <code>manifold</code> gives you a new <code>manifold</code>.</p>

<a name="186964084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/186964084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#186964084">Yury G. Kudryashov (Jan 30 2020 at 08:41)</a>:</h4>
<p>The best chart function contributes to this.</p>

<a name="186984930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/186984930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#186984930">Greg Langmead (Jan 30 2020 at 13:20)</a>:</h4>
<p>If a smooth manifold is a topological manifold together with its atlas then you do get a new one by adding a compatible chart, but of course they are diffeomorphic. Sometimes we have some equivalence class in mind and this detail is a distraction. Could Lean's quotients help define the equivalence class in a way that lets us work in both approaches? (Having a multiplicity of approaches feels right to me -- many equivalent definitions and proofs that they are equivalent.)</p>

<a name="187604562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/187604562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#187604562">Greg Langmead (Feb 07 2020 at 00:59)</a>:</h4>
<p>I took the suggestions of <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span>, and have a new question. I'm defining the inverse of stereographic projection, the function that maps euclidean space of dimension n back into the sphere of dimension n, living in euclidean space of dimension n+1. The lambda doesn't typecheck -- where, in what structure, do I provide the proof that the image of this map is in fact contained in the sphere?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">unit_sphere_minus_north_pole</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">unit_sphere</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
  <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">1</span><span class="o">}</span>

<span class="n">def</span> <span class="n">stereographic_projection_inv_north</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">unit_sphere</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span><span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="bp">λ</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)),</span> <span class="k">if</span> <span class="n">lt</span> <span class="o">:</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span>
    <span class="k">then</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="o">(</span><span class="n">fin_upgrade</span> <span class="n">n</span> <span class="n">i</span> <span class="n">lt</span><span class="o">))</span> <span class="bp">/</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="err">^</span> <span class="mi">2</span><span class="o">))</span>
    <span class="k">else</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="err">^</span> <span class="mi">2</span><span class="o">))</span> <span class="bp">/</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="err">^</span> <span class="mi">2</span><span class="o">)))</span>
</pre></div>


<p>This doesn't typecheck, it says </p>
<div class="codehilite"><pre><span></span>type mismatch, term
  λ (x : euclidean_space n) (i : fin (n + 1)),
    dite (i.val &lt; n)
      (λ (lt : i.val &lt; n), 2 * x (fin_upgrade n i lt) / (1 + finset.sum finset.univ (λ (i : fin n), x i ^ 2)))
      (λ (lt : ¬i.val &lt; n),
         (-1 + finset.sum finset.univ (λ (i : fin n), x i ^ 2)) /
           (1 + finset.sum finset.univ (λ (i : fin n), x i ^ 2)))
has type
  euclidean_space n → fin (n + 1) → ℝ
but is expected to have type
  euclidean_space n → unit_sphere n
</pre></div>

<a name="187608762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/187608762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#187608762">Mario Carneiro (Feb 07 2020 at 02:44)</a>:</h4>
<p><code>unit_sphere</code> is a subtype, right? So you need to have a proof after it:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">stereographic_projection_inv_north</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">euclidean_space</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">unit_sphere</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span><span class="n">x</span><span class="o">,</span> <span class="bp">⟨λ</span><span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)),</span> <span class="k">if</span> <span class="n">lt</span> <span class="o">:</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span>
    <span class="k">then</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">x</span> <span class="o">(</span><span class="n">fin_upgrade</span> <span class="n">n</span> <span class="n">i</span> <span class="n">lt</span><span class="o">))</span> <span class="bp">/</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="err">^</span> <span class="mi">2</span><span class="o">))</span>
    <span class="k">else</span> <span class="o">(</span><span class="bp">-</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="err">^</span> <span class="mi">2</span><span class="o">))</span> <span class="bp">/</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">+</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="err">^</span> <span class="mi">2</span><span class="o">)),</span>
<span class="n">sorry</span><span class="bp">⟩</span>
</pre></div>

<a name="187609050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/continuity/near/187609050" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/75863continuity.html#187609050">Greg Langmead (Feb 07 2020 at 02:52)</a>:</h4>
<p>Yes <code>unit_sphere</code> is a subtype</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">unit_sphere</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">:</span> <span class="n">euclidean_space</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">//</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="err">^</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">}</span>
</pre></div>


<p>I added the sorry and it's a variation on the above error, but this gives me something to follow up on so I'll keep at it, thanks!</p>


{% endraw %}

{% include archive_update.html %}