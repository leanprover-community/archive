---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/72888pequivvslocalequiv.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html">pequiv vs local_equiv</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="191775652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191775652" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191775652">Yury G. Kudryashov (Mar 25 2020 at 16:40)</a>:</h4>
<p>It seems to me that they both model the same mathematical concept. Do we need both of them?</p>

<a name="191775790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191775790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191775790">Yury G. Kudryashov (Mar 25 2020 at 16:41)</a>:</h4>
<p><code>pequiv</code>s have better definitional equality at the cost of bad codomains of <code>to_fun</code> and <code>inv_fun</code>.</p>

<a name="191783476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191783476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191783476">Chris Hughes (Mar 25 2020 at 17:33)</a>:</h4>
<p><code>pequiv</code>s also have better equality. I think, though I may be wrong, that equality of <code>local_equiv</code> depends on the out of domain behaviour. There's redundant information in a local equiv, which mucks up equality.</p>

<a name="191785305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191785305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191785305">Kevin Buzzard (Mar 25 2020 at 17:45)</a>:</h4>
<p>whatever is "out of domain behaviour"?</p>

<a name="191785398"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191785398" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191785398">Chris Hughes (Mar 25 2020 at 17:45)</a>:</h4>
<p>An example is how <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>0</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0^{-1}=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>

<a name="191785673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191785673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191785673">Chris Hughes (Mar 25 2020 at 17:47)</a>:</h4>
<p><code>local_equiv</code> is a partial function, but it's implemented as a total function that returns junk outside of the domain of the partial function.</p>

<a name="191786125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191786125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191786125">Reid Barton (Mar 25 2020 at 17:50)</a>:</h4>
<p>I think the answer is: try to port manifolds to <code>pequiv</code> or something else that has the correct equality and see if you can do it without everything falling over.</p>

<a name="191786134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191786134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191786134">Reid Barton (Mar 25 2020 at 17:50)</a>:</h4>
<p>If you can, it will be great.</p>

<a name="191789211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191789211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191789211">Yury G. Kudryashov (Mar 25 2020 at 18:13)</a>:</h4>
<p><code>pequiv</code> won't work, e.g., in the inverse function theorem because I want <code>(h.to_local_homeomorph f).to_fun = f</code> to be defeq. This way it's much easier to prove theorems about <code>local_homeomorph</code>s and apply to the original function. Probably the same is the case in many places in <code>manifold</code>s.</p>

<a name="191789444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191789444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191789444">Yury G. Kudryashov (Mar 25 2020 at 18:15)</a>:</h4>
<p>Probably we should mention each equivalence in the docstring of another and prove that the quotient of <code>local_equiv</code> by <code>eq_on_source</code> is the same as <code>pequiv</code>.</p>

<a name="191789521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191789521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191789521">Mario Carneiro (Mar 25 2020 at 18:16)</a>:</h4>
<p>that's not true either, unfortunately, because of empty types</p>

<a name="191789569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191789569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191789569">Mario Carneiro (Mar 25 2020 at 18:16)</a>:</h4>
<p>it's not always possible to add "junk" to complete the function</p>

<a name="191789642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191789642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191789642">Yury G. Kudryashov (Mar 25 2020 at 18:17)</a>:</h4>
<p>OK, it's the same provided <code>[nonempty α] [nonempty β]</code></p>

<a name="191789922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191789922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191789922">Mario Carneiro (Mar 25 2020 at 18:19)</a>:</h4>
<p>I think you can get a pequiv to invert to the original function, but you have to supply a proof that it is total</p>

<a name="191790081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191790081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191790081">Mario Carneiro (Mar 25 2020 at 18:21)</a>:</h4>
<p>When you are working with a pequiv, you should never talk about out of range values, and as long as you are in range it should be defeq to the original function <code>f</code></p>

<a name="191791901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191791901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191791901">Yury G. Kudryashov (Mar 25 2020 at 18:34)</a>:</h4>
<p>Another difficulty with calculus and <code>pequiv</code>: I can't say that the forward/inverse function is differentiable because it has a bad codomain.</p>

<a name="191791989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191791989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191791989">Mario Carneiro (Mar 25 2020 at 18:35)</a>:</h4>
<p>what do you mean? I thought we had support for differentiating partial functions</p>

<a name="191792165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191792165" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191792165">Yury G. Kudryashov (Mar 25 2020 at 18:36)</a>:</h4>
<p>Do we?</p>

<a name="191792317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191792317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191792317">Mario Carneiro (Mar 25 2020 at 18:37)</a>:</h4>
<p>ah, we had a big discussion about this when it was getting set up. Looks like the core definitions all assume <code>f</code> itself is total</p>

<a name="191792401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191792401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191792401">Mario Carneiro (Mar 25 2020 at 18:37)</a>:</h4>
<p>There are some useful filters for partial functions but they weren't hooked up to <code>deriv</code></p>

<a name="191792516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/pequiv%20vs%20local_equiv/near/191792516" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72888pequivvslocalequiv.html#191792516">Mario Carneiro (Mar 25 2020 at 18:38)</a>:</h4>
<p>I guess the nearest approximation is to say that a <code>pequiv</code> is differentiable if it extends to a function that is differentiable on the subset</p>


{% endraw %}

{% include archive_update.html %}