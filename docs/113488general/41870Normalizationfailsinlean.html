---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/41870Normalizationfailsinlean.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html">Normalization fails in lean</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="181055359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181055359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181055359">Mario Carneiro (Nov 18 2019 at 21:01)</a>:</h4>
<p>Andreas Abel and Thierry Coquand have brought my attention to the following counterexample to normalization in impredicative type theories with proof irrelevance, such as Lean.</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">false&#39;</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="n">p</span>
<span class="n">def</span> <span class="n">true&#39;</span> <span class="o">:=</span> <span class="n">false&#39;</span> <span class="bp">→</span> <span class="n">false&#39;</span>
<span class="n">def</span> <span class="n">omega</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="n">false&#39;</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span> <span class="n">A</span><span class="o">,</span> <span class="bp">@</span><span class="n">cast</span> <span class="n">true&#39;</span> <span class="bp">_</span> <span class="o">(</span><span class="n">h</span> <span class="n">true&#39;</span> <span class="n">A</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">:</span> <span class="n">false&#39;</span><span class="o">,</span> <span class="n">z</span> <span class="n">true&#39;</span> <span class="n">z</span>

<span class="n">def</span> <span class="n">Omega</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span> <span class="n">false&#39;</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">omega</span> <span class="n">h</span> <span class="n">true&#39;</span> <span class="o">(</span><span class="n">omega</span> <span class="n">h</span><span class="o">)</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">Omega</span> <span class="c1">-- timeout</span>
</pre></div>

<a name="181055479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181055479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181055479">Patrick Massot (Nov 18 2019 at 21:02)</a>:</h4>
<p>Should we care?</p>

<a name="181055756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181055756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181055756">Mario Carneiro (Nov 18 2019 at 21:05)</a>:</h4>
<p>It is news; this was the last remaining unresolved question in my MS thesis, and I had expected it to be true, so this counterexample is a surprise. Normalization is sometimes used for proofs of consistency, but in lean's case we have a model construction that achieves this goal by alternate means, so that at least is not at risk</p>

<a name="181056278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181056278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181056278">Mario Carneiro (Nov 18 2019 at 21:09)</a>:</h4>
<p>It does, however, put us more firmly in the "classical" camp, because our type theory can't be used to "just compute" anything that doesn't use axioms</p>

<a name="181056423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181056423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181056423">Mario Carneiro (Nov 18 2019 at 21:10)</a>:</h4>
<p>at this point I would prefer to just have a reflection axiom to deduce <code>A</code> is defeq to <code>B</code> from <code>A = B</code> and finish the job</p>

<a name="181056857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181056857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181056857">Mario Carneiro (Nov 18 2019 at 21:14)</a>:</h4>
<p>It does possibly open the door to performing arbitrary TM computations in the lean kernel. We already knew that this was possible in theory, but lean would not actually perform the required sequence of reductions, it would get stuck early on. The difference with this example is that lean <em>actually</em> goes ahead and does the infinite reduction.</p>

<a name="181057260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181057260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181057260">Mario Carneiro (Nov 18 2019 at 21:18)</a>:</h4>
<p>(It's not clear if this can be used to do <em>useful</em> computation, though, as, like the example in my paper, it requires an inconsistent context, so it's tricky to get the computation out into an inhabited context.)</p>

<a name="181059585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181059585" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181059585">Simon Hudon (Nov 18 2019 at 21:42)</a>:</h4>
<p>In <code>#reduce Omega -- timeout</code>, <code>Omega</code> should be a lambda abstraction. Why does the reduction not stop there?</p>

<a name="181059714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181059714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181059714">Bryan Gin-ge Chen (Nov 18 2019 at 21:43)</a>:</h4>
<p>Are there options to control the number of steps <code>#reduce</code> takes? Is there any option to trace the reduction steps?</p>

<a name="181059978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181059978" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181059978">Mario Carneiro (Nov 18 2019 at 21:46)</a>:</h4>
<p><code>#reduce</code> will reduce the whole term to a normal form, it doesn't stop at whnf</p>

<a name="181060017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181060017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181060017">Mario Carneiro (Nov 18 2019 at 21:47)</a>:</h4>
<p>sadly there is no way to trace the reduction</p>

<a name="181060127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181060127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181060127">Bryan Gin-ge Chen (Nov 18 2019 at 21:48)</a>:</h4>
<p>How hard would it be to imitate the reduction in <code>meta</code> code?</p>

<a name="181060342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181060342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181060342">Mario Carneiro (Nov 18 2019 at 21:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">:</span> <span class="n">Omega</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">Omega</span> <span class="n">h</span> <span class="o">:=</span>
<span class="k">calc</span> <span class="n">Omega</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">omega</span> <span class="n">h</span> <span class="n">true&#39;</span> <span class="o">(</span><span class="n">omega</span> <span class="n">h</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
         <span class="bp">...</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">cast</span> <span class="n">true&#39;</span> <span class="n">true&#39;</span> <span class="o">(</span><span class="n">h</span> <span class="n">true&#39;</span> <span class="n">true&#39;</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span><span class="o">:</span> <span class="n">false&#39;</span><span class="o">,</span> <span class="n">z</span> <span class="n">true&#39;</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">omega</span> <span class="n">h</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
         <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span><span class="o">:</span> <span class="n">false&#39;</span><span class="o">,</span> <span class="n">z</span> <span class="n">true&#39;</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">omega</span> <span class="n">h</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
         <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="n">omega</span> <span class="n">h</span><span class="o">)</span> <span class="n">true&#39;</span> <span class="o">(</span><span class="n">omega</span> <span class="n">h</span><span class="o">)</span> <span class="o">:</span> <span class="n">rfl</span>
         <span class="bp">...</span> <span class="bp">=</span> <span class="n">Omega</span> <span class="n">h</span> <span class="o">:</span> <span class="n">rfl</span>
</pre></div>

<a name="181060697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181060697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181060697">Jeremy Avigad (Nov 18 2019 at 21:54)</a>:</h4>
<p>Their result is a very pretty result, even though it is unfortunate for Lean. But it is not clear whether this result has any bearing on data, i.e. whether we can get a term of type <code>nat</code> that doesn't normalize. And even if we can, there is still hope for <code>eval</code>, which will erase nonsense like Omega.</p>
<p>I don't know what to make of it. Definitional proof irrelevance is nice in practice, and it is hard to imagine someone formalizing mathematics stumbling across a non-normalizing term. I'd rather have a type theory that is theoretically bad but nice in practice than a type theory that is theoretically nice but bad in practice, but of course it would be better to have a theory with both the theoretical and the practical virtues.</p>

<a name="181060789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181060789" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181060789">Mario Carneiro (Nov 18 2019 at 21:55)</a>:</h4>
<p>So the question of whether VM evaluation on a computable well typed term can run forever is still open</p>

<a name="181095679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181095679" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181095679">Mario Carneiro (Nov 19 2019 at 09:46)</a>:</h4>
<p>Here's a modification of the example to act like a Y combinator:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">false&#39;</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="n">p</span>
<span class="n">def</span> <span class="n">true&#39;</span> <span class="o">:=</span> <span class="n">false&#39;</span> <span class="bp">→</span> <span class="n">false&#39;</span>
<span class="n">def</span> <span class="n">y</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">false&#39;</span> <span class="bp">→</span> <span class="n">false&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">false&#39;</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">A</span><span class="o">,</span> <span class="bp">@</span><span class="n">cast</span> <span class="n">true&#39;</span> <span class="bp">_</span> <span class="o">(</span><span class="n">h</span> <span class="n">true&#39;</span> <span class="n">A</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">z</span><span class="o">:</span> <span class="n">false&#39;</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">z</span> <span class="n">true&#39;</span> <span class="n">z</span><span class="o">)</span>

<span class="n">def</span> <span class="n">Y</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">false&#39;</span> <span class="bp">→</span> <span class="n">false&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">false&#39;</span> <span class="o">:=</span>
<span class="n">y</span> <span class="n">f</span> <span class="n">h</span> <span class="n">true&#39;</span> <span class="o">(</span><span class="n">y</span> <span class="n">f</span> <span class="n">h</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">f</span> <span class="n">h</span><span class="o">)</span> <span class="o">:</span> <span class="n">Y</span> <span class="n">f</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">f</span> <span class="o">(</span><span class="n">Y</span> <span class="n">f</span> <span class="n">h</span><span class="o">))))))</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>


<p>Now we can compute with arbitrary functions on <code>false'</code> :P</p>

<a name="181095838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181095838" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181095838">Kevin Buzzard (Nov 19 2019 at 09:48)</a>:</h4>
<blockquote>
<p>It does, however, put us more firmly in the "classical" camp, because our type theory can't be used to "just compute" anything that doesn't use axioms</p>
</blockquote>
<p>So in fact this is something to celebrate, as far as mathematicians are concerned!</p>

<a name="181097047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181097047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181097047">Mario Carneiro (Nov 19 2019 at 10:08)</a>:</h4>
<p>Embedded lambda calculus:</p>
<div class="codehilite"><pre><span></span><span class="kn">section</span>
<span class="kn">parameter</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span><span class="o">)</span>

<span class="n">def</span> <span class="n">D</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="n">p</span>
<span class="n">def</span> <span class="n">F</span> <span class="o">:=</span> <span class="n">D</span> <span class="bp">→</span> <span class="n">D</span>

<span class="n">def</span> <span class="n">app</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="o">:</span> <span class="n">D</span> <span class="o">:=</span> <span class="n">a</span> <span class="n">F</span> <span class="n">b</span>
<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">$$</span> <span class="bp">`</span><span class="o">:</span><span class="mi">400</span> <span class="o">:=</span> <span class="n">app</span>

<span class="n">def</span> <span class="n">lam</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">→</span> <span class="n">D</span><span class="o">)</span> <span class="o">:</span> <span class="n">D</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span><span class="o">,</span> <span class="bp">@</span><span class="n">cast</span> <span class="n">F</span> <span class="bp">_</span> <span class="o">(</span><span class="n">H</span> <span class="n">F</span> <span class="n">A</span><span class="o">)</span> <span class="n">f</span>
<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`</span><span class="err">Λ</span><span class="bp">`</span> <span class="n">binders</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="n">r</span><span class="o">:(</span><span class="n">scoped</span> <span class="n">P</span><span class="o">,</span> <span class="n">lam</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="n">r</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">lam</span> <span class="n">f</span> <span class="err">$$</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="n">def</span> <span class="n">y</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">D</span> <span class="o">:=</span> <span class="err">Λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">z</span> <span class="err">$$</span> <span class="n">z</span><span class="o">)</span>
<span class="n">def</span> <span class="n">Y</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">D</span> <span class="o">:=</span> <span class="n">y</span> <span class="n">f</span> <span class="err">$$</span> <span class="n">y</span> <span class="n">f</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">lam</span> <span class="n">id</span>

<span class="n">def</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">D</span> <span class="o">:=</span> <span class="err">Λ</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span>
<span class="n">def</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="o">:</span> <span class="n">D</span> <span class="o">:=</span> <span class="err">Λ</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="err">$$</span> <span class="o">(</span><span class="n">n</span> <span class="err">$$</span> <span class="n">f</span> <span class="err">$$</span> <span class="n">x</span><span class="o">)</span>

<span class="n">def</span> <span class="n">of_nat</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">D</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">zero</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">of_nat</span> <span class="n">n</span><span class="o">)</span>

<span class="n">def</span> <span class="n">plus</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="o">:</span> <span class="n">D</span> <span class="o">:=</span> <span class="err">Λ</span> <span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">m</span> <span class="err">$$</span> <span class="n">f</span> <span class="err">$$</span> <span class="o">(</span><span class="n">n</span> <span class="err">$$</span> <span class="n">f</span> <span class="err">$$</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">plus</span> <span class="o">(</span><span class="n">of_nat</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">of_nat</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="n">of_nat</span> <span class="mi">4</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">end</span>
</pre></div>

<a name="181196013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181196013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181196013">Gaëtan Gilbert (Nov 20 2019 at 10:40)</a>:</h4>
<blockquote>
<p>(It's not clear if this can be used to do useful computation, though, as, like the example in my paper, it requires an inconsistent context, so it's tricky to get the computation out into an inhabited context.)</p>
</blockquote>
<p>It doesn't require an inconsistent context (but does require an axiom AFAICT), you can do the same manipulation using an hypothesis <code>∀ (A B : Prop), A → B → A = B</code> (propext for inhabited propositions) and instead of inhabiting <code>∀ p : Prop, p</code> inhabit <code>∀ p : Prop, p → p</code><br>
ie</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">top</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">p</span>

<span class="n">def</span> <span class="n">ext</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">B</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span>

<span class="n">def</span> <span class="n">supercast</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">ext</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">B</span>
  <span class="o">:=</span> <span class="bp">@</span><span class="n">cast</span> <span class="n">A</span> <span class="n">B</span> <span class="o">(</span><span class="n">h</span> <span class="n">A</span> <span class="n">B</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">a</span>

<span class="n">def</span> <span class="n">omega</span> <span class="o">:</span> <span class="n">ext</span> <span class="bp">→</span> <span class="n">top</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">h</span> <span class="n">A</span> <span class="n">a</span><span class="o">,</span> <span class="n">supercast</span> <span class="n">h</span> <span class="o">(</span><span class="n">top</span> <span class="bp">→</span> <span class="n">top</span><span class="o">)</span> <span class="n">A</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span><span class="o">:</span> <span class="n">top</span><span class="o">,</span> <span class="n">z</span> <span class="o">(</span><span class="n">top</span> <span class="bp">→</span> <span class="n">top</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="n">z</span><span class="o">)</span> <span class="n">a</span>

<span class="n">def</span> <span class="n">Omega</span> <span class="o">:</span> <span class="n">ext</span> <span class="bp">→</span> <span class="n">top</span> <span class="o">:=</span>
  <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">omega</span> <span class="n">h</span> <span class="o">(</span><span class="n">top</span> <span class="bp">→</span> <span class="n">top</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">omega</span> <span class="n">h</span><span class="o">)</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">Omega</span> <span class="c1">-- timeout</span>
</pre></div>


<p>See also discussion at <a href="https://github.com/coq/coq/pull/10390" target="_blank" title="https://github.com/coq/coq/pull/10390">https://github.com/coq/coq/pull/10390</a></p>

<a name="181200161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181200161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181200161">Mario Carneiro (Nov 20 2019 at 11:56)</a>:</h4>
<p>Right, here's another example shared by Andreas Abel:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- axiom propext {a b : Prop} : (a ↔ b) → a = b</span>

<span class="n">def</span> <span class="n">True</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">p</span>

<span class="n">def</span> <span class="n">om</span> <span class="o">:</span> <span class="n">True</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">a</span><span class="o">,</span>
   <span class="bp">@</span><span class="n">cast</span> <span class="o">(</span><span class="n">True</span> <span class="bp">→</span> <span class="n">True</span><span class="o">)</span> <span class="n">A</span> <span class="o">(</span><span class="n">propext</span> <span class="bp">⟨λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">id</span><span class="bp">⟩</span><span class="o">)</span> <span class="err">$</span>
   <span class="bp">λ</span> <span class="n">z</span><span class="o">:</span> <span class="n">True</span><span class="o">,</span> <span class="n">z</span> <span class="o">(</span><span class="n">True</span> <span class="bp">→</span> <span class="n">True</span><span class="o">)</span> <span class="n">id</span> <span class="n">z</span>

<span class="n">def</span> <span class="n">Om</span> <span class="o">:</span> <span class="n">True</span> <span class="o">:=</span> <span class="n">om</span> <span class="o">(</span><span class="n">True</span> <span class="bp">→</span> <span class="n">True</span><span class="o">)</span> <span class="n">id</span> <span class="n">om</span>

<span class="c1">-- #reduce Om  -- timeout</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">Om</span> <span class="bp">=</span> <span class="n">Om</span> <span class="o">:=</span>
<span class="k">calc</span> <span class="n">Om</span> <span class="bp">=</span> <span class="n">om</span> <span class="o">(</span><span class="n">True</span> <span class="bp">→</span> <span class="n">True</span><span class="o">)</span> <span class="n">id</span> <span class="n">om</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">cast</span> <span class="o">(</span><span class="n">True</span> <span class="bp">→</span> <span class="n">True</span><span class="o">)</span> <span class="o">(</span><span class="n">True</span> <span class="bp">→</span> <span class="n">True</span><span class="o">)</span> <span class="o">(</span><span class="n">propext</span> <span class="bp">⟨λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">id</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">id</span><span class="bp">⟩</span><span class="o">)</span>
            <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span><span class="o">:</span> <span class="n">True</span><span class="o">,</span> <span class="n">z</span> <span class="o">(</span><span class="n">True</span> <span class="bp">→</span> <span class="n">True</span><span class="o">)</span> <span class="n">id</span> <span class="n">z</span><span class="o">)</span> <span class="n">om</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span><span class="o">:</span> <span class="n">True</span><span class="o">,</span> <span class="n">z</span> <span class="o">(</span><span class="n">True</span> <span class="bp">→</span> <span class="n">True</span><span class="o">)</span> <span class="n">id</span> <span class="n">z</span><span class="o">)</span> <span class="n">om</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">om</span> <span class="o">(</span><span class="n">True</span> <span class="bp">→</span> <span class="n">True</span><span class="o">)</span> <span class="n">id</span> <span class="n">om</span> <span class="o">:</span> <span class="n">rfl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">Om</span> <span class="o">:</span> <span class="n">rfl</span>
</pre></div>

<a name="181200371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181200371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181200371">Mario Carneiro (Nov 20 2019 at 11:59)</a>:</h4>
<p>More lambda calculus:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">D</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">p</span>
<span class="n">def</span> <span class="n">F</span> <span class="o">:=</span> <span class="n">D</span> <span class="bp">→</span> <span class="n">D</span>

<span class="n">def</span> <span class="n">app</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span> <span class="o">:</span> <span class="n">D</span> <span class="o">:=</span> <span class="n">a</span> <span class="n">F</span> <span class="n">id</span> <span class="n">b</span>
<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">$$</span> <span class="bp">`</span><span class="o">:</span><span class="mi">400</span> <span class="o">:=</span> <span class="n">app</span>

<span class="n">def</span> <span class="n">lam</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">D</span> <span class="bp">→</span> <span class="n">D</span><span class="o">)</span> <span class="o">:</span> <span class="n">D</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">a</span><span class="o">,</span> <span class="bp">@</span><span class="n">cast</span> <span class="n">F</span> <span class="bp">_</span> <span class="o">(</span><span class="n">propext</span> <span class="bp">⟨λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">id</span><span class="bp">⟩</span><span class="o">)</span> <span class="n">f</span>
<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`</span><span class="err">Λ</span><span class="bp">`</span> <span class="n">binders</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="n">r</span><span class="o">:(</span><span class="n">scoped</span> <span class="n">P</span><span class="o">,</span> <span class="n">lam</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="n">r</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">lam</span> <span class="n">f</span> <span class="err">$$</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>

<a name="181200682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181200682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181200682">Mario Carneiro (Nov 20 2019 at 12:05)</a>:</h4>
<p>However, it is still difficult to use this for actual computations, because they take place inside proof reduction, which is not something that lean will normally even do anyway. For example, the final example <code>lam f $$ x = f x</code> is a bit misleading, because even if I wrote <code>lam f $$ x = f (f x)</code> it would still be proved by <code>rfl</code> because both sides are proofs. The real demonstration that this encoding works is the observation that the LHS <code>#reduce</code>s to the RHS:</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">D</span><span class="o">)</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">lam</span> <span class="n">f</span> <span class="err">$$</span> <span class="n">x</span> <span class="c1">-- f x</span>
</pre></div>

<a name="181235567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181235567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181235567">Wojciech Nawrocki (Nov 20 2019 at 18:34)</a>:</h4>
<p>Am I misunderstanding something, or does this mean that Lean's algorithmic equivalence is also undecidable?</p>

<a name="181264528"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181264528" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181264528">Wojciech Nawrocki (Nov 21 2019 at 00:23)</a>:</h4>
<p>Oh well, it shouldn't be because these are <code>Prop</code>s, right? But then</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">Omega&#39;</span> <span class="o">:</span> <span class="n">pext</span> <span class="bp">→</span> <span class="n">top</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
<span class="kn">theorem</span> <span class="n">blah</span> <span class="o">:</span> <span class="n">Omega</span> <span class="bp">=</span> <span class="n">Omega&#39;</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>


<p>goes into a loop in the kernel (<code>deep recursion was detected at 'replace' (potential solution: increase stack space in your system)</code>). What's going on here - why does Lean seemingly reduce them instead of immediately coming back and saying "these are two proofs of <code>pext → top</code>, hence the same"?</p>

<a name="181268329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181268329" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181268329">Mario Carneiro (Nov 21 2019 at 01:35)</a>:</h4>
<blockquote>
<p>Am I misunderstanding something, or does this mean that Lean's algorithmic equivalence is also undecidable?</p>
</blockquote>
<p>I think it is decidable, but lean's algorithm doesn't decide it. If you never reduce proofs then I think you might be able to dodge this bullet</p>

<a name="181268481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181268481" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181268481">Mario Carneiro (Nov 21 2019 at 01:38)</a>:</h4>
<p>I'm not sure why your example loops. Perhaps lean doesn't notice that they are props? That seems unlikely...</p>

<a name="181308545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/181308545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#181308545">Mario Carneiro (Nov 21 2019 at 14:23)</a>:</h4>
<p>Abel and Coquand's paper with the original example is on arXiv: <a href="https://arxiv.org/abs/1911.08174" target="_blank" title="https://arxiv.org/abs/1911.08174">https://arxiv.org/abs/1911.08174</a></p>

<a name="182498829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/182498829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#182498829">Wojciech Nawrocki (Dec 03 2019 at 21:35)</a>:</h4>
<p>Just came across this: <a href="https://www.youtube.com/watch?v=rhNea8VlWcA" target="_blank" title="https://www.youtube.com/watch?v=rhNea8VlWcA">Cedille Cast #9: Impredicativity, proof-irrelevance, and normalization</a></p>
<div class="youtube-video message_inline_image"><a data-id="rhNea8VlWcA" href="https://www.youtube.com/watch?v=rhNea8VlWcA" target="_blank" title="https://www.youtube.com/watch?v=rhNea8VlWcA"><img src="https://i.ytimg.com/vi/rhNea8VlWcA/default.jpg"></a></div>

<a name="186840845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Normalization%20fails%20in%20lean/near/186840845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/41870Normalizationfailsinlean.html#186840845">Chris Hughes (Jan 28 2020 at 23:21)</a>:</h4>
<p>No idea if this is related or interesting, but I stumbled upon this failing to reduce as well. It reduces if I replace <code>false</code> with <code>empty</code>.</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">not&#39;</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">false</span>

<span class="kn">prefix</span> <span class="bp">`</span> <span class="bp">¬</span><span class="err">&#39;</span> <span class="bp">`</span><span class="o">:</span><span class="mi">40</span> <span class="o">:=</span> <span class="n">not&#39;</span>

<span class="n">def</span> <span class="n">X</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="bp">¬</span><span class="err">&#39;</span> <span class="bp">¬</span><span class="err">&#39;</span> <span class="o">(</span><span class="bp">¬</span><span class="err">&#39;</span> <span class="bp">¬</span><span class="err">&#39;</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span><span class="err">&#39;</span> <span class="o">(</span><span class="bp">¬</span><span class="err">&#39;</span> <span class="bp">¬</span><span class="err">&#39;</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">p</span><span class="o">),</span>
<span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnnp</span><span class="o">,</span> <span class="o">(</span><span class="n">hnnp</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnnp</span><span class="o">,</span> <span class="n">hp</span><span class="o">)))</span><span class="bp">.</span><span class="n">elim</span><span class="o">)</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">X</span>
</pre></div>


{% endraw %}

{% include archive_update.html %}