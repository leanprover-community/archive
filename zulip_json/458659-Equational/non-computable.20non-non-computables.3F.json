[
    {
        "content": "<p>Silly lean question; can <code>def</code>s <em>not</em> marked with <code>noncomputable</code> actually be non-computable?</p>",
        "id": 477477115,
        "sender_full_name": "Cody Roux",
        "timestamp": 1729180822
    },
    {
        "content": "<p><code>noncomputable</code> lean defs are ones that use an axiom (usually choice). So their meaning is \"you are using a theorem that says you get a data object of your type, but doesn't really tell you how to pick this object\". Non-<code>noncomputable</code> defs have to be total and provably terminating, so I don't see how you can encode a non-computable function in it.</p>",
        "id": 477478280,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1729181193
    },
    {
        "content": "<p>Fair point, so the last bullet may already be given.</p>",
        "id": 477479276,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729181495
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477478280\">said</a>:</p>\n<blockquote>\n<p><code>noncomputable</code> lean defs are ones that use an axiom (usually choice). So their meaning is \"you are using a theorem that says you get a data object of your type, but doesn't really tell you how to pick this object\". Non-<code>noncomputable</code> defs have to be total and provably terminating, so I don't see how you can encode a non-computable function in it.</p>\n</blockquote>\n<p>Defs that aren't noncomputable don't actually have to be terminating, that's a common misconception. This is due to how partial functions work in Lean. They exist, and the guarantee is just that they don't violate the type safety, so I can't have a partial function that returns a <code>{x:Nat // And (IsSquare x) (Prime x)}</code>, since there's no data of that type. But I can have a define a partial function that returns how many steps an (arbitrary, possibly non-halting) Turing machine takes to halt, and prove that this is what it computes. This doesn't compromise any safety because the mere existence of this information doesn't let me prove False.</p>\n<p>And, this data can then be used in a later definition that isn't <code>partial</code>, there wouldn't be any external indicator that this function doesn't terminate.</p>",
        "id": 477485356,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1729183623
    },
    {
        "content": "<p>I am completely ignoring <code>partial</code> since one can't prove anything about them</p>",
        "id": 477486074,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1729183884
    },
    {
        "content": "<p>In the context of the discussion, I think Joachim was trying to prove something about the implication graph</p>",
        "id": 477486145,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1729183911
    },
    {
        "content": "<p>But yeah it is new to me that you can plug in a partial def into a non-partial one</p>",
        "id": 477486549,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1729184052
    },
    {
        "content": "<p>And still prove anything with this def</p>",
        "id": 477486678,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1729184105
    },
    {
        "content": "<p>Once we have <a href=\"https://github.com/leanprover/lean4/issues/3119\">https://github.com/leanprover/lean4/issues/3119</a> we can even have (some) genuinely non-terminating functions and still do all the proofs we want about them.</p>",
        "id": 477490254,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729185476
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116028\">Cody Roux</span> <a href=\"#narrow/channel/458659-Equational/topic/non-computable.20non-non-computables.3F/near/477477115\">said</a>:</p>\n<blockquote>\n<p>Silly lean question; can <code>def</code>s <em>not</em> marked with <code>noncomputable</code> actually be non-computable?</p>\n</blockquote>\n<p>Yes, it's actually trivial to do so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">choice</span>\n</code></pre></div>",
        "id": 477546578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729212901
    },
    {
        "content": "<p>We can even formally prove it using mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Computability</span><span class=\"bp\">.</span><span class=\"n\">Halting</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">choice</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Partrec</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">haltingFunction</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Code</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Dom</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">instNonemptyDecidable</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">haltingFunction_not_computable</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">Computable</span><span class=\"w\"> </span><span class=\"n\">haltingFunction</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ComputablePred</span><span class=\"bp\">.</span><span class=\"n\">halting_problem</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 477547565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729213564
    },
    {
        "content": "<p>What's the decision procedure for classical.instNonEmptyDecidable?</p>",
        "id": 477551531,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1729216743
    },
    {
        "content": "<p>it's a pattern match on the excluded middle, which itself is proven using choice</p>",
        "id": 477561966,
        "sender_full_name": "Cody Roux",
        "timestamp": 1729221873
    },
    {
        "content": "<p>I'm sad that <code>noncomputable</code> isn't as \"sticky\" as I thought, I'm not entirely sure why <code>partial</code> isn't.</p>",
        "id": 477562043,
        "sender_full_name": "Cody Roux",
        "timestamp": 1729221915
    },
    {
        "content": "<p>What non-<code>noncomputable</code> actually means is that the lean compiler can generate code for the definition. Because there is no assumption that the code be terminating, it is always possible to trivially implement any <code>axiom</code> via looping on every input; it's a \"courtesy\" that this is not done and instead you get a compilation error if you try to call <code>Classical.choice</code> in your program, because this is presumably more useful than just wasting CPU cycles.</p>",
        "id": 477570006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729225934
    },
    {
        "content": "<p>The reason <code>partial</code> is not a viral marker is because it's not really marking the partiality, it's marking the opaqueness. A <code>partial</code> definition is not provably equal to its unfolding</p>",
        "id": 477570043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729225982
    },
    {
        "content": "<p>You can of course implement a metaprogram to check for transitive usage of opaques or partial definitions; see <a href=\"#narrow/channel/348111-batteries/topic/Batteries.20and.20LEM/near/473084706\">link</a> and the transitive links</p>",
        "id": 477570253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729226156
    },
    {
        "content": "<p>Ok, so either we need to do this check, or \"promise\" not to use <code>partial</code> in the \"final end-to-end theorem\" definition.</p>",
        "id": 477681251,
        "sender_full_name": "Cody Roux",
        "timestamp": 1729265529
    },
    {
        "content": "<p>sorry, I am missing the context here. In what way do you think this relates to the final theorem?</p>",
        "id": 477689521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729268247
    },
    {
        "content": "<p>I didn't think computability (in the mathematical sense) was on the agenda</p>",
        "id": 477689600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729268274
    },
    {
        "content": "<p>I'm not even sure what that would mean here. We're proving theorems, not providing a calculation. Surely we're not aiming to prove everything constructively (i.e. without using the law of excluded middle).</p>",
        "id": 477691372,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1729268925
    },
    {
        "content": "<p>The final calculation is trying to prove statements like A=&gt;B OR NOT (A=&gt;B) so LEM is somewhat of a hinderance there</p>",
        "id": 477694373,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1729270096
    },
    {
        "content": "<p>We're trying to say: here is a complete, <em>concrete</em> graph of all implications and non-implications. No need to stare at it, it's huge, but trust us it is both complete and concretely given.</p>",
        "id": 477702845,
        "sender_full_name": "Cody Roux",
        "timestamp": 1729273632
    },
    {
        "content": "<p>If we just say \"there exists such a graph\" then perhaps people might be less than impressed, since it's easy to prove it exists.</p>",
        "id": 477703095,
        "sender_full_name": "Cody Roux",
        "timestamp": 1729273729
    },
    {
        "content": "<p>This happens all the time in classification problems.</p>",
        "id": 477703194,
        "sender_full_name": "Cody Roux",
        "timestamp": 1729273764
    },
    {
        "content": "<p>Using choice or LEM to prove things about whether some implications are true or false does not change anything to the concreteness of the graph, which is completely explicit here.</p>",
        "id": 477703511,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1729273889
    },
    {
        "content": "<p>I know that, but does the casual reader know this? How do they know it?</p>",
        "id": 477703637,
        "sender_full_name": "Cody Roux",
        "timestamp": 1729273942
    },
    {
        "content": "<p>I see. You'd like to see some final result that's something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The implication graph, as an adjacency matrix --/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">doesImply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eqA</span><span class=\"w\"> </span><span class=\"n\">eqB</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">4695</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">something</span><span class=\"w\"> </span><span class=\"n\">computable</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">doesImply_correct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eqA</span><span class=\"w\"> </span><span class=\"n\">eqB</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">4695</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">doesImply</span><span class=\"w\"> </span><span class=\"n\">eqA</span><span class=\"w\"> </span><span class=\"n\">eqB</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"n\">iff</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Equation</span><span class=\"w\"> </span><span class=\"n\">eqA</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">eqB</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">   </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">correctness</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span>\n</code></pre></div>\n<p>and that way, anyone who wants to see that the project is complete, would just have to verify that (1) <code>doesImply_correct</code> doesn't depend on <code>sorryAx</code>, and (2) that <code>doesImply</code> is a computable function.</p>\n<p>And the concern is that <code>doesImply</code> could just be defined in terms of e.g. whether a particular Turing machine halts or not, without being marked noncomputable, and then we could have cheated and \"skipped\" the whole project.</p>",
        "id": 477706720,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1729275172
    },
    {
        "content": "<p>I think the right way to present this is something like \"here is a concrete list of implications and non-implications, and here is a proof that the transitive closure of these generates the whole graph\"</p>",
        "id": 477727011,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729281903
    },
    {
        "content": "<p>\"oh and here's a function if you want to query parts of it\"</p>",
        "id": 477727034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729281914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/non-computable.20non-non-computables.3F/near/477727011\">said</a>:</p>\n<blockquote>\n<p>I think the right way to present this is something like \"here is a concrete list of implications and non-implications, and here is a proof that the transitive closure of these generates the whole graph\"</p>\n</blockquote>\n<p>That list will be large and possibly generated by a tactic, so the user cannot just eyeball it to see that it really is concrete (and not produced with <code>Classical.choose</code>), hence the musing of whether there is a more declarative way of saying “this function or this data is concrete/computable/whatever”, besides <code>#print</code>.</p>",
        "id": 477733658,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729285091
    },
    {
        "content": "<p>It should be specified by some actually explicit list together with some closure algorithm which may do more than just implication chaining but also duals and I don't know what else</p>",
        "id": 477740004,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729288722
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/non-computable.20non-non-computables.3F/near/477547565\">said</a>:</p>\n<blockquote>\n<p>We can even formally prove it using mathlib:</p>\n</blockquote>\n<p>This sounds like a nice result for the <code>Counterexamples</code> directory</p>",
        "id": 477742638,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729290284
    },
    {
        "content": "<p>regarding the completeness of the graph, could the statement be something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">theRawData</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">read_matrix</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"s2\">\"implications.txt\"</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">as_closure</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">theRawData</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">closureOf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">someSmallerData</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">theRawData</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"n\">iff</span><span class=\"w\"> </span><span class=\"n\">implies</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">as_closure</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 477742849,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729290435
    },
    {
        "content": "<p>Then you just need to trust <code>read_matrix%</code>, which is hopefully very trivial</p>",
        "id": 477742860,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729290447
    },
    {
        "content": "<p>the trouble is that this formulation is very likely to crash lean</p>",
        "id": 477743027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729290551
    },
    {
        "content": "<p>because <code>theRawData</code> is an object with 22 million entries</p>",
        "id": 477743045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729290567
    },
    {
        "content": "<p>maybe it would be okay if you encoded it as a bitvector in a string literal or bignum? but even then you'll be stuck trying to prove anything about it without an explosion in term size</p>",
        "id": 477743167,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729290646
    },
    {
        "content": "<p>22 million bits is only 2.76 megabytes, so storing it as a bitvector and proving facts about it via halving it 25 times could work</p>",
        "id": 477743413,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729290842
    },
    {
        "content": "<p>Maybe you need ofReduceBool for this to work</p>",
        "id": 477743470,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729290863
    },
    {
        "content": "<p>never underestimate lean's ability to use more memory than a napkin calculation would suggest <span aria-label=\"skull\" class=\"emoji emoji-1f480\" role=\"img\" title=\"skull\">:skull:</span></p>",
        "id": 477744037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729291282
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/stream/458659-Equational/topic/non-computable.20non-non-computables.3F/near/477485356\">said</a>:</p>\n<blockquote>\n<p>I can have a define a partial function that returns how many steps an (arbitrary, possibly non-halting) Turing machine takes to halt, and prove that this is what it computes. This doesn't compromise any safety because the mere existence of this information doesn't let me prove False.</p>\n</blockquote>\n<p>Can't you define a proof sequence of False using this method? With functions <code>conclusion : ProofSeq -&gt; Prop</code> and <code>embed : (seq : ProofSeq) -&gt; (term : conclusion seq)</code>? Or even if such embedding is not possible in Lean, it would prove that first-order logic formalized in Lean is inconsistent?</p>",
        "id": 477796326,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729335624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/458659-Equational/topic/non-computable.20non-non-computables.3F/near/477743413\">said</a>:</p>\n<blockquote>\n<p>22 million bits is only 2.76 megabytes, so storing it as a bitvector and proving facts about it via halving it 25 times could work</p>\n</blockquote>\n<p>That’s what I am experimenting in <a href=\"https://github.com/teorth/equational_theories/pull/636\">https://github.com/teorth/equational_theories/pull/636</a> with, zulip thread  <a class=\"stream-topic\" data-stream-id=\"458659\" href=\"/#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean\">#Equational &gt; A final end-to-end theorem in Lean</a></p>",
        "id": 477797115,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729336384
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302984\">Amir Livne Bar-on</span> <a href=\"#narrow/stream/458659-Equational/topic/non-computable.20non-non-computables.3F/near/477796326\">said</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Can't</span><span class=\"w\"> </span><span class=\"n\">you</span><span class=\"w\"> </span><span class=\"n\">define</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"n\">sequence</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">method?</span><span class=\"w\"> </span><span class=\"n\">With</span><span class=\"w\"> </span><span class=\"n\">functions</span><span class=\"w\"> </span><span class=\"ss\">`conclusion</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProofSeq</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"ss\">`embed</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProofSeq</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">conclusion</span><span class=\"w\"> </span><span class=\"n\">seq</span><span class=\"o\">)</span><span class=\"bp\">`?</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"n\">even</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">such</span><span class=\"w\"> </span><span class=\"n\">embedding</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">possible</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">would</span><span class=\"w\"> </span><span class=\"n\">prove</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"bp\">-</span><span class=\"n\">order</span><span class=\"w\"> </span><span class=\"n\">logic</span><span class=\"w\"> </span><span class=\"n\">formalized</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">inconsistent?</span>\n</code></pre></div>\n<p>Sorry, I should say, \"it computes how many steps it takes to halt, if it halts; otherwise it returns -1\". That was implied in my head (because Lean has a number of functions that do something similar of returning junk \"if something never happens\") but I should have been more explicit. </p>\n<p>No, it's not something that implies it's inconsistent.</p>",
        "id": 477803326,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1729342096
    },
    {
        "content": "<p>This presumably requires <code>choice</code> though? So we can detect such non-computable definitions by their axioms</p>",
        "id": 477810674,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729347203
    },
    {
        "content": "<p>Oh I see, there's also the <code>partial</code> loophole, so no need for choice</p>",
        "id": 477811229,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729347652
    },
    {
        "content": "<p>Note that the <code>partial</code> loophole is secretly using choice</p>",
        "id": 477813716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729349819
    },
    {
        "content": "<p>I mean, that should be pretty obvious because it gives you a value with the same type as Classical.choice</p>",
        "id": 477813752,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729349849
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"c1\">-- 'foo' does not depend on any axioms</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bar</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"c1\">-- 'bar' depends on axioms: [Classical.choice]</span>\n</code></pre></div>",
        "id": 477813848,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729349944
    },
    {
        "content": "<p>Here's the secret definition <em>they</em> don't want you to know:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bar</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"n\">run_meta</span><span class=\"w\"> </span><span class=\"c1\">-- fun {α} a =&gt; Classical.ofNonempty</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">opaqueInfo</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"ss\">`bar</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">failure</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">value</span>\n</code></pre></div>",
        "id": 477814339,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729350307
    },
    {
        "content": "<p>So here<br>\n<a href=\"#narrow/channel/458659-Equational/topic/non-computable.20non-non-computables.3F/near/477706720\">https://leanprover.zulipchat.com/#narrow/channel/458659-Equational/topic/non-computable.20non-non-computables.3F/near/477706720</a><br>\nitem (2) would be a statement that doesImply does not depend on AoC</p>",
        "id": 477822998,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729357382
    },
    {
        "content": "<p>That is, assuming that the DB constructed by equational_result doesn't depend on the axioms used by the theorems</p>",
        "id": 477823776,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729358021
    },
    {
        "content": "<p>I guess the greedy construction can be done without choice, so we don't actually need it in the proofs yet</p>",
        "id": 477824087,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729358332
    }
]