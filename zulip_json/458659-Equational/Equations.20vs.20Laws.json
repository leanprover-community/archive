[
    {
        "content": "<p>I propose to make a formal distinction between \"equations\" on one hand, and \"laws\" on the other. (Roughly speaking, equations are to semantics as laws are to syntax.)</p>\n<p>A law is a formal string <code>w == w'</code> where <code>w</code>, <code>w'</code> are elements of the free magma  <code>FreeMagma ℕ</code> over the natural numbers, and <code>==</code> is a formal equality symbol with no prior semantic content.  A typical example of a law is the commutative law</p>\n<p><code>0 ∘ 1 == 1 ∘ 0</code></p>\n<p>An equation is an expression <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo><mo>=</mo><mi>g</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x_1,\\dots,x_n) = g(x_1,\\dots,x_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> in several variables <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_1,\\dots,x_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> living in some magma <code>G</code>.  A typical example of an equation is the commutative equation</p>\n<p><code>x ∘ y = y ∘ x</code></p>\n<p>for some variables <code>x y: G</code>.</p>\n<p>Every law can be interpreted in a given magma as an equation; if the equation is universally satisfied by the magma, we say that the magma obeys the law.  For instance, a magma <code>G</code> will obey the commutative law <code>0 ∘ 1 == 1 ∘ 0</code> if and only if the commutative equation <code>x ∘ y = y ∘ x</code> is obeyed for all <code>x y : G</code>.  In the language of model theory, the former statement would be expressed as <code>G ⊧ 0 ∘ 1 == 1 ∘ 0</code>.</p>\n<p>Right now, the Lean codebase is organized around equations, but as discussed in <a class=\"stream-topic\" data-stream-id=\"458659\" href=\"/#narrow/stream/458659-Equational/topic/Syntax\">#Equational &gt; Syntax</a>  ,  it would be preferable to organize it around laws instead.  A start has been made at <a href=\"https://github.com/teorth/equational_theories/blob/main/equational_theories/FreeMagma.lean\">https://github.com/teorth/equational_theories/blob/main/equational_theories/FreeMagma.lean</a> with the basic definitions of a free magma.  I am working on updating blueprint with an outline of more API for free magmas, equations, and laws, which should appear on the repo soon (it is building as we speak).</p>\n<p>Laws will be a better \"back end\" representation than equations because it is significantly easier to prove metatheorems about laws than about equations (they are elements of the type <code>FreeMagma ℕ × FreeMagma ℕ</code>, which can be equipped within Lean with a preorder (implication), a duality operation, etc.), whereas for equations this sort of structure can only be extracted through metaprogramming or from scraping tools external to Lean.</p>\n<p>However, this still leaves the question of what to use for the \"front end\" - the representation that human and automated contributors will use by default.  For instance, should the databases of equations and implications that are autogenerated be expressed using equations such as <code>x ∘ y = y ∘ x</code>, or laws such as <code>0 ∘ 1 == 1 ∘ 0</code>?  The conversion between the two is easy so this is mostly an aesthetic issue.  Also, some API within Lean will be needed to convert, for instance, the assertion <code>G ⊧ 0 ∘ 1 == 1 ∘ 0</code> that a magma <code>G</code> obeys the commutative law <code>0 ∘ 1 == 1 ∘ 0</code>, with the (logically equivalent) assertion <code>∀ x y : G, x ∘ y == y ∘ x</code> that <code>G</code> obeys the commutative equation <code>x ∘ y = y ∘ x</code>.</p>\n<p>How should we proceed here?  For instance, we could have every equation, e.g., </p>\n<p><code>abbrev Equation43 (G: Type u) [Magma G] := ∀ x y : G, x ∘ y = y ∘ x</code></p>\n<p>paired with a law</p>\n<p><code>abbrev Law43 := 0 ∘ 1 == 1 ∘ 0</code></p>\n<p>(this requires some notation for <code>==</code> that has not yet been set up), as well as an easy theorem</p>\n<p><code>theorem Equiv43 (G: Type u) [Magma G]: Equation43 G ↔ G ⊧ Law43</code></p>\n<p>Not sure if this is the most efficient approach though.</p>",
        "id": 473472323,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727630824
    },
    {
        "content": "<p>You can add syntax and unexpanders or notation to move from Lean's data type for the syntax and string representations.</p>",
        "id": 473473189,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727631331
    },
    {
        "content": "<p>This is relatively straightforward and used in programming language theory a lot</p>",
        "id": 473473263,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727631365
    },
    {
        "content": "<p>I think all of this can be done in a straightforward way using lean4’s metaprogramming infrastructure. But I don’t see why you would want to use string representations for any of this.</p>",
        "id": 473473475,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727631582
    },
    {
        "content": "<p>Data sets</p>",
        "id": 473473537,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727631603
    },
    {
        "content": "<p>Stored in .txt files or CSV files</p>",
        "id": 473473551,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727631613
    },
    {
        "content": "<p>Ok, I understand, but I suppose you would want to parse a string to an expression representing a term in the free magma, and beyond that there should not be any need to use strings</p>",
        "id": 473473631,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727631707
    },
    {
        "content": "<p>Yeah that was my idea</p>",
        "id": 473473693,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727631727
    },
    {
        "content": "<p>Parse strings into TSyntax and serialise them on the other direction. But apart from that use lean syntax/notation</p>",
        "id": 473473729,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727631783
    },
    {
        "content": "<p>But why go via syntax and not just to expr?</p>",
        "id": 473473746,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727631801
    },
    {
        "content": "<p>The syntax still has to be elaborated to be useful</p>",
        "id": 473473766,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727631825
    },
    {
        "content": "<p>To be fair, the distinction between syntax and elaborated expressions is quite minimal in this case of magma words</p>",
        "id": 473473870,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727631909
    },
    {
        "content": "<p>Sure that also works. Ultimately we just need magma term objects.</p>",
        "id": 473473985,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727631969
    },
    {
        "content": "<p>We could simply write a parser and serialiser for magmas into lean.</p>",
        "id": 473474004,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727631996
    },
    {
        "content": "<p>The notation stuff is to work nicely with infoview</p>",
        "id": 473474034,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727632027
    },
    {
        "content": "<p>And inside lean in general</p>",
        "id": 473474048,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727632036
    },
    {
        "content": "<p>If you want to open an issue with what’s needed from the meta side then I’ll claim it</p>",
        "id": 473474342,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727632282
    },
    {
        "content": "<p>One consideration is that I am expecting many contributors to not come with an background in advanced algebra, model theory, or the computer science of syntax.  So it may be less intimidating for such contributors to use the language of equations such as <code>∀ x y : G, x ∘ y = y ∘ x</code> rather than more abstruse-looking syntactical expressions such as <code>G ⊧ 0 ∘ 1 == 1 ∘ 0</code>.  I'm hoping though that there is some way to use both equations and laws almost interchangeably, so that the representation one wants for a particular use case is primarily an aesthetic choice.</p>",
        "id": 473474448,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727632349
    },
    {
        "content": "<p>If we write elaborators, then at least in the infoview it would look completely familiar</p>",
        "id": 473474491,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727632392
    },
    {
        "content": "<p>If one can set it up so that in the Lean front end it looks like equations, in the back end it is formalized as laws, and on the data end it can be text strings associated to either laws or equations, I guess it will work out.  (It should be fairly trivial to convert a text string of a law to a text string of an equation; the only silly issue is that we have only specified the first six letters <code>x y z w u v</code> of the alphabet used in an equation, whereas the law string can handle any number of distinct variables.)</p>",
        "id": 473474677,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727632547
    },
    {
        "content": "<p>within lean, I think you will find notation convenient</p>",
        "id": 473474680,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727632550
    },
    {
        "content": "<p>I guess if it can be set up so that <code>G ⊧ 0 ∘ 1 == 1 ∘ 0</code> and <code>∀ x y : G, x ∘ y = y ∘ x</code> are definitionally equivalent then the distinction becomes essentially irrelevant to anyone working within Lean</p>",
        "id": 473474836,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727632654
    },
    {
        "content": "<p>I don't understand. One is saying that for a specific instantiation of x and y to resp 0 and 1,  G entails this equation. The other is a universally quantified property from which this relation can be derived. Definitionally equivlanet would mean I could go in the other direction: from one special case to a general rule</p>",
        "id": 473475072,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727632826
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 473475135,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727632879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473475072\">said</a>:</p>\n<blockquote>\n<p>I don't understand. One is saying that for a specific instantiation of x and y to resp 0 and 1,  G entails this equation. The other is a universally quantified property from which this relation can be derived. Definitionally equivlanet would mean I could go in the other direction: from one special case to a general rule</p>\n</blockquote>\n<p>this notation uses numbers to refer to variables, rather than conventional letters. it does not carry the semantics usually assigned to <code>0</code> or <code>1</code>.</p>",
        "id": 473475463,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727633110
    },
    {
        "content": "<p>Oh perhaps I am using the entailment relation incorrectly.  What I mean by <code>G ⊧ 0 ∘ 1 == 1 ∘ 0</code> is that <em>every</em> interpretation of <code>0 1</code> in <code>G</code> represents <code>0 ∘ 1 == 1 ∘ 0</code> as a true equation.  One could use something like <code>G.obeys 0 ∘ 1 == 1 ∘ 0</code> if that is less confusing.</p>",
        "id": 473475473,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727633119
    },
    {
        "content": "<p>One <em>could</em> set up a parallel copy of <code>ℕ</code> with copies <code>x₀ x₁ x₂ ...</code> of <code>0 1 2 ...</code> (representing formal indeterminate variables) if this is less confusing, but for back end purposes at least it seems simpler to me to use the natural numbers directly to represent the indeterminates</p>",
        "id": 473475642,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727633256
    },
    {
        "content": "<p>right, but for syntax purposes i'd expect using general identifiers shouldn't be difficult?</p>",
        "id": 473475741,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727633343
    },
    {
        "content": "<p>I guess there is a slight tension between choices of notation that make it (a) easy for a human to read; (b) easy for an automated prover to read; and (c) easy for Lean to work with.  Ideally I want all of (a), (b), (c), of course.</p>",
        "id": 473475746,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727633347
    },
    {
        "content": "<p>Well the advantage of fixing the alphabet to be, say, <code>ℕ</code>, is that I can now easily formalize in Lean statements such as \"The type <code>FreeMagma ℕ × FreeMagma ℕ</code> of laws is a pre-order (with respect to implication), with <code>0==0</code> as a minimal element, <code>0==1</code> as a maximal element, and the duality operation [to be defined] as a pre-order isomorphism\".</p>",
        "id": 473475875,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727633465
    },
    {
        "content": "<p>but what about <code>1 == 1</code>?</p>",
        "id": 473475902,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727633504
    },
    {
        "content": "<p><code>1 == 1</code> is equivalent to <code>0 == 0</code>.  It's a pre-order, not a partial order.</p>",
        "id": 473475960,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727633524
    },
    {
        "content": "<p>If one quotients out by equivalence, one gets a partial order, but that's a different type</p>",
        "id": 473475976,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727633569
    },
    {
        "content": "<p>in particular a type in which equality is likely undecidable, so not great to work with inside Lean.  I think the pre-ordered type <code>FreeMagma ℕ × FreeMagma ℕ</code> will be a more convenient base type to encode the notion of a law.</p>",
        "id": 473476029,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727633635
    },
    {
        "content": "<p>i think that using <code>G ⊧ x ∘ y = y ∘ x</code> should at the very least satisfy (c), and it's not too difficult for lean (i think) to parse, if one simply uses a DSL-embedding. (use order of appearance to assign numbers to identifiers). whether it satisfies (a) is not for me to judge</p>",
        "id": 473476032,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727633637
    },
    {
        "content": "<p>I also want to refer to laws as first class objects.  The expression <code>x ∘ y = y ∘ x</code> is of type <code>Prop</code> in Lean, I think?  (assuming <code>x y</code> are already introduced as variables).  This is why I wanted to introduce a distinct equality symbol <code>==</code> for laws</p>",
        "id": 473476213,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727633764
    },
    {
        "content": "<p>what i mean by DSL embedding is we can define notation <code>law(x ∘ y = y ∘ x)</code> to refer to the law, not the prop</p>",
        "id": 473476311,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727633844
    },
    {
        "content": "<p>Oh, that's nice</p>",
        "id": 473476319,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727633857
    },
    {
        "content": "<p>didn't realize Lean's elaborator could do that</p>",
        "id": 473476329,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727633867
    },
    {
        "content": "<p>yea, Lean's language extention feature is quite extensive <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 473476392,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727633893
    },
    {
        "content": "<p>we could then have the best of both worlds, with two notations <code>law(x ∘ y = y ∘ x)</code> and <code>0 ∘ 1 == 1 ∘ 0</code> to refer to the same <code>Law</code> object; it would internally be stored as basically the type <code>FreeMagma ℕ × FreeMagma ℕ</code> with some additional API, but this would be invisible to anyone not actually trying to prove metatheorems about equations.</p>",
        "id": 473476490,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727633999
    },
    {
        "content": "<p>There would still need to be some general tool within Lean to equate <code>G ⊧ x ∘ y = y ∘ x</code> with <code>∀ x y : G, x ∘ y = y ∘ x</code> though, since this is not going to be <code>rfl</code></p>",
        "id": 473476619,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727634084
    },
    {
        "content": "<p>I think it's possible to make it defeq, but I'm not sure how well the kernel would like it, it might be very slow</p>",
        "id": 473476705,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727634141
    },
    {
        "content": "<p>let me take a look if i can whip something up</p>",
        "id": 473476753,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727634196
    },
    {
        "content": "<p>So there is always the quick and dirty solution I proposed above, which is to have both an equation and a law for each of the 4692 equations we care about, as well as 4692 theorems linking the two.  Not elegant, but it would work and perhaps not choke the Lean compiler if it could be compiled once and then cached?</p>",
        "id": 473476780,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727634224
    },
    {
        "content": "<p>About the name == for the \"law\" operator - this makes sense to me as an easy-to-write symbol, and it looks good enough on chats and programming editors. But it doesn't render very nicely in latex. Maybe we can use a symbol such as \\circeq there?</p>",
        "id": 473477833,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1727634662
    },
    {
        "content": "<p>I am partial to the idea of encoding implications using the pre-order one can place on <code>Law</code>, e.g., <code>Law1163 ≥ Law3521</code>, and anti-implications as <code>¬ Law1163 ≥ Law3521</code>, so that the entire API of Mathlib.Order becomes available (in particular to do transitive closure etc.), but then we need some metatheorems that allow one to convert these statements to <code>∀ (G: Type *) (hG: Magma G): Equation1163 G → Equation3521 G</code> and <code>∃ (G: Type *) (_: Magma G), Equation1163 G ∧ ¬ Equation3521 G</code> respectively.</p>",
        "id": 473478287,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727634809
    },
    {
        "content": "<p>I'm open to other suggestions on names.  One could simply permit both to be used, for instance, since neither symbol collides with anything commonly used in Mathlib. EDIT: i misread your comment. Sure, i’ll change == to \\circeq in the blueprint shortly.</p>",
        "id": 473478500,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727634889
    },
    {
        "content": "<p>I think you can use ordinary variables instead of Nats.</p>",
        "id": 473478929,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727635032
    },
    {
        "content": "<p>It's not super difficult. Lean already has a substantial parsing infrastructure</p>",
        "id": 473478979,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727635049
    },
    {
        "content": "<p>There are countably many identifiers</p>",
        "id": 473479170,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727635106
    },
    {
        "content": "<p>So you get the same cardinality for the variable set</p>",
        "id": 473479241,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727635125
    },
    {
        "content": "<p>OK that would be nice.  I had in my mind a conceptual separation between indeterminates (purely syntactic objects) and variables (quantities with a specified type), so for me it worked out well to use different symbols for the two (Nats for indeterminants, and <code>x y z w u v</code> for variables) but perhaps it would be easier for the majority of contributors to use the same symbol for both.  So one could write things like <code>G ⊧ x ∘ y = y ∘ x</code> in one line of code (in which <code>x y</code> are purely syntactic indeterminates) and then <code>x ∘ y = y ∘ x</code> in a later line of code (where now <code>x y : G</code> are variables of type <code>G</code>) without either the human or Lean getting confused</p>",
        "id": 473479622,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727635271
    },
    {
        "content": "<p>In LaTeX I typically use a different font to denote indeterminates (e.g., <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>⊨</mo><mi mathvariant=\"normal\">x</mi><mo>∘</mo><mi mathvariant=\"normal\">y</mi><mo>=</mo><mi mathvariant=\"normal\">y</mi><mo>∘</mo><mi mathvariant=\"normal\">x</mi></mrow><annotation encoding=\"application/x-tex\">G \\models \\mathrm{x} \\circ \\mathrm{y} = \\mathrm{y} \\circ \\mathrm{x}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.999em;vertical-align:-0.249em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊨</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord mathrm\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathrm\" style=\"margin-right:0.01389em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathrm\" style=\"margin-right:0.01389em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathrm\">x</span></span></span></span>) as opposed to variables (e.g., <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∘</mo><mi>y</mi><mo>=</mo><mi>y</mi><mo>∘</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x \\circ y = y \\circ x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>) but I don't think Lean supports fonts</p>",
        "id": 473479941,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727635381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473478929\">said</a>:</p>\n<blockquote>\n<p>I think you can use ordinary variables instead of Nats.</p>\n</blockquote>\n<p>by this, do you mean to use <code>FreeMagma String</code>? or something else?</p>",
        "id": 473480918,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727635729
    },
    {
        "content": "<p>Lean ident</p>",
        "id": 473481282,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727635885
    },
    {
        "content": "<p>That's an alias for all of <code>Syntax</code>, you probably want to use <code>Name</code> instead:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">MagmaWord</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MagmaWord</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MagmaWord</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MagmaWord</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MagmaWord</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"n\">declare_syntax_cat</span><span class=\"w\"> </span><span class=\"n\">magma_word</span>\n\n<span class=\"n\">syntax</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">magma_word</span>\n<span class=\"n\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"(\"</span><span class=\"w\"> </span><span class=\"n\">magma_word</span><span class=\"w\"> </span><span class=\"s2\">\"∘\"</span><span class=\"w\"> </span><span class=\"n\">magma_word</span><span class=\"w\"> </span><span class=\"s2\">\")\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">magma_word</span>\n\n<span class=\"n\">partial</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">elabMagmaWord</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">magma_word</span><span class=\"bp\">|$</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Meta.mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``MagmaWord.of</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"n\">i.getId</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">magma_word</span><span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">j</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabMagmaWord</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabMagmaWord</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">    </span><span class=\"n\">Meta.mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``MagmaWord.mul</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"n\">j</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Elab.throwUnsupportedSyntax</span>\n\n<span class=\"n\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"elabMagmaWord\"</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">:</span><span class=\"n\">magma_word</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">elabMagmaWord</span><span class=\"w\"> </span><span class=\"n\">w</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">elabMagmaWord</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">x3</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 473481793,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727636171
    },
    {
        "content": "<p>i was already on a similar path:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"o\">:</span><span class=\"n\">magma_term</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"n\">magma_term</span><span class=\"w\"> </span><span class=\"s2\">\"∘\"</span><span class=\"w\"> </span><span class=\"n\">magma_term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">magma_term</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"(\"</span><span class=\"w\"> </span><span class=\"n\">magma_term</span><span class=\"w\"> </span><span class=\"s2\">\")\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">magma_term</span>\n\n<span class=\"n\">declare_syntax_cat</span><span class=\"w\"> </span><span class=\"n\">magma_law</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"n\">magma_term</span><span class=\"w\"> </span><span class=\"s2\">\"=\"</span><span class=\"w\"> </span><span class=\"n\">magma_term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">magma_law</span>\n\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">elabMagmaTerm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">magma_term</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n\n<span class=\"w\">    </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``FreeMagma.Leaf</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">mkStrLit</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"bp\">.</span><span class=\"n\">toString</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">magma_term</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"n\">magma_term</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"n\">magma_term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``FreeMagma.Fork</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabMagmaTerm</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabMagmaTerm</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">magma_term</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">magma_term</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">elabMagmaTerm</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">elabMagmaLaw</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">magma_law</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"n\">magma_term</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"n\">magma_term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``Prod.mk</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabMagmaTerm</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabMagmaTerm</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwUnsupportedSyntax</span>\n\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"law{\"</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"n\">magma_law</span><span class=\"w\"> </span><span class=\"s2\">\"}\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">elabMagmaLaw</span><span class=\"w\"> </span><span class=\"n\">l</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">law</span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ζ</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 473481927,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727636284
    },
    {
        "content": "<p>Nice!</p>",
        "id": 473481999,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727636354
    },
    {
        "content": "<p>this elaborates to a <code>FreeMagma String</code>, for which we can likely write a simple function to transform it into <code>FreeMagma Nat</code> in a canonically reduced way?<br>\nright now i'm still concerned a bit about the fact that i haven't mentioned to lean if <code>∘</code> is left- or right-associative, could someone give me a pointer?</p>",
        "id": 473482308,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727636521
    },
    {
        "content": "<p>With the syntax approach you will need unexpanders. I think if you express the above with <code>notation</code> you will get the unexpanders for free</p>",
        "id": 473482363,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727636547
    },
    {
        "content": "<p>BTW, if you're happy to use json for serializing words, you could get the serialization and parsing automatically by deriving <code>ToJson</code> and <code>FromJson</code>. Using json might be useful anyway as it's easy to parse with essentially all other programming languages and already has the correct tree structure.</p>",
        "id": 473482365,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727636548
    },
    {
        "content": "<p>One thought: we could have a custom tactic to convert inequalities or anti inequalities between laws to their equational counterparts or vice versa. Then it is just one line of Lean code invoking the tactic to pass back and forth</p>",
        "id": 473482385,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727636574
    },
    {
        "content": "<p>An alternative is to do something similar to the <code>reassoc</code> attribute to automatically generate the equational lemmas from proofs of inequalities</p>",
        "id": 473482430,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727636618
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473482385\">said</a>:</p>\n<blockquote>\n<p>One thought: we could have a custom tactic to convert inequalities or anti inequalities between laws to their equational counterparts or vice versa. Then it is just one line of Lean code invoking the tactic to pass back and forth</p>\n</blockquote>\n<p>e.g. if one has to prove <code>Law25 ≥ Law166</code>, the tactic (let's call it <code>eqintros</code> for sake of argument) would introduce <code>G: Type *</code>, <code>[Magma G]</code>, <code>h: Equation25 G</code>, and enough variables <code>x y z: G</code> to state <code>Equation166 G x y z</code>, which is now the goal.  If one instead had to prove <code>¬ Law25 ≥ Law166</code>, a separate tactic (e.g., <code>counterexample G hG x y z</code>) would take a magma <code>(G:Type *) (hG: Magma G)</code> and return two goals: one to show <code>Equation25 G</code> (perhaps introducing relevant variables first), and the other to disprove <code>Equation166 G x y z</code>.</p>",
        "id": 473483332,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727637323
    },
    {
        "content": "<p>Actually with the tactic approach, we no longer actually need the EquationX <code>abbrev</code>s, the tactic handles the unfolding of all the <code>LawX</code> to appropriate universally quantified statements.</p>",
        "id": 473483609,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727637515
    },
    {
        "content": "<p>We probably want a more general tactic in addition to <code>counterexample</code>, that converts to the existential, in case we find a non-constructive proof? And then <code>counterexample</code> = <code>notimplies.exists + use</code></p>",
        "id": 473484300,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1727638121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473482363\">said</a>:</p>\n<blockquote>\n<p>With the syntax approach you will need unexpanders. I think if you express the above with <code>notation</code> you will get the unexpanders for free</p>\n</blockquote>\n<p>i'm having trouble finding a way to express this with merely notation, and looking at the metaprogramming guidebook i'm having a hard time writing unexpanders or delaborators... could someone else give it a go?</p>",
        "id": 473484863,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727638604
    },
    {
        "content": "<p>Unexpanders are a pain to write, especially when you want to embed lean declarations which expand into a magma term. If no one takes it up, I'll try in a few hours when I am on a machine.</p>",
        "id": 473485215,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727638950
    },
    {
        "content": "<p>Inside which PR can I find this in? Also did you try notation3?</p>",
        "id": 473485253,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727639009
    },
    {
        "content": "<p>my approach was the DSL approach, as described in the metaprogramming book.<br>\nfind my code at <a href=\"https://github.com/teorth/equational_theories/pull/113\">equational#113</a></p>",
        "id": 473486107,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727639766
    },
    {
        "content": "<p>Dang y'all are fast; I'm almost done with soundness, so we'll have a \"deep\" proof system at least.</p>",
        "id": 473486246,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727639902
    },
    {
        "content": "<p>I just created a task <a href=\"https://github.com/teorth/equational_theories/pull/114\">equational#114</a> to set up the standard API for homomorphisms between magmas, I have a feeling this will be useful in all the other syntactic tasks, including <a href=\"https://github.com/teorth/equational_theories/pull/104\">equational#104</a> and the rest of <a href=\"https://github.com/teorth/equational_theories/pull/36\">equational#36</a>.</p>",
        "id": 473487056,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727640643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473486107\">said</a>:</p>\n<blockquote>\n<p>my approach was the DSL approach, as described in the metaprogramming book.<br>\nfind my code at <a href=\"https://github.com/teorth/equational_theories/pull/113\">equational#113</a></p>\n</blockquote>\n<p>I think I can make notation work for this bit</p>",
        "id": 473487185,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727640763
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116028\">@Cody Roux</span> How are you planning to formalize equations in Lean? As pairs in <code>FreeMagma X</code> for some alphabet <code>X</code>?</p>",
        "id": 473487354,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727640935
    },
    {
        "content": "<p><a href=\"https://github.com/teorth/equational_theories/pull/115\">https://github.com/teorth/equational_theories/pull/115</a></p>",
        "id": 473487627,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727641154
    },
    {
        "content": "<p>Correct, just pairs (with names), I call them <code>lhs</code> and <code>rhs</code>, as is tradition, and use the notation <code>≃</code> (<code>\\simeq</code>) because it's close to what's in \"Term Rewriting and All that\".</p>",
        "id": 473487716,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727641219
    },
    {
        "content": "<p>All this can be easily changed before merge, I'm about to start on Birkhoff's theorem though I need to remember how quotients work in Lean.</p>",
        "id": 473487773,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727641278
    },
    {
        "content": "<p>I would put the pair behind a constructor.</p>",
        "id": 473487807,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727641312
    },
    {
        "content": "<p>A record is exactly an inductive with a single constructor, if that's what you mean.</p>",
        "id": 473487876,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727641348
    },
    {
        "content": "<p>I call it <code>SynEqn</code>, though I'm not in love with the name (seems Synfull)</p>",
        "id": 473487901,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727641386
    },
    {
        "content": "<p>I think <code>Law</code> would be a good name, I think it is rather consistent with the universal algebra literature (but I'd love for a universal algebraist to weigh in on this!)</p>",
        "id": 473487927,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727641422
    },
    {
        "content": "<p>I like \\simeq, I think I will adopt it for the blueprint</p>",
        "id": 473487994,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727641452
    },
    {
        "content": "<p>I think we lost most of them to category theory, sadly, TRaAT calls them \"Σ-identities\". I'll go with <code>Law</code> for now though.</p>",
        "id": 473488037,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727641508
    },
    {
        "content": "<p>unfortunately that will collide with mathlibs notation for <code>Equiv</code></p>",
        "id": 473488040,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727641517
    },
    {
        "content": "<p>i think <code>MagmaLaw</code> would be a bit more descriptive...</p>",
        "id": 473488056,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727641537
    },
    {
        "content": "<p>Use a higher priority</p>",
        "id": 473488061,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727641546
    },
    {
        "content": "<p>You can override an imported notation by increasing the priority of your declaration</p>",
        "id": 473488155,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727641588
    },
    {
        "content": "<p>I was proposing in <a href=\"https://github.com/teorth/equational_theories/pull/114\">equational#114</a> to introduce <code>MagmaHom</code> and <code>MagmaEquiv</code>, so <code>MagmaLaw</code> will fit right in</p>",
        "id": 473488167,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727641596
    },
    {
        "content": "<p>\"commutative law\" and \"associative law\" are in widespread use even in undergraduate mathematics, so I hope the meaning of \"law\" should be pretty accessible to the target audience here</p>",
        "id": 473488281,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727641704
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> : May I start working on <a href=\"https://github.com/teorth/equational_theories/pull/113\">equational#113</a>?</p>",
        "id": 473490399,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727643612
    },
    {
        "content": "<p>I don't want to create merge conflicts for you</p>",
        "id": 473490413,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727643620
    },
    {
        "content": "<p>This may have been discussed elsewhere, but, concerning <code>MagmaHom</code> is there a reason the project is not using <code>Mul</code> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MulHom#doc\">docs#MulHom</a> ?</p>",
        "id": 473491311,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727644488
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473491311\">said</a>:</p>\n<blockquote>\n<p>This may have been discussed elsewhere, but, concerning <code>MagmaHom</code> is there a reason the project is not using <code>Mul</code> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MulHom#doc\">docs#MulHom</a> ?</p>\n</blockquote>\n<p>Reposting my previous comment from the syntax thread:</p>\n<p>Terence Tao<a href=\"#narrow/stream/458659-Equational/topic/Syntax/near/472959874\">12:17 PM</a></p>\n<p>By the way, I initially used <code>[Mul α]</code> (or more precisely <code>[Add α]</code>) to encode Magmas but then ran into weird instance diamond issues when trying to create counterexample Magmas in which I wanted to redefine the addition or multiplication law on, say, the natural numbers. This was why I eventually created a new <code>Magma</code> class with a new infix symbol <code>∘</code>that did not conflict with the existing <code>+</code> and <code>*</code>symbols. By doing so I forego any API that Mathlib already has for <code>[Mul α]</code> or <code>[Add α]</code>, but for this project I'm not expecting much synergy with Mathlib anyway (although the API for basic number systems is useful to verify axioms for counterexamples, e.g., using <code>ring</code>, and <code>simp</code> has been working wonders also).</p>\n<p>[there is also the psychological effect that I at least think of a Mul structure as likely to be associative.]</p>",
        "id": 473491611,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727644751
    },
    {
        "content": "<p>I see. Thanks.</p>",
        "id": 473491719,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727644880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473490399\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> : May I start working on <a href=\"https://github.com/teorth/equational_theories/pull/113\">equational#113</a>?</p>\n</blockquote>\n<p>Feel free, I won't be able to work on it anyway while I'm asleep</p>",
        "id": 473492647,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727645757
    },
    {
        "content": "<p>Thanks. Will get to it now</p>",
        "id": 473492745,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727645809
    },
    {
        "content": "<p>Done</p>",
        "id": 473493657,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727646611
    },
    {
        "content": "<p>Also your MagmaLaw was capturing identifiers as strings. So if  I had defined <code>x</code> to be some other Magma, you would end up with a magma law that treated <code>x</code> as a new identifier</p>",
        "id": 473493716,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727646665
    },
    {
        "content": "<p>There is some complicated quoting and unquoting that I have seen experts use and that's a huge reason to use notation whenever you can</p>",
        "id": 473493800,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727646730
    },
    {
        "content": "<p>I suspect I can also recover the usual composition notation.</p>",
        "id": 473494148,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727647068
    },
    {
        "content": "<p>Nvm, I think you are using it as notation for the Magma typeclass, so it makes very little sense to overload it.</p>",
        "id": 473494350,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727647258
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> : I simplified the DSL, but I want to ask if you would still like Magma \"laws\" to be tagged as such</p>",
        "id": 473494760,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727647644
    },
    {
        "content": "<p>see examples : <a href=\"https://github.com/teorth/equational_theories/pull/113/files\">https://github.com/teorth/equational_theories/pull/113/files</a></p>",
        "id": 473494765,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727647647
    },
    {
        "content": "<p>I added the tag <code>magma law: </code> to denote magma laws.<br>\nExamples without and with this tag can be found respectively on the left and right hand side panel of this link : <a href=\"https://github.com/teorth/equational_theories/pull/113/commits/022d8de73ed0cd2f90894c7d8ec27900072d0e61\">https://github.com/teorth/equational_theories/pull/113/commits/022d8de73ed0cd2f90894c7d8ec27900072d0e61</a></p>\n<p>EDIT: It seems I may have posted two variations on labelling magma laws. Nevertheless, the previous two links can show the comparisons when taken together.</p>",
        "id": 473495448,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727648081
    },
    {
        "content": "<p>Done with completeness! I'm not sure how what I've done clashes with the discussion above; I'm happy to amend the PR: <a href=\"https://github.com/teorth/equational_theories/pull/115\">https://github.com/teorth/equational_theories/pull/115</a></p>",
        "id": 473509053,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727654863
    },
    {
        "content": "<p>Hopefully only notation needs to be updated (if that)</p>",
        "id": 473509147,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727654895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473494760\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> : I simplified the DSL, but I want to ask if you would still like Magma \"laws\" to be tagged as such</p>\n</blockquote>\n<p>I'm not sure what the precise technical advantages of this are, but as long as it is easy for automated tools (either within Lean, or external scrapers) to collect all the laws that are defined in a given file (in particular, presumably <code>Equations.lean</code> and <code>AllEquations.lean</code> will eventually transition over to defining some laws, rather than the current situation of  having them define equations), it should be fine.</p>",
        "id": 473510828,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727655792
    },
    {
        "content": "<p>These are essentially independent issues. There should be no trouble extracting these laws as data. The notation labelling merely allows readers of the code to separate laws from other stuff</p>",
        "id": 473511072,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727655992
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116028\">Cody Roux</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473509147\">said</a>:</p>\n<blockquote>\n<p>Hopefully only notation needs to be updated (if that)</p>\n</blockquote>\n<p>I think your notation mostly matches what we have.</p>",
        "id": 473511100,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727656028
    },
    {
        "content": "<p>I now notice that the definitions in the completeness proof uses <code>modelsEq</code> instead of \"satisfies\" in the doc, that's an easy change, but there's also <code>models</code> and <code>modelsSet</code> which need more harmonious names.</p>\n<p>Certainly I should have used <code>modelsLaw</code> at least.</p>",
        "id": 473511190,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727656122
    },
    {
        "content": "<p>The notations seem to align.</p>",
        "id": 473511196,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727656133
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473511072\">said</a>:</p>\n<blockquote>\n<p>These are essentially independent issues. There should be no trouble extracting these laws as data. The notation labelling merely allows readers of the code to separate laws from other stuff</p>\n</blockquote>\n<p>It looks like a fairly lightweight addition to the code, so I'm happy to put it in.  There should basically only be two files where we have to create laws, namely <code>Equations.lean</code> and <code>AllEquations.lean</code>,  all the other files will just import these files (which I expect to be rather stable, other than the occasional transferring of a law from the latter to the former), so if we add relevant tags and stuff to these files it shouldn't affect the workflow of most of the contributors.</p>",
        "id": 473511200,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727656145
    },
    {
        "content": "<p>Okay. So based on the above message <span class=\"user-mention\" data-user-id=\"116028\">@Cody Roux</span> : only a cosmetic change in the notation of laws is required. I think the easiest thing is to borrow the notation I just wrote for MagmaLaw</p>",
        "id": 473511360,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727656297
    },
    {
        "content": "<p>Where is it defined?</p>",
        "id": 473511452,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727656358
    },
    {
        "content": "<p>It's in </p>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473495448\">said</a>:</p>\n<blockquote>\n<p>I added the tag <code>magma law: </code> to denote magma laws.<br>\nExamples without and with this tag can be found respectively on the left and right hand side panel of this link : <a href=\"https://github.com/teorth/equational_theories/pull/113/commits/022d8de73ed0cd2f90894c7d8ec27900072d0e61\">https://github.com/teorth/equational_theories/pull/113/commits/022d8de73ed0cd2f90894c7d8ec27900072d0e61</a></p>\n<p>EDIT: It seems I may have posted two variations on labelling magma laws. Nevertheless, the previous two links can show the comparisons when taken together.</p>\n</blockquote>\n<p>It's in the link</p>",
        "id": 473511481,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727656387
    },
    {
        "content": "<p>Another thing, we can use a little trick to define the notation for <code>derive</code> beforehand</p>",
        "id": 473511502,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727656410
    },
    {
        "content": "<p>And use it in the inductive type</p>",
        "id": 473511511,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727656417
    },
    {
        "content": "<p>Ah that'd be nice! I knew this in Coq, but I didn't figure it out in Lean.</p>",
        "id": 473511834,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727656646
    },
    {
        "content": "<p>Let me try to fix rebase-hell and fix the notation thing.</p>",
        "id": 473511881,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727656671
    },
    {
        "content": "<p>I just added the suggestion as a review comment.</p>",
        "id": 473512723,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727657050
    },
    {
        "content": "<p>Whew, I don't know how I always bork things up with Git. Thanks for the suggestion <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span>. I'll refer to the correct <code>MagmaLaw</code> notation as soon as it's merged.</p>",
        "id": 473518105,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727658792
    },
    {
        "content": "<p>Hey, I have compactness now! <a href=\"https://github.com/codyroux/equational_theories/blob/0827d2a480dd8c82b66974f7819cd674ca192f81/equational_theories/Compactness.lean#L81\">https://github.com/codyroux/equational_theories/blob/0827d2a480dd8c82b66974f7819cd674ca192f81/equational_theories/Compactness.lean#L81</a></p>\n<p>I'll create a PR if desired, but for now I'll just sleep.</p>",
        "id": 473546214,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727665680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473493716\">said</a>:</p>\n<blockquote>\n<p>Also your MagmaLaw was capturing identifiers as strings. So if  I had defined <code>x</code> to be some other Magma, you would end up with a magma law that treated <code>x</code> as a new identifier</p>\n</blockquote>\n<p>Indeed, as the purpose of the syntax I suggested was to capture concrete laws.</p>",
        "id": 473601155,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727677491
    },
    {
        "content": "<p>It seems we had different ideas in mind as to the purpose of the syntax</p>",
        "id": 473601427,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727677544
    },
    {
        "content": "<p>In my mind, it would be a way to construct a concrete law</p>",
        "id": 473602552,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727677758
    },
    {
        "content": "<p>It constructs the same concept</p>",
        "id": 473622267,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727680910
    },
    {
        "content": "<p>It's just that with notation to construct a term in multiple pieces</p>",
        "id": 473622610,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727680955
    },
    {
        "content": "<p>It doesn't. What you defined constructs laws with free variables</p>",
        "id": 473622651,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727680964
    },
    {
        "content": "<p>That's not a concrete law</p>",
        "id": 473622819,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727681002
    },
    {
        "content": "<p>I actually only replaced the syntax parts</p>",
        "id": 473623637,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727681148
    },
    {
        "content": "<p>The elaboration is different now</p>",
        "id": 473623879,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727681183
    },
    {
        "content": "<p>It was on purpose that it turned the identifiers into strings</p>",
        "id": 473623989,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727681204
    },
    {
        "content": "<p>Yeah it creates free variables</p>",
        "id": 473624074,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727681218
    },
    {
        "content": "<p>A Leaf Node</p>",
        "id": 473624269,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727681252
    },
    {
        "content": "<p>A leaf node is not the same as a free variable</p>",
        "id": 473624358,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727681270
    },
    {
        "content": "<p>But that's exactly what you were doing in line 24</p>",
        "id": 473624586,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727681309
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/QxMtWhLt_37bdeKXaWP2kv2K/Screenshot_20240930-092901.png\">Screenshot_20240930-092901.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/QxMtWhLt_37bdeKXaWP2kv2K/Screenshot_20240930-092901.png\" title=\"Screenshot_20240930-092901.png\"><img data-original-dimensions=\"961x1047\" src=\"/user_uploads/thumbnail/3121/QxMtWhLt_37bdeKXaWP2kv2K/Screenshot_20240930-092901.png/840x560.webp\"></a></div>",
        "id": 473625117,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727681404
    },
    {
        "content": "<p>What I have done is an exact syntactic replacement</p>",
        "id": 473625451,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727681468
    },
    {
        "content": "<p>It isn't? Your code doesn't produce leaf nodes</p>",
        "id": 473625778,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727681525
    },
    {
        "content": "<p>You changed the semantics</p>",
        "id": 473625936,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727681556
    },
    {
        "content": "<p>One second</p>",
        "id": 473625964,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727681563
    },
    {
        "content": "<p><em>and</em> the syntax</p>",
        "id": 473625988,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727681567
    },
    {
        "content": "<p>I'll check it again. Not on a laptop</p>",
        "id": 473626051,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727681583
    },
    {
        "content": "<p>I simply removed the extra syntax you had built which still elaborated to a freemagma structure</p>",
        "id": 473626315,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727681642
    },
    {
        "content": "<p>We can reintroduce it</p>",
        "id": 473626803,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727681737
    },
    {
        "content": "<p>But from the point of view of theorems, I don't see the difference. Lean will see the same Expr</p>",
        "id": 473626968,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727681770
    },
    {
        "content": "<p>And so the same theorems will be true modulo the fact that my second example would be a syntax error in your case, which would only be disallowing you to construct large terms in many steps.</p>",
        "id": 473627702,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727681956
    },
    {
        "content": "<p>The only difference is in surface level syntax</p>",
        "id": 473628019,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727682023
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473626315\">said</a>:</p>\n<blockquote>\n<p>I simply removed the extra syntax you had built which still elaborated to a freemagma structure</p>\n</blockquote>\n<p>We can replicate your syntax in the file by altering the FreeMagma notation, but the outcome is the same</p>",
        "id": 473630207,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727682589
    },
    {
        "content": "<p>To make my claim more concrete, lean is seeing the same Expr object in both our syntaxes (except the star notation instead of \\o, but this can be changed). So the metatheorems that can be proved are identical. Only the surface rendering of syntax has changed, and now we can construct the Expr in many steps and get the unexpander for free. I haven't altered the semantic content in anyway (I might have added the universe polymorphism thing)</p>",
        "id": 473631457,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727682907
    },
    {
        "content": "<p>But yeah the changes can be reset or rolled back</p>",
        "id": 473631653,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727682957
    },
    {
        "content": "<p>it was my intention to eventually have <code>law{x * y = y * x}</code> (modulo notation for Fork) translate effectively to <code>(Fork (Node 0) (Node 1),Fork (Node 1) (Node 0))</code>, with explicit nodes. (i.e. always interpret identifiers inside <code>law{...}</code> as variables of the law)</p>",
        "id": 473633835,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727683446
    },
    {
        "content": "<p>Ah then the syntax that was there before doesn't quite do that</p>",
        "id": 473634188,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727683493
    },
    {
        "content": "<p>It simply interprets identifiers as is</p>",
        "id": 473634439,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727683524
    },
    {
        "content": "<p>indeed, but it does already produce the nodes. changing from <code>String</code> to <code>Nat</code> is a matter of defining a recursive function, and applying it.</p>",
        "id": 473634599,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727683542
    },
    {
        "content": "<p>in that sense, interpreting the identifiers as <code>String</code> does help along the way.</p>",
        "id": 473634866,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727683567
    },
    {
        "content": "<p>Right, so I just took the syntax def and converted it</p>",
        "id": 473635078,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727683593
    },
    {
        "content": "<p>And then removed what felt like redundant Notation</p>",
        "id": 473635183,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727683607
    },
    {
        "content": "<p>I have a suggestion though. These indices can be hard to maintain</p>",
        "id": 473635577,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727683660
    },
    {
        "content": "<p>what indices?</p>",
        "id": 473635696,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727683672
    },
    {
        "content": "<p>Nat indices that you use for variables</p>",
        "id": 473635870,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727683688
    },
    {
        "content": "<p>how do you mean maintain?</p>",
        "id": 473636081,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727683716
    },
    {
        "content": "<p>You would need to track multiple occurrences of the same variable through rewrites, simplifications, and substitution</p>",
        "id": 473636495,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727683763
    },
    {
        "content": "<p>I am guessing</p>",
        "id": 473636542,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727683769
    },
    {
        "content": "<p>i was under the impression that we won't do those operations on laws, but rather on equations.</p>",
        "id": 473637114,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727683830
    },
    {
        "content": "<p>so imo that's a non-issue</p>",
        "id": 473637855,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727683914
    },
    {
        "content": "<p>Okay, but then you will need that for equations</p>",
        "id": 473638075,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727683942
    },
    {
        "content": "<p>In any case, adapting this notation to the Nat index variables is not too hard</p>",
        "id": 473638312,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727683968
    },
    {
        "content": "<p>The current notation is, modulo surface level syntactic differences, just the same as the syntax as it was in the file  before.</p>",
        "id": 473639098,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727684072
    },
    {
        "content": "<p>that's not true?</p>",
        "id": 473639181,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727684089
    },
    {
        "content": "<p>How is it different?</p>",
        "id": 473639316,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727684104
    },
    {
        "content": "<p>like i said, your syntax produces free variables, while mine produces nodes</p>",
        "id": 473639364,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727684109
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"https://leanprover.zulipchat.com#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473625117\">said</a>:</p>\n<blockquote>\n<p><a href=\"/user_uploads/3121/QxMtWhLt_37bdeKXaWP2kv2K/Screenshot_20240930-092901.png\">Screenshot_20240930-092901.png</a></p>\n</blockquote>\n<p>Not here</p>",
        "id": 473639567,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727684134
    },
    {
        "content": "<p>Anyway, I think there is still one challenge</p>",
        "id": 473639923,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727684175
    },
    {
        "content": "<p>With nat indexed Nodes</p>",
        "id": 473639968,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727684181
    },
    {
        "content": "<p>When translating syntax recursively, for each identifier, you have to keep track of whether it has already been assigned a number or not</p>",
        "id": 473640554,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727684252
    },
    {
        "content": "<p>And how many numbers have already been used for up for variables.</p>",
        "id": 473640733,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727684275
    },
    {
        "content": "<p>Invariably this will require a 'context' that maps Nats to identifier strings.</p>",
        "id": 473640984,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727684303
    },
    {
        "content": "<p>with your syntax, <code>#check magma law: x ⋆ (combine x y) ⋆ z ≃ z</code> requires <code>x:FreeMagma ?m</code>, which is not an explicit leaf. it can be a fork.</p>",
        "id": 473642068,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727684436
    },
    {
        "content": "<p>so it is <em>not</em> the same.</p>",
        "id": 473642148,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727684449
    },
    {
        "content": "<p>Okay, we can actually get the underlying Expr</p>",
        "id": 473642673,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727684562
    },
    {
        "content": "<p>I think I see your point in that you don't want identifiers to represent FreeMagma terms</p>",
        "id": 473644650,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727685017
    },
    {
        "content": "<p>This can be fixed.</p>",
        "id": 473644711,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727685029
    },
    {
        "content": "<p>The fix is to add a separate identifier type, and a FreeMagma \"var\" constructor that takes values of this type.</p>",
        "id": 473644892,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727685068
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> : we can roll the notation to your commit if that is your preference. Here is an <a href=\"https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAGQKYEMB2BYAUKSs4CyKMAFgDbABGAdACooDGMwD2EYSaiqXy61AZQCeaGCgAe3fgAUoSGDCGzgopFGzYVAEwCuTYADckcAELa1cAO4k1SbHDgAfUwDkUIJFrgAKAM5wALjgBGCgVAHMASnsnUwBBNAhMLC01Qwi4ACUkMCgAGjgAESQGYC0USjIkAFEARw0cNF19I0Rq8VyrGzkY5wA1FCgfSSCQsLQo3sR3YcDTcyhIn2MghHbc6KwHZziwMGXAQII4JEAggjm1jsWphGAYAElRHy4gwBJCTe24aTIdf28kI9O53WVxSaQMGWyuQKxVK5UqNXqWDYHF4wOwqQYZEGSAA+r4RGJxDiGMQ4CoYNh8aIJD4AEQAWlpkQA/HA0DoQHNyZSCTTaQBtABazlpZMeooAuqKgjA1CAGiBGFAIDioDoqr5sM4AAbeIWOAAkaAC7JAEqWAF4AHxwXVGzY6vXC+lGk0c81wa227wutCbBrokpYuR43lEknwSgLHnUyRlTjwIJRppqGOEuACkyOUXJ1JDWlSuayqDypFYRUMZWq9VITVYR38rMG8QBeOiD1euBaCAxBwOKrwcRjDIBC1SNDUWo6CCynwwCDDiZwcTUcLyO5ad59hy6swpqDUExuDxeZuLyZljHB3FUwnE0lIS5pmltxPHJ9YW8vx5BR+5Z+SLSgDdwBmcC5hYoqAGWEoF/kMv4fl+kiwaBADtMGXHMsEAe+nSigA1OhnTwf+n5hhm3iEfmcCRNKOHqKRsYZvyWIgCKdGgYWMpygqSoqmqGpat6zHuM4zatqk7aWjauoXLk1ADEMBreHwE5TjOxjePO57Lqu66bpEDpCSxzggQalABOBQzQQaSABLBHbScpwLUAgMyNoalASnAwmsXANnmoJuo+aJ/xwGhNknA53qyQeuz7MFNkHF5CWnAF9ZGSJfnGuSUUyc5Nz3I8+pGmlDbGT4Nl2ZckS5Xq5X+YZQX1aFBERbVMXUF8Pzec1SU9ZlbX+mW9L0nAtA2L4xgMBAailEk/jYnAPyeGBQhwKQxg6Ggf7oHm/iUEgZAQJYmhoL4YhoAwKxwAAwjNcAuByBU+LQwiMdqsFLNYtgxNNxj+KOcCABfkvjUFAKCWIAl+QNCo53oFdcx3Rpr1kdq5JLN4KPvZ9XQ/VscB/XAANjiDYMQ9DZanXDl3XUjcAbgmL1vemH3VbjPT44TxPA6D4NQzDZ0XQjQR02Mz2Y8zNLapZX3dHYnP3dzpN8xTsNC7T91i7cTOozj30cw4XOBCTvPkwGZYAAL8igew4ltO37vM+6HsengSoGABmS3bR0u1Hu4K1BAAqj7YC7am+OOgaOJ7nmLsB6eLbnYsnqOe5fniGlHw4qn60kMqlg+ENVs22Aduh+HQwdQVDwwO7oJe/bvtNDXP5wCHDt5lMdo582Um9nAiowAwJDLlYtwkAPUctqaUkZb5zZZ32joujPHJz01mWr0v2e56QBdF1MOdevvx2H5b1u203YeOx1XW+PXqSNxXTT33MHfN13kfetHd/fP4wU/L/CqrkZKzUTggKgLVQBiU4CtVSluZwx8bSn0Lt4Yul8y7X0rm0S4Ll3CPyQM/TurlOTBxfl/D4Pdq5uSzH5cylkwEDVsvZDedURKmUoHAaySAl5IL3vnM+6CGglyvhQiwHU4qEOIZ/OK79xH0Sod4X+zk5EwOAfZfqC9TiQOgb1MKQDIqILgMgvOB9hEX1LuXTuEjnIKWkd7TuCl5E2MUbEahdjBgZwCMnNhMDM7GNMag8+5sADEI8SgAGstHOEznAEaMSMziElHMVUEAZw4hcmiLA4SbAMGiYAkCa1oJrQIqU5cXkEmFIzEIKCNT8L1LgUklJQQ0kZKyR+XJUTEn0gAIyVNGtXW4tcfB9KWK05U7SYrm20HoZgrQBhkHZvLD4rcYB9CeHMN41x3AbO8CMJ2eYMbXRipsPM6QlyQnyEUEoZQKhVDqMiTgcBFkNCvNiUMsZ7zwAMCgMg2FyRzF+f8hi6ZgKgUsqBaCopkJBGBdhAUwK2LAo4rRYspZsAVirPxWsgU9RIqyq2SSuddSLJcsM0QGz9RZVKkJAlnCLILG4UA3RbCyWkKpU2TyMSGoC2psLW691HogHFljFmwLZZ40NorY2PMyb80aPyjWyNJaSDRqIDGYqpYSuWb9GVgNlZmywKIrBCiXl/PJYVdZDjsEt1uH0EZ5DXHd2Ub3cQ/d8YOCHiPMelgJ5Tx/mvEAfiCWLy3Eo1ebpg0kvxX85w29w2xCCYItBgSBHmIwVY21eZzVkHwSAPoNqKEcpcZ/COSjo7st2d5JscSUrQPpRnZlvLv7JozQ0Lp+TvIEv6dgTtBTG2SGguIFCI7M59oiV2/kBK+n1yAA\">example for unexpanders I wrote a year ago:</a></p>",
        "id": 473646763,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727685519
    },
    {
        "content": "<p>You might like to compare with the formulae in mathlib's model theory, which already seems to have many of the features you are discussing (in particular nat indexed nodes and correct assignment)</p>",
        "id": 473724927,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1727701812
    },
    {
        "content": "<p>Opened <a href=\"https://github.com/teorth/equational_theories/pull/147\">equational#147</a> to formalize the base versions of tactic mentioned earlier, tentatively named <code>equation_to_law</code> and <code>law_to_equation</code>, though other name suggestions are welcome.</p>",
        "id": 473764268,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727708761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473483332\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473482385\">said</a>:</p>\n<blockquote>\n<p>One thought: we could have a custom tactic to convert inequalities or anti inequalities between laws to their equational counterparts or vice versa. Then it is just one line of Lean code invoking the tactic to pass back and forth</p>\n</blockquote>\n<p>e.g. if one has to prove <code>Law25 ≥ Law166</code>,</p>\n</blockquote>\n<p>I think that actually Lean is already happy for you to use equalities like this using the existing <code>Equation25 ≤ Equation166</code>?</p>",
        "id": 473768217,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727709498
    },
    {
        "content": "<p>Via the <code>LE</code> instance on function types and on propositions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"c1\">-- change to Mul just to make a mwe</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Equation1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Equation2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"c1\">-- this spelling of implication is legal!</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equation2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Equation1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 473768339,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727709535
    },
    {
        "content": "<p>the issue with that is that for all those we'll have all of them equivalent?</p>",
        "id": 473768523,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727709585
    },
    {
        "content": "<p>Yeah I don't think mathlib type classes ought to be used when developing a syntactic metatheory</p>",
        "id": 473768678,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727709619
    },
    {
        "content": "<p><del>or <em>almost</em> all, since they represent the statement \"for all magmas G, this holds\"</del> nvm i think i was confused</p>",
        "id": 473768701,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727709625
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473768523\">said</a>:</p>\n<blockquote>\n<p>the issue with that is that for all those we'll have all of them equivalent?</p>\n</blockquote>\n<p>What do you mean by this?</p>",
        "id": 473768751,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727709640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473768678\">said</a>:</p>\n<blockquote>\n<p>Yeah I don't think mathlib type classes ought to be used when developing a syntactic metatheory</p>\n</blockquote>\n<p>I don't think there is any reason to reject Pi.instLE from mathlib if it's useful.</p>",
        "id": 473768943,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727709684
    },
    {
        "content": "<p>To be clear, I'm not arguing against building the metatheory; but if you're going to use ≤ in the metatheory, why not also use it in the theory for consistency?</p>",
        "id": 473769366,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727709782
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/458659-Equational/topic/Equations.20vs.20Laws/near/473768339\">said</a>:</p>\n<blockquote>\n<p>Via the <code>LE</code> instance on function types and on propositions</p>\n</blockquote>\n<p>oh, I had a PR for that, not sure if it's the same (PR: <a href=\"https://github.com/teorth/equational_theories/pull/135\">equational#135</a>, issue: <a href=\"https://github.com/teorth/equational_theories/pull/132\">equational#132</a>)</p>",
        "id": 473769668,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1727709861
    },
    {
        "content": "<p>(as in, not sure if you're saying we'd get the same instance synthesized from Mathlib somewhere)</p>",
        "id": 473769824,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1727709906
    },
    {
        "content": "<p>It's a design issue. When you are invoking any mathlib typeclass, you also get a number of other theorems and equalities that come with that typeclass. It is easier to build and study syntactic relations you need from scratch as inductive types so that you start with the weakest form of that relation.</p>",
        "id": 473769935,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727709935
    },
    {
        "content": "<p>Namely the one that lean's definitional equality gives it.</p>",
        "id": 473770197,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727709984
    },
    {
        "content": "<p>i think it should be enough to allow it, so long as we add proofs that it means what you think it means.</p>",
        "id": 473770342,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727710024
    },
    {
        "content": "<p>Edited above with an example, the definitional equality is the same as the one you'd write by hand</p>",
        "id": 473777763,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727711288
    },
    {
        "content": "<p>So you can get the order structure you want on laws by just pulling back from the order structure on equations</p>",
        "id": 473777982,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727711352
    },
    {
        "content": "<p>i'm basically finished making the delaborator (unexpander) for laws. i'm pretty sure that people with more experience writing code related to the prettyprinter can touch it up more though, so if, for example, you know how to work the parenthesiser, feel free to suggest a change. however, please make sure the examples still work as documented... find the code <a href=\"https://github.com/edegeltje/equational_theories/blob/magmalaw-dsl-but-actually/equational_theories/MagmaLaw.lean\">here</a></p>",
        "id": 473780771,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727712029
    },
    {
        "content": "<p>a small excerpt:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- magmaterm{(x ∘ (y ∘ (z ∘ zks)))} : FreeMagma String</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">magmaterm</span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">zks</span><span class=\"o\">)}</span>\n\n<span class=\"c1\">-- magmalaw{x ∘ y ∘ z ≃ z} : MagmaLaw String</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">magmalaw</span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- magmalaw{x ∘ y ≃ y ∘ x} : MagmaLaw Nat</span>\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">reduce_law</span><span class=\"w\"> </span><span class=\"n\">magmalaw</span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- magmalaw{x ∘ y ≃ y ∘ x} : MagmaLaw Nat</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">MagmaLaw</span><span class=\"bp\">.</span><span class=\"n\">mk</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">FreeMagma</span><span class=\"bp\">.</span><span class=\"n\">Fork</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FreeMagma</span><span class=\"bp\">.</span><span class=\"n\">Leaf</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FreeMagma</span><span class=\"bp\">.</span><span class=\"n\">Leaf</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">FreeMagma</span><span class=\"bp\">.</span><span class=\"n\">Fork</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FreeMagma</span><span class=\"bp\">.</span><span class=\"n\">Leaf</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FreeMagma</span><span class=\"bp\">.</span><span class=\"n\">Leaf</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 473780969,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727712080
    },
    {
        "content": "<p>code style nitpicks are welcome too</p>",
        "id": 473781772,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727712274
    },
    {
        "content": "<p>I think you should test this setup by proving a few syntactic theorems. While doing so, do check if the unexpander experience is optimal.</p>",
        "id": 473782350,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727712391
    },
    {
        "content": "<p>i've written a proof about equation1 and equation2 as examples. it's not trivial to transform the goal into the usual shape, but that's not an issue with the notation/unexpander, just with the fact that we're doing meta theorems. it is definitely imaginable that a tactic does the \"meta\"-transformation.</p>",
        "id": 473805429,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727717307
    },
    {
        "content": "<p>another feasible addition might be some sort of \"escaping\" syntax to allow variables to be used in declaring laws and expressions.</p>",
        "id": 473806174,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727717434
    },
    {
        "content": "<blockquote>\n<p>it's not trivial to transform the goal into the usual shape</p>\n</blockquote>\n<p>i would expect it to be straightforward to train <code>dsimp</code> to do this</p>",
        "id": 473808353,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727718133
    },
    {
        "content": "<p>I dont know, can dsimp turn quantification over <code>f:a-&gt;b</code> into multiple quantification over <code>b</code>, for every point where f is evaluated?</p>",
        "id": 473808901,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727718318
    },
    {
        "content": "<p>Because I don't think that's defeq</p>",
        "id": 473809106,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727718366
    },
    {
        "content": "<p>(i suspect there's a way to make this work anyway, but i also suspect it involves a custom elaborator)</p>",
        "id": 473810029,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727718665
    },
    {
        "content": "<p>Where are you defining the conversion between laws and Prop?</p>",
        "id": 473811809,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727719281
    },
    {
        "content": "<p>I'm confused by the three different PRs doing this</p>",
        "id": 473811879,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727719296
    },
    {
        "content": "<p>I think the project is moving in a more distributed fashion</p>",
        "id": 473812013,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727719319
    },
    {
        "content": "<p><a href=\"https://github.com/edegeltje/equational_theories/blob/magmalaw-dsl-but-actually/equational_theories/MagmaLaw.lean\">here</a></p>",
        "id": 473812015,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727719319
    },
    {
        "content": "<p>Ah I see, it reduces to <code>∀ (f : ℕ → G), f 0 ∘ f 1 = f 1 ∘ f 0</code> rather than the nested quanfiers you could get by having a special evaluation function for <code>Fin</code>-indexed equations</p>",
        "id": 473832744,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727724241
    },
    {
        "content": "<p>i suppose you could recursively define the \"support\" of the law, and then make the domain of <code>f</code> only that support (or something like that)...</p>",
        "id": 473833285,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727724334
    },
    {
        "content": "<p>but i still don't know that that would allow <code>dsimp</code> to \"unfold\" the universal quantifier...</p>",
        "id": 473833619,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727724406
    },
    {
        "content": "<p>Yep that's how it works in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula</a></p>",
        "id": 473833728,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727724430
    },
    {
        "content": "<p>Not sure it's worth the hassle here, since there's only quantifiers at the top level.</p>",
        "id": 473833887,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727724468
    }
]