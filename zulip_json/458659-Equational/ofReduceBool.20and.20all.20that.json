[
    {
        "content": "<p><code>native_decide</code> is just a wrapper around <code>ofReduceBool</code></p>",
        "id": 517952956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747187487
    },
    {
        "content": "<p>currently the design of axiom tracking around compiler things means that it's not just \"we trust the compiler\", it's really trusting an unbounded set of extensions to the compiler</p>",
        "id": 517953079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747187578
    },
    {
        "content": "<p>which makes it pretty much useless from a trust perspective unless you are only checking that it isn't present</p>",
        "id": 517953110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747187606
    },
    {
        "content": "<p><code>@[csimp]</code> is one of those extension mechanisms</p>",
        "id": 517953185,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747187647
    },
    {
        "content": "<p>And bvdecide also trusts the compiler iirc</p>",
        "id": 517953207,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1747187661
    },
    {
        "content": "<p><code>@[csimp]</code>, <code>@[implemented_by]</code> and <code>@[extern]</code> all get laundered through <code>ofReduceBool</code></p>",
        "id": 517953222,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747187674
    },
    {
        "content": "<p><code>bv_decide</code> also uses <code>ofReduceBool</code></p>",
        "id": 517953497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747187873
    },
    {
        "content": "<p>Fun fact, there is also <code>ofReduceNat</code> but I think no one has ever used it</p>",
        "id": 517953549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747187889
    },
    {
        "content": "<p>It seems the more efficient a tactic needs to be, the more its author is willing to trust the compiler.</p>",
        "id": 517953737,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1747188017
    },
    {
        "content": "<p>that's kind of a necessity thing. Some tasks are just too big to be done using the 'slow trusted' tools we have</p>",
        "id": 517953852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747188083
    },
    {
        "content": "<p>But you can get pretty far with kernel computation if you use it right</p>",
        "id": 517953947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747188129
    },
    {
        "content": "<p><code>bv_decide</code> is basically not a tactic you or I will ever have cause to use</p>",
        "id": 517953983,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747188164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/458659-Equational/topic/Bump.20to.20v20.2E0-rc5/near/517953497\">said</a>:</p>\n<blockquote>\n<p><code>bv_decide</code> also uses <code>ofReduceBool</code></p>\n</blockquote>\n<p>But the possible set of csimp/implemented_by/extern that apply to bv_decide are limited to what's available in core and you can review those. So I would argue the set is by no means unbounded in this case and if you trust the attributes in core it is indeed only the compiler you have to trust.</p>",
        "id": 517971930,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1747199801
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> It uses <code>ofReduceBool</code>, which means it makes post hoc verification very difficult because <code>#print axioms</code> shows it as a use of <code>ofReduceBool</code> and it's not very easy to determine whether a proof containing <code>ofReduceBool</code> got it because <code>bv_decide</code> put it there or something else did</p>",
        "id": 518055896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747226731
    },
    {
        "content": "<p>It would be better if it used <code>ofReduceBoolForBVDecide</code></p>",
        "id": 518055981,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747226759
    },
    {
        "content": "<p>Or more to the point, the argument to <code>ofReduceBool</code> (which is always a constant declaration) needs to be marked as \"vetted by <code>bv_decide</code> maintainers\"</p>",
        "id": 518056384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747226841
    },
    {
        "content": "<p>i.e. it always boils down to \"we need better tracking for ofReduceBool\"</p>",
        "id": 518056499,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747226871
    },
    {
        "content": "<p>because the worst part is that you can't look at the term itself to be executed to determine whether it is something bv_decide would have produced</p>",
        "id": 518056720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747226922
    },
    {
        "content": "<p>If the argument involves saying \"I know it's fine because I called the <code>bv_decide</code> function and this definition popped out\" then that means you aren't just validating that the proof object is correct, you have to trust that the execution process itself hasn't been compromised. This implicates the entire elaborator and all the rest of lean</p>",
        "id": 518057175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747227038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/Bump.20to.20v20.2E0-rc5/near/518055981\">said</a>:</p>\n<blockquote>\n<p>It would be better if it used <code>ofReduceBoolForBVDecide</code></p>\n</blockquote>\n<p>I don't think that would help? Every other person could also use that</p>",
        "id": 518057663,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1747227155
    },
    {
        "content": "<p>You're right. That would make tracking easier but not in an adversarial scenario</p>",
        "id": 518057882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747227205
    },
    {
        "content": "<p>Here's an illustration of the issue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">black_magic</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">lie</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"c1\">-- local to destroy the evidence of tampering</span>\n<span class=\"kd\">@[</span><span class=\"n\">local</span><span class=\"w\"> </span><span class=\"n\">csimp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">lie_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">lie</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">lie_eq</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">lie</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">contra</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">nomatch</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">ofReduceBool</span><span class=\"w\"> </span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">macro_rules</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bv_decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">contra</span><span class=\"o\">)</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">black_magic</span>\n\n<span class=\"c1\">-- Proof by bv_decide</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">bv_decide</span>\n\n<span class=\"c1\">-- axioms check out</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"c1\">-- 'foo' depends on axioms: [Lean.ofReduceBool]</span>\n\n<span class=\"c1\">-- Even if we poke at each definition evaluated by an `Lean.ofReduceBool` we see nothing weird</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"c1\">-- 'prog' does not depend on any axioms</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"c1\">-- def prog : Bool := lie</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">lie</span><span class=\"w\"> </span><span class=\"c1\">-- def lie : Bool := false</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">Compiler</span><span class=\"bp\">.</span><span class=\"n\">hasCSimpAttribute</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"ss\">`prog</span><span class=\"w\"> </span><span class=\"c1\">-- false</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">Compiler</span><span class=\"bp\">.</span><span class=\"n\">hasCSimpAttribute</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"ss\">`lie</span><span class=\"w\"> </span><span class=\"c1\">-- false</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{(IR.findEnvDecl (← getEnv) `prog).get!}\"</span>\n<span class=\"c1\">-- def prog : u8 :=</span>\n<span class=\"c1\">--   let x_1 : u8 := 1;</span>\n<span class=\"c1\">--   ret x_1</span>\n</code></pre></div>",
        "id": 518059083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747227498
    },
    {
        "content": "<p>I had the same criticism of the Veil tool. In their default setting, they simply insert their SMT verified theorems as theorem statements with a sorry. This doesn't scale well in a large proof development, since it requires extra work to track down where the sorries are coming from, especially since the tool inserted theorems don't show up in the editor.</p>",
        "id": 518065482,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1747229075
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/458659-Equational/topic/Bump.20to.20v20.2E0-rc5/near/518065482\">said</a>:</p>\n<blockquote>\n<p>I had the same criticism of the Veil tool. In their default setting, they simply insert their SMT verified theorems as theorem statements with a sorry. This doesn't scale well in a large proof development, since it requires extra work to track down where the sorries are coming from, especially since the tool inserted theorems don't show up in the editor.</p>\n</blockquote>\n<p><code>bv_decide</code> is very different though, with the SMT stuff you trust arbitrary results from an SMT solver. With <code>bv_decide</code> assuming that all implemented_by/csimp in core are fine (which, given the fact they are one of the most well tested code we have they probably are) and the compiler is fine it is guaranteed to be correct, there is no trusting the SAT solver or something like that.</p>",
        "id": 518066454,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1747229312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> 's point is about the non-adversarial setting. In a large project there can be bad uses and good uses of <code>sorry</code> and <code>ofReduceBool</code>, and even if one accepts that <code>bv_decide</code> is a \"good use\" it's still blending into the crowd</p>",
        "id": 518066722,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747229383
    },
    {
        "content": "<p>I suspect that <code>bv_decide</code> is using <code>ofReduceBool</code> more than necessary; I'm sure that large SAT certificates need it but small ones can be evaluated in the kernel</p>",
        "id": 518068130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747229721
    },
    {
        "content": "<p>It's a UX problem. I want to be able to isolate <code>sorry</code>s and <code>ofReduceBool</code>s that are generated by specific tools from ones I write and want to remove later.</p>",
        "id": 518068226,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1747229748
    },
    {
        "content": "<p>(keep in mind that a significant fraction of calls to <code>linarith</code> and <code>omega</code> are things like <code>x &lt; x + 1</code> - there is value in optimizing for the small case)</p>",
        "id": 518068416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747229788
    },
    {
        "content": "<p>That's not the only reason bv_decide uses ofReduceBool. It also needs to demonstrate to the kernel that the generated CNF is equivalent to the actual reflected problem which it does by rerunning bitblasting as part of the ofReduceBool invocation. Bitblasting being fast heavily relies on HashMaps, computed_field hash codes etc. You can't just evaluate the bitblaster with kernel reduction.</p>",
        "id": 518068593,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1747229830
    },
    {
        "content": "<p>When it's a hashmap with one element in it it's really not a problem</p>",
        "id": 518068733,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747229862
    },
    {
        "content": "<p>unless it literally can't be evaluated of course (because of some irreducible or opaque thing)</p>",
        "id": 518068955,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747229909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/Bump.20to.20v20.2E0-rc5/near/518068733\">said</a>:</p>\n<blockquote>\n<p>When it's a hashmap with one element in it it's really not a problem</p>\n</blockquote>\n<p>There is literally up to hundreds of thousands of elements, the HashMap is linear in the DAG size of the produced circuit</p>",
        "id": 518076769,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1747231665
    },
    {
        "content": "<p>But aren't there many concrete use cases where the problem is really simple and there are less than 10 elements? Most of the concrete uses cases, maybe? For a different example, I'm pretty sure most <code>omega</code> uses in mathlib use only one or two inequalities in the context, although <code>omega</code> is powerful enough to handle much more complicated situations.</p>",
        "id": 518083713,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1747233276
    },
    {
        "content": "<p>(everyone has permissions to move topics)</p>",
        "id": 518084710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747233497
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/stream/458659-Equational/topic/Bump.20to.20v20.2E0-rc5/near/518083713\">said</a>:</p>\n<blockquote>\n<p>But aren't there many concrete use cases where the problem is really simple and there are less than 10 elements? Most of the concrete uses cases, maybe? For a different example, I'm pretty sure most <code>omega</code> uses in mathlib use only one or two inequalities in the context, although <code>omega</code> is powerful enough to handle much more complicated situations.</p>\n</blockquote>\n<p>no, bv_decide builds a circuit from the BitVec  statements, there are necessarily linear and quadratic constructions in length of the bit width happening. I've barely seen problems that people practically solve with bv_decide that are below at least hundreds of circuit nodes being worked in the HashMap and not just being solved in pre processing (which does not use axioms). So even if it is possible adding this feature is useful to maybe .1 percent of the users and thus not worth the effort.</p>",
        "id": 518084772,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1747233510
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/Bump.20to.20v20.2E0-rc5/near/518084710\">said</a>:</p>\n<blockquote>\n<p>(everyone has permissions to move topics)</p>\n</blockquote>\n<p>Not to another channel</p>",
        "id": 518084914,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1747233548
    },
    {
        "content": "<p>right now figuring out what percent of users need hard instances means dividing by zero, if we take usage in batteries and mathlib as the metric</p>",
        "id": 518085050,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747233580
    },
    {
        "content": "<p>(which makes it really off topic for this stream. No one here will ever use this tactic)</p>",
        "id": 518085526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747233689
    },
    {
        "content": "<p>I can move the messages, but because zulip doesn't give you the option to exactly select which messages to move, I will have to salami slice this thread, suffix by suffix, moving messages back and forth until every message is in the right thread</p>",
        "id": 518088088,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1747234300
    },
    {
        "content": "<p>I think I got everything. The discussions about the toolchain bump are in <a class=\"stream-topic\" data-stream-id=\"458659\" href=\"/#narrow/channel/458659-Equational/topic/Bump.20to.20v20.2E0-rc5/with/517715804\">#Equational &gt; Bump to v20.0-rc5</a>  and the <code>ofReduceBool</code> discussion is here</p>",
        "id": 518089343,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1747234610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/458659-Equational/topic/ofReduceBool.20and.20all.20that/near/518085050\">said</a>:</p>\n<blockquote>\n<p>right now figuring out what percent of users need hard instances means dividing by zero, if we take usage in batteries and mathlib as the metric</p>\n</blockquote>\n<p>There are a couple of research and industrial users outside of mathlib and batteries though. And with all the example problems I've seen from them, unless there is just a rewrite to solve the problem the circuit is always in the 100s of nodes up to millions of nodes.</p>\n<p>So I'd say as long as you are not just dealing with a <code>BitVec 8</code> and a problem that's not doable with rewriting the circuit will just end up with at least 100s of nodes, so the in kernel evaluation will not scale for the specific workload that bv_decide puts on it as it makes heavy use of HashMap, Array, String and ByteArray. If these tiny low bit-width instances arise, it' likely more reasonable to just case split that part, instead of trying to figure out how to run a tool like bv_decide completely in the kernel when almost all users we see work on medium to large instances. Alternatively a different tool that can deal with these smaller problems and be specifically optimized for the kernel could exist of course but I'm not seeing any demand for it so far.</p>",
        "id": 518091414,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1747235045
    },
    {
        "content": "<p>Maybe we could specialize print axioms for ofReduce* to print the term (or given that it only works on closed decls the term in the contained definition) that is being reduced?</p>",
        "id": 518093694,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1747235588
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/458659-Equational/topic/ofReduceBool.20and.20all.20that/near/518055981\">said</a>:</p>\n<blockquote>\n<p>It would be better if it used <code>ofReduceBoolForBVDecide</code></p>\n</blockquote>\n<p>At least unlike this part, this can't cheat in an adversarial scenario (of course assuming sane environment yadda yadda)</p>",
        "id": 518094900,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1747235873
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/458659-Equational/topic/ofReduceBool.20and.20all.20that/near/518093694\">said</a>:</p>\n<blockquote>\n<p>Maybe we could specialize print axioms for ofReduce* to print the term (or given that it only works on closed decls the term in the contained definition) that is being reduced?</p>\n</blockquote>\n<p>See my example above, which is designed to foil every post hoc rationalization method available, including this</p>",
        "id": 518112165,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747240392
    }
]