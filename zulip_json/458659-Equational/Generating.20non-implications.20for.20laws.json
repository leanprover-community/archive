[
    {
        "content": "<p>I've been slowly chipping away at lifting all equational results to laws so we can apply duality to prove the closure of things. <a href=\"https://github.com/leanprover-community/Equational/pull/459\">Equational#459</a> for example generates an implication of (syntactic) laws for every implication of equations, and that works well! We only generate a law implication where we had the equation implication, since we have transitivity (and as <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> <a href=\"#narrow/stream/458659-Equational/topic/Automatically.20generating.20magma.20laws.20.26.20proofs.20from.20equations/near/476057027\">pointed out</a>, duality should work the same essentially, we just compute it when we need it).</p>\n<p>The problem is that for anti-implications (of which there is roughly 2x as many), things are not as clear. We have this whole system of facts, so that we get one counterexample providing multiple non-implications. I wonder if it's worth creating an anti-implication theorem for laws for each of these?</p>\n<p>For a random example, <a href=\"https://github.com/teorth/equational_theories/blob/0538be7f995914f426a45d4ab1e46b4135889213/equational_theories/Generated/All4x4Tables/Refutation29.lean\">Refutation29</a> shows that for that concrete example, Equations 3894, 4098, 4284, 4423 and 4497 hold, whereas Equations[3253, 3456, 3660, 3661, 3685, 3687, 3721, 3725, 3865, 3867, 3881, 3887, 3915, 3928, 4070, 4073, 4084, 4131, 4269, 4273, 4275, 4276, 4283, 4290, 4291, 4293, 4314, 4320, 4321, 4396, 4398, 4405, 4433, 4435, 4442, 4445, 4473, 4479, 4480, 4583, 4591, 4598, 4599, 4605, 4606, 4608, 4631, 4635, 4636, 4647, 4656 don't hold. That's 5 * 51 = 255 anti-implications.  So one theorem on Equations would become 255 theorems on Laws! </p>\n<p>We obviously also don't need all anti-implications because of transitivity (backwards), but I don't know if we want to split these sweeping counterexamples (as individual <code>¬ LawN.implies LawM</code> theorems) ?Or do we want to encode the whole batch of non-implications as laws (using propositional logic), defering the \"splitting up\" to the computation of the transitive closure again for laws? Maybe someone here has a better idea what we should do?</p>",
        "id": 476588897,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1728808162
    },
    {
        "content": "<p>e.g. if we have a magma that shows laws <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">L_1, L_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> but not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>L</mi><mn>3</mn></msub><mo separator=\"true\">,</mo><msub><mi>L</mi><mn>4</mn></msub></mrow><annotation encoding=\"application/x-tex\">L_3, L_4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> we could translate it to an implication like <code>¬(L₁ ∨ L₂ → L₃ ∨ L₄)</code> but then we'd need to extend the implication definition on laws to express these disjunctions (and multiple laws), which I guess could be useful in the future? (there's also already <code>satisfiesSet</code> so it shouldn't be too difficult)</p>",
        "id": 476590102,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1728809321
    },
    {
        "content": "<p>One could do something like <code>∀ L L', L ∈ { L₁, L₂ } → L' ∈ { L₃, L₄ } → ¬(L→ L')</code> perhaps?</p>",
        "id": 476612823,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728831804
    }
]