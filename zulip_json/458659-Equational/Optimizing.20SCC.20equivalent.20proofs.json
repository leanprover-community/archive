[
    {
        "content": "<p>How much optimization has been done on the SCC part of the proof? When two laws are equivalent, transitive reduction becomes not uniquely determined. There are two kinds of \"moves\" one can make here:</p>\n<ul>\n<li>If A and A' are equivalent, prove A -&gt; B instead of A' -&gt; B or A -/&gt; B instead of A' -/-&gt; B</li>\n<li>If {Ai} is an SCC, replace any of the implications with any equivalent presentation of this SCC</li>\n</ul>\n<p>There are two reasons one might want to change the representatives:</p>\n<ul>\n<li>Using A instead of A' results in a shorter proof or counterexample proof</li>\n<li>Using a different presentation makes it easier to prove {Ai} is an SCC</li>\n</ul>",
        "id": 486128929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733328634
    },
    {
        "content": "<p>I'm wondering whether we have already done any kind of optimizations here, and whether we should.</p>",
        "id": 486129070,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733328675
    },
    {
        "content": "<p>Some of the SCCs themselves are not established optimally, e.g. not a hamiltonian cycle but something with more edges than necessary. It would not be hard to establish the minimal equivalent graph if that's what we wanted, though I'm not sure if we care about deleting the old implications in favor of a more optimized representation.</p>",
        "id": 486133125,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733329727
    },
    {
        "content": "<p>We could also pick representatives from every SCC to have all inbound/outbound edges go to them.</p>",
        "id": 486133225,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733329759
    },
    {
        "content": "<p>how do you check which are the SCCs? is that a python script?</p>",
        "id": 486139091,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1733331525
    },
    {
        "content": "<p>or does it work with graphiti directly?</p>",
        "id": 486139120,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1733331536
    },
    {
        "content": "<p>The ruby code can import the implications data and compute SCCs, there is python code to do the same for the equation explorer data but I just don't use it.</p>",
        "id": 486139865,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733331744
    },
    {
        "content": "<p>You can also get the SCCs directly from the graphit datai though, since it uses the condensed graph. See json[\"general_graph\"][\"scc_to_node_map\"] in <a href=\"https://teorth.github.io/equational_theories/graphiti/graph.json\">https://teorth.github.io/equational_theories/graphiti/graph.json</a></p>",
        "id": 486140346,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733331884
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/486126280\">said</a>:</p>\n<blockquote>\n<p>It might also be possible to make the SCC computation faster by adding just a _few_ extra theorems. Like for the Eq2 equivalence class, adding a theorem for EqX -&gt; Eq2 directly (instead of relying on dynamically finding a path through other theorems) means that we can verify everything in the SCC by just checking those O(n) extra theorems.</p>\n</blockquote>\n<p>Also Eq1 and Eq2 are special because we literally have a proof that every magma law sits between these two with no regard for the law itself</p>",
        "id": 486140741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733332008
    },
    {
        "content": "<p>i.e. they aren't just the top and bottom of the proved lattice, they are top and bottom of the full infinite graph</p>",
        "id": 486140874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733332056
    },
    {
        "content": "<p>Right, I'm aware, that's why just having the EqX -&gt; Eq2 theorems would be necessary.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/486126698\">said</a>:</p>\n<blockquote>\n<p>We need to prove SCCs, not non-SCCs</p>\n</blockquote>\n<p>I'm not sure I understand you here</p>",
        "id": 486153258,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1733336301
    },
    {
        "content": "<p>I'm saying: we want to show that a whole long list L of equations is in the Eq2 SCC. One way to do this is to (in Lean) walk the graph and find cycles and do Tarjan's algorithm or whatever.<br>\nBut, if we just directly show that each equation EqX in L has a theorem EqX -&gt; Eq2, then that's enough, and easier to verify I think.<br>\nRight now, we don't have such theorems written down. For instance for Eq123, the chain of implications looks like <a href=\"https://teorth.github.io/equational_theories/implications/show_proof.html?pair=123,2\">https://teorth.github.io/equational_theories/implications/show_proof.html?pair=123,2</a><br>\nIf we just added a <code>theorem Eq123_implies_Eq2</code> that's the <code>.trans</code> of these, then for a pretty-low overhead in the theorem count, we can really easily verify the SCC.</p>",
        "id": 486153731,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1733336493
    },
    {
        "content": "<p>I mention Eq2 in particular because it has such a large SCC.</p>",
        "id": 486153870,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1733336539
    },
    {
        "content": "<p>Oh, I now see your new thread <a href=\"#narrow/channel/458659-Equational/topic/Optimizing.20SCC.20equivalent.20proofs/near/486128929\">https://leanprover.zulipchat.com/#narrow/channel/458659-Equational/topic/Optimizing.20SCC.20equivalent.20proofs/near/486128929</a>, which is the same thing.</p>",
        "id": 486154198,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1733336657
    },
    {
        "content": "<p>Personally I'm in favor of picking representatives, adding the O(n) theorems necessary to give all outbound/inbound edges/nonedges, and then going from there.</p>",
        "id": 486154374,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1733336744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/486153258\">said</a>:</p>\n<blockquote>\n<p>Right, I'm aware, that's why just having the EqX -&gt; Eq2 theorems would be necessary.</p>\n</blockquote>\n<p>Well no, I'm saying that we don't need these theorems at all</p>",
        "id": 486164661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733340736
    },
    {
        "content": "<p>Oh whoops you're talking about the other direction</p>",
        "id": 486164929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733340851
    },
    {
        "content": "<p>Because Eq2 is special, some aspect of this SCC calculation is also specialized to Eq2. I think this should be a sequence of theorems of the form \"EqX is trivial\", each of which is done by proving either that EqX implies Eq2 or that EqX implies EqY which is known trivial. That is, the transitivity step is being applied explicitly here, we aren't using an algorithm to do the work for us.</p>",
        "id": 486165647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733341159
    },
    {
        "content": "<p>9 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"458659\" href=\"/#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean\">#Equational &gt; A final end-to-end theorem in Lean</a> by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>.</p>",
        "id": 486166233,
        "sender_full_name": "Notification Bot",
        "timestamp": 1733341405
    },
    {
        "content": "<p>Here are some pictures of the different SCC shapes. There are 1153 SCCs of size 1, 137 of size 2 (only one possible shape), 61 of size 3 (of which 37 are the optimal cycle, 23 have 4 edges and one has 5 edges), and then these larger graphs:</p>\n<p><a href=\"/user_uploads/3121/Qw9TgnMRzJF4hvQx9rvdx1wT/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Qw9TgnMRzJF4hvQx9rvdx1wT/image.png\" title=\"image.png\"><img data-original-dimensions=\"2357x1315\" src=\"/user_uploads/thumbnail/3121/Qw9TgnMRzJF4hvQx9rvdx1wT/image.png/840x560.webp\"></a></div>",
        "id": 486180222,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733346859
    },
    {
        "content": "<p>Pretty!</p>",
        "id": 486181463,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733347383
    },
    {
        "content": "<p>I was hoping that if we look at edges coming into an SCC that there would be a preference for one of the members of the class, but this is almost never the case, and in fact the opposite is true: of the 270 SCCs of size &gt; 1, 23 have 1 \"canonical representative\" when relating to other SCCs, while 175 have as many representatives as the group size itself. The biggest SCC, for equation 2, has 1496 members and 125 \"representatives\"</p>",
        "id": 486183013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733348053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/458659-Equational/topic/Optimizing.20SCC.20equivalent.20proofs/near/486154374\">said</a>:</p>\n<blockquote>\n<p>Personally I'm in favor of picking representatives, adding the O(n) theorems necessary to give all outbound/inbound edges/nonedges, and then going from there.</p>\n</blockquote>\n<p>So this proposal would indeed change a lot of proofs</p>",
        "id": 486183113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733348105
    },
    {
        "content": "<p>A tangential remark: since we are talking about SCCs, Donald Knuth will be talking about Tarjan's SCC algorithm in his Christmas lecture which is sometime in the next two days</p>",
        "id": 486185593,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1733349241
    },
    {
        "content": "<p>Thanks for the alert on this.  His talks are always fun and instructive! For those interested, <a href=\"https://www-cs-faculty.stanford.edu/~knuth/musings.html\">https://www-cs-faculty.stanford.edu/~knuth/musings.html</a> describes the talk, and <a href=\"https://learn.stanford.edu/DonKnuthXmas-2024-Registration.html\">https://learn.stanford.edu/DonKnuthXmas-2024-Registration.html</a> is the registration page. Talk on December 5 5pm PDT</p>",
        "id": 486188788,
        "sender_full_name": "Oisin McGuinness",
        "timestamp": 1733350766
    },
    {
        "content": "<p>How large is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∑</mo><mi mathvariant=\"normal\">∣</mi><mi>S</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\sum |S|^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> for SCCs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>? We could try computing all proofs and then solve approximately the appropriate minimization problem with the proof lengths</p>",
        "id": 486230469,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1733377485
    },
    {
        "content": "<p>even an inefficient SCC proof is linear</p>",
        "id": 486257267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733390117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/Optimizing.20SCC.20equivalent.20proofs/near/486183113\">said</a>:</p>\n<blockquote>\n<p>So this proposal would indeed change a lot of proofs</p>\n</blockquote>\n<p>Well, we wouldn't need to change anything existing. Just generate the right transitive proofs. Right?</p>",
        "id": 486330249,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1733412064
    },
    {
        "content": "<p>that's equivalent to doing nothing</p>",
        "id": 486330917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733412234
    },
    {
        "content": "<p>since the main proof will end up doing this work if it isn't prepared in advance</p>",
        "id": 486331025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733412256
    },
    {
        "content": "<p>the point of \"optimizing\" here is to make it so that the main proof never needs to do the work in the first place</p>",
        "id": 486331094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733412274
    },
    {
        "content": "<p>in particular, if all implications and non-implications use only SCC representatives, then the proof that the laws in each SCC are equivalent is completely local and we don't need to store a bunch of theorems for later random access</p>",
        "id": 486331346,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733412344
    },
    {
        "content": "<p>the SCC proofs and the hasse proof become independent of each other</p>",
        "id": 486331558,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733412395
    }
]