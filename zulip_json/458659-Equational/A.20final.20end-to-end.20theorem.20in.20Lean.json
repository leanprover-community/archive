[
    {
        "content": "<p>Overnight, I thought a bit more about what an end-to-end theorem in lean could look like. Put differently, what is a “minimal” set of definitions and theorems that one would have to manually inspect and which convey the end result of this project, all checked in lean</p>\n<p>This would be my proposal. For defs with <code>:=</code>, the actual value on the right-hand side is not necessary for the skeptical human to check, and would likely be filled by a macro or command.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">…</span>\n<span class=\"sd\">/-- all our laws, in one definition -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">law</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NatMagmaLaw</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">…</span>\n<span class=\"sd\">/-- a proof that this contains all laws we claim to look at -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">law_complete</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatMagmaLaw</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">countOps</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">law</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"sd\">/-- the final matrix -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">implicationGraph</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">…</span>\n<span class=\"sd\">/-- and correctness thereof -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">implicationGraph_correct</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">),</span>\n<span class=\"w\">  </span><span class=\"n\">implicationGraph</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">law</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">implies</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">law</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Notes:</p>\n<ul>\n<li>I am phrasing <code>law</code> and <code>implementationGraph</code> as functions, not lists or matrices or so. That’s sufficient to state these theorems in a clear and declarative way. Very likely one has to find suitable data structures, define them, and then access these in <code>law</code> and <code>implementationGraph</code>.</li>\n<li>Filling these definitions naively, e.g. by pure enumeration, wouldn’t be too hard, I assume, but likely be too large for lean to handle. So this needs serious proof engineering. In particular, I expect that <code>law</code> should be backed by a balanced binary search tree that the kernel can index into somewhat quickly (I have code for that somewhere). And not sure about the graph, maybe actually a bitmap encoded in a large <code>Nat</code>?</li>\n<li>For the graph, maybe it makes sense to re-implement the closure code in a verified and kernel-reduction-friendly way. So one step would be to define the (partial) implies and not-implies graphs, and then prove that the final graph is the result of taking the closure using a verified algorithm, rather than proving correctness of each entry in the final graph.</li>\n<li>Arguably the above is trivial to satisfy if one uses the axioms of classical logic in the definitions. So maybe one should also add a check that <code>implementationGraph</code> doesn’t use such axioms, and hence is actually computable.</li>\n<li><code>law_complete</code> cannot be proven like this, we want to restrict it to those laws with variables in order (or up-toprenaming)</li>\n</ul>\n<p>If one would want to build that, and want to build it even before proving everything, then one either has to complicate the statements somehow (excluding certain pairs from the correctness theorem). Or introduce an axiom for “conjectured implication” and build this infrastructure as if we are already done, and when we are done then that axiom will be unused.</p>",
        "id": 477384391,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729153470
    },
    {
        "content": "<p><a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477384391\">A message</a> was moved here from <a class=\"stream-topic\" data-stream-id=\"458659\" href=\"/#narrow/channel/458659-Equational/topic/Thoughts.20and.20impressions.20thread\">#Equational &gt; Thoughts and impressions thread</a> by <span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span>.</p>",
        "id": 477384450,
        "sender_full_name": "Notification Bot",
        "timestamp": 1729153495
    },
    {
        "content": "<p>Playing around in that direction. That’s a good start:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">laws</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RArray</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"bp\">.</span><span class=\"n\">NatMagmaLaw</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">defineLaws</span><span class=\"bp\">%</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">laws</span><span class=\"o\">[</span><span class=\"mi\">1000</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Law1001</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 477481534,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729182310
    },
    {
        "content": "<p>Ah I see, this is a theorem that we have proved all the theorems</p>",
        "id": 477482557,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1729182680
    },
    {
        "content": "<p>6 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"458659\" href=\"/#narrow/channel/458659-Equational/topic/non-computable.20non-non-computables.3F\">#Equational &gt; non-computable non-non-computables?</a> by <span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span>.</p>",
        "id": 477485891,
        "sender_full_name": "Notification Bot",
        "timestamp": 1729183808
    },
    {
        "content": "<p>Little experiments in that direction in <a href=\"https://github.com/teorth/equational_theories/pull/618\">https://github.com/teorth/equational_theories/pull/618</a><br>\nThis defines a single definition that contains all laws, and a binary search function to find the index of a law therein.</p>\n<p>But what’s missing for <code>laws_complete</code> is a verified(!) generator of laws up to a certain size, which is doable, but not trivial. Parking this for today.</p>",
        "id": 477490504,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729185562
    },
    {
        "content": "<p>There is a script from which our current set of equations were defined. It is in python and I think we also have an extraction script from lean's equations list to json</p>",
        "id": 477491142,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1729185796
    },
    {
        "content": "<p>I know, but thats not verified. How do we know that we didn't miss a certain law? (Unlikely, but if we want an end-to-end proof of our end result, that is one necessary part.)</p>",
        "id": 477491717,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729186009
    },
    {
        "content": "<p>oh, that's really cool! I've been knid of slacking off integrating duality into the transitive closure computation, so I feel reassured you think it makes sense to re-implement it in a verified and kernel-reduction-friendly way (so that effort wasn't wasted <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> )</p>",
        "id": 477494108,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1729186995
    },
    {
        "content": "<p>Maybe it would make sense to split up the proof of <code>implicationGraph_correct</code> into two parts, one that says \"it suffices to prove these implications/anti implications\" because of transitivity, duality, and a second part that just supplies the necessary proofs. That would also help with the issue of making this work before everything's integrated (because we can prove the \"it suffices\" part already without having the explicit proofs for every implication/anti-implication, and that's likely the one that's going to be more optimizable)</p>",
        "id": 477495077,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1729187345
    },
    {
        "content": "<p>I've been away from chat, but worked on and off on converting the code generating laws to Lean.</p>\n<p>It's now in a working state, at<br>\n<a href=\"https://github.com/amirlb/equational_theories/blob/generate-laws-lean/scripts/generate_laws.lean\">https://github.com/amirlb/equational_theories/blob/generate-laws-lean/scripts/generate_laws.lean</a></p>",
        "id": 477511506,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729193612
    },
    {
        "content": "<p>I'm not fluent enough in Lean yet to prove it covers all laws up to equivalence</p>",
        "id": 477511805,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729193741
    },
    {
        "content": "<p>sorry for possibly duplicating work, I'm almost through with my generator.</p>",
        "id": 477514056,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729194695
    },
    {
        "content": "<p>It's not that much code anyway... So the important thing is to structure it so it's easy to prove properties about it</p>",
        "id": 477514489,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729194881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andrés Goens</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477494108\">said</a>:</p>\n<blockquote>\n<p>oh, that's really cool! I've been knid of slacking off integrating duality into the transitive closure computation, so I feel reassured you think it makes sense to re-implement it in a verified and kernel-reduction-friendly way (so that effort wasn't wasted <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> )</p>\n</blockquote>\n<p>I believe duality is already integrated as of 76ace3ce93a728b536252d206bb75c9b71b4d421 unless you're referring to something else?</p>",
        "id": 477516170,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1729195565
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477514056\">said</a>:</p>\n<blockquote>\n<p>sorry for possibly duplicating work, I'm almost through with my generator.</p>\n</blockquote>\n<p>I take the <code>almost</code> back, it seems tricky to recognize/generate laws up to permutation of the variables efficiently.</p>",
        "id": 477517719,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729196247
    },
    {
        "content": "<p>I bet this is a well-known problem, but seems hard to google</p>",
        "id": 477518589,
        "sender_full_name": "Cody Roux",
        "timestamp": 1729196618
    },
    {
        "content": "<p>Ok, I got a generator that finds all equations, does not generate extra ones, but doesn’t try all permutations of variables. It’s not verified yet, but this looks promising:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- info: true -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">testLaws</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">laws</span><span class=\"o\">[</span><span class=\"n\">findMagmaLaw</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span>\n</code></pre></div>",
        "id": 477522487,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729198358
    },
    {
        "content": "<p>Very nice!</p>",
        "id": 477533474,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729204003
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"761203\">Vlad Tsyrklevich</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477516170\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andrés Goens</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477494108\">said</a>:</p>\n<blockquote>\n<p>oh, that's really cool! I've been knid of slacking off integrating duality into the transitive closure computation, so I feel reassured you think it makes sense to re-implement it in a verified and kernel-reduction-friendly way (so that effort wasn't wasted <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> )</p>\n</blockquote>\n<p>I believe duality is already integrated as of 76ace3ce93a728b536252d206bb75c9b71b4d421 unless you're referring to something else?</p>\n</blockquote>\n<p>right, sorry, I should have been more precise here. That piece of code is great for keeping score, but it's just taking the duals out of some json file:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">dualityRelation</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">DualityRelation</span><span class=\"bp\">.</span><span class=\"n\">ofFile</span><span class=\"w\"> </span><span class=\"s2\">\"data/duals.json\"</span>\n</code></pre></div>\n<p>I mean formally using the duality definition and metatheorem (from <a href=\"https://github.com/teorth/equational_theories/pull/285\">equational#285</a>) when computing the closure, as part of an end-to-end theorem in Lean</p>",
        "id": 477576171,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1729230244
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477522487\">said</a>:</p>\n<blockquote>\n<p>Ok, I got a generator that finds all equations, does not generate extra ones, but doesn’t try all permutations of variables. It’s not verified yet, but this looks promising:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- info: true -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">testLaws</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">laws</span><span class=\"o\">[</span><span class=\"n\">findMagmaLaw</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>cool! by the way, formalizing this also probably requires/is closely related to <a href=\"https://github.com/teorth/equational_theories/pull/148\">equational#148</a> and <a href=\"https://github.com/teorth/equational_theories/pull/184\">equational#184</a>, formalizing the counts</p>",
        "id": 477579331,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1729231915
    },
    {
        "content": "<p>Proved</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">laws_complete</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"bp\">.</span><span class=\"n\">MagmaLaw</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">forks</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">is_canonical</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">laws</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span>\n</code></pre></div>\n<p>This is using <code>native_decide</code>, but still a very convincing proof, I’d say.</p>\n<p>If one defines a suitable equivalence on <code>MagmaLaw</code> (up to relabeling of variables, reorienting the equation), then one could even prove the slightly more high-level</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">laws_complete</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"bp\">.</span><span class=\"n\">MagmaLaw</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">forks</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">l'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"n\">l'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">laws</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l'</span>\n</code></pre></div>\n<p>and take <code>l.is_canonical</code> out of the “trusted spec base”. Looks like we don’t have that equivalence definition yet, though.</p>",
        "id": 477644314,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729254427
    },
    {
        "content": "<p>We do have logical equivalence, which is weaker. And looks even more convincing to me: it doesn't matter if we missed a few equations if we provably covered all equivalence classes.</p>",
        "id": 477657130,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729258435
    },
    {
        "content": "<p>True, so we’d just™ have to prove that relabeling or symmetry preserves logical equivalence.</p>",
        "id": 477657672,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729258594
    },
    {
        "content": "<p>That is simple enough for even me to prove :p (and might even be exactly <code>MagmaLaw.satisfies_map_equiv</code>). Syntactic equivalence sounds like a useful property to have though so probably worth defining anyway.</p>",
        "id": 477662221,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729259944
    },
    {
        "content": "<p>In <a href=\"https://github.com/teorth/equational_theories/pull/636\">https://github.com/teorth/equational_theories/pull/636</a> I am experimenting with representing the graph of proven implications in a single <code>def</code>, in a verified way. <del>I think it built locally, but seems to bring the GitHub runner to its knees. This definitely needs more tuning.</del> It needs more work to actually scale to the full graph, though.</p>\n<p>This doesn't take the closure yet. For that I am wondering if there is a way to precalculate some data so that the actual proof doesn't have to calculate the closure, just check it. For example if for every nodes i, j in the closure it would also store the number of steps it takes from i to j, and also what the next node on that path is, then checking that for correctness should be linear. Maybe that's noticably better than running the full closure algorithm.</p>",
        "id": 477733122,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729284794
    },
    {
        "content": "<p>If it was a simple graph, it would be simple, right? You could prove that for one vertex you have both a forward and a backwards path to every other vertex</p>",
        "id": 477777629,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729318209
    },
    {
        "content": "<p>Actually I never saw the structure of the (non-)implications graph written down, so for completeness:</p>\n<ul>\n<li>There are two nodes for each equation, <code>EqA</code> and <code>EqA'</code></li>\n<li>There is a node for each \"Facts\" statement, <code>MagmaN</code></li>\n<li>For each statement <code>EqA_implies_EqB</code> two edges: <code>EqB -&gt; EqA</code> and <code>EqB' -&gt; EqA'</code></li>\n<li>For each statement <code>Facts [A, ...] [B, ...]</code> edges are added <code>EqA -&gt; MagmaN</code> and <code>MagmaN -&gt; EqB'</code></li>\n</ul>\n<p>Then a path <code>EqA -&gt; ... -&gt; EqB</code> indicates an implication <code>EqB =&gt; EqA</code> and a path <code>EqA -&gt; ... -&gt; EqB'</code> indicates a non-implication <code>not (EqA =&gt; EqB)</code>.</p>",
        "id": 477778368,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729319082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477733122\">said</a>:</p>\n<blockquote>\n<p><del>I think it built locally, but seems to bring the GitHub runner to its knees. This definitely needs more tuning.</del> It needs more work to actually scale to the full graph, though.</p>\n</blockquote>\n<p>Interesting, the file finishes fine in VSCode, but <code>lake build</code> takes a long time. <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>\n<p>Even worse: <code>lake build</code> sits there for minutes, and if I stop it and re-run it, it considers the build done. That looks like a bug somewhere…<br>\nAh, it seems that writing the C file with the large data structure is what keeps Lean overly busy (and which doesn’t happen in vscode). I think that’s what <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>  observed before. And after Ctrl-C there is an empty <code>.c</code> file and lake is happy to use that :-( <br>\nBut I fail to reproduce this behavior in a small example.</p>",
        "id": 477797331,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729336591
    },
    {
        "content": "<p>Hmm, using large bitvectors encoded as <code>Nat</code> seems to hit limitations in lean:</p>\n<ul>\n<li>Compiling is super slow because <code>Nat.repr</code> goes via <code>toDigits</code>  which goes via <code>List Char</code>,  instead of mutably filling a  <code>String</code>. Reported as <a href=\"https://github.com/leanprover/lean4/issues/5771\">https://github.com/leanprover/lean4/issues/5771</a>.</li>\n<li>The generated C code runs <code>lean_cstr_to_nat</code> when initializing, so presumably (didn’t measure) this increases the startup time of any program importing such a module.</li>\n</ul>\n<p>But maybe a single bitvector for the whole graph isn’t needed, and maybe something like <code>Array Nat</code> (i.e. adjacency bitvectors) would work better.</p>",
        "id": 477799143,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729338347
    },
    {
        "content": "<p>fwiw the closure code uses arrays of bitvectors, where each bitvector is an array of UInt64</p>",
        "id": 477801595,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729340699
    },
    {
        "content": "<p>That is a good choice for native evaluation. Maybe I should first aim at proving the final theorem using <code>native_decide</code> and the existing code, and defer (or give up on) trying to avoid native evaluation.</p>",
        "id": 477812550,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729348900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477799143\">said</a>:</p>\n<blockquote>\n<p>Hmm, using large bitvectors encoded as <code>Nat</code> seems to hit limitations in lean:</p>\n<ul>\n<li>Compiling is super slow because <code>Nat.repr</code> goes via <code>toDigits</code>  which goes via <code>List Char</code>,  instead of mutably filling a  <code>String</code>. Reported as <a href=\"https://github.com/leanprover/lean4/issues/5771\">https://github.com/leanprover/lean4/issues/5771</a>.</li>\n<li>The generated C code runs <code>lean_cstr_to_nat</code> when initializing, so presumably (didn’t measure) this increases the startup time of any program importing such a module.</li>\n</ul>\n<p>But maybe a single bitvector for the whole graph isn’t needed, and maybe something like <code>Array Nat</code> (i.e. adjacency bitvectors) would work better.</p>\n</blockquote>\n<p>Why are you using <code>Nat.repr</code>?</p>",
        "id": 477812960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729349269
    },
    {
        "content": "<p>I thought the idea was that you read a data file, construct a <code>Nat</code> in memory at elaboration time and insert it as a nat literal into the environment</p>",
        "id": 477813033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729349305
    },
    {
        "content": "<p>you should never need to go via decimal, you really shouldn't because base conversion of huge numbers is incredibly expensive</p>",
        "id": 477813182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729349432
    },
    {
        "content": "<p>Here's an alternative proof structure, which perhaps sidesteps the questions about computability:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">equational_theories</span><span class=\"bp\">.</span><span class=\"n\">Preorder</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">equational_theories</span><span class=\"bp\">.</span><span class=\"n\">MagmaOp</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"w\"> </span><span class=\"kn\">renaming</span><span class=\"w\"> </span><span class=\"n\">NatMagmaLaw</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Law</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Fact'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Record</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">implies</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Record</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">notImplies</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Record</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fact</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Record</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">dual</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Record</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Record</span><span class=\"bp\">.</span><span class=\"n\">WF</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Record</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">implies</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">notImplies</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fact</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">dual</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">dual</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsDual</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Record</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"n\">dual</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">dual</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Record</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">imp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">implies</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">notimp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">notImplies</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fact</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fact</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">trans11</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">trans10</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">trans01</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">dual</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsDual</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsDual</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"n\">val</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"bp\">.</span><span class=\"n\">wf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">WF</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">val</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">allLaws</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">  </span><span class=\"c1\">-- explicit list</span>\n<span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">allRecords</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Record</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">  </span><span class=\"c1\">-- explicit list</span>\n<span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">allRecords_correct</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">allRecords</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">WF</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">correct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eqA</span><span class=\"w\"> </span><span class=\"n\">eqB</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">allRecords</span><span class=\"w\"> </span><span class=\"n\">eqA</span><span class=\"w\"> </span><span class=\"n\">eqB</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eqA</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">eqB</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">complete</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eqA</span><span class=\"w\"> </span><span class=\"n\">eqB</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">eqA</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">allLaws</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">eqB</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">allLaws</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Closure</span><span class=\"w\"> </span><span class=\"n\">allRecords</span><span class=\"w\"> </span><span class=\"n\">eqA</span><span class=\"w\"> </span><span class=\"n\">eqB</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 477825693,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729359820
    },
    {
        "content": "<p>Nice. Does this scale, usings lists etc, given thousands of entries?</p>",
        "id": 477827514,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729361649
    },
    {
        "content": "<p>not really, at least the way lists in lean currently work. But you can have a metaprogram that generates trees instead of lists and/or uses sub-definitions and I'm pretty sure you can push it through the kernel that way</p>",
        "id": 477827554,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729361716
    },
    {
        "content": "<p>I am computing the large nat using an elaborator (so I assume reading from a file wouldn't be different here), and use it to define a top level <code>Nat</code>. But then lean wants to write ot to the c file, and itself uses Nat.repr in the process</p>",
        "id": 477827569,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729361736
    },
    {
        "content": "<p>3 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"458659\" href=\"/#narrow/channel/458659-Equational/topic/non-computable.20non-non-computables.3F\">#Equational &gt; non-computable non-non-computables?</a> by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>.</p>",
        "id": 477827844,
        "sender_full_name": "Notification Bot",
        "timestamp": 1729362030
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> is it okay to just put <code>noncomputable</code> on the definition?</p>",
        "id": 477827880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729362074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477827554\">said</a>:</p>\n<blockquote>\n<p>not really, at least the way lists in lean currently work. But you can have a metaprogram that generates trees instead of lists and/or uses sub-definitions and I'm pretty sure you can push it through the kernel that way</p>\n</blockquote>\n<p>Ok, sounds like I wasn't completely on the wrong track on my Branch, with a tree-shaped proof of well-formedness of the main data structure. Fun puzzle, although it would be nice if one didn't have to puzzle to make such medium sized things work.</p>",
        "id": 477827948,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729362134
    },
    {
        "content": "<p>yes, lean falls over on big proofs for distressingly small values of \"big\"</p>",
        "id": 477827965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729362162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477827880\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> is it okay to just put <code>noncomputable</code> on the definition?</p>\n</blockquote>\n<p>Possibly, but I assumed I can only do that once I no longer use <code>native_decide</code></p>",
        "id": 477827984,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729362175
    },
    {
        "content": "<p>IIRC there is some way to force definitions to be interpreted, but I forget what it is. Maybe just disable the compiler with an option?</p>",
        "id": 477828030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729362238
    },
    {
        "content": "<p>I would be interested to know what kind of algorithms exist for proving completeness without needing to enumerate all n^2 cases</p>",
        "id": 477828259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729362455
    },
    {
        "content": "<p>it feels like you should be able to construct a hasse diagram and extract a bunch of facts implicitly from that</p>",
        "id": 477828344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729362510
    },
    {
        "content": "<p>actually I think that's exactly the answer: a hasse diagram presentation where every edge is a proved non-implication is already complete, so the proof is just to construct a hasse diagram presentation and check that every law is somewhere in the diagram</p>",
        "id": 477829062,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729363208
    },
    {
        "content": "<p>A small search found an anti-chain of size 200, so we need at least 200^2 negative edges in the graph</p>",
        "id": 477830399,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729364580
    },
    {
        "content": "<p>It's possible to prove those 200^2 negative edges using only 200 models though in the best case</p>",
        "id": 477830654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729364769
    },
    {
        "content": "<p>in other words, we have to consider the extended graph <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477778368\">you</a> mentioned that also has nodes for <code>Facts</code> statements</p>",
        "id": 477830701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729364842
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> I'm looking at your <code>RArray</code> structure, very nice. One thing which I think would improve it is to use a slightly different version of the <code>get</code> function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The crucial operation, written with very little abstractional overhead -/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">RArray</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RArray</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">RArray</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">ble</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sub</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>In other words, the data stored at nodes is not the index of the middle point in the array but rather the size of the left subtree. This has the effect that many operations on it become O(log n) instead of O(n)</p>",
        "id": 477830815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729364917
    },
    {
        "content": "<p><code>get</code> might also get faster, although it's unlikely to matter at these sizes, because you are comparing smaller numbers</p>",
        "id": 477830945,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729365029
    },
    {
        "content": "<p>They are not O(log(n))? Then I didn't do what I intended. I stored the index there to avoid the subtraction in get</p>",
        "id": 477830977,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729365088
    },
    {
        "content": "<p><code>get</code> is O(log n) but insertion isn't</p>",
        "id": 477831016,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729365123
    },
    {
        "content": "<p>Oh, you man other operators than get? This was designed to support exactly <code>get</code>.</p>",
        "id": 477831038,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729365131
    },
    {
        "content": "<p>In particular, I think you can prove the theorem in LawsComplete by just building up the array instead of looking individuals up in a static array</p>",
        "id": 477831053,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729365167
    },
    {
        "content": "<p>I.e. for use cases where you prepare static data at elab time, and at kernel reduction time you just index into. Hence also the garbage value when indexing out of bounds.</p>",
        "id": 477831056,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729365176
    },
    {
        "content": "<p>because you know it is sorted in advance</p>",
        "id": 477831057,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729365177
    },
    {
        "content": "<p>For example the denotation function in a reflection proof could use this instead of a list</p>",
        "id": 477831072,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729365196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477830977\">said</a>:</p>\n<blockquote>\n<p>They are not O(log(n))? Then I didn't do what I intended. I stored the index there to avoid the subtraction in get</p>\n</blockquote>\n<p>I'm not sure what the alternative you are considering here is</p>",
        "id": 477831150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729365257
    },
    {
        "content": "<p>Right. When writing the code I wasn't sure if my generation function would end up producing the same order as Terry's script (and I'm not sure it does), hence this approach for now.</p>",
        "id": 477831174,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729365283
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477831150\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477830977\">said</a>:</p>\n<blockquote>\n<p>They are not O(log(n))? Then I didn't do what I intended. I stored the index there to avoid the subtraction in get</p>\n</blockquote>\n<p>I'm not sure what the alternative you are considering here is</p>\n</blockquote>\n<p>Nevermind, ignore that message, I thought you said that my get wasn't O(log n).</p>",
        "id": 477831231,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729365340
    },
    {
        "content": "<p>Do you want to take over working on the two end-to-end theorems? You seem to have been thinking about it already a lot, and I shouldn't get too distracted from core work anyways ?</p>",
        "id": 477831322,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729365404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477831174\">said</a>:</p>\n<blockquote>\n<p>Right. When writing the code I wasn't sure if my generation function would end up producing the same order as Terry's script (and I'm not sure it does), hence this approach for now.</p>\n</blockquote>\n<p>But you never sort the list? It seems to just put Law(i+1) at position i in the list</p>",
        "id": 477831367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729365458
    },
    {
        "content": "<p>but <code>findMagmaLaw</code> exploits that it is sorted according to your sort order</p>",
        "id": 477831431,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729365487
    },
    {
        "content": "<p>so I think this is a proof that the laws are in fact sorted</p>",
        "id": 477831436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729365496
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477831322\">said</a>:</p>\n<blockquote>\n<p>Do you want to take over working on the two end-to-end theorems? You seem to have been thinking about it already a lot, and I shouldn't get too distracted from core work anyways ?</p>\n</blockquote>\n<p>lol, I need to be reviewing a paper, I'm intensely procrastinating right now</p>",
        "id": 477831476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729365545
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 477831492,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729365563
    },
    {
        "content": "<p>I don't think we even need to prove it is transitively reduced</p>",
        "id": 477831521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729365587
    },
    {
        "content": "<p>Sorry, I think I said nonsense, but you answer too quickly</p>",
        "id": 477831602,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729365631
    },
    {
        "content": "<p>(nonsense because you also need to demonstrate non-implications between nodes that are unrelated in the graph)</p>",
        "id": 477831649,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729365693
    },
    {
        "content": "<p>Right, with transitive reduction I meant we can remove some implied edges, not that it has to be fully reduced.</p>",
        "id": 477831713,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729365731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477831436\">said</a>:</p>\n<blockquote>\n<p>so I think this is a proof that the laws are in fact sorted</p>\n</blockquote>\n<p>Yes, Terry's list is sorted wrt to some order that I had to find out. I don't know if my generator produces them in that order, hence generate-and-lookup.</p>",
        "id": 477831875,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729365874
    },
    {
        "content": "<p>So you are saying that <code>Law.MagmaLaw.comp</code> is actually terry's order?</p>",
        "id": 477831931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729365921
    },
    {
        "content": "<p>but you don't know how to generate laws in that order</p>",
        "id": 477831953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729365948
    },
    {
        "content": "<p>Yes, its his order (so that binary search works), and I didn't attempt to recreate his order so far.</p>",
        "id": 477832350,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729366304
    },
    {
        "content": "<p>By the way, the script was written by <span class=\"user-mention\" data-user-id=\"302984\">@Amir Livne Bar-on</span> , back in the prehistory of the project on Sep 26 (when it was in a different repository).</p>",
        "id": 477834261,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729368168
    },
    {
        "content": "<p>36 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"458659\" href=\"/#narrow/channel/458659-Equational/topic/proving.20a.20hasse.20diagrams.20to.20be.20complete\">#Equational &gt; proving a hasse diagrams to be complete</a> by <span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span>.</p>",
        "id": 477837640,
        "sender_full_name": "Notification Bot",
        "timestamp": 1729371427
    },
    {
        "content": "<p>If we change the type of the checker from <code>Law -&gt; Bool</code> to <code>Law -&gt; Monoid</code> it can also be a generator. Then we can test and tweak the order if we want it to fit the list.</p>",
        "id": 477866676,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729400436
    },
    {
        "content": "<p>This is easier said than done. The nice way I managed to put it uses higher-order types, and I can't see how to make the induction on <code>iterFreeMagmas</code> (nee <code>testFreeMagmas</code>) work correctly.<br>\n<a href=\"https://github.com/amirlb/equational_theories/blob/laws_iterator/equational_theories/Equations/LawsComplete.lean#L176\">https://github.com/amirlb/equational_theories/blob/laws_iterator/equational_theories/Equations/LawsComplete.lean#L176</a></p>\n<p>The ordering is still not exactly the same, but we can probably shuffle some indices to make it output in the same order.</p>",
        "id": 477881311,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729416454
    },
    {
        "content": "<p>Is it worth the bother?  Generate-and-lookup seems fine to me, and the speed is acceptable.</p>",
        "id": 477885857,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729421010
    },
    {
        "content": "<p>Probably not worth it. Especially since (as I realized after I got the list) it doesn't generate any law more than twice</p>",
        "id": 477886410,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729421576
    },
    {
        "content": "<p>well, I wanted to improve on the native_decide part</p>",
        "id": 477892127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729427725
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302984\">@Amir Livne Bar-on</span> do you have code?</p>",
        "id": 477892216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729427819
    },
    {
        "content": "<p>Yes, <a href=\"https://github.com/amirlb/equational_theories/blob/laws_iterator/equational_theories/Equations/LawsComplete.lean\">the link above</a> is a file that generates lists and checks properties with the same code. It works, only one theorem is broken.</p>\n<p>But if we go for complicated type-classes here, we may as well use ForIn which has syntax and support for propositions.</p>",
        "id": 477894125,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1729429660
    },
    {
        "content": "<p>oh, I missed that that was a link to your fork</p>",
        "id": 477896446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729431756
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/477885857\">said</a>:</p>\n<blockquote>\n<p>Is it worth the bother?  Generate-and-lookup seems fine to me, and the speed is acceptable.</p>\n</blockquote>\n<p>Maybe worth the bother if we want to get rid of <code>native_decide</code>, and need to make it go a lot faster.</p>\n<p>In <a href=\"https://github.com/teorth/equational_theories/pull/780\">https://github.com/teorth/equational_theories/pull/780</a> I saw how far I get with using some tricks to make well-founded recursion go well and with reducing some overhead (typeclasses, Monad), but it is still far too slow.</p>\n<p>I expect if we refactor the code to use a generator (as <span class=\"user-mention\" data-user-id=\"302984\">@Amir Livne Bar-on</span> started to do), and either make it generate them in the right order, or go trough a lookup table for the permuation (which can be calculated at elaboration time), then maybe it’s feasible.</p>\n<p><span class=\"user-mention\" data-user-id=\"302984\">@Amir Livne Bar-on</span> , <code>List.append</code> is likely far too slow here, due to the quadratic runtime; you probably need at least difference lists as the structure to collect the results, or maybe implement the generator as left-folds (resp. <code>StateM</code>) and use <code>List.cons</code> to add new entries to the front.</p>\n<p>Or, don’t even generate the list, and stick closer to the current code, but keep a counter that’s passed to the predicate and then we can use that counter to avoid the (likely expensive) <code>findMagmaLaw</code> search.</p>",
        "id": 480260660,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1730592204
    },
    {
        "content": "<p>Can someone remind me where to find the definition of the magma enumeration ordering?</p>",
        "id": 480261169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730592671
    },
    {
        "content": "<p>Here's the lean implementation: <a href=\"#narrow/channel/458659-Equational/topic/Reconstructing.20the.204694.20expressions.20from.20the.20ground.20up.2E/near/478350231\">https://leanprover.zulipchat.com/#narrow/channel/458659-Equational/topic/Reconstructing.20the.204694.20expressions.20from.20the.20ground.20up.2E/near/478350231</a> .  I should put the ordering in the blueprint at some point.</p>",
        "id": 480262541,
        "sender_full_name": "Terence Tao",
        "timestamp": 1730593948
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> <a href=\"#narrow/channel/458659-Equational/topic/Reconstructing.20the.204694.20expressions.20from.20the.20ground.20up.2E/near/478348580\">said</a>:</p>\n<blockquote>\n<ul>\n<li>The ordering on laws with a fixed length on both the left-hand side and right-hand side is a bit hard to explain (recursive lexicographic).  At this point it is easier just to point to the python code than to try to describe it properly here.</li>\n</ul>\n</blockquote>\n<p>What python code?</p>",
        "id": 480262841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730594262
    },
    {
        "content": "<p><code>scripts/generate_eqs_list.py</code></p>",
        "id": 480262890,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1730594292
    },
    {
        "content": "<p>The <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>C</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">C_{n+1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8917em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span> factor hints at a simple explanation: consider the tree corresponding to <code>lhs * rhs</code>, first order by that, and then lexicographically</p>",
        "id": 480281084,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1730612690
    },
    {
        "content": "<p>JFTR, Mario solved the issue, as mentioned over at <a class=\"stream-topic\" data-stream-id=\"458659\" href=\"/#narrow/channel/458659-Equational/topic/LawsComplete.20by.20proof.20term.20generation\">#Equational &gt; LawsComplete by proof term generation</a></p>",
        "id": 480295721,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1730628768
    },
    {
        "content": "<p>So I was looking back a bit at this and it seems we have solved the enumeration issue (laws complete), but we still have no proof that includes the implications/refutations. I'm not sure how we'd even want to state that theorem, saying that for every pair of laws <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mn>1</mn></msub><msub><mi>l</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">l_1 l_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> we either have a proof of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mn>1</mn></msub><mo>⊢</mo><msub><mi>l</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">l_1 \\vdash l_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> or a refutation. </p>\n<p>The best way I can think of is defining the set of implications as an adjacency matrix <code>implications</code> (similar to <code>laws</code> in <code>LawsComplete</code>) and proving something like <code>laws[i] ≤ laws[j] ↔ implications[i][j] = true</code>. Does someone have a better idea? Is it worth adding this as an issue? (I would be interested in contributing to this, although I don't know how much time I will have for it)</p>",
        "id": 486094738,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1733319600
    },
    {
        "content": "<p>having said that, this array is probably a bit too large to have in memory (and be efficient), so maybe we want to phrase this for the transitive closure of a sparse matrix only</p>",
        "id": 486095528,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1733319841
    },
    {
        "content": "<p>That is roughly the theorem, but the harder question is the necessary proof engineering that we don't generate 4000² individual proofs.</p>\n<p>I would expect something like </p>\n<ul>\n<li>a reasonable efficient representation of all <em>explicitly</em> proven facts (impliciations and counter-examples), maybe transitively reduced to keep it small</li>\n<li>a proof that for each entry in that data structure we really have a theorem</li>\n<li>a proof that the the closure of this data structure cover the whole graph.</li>\n</ul>\n<p>Ideally the third point can be proven in a way that does not require going through the whole graph. I believe Mario did think about this quite a bit.</p>",
        "id": 486095692,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733319888
    },
    {
        "content": "<p>Right, so you think that just storing the explicitly proven facts like we're currently doing (with the <code>@equational_result</code> tag) is going to be too inefficient?</p>",
        "id": 486101501,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1733321458
    },
    {
        "content": "<p>I think that depends on the algorithm used for the third step, and whether that will involve kernel-computation.</p>",
        "id": 486101824,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733321541
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">rg</span><span class=\"w\"> </span><span class=\"s2\">\"@</span><span class=\"err\">\\</span><span class=\"s2\">[equational_result\"</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">wc</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">l</span>\n<span class=\"mi\">12452</span>\n</code></pre></div>\n<p>I just checked roughly and it seems it's about 12k explicitly proven facts. That might indeed be a bit too large for putting them all together one proof term, so we should think about how to split them up</p>",
        "id": 486102039,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1733321605
    },
    {
        "content": "<p>(this set is probably not minimal, but ballpark it still sounds like too much)</p>",
        "id": 486102277,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1733321668
    },
    {
        "content": "<p>I don’t know how useful it is to split them up if you end up having to put them together for the third proof step?</p>",
        "id": 486102307,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733321680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/486102307\">said</a>:</p>\n<blockquote>\n<p>I don’t know how useful it is to split them up if you end up having to put them together for the third proof step?</p>\n</blockquote>\n<p>but for the third proof step it doesn't have to actually look at the proof term, just its type, right?</p>",
        "id": 486102424,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1733321714
    },
    {
        "content": "<p>Right, but the type would still mention a data structure that contains 12k entries, woudn’t it</p>",
        "id": 486102514,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733321741
    },
    {
        "content": "<p>I am not primarily worried about a <code>def</code> with a careful chosen data structure with 12k elements, and then a proof that the entries are correct that is essentially 12k times “see theorem <code>foo</code>” (step 2). It’s step 3 that worries me.</p>\n<p>And as step3 likely influence which data structure to use here, I’m hesitant to worry about step 2 before that is determined.</p>",
        "id": 486102778,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733321813
    },
    {
        "content": "<p>hmm, interesting <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> yeah, I think I see the problem</p>",
        "id": 486103133,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1733321912
    },
    {
        "content": "<p>I think <a class=\"stream-topic\" data-stream-id=\"458659\" href=\"/#narrow/channel/458659-Equational/topic/proving.20a.20hasse.20diagrams.20to.20be.20complete\">#Equational &gt; proving a hasse diagrams to be complete</a>  is the thread where approaches to step 3 were discussed</p>",
        "id": 486103378,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733321987
    },
    {
        "content": "<p>12k explicit facts doesn't sound that bad, that's only about 3 times larger than the list of equations itself</p>",
        "id": 486111285,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733324097
    },
    {
        "content": "<p>that's a very sparse graph</p>",
        "id": 486111306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733324102
    },
    {
        "content": "<p>Note that each counter-example fact can represent a large amount of actual edges, but still.</p>",
        "id": 486111765,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733324236
    },
    {
        "content": "<p>It might help for some folks to try to do an analysis of the full hasse diagram to see whether there are any interesting structures we can exploit (eg. does it have many connected components? is it almost linear? etc)</p>",
        "id": 486111769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733324237
    },
    {
        "content": "<p>Is there some interest in porting <code>find_equation_id.py</code> from python to Lean?  I can deal with the complexities of indices but I don't understand yet how to get started: for instance I don't understand the relation between <code>equation</code> in <code>Equations/Eqns1_999.lean</code> and <code>EquationN</code> in files like <code>ParseImplications.lean</code>.  Is there some documentation of that somewhere?</p>",
        "id": 486112037,
        "sender_full_name": "Bruno Le Floch",
        "timestamp": 1733324307
    },
    {
        "content": "<p>Yes, there are 10k implications, and ~1.3k refutations but they represent around ~500k edges. That ~500k number is not all necessary for completeness though</p>",
        "id": 486112047,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733324309
    },
    {
        "content": "<p>I'm surprised there are so few refutations</p>",
        "id": 486112111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733324331
    },
    {
        "content": "<p>Most of the refutations are resolved by just looking at 3x3 magmas.</p>",
        "id": 486112223,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733324361
    },
    {
        "content": "<p>The refutations are also grouped, right? i.e. they are more like \"fact nodes\" saying that Ai -/&gt; Bj for all i,j in some lists A, B</p>",
        "id": 486112294,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733324385
    },
    {
        "content": "<p>Yes, that's what I mean by 1.3k theorems but 500k edges.</p>",
        "id": 486112410,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733324405
    },
    {
        "content": "<p>right, this is definitely going to be exploited by the proof</p>",
        "id": 486112559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733324432
    },
    {
        "content": "<p>500k is the sum of the 1.3k Satisfying*Refuting</p>",
        "id": 486112572,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733324433
    },
    {
        "content": "<p>there will be no \"multiply all these terms together\" proof</p>",
        "id": 486112661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733324456
    },
    {
        "content": "<p>at least not if I have anything to say about it :)</p>",
        "id": 486112757,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733324484
    },
    {
        "content": "<p>how many edges are there if we count a fact as having A+B edges?</p>",
        "id": 486113040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733324562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/486111769\">said</a>:</p>\n<blockquote>\n<p>It might help for some folks to try to do an analysis of the full hasse diagram to see whether there are any interesting structures we can exploit (eg. does it have many connected components? is it almost linear? etc)</p>\n</blockquote>\n<p>Strongly connected components is already know, there are 1,415 equivalence classes, the largest is of size 1,496, but 1,145/1,415 are of size 1</p>",
        "id": 486113094,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733324577
    },
    {
        "content": "<p>oh well that makes things easier</p>",
        "id": 486113200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733324607
    },
    {
        "content": "<p>Yes, the SCC graph is ~10x smaller than the original</p>",
        "id": 486113281,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733324635
    },
    {
        "content": "<p>And there are only ~4.8k edges in the transitive reduction between equivalence classes</p>",
        "id": 486113390,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733324654
    },
    {
        "content": "<p>The rest are establishing equivalence classes.</p>",
        "id": 486113437,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733324662
    },
    {
        "content": "<p>or does it? If there are a huge number of isolated components (once you take off the top and bottom, I assume) don't we have to prove all the n^2 non-implications?</p>",
        "id": 486113458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733324666
    },
    {
        "content": "<p>Don't you just have to prove the most general refutations? I mean perhaps that entails some level of graph search as well, but I'm not sure that it's n^2</p>",
        "id": 486113649,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733324719
    },
    {
        "content": "<p>Let's suppose that step 1 of the proof is to separate out all the size 1 components and handle them specially. What is the proof strategy?</p>",
        "id": 486113682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733324727
    },
    {
        "content": "<p>Just checking: Are you talking about the same thing if you say equivalence classes resp. connected components?</p>",
        "id": 486113738,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733324743
    },
    {
        "content": "<p>I am picturing a diagram with <code>0 &lt;= x_i &lt;= 1</code> and all <code>x_i</code> incomparable</p>",
        "id": 486113880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733324776
    },
    {
        "content": "<p>Why are size 1 components special? I think you treat all SCCs equivalently, and then prove that if it's complete for SCCs it's true for the graph.</p>",
        "id": 486113956,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733324797
    },
    {
        "content": "<p>They aren't, but I want to exploit known structure in the graph to make the proof smaller</p>",
        "id": 486114177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733324849
    },
    {
        "content": "<p>I think Mario is already one step ahead, and looks at a graph where equivalent laws are already represented by a single node, with the top and bottom law cut off, and now wants to know the connected components of this graph</p>",
        "id": 486114207,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733324856
    },
    {
        "content": "<p>something like \"80% of the graph is trivial\" definitely qualifies</p>",
        "id": 486114254,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733324869
    },
    {
        "content": "<p>How can there be connected components, it's already a condensed graph</p>",
        "id": 486114360,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733324885
    },
    {
        "content": "<p>Ah, perhaps I'm confusing terminology with connected components and strongly connected?</p>",
        "id": 486114688,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733324971
    },
    {
        "content": "<p>Yes, Joachim is correct. The connected components I'm talking about are in the undirected version of the transitive reduction graph, after collapsing equivalent nodes and deleting the top and bottom</p>",
        "id": 486114907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733325022
    },
    {
        "content": "<p>Well, take what I said above to be about <em>strongly</em> connected components in the base graph, not this model.</p>",
        "id": 486115163,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733325090
    },
    {
        "content": "<p>SCCs would be single nodes in what I said. How many nodes are there in the graph after reducing SCCs?</p>",
        "id": 486115284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733325122
    },
    {
        "content": "<p>oh wait you answered that already (1415)</p>",
        "id": 486115523,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733325182
    },
    {
        "content": "<p>In addition to knowing how many such components we have it’s also relevant to know, for each of them, their size, the number of least elements and the number of greatest elements (because we’ll need counter-examples between each greatest and each least element, unless I’m mistaken).</p>",
        "id": 486115981,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733325296
    },
    {
        "content": "<p>yeah knowing the actual numbers helps a lot with determining how much engineering is overengineering</p>",
        "id": 486116191,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733325352
    },
    {
        "content": "<p>e.g. no need to deploy Tarjan's SCC algorithm if it's all singletons</p>",
        "id": 486116341,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733325382
    },
    {
        "content": "<p>but I think SCCs are essentially an independent part of the proof from the hasse diagram structure</p>",
        "id": 486116566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733325454
    },
    {
        "content": "<p>For least and greatest, I assume you just meant inbound edges to Equation 1 and outbound edges of Equation 2, or do you mean this recursively, since some connected components are large?</p>",
        "id": 486118225,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733325913
    },
    {
        "content": "<p>I assume that you remove Eq1 and Eq2 first (“deleting top and bottom”), and then the graph falls apart into connected components. Of these components, it’s relevant to know how many least and greatest there are.</p>\n<p>Ah, but you are right: these are indeed the edges from and to Eq1 and Eq2 in the transitively reduced graph.</p>",
        "id": 486118596,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733325994
    },
    {
        "content": "<p>Here's <a href=\"https://teorth.github.io/equational_theories/graphiti/?render=true&amp;neighborhood_of_distance=1&amp;neighborhood_of=2\">graphiti</a> showing outbound edges from Eq2. Open the JS console and it shows that there are 46 edges.</p>",
        "id": 486118779,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733326039
    },
    {
        "content": "<p>For <a href=\"https://teorth.github.io/equational_theories/graphiti/?render=true&amp;neighborhood_of_distance=1&amp;neighborhood_of=1\">Equation 1</a> it's 57 inbounds.</p>",
        "id": 486118873,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733326064
    },
    {
        "content": "<p>Thanks! That also puts  upper bounds on the number of connected components (after deleting Eq 1 and Eq2)</p>",
        "id": 486118990,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733326084
    },
    {
        "content": "<p>Looking at the size of the components outwards from Eq2, they have this number of elements:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>2 Eq1076<br>\n2 Eq1083<br>\n2 Eq1110<br>\n2 Eq1279<br>\n2 Eq1286<br>\n2 Eq1516<br>\n2 Eq1692<br>\n2 Eq1719<br>\n2 Eq1888<br>\n2 Eq1895<br>\n2 Eq2091<br>\n2 Eq2301<br>\n2 Eq2328<br>\n2 Eq2497<br>\n2 Eq2504<br>\n2 Eq2531<br>\n2 Eq2700<br>\n2 Eq2903<br>\n2 Eq2910<br>\n2 Eq2937<br>\n2 Eq3106<br>\n2 Eq3140<br>\n2 Eq467<br>\n2 Eq501<br>\n2 Eq670<br>\n2 Eq677<br>\n2 Eq704<br>\n2 Eq907<br>\n3 Eq1313<br>\n3 Eq1489<br>\n3 Eq2098<br>\n3 Eq2294<br>\n4 Eq66<br>\n6 Eq2707<br>\n6 Eq880<br>\n9 Eq125<br>\n9 Eq222<br>\n9 Eq3113<br>\n9 Eq474<br>\n12 Eq271<br>\n12 Eq63<br>\n39 Eq168<br>\n478 Eq895<br>\n643 Eq41<br>\n693 Eq4<br>\n693 Eq5</p>\n</div></div>",
        "id": 486121564,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733326712
    },
    {
        "content": "<p>Nice! Are Eq4 and Eq5 are in the same component of size 693?</p>",
        "id": 486121827,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733326785
    },
    {
        "content": "<p>No, they are dual.</p>",
        "id": 486121968,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733326811
    },
    {
        "content": "<p>And the small ones have size 2 because you are including Eq1 in the count? Or are they all equivalence classes consisting of two laws?</p>",
        "id": 486122076,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733326840
    },
    {
        "content": "<p>so this list is already just taking a single representative of every scc?</p>",
        "id": 486122154,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1733326863
    },
    {
        "content": "<p>No I'm not including Eq1, for example, <a href=\"https://teorth.github.io/equational_theories/graphiti/?render=true&amp;neighborhood_of_distance=4&amp;neighborhood_of=1076&amp;show_sporadic_equations=on\">here is 1076</a></p>",
        "id": 486122180,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733326870
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andrés Goens</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/486122154\">said</a>:</p>\n<blockquote>\n<p>so this list is already just taking a single representative of every scc?</p>\n</blockquote>\n<p>Yes.</p>",
        "id": 486122394,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733326926
    },
    {
        "content": "<p>I just noticed the list has sporadic equations (or order &gt;4) included but there are only a few of them so it shouldn't affect the numbers much.</p>",
        "id": 486122607,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733326982
    },
    {
        "content": "<p>Looking at <a href=\"https://teorth.github.io/equational_theories/graphiti/?render=true&amp;neighborhood_of_distance=12&amp;neighborhood_of=271&amp;show_sporadic_equations=on\">271 here</a> it looks like repeating the process of cutting off top or bottom elements and recursing might handle a good part of the graph.</p>",
        "id": 486122806,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733327037
    },
    {
        "content": "<p>I guess also generating and proving the 1415 theorems that describe the scc's is a pretty good idea in any case already, right?</p>",
        "id": 486123419,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1733327180
    },
    {
        "content": "<p>independent of how we split the collapsed graph</p>",
        "id": 486123489,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1733327201
    },
    {
        "content": "<p>we'll need to collapse it</p>",
        "id": 486123507,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1733327207
    },
    {
        "content": "<p>(There are only 270 SCCs of size &gt;1)</p>",
        "id": 486123873,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733327313
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"761203\">Vlad Tsyrklevich</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/486121968\">said</a>:</p>\n<blockquote>\n<p>No, they are dual.</p>\n</blockquote>\n<p>Oh, duality is also going to be super helpful here. Can we pair up the connected components into dual pairs which have the exact same structure?</p>",
        "id": 486123897,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733327323
    },
    {
        "content": "<p>I guess Eq41 has to be self-dual</p>",
        "id": 486123987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733327353
    },
    {
        "content": "<p>41 is, but 895 is not.</p>",
        "id": 486124074,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733327385
    },
    {
        "content": "<p>(895 is equivalent to it's dual, hence you don't see it.)</p>",
        "id": 486124112,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733327399
    },
    {
        "content": "<p>I mean the cluster should be self-dual, i.e. the image of the dual map on the 895 cluster is itself</p>",
        "id": 486124379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733327471
    },
    {
        "content": "<p>Are there really no size 1 components?</p>",
        "id": 486124552,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733327518
    },
    {
        "content": "<p>I don't think there can be, any &gt;1 variable equation implies its one-variable version.</p>",
        "id": 486124826,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733327590
    },
    {
        "content": "<p>but the 1 variable version could be top or bottom, no?</p>",
        "id": 486125277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733327715
    },
    {
        "content": "<p>i.e. that argument proves there are two nodes but not that neither of them is extremal (or that they are inequivalent)</p>",
        "id": 486125407,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733327752
    },
    {
        "content": "<p>there might be a general argument for why reducing the variable count always results in an inequivalent equation though</p>",
        "id": 486125613,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733327809
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/486125277\">said</a>:</p>\n<blockquote>\n<p>but the 1 variable version could be top or bottom, no?</p>\n</blockquote>\n<p>If I understand what you mean correctly, it has to be top, e.g. most general. It's only restricting elements related to the diagonal.</p>",
        "id": 486125809,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733327865
    },
    {
        "content": "<p>does graphiti have an option for collapsing equivalent nodes?</p>",
        "id": 486125987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733327903
    },
    {
        "content": "<p>It already collapses them</p>",
        "id": 486126031,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733327917
    },
    {
        "content": "<p>what does rounded corners mean?</p>",
        "id": 486126142,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733327959
    },
    {
        "content": "<p>It means it's an SCC of size &gt;1.</p>",
        "id": 486126238,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733327983
    },
    {
        "content": "<p>It might also be possible to make the SCC computation faster by adding just a _few_ extra theorems. Like for the Eq2 equivalence class, adding a theorem for EqX -&gt; Eq2 directly (instead of relying on dynamically finding a path through other theorems) means that we can verify everything in the SCC by just checking those O(n) extra theorems.</p>",
        "id": 486126280,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1733327998
    },
    {
        "content": "<p>While creating all 4000^2 theorems is obviously too much, adding a theorem for \"X implies 2\" for each X that does seems totally fine as overehead/optimization</p>",
        "id": 486126454,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1733328032
    },
    {
        "content": "<p>It's not clear why we would need that</p>",
        "id": 486126595,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733328065
    },
    {
        "content": "<p>We need to prove SCCs, not non-SCCs</p>",
        "id": 486126698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733328087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/486125613\">said</a>:</p>\n<blockquote>\n<p>there might be a general argument for why reducing the variable count always results in an inequivalent equation though</p>\n</blockquote>\n<p><del>You're right that my original argument missed this, and the argument as to why this is the case is that that setting all 0s along the diagonal always satisfies the one-variable equation, and then setting all the other elements to 1 should cause the multi-variable version to fail.</del></p>\n<p>EDIT: I suppose this actually isn't true for x = (xx)(yy), though it is for other equations it's equivalent to.</p>",
        "id": 486126738,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733328097
    },
    {
        "content": "<p>non-SCCs will be implied from non-implications during the hasse diagram part of the proof</p>",
        "id": 486126806,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733328110
    },
    {
        "content": "<p>Got lost in something else, here's the list of component sizes looking outwards from Eq2 paired by dual:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>2 Eq1076 Eq2531<br>\n2 Eq1083 Eq2504<br>\n2 Eq1110 Eq2497<br>\n2 Eq1279 Eq2328<br>\n2 Eq1286 Eq2301<br>\n2 Eq1516 Eq2091<br>\n2 Eq1692 Eq1895<br>\n2 Eq1719 Eq1888<br>\n2 Eq467 Eq3140<br>\n2 Eq501 Eq3106<br>\n2 Eq670 Eq2937<br>\n2 Eq677 Eq2910<br>\n2 Eq704 Eq2903<br>\n2 Eq907 Eq2700<br>\n3 Eq1313 Eq2294<br>\n3 Eq1489 Eq2098<br>\n4 Eq66 Eq281<br>\n6 Eq880 Eq2707<br>\n9 Eq125 Eq222<br>\n9 Eq474 Eq3113<br>\n12 Eq63 Eq271<br>\n39 Eq168<br>\n478 Eq895 Eq2789<br>\n643 Eq41<br>\n693 Eq4 Eq5</p>\n</div></div>",
        "id": 486131142,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733329205
    },
    {
        "content": "<p>Some stats that I didn't see mentioned in the thread already:</p>\n<ul>\n<li>The 1415 components are comprised of 67 self-dual components and 674 pairs of dual components</li>\n<li>The number of transitively-reduced implications in the Hesse diagram is 4824, or 2467 up to duality</li>\n<li>There are 14522 irreducible non-implications needed to prove that the diagram is fully-specified, or 7286 up to duality</li>\n</ul>",
        "id": 486167471,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1733341877
    },
    {
        "content": "<p>Oh, the last number is nice. I have a PR that adds dashboard stats that computes and publishes various facts about the graph, I should add that as well. By what algorithm do you compute the minimum required non-implications?</p>",
        "id": 486168355,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733342197
    },
    {
        "content": "<p>Nothing too smart, went over all the non-implications and checked if each can be derived directly from an implication + a stronger non-implication. Takes a few seconds in python.</p>",
        "id": 486169510,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1733342636
    },
    {
        "content": "<p>Where is the actual (explicit) implication data? The graphiti json doesn't have the implications themselves, only the induced implications on SCCs</p>",
        "id": 486169968,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733342785
    },
    {
        "content": "<p>lake exe extract_implications outcomes</p>",
        "id": 486170054,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1733342814
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302984\">Amir Livne Bar-on</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/486167471\">said</a>:</p>\n<blockquote>\n<ul>\n<li>There are 14522 irreducible non-implications needed to prove that the diagram is fully-specified, or 7286 up to duality</li>\n</ul>\n</blockquote>\n<p>How do you obtain this number? Using some algorithm that takes a Hesse diagram and gives you the least number of anti-implications you have to provide to prove that the diagram is fully specified?</p>",
        "id": 486170948,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1733343150
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302984\">Amir Livne Bar-on</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/486170054\">said</a>:</p>\n<blockquote>\n<p>lake exe extract_implications outcomes</p>\n</blockquote>\n<p>This seems to require the whole lean project to be built, I was hoping for a data dump file</p>",
        "id": 486172297,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733343649
    },
    {
        "content": "<p>Do you know if you have a particular data format you want?</p>",
        "id": 486172733,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733343832
    },
    {
        "content": "<p>e.g. <code>extract_implications</code> versus <code>extract_implications outcomes</code> etc.</p>",
        "id": 486172812,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733343845
    },
    {
        "content": "<p><code>lake exe extract_implications</code> doesn't run at all, it says </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">uncaught</span><span class=\"w\"> </span><span class=\"n\">exception</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">object</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"w\"> </span><span class=\"bp\">'././.</span><span class=\"n\">lake</span><span class=\"bp\">/</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">lib</span><span class=\"bp\">/</span><span class=\"n\">equational_theories</span><span class=\"bp\">.</span><span class=\"n\">olean'</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"n\">equational_theories</span><span class=\"w\"> </span><span class=\"n\">does</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">exist</span>\n</code></pre></div>",
        "id": 486173285,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733344036
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 486173306,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733344045
    },
    {
        "content": "<p>Oops, different exception</p>",
        "id": 486173334,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733344055
    },
    {
        "content": "<p>by which I inferred that it needs the project to be built</p>",
        "id": 486173347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733344059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"761203\">Vlad Tsyrklevich</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/486172733\">said</a>:</p>\n<blockquote>\n<p>Do you know if you have a particular data format you want?</p>\n</blockquote>\n<p>implications in json would be nice</p>",
        "id": 486173895,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733344245
    },
    {
        "content": "<p>I have managed to get stuff out of outcomes.png, which I recall being a recommendation before</p>",
        "id": 486173980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733344285
    },
    {
        "content": "<p><a href=\"https://tsyrklevi.ch/general.json.gz\">https://tsyrklevi.ch/general.json.gz</a></p>",
        "id": 486174138,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733344330
    },
    {
        "content": "<p>Once <a href=\"https://github.com/teorth/equational_theories/pull/973\">equational#973</a> lands (and assuming github pages accepts it), this should just be available on the dashboard going forward</p>",
        "id": 486174204,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733344365
    },
    {
        "content": "<p>That's the outcome of just plain <code>extract_implications</code></p>",
        "id": 486174255,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733344389
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/486170948\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"302984\">Amir Livne Bar-on</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/486167471\">said</a>:</p>\n<blockquote>\n<ul>\n<li>There are 14522 irreducible non-implications needed to prove that the diagram is fully-specified, or 7286 up to duality</li>\n</ul>\n</blockquote>\n<p>How do you obtain this number? Using some algorithm that takes a Hesse diagram and gives you the least number of anti-implications you have to provide to prove that the diagram is fully specified?</p>\n</blockquote>\n<p>This number doesn't include the fact that the edges of the diagram are strict implications, so the full number is actually 19346. Here's the main chunk of code I used to count these:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">non_implications</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{(</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">implications</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">implications</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]}</span>\n<span class=\"n\">simple_non_implications</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">non_implications</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"o\">((</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">non_implications</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">implications_rev</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">!=</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"o\">((</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">non_implications</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">implications</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">!=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 486175482,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1733344885
    },
    {
        "content": "<p>I get 10675 explicit implications and 587150 nonimplications from that json <span class=\"user-mention\" data-user-id=\"761203\">@Vlad Tsyrklevich</span> , is this correct?</p>",
        "id": 486175729,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733345009
    },
    {
        "content": "<p>that seems higher than the numbers we've been talking about</p>",
        "id": 486175750,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733345021
    },
    {
        "content": "<p>the nonimplications are unfortunately inflated because I don't think the \"facts\" are being tracked anywhere</p>",
        "id": 486175853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733345049
    },
    {
        "content": "<p>10,657 I think. You can check <a href=\"https://teorth.github.io/equational_theories/dashboard/\">https://teorth.github.io/equational_theories/dashboard/</a></p>",
        "id": 486175864,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733345055
    },
    {
        "content": "<p>that's weird, it's not a typo</p>",
        "id": 486175913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733345090
    },
    {
        "content": "<p>This is for the equations, before reducing to SCCs. So there are more edges.</p>",
        "id": 486175917,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1733345092
    },
    {
        "content": "<p>For raw facts, look here <a href=\"https://tsyrklevi.ch/general_raw_full_entries.json\">https://tsyrklevi.ch/general_raw_full_entries.json</a></p>",
        "id": 486175976,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733345117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/A.20final.20end-to-end.20theorem.20in.20Lean/near/486175913\">said</a>:</p>\n<blockquote>\n<p>that's weird, it's not a typo</p>\n</blockquote>\n<p>Ah, that may just be duplicates</p>",
        "id": 486176010,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733345140
    },
    {
        "content": "<p>Your numbers look slightly higher, so maybe equations beyond 4694 are included?</p>",
        "id": 486176012,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1733345141
    },
    {
        "content": "<p>Oh yes, also sporadic equations. The two great confounders.</p>",
        "id": 486176051,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733345160
    },
    {
        "content": "<p>There are 10 duplicates on main, the rest are sporadic I think.</p>",
        "id": 486176108,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733345170
    },
    {
        "content": "<p>There seem to be no implications in <code>general_raw_full_entries.json</code> with finite = true</p>",
        "id": 486177343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733345740
    },
    {
        "content": "<p>You need a different output for that, want the finite one?</p>",
        "id": 486177382,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733345759
    },
    {
        "content": "<p>not really, just checking</p>",
        "id": 486177450,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733345772
    },
    {
        "content": "<p>The output is per graph, either general or finite.</p>",
        "id": 486177491,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733345792
    },
    {
        "content": "<p>I would have thought the raw data just contains all the lean-proven theorems in whatever disposition</p>",
        "id": 486177498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733345794
    },
    {
        "content": "<p>I assume the finite facts are included though</p>",
        "id": 486177615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733345849
    },
    {
        "content": "<p>Yes.</p>",
        "id": 486177738,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733345890
    },
    {
        "content": "<p>there is only one :)</p>",
        "id": 486177823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733345929
    },
    {
        "content": "<p>wait nevermind, I can't count</p>",
        "id": 486177952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733345994
    },
    {
        "content": "<p>By the way, I checked and even if we remove the components for equations 1 and 2 there is a single connected component.</p>\n<p>What would a cut get us, if we find one in an inner part of the graph? It'll probably make the proof simpler to write, but will take longer to verify?</p>",
        "id": 486178552,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1733346209
    },
    {
        "content": "<p>How is that possible? See <a href=\"https://teorth.github.io/equational_theories/graphiti/?render=true&amp;neighborhood_of_distance=3&amp;neighborhood_of=1076\">https://teorth.github.io/equational_theories/graphiti/?render=true&amp;neighborhood_of_distance=3&amp;neighborhood_of=1076</a></p>",
        "id": 486178666,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733346246
    },
    {
        "content": "<p>Ah wait, I'm only looking up from Eq2, not down from Eq1, yes that still makes sense.</p>",
        "id": 486178721,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733346268
    },
    {
        "content": "<p>Horizontal cuts are better than vertical, but that doesn't help us much in this very flat graph</p>",
        "id": 486178892,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733346346
    },
    {
        "content": "<p>If anyone wants to play with the SCC-reduced graph, I'm attaching my data here (script, textual output, sqlite)</p>\n<p><a href=\"/user_uploads/3121/79mp1dmFOi3vvjLlrJkuZGgq/analyze_comps.py\">analyze_comps.py</a><br>\n<a href=\"/user_uploads/3121/LkkM8lYdkOErXtlYtAWednIS/comps_graph.db\">comps_graph.db</a><br>\n<a href=\"/user_uploads/3121/Q6N-t3ysIJMUMCoaJXDZj-Wk/comps_graph.txt\">comps_graph.txt</a></p>",
        "id": 486178898,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1733346349
    },
    {
        "content": "<p>Just an FYI, that a number of the stats we've discussed here and the exported data is now available on <a href=\"https://teorth.github.io/equational_theories/dashboard/\">https://teorth.github.io/equational_theories/dashboard/</a></p>",
        "id": 486239109,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1733382708
    },
    {
        "content": "<p>Sorry; I don't have anything to contribute.<br>\nI just want to say that I am really happy that people work on this.</p>",
        "id": 486484919,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1733481552
    },
    {
        "content": "<p>I spent a while burning brain energy on this hasse diagram problem, and my conclusion is that my previous suggestion of using some kind of sweep across the poset doesn't work, or not well enough. The new plan is much simpler:</p>\n<p>We want to prove every pair <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo>∈</mo><mi>L</mi><mi>a</mi><mi>w</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">A,B\\in Laws</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">s</span></span></span></span> is represented in the poset (either via implication or nonimplication). Call this property <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Dec</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo>≤</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Dec}(A\\le B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Dec</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span>. We generalize to the predicate <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Dec</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>S</mi><mo>≤</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Dec}(S\\le T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Dec</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo separator=\"true\">,</mo><mi>T</mi><mo>⊆</mo><mi>L</mi><mi>a</mi><mi>w</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">S,T\\subseteq Laws</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">s</span></span></span></span>, which asserts that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Dec</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo>≤</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Dec}(A\\le B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Dec</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span> for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∈</mo><mi>S</mi><mo separator=\"true\">,</mo><mi>B</mi><mo>∈</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">A\\in S, B\\in T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>. We now have the following rules:</p>\n<ul>\n<li>Split left: If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>S</mi><mn>2</mn></msub><mo>=</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S_1\\cup S_2=S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Dec</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><msub><mi>S</mi><mn>1</mn></msub><mo>≤</mo><mi>T</mi><mo stretchy=\"false\">)</mo><mo>∧</mo><mi mathvariant=\"normal\">Dec</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><msub><mi>S</mi><mn>2</mn></msub><mo>≤</mo><mi>T</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi mathvariant=\"normal\">Dec</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>S</mi><mo>≤</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Dec}(S_1\\le T)\\land \\operatorname{Dec}(S_2\\le T)\\to \\operatorname{Dec}(S\\le T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Dec</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Dec</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Dec</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>Split right: If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>T</mi><mn>2</mn></msub><mo>=</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T_1\\cup T_2=T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Dec</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>S</mi><mo>≤</mo><msub><mi>T</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mo>∧</mo><mi mathvariant=\"normal\">Dec</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>S</mi><mo>≤</mo><msub><mi>T</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo><mo>→</mo><mi mathvariant=\"normal\">Dec</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>S</mi><mo>≤</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Dec}(S\\le T_1)\\land \\operatorname{Dec}(S\\le T_2)\\to \\operatorname{Dec}(S\\le T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Dec</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Dec</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Dec</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>Nonimplies: If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">M=min(S)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">min</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span></span></span></span> is the set of minimal elements of S and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">N=max(T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span></span></span></span> similarly, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>≰</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\not\\le B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∈</mo><mi>M</mi><mo separator=\"true\">,</mo><mi>B</mi><mo>∈</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">A\\in M,B\\in N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Dec</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>S</mi><mo>≤</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Dec}(S\\le T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Dec</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span></span></span></span>.</li>\n</ul>\n<p>The main strategy then for certificate generation is to pick a (preferably explicit) nonimplication <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>≰</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\not\\le B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> for which <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mo lspace=\"0em\" rspace=\"0em\">↑</mo><mi>A</mi><mi mathvariant=\"normal\">∣</mi><mtext> </mtext><mi mathvariant=\"normal\">∣</mi><mo lspace=\"0em\" rspace=\"0em\">↓</mo><mi>B</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|{\\uparrow}A|\\ |{\\downarrow}B|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mrel\">↑</span></span><span class=\"mord mathnormal\">A</span><span class=\"mord\">∣</span><span class=\"mspace\"> </span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mrel\">↓</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord\">∣</span></span></span></span> is as large as possible (where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo lspace=\"0em\" rspace=\"0em\">↑</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">{\\uparrow}A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mrel\">↑</span></span><span class=\"mord mathnormal\">A</span></span></span></span> is the set of elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> above <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> and likewise for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo lspace=\"0em\" rspace=\"0em\">↓</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">{\\downarrow}B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mrel\">↓</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>), grow it if possible to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mo lspace=\"0em\" rspace=\"0em\">↑</mo><mi>M</mi><mi mathvariant=\"normal\">∣</mi><mtext> </mtext><mi mathvariant=\"normal\">∣</mi><mo lspace=\"0em\" rspace=\"0em\">↓</mo><mi>N</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|{\\uparrow}M|\\ |{\\downarrow}N|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mrel\">↑</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\">∣</span><span class=\"mspace\"> </span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mrel\">↓</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord\">∣</span></span></span></span> while maintaining the property that every element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is not below every element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>, then use the rules:</p>\n<ul>\n<li>split left with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>=</mo><mo lspace=\"0em\" rspace=\"0em\">↑</mo><mi>M</mi><mo>∪</mo><mo stretchy=\"false\">(</mo><mi>S</mi><mo>∖</mo><mo lspace=\"0em\" rspace=\"0em\">↑</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">S={\\uparrow}M\\cup (S\\setminus {\\uparrow}M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mrel\">↑</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∖</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mrel\">↑</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span><ul>\n<li>split right with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><mo lspace=\"0em\" rspace=\"0em\">↓</mo><mi>N</mi><mo>∪</mo><mo stretchy=\"false\">(</mo><mi>T</mi><mo>∖</mo><mo lspace=\"0em\" rspace=\"0em\">↓</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T={\\downarrow}N\\cup (T\\setminus {\\downarrow}N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mrel\">↓</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∖</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mrel\">↓</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span><ul>\n<li>nonimplies on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo separator=\"true\">,</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M, N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></li>\n<li>recurse to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Dec</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mo lspace=\"0em\" rspace=\"0em\">↑</mo><mi>M</mi><mo>≤</mo><mo stretchy=\"false\">(</mo><mi>T</mi><mo>∖</mo><mo lspace=\"0em\" rspace=\"0em\">↓</mo><mi>N</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Dec}({\\uparrow}M\\le (T\\setminus {\\downarrow}N))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Dec</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mrel\">↑</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∖</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mrel\">↓</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">))</span></span></span></span>.</li>\n</ul>\n</li>\n<li>recurse to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Dec</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>S</mi><mo>∖</mo><mo lspace=\"0em\" rspace=\"0em\">↑</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo>≤</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Dec}((S\\setminus {\\uparrow}M)\\le T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Dec</span></span><span class=\"mopen\">((</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∖</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mrel\">↑</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span></span></span></span>.</li>\n</ul>\n</li>\n</ul>\n<p>Using only splitting, we get a quadratic size proof. But the nonimplies proof is proportional only to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mo lspace=\"0em\" rspace=\"0em\">↑</mo><mi>M</mi><mi mathvariant=\"normal\">∣</mi><mtext> </mtext><mi mathvariant=\"normal\">∣</mi><mo lspace=\"0em\" rspace=\"0em\">↓</mo><mi>N</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|{\\uparrow}M|\\ |{\\downarrow}N|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mrel\">↑</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\">∣</span><span class=\"mspace\"> </span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mrel\">↓</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord\">∣</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> will generally be very small here (usually 1) so this knocks out entire contiguous rectangles from the implication matrix at a time.</p>\n<p>If the procedure fails to make progress, then there must not be any nonimplications remaining. Proof strategy TODO for this case</p>",
        "id": 486537921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733498729
    }
]