[
    {
        "content": "<p>All 35 of the conjectured non-implications from 2126 are false, and can be proven so by completing the rewriting system and showing that both sides of the resultant equation are reduced. The completion is </p>\n<ul>\n<li>((yy)x)(xz) = x</li>\n<li>(xx)(((xx)y)z) = (xx)y</li>\n<li>((yy)((xx)z))z = (xx)z</li>\n<li>((xx)y)((((xx)y)w)z) = ((xx)y)w</li>\n</ul>",
        "id": 476396542,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1728655761
    },
    {
        "content": "<p>was this from an ATP?</p>",
        "id": 476396858,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728655862
    },
    {
        "content": "<p>It was from using kbcv to complete the TRS, then just inspection of the conjectures from <a href=\"https://teorth.github.io/equational_theories/implications/?2126\">https://teorth.github.io/equational_theories/implications/?2126</a></p>",
        "id": 476396975,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1728655904
    },
    {
        "content": "<p>(Plus the intuition that this equation is like the central groupoid law and so it was a reasonable bet that it had a nice completion, which is why I tried this one and not others)</p>",
        "id": 476397186,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1728655971
    },
    {
        "content": "<p>Your own implementation of kbc?</p>",
        "id": 476397254,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728655994
    },
    {
        "content": "<p>That's really cool</p>",
        "id": 476397310,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728656015
    },
    {
        "content": "<p>No, kbcv: <a href=\"http://cl-informatik.uibk.ac.at/software/kbcv/\">http://cl-informatik.uibk.ac.at/software/kbcv/</a></p>",
        "id": 476397372,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1728656031
    },
    {
        "content": "<p>Nice! With duality, that’s 70 implications off the table, a sizeable advance! I’ll open a task to formalize this now.</p>",
        "id": 476397393,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728656039
    },
    {
        "content": "<p>Oh I missed the <code>v</code> in <code>kbcv</code></p>",
        "id": 476397484,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728656059
    },
    {
        "content": "<p>Nice work</p>",
        "id": 476397522,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728656073
    },
    {
        "content": "<p>My proof that terms in central groupoids have a normal form in Lean forces you to discover the completion, so I could have done it like that too. But that isn't what I did; it will probably be how I formalise this unless someone does it before me using Confluence.lean</p>",
        "id": 476397610,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1728656112
    },
    {
        "content": "<p>opened <a href=\"https://github.com/teorth/equational_theories/pull/515\">equational#515</a> for this.  There are some details on how to manage <code>Equations.lean</code> because we are trying (manually) to keep Chapter 2 of the blueprint synchronized with this file.</p>",
        "id": 476398821,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728656527
    },
    {
        "content": "<p>I think this is true for all current conjectures, I added infrastructure in <a href=\"https://github.com/teorth/equational_theories/pull/510\">https://github.com/teorth/equational_theories/pull/510</a> to define a system of rewrite rules, and it should be possible to prove all remaining conjectures this way, using output from either Twee or Vampire (they seem better than kbcv)</p>",
        "id": 476401446,
        "sender_full_name": "lyphyser",
        "timestamp": 1728657344
    },
    {
        "content": "<p>I'll probably do it in the next days, my current plan is to generate the rewrite rule system and the skeleton of the proof automatically using rule_system like the current ones in Confluence.lean, then prove manually and if a pattern emerges possibly write a tactic that can prove all of them and then switch to fully automated generation</p>",
        "id": 476401950,
        "sender_full_name": "lyphyser",
        "timestamp": 1728657521
    },
    {
        "content": "<p>an alternative could be to generally show that all critical pairs are confluent rather than showing that the normal forms of the hypothesis sides are equal; it seems that might be much slower to compile and complicated though, but I haven't tried it and maybe there's a great way to do it</p>",
        "id": 476402796,
        "sender_full_name": "lyphyser",
        "timestamp": 1728657813
    },
    {
        "content": "<p>also the current method has only been used for systems with 2 rules so far, so might need some sort of extra work for larger systems, although it could also just work as is</p>",
        "id": 476403074,
        "sender_full_name": "lyphyser",
        "timestamp": 1728657892
    },
    {
        "content": "<p>e.g. the system presented here for 2126 is substantially more complicated then the ones in the proofs so far</p>",
        "id": 476403191,
        "sender_full_name": "lyphyser",
        "timestamp": 1728657925
    },
    {
        "content": "<p>Just a notational question: does your system show that 2126 is a confluent law, or is it establishing something weaker than confluence?</p>",
        "id": 476403947,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728658157
    },
    {
        "content": "<p>2126 isn't confluent, but the system I gave above is a completion of it: they're equations derivable from 2126 but together the 4 of them give a confluent system</p>",
        "id": 476405880,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1728658770
    },
    {
        "content": "<p>on the surface it seems it establishes something weaker (but still sufficient to prove non-implications) but maybe it's actually equivalent, not totally sure</p>",
        "id": 476406070,
        "sender_full_name": "lyphyser",
        "timestamp": 1728658821
    },
    {
        "content": "<p>for context this is the current proof for the ! 3588 -&gt; implications submitted in <a href=\"https://github.com/teorth/equational_theories/pull/510\">https://github.com/teorth/equational_theories/pull/510</a></p>\n<p>rule_system rules {x y z w}<br>\n| z ⋆ ((x ⋆ y) ⋆ z) =&gt; x ⋆ y<br>\n| ((z ⋆ w) ⋆ (x ⋆ y)) ⋆ (z ⋆ w) =&gt; x ⋆ y</p>\n<p>theorem comp2 {α} [DecidableEq α] {x y z : FreeMagma α} (hxy: NF rules (x ⋆ y)):<br>\n    rules (z ⋆ rules (x ⋆ y ⋆ z)) = x ⋆ y := by<br>\n  generalize h: rules (x ⋆ y ⋆ z) = e<br>\n  simp only [rules.elim] at h<br>\n  separate<br>\n  · apply rules.eq2<br>\n  · apply rw_eq_self_of_NF rules hxy<br>\n  · apply rules.eq1</p>\n<p>theorem comp3 {α} [DecidableEq α] {x y z : FreeMagma α} (hx: NF rules x) (hy: NF rules y):<br>\n    rules (z ⋆ rules (rules (x ⋆ y) ⋆ z)) = rules (x ⋆ y) := by<br>\n  generalize h: rules (x ⋆ y) = e<br>\n  simp only [rules.elim] at h<br>\n  separate<br>\n  all_goals apply comp2<br>\n  · apply Everywhere.left hy<br>\n  · apply Everywhere.right hx<br>\n  · rw [NF, Everywhere]<br>\n    refine ⟨hx, hy, ?_⟩<br>\n    simp only [rules.elim]<br>\n    right<br>\n    constructorm* _ ∧ _<br>\n    all_goals trivial</p>\n<p>@[equational_result]<br>\ntheorem «Facts» :<br>\n  ∃ (G : Type) (_ : Magma G), Facts G [3588] [3862, 3878, 3917, 3955] := by<br>\n  use ConfMagma (@rules Nat _), inferInstance<br>\n  repeat' apply And.intro<br>\n  · rintro ⟨x, hx⟩ ⟨y, hy⟩ ⟨z, hz⟩<br>\n    simp only [Magma.op, bu, hx, hy, hz, buFixed_rw_op]<br>\n    symm<br>\n    congr! 1<br>\n    apply comp3 ((NF_iff_buFixed rules).mpr hx) ((NF_iff_buFixed rules).mpr hy)<br>\n  all_goals refute</p>",
        "id": 476406421,
        "sender_full_name": "lyphyser",
        "timestamp": 1728658936
    },
    {
        "content": "<p>so e.g. in this case the question is whether establishing that rules (z ⋆ rules (rules (x ⋆ y) ⋆ z)) = rules (x ⋆ y) is weaker than establishing that the \"rules\" rewrite rules system is confluent or whether they are equivalent</p>",
        "id": 476406627,
        "sender_full_name": "lyphyser",
        "timestamp": 1728659004
    },
    {
        "content": "<p>2126 -&gt; proved in <a href=\"https://github.com/teorth/equational_theories/pull/510\">https://github.com/teorth/equational_theories/pull/510</a></p>",
        "id": 476471176,
        "sender_full_name": "lyphyser",
        "timestamp": 1728688207
    },
    {
        "content": "<p>I think I proved them all modulo duality in that pull request</p>",
        "id": 476515061,
        "sender_full_name": "lyphyser",
        "timestamp": 1728730124
    },
    {
        "content": "<p>Looking at <a href=\"https://teorth.github.io/equational_theories/implications/?1659\">equation 1659</a> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo>⋄</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>⋄</mo><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>y</mi><mo>⋄</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>⋄</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">x = (x \\diamond y) \\diamond ((y \\diamond y) \\diamond z)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋄</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋄</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">((</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋄</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋄</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span></span></span></span>, the pair of rules <code>x ◇ ((y ◇ y) ◇ z) = x ◇ y</code> and <code>(x ◇ y) ◇ y = x</code> seems confluent to me (and both of them together are equivalent to 1659). Can someone better-versed in confluence check this?</p>",
        "id": 476532975,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728747922
    },
    {
        "content": "<p>no; Twee doesn't terminate and gives output that starts like this:<br>\n11. mul(X, mul(mul(mul(mul(Y, Y), Z), Y), W)) -&gt; mul(X, Y)<br>\n12. mul(X, mul(mul(mul(mul(mul(mul(Y, Y), Z), Y), W), Y), V)) -&gt; mul(X, Y)<br>\n13. mul(X, mul(mul(mul(mul(mul(mul(mul(mul(Y, Y), Z), Y), W), Y), V), Y), U)) -&gt; mul(X, Y)<br>\n14. mul(X, mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(Y, Y), Z), Y), W), Y), V), Y), U), Y), T)) -&gt; mul(X, Y)<br>\n15. mul(X, mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(Y, Y), Z), Y), W), Y), V), Y), U), Y), T), Y), S)) -&gt; mul(X, Y)<br>\n16. mul(X, mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(Y, Y), Z), Y), W), Y), V), Y), U), Y), T), Y), S), Y), X2)) -&gt; mul(X, Y)<br>\n17. mul(X, mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(Y, Y), Z), Y), W), Y), V), Y), U), Y), T), Y), S), Y), X2), Y), Y2)) -&gt; mul(X, Y)<br>\n18. mul(X, mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(Y, Y), Z), Y), W), Y), V), Y), U), Y), T), Y), S), Y), X2), Y), Y2), Y), Z2)) -&gt; mul(X, Y)<br>\n19. mul(X, mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(Y, Y), Z), Y), W), Y), V), Y), U), Y), T), Y), S), Y), X2), Y), Y2), Y), Z2), Y), W2)) -&gt; mul(X, Y)<br>\n20. mul(X, mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(Y, Y), Z), Y), W), Y), V), Y), U), Y), T), Y), S), Y), X2), Y), Y2), Y), Z2), Y), W2), Y), V2)) -&gt; mul(X, Y)<br>\n21. mul(X, mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(mul(Y, Y), Z), Y), W), Y), V), Y), U), Y), T), Y), S), Y), X2), Y), Y2), Y), Z2), Y), W2), Y), V2), Y), U2)) -&gt; mul(X, Y)</p>",
        "id": 476545097,
        "sender_full_name": "lyphyser",
        "timestamp": 1728759369
    },
    {
        "content": "<p>maybe adding the infinite rule scheme X(YY(?Y)*?) -&gt; XY would work?</p>",
        "id": 476545267,
        "sender_full_name": "lyphyser",
        "timestamp": 1728759583
    },
    {
        "content": "<p>I think it might, if you can test it that'd be great (does Twee support infinite rule schemes?)</p>",
        "id": 476545524,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728759759
    },
    {
        "content": "<p>perhaps there's a way to express it finitely by adding other symbols?</p>",
        "id": 476545639,
        "sender_full_name": "lyphyser",
        "timestamp": 1728759869
    },
    {
        "content": "<p>You can define <code>good(Y, A) ↔ A = Y ∨ ∃ B C, good(Y, B) ∧ A = mul(mul(B, Y), C)</code>, I guess, and then add <code>good(Y, A) -&gt; mul(X, A) = mul(X, Y)</code></p>",
        "id": 476545810,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728760042
    },
    {
        "content": "<p>I tried encoding this to vampire as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">fof</span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kn\">axiom</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mul</span><span class=\"o\">(</span><span class=\"n\">mul</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span>\n<span class=\"n\">fof</span><span class=\"o\">(</span><span class=\"n\">good_def</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kn\">axiom</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">good</span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">good</span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&amp;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">mul</span><span class=\"o\">(</span><span class=\"n\">mul</span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)))))))</span><span class=\"bp\">.</span>\n<span class=\"n\">fof</span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kn\">axiom</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">good</span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mul</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">mul</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">))))</span><span class=\"bp\">.</span>\n</code></pre></div>",
        "id": 476546260,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728760536
    },
    {
        "content": "<p>It can't reach saturation from this, but from what I'm seeing all equations it produces are reduced by this</p>",
        "id": 476546615,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728760908
    },
    {
        "content": "<p>How does one prove confluence?</p>",
        "id": 476615501,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728834207
    },
    {
        "content": "<p>It looks confluent to me. The only non trivial critical pair arises from matching yy with xy=x((yy)z...), in which case except for the first y, the other y's can be replaced by a simple variable.</p>",
        "id": 476645998,
        "sender_full_name": "Fan Zheng",
        "timestamp": 1728862891
    },
    {
        "content": "<p>It seems that ChatGPT is able to find the pattern in this infinite sequence:<br>\n<a href=\"https://chatgpt.com/share/670ce7db-8a44-800d-a5dc-8462c12eca3b\">https://chatgpt.com/share/670ce7db-8a44-800d-a5dc-8462c12eca3b</a><br>\nSo here is an opportunity for input from AI.</p>",
        "id": 476734739,
        "sender_full_name": "Fan Zheng",
        "timestamp": 1728899163
    },
    {
        "content": "<p><del>This is 404 for me</del>(needs login)</p>",
        "id": 476737827,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728899952
    },
    {
        "content": "<p>As <span class=\"user-mention\" data-user-id=\"751429\">@lyphyser</span> says, the two equations as given by Daniel aren't confluent: the term x((tt)z) with t = (yy)w has two reductions, and produces the equation x((ty)z) = xy, both sides of which are fully reduced under the two proposed rewrite rules. (I abbreviate t just for ease of transcription!)</p>",
        "id": 476743753,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1728901528
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> After putting back t you get x((((yy)w)y)z)=xy, which is the next one in the infinite sequence.</p>",
        "id": 476752502,
        "sender_full_name": "Fan Zheng",
        "timestamp": 1728903886
    },
    {
        "content": "<p>Indeed, using a third equation not included in Daniel's two :)</p>",
        "id": 476758249,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1728905535
    },
    {
        "content": "<p>Just to confirm (for the purposes of reporting in my daily personal log), does this ChatGPT-inspired infinite sequence of rewriting rules establish that 1659 is confluent?</p>",
        "id": 476816076,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728921549
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"751429\">lyphyser</span> <a href=\"#narrow/stream/458659-Equational/topic/Equation.202126/near/476545267\">said</a>:</p>\n<blockquote>\n<p>maybe adding the infinite rule scheme X(YY(?Y)*?) -&gt; XY would work?</p>\n</blockquote>\n<p>Isn't that what lyphyser suggested here?</p>",
        "id": 476817616,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728922128
    },
    {
        "content": "<p>The correct statement is: the rules x=xyy, xy=x(yyz), xy=x(yyzyw) (multiplication is from left to right), ... together form a confluent set. To be fair I wouldn't say it is GPT inspired, because the pattern is easily recognizable to the human eye. I am just trying to see if ChatGPT can figure out the pattern, and it can.</p>",
        "id": 476836287,
        "sender_full_name": "Fan Zheng",
        "timestamp": 1728931207
    },
    {
        "content": "<p>Even if this particular example is also visible to the human eye, knowing about the ChatGPT option is valuable, because it could potentially scale up better than human inspection.  (Though at this stage we are down to a few dozen unresolved equations, so for this project at least we might be able to do the remaining confluence analysis just by hand.)</p>",
        "id": 476836508,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728931352
    },
    {
        "content": "<p>Initially I misread Tao's question as whether ChatGPT can prove that the set is confluent. I tried it,  and the response degraded to AI-style gibberish (it says that they are not confluent without giving any new critical pair.) That said, I'm not on any fancy plan, so do not have access to the strongest LLM.</p>",
        "id": 476837151,
        "sender_full_name": "Fan Zheng",
        "timestamp": 1728931752
    },
    {
        "content": "<p>Here is the text version:</p>\n<h1>Equation Pattern Prediction</h1>\n<p>Here is a sequence of equations: xy=x((yy)z) xy=x((((yy)z)y)w) xy=x((((((yy)z)y)w)y)u) Can you find the pattern? Can you predict the next ones in the series?</p>\n<p>ChatGPT</p>\n<p>Yes! Let's examine the sequence of equations to identify a pattern.</p>\n<ol>\n<li>\n<p><strong>First equation</strong>:</p>\n<p>xy=x((yy)z)</p>\n<ul>\n<li>On the right-hand side, we have a composition where (yy) is computed first, then multiplied by z, and finally everything is multiplied by x.</li>\n</ul>\n</li>\n<li>\n<p><strong>Second equation</strong>:</p>\n<p>xy=x((((yy)z)y)w)</p>\n<ul>\n<li>Here, the nested part inside the parentheses grows. After computing ((yy)z), it is multiplied by y, and then by w.</li>\n</ul>\n</li>\n<li>\n<p><strong>Third equation</strong>:</p>\n<p>xy=x((((((yy)z)y)w)y)u)</p>\n<ul>\n<li>The nested part gets even larger: after computing ((((yy)z)y)w), it is multiplied by y and then by u.</li>\n</ul>\n</li>\n</ol>\n<h3>General pattern:</h3>\n<ul>\n<li>The right-hand side of the equation contains a progressively deeper sequence of nested expressions.</li>\n<li>Each expression starts with (yy)z, then subsequent levels are multiplied by y, and at the end, a new variable is introduced at each step (first w, then u).</li>\n</ul>\n<h3>Predicting the next ones:</h3>\n<ol start=\"4\">\n<li>\n<p><strong>Fourth equation</strong>:<br>\n  The next equation would continue this pattern by adding another nested multiplication with y and introducing a new variable (say v).</p>\n<p>xy=x((((((((yy)z)y)w)y)u)y)v)</p>\n</li>\n<li>\n<p><strong>Fifth equation</strong>:<br>\n  The next one adds yet another layer and a new variable (say t).</p>\n<p>xy=x((((((((((yy)z)y)w)y)u)y)v)y)t)</p>\n</li>\n</ol>\n<h3>Conclusion:</h3>\n<p>The general structure involves nesting an expression that multiplies (yy)z by y, with a new variable introduced in each step. Each subsequent equation deepens the level of nesting and multiplies by y one more time.</p>",
        "id": 476837562,
        "sender_full_name": "Fan Zheng",
        "timestamp": 1728931953
    },
    {
        "content": "<p>Thanks!  Without integration with a formal proof assistant, using an LLM to actually prove anything beyond an undergraduate or early graduate homework assignment is still too unreliable to use, but this use case (to detect possible patterns that one could then check externally) could be a more promising workflow.</p>",
        "id": 476839860,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728933076
    },
    {
        "content": "<p>Does it have to that reliable? How about agents that would break the tasks down (CoT), and then try them out (esp. O1, when available, with RL instead of RLHF) until there're no goals left (and Lean marks the result with qed)? </p>\n<p>One would just be leaving an agent \"running all night\".</p>\n<p>Also, I have one algorithm idea that could be used in agents. It's a bit like collaborative filtering. One would give the LLM a task together with all the proofs related to that task in the context, and ask it to create a result that follows not only the task, but the task + the context.</p>",
        "id": 476841738,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1728934124
    },
    {
        "content": "<p>I think Terence Is talking about the final proof</p>",
        "id": 476849150,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728938254
    },
    {
        "content": "<p>Lean is basically the tutor in the feedback loop</p>",
        "id": 476849178,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728938273
    },
    {
        "content": "<p>Ran this prompt </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Here</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">sequence</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">equations</span><span class=\"o\">:</span>\n\n<span class=\"n\">xy</span><span class=\"bp\">=</span><span class=\"n\">x</span><span class=\"o\">((</span><span class=\"n\">yy</span><span class=\"o\">)</span><span class=\"n\">z</span><span class=\"o\">)</span>\n<span class=\"n\">xy</span><span class=\"bp\">=</span><span class=\"n\">x</span><span class=\"o\">((((</span><span class=\"n\">yy</span><span class=\"o\">)</span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"n\">xy</span><span class=\"bp\">=</span><span class=\"n\">x</span><span class=\"o\">((((((</span><span class=\"n\">yy</span><span class=\"o\">)</span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"n\">Can</span><span class=\"w\"> </span><span class=\"n\">these</span><span class=\"w\"> </span><span class=\"n\">form</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">confluent</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">terminating</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">equations?</span><span class=\"w\"> </span><span class=\"n\">If</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">adding</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">equations</span><span class=\"w\"> </span><span class=\"n\">via</span><span class=\"w\"> </span><span class=\"n\">Knuth</span><span class=\"bp\">-</span><span class=\"n\">Bendix?</span>\n</code></pre></div>\n<p>using ChatGPT o1-preview</p>\n<p><a href=\"https://chatgpt.com/share/671025cc-5c90-8013-b394-5e7738c50725\">https://chatgpt.com/share/671025cc-5c90-8013-b394-5e7738c50725</a></p>\n<p>and o1-mini</p>\n<p><a href=\"https://chatgpt.com/share/671025e2-4784-8013-bc17-31af5aa1ca07\">https://chatgpt.com/share/671025e2-4784-8013-bc17-31af5aa1ca07</a></p>\n<p>both noted a similar answer.</p>\n<blockquote>\n<p>No; as given, these equations cannot form a confluent and terminating set, and even with additional equations from Knuth-Bendix completion, the system cannot be made both confluent and terminating.</p>\n</blockquote>",
        "id": 477298109,
        "sender_full_name": "Eric Taucher",
        "timestamp": 1729111796
    },
    {
        "content": "<p>You should probably ask for the other direction, conventional way of writing rewrite rules is with the pattern left and the result right. Only we have it sometimes the other direction here because our equations tend to be written that way. Maybe then chatgpt would answer differently</p>",
        "id": 477301864,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729113377
    },
    {
        "content": "<p>Also it's saying things that are not really true:</p>\n<blockquote>\n<p>Confluence: Without termination, achieving confluence is not feasible.</p>\n</blockquote>\n<p>The rule  xy -&gt; yx is non-terminating, but confluent.</p>",
        "id": 477302086,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729113483
    },
    {
        "content": "<p>Ah, and maybe worth clarifying to chatgpt whether you consider these rewrite rules as rules on words or on the free magma.</p>",
        "id": 477302224,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729113546
    },
    {
        "content": "<p>As I am not an expert with term rewriting and much of the project is beyond my understanding, if you create the prompt I will be happy to run it with the <code>o1-mini model</code> first and then possibly the <code>o1-preview model</code>. Use of these models is extremely limited.</p>\n<p><a href=\"https://community.openai.com/t/o1-models-limits-increased-for-plus-and-team-users/947488\">https://community.openai.com/t/o1-models-limits-increased-for-plus-and-team-users/947488</a></p>\n<p>o1-mini - 50 messages per day<br>\no1-preview - 50 messages per week</p>",
        "id": 477304169,
        "sender_full_name": "Eric Taucher",
        "timestamp": 1729114395
    },
    {
        "content": "<p>Your prompt wasn't bad, I'd maybe try</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Here</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">rewriting</span><span class=\"w\"> </span><span class=\"n\">system</span><span class=\"w\"> </span><span class=\"n\">given</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">these</span><span class=\"w\"> </span><span class=\"n\">rules</span><span class=\"bp\">::</span>\n\n<span class=\"n\">x</span><span class=\"o\">((</span><span class=\"n\">yy</span><span class=\"o\">)</span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">xy</span>\n<span class=\"n\">x</span><span class=\"o\">((((</span><span class=\"n\">yy</span><span class=\"o\">)</span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">xy</span>\n<span class=\"n\">x</span><span class=\"o\">((((((</span><span class=\"n\">yy</span><span class=\"o\">)</span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">xy</span>\n\n<span class=\"n\">Is</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">rewriting</span><span class=\"w\"> </span><span class=\"n\">system</span><span class=\"w\"> </span><span class=\"n\">confluent?</span><span class=\"w\"> </span><span class=\"n\">If</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">made</span><span class=\"w\"> </span><span class=\"n\">confluent</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">adding</span><span class=\"w\"> </span><span class=\"n\">more</span><span class=\"w\"> </span><span class=\"n\">rules</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">maybe</span><span class=\"w\"> </span><span class=\"n\">via</span><span class=\"w\"> </span><span class=\"n\">Knuth</span><span class=\"bp\">-</span><span class=\"n\">Bendix?</span>\n</code></pre></div>",
        "id": 477304747,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729114648
    },
    {
        "content": "<p>Thanks for the prompt.</p>\n<p>Model: o1-mini</p>\n<p><a href=\"https://chatgpt.com/share/671032b1-db08-8013-bafe-c36e4c189e41\">https://chatgpt.com/share/671032b1-db08-8013-bafe-c36e4c189e41</a></p>\n<hr>\n<hr>\n<p>For those lacking access via the share link</p>\n<hr>\n<p>Thought process</p>\n<p>Thought for 7 seconds<br>\n<strong>Identifying the pattern</strong></p>\n<p>I’m looking at the rules of the term rewriting system (TRS). The left-hand sides involve x with nested (yy)z and other variables, possibly concatenation or a binary operation. I need to clarify the terms’ structure.<br>\n<strong>Piecing together string rules</strong></p>\n<p>I’m working through this idea of interpreting the system as a string rewriting system. It seems clear that concatenation applies and groupings are associative. Reactions to string operations highlight focusing on specific nested terms and critical pairs.<br>\n<strong>Analyzing rule patterns</strong></p>\n<p>I'm mapping out the left-hand sides of the rules, noticing they consistently involve an outer term x followed by a deeply nested application of y, z, w, and u. This leads me to consider the confluence of the term rewriting system (TRS).<br>\n<strong>Investigating overlapping rules</strong></p>\n<p>I’m noting that Confluence involves comparing left-hand sides of rules for intersections and common reductions. Examples show terms rewritten by different rules depend on nested parts.<br>\n<strong>Figuring out confluence</strong></p>\n<p>I'm mapping out the confluence of a rule system, considering associativity, termination, and unique normal forms. Distinct left-hand sides might prevent overlaps.</p>\n<hr>\n<p>The given term rewriting system (TRS) consists of the following rules:</p>\n<ol>\n<li>\\( x((yy)z) \\rightarrow xy \\)</li>\n<li>\\( x((((yy)z)y)w) \\rightarrow xy \\)</li>\n<li>\\( x((((((yy)z)y)w)y)u) \\rightarrow xy \\)</li>\n</ol>\n<h3>Analyzing Confluence</h3>\n<p><strong>Confluence</strong> in a TRS means that if a term can be rewritten in multiple ways, all those different rewriting paths eventually lead to a common term. To determine if the system is confluent, we need to examine potential overlaps and critical pairs where different rules might apply to the same term in different ways.</p>\n<ol>\n<li>\n<p><strong>Non-overlapping Rules:</strong></p>\n<ul>\n<li>Each rule in the system handles a distinct pattern with increasing nesting. For instance, the first rule deals with \\( x((yy)z) \\), the second with \\( x((((yy)z)y)w) \\), and so on.</li>\n<li>Since the left-hand sides of the rules do not overlap (i.e., no single term matches the left-hand side of more than one rule simultaneously), there are no critical pairs arising from overlapping rules.</li>\n</ul>\n</li>\n<li>\n<p><strong>Unique Normal Forms:</strong></p>\n<ul>\n<li>Each rule reduces a complex term to the simpler form \\( xy \\).</li>\n<li>Given the specific patterns, any term that matches a left-hand side of a rule will uniquely reduce to \\( xy \\), ensuring that there is only one possible normal form for each reducible term.</li>\n</ul>\n</li>\n<li>\n<p><strong>Termination:</strong></p>\n<ul>\n<li>The rules are designed to simplify terms by reducing their complexity, suggesting that the system is terminating (no infinite rewriting sequences).</li>\n</ul>\n</li>\n</ol>\n<p>Given these observations, <strong>the TRS appears to be confluent</strong> because:</p>\n<ul>\n<li>There are no overlapping rules that could lead to divergent rewriting paths.</li>\n<li>Each reducible term has a unique normal form.</li>\n<li>The system is terminating, preventing infinite rewriting sequences.</li>\n</ul>\n<h3>Making the System Confluent (If Necessary)</h3>\n<p>If, however, there are additional terms or patterns not covered by the existing rules that could lead to ambiguities or multiple normal forms, the system might not be confluent as is. In such cases, <strong>applying the Knuth-Bendix completion procedure</strong> could help:</p>\n<ul>\n<li><strong>Knuth-Bendix Completion:</strong> This algorithm attempts to extend the TRS by adding necessary rules to resolve any critical pairs, thereby ensuring confluence.</li>\n<li><strong>Adding Rules:</strong> By systematically identifying and resolving overlaps or ambiguities, additional rules can be introduced to handle more complex or previously unhandled terms.</li>\n</ul>\n<h3>Conclusion</h3>\n<p><strong>The given term rewriting system is confluent as it stands because its rules do not overlap and each reducible term has a unique normal form. However, if additional patterns or terms introduce ambiguities, the system can be made confluent by adding more rules using the Knuth-Bendix completion procedure.</strong></p>\n<p><strong>Answer:</strong>  <br>\nNo, the system as given is not confluent. However, by introducing additional rules (for example, through the Knuth-Bendix completion process), it can be extended to become confluent.</p>",
        "id": 477305414,
        "sender_full_name": "Eric Taucher",
        "timestamp": 1729114966
    }
]