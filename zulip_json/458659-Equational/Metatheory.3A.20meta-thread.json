[
    {
        "content": "<p>Given that I've been having a hard time keeping track of what's going on with metatheory tasks, I wanted to ask what the thoughts were on how to organize it; generally I have the intuition that smaller files mean fewer conflicts, with the risk that definitions are duplicated, which is already the case with <code>MagmaLaws</code>, and is at risk between the pre-order on laws and ordinary semantic entailment as exist in <code>Completeness.lean</code>.</p>\n<p>So how should we organize?</p>",
        "id": 473916197,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727749849
    },
    {
        "content": "<p>I'm hoping that the metatheory codebase is still small enough that it is relatively easy to refactor to align notation and remove duplicates after the fact.  But it's good to have a stream here to try to coordinate.</p>\n<p>There is the question of whether we want the magma code to be up to Mathlib standards for eventual porting.  One could argue that Mathlib would prefer magmas to be modeled using <code>[Mul]</code> rather than <code>[Magma]</code>...</p>",
        "id": 473943660,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727759219
    },
    {
        "content": "<p>I think a lot of issues with redundancy can be mitigated with reasonable API. For instance, while it would be nice if <code>E ≥ F</code> and <code>{E} ⊧ F</code> were definitionally equal, having a theorem saying that they were logically equivalent would be enough for our purposes.</p>",
        "id": 474053973,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727793470
    },
    {
        "content": "<p>I actually wonder if they aren't definitionally equal at the moment in PR <a href=\"https://github.com/teorth/equational_theories/issues/132\">https://github.com/teorth/equational_theories/issues/132</a>, just masked by a bunch of definitions.</p>",
        "id": 474057852,
        "sender_full_name": "Cody Roux",
        "timestamp": 1727794475
    },
    {
        "content": "<p>One could try proving the equivalence, it could potentially just be <code>rfl</code>.</p>",
        "id": 474058742,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727794710
    },
    {
        "content": "<p>If you are really interested in merging with Mathlib at some point, worth noting that currently in Mathlib the order defined by implication is the other way round</p>",
        "id": 474070492,
        "sender_full_name": "A.",
        "timestamp": 1727798114
    },
    {
        "content": "<p>Oof, this is an issue we need to discuss and get consensus on. Intuitively I view a stronger law as “larger” than a weaker one, which is how the ordering is currently structured (and how the Hasse diagrams are oriented), but on the other hand a stronger law is satisfied by a smaller set of magmas so is “smaller” than a weaker law which I guess explains the Mathlib perspective. So which option will participants prefer?</p>\n<ol>\n<li>Maintaining the current convention of stronger \\geq weaker despite incompatibility with Mathlib</li>\n<li>converting to the Mathlib convention stronger \\leq weaker and changing all existing code, documentation, and visuals (except for legacy visuals) accordingly</li>\n</ol>",
        "id": 474080306,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727801283
    },
    {
        "content": "<p>from the point of <code>Prop</code>, it makes sense though, as False is also known as bottom <code>⊥</code> while true is top <code>⊤</code>. with the ordering where <code>(. ≤ .)</code> is the same as <code>(. → .)</code>, this makes sense because indeed <code>False</code> is the bottom element of the lattice (and likewise for <code>True</code>).</p>",
        "id": 474080914,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727801463
    },
    {
        "content": "<p>For relations the motivation is that for two relations <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> on a type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>≤</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">R \\le S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> induces a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mi mathvariant=\"normal\">/</mi><mi>R</mi><mo>→</mo><mi>X</mi><mi mathvariant=\"normal\">/</mi><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">X/R \\to X/S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>. So in this sense, this is a \"covariant\" convention.</p>",
        "id": 474081635,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727801659
    },
    {
        "content": "<p>let's make a poll:</p>",
        "id": 474081858,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727801702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/458659-Equational/topic/Metatheory.3A.20meta-thread/near/474058742\">said</a>:</p>\n<blockquote>\n<p>One could try proving the equivalence, it could potentially just be <code>rfl</code>.</p>\n</blockquote>\n<p>I did prove the equivalence (it's <a href=\"https://github.com/teorth/equational_theories/pull/135/files#diff-05f566e2af56493dfceb1987c58bbac15222bf1324784aeefe27b77796db18b3R32\">implies_eq_singleton_models</a>), it seems it's not quite definitional equal, at least if I replace the <code>simp only</code> with <code>dsimp only</code> it doesn't go through. At this point there's nothing preventing us to just swap it around, make that the definition and the current definition a characterization</p>",
        "id": 474081873,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1727801704
    },
    {
        "content": "<p>/poll What should be the ordering on MagmaLaw<br>\n<code>(. → .)</code> the same as <code>(. ≤ .)</code>, like mathlib<br>\n<code>(. → .)</code> the same as <code>(. ≥ .)</code>, unlike mathlib</p>",
        "id": 474081876,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727801704
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/458659-Equational/topic/Metatheory.3A.20meta-thread/near/474080306\">said</a>:</p>\n<blockquote>\n<p>Oof, this is an issue we need to discuss and get consensus on. Intuitively I view a stronger law as “larger” than a weaker one, which is how the ordering is currently structured (and how the Hasse diagrams are oriented), but on the other hand a stronger law is satisfied by a smaller set of magmas so is “smaller” than a weaker law which I guess explains the Mathlib perspective. So which option will participants prefer?</p>\n<ol>\n<li>Maintaining the current convention of stronger \\geq weaker despite incompatibility with Mathlib</li>\n<li>converting to the Mathlib convention stronger \\leq weaker and changing all existing code, documentation, and visuals (except for legacy visuals) accordingly</li>\n</ol>\n</blockquote>\n<p>just to be sure, if we change it that, would we also change it in the blueprint and the Hasse diagrams? (I'd vote for consistency between those three over consistency with Mathlib, so my opinion depends on that)</p>",
        "id": 474082753,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1727801866
    },
    {
        "content": "<p>the hasse diagrams use arrows afaik, so i don't think this changes anything for that?</p>",
        "id": 474083211,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727801946
    },
    {
        "content": "<p>My thought is to just add a caveat to any legacy diagrams that the arrows are reversed from the new conventions, which we would enforce for diagrams going forward. The blueprint would only need to be changed in a few places (eg when referring to minimal and maximal elements) since we mostly use “implies” instead of \\geq or \\leq.</p>",
        "id": 474084126,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727802102
    },
    {
        "content": "<p>new hasse diagrams would presumably ne inverted with x=x at the top and x=y at the bottom with either downward pointing arrows or upward pointing implication symbols (not sure which is better)</p>",
        "id": 474084825,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727802260
    },
    {
        "content": "<p>/poll ASSUMING we reverse the partial ordering (so that  <code>(. → .)</code> the same as <code>(. ≤ .)</code>), how should Hasse diagrams be oriented going forward?<br>\nx=y on top, x=x on bottom, -&gt; downward arrows (current setup, incompatible with new ordering)<br>\nx=x on top, x=y on bottom, -&gt; downward arrows<br>\nx=x on top, x=y on bottom, =&gt; upward arrows<br>\nx=x on top, x=y on bottom, unoriented edges<br>\nx=y on top, x=x on bottom, -&gt; upward arrows<br>\nx=y on top, x=x on bottom, =&gt; downward arrows<br>\nx=y on top, x=x on bottom, unoriented edges</p>",
        "id": 474106070,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727809112
    },
    {
        "content": "<p>Lots of options on how to orient Hasse diagrams... would be interested in people's views</p>",
        "id": 474106218,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727809148
    },
    {
        "content": "<p>imo, so long as the edges are labeled in direction of the implication, what side is up or down doesn't matter too much to me</p>",
        "id": 474107075,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727809375
    },
    {
        "content": "<p>i wouldn't even object to sideways if that for some reason is easier to render</p>",
        "id": 474107305,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727809436
    },
    {
        "content": "<p>Based on the above polls, I have announced a refactor to reverse the ordering on laws and the recommended ordering on Hasse diagrams, see <a class=\"stream-topic\" data-stream-id=\"458659\" href=\"/#narrow/stream/458659-Equational/topic/REFACTOR.20I.3A.20Reversing.20the.20ordering.20on.20laws\">#Equational &gt; REFACTOR I: Reversing the ordering on laws</a> .  Any further discussion of ordering issues should be made at that thread.   However, this thread can continue to be used for other metatheory issues aside from ordering.</p>",
        "id": 474326748,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727882390
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111433\">@A.</span>  just pointed out that the order was the same as in mathlib already in the code (but not in the blueprint), so in <a href=\"https://github.com/teorth/equational_theories/pull/273\">equational#273</a> I messed it up (should have checked more carefully, I'm always confused by such 50-50 conventions). I've fixed this in <a href=\"https://github.com/teorth/equational_theories/pull/289\">equational#289</a>, proving the subset inclusion too for good measure</p>",
        "id": 474869605,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1728062316
    }
]