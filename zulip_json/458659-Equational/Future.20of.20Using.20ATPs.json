[
    {
        "content": "<p>The prominent use of automated theorem provers (ATPs) in this project has left me uncertain about the precise nature of how ATPs will be used in Lean in the future. With this topic I would like to collect ideas on how people think we should be using ATPs from Lean. I think there are two questions which need to be considered:</p>\n<ol>\n<li>How do we invoke the ATPs?</li>\n<li>How do we persists the results of ATPs?</li>\n</ol>\n<p>(If some of these points have already been discussed in other topics, I'd be happy to collect links to them here.)</p>\n<p>Question 1 may sound like a technicality, but I think it's quite important when considering what reasoning in Lean should look like in the future. Right now, I can think of three ways to invoke an ATP for use with Lean:</p>\n<ol>\n<li>by using a Lean tactic which calls an ATP implementation written in Lean (like <code>simp</code> or <code>ring</code>).</li>\n<li>by using a Lean tactic which calls an existing (external) ATP and reconstructs a proof term from the ATP's result (like <code>bv_decide</code> or <code>egg</code>).</li>\n<li>by using an external script which calls an existing ATP and generates a <code>.lean</code> file which captures the ATP's result.</li>\n</ol>\n<p>In the context of this project, Approach 3 seems to have been the most prominent. There have been various efforts, like using Vampire, Z3, and Egg, which constructed a large number of proofs by generating <code>.lean</code> files. While this approach may require the least amount of effort for implementation, it's arguably also the least user-friendly. I'm guessing your everyday (curious) mathematician playing with Lean would much rather call a proof tactic than some external script to run proof automation. Accordingly, there has also been an attempt at using Approach 2 by means of the <code>egg</code> tactic, which calls the Egg engine (implemented in Rust) in the background. Unfortunately, this approach necessitates the user to have a working installation of whatever software is required to call the external ATP. In the context of this project, this meant that some people were not able to build the project as long as it had <code>egg</code> as a dependency - the dependency was thus removed. Approach 1 was not used (as far as I am aware) as implementing an ATP in Lean has an extremely high initial implementation cost, as well as a high maintenance cost, as external ATPs continue to improve making it very burdensome to keep up with the state of the art. This circumstance is also reflected in the fact that Lean's very own <code>bv_decide</code> tactic depends on the external SAT solver CaDiCaL - that is, uses Approach 2. Does that mean that the <code>bv_decide</code> tactic faces the same issue as the <code>egg</code> tactic, as it requires an external dependency? No, but only because CaDiCaL now <em>ships with Lean</em>. As it is obviously not possible to ship every possible ATP with Lean, Approach 2 is currently more or less infeasible. This is unfortunate as (IMHO) Approach 2 hits the sweet spot between user-friendliness and implementation effort. </p>\n<p>One possible way out of this issue may be by addressing Question 2. I can think of three answers to this question:</p>\n<p>A. Don't persist results - that is, rerun the tactic on every recompilation (as typical with <code>simp</code> or <code>ring</code>).<br>\nB. Persist results by converting them to existing Lean tactic calls like <code>rw</code>, <code>simp</code>, and explicit proof terms with <code>exact</code>.<br>\nC. Persist results by storing them in some other format, e.g. in an external file, which a given tactic can turn into a Lean proof. </p>\n<p>In the context of this project, Approach B seems to have been the most common. The upside of Approach B is that it makes ATP usage ephemeral. For example, Approach 2 can thus be realized by introducing \"Try this\" suggestions which replace the ATP tactic call with calls to existing Lean tactics. A first downside of Approach B is that it exposes the reasoning steps of the ATP (which we might not care about) and thus introduces noise into the proof script. For example, it's probably much clearer to have a proof script contain <code>simp [...]</code>, instead of explicitly stating all of the steps which <code>simp</code> took to prove a goal. A second downside of Approach B is that ATPs can produce very long proofs. For example, the <code>egg</code> tactic sometimes produces proofs containing hundreds of rewrites which is hardly desirable for a Lean proof script. Interestingly, ATPs may still produce these long proofs very quickly. Thus I believe Approach A could be feasible (that is, not slow down compilation too much) in many cases if only it weren't for the problems of having external dependencies as outlined in the previous section. Due to these downsides of Approaches A and B, I think Approach C may currently be the most promising. There are of course still downsides to this approach. Namely, if we use Approach C with a tactic which depends on an external ATP, then we need to split that tactic into two distinct packages: one for proof generation (package <code>G</code>) and one for proof reconstruction (package <code>R</code>). Package <code>R</code> only handles proof reconstruction from results produced by tactics from <code>G</code> and does not require the external dependency. Therefore it is unproblematic as a dependency of other packages and can be kept in the proof script. Package <code>G</code> on the other hand should only be installed locally by the user trying to generate new proofs, as this will depend on an external ATP. The proof tactic of package <code>G</code> should then always be ephemeral by providing a \"Try this\" which delegates to the proof reconstruction of package <code>R</code> with the ATP's result being stored somewhere else (e.g. in a separate file). This two part approach may also be simplified by not introducing a proof reconstruction package (<code>R</code>) for <em>each</em> new tactic, but instead trying to find an intermediate proof format which works for many kinds of proofs and having a more general proof reconstruction package which can be used for mutliple tactics. (The obvious format would be terms of <code>Lean.Expr</code>, but those terms might get very large.) </p>\n<p>In conclusion, my take away is that Approach 2 + Approach C are the most promising, and it might be worth investigating proof persistence techniques. But I'm interested to hear if there are any other ideas floating around.</p>",
        "id": 475298037,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1728307836
    },
    {
        "content": "<p>How about deeply embedding the ATPs internal representation in lean instead of translating Lean Exprs. We discussed this on day 1 or 2, but I think we lose a lot of the ability to exploit meta theorems when we don't have the correct syntactic representation of a domain within lean.</p>",
        "id": 475298724,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728308025
    },
    {
        "content": "<p>We also lose the ability to use this structure for tooling within lean.</p>",
        "id": 475298827,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728308051
    },
    {
        "content": "<blockquote>\n<p>This circumstance is also reflected in the fact that Lean's very own <code>bv_decide</code> tactic depends on the external SAT solver CaDiCaL - that is, uses Approach 2.</p>\n</blockquote>\n<p>Note that bv_decide implements a lot of things besides calling the SAT solver. It is in essence an attempt to reimplement the currently leading SMT solver for bit vector theory, Bitwuzla, in Lean. There is the bitblasting, the rewriting engine etc. involved, all of which are not part of the external solver. So doing this in Lean is feasible even if hard.</p>\n<blockquote>\n<p>No, but only because CaDiCaL now <em>ships with Lean</em>. As it is obviously not possible to ship every possible ATP with Lean</p>\n</blockquote>\n<p>Oh but it totally is <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> Isabelle ships at least half a dozen ATPs in its installation for example.</p>\n<blockquote>\n<p>B. Persist results by converting them to existing Lean tactic calls like <code>rw</code>, <code>simp</code>, and explicit proof terms with <code>exact</code>.</p>\n</blockquote>\n<p>This is actually impossible if your proof relies on something like <code>ofReduceBool</code> which is the case for <code>bv_decide</code>.</p>\n<blockquote>\n<p>C. Persist results by storing them in some other format, e.g. in an external file, which a given tactic can turn into a Lean proof.</p>\n</blockquote>\n<p>This is the current approach of <code>bv_decide</code>. In general systems that rely on verifying external proof certificates with native code probably need to do this to cache results.</p>",
        "id": 475310362,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1728311189
    },
    {
        "content": "<p>Regarding Approach B, have you seen the format used for the Vampire-produced proofs (<a href=\"https://github.com/teorth/equational_theories/blob/main/equational_theories/Generated/VampireProven/Proofs1.lean\">https://github.com/teorth/equational_theories/blob/main/equational_theories/Generated/VampireProven/Proofs1.lean</a>, for example)? I wrote a term elaborator (<code>superpose</code>) which applies the reasoning steps of Vampire, and then most proofs could be represented reasonably concisely.</p>\n<p>Regarding Approach 3, I think the main reason that it was so prominent in this project is that it's very fast-paced, which doesn't necessarily lead to user-friendly development.</p>\n<p>By the way, do you know of <code>polyrith</code>? It's a tactic that invokes SAGE via a web API and then replaces itself by a <code>linear_combination</code> application, this might be a cheaper way to do Approach 2</p>",
        "id": 475311511,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728311510
    },
    {
        "content": "<p>As additional datapoints, think of <code>aesop</code> and <code>simp?</code>:</p>\n<ul>\n<li>Most uses of <code>aesop</code> are ephemeral, and it works by persisting with converting to existing lean tactics (approach B), even though it falls under category 1 (it is written in Lean). So I think the two questions are a bit orthogonal.</li>\n<li>When you call <code>simp?</code> it doesn't give you a proof term or a set of <code>rw</code>s, it gives you a <code>simp only</code> set, which also hits a sweet-spot between being simple to compute (minimal) but still a small (readable) proof script and somewhat resilient to changes.</li>\n</ul>\n<p>I could see a world where we combine approaches 1. and 2., and for example calls to <code>egg?</code> are encoded with something like <code>calc + cc</code> (and some pruning), or even a lean-only implementation of <code>egg</code> which might be less performant but good enough to rerun the <code>egg only</code> call.</p>",
        "id": 475311515,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1728311512
    },
    {
        "content": "<p>Also regarding approach B and <code>egg</code>: The <code>calcify</code> tool can be used to turn the egg proofs into (relatively) pretty equational proofs.</p>",
        "id": 475314957,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1728312514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/458659-Equational/topic/Future.20of.20Using.20ATPs/near/475314957\">said</a>:</p>\n<blockquote>\n<p>Also regarding approach B and <code>egg</code>: The <code>calcify</code> tool can be used to turn the egg proofs into (relatively) pretty equational proofs.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"372804\">@Marcus Rossel</span> also <a href=\"https://github.com/marcusrossel/lean-egg/commit/46bee894f2325a195f8636b7360256d2fdf3264b\">built this interaction into an ergonomical <code>egg?</code> tactic</a> <span aria-label=\"octopus\" class=\"emoji emoji-1f419\" role=\"img\" title=\"octopus\">:octopus:</span></p>",
        "id": 475319042,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1728313591
    },
    {
        "content": "<p>Just wanted to say that this is an excellent discussion and we should certainly talk about this issue in the paper; I added a brief mention of it to the <a href=\"https://github.com/teorth/equational_theories/wiki/Plan-of-paper\">paper plan</a> (in the \"automated theorem proving\" section).</p>\n<p>One can imagine a table in the paper giving some real-world examples in Lean (or in other proof asssistant languages) of approaches 1, 2, 3, drawing on many of the examples listed above.</p>",
        "id": 475321932,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728314428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andrés Goens</span> <a href=\"#narrow/stream/458659-Equational/topic/Future.20of.20Using.20ATPs/near/475319042\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/458659-Equational/topic/Future.20of.20Using.20ATPs/near/475314957\">said</a>:</p>\n<blockquote>\n<p>Also regarding approach B and <code>egg</code>: The <code>calcify</code> tool can be used to turn the egg proofs into (relatively) pretty equational proofs.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"372804\">Marcus Rossel</span> also <a href=\"https://github.com/marcusrossel/lean-egg/commit/46bee894f2325a195f8636b7360256d2fdf3264b\">built this interaction into an ergonomical <code>egg?</code> tactic</a> <span aria-label=\"octopus\" class=\"emoji emoji-1f419\" role=\"img\" title=\"octopus\">:octopus:</span></p>\n</blockquote>\n<p>I didn't know! Now I have to make sure I don't break the code too easily.</p>",
        "id": 475329725,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1728316123
    },
    {
        "content": "<p>I like the combination of Approach 2 (external ATPs, lower maintenance cost; more people could use it and create libraries), and C (own format, like we have in ML; we’d be able to decouple proof generation from proof checking as well as avoid cluttering the proof scripts).</p>\n<p>Approach 2 reminds me of JS/TS/Python flexibility. C is commonly used in ML (involves serialization, artifact storage, versioning, and deployment). </p>\n<p>I would also consider the following (perhaps some of them are not possible at the moment):</p>\n<ul>\n<li>Lineage (also common in ML; being able to follow the full history),</li>\n<li>ATPs as APIs (can we get to real-time insights?),</li>\n<li>Agents (Perhaps a Cursor plugin? Or an additional functionality in vscode-lean4?)</li>\n<li>New UX (Via shortcuts - „quick complete“, „full complete“, etc.),</li>\n<li>Generative (Like CTRL+K in Cursor when the file is empty),</li>\n<li>Proof as JSON (That would enable us to potentially integrate certain logic in software), re-using the open formats (or creating a new format); using plugins / modules,</li>\n<li>Background bots for curriculum learning (for instance, higher-order tactic dev),</li>\n<li>One storage for all math (global, open etc.; like github+HuggingFace, but for math),</li>\n<li>Using Lean’s FFI to write a couple of community building programs that profit from Lean (one idea that comes to mind is (eventually) 3k+1-related flow control logic for hardware and software).</li>\n</ul>",
        "id": 476859613,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1728945130
    }
]