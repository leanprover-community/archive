[
    {
        "content": "<p>Here is a thought for how to speed up type checking of proofs that a certain finite magma satisfies or doesn't satisfy an equation. In <a href=\"https://github.com/teorth/equational_theories/pull/19\">https://github.com/teorth/equational_theories/pull/19</a> the magma operation is given as a polynomial, and in another topic I saw tables. Now calculating that polynomial at every evaluation of the operator is a bit wasteful. A table sounds better, and certainly the proof could first construct the full table from the polynomial, and then work with that.</p>\n<p>But the kernel doesn’t support (effiicent) arrays, and lists are wasteful again. So my idea, which I’ll try now, is to encode the full table in one big number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span>. First I flatten the table as a list $$t_i$ of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> entries (with index <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>⋅</mo><mi>n</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">i = (a-1)\\cdot n + b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> to look up <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>∘</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a \\circ b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> ), and then encode that in a single large <code>Nat</code> as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>t</mi><mi>i</mi></msub><mo>∗</mo><msup><mi>n</mi><mi>i</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\sum_i t_i*n^i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.162em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span></span></span></span></span></span></span></span>. Reading off that number is a matter of one division and one modulo operation.  Since all these operations work in the type checker using native operations, this might be noticably faster.</p>\n<p>(Maybe this is all going to be futile because the kernel’s caching mechanism already has a similar effect; we’ll see.)</p>",
        "id": 473217469,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1727473414
    },
    {
        "content": "<p>Not sure if it is going to help a lot, but it was a nice exercise: <a href=\"https://github.com/teorth/equational_theories/blob/937546f1d3acf0cd92b891162a6fb43369accfb9/equational_theories/MemoFinOp.lean\">https://github.com/teorth/equational_theories/blob/937546f1d3acf0cd92b891162a6fb43369accfb9/equational_theories/MemoFinOp.lean</a></p>",
        "id": 473247307,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1727477307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/458659-Equational/topic/Memoizing.20finite.20magmas.20for.20kernel-friendly.20reduction/near/473217469\">said</a>:</p>\n<blockquote>\n<p>But the kernel doesn’t support (effiicent) arrays, and lists are wasteful again.</p>\n</blockquote>\n<p>How about a tree data structure like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.PersistentArray#doc\">docs#Lean.PersistentArray</a> ?</p>",
        "id": 473270845,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1727491606
    },
    {
        "content": "<p>I think the magmas involved are small enough that a tree won't be noticeably better</p>",
        "id": 473270927,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727491645
    },
    {
        "content": "<p>I wonder if the table could be encoded using CHT, so only a single modulo is needed</p>",
        "id": 473271121,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727491705
    },
    {
        "content": "<p>CHT?</p>",
        "id": 473299214,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1727506728
    },
    {
        "content": "<p>Sorry, CRT (Chinese remainder theorem)</p>",
        "id": 473299240,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727506746
    },
    {
        "content": "<p>How would that work? If i first have to find the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> th prime number to make a lookup I have not gained much :-) So I may be thinking of the wrong thing.</p>",
        "id": 473299785,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1727507032
    },
    {
        "content": "<p>It doesn't have to be primes, you can also use e.g. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2520</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2520 i + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2520</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></p>",
        "id": 473300351,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727507270
    },
    {
        "content": "<p>Actually I think it would be best to encode it in base <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mo stretchy=\"false\">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">⌉</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">2^{\\lceil \\log_2(n) \\rceil}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.888em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">⌈</span><span class=\"mop mtight\"><span class=\"mop mtight\"><span class=\"mtight\">l</span><span class=\"mtight\">o</span><span class=\"mtight\" style=\"margin-right:0.01389em;\">g</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span style=\"top:-2.2341em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2659em;\"><span></span></span></span></span></span></span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)⌉</span></span></span></span></span></span></span></span></span></span></span></span> and then use shifting and bitwise and to find the data</p>",
        "id": 473300911,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727507476
    },
    {
        "content": "<p>I was thinking the same (shifting). In the next version. Its probably not the bottleneck anyways <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 473303643,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1727508396
    },
    {
        "content": "<p>By the way there were some specific finite magmas in <a href=\"https://mathoverflow.net/a/450987/766\">this MathOverflow answer</a> that might be particularly useful to establish anti-implications. But perhaps just brute forcing over all small magmas is already fast enough.</p>",
        "id": 473351869,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727532518
    },
    {
        "content": "<p>There may already be a list of all small magmas up to equivalence somewhere on the internet EDIT: <a href=\"https://oeis.org/A001329\">https://oeis.org/A001329</a> is a starting point</p>",
        "id": 473352023,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727532625
    },
    {
        "content": "<p>We can see if Nicholas’ project (<a href=\"https://github.com/teorth/equational_theories/pull/19\">equational#19</a>) covers these anti-implications. But if not we can of of course use the same lean representation to throw in more magmas.</p>",
        "id": 473352028,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1727532632
    },
    {
        "content": "<p>Oof.  According to the OEIS there are already 2483527537094825 non-isomorphic magmas of order 5.  So yeah maybe some targeted finite magmas would be a better approach than brute-forcing over all</p>",
        "id": 473352247,
        "sender_full_name": "Terence Tao",
        "timestamp": 1727532786
    },
    {
        "content": "<p>I've brute forced all finite magmas up to order 4 and it did not contribute many more counterexamples than searching random polynomials did.</p>",
        "id": 473353120,
        "sender_full_name": "Nicholas Carlini",
        "timestamp": 1727533394
    },
    {
        "content": "<p>(Or, I think I did. I enumerated all 4^(4*4) tables and checked each of these across every equation. Is that a full brute force?)</p>",
        "id": 473353211,
        "sender_full_name": "Nicholas Carlini",
        "timestamp": 1727533444
    },
    {
        "content": "<p>if we're lucky, the smallest number of counterexamples needed is the lenght of the maximum chain in the implication graph (excluding equivalent equations)... i wonder how close to that we can get!</p>",
        "id": 473353612,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727533670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"761294\">Nicholas Carlini</span> <a href=\"#narrow/stream/458659-Equational/topic/Memoizing.20finite.20magmas.20for.20kernel-friendly.20reduction/near/473353211\">said</a>:</p>\n<blockquote>\n<p>(Or, I think I did. I enumerated all 4^(4*4) tables and checked each of these across every equation. Is that a full brute force?)</p>\n</blockquote>\n<p>Very brute indeed!</p>",
        "id": 473354941,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1727534632
    },
    {
        "content": "<p>I guess what I meant was: I don't think this skips over anything, but I don't think it did</p>",
        "id": 473355134,
        "sender_full_name": "Nicholas Carlini",
        "timestamp": 1727534744
    }
]