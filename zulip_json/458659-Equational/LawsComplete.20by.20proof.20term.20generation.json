[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> I converted your algorithm to a hybrid proof term generation and refl proof, and it is way faster and cheaper now: <a href=\"https://github.com/teorth/equational_theories/pull/784\">equational#784</a> . In particular this does the proof without any dependency on <code>native_decide</code>.</p>",
        "id": 480274763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730606263
    },
    {
        "content": "<p>Nice work! I assume a large part of the speedup is that now the <code>findMagmaLaw</code> search happens at elaboration time, and the proof term contains that result already. That’s a notable benefit of term generation over proof by reflection – it’s easier to include such “certificates” in the middle of the computation.</p>",
        "id": 480295710,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1730628742
    },
    {
        "content": "<p>This is the part that’s still by refl:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">laws</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">l'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">l'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:)</span>\n</code></pre></div>\n<p>did you benchmark if this was slower than a proof object that shows that <code>$l;</code> is in <code>laws</code>, or was it fast enough and you didn’t bother?</p>",
        "id": 480295853,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1730628958
    },
    {
        "content": "<p>the latter</p>",
        "id": 480295896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730628970
    },
    {
        "content": "<p>In the two examples where I saw you apply this method, you proved custom lemmas like <code>TestLawsBody.mk3</code> or <code>TestFreeMagmas.succ</code> to build the proof terms from.</p>\n<p>Squinting enough, these seem to be a bit similar to the equational lemmas for the functions. So I wonder if one could achieve something similar, with much less manual effort, by using the simplifier (or a variant of it, “simp_cbv” or so, that is only rewriting in an evaluation context) to perform the calculation at elaboration time and produce a suitable proof term.</p>\n<p>Would this yield similar performance characteristics (both at elab time and kernel checking time), or is that inherently worse? (Ignoring the “elab-time <code>findMagmaLaw</code> trick for now, although that could probably be done as well, using a <code>simproc</code> or rewrite rules with auto-param or so.)</p>",
        "id": 480296136,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1730629256
    },
    {
        "content": "<p>Also, you write</p>\n<blockquote>\n<p><code>#time</code> says it takes 7 seconds, but because it is checked twice as written (once in the kernel and once in the elaborator)</p>\n</blockquote>\n<p>where is the proof checked in the elaborator in your code? Is there an unnecessary <code>Meta.check</code> in <code>by_elab</code> or in the qq library?</p>",
        "id": 480296520,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1730629638
    },
    {
        "content": "<p>I'm not sure exactly where, my general impression is that this happens in any tactic so it must be the tactic / MetaM infrastructure</p>",
        "id": 480296587,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730629700
    },
    {
        "content": "<p>I'm sure it's not in qq</p>",
        "id": 480296606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730629738
    },
    {
        "content": "<p>Hmm, don’t think it’s general – the <code>decideFin!</code> tactic that I added in the repo does not go through any hoops to avoid the meta-time check. <code>by_elab</code> also looks fine.</p>",
        "id": 480296619,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1730629749
    },
    {
        "content": "<p>maybe you could try doing some tests on artificial versions of the example</p>",
        "id": 480296696,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730629825
    },
    {
        "content": "<p>I’ll have a look</p>",
        "id": 480296700,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1730629834
    },
    {
        "content": "<p>With <code>set_option debug.skipKernelTC true</code> I can change parts of the proof to bogus values and nothing complains. Looks like the meta-program simply takes its time, but nothing is actually done twice?</p>",
        "id": 480296935,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1730630063
    },
    {
        "content": "<p>my experience is that with that option on it takes 3 seconds instead of 6</p>",
        "id": 480296973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730630131
    },
    {
        "content": "<p>Right – but that could simply mean that the elab code and the kernel checking roughly take the same time; it doesn't necessarily mean that any work is duplicated. (And at least so far I don’t see evidence for that, so all good!)</p>",
        "id": 480297051,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1730630179
    },
    {
        "content": "<p>Will it be easy to convert this to also generate a list of laws? That would be useful for proving e.g. the counting lemmas. (In my attempt before I ran into issues with polymorphic induction)</p>",
        "id": 480299909,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1730633036
    },
    {
        "content": "<p>The code already produces such a list (or rather, it assembles the list that already exists in the equations files)</p>",
        "id": 480300183,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730633271
    },
    {
        "content": "<p>I'm thinking of making the \"canonical\" criterion a bit less precise:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">Checks whether a magma law is canonical:</span>\n<span class=\"sd\">* Variables are canonically labeled</span>\n<span class=\"sd\">* `lhs &lt; rhs` (with the exception of `0 ≃ 0`)</span>\n<span class=\"sd\">* The symmetric law did not come first</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"bp\">.</span><span class=\"n\">MagmaLaw</span><span class=\"bp\">.</span><span class=\"n\">IsCanonical</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Law</span><span class=\"bp\">.</span><span class=\"n\">MagmaLaw</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">IsCanonicalLabel</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">lhs</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Leaf</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">  </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">canonicalize</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">lt</span>\n</code></pre></div>\n<p>The problem with this criterion is that it's not obvious that either the original or the flipped version of the equation can be made canonical by relabeling, because both the second and third conditions are changed by flipping. Empirically I have observed though that it is impossible to have <code>l.symm.canonicalize &gt; l</code> and yet <code>l.lhs &gt; l.rhs</code>, but my attempts to prove it have failed because canonicalization is a complicated operation with nontrivial effects on the ordering. I can sidestep this issue by just not using this shortcut and considering both <code>l.lhs &lt; l.rhs</code> and <code>l.lhs &gt; l.rhs</code> cases, using only the canonicalization ordering to prune them. Doing this increases the runtime of the check from 7 seconds to 16 seconds.</p>",
        "id": 480300787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730633856
    },
    {
        "content": "<p>Actually even this isn't enough, because if <code>l.symm.canonicalize = l</code> then we still don't know that <code>l</code> is of the form <code>w = w</code>. In fact this can happen: <code>x * y = x * z</code> is equal to its own symmetric version, but it is not of the form <code>w = w</code>.</p>",
        "id": 480302943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730636023
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/LawsComplete.20by.20proof.20term.20generation/near/480300183\">said</a>:</p>\n<blockquote>\n<p>The code already produces such a list (or rather, it assembles the list that already exists in the equations files)</p>\n</blockquote>\n<p>My thought was to generate the list and not base it on the files. If there was code that returned a List or a Finset or an iterator, we could prove theorems about the set of equations (for example, its size) without running it.</p>",
        "id": 480305759,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1730638831
    },
    {
        "content": "<p>The way <code>FreeMagma.comp</code> is written looks a bit strange to me. IMO the natural thing is to have a function <code>FreeMagma α → FreeMagma Unit × List α</code>, and compare by lexicographic order on that. Then you're guaranteed that laws with smaller RHS shape are never canonical, and laws with smaller LHS shape are always canonical.</p>\n<p>[EDIT: assuming the variables at the leaves are in canonical order]</p>",
        "id": 480306243,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1730639320
    },
    {
        "content": "<p>(I've a branch where I used <code>Tree Unit</code> for the shape, since the <code>Enumerative.Catalan</code> module counts that natively, but <code>FreeMagma Unit</code> is equivalent)</p>",
        "id": 480306391,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1730639445
    },
    {
        "content": "<p>Yes, that is in the LawsComplete file. It is a prerequisite to stating the theorem that all laws up to a certain size are in \"the list\", we need \"the list\" to say this</p>",
        "id": 480307492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730640516
    },
    {
        "content": "<p>Re: <code>FreeMagma.comp</code>, I think it's equivalent to what you said?</p>",
        "id": 480307598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730640625
    },
    {
        "content": "<p>the \"shape\" comparison happens inside <code>Law.MagmaLaw.comp</code></p>",
        "id": 480307637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730640675
    },
    {
        "content": "<p>It's equivalent, but this formulation could make it easier to prove that <code>l.symm.canonicalize &gt; l</code> is incompatible with <code>l.lhs &gt; l.rhs</code></p>",
        "id": 480307745,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1730640736
    },
    {
        "content": "<p>can you elaborate?</p>",
        "id": 480307765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730640769
    },
    {
        "content": "<p>Let's suppose it's defined like that</p>",
        "id": 480307767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730640775
    },
    {
        "content": "<p>how does it help?</p>",
        "id": 480307776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730640786
    },
    {
        "content": "<p>I tried to prove that <code>fun l =&gt; l.map f</code> is a monotone function if <code>f</code> is, but it doesn't seem to be true</p>",
        "id": 480307920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730640935
    },
    {
        "content": "<p>If <code>l.symm.canonicalize &gt; l</code>, it is either because <code>l.rhs.forks &gt; l.lhs.forks</code>, or they're equal <code>l.rhs.shape &gt; l.lhs.shape</code>, or they're equal and <code>l.rhs.leaves &gt; l.lhs.leaves</code>. In the first case obviously <code>l.rhs &gt; l.lhs</code>, and the other two cases are exactly phrasing the comparison as lex order on (shape, leaves).</p>",
        "id": 480307940,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1730640960
    },
    {
        "content": "<p>oh but <code>l.lhs &gt; l.rhs</code> is using this mixed comparison</p>",
        "id": 480307997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730641001
    },
    {
        "content": "<p>it's not shape-then-leaves</p>",
        "id": 480308007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730641016
    },
    {
        "content": "<p>perhaps that was a mistake</p>",
        "id": 480308015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730641027
    },
    {
        "content": "<p>I can't think of an example where the order as implemented in <code>FreeMagma.comp</code> contradicts this, since we first compare the number of forks</p>",
        "id": 480308111,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1730641113
    },
    {
        "content": "<p>is that correct? Doing forks comparison at every node</p>",
        "id": 480308294,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730641312
    },
    {
        "content": "<p>Oh I see, so it would have <code>((x * x) * x) * (x * x) &lt; (x * (x * (x * x))) * x</code>, which is not the same as the order on shapes</p>",
        "id": 480308513,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1730641520
    },
    {
        "content": "<p>(that would mean that once we reach high enough order the set of laws will differ; so really not the same theorem)</p>",
        "id": 480309252,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1730642207
    },
    {
        "content": "<p>wait, so which is correct?</p>",
        "id": 480309604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730642507
    },
    {
        "content": "<p>correct meaning whatever was implemented in the original enumeration</p>",
        "id": 480309666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730642530
    },
    {
        "content": "<p>I managed to confuse myself. There is only one order on shapes implemented anywhere. (I imagined another one before but it's complicated and not used)</p>\n<p>The order on terms is different, in the generating scripts it's based strictly on tree shapes then leaves.</p>",
        "id": 480312814,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1730645416
    },
    {
        "content": "<p>For instance <code>y(x(xx)) &lt; x((xx)x)</code></p>",
        "id": 480312877,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1730645488
    },
    {
        "content": "<p>when are forks comparisons involved?</p>",
        "id": 480317510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730649586
    },
    {
        "content": "<p>is it just once at the top level, once for each side of the equation or once at every node?</p>",
        "id": 480317575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730649613
    },
    {
        "content": "<p>The (original) generation code doesn't have a comparison function, but there's an implicit order based on what is generated first. Then it checks all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo>⋅</mo><mi>n</mi><mo stretchy=\"false\">!</mo></mrow><annotation encoding=\"application/x-tex\"> 2 \\cdot n! </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span></span></span></span> permutations of variables and orders to eliminate equivalents. (We played around with the order a bit in the first day, so it was useful to have exhaustive equivalence check)</p>\n<p>Equations are enumerated by: total order, lhs order, lhs shape, rhs shape, lex order on the leaves.<br>\nEnumeration of shapes is by left fork order, left shape, right shape. The implied order is exactly <code>FreeMagma.comp</code> on <code>FreeMagma Unit</code>.</p>",
        "id": 480319202,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1730650923
    },
    {
        "content": "<p>A more efficient implementation of the same ordering appears in the newer script <br>\n<a href=\"https://github.com/teorth/equational_theories/blob/main/scripts/find_equation_id.py#L186\">find_equation_id.py</a>, this script also represents an equation as (shape, shape, leaves) which was more efficient than separating to lhs and rhs expressions.</p>",
        "id": 480319412,
        "sender_full_name": "Amir Livne Bar-on",
        "timestamp": 1730651086
    },
    {
        "content": "<p>Success! <a href=\"https://github.com/teorth/equational_theories/pull/789\">equational#789</a> proves the completeness of the generation code, including the analysis of the canonicalization function and using the original ordering. <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 480332397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730662323
    },
    {
        "content": "<p>Very nice! Glad I didn't give this a more serious attempt, I wouldn't have managed within reasonable time.</p>\n<p>I'd say that's the proper theorem, I think the prime should go on the other one (or some other name)</p>",
        "id": 480343567,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1730673119
    },
    {
        "content": "<p><a href=\"https://github.com/teorth/equational_theories/pull/789\">equational#789</a></p>",
        "id": 480496724,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1730742739
    }
]