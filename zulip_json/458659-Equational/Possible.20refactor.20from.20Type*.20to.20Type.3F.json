[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"690858\">@Daniel Weber</span> is reporting some issues with converting between laws and equations at <a href=\"https://github.com/teorth/equational_theories/pull/147\">equational#147</a> due to the inability to define <code>G ⊨ law</code> if <code>G</code> is <code>Type*</code> rather than <code>Type</code>.  I had thought that <a href=\"https://github.com/teorth/equational_theories/pull/186\">equational#186</a> would fix the issue, but apparently this is insufficient.   (Edit: and now <span class=\"user-mention\" data-user-id=\"116028\">@Cody Roux</span>  has thrown in the towel on <a href=\"https://github.com/teorth/equational_theories/pull/186\">equational#186</a>, so maybe unrestricted universes are not the way to go here.)</p>\n<p>I am not well versed in the finer subtleties of Lean's type theory, so I am not sure how serious this issue is.  One possible way out is to refactor the <em>entire</em> project to only consider Magmas in <code>Type</code> rather than in <code>Type*</code>.  This could potentially lead to a slight loss of expressivity in our results, but perhaps some version of <a href=\"https://github.com/teorth/equational_theories/pull/168\">equational#168</a> is still possible that would recover that.  But now that we have a large amount of both human-generated and computer-generated Lean code, this could be a non-trivial refactor.</p>\n<p>I am not sure how to proceed here.  Any thoughts would be appreciated.</p>",
        "id": 475003683,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728151922
    },
    {
        "content": "<p>I can give it another shot, my tentative feeling is that either <em>everything</em> should be <code>Type* + Prop</code> or everything should be <code>Type</code>;  the \"half and half\" seems to require some subtle casts which I do not know how to express (I know nothing of polymorphism in Lean).</p>\n<p>I can try to do the former.</p>",
        "id": 475008623,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728154692
    },
    {
        "content": "<p>I also agree with the former, except for non implications, which I think should be <code>exists (G : Type) [Magma G], ...</code> (or potentially allowing for a fixed universe for <code>G</code>)</p>",
        "id": 475008982,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728154908
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span>  ULift</p>",
        "id": 475008985,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728154915
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#ULift\">ULift</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#ULift.down\">ULift.down</a>, and <a href=\"https://loogle.lean-lang.org/?q=ULift\">576 more</a></p>",
        "id": 475008986,
        "sender_full_name": "loogle",
        "timestamp": 1728154915
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 475009109,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728154989
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/458659-Equational/topic/Possible.20refactor.20from.20Type*.20to.20Type.3F/near/475008982\">said</a>:</p>\n<blockquote>\n<p>except for non implications, which I think should be <code>exists (G : Type) [Magma G], ...</code> (or potentially allowing for a fixed universe for <code>G</code>)</p>\n</blockquote>\n<p>In counterexamples I guess the question is whether you want to exhibit a counterexample in <em>every</em> universe, or in <em>any</em> universe.</p>",
        "id": 475013726,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728157215
    },
    {
        "content": "<p>The latter, typically</p>",
        "id": 475023297,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728162688
    },
    {
        "content": "<p>I don't really see what universes are buying this project; I read the claim that it could in theory be the case that some random large category could be a counterexample but I'll believe it when I see it! If they're causing trouble then why not just retreat to <code>Type</code>? This is where mathematicians typically work.</p>",
        "id": 475023398,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728162777
    },
    {
        "content": "<p>I'm pretty sure it's possible to prove that every counterexample is at most countable and therefore no smallest counterexample can live in a larger universe</p>",
        "id": 475024864,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728164317
    },
    {
        "content": "<p>Yes, the problem here is more technical and Lean-specific than mathematical... we're having some problems actually formalizing in Lean a proof of this assertion, even though it should just be a consequence of standard logical theorems such as the completeness or compactness theorem (or the Lowenheim-Skolem theorem).</p>",
        "id": 475024905,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728164400
    },
    {
        "content": "<p>if you want to construct a counterexample to <code>A -&gt; B</code>, you can construct a free magma quotient by <code>A</code> and if it satisfies <code>B</code> also then <code>A -&gt; B</code> is true in every magma, and if it doesn't then it's a countable counterexample</p>",
        "id": 475024954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728164415
    },
    {
        "content": "<p>Though there may be some subtleties about what \"countable\" means in different universes</p>",
        "id": 475024959,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728164425
    },
    {
        "content": "<p>no, countability is absolute I think?</p>",
        "id": 475024970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728164440
    },
    {
        "content": "<p>certainly in lean they are provably equivalent</p>",
        "id": 475024981,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728164459
    },
    {
        "content": "<p>Yeah I do feel that these assertions are provable in Lean, but it needs someone who really understands Lean's universe type system to actually work out the details.</p>",
        "id": 475025031,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728164503
    },
    {
        "content": "<p>Is there a general definition of what the class of equational theories in question is?</p>",
        "id": 475025114,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728164561
    },
    {
        "content": "<p>you should be able to formalize everything I just said above in lean if you have that</p>",
        "id": 475025128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728164581
    },
    {
        "content": "<p>in any case, if you construct proofs and counterexamples in <code>Type</code> for every entry in your table, then you've sort of answered this question too without needing to address it explicitly</p>",
        "id": 475025242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728164668
    },
    {
        "content": "<p>I would be interested to know if there are any cases of A -&gt; B failing where the smallest counterexample is infinite</p>",
        "id": 475025284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728164727
    },
    {
        "content": "<p>are there any infinite counterexamples being used in the project currently?</p>",
        "id": 475025300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728164749
    },
    {
        "content": "<blockquote>\n<p>I would be interested to know if there are any cases of A -&gt; B failing where the smallest counterexample is infinite</p>\n</blockquote>\n<p>Yes, there are already <a href=\"https://github.com/teorth/equational_theories/blob/main/equational_theories/InfModel.lean\">proofs about the unavoidability</a> of such examples for certain pairs of eqns. I think proved by <span class=\"user-mention\" data-user-id=\"690858\">@Daniel Weber</span> ?</p>",
        "id": 475025361,
        "sender_full_name": "Zoltan A. Kocsis (Z.A.K.)",
        "timestamp": 1728164788
    },
    {
        "content": "<p>We have a <code>MagmaLaw</code> object which encodes a syntactic assertion <code>LawX</code> (it's a pair of elements from <code>FreeMagma Nat</code>).  We also have an operation <code>G ⊧ E</code> for when a <code>(G: Type) [Magma G]</code> obeys <code>E: MagmaLaw</code>, with a completeness theorem for this operation, but we don't currently have the same operation for <code>(G: Type*) [Magma G]</code>, with the corresponding completeness theorem in an unspecified universe.  Perhaps if we had both completeness theorems linking completeness to an absolute syntactic assertion then we would not have any issue.</p>",
        "id": 475025434,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728164877
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I'll give you a quick file overview</p>",
        "id": 475027045,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728166491
    },
    {
        "content": "<ol>\n<li>Starting point: We define a free magma <a href=\"https://github.com/teorth/equational_theories/blob/main/equational_theories/FreeMagma.lean\">here</a></li>\n<li>Magma Equations are defined here:  <a href=\"https://github.com/teorth/equational_theories/blob/main/equational_theories/MagmaLaw.lean\">https://github.com/teorth/equational_theories/blob/main/equational_theories/MagmaLaw.lean</a><br>\n(Side note: I'll remove that toplevel <code>hygiene</code> option in a PR quickly now)<br>\nThis contains our derivation rules</li>\n</ol>",
        "id": 475027201,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728166635
    },
    {
        "content": "<ol start=\"3\">\n<li>The magma operation is given  semantics here: <a href=\"https://github.com/teorth/equational_theories/blob/main/equational_theories/MagmaOp.lean\">https://github.com/teorth/equational_theories/blob/main/equational_theories/MagmaOp.lean</a></li>\n</ol>",
        "id": 475027268,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728166694
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/458659-Equational/topic/Possible.20refactor.20from.20Type*.20to.20Type.3F/near/475025434\">said</a>:</p>\n<blockquote>\n<p>We have a <code>MagmaLaw</code> object which encodes a syntactic assertion <code>LawX</code> (it's a pair of elements from <code>FreeMagma Nat</code>).  We also have an operation <code>G ⊧ E</code> for when a <code>(G: Type) [Magma G]</code> obeys <code>E: MagmaLaw</code>, with a completeness theorem for this operation, but we don't currently have the same operation for <code>(G: Type*) [Magma G]</code>, with the corresponding completeness theorem in an unspecified universe.  Perhaps if we had both completeness theorems linking completeness to an absolute syntactic assertion then we would not have any issue.</p>\n</blockquote>\n<p>Yes, that sounds about right. You should be able to prove the exact same completeness theorem in an arbitrary universe, and because the conclusion is something in Type 0 this tells you that they all have the same implication graph</p>",
        "id": 475027291,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728166725
    },
    {
        "content": "<p>Then we have soundness and completeness proofs here: <a href=\"https://github.com/teorth/equational_theories/blob/main/equational_theories/Completeness.lean\">https://github.com/teorth/equational_theories/blob/main/equational_theories/Completeness.lean</a></p>",
        "id": 475027295,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728166729
    },
    {
        "content": "<p>The current version of compactness is here: <a href=\"https://github.com/teorth/equational_theories/blob/main/equational_theories/Compactness.lean\">https://github.com/teorth/equational_theories/blob/main/equational_theories/Compactness.lean</a></p>",
        "id": 475027318,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728166767
    },
    {
        "content": "<p>I agree it does sound doable, the main issue is technical (and not getting trapped in some weird \"universe hell\").</p>",
        "id": 475027520,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728166965
    },
    {
        "content": "<p>that does exist, but you are not likely to encounter it in this project</p>",
        "id": 475027862,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728167350
    },
    {
        "content": "<p>I don't have any spare time to allocate, but if I get the chance I will see if I can audit the project and make sure the universes aren't an issue</p>",
        "id": 475027934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728167427
    },
    {
        "content": "<p>Basically the idea is that one may define satisfaction \"generically\" over a universe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">satisfies</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Magma</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MagmaLaw</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">satisfiesPhi</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">E</span>\n</code></pre></div>\n<p>This is the \"natural\" notion: we have no idea where such a <code>G</code> might live! So one can \"just\" prove that this is equivalent to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">satisfies</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Magma</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MagmaLaw</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">satisfiesPhi</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">E</span>\n</code></pre></div>\n<p>But this is both hard to <del>state and to</del> prove, I think.</p>\n<p>Here's a branch, where <code>Preorder.lean</code> fails. Happy to know how to fix it.  <a href=\"https://github.com/codyroux/equational_theories/tree/universes\">https://github.com/codyroux/equational_theories/tree/universes</a></p>",
        "id": 475028903,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728168430
    },
    {
        "content": "<p>I think you want to universally quantify over <code>G</code> there</p>",
        "id": 475028971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728168498
    },
    {
        "content": "<p>otherwise the two satisfies relations can only be compared over the same G and at that point it's obviously true</p>",
        "id": 475028985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728168526
    },
    {
        "content": "<p>That's the next definition in <code>MagmaLaw.lean</code></p>",
        "id": 475028988,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728168531
    },
    {
        "content": "<p>fair</p>",
        "id": 475028995,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728168539
    },
    {
        "content": "<p>at some point one has to cast explicitly, I'm sure</p>",
        "id": 475029009,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728168561
    },
    {
        "content": "<p>If one can prove soundness in arbitrary universes, completeness in the Type 0 universe, and can cast the <code>satisfies</code> relation from Type 0 to arbitrary Types, this should show everything is  equivalent, I think...</p>",
        "id": 475029068,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728168608
    },
    {
        "content": "<p>Then using the compactness theorem shouldn't be _too_ tough, it just involves collecting all the finite variables and mapping them injectively to, say <code>ℕ</code>, but it's also a bit tedious.</p>",
        "id": 475029082,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728168628
    },
    {
        "content": "<p>Amusingly there's a proof of cut-elimination that works like this: prove soundness of the system with cut and completeness for the system without cut.</p>\n<p>Computational content of the proof left as exercise.</p>",
        "id": 475029113,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728168688
    },
    {
        "content": "<p>I think what you want is something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">implies</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E1</span><span class=\"w\"> </span><span class=\"n\">E2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MagmaLaw</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Magma</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">E1</span><span class=\"w\"> </span><span class=\"bp\">|=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">E2</span><span class=\"w\"> </span><span class=\"bp\">|=</span><span class=\"w\"> </span><span class=\"n\">G</span>\n</code></pre></div>\n<p>and then the theorem is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">implies_def</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E1</span><span class=\"w\"> </span><span class=\"n\">E2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MagmaLaw</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">implies</span><span class=\"w\"> </span><span class=\"n\">E1</span><span class=\"w\"> </span><span class=\"n\">E2</span><span class=\"w\"> </span><span class=\"bp\">&lt;-&gt;</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Magma</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">E1</span><span class=\"w\"> </span><span class=\"bp\">|=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">E2</span><span class=\"w\"> </span><span class=\"bp\">|=</span><span class=\"w\"> </span><span class=\"n\">G</span>\n</code></pre></div>",
        "id": 475029124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728168710
    },
    {
        "content": "<p>I think I tried something similar and struggled to prove it, but I can give it another whirl tomorrow, unless someone else wants to give it a shot</p>",
        "id": 475029212,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728168813
    },
    {
        "content": "<p>I wonder if Lowenheim-Skolem is stated inter-universe in Mathlib (I assume it is)</p>",
        "id": 475029263,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728168843
    },
    {
        "content": "<p>The fact that alpha is also universe parametric here complicates things, but you can use compactness to show that it suffices to take alpha = Nat</p>",
        "id": 475029271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728168853
    },
    {
        "content": "<p>(that is, E1 and E2 have finite support so you can map them to a finite set of generators)</p>",
        "id": 475029312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728168942
    },
    {
        "content": "<p>It's amusing to see model theory having to come in for a project as concrete as proving (22 million times) that one algebraic identity implies or does not imply another.  (I mean, we <em>could</em> finish the project without this, but then we would not be able to do things like automatically invoke duality on implications within Lean, but instead have to do some awful metaprogramming to dualize proofs or something.)</p>",
        "id": 475029429,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728169016
    },
    {
        "content": "<p>It is usually simpler to prove a theorem and apply it than generate a proof wholesale from tactics.</p>",
        "id": 475029927,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728169467
    },
    {
        "content": "<p>It still disturbs me that we spend so little time as humans thinking about this but a lot in ITP. I had hoped that a \"sufficiently polymorphic\" type theory would save us, but no dice.</p>",
        "id": 475029935,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728169484
    },
    {
        "content": "<p>I wonder how Coq's cumulative universes would affect this question.</p>",
        "id": 475029965,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728169544
    },
    {
        "content": "<p>Meta-theoretically it should be the same (maybe avoid a cast somewhere) I would guess. I've already used choice in the proof of completeness though.</p>",
        "id": 475030096,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728169662
    },
    {
        "content": "<p>It's surprising to me that choice is needed.  Shouldn't there be a canonical model - a free magma quotiented out by syntactic equivalence or something?</p>",
        "id": 475030163,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728169717
    },
    {
        "content": "<p>Yes, I don't think it's needed, but at some point in the proof I needed to turn an instantiation into the canonical model into a substitution by \"lifting\". And this is only possible with choice in general.</p>\n<p>I didn't think much harder.</p>",
        "id": 475030202,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728169780
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116028\">Cody Roux</span> <a href=\"#narrow/stream/458659-Equational/topic/Possible.20refactor.20from.20Type*.20to.20Type.3F/near/475029935\">said</a>:</p>\n<blockquote>\n<p>It still disturbs me that we spend so little time as humans thinking about this but a lot in ITP. I had hoped that a \"sufficiently polymorphic\" type theory would save us, but no dice.</p>\n</blockquote>\n<p>No, I actually think it is the opposite, allowing universe levels was the original sin, we should have just stuck to ZFC</p>",
        "id": 475030208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728169796
    },
    {
        "content": "<p>The \"F\" is already universes, in a way :)</p>",
        "id": 475030268,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728169822
    },
    {
        "content": "<p>FWIW this stuff never came up when I was working in metamath</p>",
        "id": 475030281,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728169839
    },
    {
        "content": "<p>heck, this whole project can be done in PA with a bit of finagling</p>",
        "id": 475030313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728169900
    },
    {
        "content": "<p>It's fair it's fair, but someone, someday is going to want the \"magma of <code>Type</code>s with products\"...</p>",
        "id": 475030321,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728169915
    },
    {
        "content": "<p>but in ZFC you handle that by reinterpreting what <code>Type</code> is instead of reinterpreting the whole rest of the theory to stick astro sets on top</p>",
        "id": 475030385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728169966
    },
    {
        "content": "<p>I imagine that once the project is completed, some external tool could deconstruct the Lean proofs and give extremely low-level proofs using essentially no axioms, which could also be exported to other languages than Lean.  In particular, any invocation of duality could be replaced by some ad hoc code to dualize the low level proof instead.</p>",
        "id": 475030407,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728170002
    },
    {
        "content": "<p>e.g. you just say \"oh and by the way there is an inaccessible cardinal\" and you haven't made all of the previous theorems no longer completely general</p>",
        "id": 475030413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728170011
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/458659-Equational/topic/Possible.20refactor.20from.20Type*.20to.20Type.3F/near/475030407\">said</a>:</p>\n<blockquote>\n<p>I imagine that once the project is completed, some external tool could deconstruct the Lean proofs and give extremely low-level proofs using essentially no axioms, which could also be exported to other languages than Lean.  In particular, any invocation of duality could be replaced by some ad hoc code to dualize the low level proof instead.</p>\n</blockquote>\n<p>I will absolutely attempt to do this at some point</p>",
        "id": 475030450,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728170042
    },
    {
        "content": "<p>I already want to do this for FLT, but this project will be way easier to do reverse mathematics on</p>",
        "id": 475030497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728170098
    },
    {
        "content": "<p>I wonder whether FLT will encounter this issue.  There was a famous debate some decades ago as to whether Wiles's proof really used Grothendieck's axiom of universes or whether it could be avoided \"in principle\".  Tangential to the current discussion, but I would be curious as to <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> 's opinion on this.</p>",
        "id": 475030521,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728170110
    },
    {
        "content": "<p>We've had discussions about this. Ideally Kevin won't have to do anything untoward with the proof, this should be a completely automatic affair. In practice it requires solving some tricky theoretical problems in addition to building a tool (the tool already exists, it just doesn't give answers I like)</p>",
        "id": 475030613,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728170206
    },
    {
        "content": "<p>FLT will certainly engage with universes in some ways, but not really in interesting ways that would cause universe hell issues. For that you need to be doing set theory or category theory I think</p>",
        "id": 475030746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728170331
    },
    {
        "content": "<p>That sounds plausible to me.</p>",
        "id": 475030756,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728170351
    },
    {
        "content": "<p>My hope is to prove that while it refers to <code>Type</code> as a thing, that thing doesn't actually need to be a full ZFC universe, only an approximation thereof, and ZFC proves the existence of an abundance of approximate universes so you can use that to construct a model to conduct the proof in</p>",
        "id": 475030841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728170420
    },
    {
        "content": "<p>i.e. it's sort of automating the technique of sticking <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>-small in front of everything</p>",
        "id": 475030866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728170458
    },
    {
        "content": "<p>Yeah that roughly tracks with how ultrafilters / choice tends to come up in analysis.  In practice there's always some finitary approximate version that's good enough, but the exact quantification of \"approximate\" depends on how complicated your proof is so it's far more convenient to assume a strong axiom and just use the transfinite object or whatever instead.</p>",
        "id": 475030900,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728170508
    },
    {
        "content": "<p>right, which is why it's a prime target for ITP proofs since you can automate the derivation of what \"good enough\" means for your proof</p>",
        "id": 475030954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728170546
    },
    {
        "content": "<p>Ok, so what should we do pragmatically? I can just search-replace <code>Type*</code> to <code>Type</code>, honestly that might just work, or I can give another shot at making the other direction prove.</p>",
        "id": 475032439,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728172327
    },
    {
        "content": "<p>It might temporarily disrupt some of the automated proof code to do this refactor to retreat from <code>Type*</code> to <code>Type</code>, but I assume this would all get sorted out relatively quickly.  I guess one could always pursue the model theoretic question of establishing soundness in arbitrary universes at a later date.  In principle there is a scenario in which the most natural counterexample for an implication turns out to live in a higher universe than Type 0, but I think this is really, really unlikely.  (Unless our example somehow relies on FLT <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> .)</p>",
        "id": 475032700,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728172654
    },
    {
        "content": "<p>reminder that FLT is a statement about natural numbers <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 475032778,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728172726
    },
    {
        "content": "<p>In particular if we do retreat from <code>Type*</code> to <code>Type</code> it's not quite enough to search-and-replace all the human-generated and computer-generated Lean code; we also have to go into some of the scripts that generate the latter and do appropriate search-and-replaces there too, otherwise they will autogenerate back results in the wrong format.  But I assume that should be doable, just tedious.  I can't imagine that any code will actually break with this edit.</p>",
        "id": 475032877,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728172812
    },
    {
        "content": "<p>My recommendation is to not do that, just keep proofs in Type* and counterexamples inType</p>",
        "id": 475032959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728172882
    },
    {
        "content": "<p>But then we can't use duality without a soundness theorem in Type* and a completeness theorem in Type and we only have the latter currently</p>",
        "id": 475033053,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728172926
    },
    {
        "content": "<p>all of the universe handling will focus on a few theorems like completeness, and it will provide an interface most convenient for everything else</p>",
        "id": 475033071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728172961
    },
    {
        "content": "<p>so just sorry the theorem if you need it for something and set it as an objective for the people who work on this kind of thing</p>",
        "id": 475033102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728173001
    },
    {
        "content": "<p>I mean I agree this is the right format for proofs and counterexamples, it's just that we still need a metatheorem that we don't currently have (soundness in Type*).</p>",
        "id": 475033112,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728173012
    },
    {
        "content": "<p>I'm quite sure the theorem is true as long as you can state it in a way that typechecks</p>",
        "id": 475033140,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728173037
    },
    {
        "content": "<p>but I need to sleep now (or rather 4 hours ago), I am sure others can continue this</p>",
        "id": 475033227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728173105
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"116028\">@Cody Roux</span> you have another run at this problem but bring any issues you discover to this thread and we can try to problem solve any universe issues that arise?</p>",
        "id": 475033285,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728173163
    },
    {
        "content": "<p>Some of our counterexample code I think is in <code>Type*</code> instead of <code>Type</code> (e.g., <a href=\"https://github.com/teorth/equational_theories/blob/main/equational_theories/FactsSyntax.lean\">https://github.com/teorth/equational_theories/blob/main/equational_theories/FactsSyntax.lean</a> ).  Regardless of what we do, I guess we have to do some refactoring to make this consistent.  </p>\n<p>I created <a href=\"https://github.com/teorth/equational_theories/pull/344\">equational#344</a> to deal with this refactor (which is separate from the soundness issue, and I think can be handled independently.)</p>",
        "id": 475033653,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728173591
    },
    {
        "content": "<p>Soundness in <code>Type*</code> is done, no problem, it's the second bit we need.</p>",
        "id": 475036520,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728176826
    },
    {
        "content": "<p>I'll try to sort it all out tomorrow and advise.</p>",
        "id": 475036531,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728176857
    },
    {
        "content": "<p>I was asleep so I couldn't participate in the discussion, but I'm not sure I was clear enough what the problem was:<br>\nSuppose we have an implication <code>theorem Equation2_implies_Equation3 (G: Type*) [Magma G] (h: Equation2 G) : Equation3 G</code>. Suppose you then invoke <code>equation_to_law</code> - the natural goal for it to produce is <code>G ⊧ Lf 0 ≃ Lf 0 ⋆ Lf 0</code>. However, this isn't type correct, because <code>satisfies</code> is defined as <code>def satisfies {α : Type} (G : Type) [Magma G] (E : MagmaLaw α)</code></p>",
        "id": 475036780,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728177128
    },
    {
        "content": "<p>Is it type correct to also define <code>def satisfies' {α : Type*} (G : Type*) [Magma G] (E : MagmaLaw α)</code> and <code>G ⊧' Lf 0 ≃ Lf 0 ⋆ Lf 0</code> in the obvious fashion?  Then have some soundness theorem that shows that the latter is implied by <code>G ⊧' Lf 0 ≃ Lf 1</code> and <code>(Lf 0 ≃ Lf 1) ≤ (Lf 0 ≃ Lf 0 * Lf 0)</code>?</p>",
        "id": 475037270,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728177662
    },
    {
        "content": "<p>It is, but I think it makes more sense to just modify the existing <code>satisfies</code> - would that cause a problem anywhere?</p>",
        "id": 475037293,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728177703
    },
    {
        "content": "<p>Well we want our counterexamples to live in <code>Type</code> rather than <code>Type*</code></p>",
        "id": 475037342,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728177729
    },
    {
        "content": "<p>That shouldn't affect it - <code>Type*</code> is a superset of <code>Type</code>, you could still write <code>G ⊧ Lf 0 ≃ Lf 0 ⋆ Lf 0</code> for <code>G : Type</code></p>",
        "id": 475037365,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728177775
    },
    {
        "content": "<p>Note also that the \"syntactic model\" is also bounded by the universe of the argument to <code>FreeMagma</code>, though I don't think anyone's complained about that one.</p>",
        "id": 475037372,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728177781
    },
    {
        "content": "<p>Yeah fair enough</p>",
        "id": 475037384,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728177799
    },
    {
        "content": "<p>I thought we were using <code>FreeMagma Nat</code> for the syntactic model, so always Type 0</p>",
        "id": 475037403,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728177816
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"690858\">@Daniel Weber</span> (modulo some cast, I think)</p>",
        "id": 475037405,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728177819
    },
    {
        "content": "<p>No it's all parametrized over alpha.</p>",
        "id": 475037415,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728177834
    },
    {
        "content": "<p>oh but maybe we could force alpha to be Type 0? I see no scenario in which we would need a higher universe of variable symbols</p>",
        "id": 475037473,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728177870
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/458659-Equational/topic/Possible.20refactor.20from.20Type*.20to.20Type.3F/near/475037403\">said</a>:</p>\n<blockquote>\n<p>I thought we were using <code>FreeMagma Nat</code> for the syntactic model, so always Type 0</p>\n</blockquote>\n<p>For <code>equation_to_law</code>, yes, but for <code>law_to_equation</code> it can accept any free magma</p>",
        "id": 475037474,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728177872
    },
    {
        "content": "<p>In fact it's already rare that we need more than six variables</p>",
        "id": 475037496,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728177907
    },
    {
        "content": "<p>Sure, of course one may add many many variables if one likes, e.g. to build non-standard models, but all this is theoretical.</p>",
        "id": 475037523,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728177955
    },
    {
        "content": "<p>As I mentioned earlier, given 2 or 4 elements of <code>FreeMagma A</code> representing the equations you want to relate, they can altogether mention only finitely many elements of A, so you can map the question onto <code>Fin n</code> for some <code>n</code></p>",
        "id": 475037526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728177961
    },
    {
        "content": "<p>Yes, I was intending to do that yesterday but ran into universe issues.</p>",
        "id": 475037580,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728177987
    },
    {
        "content": "<p>so you can prove that having a large <code>A</code> gives you no extra power</p>",
        "id": 475037582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728177989
    },
    {
        "content": "<p>Well we would need the alphabet in <code>Type</code> if we want a completeness theorem in <code>Type</code>.  I hardly think this is a great loss though.</p>",
        "id": 475037648,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728178079
    },
    {
        "content": "<p>Agreed, will try that as well</p>",
        "id": 475037697,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728178097
    },
    {
        "content": "<p>The Wiles/Taylor--Wiles proof of FLT can be proved in ZFC, but in practice the most convenient way to prove it is to use a universe and then just ask the logicians to please shoehorn it back into ZFC. For example <a href=\"https://stacks.math.columbia.edu/tag/000H\">here</a> is Johan de Jong making some very artificial definitions to demonstrate that in the stacks project whenever he is arguing in a large category (schemes) he could in fact be arguing in a small one (schemes of \"size\" at some some cardinal whose existence can be proven in ZFC). Similarly <a href=\"https://arxiv.org/abs/1709.07343\">here</a>, section 4, is Peter Scholze showing that his work on applications of perfectoid spaces to the Langlands program can all be stuffed into ZFC by using techniques which logicians have figured out over the decades. The trick is always the same -- instead of using a universe just observe that something weaker will do because in practice (eg <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>κ</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">κ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> a strong limit cardinal), although the details are tedious (but also well-understood). Of course Grothendieck never did any such thing, he just used universes. My personal interpretation of these results is that ZFC is in some sense unsuitable/inconvenient as a foundation for algebraic geometry if it's forcing people like this to take time explaining how in theory ZFC can be used but in practice they're not going to use it.</p>",
        "id": 475073866,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728202650
    },
    {
        "content": "<p>This is exactly the argument I've used for why we should all just use <code>Type : Type</code> and let \"the logicians\" figure out how to pick out an actual proof from a proof constructed in these more convenient foundations (because obviously we won't be using those assumptions to prove a contradiction, because that would be rude)</p>",
        "id": 475083069,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728208988
    },
    {
        "content": "<p><code>Type : Type</code> is obviously the right foundations for category theory</p>",
        "id": 475083214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728209151
    },
    {
        "content": "<p>and when \"mathematicians\" go to some effort to avoid using it because it's inconsistent, this is a violation of division of labor since that's \"the logician's\" job</p>",
        "id": 475083348,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728209242
    },
    {
        "content": "<p>After trying for a bit to change it to <code>Type*</code>, I mostly agree. However, perhaps the most basic definitions, e.g. <code>satisfies</code>, should still be universe-general? It's quite annoying to be unable to write <code>G ⊧ Lf 0 ≃ Lf 0</code> for <code>G : Type*</code>. Although perhaps that just pushes the problem a bit further, as given <code>G ⊧ law1</code> and <code>implies law1 law2</code> you couldn't conclude <code>G ⊧ law2</code> without <a href=\"https://github.com/teorth/equational_theories/pull/186\">equational#186</a> (and <code>implies</code> is <code>∀ {G : Type} [Magma G], satisfies G l₁ → satisfies G l₂</code>, which can't be made universe general as that requires quantifying over universes)</p>",
        "id": 475083508,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728209394
    },
    {
        "content": "<p>So my claim above is that if you define <code>implies</code> like that (not universe-general), then you can prove that it is equivalent to the same definition over <code>Type u</code>, and you use that equivalence to apply it to general magmas</p>",
        "id": 475084351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728209802
    },
    {
        "content": "<p>I know, that's <a href=\"https://github.com/teorth/equational_theories/pull/186\">equational#186</a></p>",
        "id": 475084425,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728209823
    },
    {
        "content": "<p>can someone point me to the relevant code and/or previous attempts at this?</p>",
        "id": 475084541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728209877
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"116028\">@Cody Roux</span> attempted something, they might have relevant code</p>",
        "id": 475098532,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1728219509
    },
    {
        "content": "<p>Yep you were already in the conversation <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> :) <a href=\"https://github.com/codyroux/equational_theories/tree/universes\">https://github.com/codyroux/equational_theories/tree/universes</a></p>",
        "id": 475108117,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728228559
    },
    {
        "content": "<p>do please ping me if you have a PR that fixes/works towards this.</p>",
        "id": 475108139,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728228589
    },
    {
        "content": "<p>Nope, stuck again, <code>models</code> is annoyingly non-variant: <code>G</code> appears on the lhs and the rhs of an implies.</p>",
        "id": 475112030,
        "sender_full_name": "Cody Roux",
        "timestamp": 1728232302
    },
    {
        "content": "<p>I'm about 90% of the way through a proof, I worked on this on a plane so I didn't see your post but it looks like my stuff subsumes that</p>",
        "id": 475112128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728232383
    },
    {
        "content": "<p>in particular, I was able to fairly easily get the completeness theorem to generalize to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Completeness'_0</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MagmaLaw</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"bp\">⊧</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"bp\">⊢'</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">FreeMagmaWithLaws</span><span class=\"bp\">.</span><span class=\"n\">isDerives</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FreeMagmaWithLaws</span><span class=\"bp\">.</span><span class=\"n\">isModel</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and the rest of the work is to generalize beta to higher universes (for which you need the compactness argument I sketched)</p>",
        "id": 475112235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728232473
    },
    {
        "content": "<p>I can see that our final paper is going to have a section on universe issues.  Hopefully we find some standard solutions that future projects of this type can adopt without having to trek through universe hell.</p>",
        "id": 475112782,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728232937
    }
]