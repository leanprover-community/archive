[
    {
        "content": "<p>I've opened PR <a href=\"https://github.com/teorth/equational_theories/pull/526\">equational#526</a> that formalizes the ideas in <a href=\"https://teorth.github.io/equational_theories/blueprint/metatheory-chapter.html\">Chapter 9</a> (a generalization of <a href=\"#narrow/stream/458659-Equational/topic/Metatheorem.3A.20complexity-preserving.20equations/near/473454308\"><span class=\"user-mention\" data-user-id=\"435481\">@Hernan Ibarra</span>'s original metatheorem</a>) and automatically generates formal proofs for certain non-implications.</p>\n<p>Ideas and feedback would be much appreciated. </p>\n<p>Currently, the non-implications are of four kinds:</p>\n<ul>\n<li>ones generated by comparing the (ordered) <em>lists</em> of variables appearing on both sides of an equation</li>\n<li>ones generated by comparing the <em>multisets</em> of variables appearing on both sides of an equation</li>\n<li>ones generated by comparing the <em>left-most elements</em> appearing on both sides of an equation (originally suggested by <span class=\"user-mention\" data-user-id=\"690858\">@Daniel Weber</span> in the same thread)</li>\n<li>ones generated by comparing the <em>right-most elements</em> appearing on both sides of an equation</li>\n</ul>\n<p>More counter-examples of this kind can be generated by defining new instances of <code>LiftingMagmaFamily</code> in <code>equational_theories/LiftingMagmaFamilies</code> and manually adding them to the <code>liftingMagmaFamilyInstances</code> array in <code>equational_theories/LiftingMagmaFamiliesCounterexamples</code>. Suggestions along this direction would be particularly welcome.</p>",
        "id": 476466551,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1728684924
    },
    {
        "content": "<p>I'd like to add support for translating from <code>FreeMagmaWithLaws</code> (which is nicer to deal with mathematically) to a <code>LiftingMagmaFamily</code> (which is a custom-made definition for this particular use case). I've opened <a href=\"https://github.com/teorth/equational_theories/pull/634\">equational#634</a> and <a href=\"https://github.com/teorth/equational_theories/pull/635\">equational#635</a> towards this.</p>",
        "id": 477689899,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1729268393
    },
    {
        "content": "<p>This PR makes it possible to automatically generate further proofs of non-implications by</p>\n<ul>\n<li>defining a <code>FreeMagmaWithLaws</code></li>\n<li>proving that the free magma on a set with decidable equality also has decidable equality</li>\n<li>updating the <a href=\"https://github.com/teorth/equational_theories/blob/f2ac7470947638aa2f1450c6f6e045a55efbce34/equational_theories/LiftingMagmaFamiliesCounterexamples.lean#L14\">list of lifting magma family instances</a> with the <a href=\"https://github.com/teorth/equational_theories/blob/f2ac7470947638aa2f1450c6f6e045a55efbce34/equational_theories/LiftingMagmaFamilies.lean#L108\">instance</a> derived from this <code>FreeMagmaWithLaws</code></li>\n<li>running <code>lake exe generate_lifting_magma_family_counterexamples</code> to generate the proofs of non-implications in <a href=\"https://github.com/teorth/equational_theories/tree/main/equational_theories/Generated/InvariantMetatheoremNonimplications\">this directory</a>.</li>\n</ul>\n<p>Unfortunately, the third step needs to be done manually at the moment. The obstacle in automating this is that the structure <code>LiftingMagmaFamilyInstance</code> has type <code>Type 1</code>, while the relevant Lean definitions like <code>evalConst</code> and <code>MetaM</code> only deal with objects in the <code>Type</code> universe.</p>",
        "id": 477796516,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1729335821
    },
    {
        "content": "<p>Would resolving <a href=\"https://github.com/teorth/equational_theories/pull/186\">equational#186</a> help with the final step?  I vaguely recall <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> had some progress on this front, but I don't recall how far it got.</p>",
        "id": 477811209,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729347629
    },
    {
        "content": "<p>it was merged already</p>",
        "id": 477811231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729347656
    },
    {
        "content": "<p><a href=\"https://github.com/teorth/equational_theories/blob/84c00fd62ca990d464c720a6bb86e212ab3a7922/equational_theories/Completeness.lean#L142-L143\">https://github.com/teorth/equational_theories/blob/84c00fd62ca990d464c720a6bb86e212ab3a7922/equational_theories/Completeness.lean#L142-L143</a></p>",
        "id": 477811258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729347689
    },
    {
        "content": "<p>Oh, then I can finish <code>equation_to_law</code> and <code>law_to_equation</code></p>",
        "id": 477811359,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729347779
    },
    {
        "content": "<p>I would close <a href=\"https://github.com/teorth/equational_theories/pull/186\">equational#186</a> but I don't have the perms</p>",
        "id": 477811390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729347815
    },
    {
        "content": "<p>the relevant PR is <a href=\"https://github.com/teorth/equational_theories/pull/458\">equational#458</a></p>",
        "id": 477811448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729347843
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"690858\">@Daniel Weber</span> what do you mean by this? I don't see why universe handling should explicitly appear in any other part of the project</p>",
        "id": 477811485,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729347891
    },
    {
        "content": "<p>I need to be able to use <code>G ⊧ E</code> for <code>G : Type*</code></p>",
        "id": 477811641,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729348056
    },
    {
        "content": "<p>Why?</p>",
        "id": 477811657,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348079
    },
    {
        "content": "<p>Closed now.  Sorry for not noticing this earlier!</p>",
        "id": 477811715,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729348116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/Automatically.20proving.20non-implications.20with.20invariants/near/477811657\">said</a>:</p>\n<blockquote>\n<p>Why?</p>\n</blockquote>\n<p>Because we want to convert <code>SomeEquation G</code> to <code>G ⊧ SomeLaw</code>, and <code>G</code> can (and is, in implication theorems) be a <code>Type*</code> there</p>",
        "id": 477811723,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729348128
    },
    {
        "content": "<p>Our positive implications are spelled using <code>Type*</code>, our negative implications are spelled using <code>Type</code></p>",
        "id": 477811740,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729348143
    },
    {
        "content": "<p>In both cases, you can go to/from law inequalities without universe munging</p>",
        "id": 477811765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348189
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/Automatically.20proving.20non-implications.20with.20invariants/near/477811765\">said</a>:</p>\n<blockquote>\n<p>In both cases, you can go to/from law inequalities without universe munging</p>\n</blockquote>\n<p>Previously <code>G ⊧ SomeLaw</code> was defined only for <code>G : Type</code>, so it couldn't be used for <code>G : Type*</code></p>",
        "id": 477811825,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729348216
    },
    {
        "content": "<p>It would help to have a usage example for the tactics in <a href=\"https://github.com/teorth/equational_theories/pull/147\">equational#147</a></p>",
        "id": 477811838,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348231
    },
    {
        "content": "<p>is the idea that you want to change the theorem statement to a law inequality?</p>",
        "id": 477811858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348255
    },
    {
        "content": "<p>(It's still defined that way BTW)</p>",
        "id": 477811875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348270
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/Automatically.20proving.20non-implications.20with.20invariants/near/477811858\">said</a>:</p>\n<blockquote>\n<p>is the idea that you want to change the theorem statement to a law inequality?</p>\n</blockquote>\n<p>Not an equality, just convert the goal <code>SomeEquation G</code> to <code>G ⊧ SomeLaw</code> and vice versa</p>",
        "id": 477811912,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729348306
    },
    {
        "content": "<p>Those are in both cases just unfolding definitions</p>",
        "id": 477811967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348327
    },
    {
        "content": "<p>Also, keep in mind that <code>Type*</code> isn't actually a universe, it's syntax for <code>Type u</code> where <code>u</code> is bound somewhere else (and the location of this binding is somewhat relevant). If you write <code>Type*</code> twice you get two different universe variables</p>",
        "id": 477812094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/Automatically.20proving.20non-implications.20with.20invariants/near/477811875\">said</a>:</p>\n<blockquote>\n<p>(It's still defined that way BTW)</p>\n</blockquote>\n<p><code>models</code>, yes, but <code>satisfiesPhi</code> now has <code>α G : Type*</code>, while it previously had <code>α G : Type</code></p>",
        "id": 477812108,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729348467
    },
    {
        "content": "<p>this most likely is not relevant</p>",
        "id": 477812123,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348488
    },
    {
        "content": "<p>again, I'm not clear on your actual application</p>",
        "id": 477812133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348497
    },
    {
        "content": "<p>can you give an example why would you need to do this</p>",
        "id": 477812157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348512
    },
    {
        "content": "<p>is there a place in the code today that would use <code>law_to_equation</code> if it existed?</p>",
        "id": 477812186,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348558
    },
    {
        "content": "<p>This whole project will never involve manipulating a magma in a higher universe. The <code>models_def'</code> theorem is really not there to be used, it is there to check the box saying \"yes, this actually is WLOG\"</p>",
        "id": 477812316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348678
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/Automatically.20proving.20non-implications.20with.20invariants/near/477812186\">said</a>:</p>\n<blockquote>\n<p>is there a place in the code today that would use <code>law_to_equation</code> if it existed?</p>\n</blockquote>\n<p>The proofs by duality could be something like <code>law_to_equation (implies_iff_dual.1 (equation_to_law some_existing_theorem))</code></p>",
        "id": 477812357,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729348688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/Automatically.20proving.20non-implications.20with.20invariants/near/477812316\">said</a>:</p>\n<blockquote>\n<p>This whole project will never involve manipulating a magma in a higher universe. The <code>models_def'</code> theorem is really not there to be used, it is there to check the box saying \"yes, this actually is WLOG\"</p>\n</blockquote>\n<p>Not an explicit magmas, but all of the positive implications are on <code>G : Type*</code></p>",
        "id": 477812372,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729348703
    },
    {
        "content": "<p>that means that they can be instantiated at type 0</p>",
        "id": 477812385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348718
    },
    {
        "content": "<p>Yes, but for the other direction (from a law implication to a theorem on <code>Type*</code>) you need <code>models_def'</code></p>",
        "id": 477812408,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729348747
    },
    {
        "content": "<p>only if your counterexample uses a magma in a higher universe, which I assert will never happen in this project</p>",
        "id": 477812420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348771
    },
    {
        "content": "<p>There's no counterexample involved, it's for positive implications (although perhaps those aren't relevant anymore)</p>",
        "id": 477812439,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729348800
    },
    {
        "content": "<p>For positive implications you have a theorem saying that LawN G -&gt; LawM G for all magmas in all universes, so you specialize that to magmas in the lowest universe and hey presto that's the definition of <code>LawN |= LawM</code></p>",
        "id": 477812527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348861
    },
    {
        "content": "<p>no <code>models_def'</code> needed</p>",
        "id": 477812534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348867
    },
    {
        "content": "<p>the only time you need <code>models_def'</code> is if you have a negative implication using a <code>Type 2</code> magma or something</p>",
        "id": 477812605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/Automatically.20proving.20non-implications.20with.20invariants/near/477812527\">said</a>:</p>\n<blockquote>\n<p>For positive implications you have a theorem saying that LawN G -&gt; LawM G for all magmas in all universes, so you specialize that to magmas in the lowest universe and hey presto that's the definition of <code>LawN |= LawM</code></p>\n</blockquote>\n<p>Yes, but for the other direction, where you already have <code>LawN |= LawM</code> (obtained using <code>implies_iff_dual</code>, for instance) and want to get <code>LawN G -&gt; LawM G</code> for all magmas in all universes, don't you need <code>models_def'</code>?</p>",
        "id": 477812630,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729348958
    },
    {
        "content": "<p>Isn't it good enough to have <code>LawN |= LawM</code>?</p>",
        "id": 477812648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729348986
    },
    {
        "content": "<p>All of the theorems are <code>LawN G -&gt; LawM G</code>, not <code>LawN |= LawM</code>, so presumably you'd also want it in that form</p>",
        "id": 477812684,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729349021
    },
    {
        "content": "<p>maybe I'm confused why you want that then</p>",
        "id": 477812694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729349040
    },
    {
        "content": "<p>you will have to pack it back up in the end anyway</p>",
        "id": 477812736,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729349053
    },
    {
        "content": "<p>My understanding of the discussion around the \"final theorem\" is that duality will be automatically handled as part of the closure algorithm</p>",
        "id": 477812815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729349143
    },
    {
        "content": "<p>so I think you should just leave it at having <code>implies_iff_dual</code> itself and not stating dual theorems unless you need them for other reasons</p>",
        "id": 477812881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729349184
    },
    {
        "content": "<p>One advantage of the unpacked form <code>LawN G -&gt; LawM G</code> of the implication is that they can be described in a standalone Lean file with only minimal imports, e.g., </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Magma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">infix</span><span class=\"o\">:</span><span class=\"mi\">65</span><span class=\"w\"> </span><span class=\"s2\">\" ◇ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Magma</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Equation3511</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Magma</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">◇</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">◇</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">◇</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">◇</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Equation3456</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Magma</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">◇</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">◇</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">◇</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">◇</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Equation3511_implies_Equation3456</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Magma</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equation3511</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equation3456</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In particular if we are to try to perform low-level exports of proofs as per <a href=\"https://github.com/teorth/equational_theories/pull/343\">equational#343</a> then we would presumably spell things in something like this form.</p>",
        "id": 477814129,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729350124
    },
    {
        "content": "<p>I think this is good, for files which are doing direct proofs of implications</p>",
        "id": 477814170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729350169
    },
    {
        "content": "<p>Daniel seems to be talking about proving implications from other implications though</p>",
        "id": 477814184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729350184
    },
    {
        "content": "<p>Right, so for instance suppose we have the above implication 3511=&gt;3456 in the Lean codebase in this unpacked form, and want to then use duality to get the dual implication 3511* =&gt; 3456* without having to repeat the proof.  Wouldn't we have to convert the above theorem back to a <code>LawN |= LawM</code> statement in order to apply  <code>implies_iff_dual</code>?</p>",
        "id": 477814303,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729350274
    },
    {
        "content": "<p>(in this particular case the proof is just one <code>rw</code>, but let's pretend for sake of argument that the proof is actually dozens of rewrites.)</p>",
        "id": 477814441,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729350393
    },
    {
        "content": "<p>(Assuming you don't fix this issue by just universe generalizing <code>implies_iff_dual</code>, which is certainly a possibility,) you could just have such theorems restrict to type 0</p>",
        "id": 477814515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729350475
    },
    {
        "content": "<p>since we know that it makes no difference, you should just go with whatever is easiest</p>",
        "id": 477814570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729350498
    },
    {
        "content": "<p>Another alternative is to just write something like <code>otherImplication (op G)</code> as the proof and make sure that this is defeq to what we want (as happens in Mathlib for order dual), although that's defeq abuse</p>",
        "id": 477814618,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729350545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/channel/458659-Equational/topic/Automatically.20proving.20non-implications.20with.20invariants/near/477814129\">said</a>:</p>\n<blockquote>\n<p>One advantage of the unpacked form <code>LawN G -&gt; LawM G</code> of the implication is that they can be described in a standalone Lean file with only minimal imports, e.g., </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Magma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">infix</span><span class=\"o\">:</span><span class=\"mi\">65</span><span class=\"w\"> </span><span class=\"s2\">\" ◇ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Magma</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Equation3511</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Magma</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">◇</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">◇</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">◇</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">◇</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Equation3456</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Magma</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">◇</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">◇</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">◇</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">◇</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Equation3511_implies_Equation3456</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Magma</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equation3511</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equation3456</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In particular if we are to try to perform low-level exports of proofs as per <a href=\"https://github.com/teorth/equational_theories/pull/343\">equational#343</a> then we would presumably spell things in something like this form.</p>\n</blockquote>\n<p>Actually, looking at this again I think this is not an okay formulation, because it requires another definition of <code>Magma</code>, so it will clash with all the other definitions of <code>Magma</code> and produce incompatible theorems</p>",
        "id": 477814650,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729350581
    },
    {
        "content": "<p>Until now we did not expect any higher <code>Type</code> to come into play, but earlier in this thread it was reported that we now have a <code>Type 1</code> object <code>LiftingMagmaFamilyInstance</code> which may eventually require laws to be applied to higher type objects.</p>",
        "id": 477814737,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729350625
    },
    {
        "content": "<p>Surely we can enclose the magma inside a namespace if necessary?</p>",
        "id": 477814751,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729350640
    },
    {
        "content": "<p>that would avoid the name conflict but not the incompatibility</p>",
        "id": 477814770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729350658
    },
    {
        "content": "<p>because now every theorem is proving something about a different class of magma-things</p>",
        "id": 477814794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729350682
    },
    {
        "content": "<p>Or have a single very minimal common <code>Magma.lean</code> import containing just the first five lines of that code (This was in fact how the codebase started three weeks ago)</p>",
        "id": 477814799,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729350688
    },
    {
        "content": "<p>yes that's better</p>",
        "id": 477814808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729350700
    },
    {
        "content": "<p>but you could also put <code>models</code> in that import</p>",
        "id": 477814817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729350709
    },
    {
        "content": "<p>If you actually want to reduce imports though such that 5 lines is looking like a lot, then you should probably do something about <code>Init</code>, which is massive</p>",
        "id": 477814885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729350755
    },
    {
        "content": "<p>you can do this by putting <code>prelude</code> at the top of the file and then importing only the files that you need</p>",
        "id": 477814932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729350790
    },
    {
        "content": "<p>every file implicitly begins with <code>import Init</code> unless you use <code>prelude</code></p>",
        "id": 477814972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729350836
    },
    {
        "content": "<p>Sure but the proofs of the 10,657 forward implications in the codebase are all written using the <code>LawN G -&gt; LawM G</code> spelling.  Refactoring them all to <code>LawN |= LawM</code> would be tedious if we did not have an <code>equation_to_law</code> tactic.</p>",
        "id": 477814978,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729350840
    },
    {
        "content": "<p>Sure, I just gave that code as an example, I'm sure with suitable effort we could find a much lighter version suitable for export purposes.</p>",
        "id": 477815049,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729350875
    },
    {
        "content": "<p>I think the aggregator tool for the \"final theorem\" should just automatically handle all of the various spellings and convert as needed</p>",
        "id": 477815054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729350879
    },
    {
        "content": "<p>OK one could do all this only in the exporter front end, but why not have the capability for conversion in the Lean codebase natively?</p>",
        "id": 477815085,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729350914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/channel/458659-Equational/topic/Automatically.20proving.20non-implications.20with.20invariants/near/477814618\">said</a>:</p>\n<blockquote>\n<p>Another alternative is to just write something like <code>otherImplication (op G)</code> as the proof and make sure that this is defeq to what we want (as happens in Mathlib for order dual), although that's defeq abuse</p>\n</blockquote>\n<p>It would be nice to have a term elab <code>dually% EquationN_implies_EquationM</code> which does something like this and then cleans up the statement to remove the <code>op</code>s</p>",
        "id": 477815216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351030
    },
    {
        "content": "<p>this would also avoid the need to change universes</p>",
        "id": 477815250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351064
    },
    {
        "content": "<p>If there are actually higher type objects being used, then I will stand corrected and these will need to use <code>models_def'</code> to squash them back down.</p>",
        "id": 477815395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351165
    },
    {
        "content": "<p>But it's a heavy theorem (in the sense of using dependencies which I think will not be involved in most implication proofs) so I think it is better to avoid if possible</p>",
        "id": 477815449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351203
    },
    {
        "content": "<p>I'm not strictly wedded to the tactic-based approach; any other metaprogramming device that allows one to easily pass back and forth between equations and laws would be fine.  Duality is the most likely application, but there may be other use cases, for instance through these invariant-based approaches in which an implication between equations is disproven via some syntactic properties of the associated laws.</p>",
        "id": 477815510,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729351254
    },
    {
        "content": "<p>You can pass between equations and laws by definitional unfolding, it just means that the theorem will be restricted to Type instead of Type*, which is actually fine</p>",
        "id": 477815557,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/458659-Equational/topic/Automatically.20proving.20non-implications.20with.20invariants/near/477815557\">said</a>:</p>\n<blockquote>\n<p>You can pass between equations and laws by definitional unfolding, it just means that the theorem will be restricted to Type instead of Type*, which is actually fine</p>\n</blockquote>\n<p>From a law to an equation isn't direct unfolding, you need to define an appropriate function</p>",
        "id": 477815631,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729351351
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303675\">@Anand Rao Tadipatri</span> Will the use of <code>LiftingMagmaFamilyInstance</code> to disprove implications between laws require generating a magma in a Type 1 universe or higher?</p>",
        "id": 477815648,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729351369
    },
    {
        "content": "<p>because if needed we can lift it back up to <code>Type*</code> because that's what <code>models_def'</code> does, but the final theorem needs everything to live in type 0 anyway so it's more a question of lowering all the stuff which isn't at type 0</p>",
        "id": 477815651,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351372
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"690858\">@Daniel Weber</span> ?</p>",
        "id": 477815684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351404
    },
    {
        "content": "<p>Laws are defined as basically a pair of elements of <code>FreeMagma Nat</code>.  They aren't defeq to equations.</p>",
        "id": 477815757,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729351443
    },
    {
        "content": "<p>I guess most of the theorems should be done over equations, not laws?</p>",
        "id": 477815798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351469
    },
    {
        "content": "<p>There is a metaprogram which converts equations to laws which I wrote as part of the <code>equation</code> command rewrite</p>",
        "id": 477815852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351514
    },
    {
        "content": "<p>All the raw implications are proven this equation-based way.  All the metatheorems such as duality theorems are done using laws.</p>",
        "id": 477815867,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729351527
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/458659-Equational/topic/Automatically.20proving.20non-implications.20with.20invariants/near/477815684\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> ?</p>\n</blockquote>\n<p>What?</p>",
        "id": 477815877,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729351533
    },
    {
        "content": "<p>I wanted you to clarify your statement but I think <span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> already did</p>",
        "id": 477815973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351579
    },
    {
        "content": "<p>Currently the metaprogram is being used to prove some iff statement that <code>equation</code> generates, which should hopefully be the only place you have to interact with it</p>",
        "id": 477816025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351627
    },
    {
        "content": "<p>Is there a lean file that enumerates and proves all duality theorems?</p>",
        "id": 477816144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351702
    },
    {
        "content": "<p>in which case the <code>equation_to_law</code> and <code>law_to_equation</code> tactic could essentially be just syntactic sugar for invoking that metaprogram (modulo the issues with different type universes, but the hope was that the tactic would handle all this invisibly).</p>",
        "id": 477816159,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729351715
    },
    {
        "content": "<p>I think you don't want to reuse the metaprogram, you should instead use the iff statements that it added to the environment, which have names like <code>LawN.models_iff</code></p>",
        "id": 477816226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351770
    },
    {
        "content": "<p>I think maybe there is room for another metaprogram which generates duality theorems in both equation and law form</p>",
        "id": 477816335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351830
    },
    {
        "content": "<p>I should take a look at how <code>implies_iff_dual</code> works</p>",
        "id": 477816426,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351899
    },
    {
        "content": "<p>apparently <code>implies_iff_dual</code> is never used?</p>",
        "id": 477816501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351937
    },
    {
        "content": "<p>Yeah precisely because we don't have <code>equation_to_law</code> and <code>law_to_equation</code> yet</p>",
        "id": 477816524,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729351965
    },
    {
        "content": "<p>are there any theorems that want it?</p>",
        "id": 477816535,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729351978
    },
    {
        "content": "<p>we could cut the number of implications we explicitly prove in the codebase by half once it's implemented</p>",
        "id": 477816571,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729352002
    },
    {
        "content": "<p>okay so it's just being done by copy paste right now?</p>",
        "id": 477816589,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729352028
    },
    {
        "content": "<p>it's more that the automated code that generate large numbers of implications or antiimplications by brute force don't do any reduction by duality</p>",
        "id": 477816669,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729352057
    },
    {
        "content": "<p>oh but in that case you could just delete dual theorems and still claim them as proved since there is this duality thing</p>",
        "id": 477816726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729352115
    },
    {
        "content": "<p>we could in principle do the duality reduction right now because we haven't implemented the transitive completion + duality algorithm in Lean, it's only some external script (ruby, I think?) but for the \"final\" theorem we'd want to do that in Lean as well and that's where having internal dual metatheorems that link up with the equations and not the laws would be needed.</p>",
        "id": 477816746,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729352135
    },
    {
        "content": "<p>right</p>",
        "id": 477816773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729352160
    },
    {
        "content": "<p>I think once that last step happens there will be no need to use it via some <code>duality%</code> or <code>equation_to_law</code> tactic, that's an interface meant for humans</p>",
        "id": 477816853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729352203
    },
    {
        "content": "<p>So that was one of the motivations for having <code>equation_to_law</code> and <code>law_to_equation</code> tactics.  Of course there could be other metaprogramming solutions for this.</p>",
        "id": 477816858,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729352207
    },
    {
        "content": "<p>Well these tactics could also be useful for pedagogical purposes.  If we wanted to give a guided tour of proving various implications or anti-implications in Lean in a human readable fashion, having the ability to dualize in a human-readable way would be nice.</p>",
        "id": 477816955,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729352287
    },
    {
        "content": "<p>The approach I'm currently thinking of is a <code>Equations/Duality.lean</code> file that proves <code>LawN &lt;-&gt; LawM</code> and <code>EquationN G &lt;-&gt; EquationM G</code> for every pair <code>N,M</code> of duals</p>",
        "id": 477816957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729352288
    },
    {
        "content": "<p>It's actually <code>EquationN G &lt;-&gt; EquationM G.dual</code> (not sure what the spelling is for the reversed magma of <code>G</code>) [EDIT: I guessed incorrectly, it's actually <code>Op G</code>]</p>",
        "id": 477817009,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729352340
    },
    {
        "content": "<p>ah right, we have to do this on the implication level not the equation level</p>",
        "id": 477817140,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729352422
    },
    {
        "content": "<p>In particular <code>LawN</code> and <code>LawM</code> need not satisfy any obvious implication between them (a few laws are equivalent to their dual, but those are in the minority).</p>",
        "id": 477817148,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729352430
    },
    {
        "content": "<p>I would like a way to present this which doesn't put <code>.dual</code> in the theorem statement</p>",
        "id": 477817199,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729352473
    },
    {
        "content": "<p>I think that would be challenging.</p>",
        "id": 477817231,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729352502
    },
    {
        "content": "<p>I guess you can have <code>IsDual LawN LawM</code> and <code>IsDual' EquationN EquationM</code> which is then consumed by other theorems so that dualizing theorems don't have to work out how to actually dualize by recursion</p>",
        "id": 477817353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729352598
    },
    {
        "content": "<p>I will need to experiment a bit to see if that actually works in practice</p>",
        "id": 477817433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729352655
    },
    {
        "content": "<p>probably you still want a <code>dually%</code> tactic to hide the details of how to apply that</p>",
        "id": 477817441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729352671
    },
    {
        "content": "<p>Are there examples that would benefit from such a tactic today? When do we use an implication in a proof of another implication?</p>",
        "id": 477817534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729352741
    },
    {
        "content": "<p>This only solves the duality issue.  There are other reasons why one would want to convert equations to laws, in particular to invoke the invariant-based metatheorems.  For instance we know that <code>LawX</code> cannot imply <code>LawY</code> if <code>LawX</code> has each variable appear the same number of times on both sides of the equation, and <code>LawY</code> does not.  In order to get from this to the existence of a magma that obeys <code>EquationX</code> but not <code>EquationY</code> one needs something like a <code>law_to_equation</code> tactic.</p>",
        "id": 477817539,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729352749
    },
    {
        "content": "<p>So my general feeling on that is that in such cases you should have a metaprogram which generates all consequences of a rule like that, i.e. one file that proves a bunch of non-implications</p>",
        "id": 477817758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729352892
    },
    {
        "content": "<p>and while doing so it's not hard to present the theorem in any desired form, be it via equations or laws</p>",
        "id": 477817785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729352923
    },
    {
        "content": "<p>Yeah and that's what we currently do.  But for pedagogical purposes I think a tactic that hides all the metaprogramming from view would be more explainable, especially to casual Lean users.</p>",
        "id": 477817829,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729352962
    },
    {
        "content": "<p>Do you have an example?</p>",
        "id": 477817920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729353009
    },
    {
        "content": "<p>It allows for more self-contained looking proofs of implications or anti-implications obtained via metatheorems, without having to first run a large metaprogram</p>",
        "id": 477817929,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729353013
    },
    {
        "content": "<p>Hm, it occurs to me that it would be nice to be able to use <code>Facts</code> for this example but it doesn't apply</p>",
        "id": 477818078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729353132
    },
    {
        "content": "<p>This proof is saying that for all equations A and B where A has the same-variable invariant and B doesn't, A does not imply B, which is exactly the same form as what you get from a <code>Facts</code> application, but there is no single magma <code>G</code> witnessing all of them (or is there?)</p>",
        "id": 477818161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729353233
    },
    {
        "content": "<p><a href=\"https://github.com/teorth/equational_theories/pull/526/files#diff-e246bbd4771fc9a4732cf821dcc7559009178141a90738e7e665ef08231046e2\">https://github.com/teorth/equational_theories/pull/526/files#diff-e246bbd4771fc9a4732cf821dcc7559009178141a90738e7e665ef08231046e2</a> is an example of a large number of anti-implications generated from a metatheorem .  Admittedly no <code>law_to_equation</code> tactic was needed here, but it could conceivably have been deployed to make the proof conceptually more human-readable</p>",
        "id": 477818235,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729353265
    },
    {
        "content": "<p>In this particular example one can take <code>G</code> to be the free abelian group on countably many generators</p>",
        "id": 477818259,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729353289
    },
    {
        "content": "<p>right, this proof strategy looks about what I would suggest, my only proposals would be to maybe make it a bit more presentable with some specialized syntax</p>",
        "id": 477818393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729353366
    },
    {
        "content": "<p>It's an example of a <code>LiftingMagmaFamily</code> which can more generally establish a lot of other anti-implications of this type.  It's true that any specific anti-implication of this type can be achieved using a specific magma, but the point is that one can hide these implementation details and work with the more abstract metatheorem</p>",
        "id": 477818419,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729353399
    },
    {
        "content": "<p>I think <code>law_to_equation</code> is actually code for \"apply <code>LawN.models_iff</code>, possibly behind some syntax or typeclass to keep it clean\"</p>",
        "id": 477818421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729353404
    },
    {
        "content": "<p>yeah basically.  It could be almost entirely syntactic sugar.</p>",
        "id": 477818440,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729353429
    },
    {
        "content": "<p>Is there a way to get these results presented as double implications to avoid the quadratic blowup?</p>",
        "id": 477818556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729353531
    },
    {
        "content": "<p>It is indeed less relevant now when the number of outstanding implications is in the low hundreds and we are not expecting a large number of contributions from the general public.  When I proposed it, there were still tens of thousands of open implications, and it was not clear that ATPs would clear out so many.  I was anticipating a very crowdsourced phase in which we could get members of the public with relatively little Lean experience contributing short individual proofs, and so we would want to give them as user-friendly tools as possible.  This is not really the case any more, but still I think it wouldn't hurt to have these tactics in the codebase.</p>",
        "id": 477818573,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729353554
    },
    {
        "content": "<p>sure, for a \"teaching tactic\" it's a lot easier to design</p>",
        "id": 477818670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729353617
    },
    {
        "content": "<p>my thoughts are mostly in the direction of having a complete proof of 22 million implications with the minimum stress on lean (and also less low entropy text in files)</p>",
        "id": 477818704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729353659
    },
    {
        "content": "<p>I think there is some scope of refactoring the <code>LiftingMagmaFamily</code> stuff using <code>Facts</code> to compress things substantially.  As it turns out, we aren't actually making significant use of this particular tool for the main implication graph (the finite magma examples basically took care of all these implications beforehand), they are mostly being used to demonstrate implications involving the equations past the standard 4692 currently.</p>",
        "id": 477818831,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729353781
    },
    {
        "content": "<p>OK.  Then I think we aren't really in disagreement, we are just focused on slightly different end goals, both of which are worthwhile.</p>",
        "id": 477818883,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729353837
    },
    {
        "content": "<p>Do you know if the existing magma examples also furnish disproofs for the extra equations if you just evaluate them to see what holds or doesn't?</p>",
        "id": 477818946,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729353877
    },
    {
        "content": "<p>I wouldn't be surprised if there is some kind of robertson-seymour-like result here where some finite counterexamples are actually complete for these lifting magma families, at least for bounded variable number</p>",
        "id": 477818999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729353942
    },
    {
        "content": "<p>My guess is that they do, it's just that the finite magma examples weren't run on those extra equations.  We do have some implications which we know for sure that they can only be disproven using infinite magma examples, but they are rather subtle.  Some of the constructions based on confluence may fall under this category (there was some technical debate about saturation that I didn't really follow that may be relevant here).</p>",
        "id": 477819140,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729354060
    },
    {
        "content": "<p>in principle every anti-implication can be proven by at least one lifting magma family because of abstract nonsense, the problem is that most of these families do not have any tractable (or even decidable) description.</p>",
        "id": 477819239,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729354128
    },
    {
        "content": "<p>Ah, so this suggests maybe an additional generalization of <code>Facts</code>, where the thing that links the two sides is not a specific magma but rather a lifting magma family</p>",
        "id": 477819562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729354370
    },
    {
        "content": "<p>and I guess a magma is really just a special kind of lifting magma family (which is presumably the content of your \"abstract nonsense\")</p>",
        "id": 477819611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729354426
    },
    {
        "content": "<p>It's more like a lifting magma family is a universal object in some category of magmas obeying some specified theory, but yeah.</p>",
        "id": 477820238,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729354960
    },
    {
        "content": "<p>Oh yes, looking at the proof now I see that it does actually construct a specific magma <code>G ℕ</code> which witnesses all the invariant-preserving equations</p>",
        "id": 477820300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729355028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/channel/458659-Equational/topic/Automatically.20proving.20non-implications.20with.20invariants/near/477811209\">said</a>:</p>\n<blockquote>\n<p>Would resolving <a href=\"https://github.com/teorth/equational_theories/pull/186\">equational#186</a> help with the final step?  I vaguely recall <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> had some progress on this front, but I don't recall how far it got.</p>\n</blockquote>\n<p>No, I think this is an issue with the definitions in Lean itself. I've asked <a href=\"#narrow/channel/270676-lean4/topic/Running.20.60evalConst.60.20in.20.60Type.201.60/near/477796890\">a question</a> on #lean4 with a minimized example to check if there's a way around this.</p>",
        "id": 477828605,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1729362740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/channel/458659-Equational/topic/Automatically.20proving.20non-implications.20with.20invariants/near/477815648\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303675\">Anand Rao Tadipatri</span> Will the use of <code>LiftingMagmaFamilyInstance</code> to disprove implications between laws require generating a magma in a Type 1 universe or higher?</p>\n</blockquote>\n<p>The magma generated using a <code>LiftingMagmaFamilyInstance</code> is not necessarily in <code>Type 1</code> or higher universes (and in all the cases so far, the model is in <code>Type</code>).</p>",
        "id": 477828889,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1729363050
    },
    {
        "content": "<p>Oh, okay.  So the appearance of higher type Magmas in our codebase is still purely a future theoretical possibility at present.</p>",
        "id": 477828966,
        "sender_full_name": "Terence Tao",
        "timestamp": 1729363109
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/458659-Equational/topic/Automatically.20proving.20non-implications.20with.20invariants/near/477816957\">said</a>:</p>\n<blockquote>\n<p>The approach I'm currently thinking of is a <code>Equations/Duality.lean</code> file that proves <code>LawN &lt;-&gt; LawM</code> and <code>EquationN G &lt;-&gt; EquationM G</code> for every pair <code>N,M</code> of duals</p>\n</blockquote>\n<p>I've implemented this (ish) In <a href=\"https://github.com/teorth/equational_theories/pull/769\">equational#769</a>, so in particular all duality claims are now being checked by lean</p>",
        "id": 479977771,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730420724
    },
    {
        "content": "<p>cool, it's a nice approach to define a new <code>dual</code> command and just give them to Lean as annotations! I put off/(had given up on) doing this because I didn't want to write the meta code for doing all of that directly in meta, and didn't think of this solution</p>",
        "id": 480001835,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1730441175
    }
]