[
    {
        "content": "<p>This request is not aimed at the immediate goal of completing the implication graph in Lean, but for the second stage goal of writing a paper reporting on the results.</p>\n<p>A key component of this paper will be describing various automated techniques (e.g., deploying ATPs such as Vampire, using finite magmas to generate counterexamples, etc.), and it would be good to have metrics on how they would perform <em>in isolation</em> on this problem.  This is distinct from how they were deployed <em>in reality</em>, in which later runs could benefit from the implications already eliminated in earlier runs; also, due to various post-optimizations to the Lean codebase (e.g., transitive reductions of the implication graph), the current portion of the codebase corresponding to a given run may not be indicative of the absolute performance of that run.</p>\n<p>So, while the implementation details of runs are still fresh in the minds of those contributors who programmed these runs, I would like to set up this (long term) thread to ask all of these contributors, when they have the time and spare CPU, to run their programs again against the entire implication graph (or some random sample thereof, if the entire graph is too computationally intractable to cover), and record the results, including metrics such as</p>\n<ul>\n<li>Number of implications/anti-implications resolved (with data sets recording the specific statements resolved, if possible).</li>\n<li>CPU time (and hardware used)</li>\n<li>Any other implementation notes of interest </li>\n</ul>\n<p>These would <em>not</em> go into the (already optimized) Lean codebase, but the data files generated could go into the <code>data</code> folder, and implementation notes could also go into relevant blueprint chapters.</p>\n<p>This is not an urgent priority - the paper writing is likely weeks or months away still - but I can imagine that some of the older runs may be harder to execute after some time due to fading memories (and also some technical changes to the repository data formats).  Also, I think having all the different contributors report their statistics in this common location may be enlightening for the entire project community.</p>\n<p>EDITED TO ADD: This request is not aimed only at the most \"successful\" runs (if measured by how much they reduced the number of outstanding implications), but also the runs which may not have numerically achieved significant reduction in outstanding implications.  This will be important for comparative analysis (and also some runs may have actually been significantly more effective than they seemed in reality, because they were able to resolve many implications that had already been worked out by earlier runs).  (Also, this accords with the general scientific principle that negative results need to be published as well as positive ones.)</p>",
        "id": 476416509,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728662153
    },
    {
        "content": "<p>I think it would be better to instead record here (or somewhere else and link here) the instructions to reproduce these ATP runs. This information will need to be included in the paper anyway, and having reproduction instructions means it will be possible to wait until the paper is actually nearing publication to do the runs, rather than have them run now on what is still likely not the final project result</p>",
        "id": 476417448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728662439
    },
    {
        "content": "<p>Very good points. The emphasis for now should be on recording a replicable process and perhaps a preliminary projection of what the metrics would look like, but we can defer the full runs until we have agreed on a systematic and standardized framework to run them all.</p>",
        "id": 476429291,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728666994
    },
    {
        "content": "<p>In particular, I can see that it makes sense to ultimately perform a lot of these runs on a common set of hardware in order to be able to have an apples-to-apples comparison of performance.</p>",
        "id": 476445311,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728674151
    },
    {
        "content": "<p>there's also the question of which (subset) of the implications to consider, e.g. the entire ~4700^2, or a \"minimal\" subset known to be sufficient to establish all of them via transitivity/duality, or e.g. the known implications and non-implications separately. </p>\n<p>In the case of the egg tactic, for example, it cannot prove the non-implications, so it's kind if a waste of time and computation to run it on them, but it is part of a fair apples-to-apples comparison (and it's also what we did at the time, albeit just for subgraph, not knowing if an implication held or not).</p>",
        "id": 476539911,
        "sender_full_name": "Andr√©s Goens",
        "timestamp": 1728754329
    },
    {
        "content": "<p>ATPs are generally graded on how many problems they can solve within a time limit (for increasing values of the time limit). So non-implications are not counted against it, but the asymptote will be the overall performance</p>",
        "id": 476540276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728754703
    },
    {
        "content": "<p>you can think of this as running a race with an independent solver for each problem, where you plot how many solvers crossed their respective finish lines as a function of time</p>",
        "id": 476540431,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728754850
    },
    {
        "content": "<p>When grading time to solve for an ATP is there a set of predefined computational specs?</p>",
        "id": 476540713,
        "sender_full_name": "Joe McCann",
        "timestamp": 1728755131
    },
    {
        "content": "<p>what do you mean by that?</p>",
        "id": 476540731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728755156
    },
    {
        "content": "<p>it's a comparative method, you throw a bunch of different solvers at the problem and see how they do which tells you how good the solvers are on this kind of problem</p>",
        "id": 476540795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728755194
    },
    {
        "content": "<p>the baseline is usually to take the problem and encode it directly in a well-known off the shelf standard solver, e.g. vampire</p>",
        "id": 476540864,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728755270
    },
    {
        "content": "<p>So I guess one is grading not just the ATP, but whatever metastrategy is used to select the implications or anti-implications to try to prove.  For instance if one is given in advance what implications are actually true or not, this would greatly advantage an ATP that can only prove one of the two types of implications, as it can focus its CPU cycles on the ones that it can actually solve.</p>",
        "id": 476540933,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728755304
    },
    {
        "content": "<p>well like I said we're not putting non-implications on the plot. In the race I described, some of the solvers don't actually have a finish line but don't know it; but they will not appear in the stats because they won't finish</p>",
        "id": 476541007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728755384
    },
    {
        "content": "<p>there is another mode where you count the total number of problems solved by a <em>single</em> solver multiplexing over all the problems, and here you do get penalized if you spend time on unsolvable problems. But I wasn't suggesting that</p>",
        "id": 476541120,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728755461
    },
    {
        "content": "<p>Here's an example, <a href=\"https://content.iospress.com/articles/journal-on-satisfiability-boolean-modeling-and-computation/sat190120\">Fig. 2 of a recent SAT competition publication</a></p>\n<p><a href=\"/user_uploads/3121/AsYSB16vbxcKxzrSLDR2c0Nk/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/AsYSB16vbxcKxzrSLDR2c0Nk/image.png\" title=\"image.png\"><img data-original-dimensions=\"1000x994\" src=\"/user_uploads/thumbnail/3121/AsYSB16vbxcKxzrSLDR2c0Nk/image.png/840x560.webp\"></a></div>",
        "id": 476541352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728755675
    },
    {
        "content": "<p>there are probably more than 240 problems in the competition, but the plot does not focus on benchmark problems that no one solved</p>",
        "id": 476541445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728755762
    },
    {
        "content": "<p>What this plot does not tell you is how \"complementary\" the different solvers are - it might be that they are solving completely different sets or almost the same set or a strict subset of some other solver. For this information I usually see it presented as a table where you show how many problems are solved by the union of the best N methods, up to the full list, so you can see how much additional is added with the second and later methods</p>",
        "id": 476541745,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728756054
    },
    {
        "content": "<p>Do we have to limit ourselves to the traditional measurements?</p>",
        "id": 476542917,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728757172
    },
    {
        "content": "<p>If we want to tell mathematicians which solvers help them with what, it seems useful to also compare solvers against non-implications</p>",
        "id": 476542979,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728757209
    },
    {
        "content": "<p>So I guess once we select a set of implications as benchmarks, there appear to be standard ways in the literature to measure performance of tools against those benchmarks.  If so, the remaining question would be how to select a suite of benchmarks to test against.</p>\n<p>One obvious benchmark is to just randomly select N assertions <code>EquationX =&gt; EquationY</code> (which may be true or false) for some medium value of N, such as N = 5000.  But then we will likely miss almost completely the few hundred \"interesting\" equations that we are currently focusing on.</p>\n<p>We could also benchmark against randomly selected true assertions (about a third of the total), or randomly selected false assertions (about two thirds of the total), but again we miss out on the interesting ones.</p>\n<p>We could select on those equations that take some standard ATP such as Vampire more than some time limit to resolve, thus focusing on the \"interesting\" equations, but then of course we could not test Vampire against that benchmark in any unbiased fashion.  We could instead take some weighted basket of ATPs perhaps to perform the filtering?</p>\n<p>Maybe there are some other suggestions.  For instance we might be able to use the implication graph itself (once we have completed it) to somehow identify the \"interesting\" implications in some ATP-agnostic fashion, but I don't see how to do this offhand.</p>",
        "id": 476545493,
        "sender_full_name": "Terence Tao",
        "timestamp": 1728759723
    },
    {
        "content": "<p>As long as you have enough time to prepare the data (and I think you do), I would suggest running the tools until a relatively large limit on every problem, except for the ones for which you know they will time out (i.e. non-implications). Selecting a random subset is only needed if testing on the whole data set is impractical.</p>",
        "id": 476545806,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728760038
    },
    {
        "content": "<p>I agree that random sampling is not good for this setting, since it seems like 99.8% of the problems are easy</p>",
        "id": 476545885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728760089
    },
    {
        "content": "<p>you could bias toward the known hard problems, but in that case you might as well sweep up all the easy problems while you are at it</p>",
        "id": 476545922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728760151
    },
    {
        "content": "<p>I realize it looks like cheating to use your current knowledge of implications and non-implications to early prune the data before testing, but running a proof search when you know there is no proof or a countermodel search when there is no countermodel is just a waste of time, the only thing this would test is unsoundness bugs in the solvers</p>",
        "id": 476546102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728760351
    },
    {
        "content": "<p>Yeah, for testing implications I'm not sure why the test wouldn't just be of the implications in the reduction, that way you can test every single equation and not have to determine which ones are easy vs hard, and the reduction is &lt;10k. But the problem is equivalence classes: 1) From class1-&gt;class2, do you let the solver try every combination or just pick a single one, and 2) how to establish the equivalence class itself. You could pick a hamiltonian cycle that the provers have to prove, but some may not be able to accomplish that particular cycle though they would have found another way to complete the equivalence class otherwise.</p>",
        "id": 476604254,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1728824113
    },
    {
        "content": "<p>For non-implications the set of all 'facts' on main is pretty small, about ~1k I believe? But there may be the same combinatorial problem with choosing which elements from equivalence class 1 -&gt; 2 you test. I guess the facts are more general than what an ATP would give you for specifically establishing a refutation between two specific equations, but I think the total reduction size is still fairly small, &lt;20k?</p>",
        "id": 476604452,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1728824300
    },
    {
        "content": "<p>Made this kind of workflow using snakemake for inspiration. We could also use lineage tools that are commonly used in ML.</p>\n<p>Pipeline: Data ingestion-&gt;Data preprocessing-&gt;ATP-&gt;Metrics collection-&gt;Post-processing and analysis-&gt;Reporting and documentation</p>\n<p>Lineage: Version control, Metadata management, Automated logging, Reproducibility scripts</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"w\"> </span><span class=\"n\">Snakefile</span>\n\n<span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">input</span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"s2\">\"data/metrics.csv\"</span><span class=\"o\">,</span>\n<span class=\"w\">        </span><span class=\"s2\">\"reports/analysis.pdf\"</span>\n\n<span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">preprocess</span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">input</span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"s2\">\"../data/outcomes.png\"</span>\n<span class=\"w\">    </span><span class=\"n\">output</span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"s2\">\"../data/implications.json\"</span>\n<span class=\"w\">    </span><span class=\"n\">shell</span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"n\">python</span><span class=\"w\"> </span><span class=\"n\">select_subset</span><span class=\"bp\">.</span><span class=\"n\">py</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">input</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">output</span><span class=\"o\">}</span>\n\n<span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">run_atps</span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">input</span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"s2\">\"../data/implications.json\"</span>\n<span class=\"w\">    </span><span class=\"n\">output</span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"s2\">\"../data/atp_results.json\"</span>\n<span class=\"w\">    </span><span class=\"n\">shell</span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"n\">python</span><span class=\"w\"> </span><span class=\"n\">scripts</span><span class=\"bp\">/</span><span class=\"n\">run_atps</span><span class=\"bp\">.</span><span class=\"n\">py</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">input</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">output</span><span class=\"o\">}</span>\n\n<span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">collect_metrics</span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">input</span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"s2\">\"data/atp_results.json\"</span>\n<span class=\"w\">    </span><span class=\"n\">output</span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"s2\">\"../data/metrics.csv\"</span>\n<span class=\"w\">    </span><span class=\"n\">shell</span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"n\">python3</span><span class=\"w\"> </span><span class=\"n\">collect_metrics</span><span class=\"bp\">.</span><span class=\"n\">py</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">input</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">output</span><span class=\"o\">}</span>\n\n<span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">analyze</span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">input</span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"s2\">\"../data/outcomes.csv\"</span>\n<span class=\"w\">    </span><span class=\"n\">output</span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"s2\">\"reports/outcome_analysis.pdf\"</span>\n<span class=\"w\">    </span><span class=\"n\">shell</span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">script</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">input</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">output</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 477440926,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1729170979
    }
]