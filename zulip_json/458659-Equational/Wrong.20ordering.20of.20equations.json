[
    {
        "content": "<p>There are two issues with the various places where we described and implemented the equation ordering, so I am worried there might be more.  Extra eyes would be welcome.  I take the lists of 4694 equations of size ≤4 in the <a href=\"https://github.com/teorth/equational_theories/tree/main/equational_theories/Equations\">Equations directory</a> as ground truth because it is Lean code used in our formal proofs.  (By \"size\" I mean what we usually call \"order\", but this word would lead to confusion here.)</p>\n<p>The ordering stated in appendix A <a href=\"https://teorth.github.io/equational_theories/paper.pdf\">of the paper</a> compares laws or expressions by their size first, then by their left-hand side or left operand (recursively), then the right one.  However, our lists of equation numbers include for instance</p>\n<ul>\n<li>Equation 307: x ◇ x = x ◇ (x ◇ x)</li>\n<li>Equation 322: x ◇ y = x ◇ (x ◇ x)</li>\n<li>Equation 359: x ◇ x = (x ◇ x) ◇ x</li>\n</ul>\n<p>which makes it clear that we first consider the shape, and only afterwards consider the ordering of variables.  If we really began by looking at the left-hand sides as stated in the paper, then we would have <code>eq307&lt;eq359&lt;eq322</code>.  I think the same mistake is made at the end of <a href=\"https://teorth.github.io/equational_theories/blueprint/basic-theory-chapter.html\">Chapter 1 of the blueprint</a>.</p>",
        "id": 492307650,
        "sender_full_name": "Bruno Le Floch",
        "timestamp": 1736255785
    },
    {
        "content": "<p>The second issue is a long-standing bug, at least in <a href=\"https://github.com/teorth/equational_theories/blob/main/scripts/find_equation_id.py\">the script <code>find_equation_id.py</code></a>, in the case of balanced equations (same left and right sizes) of total size 8 and above.  It does not seem to affect <a href=\"https://github.com/teorth/equational_theories/blob/main/scripts/generate_eqs_list.py\">the script <code>generate_eqs_list.py</code></a>.  Because the equation ordering takes into account size and shape recursively, and then variables, it is easily implemented through nested loops.  Shapes of given sizes are generated correct sorted by <code>all_shapes</code> (previously <code>generate_shapes</code>) and then filled with variables in a second step.  To avoid redundant equations that only differ by swapping left and right sides, we loop only through lhs sizes up to half of the total size, and for balanced equations (same left/right sizes), we compare the lhs and rhs shapes before deciding whether to keep that pair of shapes.  This is where the bug lies: the shape comparison is not consistent with the ordering produced by <code>all_shapes</code>, so we end up keeping the \"wrong\" equation between lhs=rhs and rhs=lhs.  The inconsistency is that the shape comparison only takes into account the size at top level, which shows up first for <code>((x*x)*x)*(x*x)</code> and <code>(x*(x*(x*x)))*x</code>:</p>\n<ul>\n<li><code>((x*x)*x)*(x*x)</code> comes before <code>(x*(x*(x*x)))*x</code> according to <code>all_shapes</code>, and this is correct, but</li>\n<li>the shape comparison sees they have the same size, then compares them recursively without any further size comparison, so it compares their left operands <code>(x*x)*x</code> and <code>x*(x*(x*x))</code>, then compares left operands thereof, <code>x*x</code> and <code>x</code>, and finds the first shape to be larger.</li>\n</ul>\n<p>In <code>all_eqs</code> (previously <code>generate_all_eqs</code>), this shows up (very slowly since we're talking about equation numbers around 3e8!) by failing to have <code>Equation 295980737: ((x ◇ x) ◇ x) ◇ (x ◇ x) = (x ◇ (x ◇ (x ◇ x))) ◇ x</code>, and instead having <code>((x ◇ x) ◇ x) ◇ (x ◇ x) = ((x ◇ x) ◇ (x ◇ x)) ◇ x</code> directly (not actually tested, sorry!).  In the code to go back and forth from an equation to its id it shows up as mostly non-sensical mappings that are not inverses of each other, because my calculations of ids did not anticipate this problem.  I'll fix that.</p>",
        "id": 492307756,
        "sender_full_name": "Bruno Le Floch",
        "timestamp": 1736255828
    },
    {
        "content": "<p>So IIUC the idea is to redefine our algorithm (that is, the explanation) to match what we actually did for problem <a href=\"https://github.com/leanprover-community/mathlib4/pull/1\">#1</a>, and since the occasional dabbling with really high equation numbers has been mostly exploratory, just fix the bug for problem <a href=\"https://github.com/leanprover-community/mathlib4/pull/2\">#2</a>?</p>",
        "id": 492424022,
        "sender_full_name": "Douglas McNeil",
        "timestamp": 1736303713
    },
    {
        "content": "<p>Ugh, sorry for not spotting this earlier.  I've tried to implement a fix for <a href=\"https://github.com/leanprover-community/mathlib4/pull/1\">#1</a> in <a href=\"https://github.com/teorth/equational_theories/pull/1041\">equational#1041</a>.</p>",
        "id": 492441124,
        "sender_full_name": "Terence Tao",
        "timestamp": 1736317094
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"341148\">@Douglas McNeil</span> Yes, that's a good summary of the situation.  I have some fix incoming for the second problem.  Indeed, we have used some order-8 equations in the Higman-Neumann characterization of groups, but of the form <code>x=RHS</code>, which are not affected by this bug.</p>\n<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> Thanks! I've added a review on Github pointing out typos and related.</p>",
        "id": 492459467,
        "sender_full_name": "Bruno Le Floch",
        "timestamp": 1736326637
    }
]