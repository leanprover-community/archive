[
    {
        "content": "<p>The very notion of displayed categories requires some casting operation between the hom-over types <code>X ‚ü∂[f] Y</code> and <code>X ‚ü∂[g] Y</code>, whenever <code>f = g</code>. While this was good for unimath, since they do a lot of casting everywhere, this doesn't really fit into the mathlib approach of developing application specific lemmas, so as to make automation as powerful as possible.</p>\n<p>Another reasonable approach, is considering semi-displayed categories (Example 8.14 <a href=\"https://arxiv.org/pdf/2102.06275\">here</a>). Essentially, only the objects are indexed, whereas the hom-over types are independent of the ones below. This allows for removing all casts, while keeping the fiber (of objects) to be judgmentally over their base. An analogous notion makes the objects indexed, but requires the Sigma to be a category (this was suggested to me by <span class=\"user-mention\" data-user-id=\"648495\">@Christian Merten</span> ). I call this the total semi-displayed version below.</p>\n<p>Still, I wanted to see a clear comparison so I <a href=\"https://github.com/FernandoChu/DisplayedComparison\">partially formalized</a> that the grothendieck construction is a fibration, in three of the available options. Here are my conclusions:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Current Mathlib approach (Functor into <code>C</code>)</th>\n<th>Semi-displayed (total)</th>\n<th>Semi-displayed</th>\n<th>Displayed</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Doesn't involve casts between morphisms</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Fiber over <code>c</code> is judgmentally over it. I.e. <code>(x : Fiber c)</code> implies <code>pi x</code> defeqs <code>c</code>.</td>\n<td>No</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Morphisms over <code>f:c‚ü∂d</code> are judgmentally over it.</td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Composition in the total/base category (i.e. the one that maps to <code>C</code>) is <code>‚â´</code></td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Machinery already defined can be easily used (e.g. functors, nattrans, etc)</td>\n<td>Yes</td>\n<td>Yes (kindof)</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Approach extends to other structures (e.g. bicats, double cats, ncats, etc)</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n</tbody>\n</table>\n<p>The properties are intended to be roughly ordered from more to less important. Given this, I'm doubting quite a bit displayed cats are a good fit for mathlib. I instead am thinking that the semi-displayed total version is the better one.</p>\n<p>Any comments on this are very much appreciated. May interest you <span class=\"user-mention\" data-user-id=\"755399\">@Niels van der Weide</span> .</p>",
        "id": 515856078,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1746253463
    },
    {
        "content": "<p>Awsome, nice comparison!</p>\n<p>Some questions that arose for me:</p>\n<ul>\n<li>Does requiring the Sigma to be a category limit applications? I'm guessing this is fine in our case, but for general applicability? I think it just limits the homovers to be sets, right? </li>\n<li>Are the \"judgemental over\" rows something that can be mitigated/solved with automation? If yes, that might suggest that the current mathlib approach might be the best even for us.</li>\n</ul>",
        "id": 516361730,
        "sender_full_name": "Pim Otte",
        "timestamp": 1746514152
    },
    {
        "content": "<p>Re 1: No, it does not limit the homovers to be sets. You can ask for the sigma type to be a category with <code>Hom</code> types in an arbitrary universe, independent of the universe of objects.</p>",
        "id": 516362191,
        "sender_full_name": "Christian Merten",
        "timestamp": 1746514338
    },
    {
        "content": "<p>Re 2: This is attempted with the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.IsHomLiftAux#doc\">docs#CategoryTheory.IsHomLiftAux</a> type, it fails when the appearing terms are not free variables though. The \"I wish to be in set theory tactic\" we tried to write, was precisely an attempt at solving this with automation, but we failed miserably.</p>",
        "id": 516362759,
        "sender_full_name": "Christian Merten",
        "timestamp": 1746514562
    },
    {
        "content": "<p>Re 1: It does not limit applications, but it does make some things slightly cumbersome. E.g., if one wants to use some fact about fibrations for some functor <code>C =&gt; D</code>, they will have to replace <code>C</code> by its Sigma version (this also happens in the other non-current-mathlib approaches). It is not completely clear to me that the single improvement (second row) outweighs this and the other problems...</p>",
        "id": 516374647,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1746518148
    },
    {
        "content": "<p>My conjecture is that row 2 is mostly useful for results about abstract categories (i.e. <code>variable C : Cat</code>), and that actual concrete categories will satisfy row 2 by construction; e.g., this happens in the Grothendieck construction. But for abstract cats, the current mathlib approach will also give some version of row 2 by their <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/FiberedCategory/HomLift.html#CategoryTheory.IsHomLiftAux\">IsHomLiftAux trick</a> (not clear to me yet how this precisely compares to other approaches).</p>",
        "id": 516376503,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1746518627
    },
    {
        "content": "<p>Ultimately, your project will show that every fibred / displayed category is equivalent to one where row 2 holds.</p>",
        "id": 516377102,
        "sender_full_name": "Christian Merten",
        "timestamp": 1746518769
    },
    {
        "content": "<p>I guess, but this is a very roundabout way of showing that. This can also be seen immediately because you don't need to show that the fiber function is a pseudofunctor, and you just define a category structure on the sigma by <code>hom((x,y),(x',y')) := hom(y,y')</code>. The resulting cat will be isomorphic to the original one.</p>",
        "id": 516377682,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1746518930
    },
    {
        "content": "<p>I don't understand what <code>hom(y, y')</code> means. Are <code>y</code> and <code>y'</code> even objects of the same category? In other words, what is the indexing type and the components of the sigma type?</p>",
        "id": 516378319,
        "sender_full_name": "Christian Merten",
        "timestamp": 1746519076
    },
    {
        "content": "<p>Maybe a clearer way to see it is that for any <strong>function</strong> <code>f : B -&gt; A</code>, if we write <code>f‚Åª¬π : A -&gt; Type</code> for the fiber function, then <code>Sigma f‚Åª¬π</code> is isomorphic (as a type) to <code>B</code>. So now if <code>f</code> is a functor, we can define the category structure of the Sigma to be the one induced by this isomorphism</p>",
        "id": 516378849,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1746519222
    },
    {
        "content": "<p>Wondering if you have any thoughts about this <span class=\"user-mention\" data-user-id=\"420917\">@Sina Hazratpour ìÉµ</span> . In particular, did you have some plan on how to deal with casts of morphisms? I'm currently inclined to drop the displayed approach and only use the current in mathlib together with the <code>HasFibers</code> <a href=\"https://github.com/leanprover-community/mathlib4/pull/13611\">class</a>.</p>",
        "id": 517881050,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1747155418
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"587858\">Fernando Chu</span> <a href=\"#narrow/channel/500728-Displayed-Categories/topic/Alternative.20notions.20of.20displayed.20categories/near/515856078\">said</a>:</p>\n<blockquote>\n<p>this doesn't really fit into the mathlib approach of developing application specific lemmas, so as to make automation as powerful as possible.</p>\n</blockquote>\n<p>Could you say a bit more about this? I'm experienced with displayed categories in Agda and would like to understand why this would be bad for tactics</p>",
        "id": 524807029,
        "sender_full_name": "Max New",
        "timestamp": 1750300330
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115247\">Max New</span> <a href=\"#narrow/channel/500728-Displayed-Categories/topic/Alternative.20notions.20of.20displayed.20categories/near/524807029\">said</a>: ...</p>\n<p>Hi Max! I didn't mean to imply this is bad for tactics in general, just bad for the tactics that have already been developed in mathlib. Transport/HEq is avoided whenever possible, and in particular for categories the current approach is using <code>eqToHom</code>s everywhere to avoid mention of transports. So, a lot of (simp) lemmas have been developed and will be continued to be developed for results about <code>eqToHom</code>.</p>\n<p>So, instead of redeveloping the analogue of these for transports, I think it's better to just adapt and extend the current <code>eqToHom</code> approach for fibered categories. Unless one intends to do huge amounts of fibered category theory I think this is much more time efficient, while also contributing to other non-fibered application.</p>\n<p>Also, just 3 days ago the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/FiberedCategory/HasFibers.html#HasFibers\"><code>HasFibers</code></a> class was introduced, which can be used for recovering some judgemental equalities for concrete examples (see there for further discussions).</p>\n<p>By the way, what is your use case for displayed stuff? Is it for displayed virtual equipments?</p>",
        "id": 524834349,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1750320063
    },
    {
        "content": "<p>I've been trying to formalize properties about fibrations to do logical relations proofs in a more re-usable/compositional way. Some of it is upstreamed into the <code>cubical</code> library and a lot of it is in my extension my students and I work on: <a href=\"https://github.com/maxsnew/cubical-categorical-logic\">https://github.com/maxsnew/cubical-categorical-logic</a> . The most complete result is constructing canonicity proofs for free cartesian categories: <a href=\"https://github.com/maxsnew/cubical-categorical-logic/blob/main/Gluing/CartesianCategory.agda\">https://github.com/maxsnew/cubical-categorical-logic/blob/main/Gluing/CartesianCategory.agda</a> . I also did the coherence theorem for monoidal categories using displayed categories here: <a href=\"https://github.com/maxsnew/cubical-categorical-logic/blob/main/Cubical/Categories/Constructions/Free/Monoidal/Coherence.agda\">https://github.com/maxsnew/cubical-categorical-logic/blob/main/Cubical/Categories/Constructions/Free/Monoidal/Coherence.agda</a></p>",
        "id": 524843638,
        "sender_full_name": "Max New",
        "timestamp": 1750323630
    },
    {
        "content": "<p>Cool! I don't really know the displayed cats approach to these results, but I'd imagine that the <code>HasFibers</code> class will be very useful for this :)</p>",
        "id": 524855214,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1750328283
    }
]