[
    {
        "content": "<p>mathlib's algebraic hierarchy design involves a lot of \"defeq diamonds\" which I have parodied in the following form.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Gr</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"n\">add_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">add</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">add</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">gr1</span> <span class=\"o\">:</span> <span class=\"n\">Gr</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n  <span class=\"n\">add</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span>\n  <span class=\"n\">add_comm</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.add_comm</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">gr2</span> <span class=\"o\">:</span> <span class=\"n\">Gr</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n  <span class=\"n\">add</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span>\n  <span class=\"n\">add_comm</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n    <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span>\n    <span class=\"k\">from</span> <span class=\"n\">Nat.add_comm</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.isDefEq</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">gr1</span> <span class=\"bp\">=</span> <span class=\"n\">gr2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>To check that <code>gr1</code> and <code>gr2</code> are defeq Lean checks that the <code>add</code> fields are defeq three times. The last two are to check that the types of the <code>add_comm</code> fields are defeq. But of course they have to be once the <code>add</code> fields are, because that's how structures work.<br>\nCouldn't Lean do better here?<br>\n(The trace output below is actually printed twice, but I think that's due to some detail of the way I set up the defeq test.)</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>trace output</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>[Meta.isDefEq] ✅ gr1 = gr2 =?= ?m.740 = ?m.740\n  [Meta.isDefEq] ✅ Gr Nat =?= ?m.739\n    [Meta.isDefEq] Gr Nat [nonassignable] =?= ?m.739 [assignable]\n    [Meta.isDefEq] ✅ Sort ?u.738 =?= Type\n  [Meta.isDefEq] ✅ gr1 =?= ?m.740\n    [Meta.isDefEq] gr1 [nonassignable] =?= ?m.740 [assignable]\n    [Meta.isDefEq] ✅ Gr Nat =?= Gr Nat\n  [Meta.isDefEq] ✅ gr2 =?= gr1\n    [Meta.isDefEq] ✅ gr2 =?= gr1\n      [Meta.isDefEq] ✅ gr2 =?= { add := fun x y =&gt; x + y, add_comm := gr1.proof_1 }\n        [Meta.isDefEq] ✅ Gr Nat =?= Gr Nat\n        [Meta.isDefEq] ✅ gr2.add =?= fun x y =&gt; x + y\n          [Meta.isDefEq] ✅ fun x y =&gt; x + y =?= fun a =&gt; Gr.add gr2 a\n            [Meta.isDefEq] ✅ Nat =?= Nat\n            [Meta.isDefEq] ✅ fun y =&gt; x + y =?= Gr.add gr2 x\n              [Meta.isDefEq] ✅ fun y =&gt; x + y =?= fun a =&gt; Gr.add gr2 x a\n                [Meta.isDefEq] ✅ Nat =?= Nat\n                [Meta.isDefEq] ✅ x + y =?= Gr.add gr2 x y\n                  [Meta.isDefEq] ✅ x + y =?= gr2.1 x y\n                    [Meta.isDefEq] ✅ x + y =?= x + y + 0\n                      [Meta.isDefEq] ✅ instHAdd.1 x y =?= instHAdd.1 (x + y) 0\n                        [Meta.isDefEq] ✅ Add.add x y =?= Add.add (x + y) 0\n                          [Meta.isDefEq] ✅ instAddNat.1 x y =?= instAddNat.1 (x + y) 0\n                            [Meta.isDefEq] ✅ Nat.add x y =?= Nat.add (x + y) 0\n                              [Meta.isDefEq] ❌ x =?= x + y\n                                [Meta.isDefEq] ❌ x =?= instHAdd.1 x y\n                                  [Meta.isDefEq] ❌ x =?= Add.add x y\n                                    [Meta.isDefEq] ❌ x =?= instAddNat.1 x y\n                                      [Meta.isDefEq] ❌ x =?= Nat.add x y\n                                        [Meta.isDefEq.onFailure] ❌ x =?= Nat.add x y\n                              [Meta.isDefEq] ✅ Nat.add x y =?= x + y\n                                [Meta.isDefEq] ✅ Nat.add x y =?= Nat.add x y\n        [Meta.isDefEq] ✅ gr2.add_comm =?= gr1.proof_1\n          [Meta.isDefEq] ✅ ∀ (a b : Nat), Gr.add gr2 a b = Gr.add gr2 b a =?= ∀ (x y : Nat), x + y = y + x\n            [Meta.isDefEq] ✅ Nat =?= Nat\n            [Meta.isDefEq] ✅ Nat =?= Nat\n            [Meta.isDefEq] ✅ Gr.add gr2 a b = Gr.add gr2 b a =?= a + b = b + a\n              [Meta.isDefEq] ✅ Gr.add gr2 a b =?= a + b\n                [Meta.isDefEq] ✅ gr2.1 a b =?= a + b\n                  [Meta.isDefEq] ✅ a + b + 0 =?= a + b\n                    [Meta.isDefEq] ✅ instHAdd.1 (a + b) 0 =?= instHAdd.1 a b\n                      [Meta.isDefEq] ✅ Add.add (a + b) 0 =?= Add.add a b\n                        [Meta.isDefEq] ✅ instAddNat.1 (a + b) 0 =?= instAddNat.1 a b\n                          [Meta.isDefEq] ✅ Nat.add (a + b) 0 =?= Nat.add a b\n                            [Meta.isDefEq] ❌ a + b =?= a\n                              [Meta.isDefEq] ❌ instHAdd.1 a b =?= a\n                                [Meta.isDefEq] ❌ Add.add a b =?= a\n                                  [Meta.isDefEq] ❌ instAddNat.1 a b =?= a\n                                    [Meta.isDefEq] ❌ Nat.add a b =?= a\n                                      [Meta.isDefEq.onFailure] ❌ Nat.add a b =?= a\n                            [Meta.isDefEq] ✅ a + b =?= Nat.add a b\n                              [Meta.isDefEq] ✅ Nat.add a b =?= Nat.add a b\n              [Meta.isDefEq] ✅ Gr.add gr2 b a =?= b + a\n                [Meta.isDefEq] ✅ gr2.1 b a =?= b + a\n                  [Meta.isDefEq] ✅ b + a + 0 =?= b + a\n                    [Meta.isDefEq] ✅ instHAdd.1 (b + a) 0 =?= instHAdd.1 b a\n                      [Meta.isDefEq] ✅ Add.add (b + a) 0 =?= Add.add b a\n                        [Meta.isDefEq] ✅ instAddNat.1 (b + a) 0 =?= instAddNat.1 b a\n                          [Meta.isDefEq] ✅ Nat.add (b + a) 0 =?= Nat.add b a\n                            [Meta.isDefEq] ❌ b + a =?= b\n                              [Meta.isDefEq] ❌ instHAdd.1 b a =?= b\n                                [Meta.isDefEq] ❌ Add.add b a =?= b\n                                  [Meta.isDefEq] ❌ instAddNat.1 b a =?= b\n                                    [Meta.isDefEq] ❌ Nat.add b a =?= b\n                                      [Meta.isDefEq.onFailure] ❌ Nat.add b a =?= b\n                            [Meta.isDefEq] ✅ b + a =?= Nat.add b a\n                              [Meta.isDefEq] ✅ Nat.add b a =?= Nat.add b a\n              [Meta.isDefEq] ✅ Nat =?= Nat\n[Meta.isDefEq] ✅ Gr Nat =?= Gr Nat\n[Meta.isDefEq] ✅ Gr Nat =?= Gr Nat\n[Meta.isDefEq] ✅ Gr Nat =?= Gr Nat\n[Meta.isDefEq] ✅ Gr Nat =?= ?m.737\n  [Meta.isDefEq] Gr Nat [nonassignable] =?= ?m.737 [assignable]\n  [Meta.isDefEq] ✅ Sort ?u.736 =?= Type\n[Meta.isDefEq] ✅ Gr Nat =?= Gr Nat\n</code></pre></div>\n</div></div>",
        "id": 324548803,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675066936
    },
    {
        "content": "<p>This is extremely bad when combined with the way Lean checks defeq of projections (which <a href=\"https://github.com/leanprover/lean4/pull/2003\">lean4#2003</a> is about) if <code>gr1</code> and <code>gr2</code> are actually defined in terms of some other structures say <code>comm_gr1</code> and <code>comm_gr2</code> because checking equality of each field of the <code>gr*</code> triggers checking equality of the <strong>entirety</strong> of the <code>comm_gr*</code> structures, leading to huge blowups if this pattern is nested.<br>\nBut even in a simple case like the one above we could save a lot of work by not testing things repeatedly.</p>",
        "id": 324549227,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675067116
    },
    {
        "content": "<p>A related question which came up is whether, when we test <code>isDefEq</code> of two expressions, we are supposed to be allowed to assume that their types are already known to be defeq. This is the way type theories are usually presented on paper so I was assuming it was allowed to assume this, but Lean seems not to use this knowledge (for testing defeq of propositions specifically) so maybe it is not intended to be a precondition.</p>",
        "id": 324549595,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675067279
    },
    {
        "content": "<p>As the example shows it's not just one extra check per \"axiom\" (like <code>add_comm</code>), but one per occurrence of a field in the axiom. So <code>comm</code> is 2, <code>assoc</code> is 4, <code>distrib</code> is 5, etc. Already for a <code>Ring</code>, it adds up fast.</p>",
        "id": 324551811,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675068063
    },
    {
        "content": "<p>On the bright side, we can say that there is finally some practical purpose to figuring out whether the right unit axiom of a group follows from the left unit axiom</p>",
        "id": 324552505,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675068334
    },
    {
        "content": "<p>You might find that hard to remove that axiom even if you can prove it from the others, because group extends monoid and it's not true for monoids.</p>",
        "id": 324561893,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1675071605
    }
]