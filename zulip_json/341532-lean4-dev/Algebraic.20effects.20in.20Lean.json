[
    {
        "content": "<p>I know Lean doesn't have algebraic effects (and maybe doesn't plan to due to implementation difficulty). My question is slightly different but related.</p>\n<p>If implementation difficulty was not a concern (i.e. if the team had a lot of time to work just on this), would AE fit into Lean's model? Or would it require a significant revision (e.g. to the type system)? In other words, are any parts of Lean's design fundamentally AE-averse in some way?</p>\n<p>Thanks!</p>",
        "id": 527971804,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1752097959
    },
    {
        "content": "<p>This was a few years ago, but I recall Sebastian Ullrich briefly addressed one of the technical facets in this thread: <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/algebraic.20effects.20and.20handlers.3F/near/231513644\">#lean4 &gt; algebraic effects and handlers? @ üí¨</a></p>",
        "id": 527984840,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1752107953
    },
    {
        "content": "<p>Are they inefficient in OCaml? I presume they‚Äôre used for nontrivial programs there too. Does OCaml not have some constraints than Lean does? Or is OCaml‚Äôs implementation considered inefficient?</p>\n<p>(I‚Äôm genuinely curious, I‚Äôve almost never used OCaml)</p>",
        "id": 527992468,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1752115588
    },
    {
        "content": "<p>OCaml is inefficient in general.</p>",
        "id": 533678550,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1754862425
    },
    {
        "content": "<p>Avoid algebraic effects if possible, unless you need the call/cc feature of free monad. Effects are typed holes. Simply passing in functions works the same.</p>",
        "id": 533678605,
        "sender_full_name": "Locria Cyber",
        "timestamp": 1754862501
    },
    {
        "content": "<p>I think algebraic effects are ultimately a program verification thing</p>",
        "id": 534271809,
        "sender_full_name": "(deleted)",
        "timestamp": 1755105281
    },
    {
        "content": "<p>Running programs with algebraic effects directly is very inefficient</p>",
        "id": 534271859,
        "sender_full_name": "(deleted)",
        "timestamp": 1755105303
    },
    {
        "content": "<p>But otherwise if you are modeling the semantics of programs then algebraic effects are the way to go</p>",
        "id": 534271964,
        "sender_full_name": "(deleted)",
        "timestamp": 1755105362
    },
    {
        "content": "<p>Is there something definite I can read about them being inefficient?</p>\n<p>Is Koka slow? The Koka website <a href=\"https://koka-lang.github.io/koka/doc/book.html\">mentions</a> Perceus and FBIP (which both seem relevant to Lean) so I‚Äôd assume folks working on Koka are similarly performance-minded.</p>",
        "id": 535100680,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755600342
    },
    {
        "content": "<p>Also, is effects being slow the official position of the Lean team? Or is this more like a guess? (Sorry I don‚Äôt know who‚Äôs on the team.)</p>\n<p>The reason I‚Äôm asking is that I want to understand whether Lean has firmly decided not to look at typed effects and is happy with the status quo (monads and monad transformers). Or if effects don‚Äôt fit into the Lean typesystem in some fundamental way. Or if more research is needed on that. Or if they are at some fundamental level slow (which I find a bit harder to believe, but then I lack the domain knowledge to verify it so I‚Äôd take that on faith from someone who closely investigated this).</p>\n<p>Overall it feels like Lean is state of the art in multiple ways, so rawdogging monads and monad transformers seems like a step backwards compared to the PL research.  But then again, I‚Äôm an outsider and can‚Äôt firmly substantiate my claims so it‚Äôs just vibes.</p>",
        "id": 535102696,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755601252
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> I‚Äôm wondering if your statement from the linked thread (about unacceptable runtime vs compile overhead) is basically the official position? And that nothing changed much since then? Also I wonder if there‚Äôs something Lean does that improves on status quo wrt usability of monads. Thanks!</p>",
        "id": 535103080,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755601406
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515610\">Locria Cyber</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/533678605\">said</a>:</p>\n<blockquote>\n<p>Avoid algebraic effects if possible, unless you need the call/cc feature of free monad. Effects are typed holes. Simply passing in functions works the same.</p>\n</blockquote>\n<p>I don‚Äôt understand this part. I think the point of AE is that intermediate abstractions don‚Äôt need to be aware of what you‚Äôre ‚Äúpassing in‚Äù. So the handler can live way above and still coordinate with the thing way below. Whereas ‚Äúsimply passing functions‚Äù forces every intermediate layer in the call stack to be aware of this relationship.</p>",
        "id": 535103444,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755601558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/535100680\">said</a>:</p>\n<blockquote>\n<p>Is there something definite I can read about them being inefficient?</p>\n<p>Is Koka slow? The Koka website <a href=\"https://koka-lang.github.io/koka/doc/book.html\">mentions</a> Perceus and FBIP (which both seem relevant to Lean) so I‚Äôd assume folks working on Koka are similarly performance-minded.</p>\n</blockquote>\n<p>As a small side note, it's very relevant to Lean, Lean also uses a version of Perceus and Leo was also on the Perceus paper (<a href=\"https://dl.acm.org/doi/abs/10.1145/3453483.3454032\">https://dl.acm.org/doi/abs/10.1145/3453483.3454032</a>) (see also <a href=\"https://dl.acm.org/doi/abs/10.1145/3412932.3412935\">https://dl.acm.org/doi/abs/10.1145/3412932.3412935</a> for Lean's reference counting)</p>",
        "id": 535103668,
        "sender_full_name": "Andr√©s Goens",
        "timestamp": 1755601641
    },
    {
        "content": "<p>One thing that could very well be done (and I've played around with the idea given enough time) would be to have effects and effect types at a surface level and then elaborate them into monadic code, which would affect compile time but ideally not runtime performance (if done right)</p>",
        "id": 535103857,
        "sender_full_name": "Andr√©s Goens",
        "timestamp": 1755601713
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andr√©s Goens</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/535103668\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/535100680\">said</a>:</p>\n<blockquote>\n<p>Is there something definite I can read about them being inefficient?</p>\n<p>Is Koka slow? The Koka website <a href=\"https://koka-lang.github.io/koka/doc/book.html\">mentions</a> Perceus and FBIP (which both seem relevant to Lean) so I‚Äôd assume folks working on Koka are similarly performance-minded.</p>\n</blockquote>\n<p>As a small side note, it's very relevant to Lean, Lean also uses a version of Perceus and Leo was also on the Perceus paper (<a href=\"https://dl.acm.org/doi/abs/10.1145/3453483.3454032\">https://dl.acm.org/doi/abs/10.1145/3453483.3454032</a>) (see also <a href=\"https://dl.acm.org/doi/abs/10.1145/3412932.3412935\">https://dl.acm.org/doi/abs/10.1145/3412932.3412935</a> for Lean's reference counting)</p>\n</blockquote>\n<p>It's more the other way around, Perceus uses a version of what Lean does :P</p>",
        "id": 535103858,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1755601713
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik B√∂ving</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/535103858\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andr√©s Goens</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/535103668\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/535100680\">said</a>:</p>\n<blockquote>\n<p>Is there something definite I can read about them being inefficient?</p>\n<p>Is Koka slow? The Koka website <a href=\"https://koka-lang.github.io/koka/doc/book.html\">mentions</a> Perceus and FBIP (which both seem relevant to Lean) so I‚Äôd assume folks working on Koka are similarly performance-minded.</p>\n</blockquote>\n<p>As a small side note, it's very relevant to Lean, Lean also uses a version of Perceus and Leo was also on the Perceus paper (<a href=\"https://dl.acm.org/doi/abs/10.1145/3453483.3454032\">https://dl.acm.org/doi/abs/10.1145/3453483.3454032</a>) (see also <a href=\"https://dl.acm.org/doi/abs/10.1145/3412932.3412935\">https://dl.acm.org/doi/abs/10.1145/3412932.3412935</a> for Lean's reference counting)</p>\n</blockquote>\n<p>It's more the other way around, Perceus uses a version of what Lean does :P</p>\n</blockquote>\n<p>haha, sorry, fair enough! On that note <span class=\"user-mention\" data-user-id=\"395550\">@Henrik B√∂ving</span> , weren't you also working on FBIP for Lean? Is that still in the horizon?</p>",
        "id": 535103996,
        "sender_full_name": "Andr√©s Goens",
        "timestamp": 1755601771
    },
    {
        "content": "<p>We already have FBIP in Lean though? After all that term was invented by the Lean paper. Cameron Zwarich is working on FBIP improvements at the moment.</p>",
        "id": 535104134,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1755601817
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andr√©s Goens</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/535103857\">said</a>:</p>\n<blockquote>\n<p>One thing that could very well be done (and I've played around with the idea given enough time) would be to have effects and effect types at a surface level and then elaborate them into monadic code, which would affect compile time but ideally not runtime performance (if done right)</p>\n</blockquote>\n<p>and this could easily be a user-level library, since Lean is so extensible <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 535104182,
        "sender_full_name": "Andr√©s Goens",
        "timestamp": 1755601836
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik B√∂ving</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/535104134\">said</a>:</p>\n<blockquote>\n<p>We already have FBIP in Lean though? After all that term was invented by the Lean paper. Cameron Zwarich is working on FBIP improvements at the moment.</p>\n</blockquote>\n<p>I guess I was thinking of <span class=\"user-mention\" data-user-id=\"258922\">@Anton Lorenzen</span>'s version in <a href=\"https://dl.acm.org/doi/abs/10.1145/3607840\">https://dl.acm.org/doi/abs/10.1145/3607840</a></p>",
        "id": 535104416,
        "sender_full_name": "Andr√©s Goens",
        "timestamp": 1755601927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/535103080\">said</a>:</p>\n<blockquote>\n<p>I wonder if there‚Äôs something Lean does that improves on status quo wrt usability of monads</p>\n</blockquote>\n<p>The elaborator that handles monad lifting and coercing through monads basically Just Works, and I rarely need to think about it. Lean's <code>do</code> notation is also very flexible and does a bunch of bookkeeping for you to simulate an imperative language.</p>\n<p>Monads are also fairly well understood. There isn't much to them (in the \"how much code does it take\" sense to define things from scratch), and its a pretty light abstraction for being able to wire together imperative computations. The name's off-putting, sure, and the fact there's a name put to the abstract concept makes it seem like you're supposed to understand the abstract concept thoroughly first, but that's not necessary. \"<code>IO</code>\" is Lean's \"<code>public static void main</code>\". It means something, but do you need to fully understand it before you can do something useful?</p>\n<p>I know the context is your thread <a class=\"message-link\" href=\"/#narrow/channel/113489-new-members/topic/Is.20learning.20monads.20essential.20for.20coding.20in.20Lean.3F/near/534985375\">#new members &gt; Is learning monads essential for coding in Lean? @ üí¨</a>. Let me ask you this: what if someone had been better at naming things and called them \"contexts\". No \"monads\" and \"monad transformers\", just \"contexts\". So, for example, <code>ReaderT C (StateT S IO)</code> would be a context where you have a reader context that gives you a configuration <code>C</code> you can read, a state context where you've got some state <code>S</code> you can modify, and it's all being done in an <code>IO</code> context where you can do I/O. Would you still be thinking \"there must be something out there where I don't have to learn 'contexts'; I've heard about 'algebraic effects', they seem like they'd feel more obvious\"?  :-)</p>\n<p>The word \"context\" also suggests what's so weird about \"monad\". It's odd to say \"do I have to learn contexts\". It's easier to say \"do I have to learn about the IO context\", etc. It's very mathy to talk about \"contexts\" themselves.</p>\n<p>Answering your question in that thread, yes, you need to learn to use the common <del>monads</del><em>contexts</em> to program in Lean. For imperative programming, beyond needing to use <code>‚Üê</code> to mark where side effects are happening (which is a nice improvement to imperative programming I think), the biggest difference is that data is immutable by default. It's possible to do mutation-based programming though; there's basically a pointer type available, both using <code>IO</code> or using the magic <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=runST#doc\">docs#runST</a>.</p>",
        "id": 535209460,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755641116
    },
    {
        "content": "<p>Oh my, now I'm dreaming about actually renaming <code>Monad</code> to <code>Context</code> everwhere. <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span></p>",
        "id": 535221100,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1755650740
    },
    {
        "content": "<blockquote>\n<p>The elaborator that handles monad lifting and coercing through monads basically Just Works, and I rarely need to think about it. Lean's¬†<code>do</code>¬†notation is also very flexible and does a bunch of bookkeeping for you to simulate an imperative language.</p>\n</blockquote>\n<p>Thanks, this is actually very encouraging! Once I free up some mindspace I think I'll try to actually learn how to work with them in Lean.</p>\n<blockquote>\n<p>The name's off-putting, sure, and the fact there's a name put to the abstract concept makes it seem like you're supposed to understand the abstract concept thoroughly first, but that's not necessary. \"<code>IO</code>\" is Lean's \"<code>public static void main</code>\". It means something, but do you need to fully understand it before you can do something useful?</p>\n</blockquote>\n<p>I hope this is the case. The trigger for the linked thread is that I started looking at FPIL and this gave me flashbacks from early 2010s when folks excited about FP would try to talk about these things with web developers and were understandably met with blank stares.</p>\n<p><a href=\"/user_uploads/3121/i1LWk4rXFEwoVqnpix0gOZ6W/Screenshot-2025-08-20-at-01.53.42.png\">Screenshot 2025-08-20 at 01.53.42.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/i1LWk4rXFEwoVqnpix0gOZ6W/Screenshot-2025-08-20-at-01.53.42.png\" title=\"Screenshot 2025-08-20 at 01.53.42.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1748x918\" src=\"/user_uploads/thumbnail/3121/i1LWk4rXFEwoVqnpix0gOZ6W/Screenshot-2025-08-20-at-01.53.42.png/840x560.webp\"></a></div><p>I've clicked through these chapters and quite a bit of it doesn't <em>feel</em> like learning about \"actually using stuff\" as much as reading about quirks of compositional bookkeeping. Even if they were called \"contexts\", I'm not sure that the amount of bookkeeping being taught in those chapters feels \"grounded\" to me.</p>\n<p>Maybe it's just I haven't had the enlightenment yet and so having to think about \"functors\", \"applicatives\", etc, just to be able to compose some State and IO feels offputting. Again, I bring up effects for comparison not so much due to clearer terminology but because the mental model feels \"obvious\" (you raise effects, they interrupt upwards through the call stack until there's a handler, then the handler can resume ‚Äî like typed resumable try/catch ‚Äî see, I can explain the entire thing in one sentence). Whereas learning about lifting and composing applicative functor monad transformer sequences... ah I guess I can do it but it just feels a lot more detached. I struggle to get myself to do it, which means mainstream non-FP developers will also struggle to get themselves to do it (frankly, it's a huge turnoff), which means coding in Lean will probably be a lot more niche than maybe it could be.</p>\n<p>Maybe this is more feedback about FPIL itself and the section titles and the choices of what to focus on in the book though. I'm still open to learning this stuff and then seeing if my opinion on it changes. With effects, I feel like it's possible to teach while mostly focusing on the actual concepts you want to deal with (concrete effects/handlers, not machinery). Whereas here it feels like 80% of the focus is on manipulating abstract machinery.</p>",
        "id": 535222737,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755652194
    },
    {
        "content": "<p>If FP is offputting, how about you don't read <em>Functional Programming</em> In Lean then :-) I find these things boring to read about myself. It's more fun to find existing code to study and to try using it as a model to write my own things.</p>\n<p>Lean style tends to be a fairly straightforward kind of functional programming. For whatever reason, we tend to use functions like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Option.map#doc\">docs#Option.map</a> directly rather than hide them behind an abstract interface (that said, when it's convenient, you'll see a <code>&lt;$&gt;</code> operator, but <code>&lt;*&gt;</code> is very rare to see).  Maybe it's that dependent types are hard enough, and we don't have enough spare neurons to write perfectly abstracted code. Sometimes I also think about how \"something doesn't need to <em>be</em> something to be something\". It doesn't literally need to be <code>&lt;$&gt;</code> (<code>Functor.map</code>) for it to be a functor application. No need to let everyone know you know it's a functor. Similarly, it's fine to use a <code>for</code> loop and say \"that's a fold\". It's only a problem when it gets hard to reason about, and you might start reaching for folds/maps/etc. to try to manage the complexity.</p>\n<p>I remember when doing serious projects in Haskell how desperate I felt trying to get the right monad lifts for my transformer stack. In Lean, I pretty much never feel that way. The elaboration routine is really great, and plus we have an Infoview to see expected types, so it's all so much easier to deal with mistakes. The only exception is that sometimes I need to write <code>(myFn ¬∑)</code> instead of just <code>myFn</code> for callbacks to properly trigger monad lifting. Possibly this can be fixed.</p>\n<p>The <code>(‚Üê m)</code> expressions are a big deal for usability. Without them, code tends to either be littered with applicative functors or look like assembly language. It's pretty nice ‚Äî even if there are still some impedance mismatches (for example, when you want to mix pure values and monadic values in a short-circuiting <code>&amp;&amp;</code> or <code>||</code> in <code>if</code>, you need to learn some tricks still, though I think there is or will be a linter to warn about this).</p>\n<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/535222737\">said</a>:</p>\n<blockquote>\n<p>you raise effects, they interrupt upwards through the call stack until there's a handler, then the handler can resume ‚Äî like typed resumable try/catch ‚Äî see, I can explain the entire thing in one sentence</p>\n</blockquote>\n<p>Is it clear that this is a way to model state? That's the most pressing thing in a language with no mutation. (More accurately, one that requires explicitly opting in to mutation.) Knowing the exact context of things is a feature of FP, since you can reason about the effects of computations. You mention algebraic effects are like resumable try/catch ‚Äî aren't exceptions usually one of the more difficult parts of a program to reason about? I don't mean to say that algebraic effects are worse of a solution than monads, but it's not clear to me that they're obviously better reasoning-wise. They're certainly a more recent topic of research, with interesting problems.</p>\n<p>With monads, it's very straightforward: the state <del>monad</del><em>context</em> is encapsulating the fact that each computation takes the current state as input and outputs an updated state. The state is threaded through in a very direct way, and there's no way to do spooky assignments of global variables outside the state. The hardest part here isn't monads, but getting used to state objects as a functional programming discipline. Then with <code>do</code> notation those state transformations can be implicitly threaded through each computation step, and you don't need to think about it too hard.</p>\n<p>State monads and immutable data also give you a superpower that's almost unthinkable in mainstream imperative programs: you can snapshot the state and <em>backtrack</em>. This is used all the time in the implementation of Lean, where it speculatively tries something then undoes all the state mutations if it didn't work out. It's really boring in FP (you really just store the state in some variable then reset the state), but in imperative languages you'd have to carefully apply the action pattern and keep track of actions and be sure that the actions really can reverse their effects.</p>",
        "id": 535226639,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755655344
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/535226639\">said</a>:</p>\n<blockquote>\n<p>If FP is offputting, how about you don't read <em>Functional Programming</em> In Lean then :-) I find these things boring to read about myself. It's more fun to find existing code to study and to try using it as a model to write my own things.</p>\n</blockquote>\n<p>Fair :) I brought it up because it's currently the only recommended resource on the site about programming in Lean. In fact it's positioned on <a href=\"https://lean-lang.org/learn/\">https://lean-lang.org/learn/</a> as (quoting) the \"main\" resource for programmers who want to learn Lean and says \"no prior knowledge of functional programming is needed\". Maybe I'm nitpicking but IMO a resource positioned like this could use less jargon-y top-level chapter titles for broader appeal. E.g. do we want Rust developers to read this too? Would they be compelled to?</p>\n<p>The practical points you speak to sound great. Which makes me think that maybe this <em>is</em> an issue with me picking FPIL as an intro (but then again, that's what the site told me to read). I believe you that it's possible to not necessarily know something is a functor, but then again, education-wise having \"Functors, Applicative Functors, and Monads\" as a top level chapter soon after \"Hello World\" in the table of contents tells me these are unavoidable topics for being able to write programs in Lean. Maybe they aren't. For comparison, looking through the <a href=\"https://doc.rust-lang.org/book/\">https://doc.rust-lang.org/book/</a> sidebar doesn't fill me with similar dread although I still haven't learned any Rust. Maybe it's because jargon is always contextualized there with the task at hand so it feels more earned.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/535226639\">said</a>:</p>\n<blockquote>\n<p>Is it clear that this is a way to model state? That's the most pressing thing in a language with no mutation.</p>\n</blockquote>\n<p>Is how state is modeled actually different? My impression is you can more or less map effects 1:1 to monads. You have a State monad, you can have a State effect/handler with similar API. The difference, from my understanding, is you don't need to do anything special when you want to compose multiple difference effects since it's done behind the scenes.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/535226639\">said</a>:</p>\n<blockquote>\n<p>You mention algebraic effects are like resumable try/catch ‚Äî aren't exceptions usually one of the more difficult parts of a program to reason about? I don't mean to say that algebraic effects are worse of a solution than monads, but it's not clear to me that they're obviously better reasoning-wise.</p>\n</blockquote>\n<p>That's interesting, I personally don't find exceptions difficult to think about. What I like about them is that you always write \"normal\" code locally, and the mechanism for \"intercepting\" control flow is just adding a handler to the call stack. And if both sides are typed, you have an explicit coordination primitive between the sides of the wormhole. But nothing in your code needs to coordinate composition of independent ones because how such layers compose because it's done by the language/VM. That seems \"simple enough\" when I think about it but I have no experience with actually using effects. Maybe using them in practice sucks!</p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/535226639\">said</a>:</p>\n<blockquote>\n<p>State monads and immutable data also give you a superpower that's almost unthinkable in mainstream imperative programs: you can snapshot the state and <em>backtrack</em>.</p>\n</blockquote>\n<p>To clarify, I'm fully onboard with immutability and whatever falls out of that globally. (My background is in React, so the struggle of getting people to \"think immutably\" is familiar to me ‚Äî we even have a <a href=\"https://react.dev/learn/tutorial-tic-tac-toe#adding-time-travel\">section on that</a> in the intro tutorial!) I guess I didn't think of monads and effects as being different in that regard: I would expect State Effect/Monad to be equally powerful and have roughly a similar interface. Where I would expect to see a difference is in type signature and in how using multiple Monads/Effects is composed. Concretely, I'd expect that with effects, functions \"above\" wouldn't know that there's anything fancy going on (until we reach the place where the effect handler is), and that there's no need to explicitly transform anything because the compiler/runtime handles the machinery for us. I recognize this is a pretty abstract description and may be wrong (since I don't actually understand how monads are composed yet anyway).</p>",
        "id": 535228792,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755657069
    },
    {
        "content": "<p>Funnily enough, the thing that made me remember of AE (and wonder about them in Lean) is learning about typeclasses and instances. In my mind, AE are kind of like typeclasses/instances but going up the call stack instead of statically. And instead of lifting or transforming monads you're just taking a union of effects in types.</p>\n<p>Again, I'm talking from a noob perspective and I suspect it may take another 10 years for some \"big questions\" in AE design space to shake out. I'm sure it's not actually all rosy as I describe. I just really like Lean and I wish it had more tricks up its sleeve in this space. But if there's nothing compelling enough, that's fine I guess.</p>",
        "id": 535230062,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755658209
    },
    {
        "content": "<p>This seems like a <a href=\"https://www.reddit.com/r/ProgrammingLanguages/comments/11ti9sc/what_are_the_issues_with_algebraic_effects/\">useful list</a> of things that suck about and/or are unclear about AE</p>",
        "id": 535230326,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755658509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/535228792\">said</a>:</p>\n<blockquote>\n<p>You have a State monad, you can have a State effect/handler with similar API</p>\n</blockquote>\n<p>My point here is basically, why does your description of stacks and handlers and exceptions have anything to do with state? Is your quick explanation of algebraic effects enough of an explanation to understand how it has anything to do with state management?</p>\n<p>I know your React background, so I know you're onboard with immutability. The monad superpower is that the state is very explicitly demarcated, and also you don't technically need any runtime support for monads ‚Äî it's all implemented in terms of basic concepts (functions and products). By looking at the source code, it's possible to learn that \"state mutation\" means that each computation is a function of the form <code>œÉ ‚Üí Œ± √ó œÉ</code>. That is, they take a state and return a new state, while also computing some value. That value can be used to determine which computation comes next. If algebraic effects are implemented in a way that involves looking at actual call stacks, then that's not something you can understand from within the language. I know it's possible to implement algebraic effects as libraries, but then that means it's not literally a call stack.</p>\n<p>Back to your explanation of algebraic effects in one sentence, here's my one-sentence explanation of monads: the way Lean handles imperative programs is that each line of <code>do</code> notation is implicitly a callback for the previous lines, and the callback is called using a handler specific to the monad. It doesn't sound any more complicated, though it does invoke callback-based programming.</p>",
        "id": 535231584,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755659768
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Algebraic.20effects.20in.20Lean/near/535228792\">said</a>:</p>\n<blockquote>\n<p>For comparison, looking through the <a href=\"https://doc.rust-lang.org/book/\">https://doc.rust-lang.org/book/</a> sidebar doesn't fill me with similar dread although I still haven't learned any Rust.</p>\n</blockquote>\n<p>Maybe it‚Äôs <em>because</em> you still haven‚Äôt learned any Rust. Otherwise the \"<a href=\"https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\">Understanding Ownership</a>‚Äù in the side bar would probably fill you with a lot more dread than monads.</p>",
        "id": 535313489,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1755696265
    },
    {
        "content": "<p>Disclaimer: Although I work for the FRO, the following is just personal opinion/a vision, written down in my free time. <br>\nMuch of this comes from my experience as a Haskell developer (I have contributed a lot to GHC) and having followed forum discussions on the relevant library ecosystem.</p>\n<p><strong>TLDR;</strong> we should wait until the design of <a href=\"https://hackage-content.haskell.org/package/bluefin-0.0.16.0/docs/Bluefin.html\">Haskell's <code>bluefin</code> library</a> converges and then just copy the approach, even going so far as moving it into <code>Core</code>/<code>Init</code>.</p>\n<h1>Nomenclature</h1>\n<p>The whole \"* effects *\" nomenclature is confusing. Broadly, I think of an \"effectful computation\" as one that communicates with its calling <em>context</em> via a <em>handler</em>. <br>\nAn effect is an interface, its handler the implementation. Talking about the semantics of an effect is impossible unless you know the handler. <br>\nIn analogy to exception handling, the effectful computation might <code>throw</code> an effect and the calling context <code>catch</code>es this effect in a handler. <br>\nHowever, in contrast to plain exceptions, a general effect handler has the ability to <code>yield</code> back a return value to the computation, much like coroutines (e.g., JS's <code>Generator</code>).<br>\n(The <a href=\"https://effekt-lang.org/tour/objects#objects-and-handlers\">Effekt</a> research language makes the connection between (effects and handlers) and (interface and implementations) explicit by providing means to convert between the two viewpoints.)</p>\n<p>Often, \"&lt;blah&gt; effects <em>and handlers</em>\" refers to <em>an implementation</em> of how to achieve this communication for effects of kind &lt;blah&gt; and its handler. <br>\nIt is suprisingly difficult to give an implementation that (1) works for all kinds of effects <em>without knowing their handlers at compile-time</em>, (2) supports higher-order operations such as <code>catch</code>. Recent work on <a href=\"https://dl.acm.org/doi/pdf/10.1145/3571255\">Hefty Algebras</a> has done it, though.<br>\nStill, such implementations have major drawbacks so I don't consider them usable; we'll get there in time.   </p>\n<h1>Applications need <em>non</em>-algebraic effects, and don't often care about dynamic handlers</h1>\n<p>I'm not excited about <em>algebraic</em> effects (and handlers), because applications need non-algebraic effects. </p>\n<p>The most basic effect interaction that is important in applications is combining a state effect (<code>MonadState</code>) which has a very efficient implementation in the form of <code>StateT</code> (the handler is the <code>instance</code>) with an exceptions effect (<code>MonadExcept</code> + the instance at <code>ExceptT</code>). <br>\nSurely such applications want effectful operations to (1) <code>get</code> and <code>set</code> the state, (2) <code>throw</code> an exception, and (3) <code>catch</code> an exception. <br>\nHowever, <code>catch</code> is not supported by <em>algebraic</em> effects and handlers. See Section 1.2 of <a href=\"https://dl.acm.org/doi/pdf/10.1145/3571255\">Hefty Algebras</a>; at the end it lists a few more examples (<code>withReader</code> is one of them). </p>\n<p>Furthermore, real-world applications often know the handler for certain primitive effects such as state and exceptions. There is no need for late binding <code>MonadState</code> and <code>MonadExcept</code>; any lawful and efficient implementation is good enough.</p>\n<h1>Transformer stacks are non-modular and don't scale to Big Software</h1>\n<p>TLDR; libraries using plain monad (transformers) do not compose, hence are insufficient to write Big Software.</p>\n<p>Why are monad transformers apparently sufficient for Lean? <br>\nOpinionated answer: Because we have no big applications written in Lean yet, except for the language implementation which is a medium-sized monolith. <br>\n<em>If</em> Lean will be used to write Big Software, we will see the limitations of this approach.</p>\n<h2>Example of Big Software: AWS + PostgreSQL</h2>\n<p>Big Software is usually composed from multiple libraries, each maintaining its own notion of \"context\" (i.e., internal state and exceptions). </p>\n<p>Say I want to compose an application that communicates with AWS and writes to a database. In the Haskell world, you could use the libraries <a href=\"https://hackage.haskell.org/package/amazonka-2.0/docs/Amazonka.html\"><code>amazonka</code></a> and perhaps <a href=\"https://hackage.haskell.org/package/postgresql-simple-0.7.0.0/docs/Database-PostgreSQL-Simple.html\"><code>postgresql-simple</code></a>. Disclaimer: I have never used these libraries, I just want to point out the practical issue of composing them. <br>\nAlso note that none of them use monad transformer stacks in the initial example; they all use plain <code>IO</code> (which in Haskell includes the ability to <code>try</code>, <code>catch</code> and <code>finally</code> exceptions). We'll get to the reason for that.</p>\n<h2>Transformer stacks</h2>\n<p>A possible (flawed) design for a library <code>aws</code> just like <code>amazonka</code> is to provide functions such as <code>fetchFile (url : String) : AWS RequestBody</code> that operate in a monad <code>AWS</code> that encapsulates the internal state and exceptions of <code>aws</code>. Here, <code>AWS</code> can be implemented using a stack of monad transformers such as <code>def AWS Œ± := ExceptT AwsException (StateT AwsState IO) Œ±</code>. The <code>AwsState</code> would store stuff such as authentication tokens etc. <br>\n<code>aws</code> would provide a function <code>runAWS (user : String) (password : String) (stuffToRun : AWS Œ±) : IO (Except AwsException Œ±)</code> to run a computation <code>stuffToRun</code> in the AWS world in terms of some username/password pair and hides all authentication and request management from the user. (I doubt that auth in AWS actually is as simple as username/password pair, but bear with me for the sake of the example.) </p>\n<p>There is another library <code>postgresql</code> that provides a function <code>query (q : Query) : DB String</code> operating in a monad <code>DB</code>, similarly implemented internally as <code>def DB Œ± := ExceptT DBException (StateT DBConnection IO) Œ±</code>. There is also <code>runDB (connectionString : String) (stuffToRun : DB Œ±) : IO (Except DBException Œ±)</code>. </p>\n<p>Each library in itself has nicely encapsulated the annoying details of how to connect to their respective service and how to handle exceptions.  <br>\nBut we cannot write a program that composes both! The following program is untyped, because <code>fetchFile</code> and <code>query</code> live in incompatible monads:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">def</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"kt\">:</span><span class=\"w\"> </span><span class=\"kt\">IO</span><span class=\"w\"> </span><span class=\"kt\">Unit</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">runAWS</span><span class=\"w\"> </span><span class=\"s\">\"user\"</span><span class=\"w\"> </span><span class=\"s\">\"pw\"</span><span class=\"w\"> </span><span class=\"o\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">runDB</span><span class=\"w\"> </span><span class=\"s\">\"db.example.com\"</span><span class=\"w\"> </span><span class=\"kr\">do</span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">response</span><span class=\"w\"> </span><span class=\"ow\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">fetchFile</span><span class=\"w\"> </span><span class=\"s\">\"salaries.txt\"</span><span class=\"w\"> </span><span class=\"c1\">-- as I said, I do compilers, not CRUD :)</span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">salary</span><span class=\"w\"> </span><span class=\"kt\">:=</span><span class=\"w\"> </span><span class=\"o\">...</span><span class=\"w\"> </span><span class=\"n\">response</span><span class=\"w\"> </span><span class=\"o\">...</span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"ow\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">query</span><span class=\"w\"> </span><span class=\"s\">\"select * from employees where ${salary} &lt; salary\"</span>\n<span class=\"w\">  </span><span class=\"o\">...</span>\n</code></pre></div>\n<p>In this case, there is a way out: </p>\n<ol>\n<li>Define the combined application monad <code>def AppM Œ± := ExceptT (AwsException ‚äï DBException) (StateT (AwsState x DBConnection) IO) Œ±</code></li>\n<li>Define <code>runAppM (user password connectionString : String) : AppM Œ± -&gt; IO (AwsException ‚äï DBException) Œ±</code> in terms of <em>the implmentations</em> of <code>runAWS</code> and <code>runDB</code>.</li>\n<li>Define <code>MonadLift Aws AppM</code> and <code>MonadLift DB AppM</code> instances</li>\n</ol>\n<p>Note that way out breaks the abstraction of the library, i.e., the breaking changes to the implementation of <code>Aws</code> and <code>runAWS</code> will break your application.<br>\nFurthermore, such an approach will stop working for higher-order effects such as <code>catchAwsException (thing : AWS Œ±) (handler : AwsException -&gt; AWS Œ±) : AWS Œ±</code>.<br>\nAt the very least, you would need an instance for <code>MonadControl AWS AppM</code> (IIRC, it's a very complicated class) and the type of <code>catchAwsException</code> will likely need to change to account for the <code>DBConnection</code> state.</p>\n<p>(continued in next post)</p>",
        "id": 536041844,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1756133114
    },
    {
        "content": "<h1>The <code>ReaderT œÅ IO</code> pattern composes but lacks encapsulation</h1>\n<p>So libraries using custom monads (and transformers) do not compose.<br>\nThat is the reason why the actual Haskell implementations of <code>amazonka</code> and <code>postgresql-simple</code> do not define custom monads. Instead they define all operations in <code>IO</code> which expect state records as separate arguments. Exceptions are implicit in <code>IO</code>. This way, the issue of <code>MonadControl</code> etc. goes away; it's all just <code>IO</code>.<br>\nThe cost of this approach is having to pass around state records. This can be ameliorated by instead defining all functions on <code>ReaderT œÅ IO</code>, and instantiating <code>œÅ</code> with a record of <code>IORef</code>s for the state.<br>\nThis is exactly the popularly pragmatic <a href=\"https://github.com/commercialhaskell/rio#readme\">\"reader IO\" <code>RIO</code> pattern in Haskell</a>. It is very related to Lean's <code>StateRefT</code>.</p>\n<p>Still, this pattern feels like programming in C, where you pass around state records to top-level functions that may modify just about everything.<br>\nSay I'm debugging a problem with the DB in a big code base, and I'm wondering if it's worth digging into the definition of a big function <code>fetchFile (url : String) : ReaderT AppState IO ResponseBody</code>.<br>\nIt <em>sounds</em> like it is unrelated to the DB, but how can I be sure?! I cannot; I would have to dig into this definition. </p>\n<p>It would be great if the type system could assure that <code>fetchFile</code> indeed does not talk to the DB.   <br>\n<strong>And to me that is the single, dominating appeal of an effect system.</strong> </p>\n<h1>Effect systems compose and help maintaining Big Software</h1>\n<p>To me, an effect system is mainly a safe abstraction over <code>ReaderT œÅ IO</code> that helps with encoding architectural invariants in the types.<br>\n<a href=\"https://hackage-content.haskell.org/package/bluefin-0.0.16.0/docs/Bluefin.html\">Haskell's <code>bluefin</code> library</a> is a beautiful example of this approach. With it, I would define <a href=\"https://hackage-content.haskell.org/package/bluefin-0.0.16.0/docs/Bluefin-Compound.html#g:4\">compound effects for <code>AWS</code> and <code>DB</code></a> and then write </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">AWS</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Effects</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">AwsState</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"n\">exc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Exception</span><span class=\"w\"> </span><span class=\"n\">AwsException</span><span class=\"w\"> </span><span class=\"n\">e</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">runAWS</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">io</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IOE</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"w\"> </span><span class=\"n\">password</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stuffToRun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">AWS</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Eff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"bp\">&amp;</span><span class=\"w\"> </span><span class=\"n\">es</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">:&gt;</span><span class=\"w\"> </span><span class=\"n\">es</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Except</span><span class=\"w\"> </span><span class=\"n\">AwsException</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fetchFile</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">aws</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AWS</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">url</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">:&gt;</span><span class=\"w\"> </span><span class=\"n\">es</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ResponseBody</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Effects</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">DBConnection</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"n\">exc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Exception</span><span class=\"w\"> </span><span class=\"n\">DBException</span><span class=\"w\"> </span><span class=\"n\">e</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">runDB</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">io</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IOE</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">connectionString</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stuffToRun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">DB</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Eff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"bp\">&amp;</span><span class=\"w\"> </span><span class=\"n\">es</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">:&gt;</span><span class=\"w\"> </span><span class=\"n\">es</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Except</span><span class=\"w\"> </span><span class=\"n\">DBException</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">query</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">db</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DB</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">:&gt;</span><span class=\"w\"> </span><span class=\"n\">es</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">runEff</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">io</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">runAWS</span><span class=\"w\"> </span><span class=\"n\">io</span><span class=\"w\"> </span><span class=\"s2\">\"user\"</span><span class=\"w\"> </span><span class=\"s2\">\"pw\"</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">aws</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">runDB</span><span class=\"w\"> </span><span class=\"n\">io</span><span class=\"w\"> </span><span class=\"s2\">\"db.example.com\"</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">db</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">response</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">fetchFile</span><span class=\"w\"> </span><span class=\"n\">aws</span><span class=\"w\"> </span><span class=\"s2\">\"salaries.txt\"</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">salary</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">response</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">query</span><span class=\"w\"> </span><span class=\"n\">db</span><span class=\"w\"> </span><span class=\"s2\">\"select * from employees where ${salary} &lt; salary\"</span>\n<span class=\"w\">    </span><span class=\"bp\">...</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"c1\">-- handle exceptions</span>\n</code></pre></div>\n<p>Note</p>\n<ul>\n<li>This type-checks without needing to define any instances for <code>MonadLift</code> whatsoever</li>\n<li>It will run just as fast as the <code>IO</code>-based (\"programming in C\") variant</li>\n<li>It is very clear in the type system that <code>fetchFile</code> uses the <code>aws</code> capability but <em>not</em> the <code>db</code> capability, and vice versa for <code>query</code>.</li>\n</ul>\n<p>I'm reasonably certain that this will become the dominant architectural pattern for FP. <br>\nThe higher-rank type (<code>‚àÄ {e}, AWS e -&gt; ...</code>) takes a bit of getting used to, but on the other hand it infers well.<br>\nNeedless to say, this is a pattern for programming in the large; no need to bother newcomers with these concepts. </p>\n<h2>Performance of the analytic vs. synthetic approach to implementing <code>Eff</code></h2>\n<p><code>bluefin</code>'s author Tom Ellis calls the <code>IO</code>-based approach \"analytic\" in contrast to \"synthetic\".</p>\n<ul>\n<li>A <em>synthetic</em> implementation of the <code>MonadState œÉ</code> effect is <code>StateT œÉ</code>, that is, the effect is implemented by some algebraic data type (<code>œÉ -&gt; Œ± x œÉ</code>).  </li>\n<li>An <em>analytic</em> implementation of the <code>MonadState œÉ</code> effect is <code>StateRefT œÉ</code>, that is, the effect is implemented by an <code>ST.Ref</code> which has special support by the runtime system to enable an efficient implementation. </li>\n</ul>\n<p>In the \"limit over all possible effects\", the synthetic approach arrives at the free monad (Hefty Algebras are a variant of this), while the analytic approach stays with the very simple monomorphic implementation <code>ReaderT œÅ IO</code> (<a href=\"https://github.com/tomjaguarpaw/bluefin/blob/08db725f2467884bead3f8d6dfd96b67fb9bce0a/bluefin-internal/src/Bluefin/Internal.hs#L43\">in case of <code>bluefin</code>, it even is just <code>IO</code></a>).<br>\nWhile the free monad is a great model to prove functional correctness properties about effectful programs, it is far too slow to execute programs because everything is late bound and allocates. <br>\nBy contrast, <code>ReaderT œÅ IO</code>/<code>IO</code> is fast; its implementation of <code>bind</code> is known, we never need to eta-expand any continuations, there is no late binding of effect handlers unless explicitly requested, resource cleanup is deterministic and prompt etc. </p>\n<h1>Further reading</h1>\n<ul>\n<li>The documentation of <a href=\"https://hackage-content.haskell.org/package/bluefin-0.0.16.0/docs/Bluefin.html\"><code>bluefin</code></a></li>\n<li>Tom Ellis' recent talk about the <a href=\"https://www.youtube.com/watch?v=RsTuy1jXQ6Y\">history of effect systems in Haskell</a><div class=\"youtube-video message_inline_image\"><a data-id=\"RsTuy1jXQ6Y\" href=\"https://www.youtube.com/watch?v=RsTuy1jXQ6Y\"><img src=\"https://uploads.zulipusercontent.net/a4d354c5974b0cf29aa18066014ed0bae0f4cf52/68747470733a2f2f692e7974696d672e636f6d2f76692f5273547579316a585136592f6d7164656661756c742e6a7067\"></a></div></li>\n<li><a href=\"https://h2.jaguarpaw.co.uk/posts/bluefin-all/\">Blog posts by Tom Ellis</a> on <code>bluefin</code> </li>\n<li><a href=\"https://discourse.haskell.org/t/ann-a-series-of-articles-on-heftia-the-next-generation-of-haskell-effects-management\">A long discussion comparing a Haskell implementation of Hefty Algebras to <code>bluefin</code></a>. TLDR; Hefty Algebras are slow and don't support <code>bracket</code>/a proper <code>finally</code> for doing resource cleanup.</li>\n<li><a href=\"https://discourse.haskell.org/t/why-are-there-so-many-libraries-for-algebraic-effects\">\"Why are there so many libraries for algebraic effects (in Haskell)?\"</a></li>\n<li><a href=\"https://discourse.haskell.org/t/why-use-an-effect-system/10841/115\">My summary of why you would want to use an \"effect system\"</a></li>\n</ul>",
        "id": 536041897,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1756133126
    }
]