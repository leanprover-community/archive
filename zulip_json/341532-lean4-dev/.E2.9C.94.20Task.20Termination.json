[
    {
        "content": "<p>Would it be possible to be able to kill tasks?</p>\n<p>If a tactic has bugs, it would seize up the Lean instance running it. This is a problem for machine interactions via say Pantograph or Lean REPL. The current solution we have is to kill the server instance and restart it.</p>\n<p>If it is possible to terminate a task after a timeout and gracefully recycle all of its garbage, it would allow Pantograph or REPL instances to be long running.</p>",
        "id": 514162226,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1745509588
    },
    {
        "content": "<p>It's not really possible, just like in almost all other languages. Instead we really should fix those misbehaving tactics because they negatively affect working in the editor as well.</p>",
        "id": 514163755,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1745510075
    },
    {
        "content": "<p>Notably those tasks should check the cancellation token themselves periodically in spots they think are appropriate in order to prevent runaway computation as Lean's tasking system is cooperative, not preemptive</p>",
        "id": 514168780,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1745511561
    },
    {
        "content": "<p>I am also very interested in task termination. Is it really impossible? Would it be possible in an unsafe way? In some other languages, it is considered bad practice to abruptly kill a thread because it can cause various issues, but it is still possible to kill a thread.</p>",
        "id": 514176851,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1745513697
    },
    {
        "content": "<p>Are you fine with unbounded memory leaks? Then call <code>pthread_cancel</code> via FFI</p>",
        "id": 514178163,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1745514062
    },
    {
        "content": "<p>Am I fine with memory leaks, well not really ^^ But in some cases, we are dealing with code that makes the memory explode. There is this example from <span class=\"user-mention\" data-user-id=\"572535\">@RexWang</span>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">amc12a_2003_p1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">2003</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">2003</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2003</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h₀</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum_range_succ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum_range_zero</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<blockquote>\n<p>It consumes about 170GB of memory and takes 1,236 seconds to run.</p>\n</blockquote>\n<p>Given that various proofs are checked in parallel, cases like this jeopardize the whole proof verification process and we will likely kill the process anyway.<br>\nSo I am ok with setting a 60s time limit and having some memory leak. We will eventually have to restart the process to get back the lost memory, but the situation should be slightly better.</p>",
        "id": 514182449,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1745515383
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Task.20Termination/near/514168780\">said</a>:</p>\n<blockquote>\n<p>Notably those tasks should check the cancellation token themselves periodically in spots they think are appropriate in order to prevent runaway computation as Lean's tasking system is cooperative, not preemptive</p>\n</blockquote>\n<p>I asked Dr. Morrison and its not possible to ensure this behaviour by proving properties about tactics, so it seems like the only way to avoid production code crashing is to run them in isolated instances</p>",
        "id": 514182582,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1745515431
    },
    {
        "content": "<p>I am not very familiar with FFI, I have found this <a href=\"https://github.com/leanprover/lean4/blob/master/doc/dev/ffi.md\">https://github.com/leanprover/lean4/blob/master/doc/dev/ffi.md</a>, do you have resources to recommend to run <code>pthread_cancel()</code>? Thanks a lot for the help by the way</p>",
        "id": 514182608,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1745515438
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321854\">Auguste Poiroux</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Task.20Termination/near/514182608\">said</a>:</p>\n<blockquote>\n<p>I am not very familiar with FFI, I have found this <a href=\"https://github.com/leanprover/lean4/blob/master/doc/dev/ffi.md\">https://github.com/leanprover/lean4/blob/master/doc/dev/ffi.md</a>, do you have resources to recommend to run <code>pthread_cancel()</code>? Thanks a lot for the help by the way</p>\n</blockquote>\n<p>I used FFI and it could have the same issue as non-FFI execution of tactics, and Lean does some magic to prepare each thread in FFI so weird things can happen if you just kill a thread</p>",
        "id": 514182756,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1745515481
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Task.20Termination/near/514178163\">said</a>:</p>\n<blockquote>\n<p>Are you fine with unbounded memory leaks? Then call <code>pthread_cancel</code> via FFI</p>\n</blockquote>\n<p>at this point restarting the instance is preferable</p>",
        "id": 514182823,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1745515503
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321854\">Auguste Poiroux</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Task.20Termination/near/514182449\">said</a>:</p>\n<blockquote>\n<p>It consumes about 170GB of memory and takes 1,236 seconds to run.</p>\n</blockquote>\n<p>But surely you're not saying it does this <em>after</em> cancellation was triggered?</p>",
        "id": 514186560,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1745516686
    },
    {
        "content": "<p>Are you referring to the <code>CancelToken</code> approach? Do you think it would work well in this case?<br>\nI didn't try to trigger cancellation yet, so I am genuinely interested in this approach as well. I could consider an approach with a soft time limit (let's say 60s) after which we trigger cancellation, and if it doesn't work, we kill the REPL process after a hard time limit (120s).</p>",
        "id": 514188006,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1745517101
    },
    {
        "content": "<p>Again it's what Lean itself uses so I do hope it works quite well... until someone writes a misbehaving tactic</p>",
        "id": 514189894,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1745517357
    },
    {
        "content": "<p>Thanks, good to know! First time I read \"cooperative cancellation\", I thought I would have to manually check for cancellation within the task running the tactic. But if you tell me that, in general, tactics check for this, that's amazing.</p>",
        "id": 514199751,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1745519053
    },
    {
        "content": "<p>Would it be possible to check for cancellation in the interpreter, maybe just as an option? All non-core tactics are interpreted atm, so this might prevent a majority of issues with buggy tactics.</p>",
        "id": 514241659,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1745535771
    },
    {
        "content": "<p>Even in the interpreter, there's not much we can do but hard-abort while leaking memory</p>",
        "id": 514305990,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1745565881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> has marked this topic as resolved.</p>",
        "id": 514475837,
        "sender_full_name": "Notification Bot",
        "timestamp": 1745623604
    },
    {
        "content": "<p>well thats unfortunate but its probably the best we can have</p>",
        "id": 514475850,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1745623617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/.E2.9C.94.20Task.20Termination/near/514182582\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/341532-lean4-dev/topic/Task.20Termination/near/514168780\">said</a>:</p>\n<blockquote>\n<p>Notably those tasks should check the cancellation token themselves periodically in spots they think are appropriate in order to prevent runaway computation as Lean's tasking system is cooperative, not preemptive</p>\n</blockquote>\n<p>I asked Dr. Morrison and its not possible to ensure this behaviour by proving properties about tactics, so it seems like the only way to avoid production code crashing is to run them in isolated instances</p>\n</blockquote>\n<p>To be clear, I said not that proving properties about tactics was \"impossible\", but that it was the wrong solution to the problem. Simply <em>fixing</em> the tactics is what you want, if you are finding tactics that aren't respecting cancellation.</p>",
        "id": 515112222,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1745944768
    }
]