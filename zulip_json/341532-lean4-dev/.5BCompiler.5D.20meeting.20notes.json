[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461231\">@Jad Ghalayini</span> <span class=\"user-mention\" data-user-id=\"463095\">@Yuri de Wit</span> <span class=\"user-mention\" data-user-id=\"515083\">@Tom</span> Thanks for joining <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> <span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span> and me today.<br>\nHere are the relevant links /notes for the new code generator:</p>\n<ul>\n<li>We are using the master branch.</li>\n<li>The implementation is located at <a href=\"https://github.com/leanprover/lean4/tree/master/src/Lean/Compiler/LCNF\">https://github.com/leanprover/lean4/tree/master/src/Lean/Compiler/LCNF</a></li>\n<li>You can manually apply the new code generator using <code>#eval Lean.Compiler.compile #[...]</code> where <code>...</code> are the functions to be compiled. Heres is an example: <a href=\"https://github.com/leanprover/lean4/blob/4e8b4e96e9aa50134d1da518cc6ab20fc431a50e/tests/lean/run/lcnf1.lean#L1-L7\">https://github.com/leanprover/lean4/blob/4e8b4e96e9aa50134d1da518cc6ab20fc431a50e/tests/lean/run/lcnf1.lean#L1-L7</a></li>\n<li>Here is an example where Henrik adds a custom pass to ensure the <code>pullInstances</code> pass does not change the size of the code <a href=\"https://github.com/leanprover/lean4/blob/4ee9080a9b46e4e505045d0b744ea97e7c32b21f/tests/lean/CompilerPullInstances.lean\">https://github.com/leanprover/lean4/blob/4ee9080a9b46e4e505045d0b744ea97e7c32b21f/tests/lean/CompilerPullInstances.lean</a></li>\n<li>You can use <code>set_option trace.Compiler.result true</code> to see the code produced by the compiler passes that we have already implemented in the new code generator. We are also adding a <code>trace.Compiler.&lt;pass-name&gt;</code> for each new pass we add.</li>\n<li>The module <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Check.lean\">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Check.lean</a> checks whether LCNF code is well-formed, and is an excellent tool for debugging. It is currently executed after every single pass.</li>\n</ul>\n<p>Looking forward to seeing you again on Monday.</p>",
        "id": 298029681,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1662747570
    },
    {
        "content": "<p>Feel free to ask questions here, and we will try our best to answer them here or at our next meetings.</p>",
        "id": 298029957,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1662747675
    },
    {
        "content": "<p>Here is the example I have mentioned in the meeting similar to <code>Tuple α n</code> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Vec2</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Float</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"n\">Vec2</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">x₁</span><span class=\"o\">,</span><span class=\"n\">x₂</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">y₁</span><span class=\"o\">,</span> <span class=\"n\">y₂</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">x₁</span><span class=\"bp\">+</span><span class=\"n\">y₁</span><span class=\"o\">,</span> <span class=\"n\">x₂</span><span class=\"bp\">+</span><span class=\"n\">y₂</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HMul</span> <span class=\"n\">Float</span> <span class=\"n\">Vec2</span> <span class=\"n\">Vec2</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"o\">⟨</span><span class=\"n\">x₁</span><span class=\"o\">,</span><span class=\"n\">x₂</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"bp\">*</span><span class=\"n\">x₁</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"bp\">*</span><span class=\"n\">x₂</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">NFloatArray</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">FloatArray</span> <span class=\"bp\">//</span> <span class=\"n\">a.size</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"o\">(</span><span class=\"n\">NFloatArray</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n   <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x.1</span>\n   <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n     <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x.set</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"gr\">sorry</span><span class=\"o\">⟩</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"gr\">sorry</span><span class=\"bp\">+</span><span class=\"n\">y.1</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"gr\">sorry</span><span class=\"o\">)</span>\n   <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"gr\">sorry</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">HMul</span> <span class=\"n\">Float</span> <span class=\"o\">(</span><span class=\"n\">NFloatArray</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">NFloatArray</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n   <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x.1</span>\n   <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n     <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x.set</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"gr\">sorry</span><span class=\"o\">⟩</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"gr\">sorry</span><span class=\"o\">)</span>\n   <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"gr\">sorry</span><span class=\"o\">⟩⟩</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">FloatVector</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Unit</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Float</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Vec2</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">NFloatArray</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FloatVector.add</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">FloatVector</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">FloatVector</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Unit.unit</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>     <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">FloatVector</span> <span class=\"n\">at</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span>     <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">FloatVector</span> <span class=\"n\">at</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">FloatVector</span> <span class=\"n\">at</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FloatVector.smul</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Float</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">FloatVector</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">FloatVector</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Unit.unit</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>     <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">FloatVector</span> <span class=\"n\">at</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">s</span><span class=\"bp\">*</span><span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span>     <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">FloatVector</span> <span class=\"n\">at</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">s</span><span class=\"bp\">*</span><span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">FloatVector</span> <span class=\"n\">at</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">s</span><span class=\"bp\">*</span><span class=\"n\">x</span>\n\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"o\">(</span><span class=\"n\">FloatVector</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.add</span> <span class=\"n\">y</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HMul</span> <span class=\"n\">Float</span> <span class=\"o\">(</span><span class=\"n\">FloatVector</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">FloatVector</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.smul</span> <span class=\"n\">s</span><span class=\"o\">⟩</span>\n\n\n<span class=\"c1\">-- Am I getting just addition on Vec2?</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">FloatVector</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Compiler.init</span> <span class=\"n\">true</span>\n<span class=\"k\">#eval</span> <span class=\"n\">Lean.Compiler.compile</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">``</span><span class=\"n\">foo1</span><span class=\"o\">]</span>\n\n\n<span class=\"c1\">-- Can we get this with only one `match n with`?</span>\n<span class=\"c1\">-- This is probably hard as it is similar to `(arr.map g).map f = arr.map (f∘g)`</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo2</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Float</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">FloatVector</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Compiler.init</span> <span class=\"n\">true</span>\n<span class=\"k\">#eval</span> <span class=\"n\">Lean.Compiler.compile</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">``</span><span class=\"n\">foo2</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 298466113,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1663011695
    },
    {
        "content": "<p>What is the plan for unboxed values in the new compiler? Would it be possible to somehow know that a type is 'plain old data' and have function to read and write them to <code>ByteArray</code>? This would hopefully remove the need for specialized <code>FloatArray</code>.</p>",
        "id": 298467750,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1663012221
    },
    {
        "content": "<p>Regarding the PassManager and the testing framework.<br>\nThe PassManager: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/PassManager.lean\">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/PassManager.lean</a></p>\n<p>In the new code generator we have the notion of a <code>Pass</code> which is in essence a function <code>Array Decl -&gt; CompilerM (Array Decl)</code> + a name and a few meta informations attached. This function will receive all the <code>Decl</code>s from a single Lean module and can proceed to do whatever it wants with it really, hypothetically a user could even write their own <code>Pass</code> which will remove all declarations from the pipeline and result in an empty binary.</p>\n<p>In order to execute these passes one after another we have a <code>PassManager</code> which stores an <code>Array Pass</code> of all passes known to the compiler, these are put there by a<code>PassInstaller</code>. A <code>PassInstaller</code> will receive all of the passes currently stored in the compiler and return a new list of passes with its own pass inserted, a built-in pass removed, a built-in pass in a wrapper function etc. there are quite a few functions available to ease the creation of <code>PassInstaller</code>s: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/PassManager.lean#L128-L175\">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/PassManager.lean#L128-L175</a></p>\n<p>This is also where the meta data of a <code>Pass</code> gets relevant, as you can see from its definition it has a <code>phase</code> an an <code>occurence</code>. Right now we have 3 phases documented here: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/PassManager.lean#L14-L25\">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/PassManager.lean#L14-L25</a> and Leo is currently working on writing the function that will transition the declarations into <code>mono</code> so all of the <code>Pass</code>es in the pipeline right now will operate on <code>base</code>. Once we have populated the pipeline with more phases and a user tries to insert say a <code>base</code> <code>Pass</code> after a <code>mono</code> <code>Pass</code> the <code>PassManager</code> will notice this and throw an error. Furthermore a single <code>Pass</code> can occur multiple times in the compilation pipeline, for example <code>simp</code> appears multiple times in the pipeline so the first occurence of simp will have <code>occurence</code> set to <code>0</code>, the second to <code>1</code>. This is done so you could for example insert your own <code>Pass</code> right after a certain occurence of a certain multi-occurence pass, or right at the end of <code>mono</code> before we transition to lambda RC etc.</p>\n<p>Once you have defined a <code>PassInstaller</code> you can tag it with the <code>cpass</code> attribute like for example here in the built-in passes: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Passes.lean,then\">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Passes.lean,then</a> when you run the <code>Compiler.compile</code> function Lean will collect all the <code>PassInstaller</code>s tagged with <code>cpass</code>, execute them one after another to build a final <code>PassManager</code> state and run that pipeline on your input: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Main.lean#L59-L74\">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Main.lean#L59-L74</a></p>\n<p>The basic testing framework: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Testing.lean\">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Testing.lean</a></p>\n<p>This is also how the testing framework is realized, for example the <code>CSE</code> (common subexpression elimination) test adds two <code>PassInstaller</code>s via <code>cpass</code> to the pipeline: <a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/CompilerCSE.lean\">https://github.com/leanprover/lean4/blob/master/tests/lean/CompilerCSE.lean</a></p>\n<p>And the test framework is really only specialized functions for inserting <code>Pass</code>es that will do some sort of assertion (which might throw an error) before continuing to push the input declaration through</p>\n<p>Right now it fully revolves around these types: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Testing.lean#L46-L53\">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Testing.lean#L46-L53</a> where a <code>TestInstaller</code> is basically a function that you can pass the name of a <code>Pass</code> to test (i call these ones \"pass under test\" or PUT for short) as well as the name of your test and it will give you a <code>PassInstaller</code> There are roughly two kinds of tests to differentiate between, the \"simple tests\" which will be inserted after a certain pass (or all of its occurences) <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Testing.lean#L89-L168\">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Testing.lean#L89-L168</a> and thus only have access to the output of a certain compiler pass, we can use these to for example:</p>\n<ul>\n<li>claim that the size is not greater than some fix value</li>\n<li>that we definitely inlined the occurence of a certain function</li>\n<li>...<br>\nthe other type is \"input output tests\", these will replace the pass under test with a wrapper <code>Pass</code> which will pass the input declarations to the pass under test and can then provide both the original input as well as the pass under test output to our assertion: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Testing.lean#L137-L177\">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/LCNF/Testing.lean#L137-L177</a>  so we can do things like \"the overall size of declarations in the pipeline was reduced by this pass\" etc.</li>\n</ul>\n<p>If you have further ideas for abstractions or how to improve the current ones please do tell me, it took me like 4 iterations until i was happy with the ones that are there right now.</p>\n<p>and below you can see the 3 types of tests that i have implemented on top of this framework so far:</p>\n<ul>\n<li>a fixpoint tests which will assert \"if we run the pass on its own output it will not change again\" i.e. is at a fixpoint</li>\n<li>several in-out based size tests</li>\n<li>a \"constant does not occur in output\" test which we use for asserting that functions have been inlined right now</li>\n</ul>\n<p>in general tests that we could imagine are:</p>\n<ul>\n<li>ones that statically assert that the code does not become bigger than a certain threshold, this is will allow us to detect code explosion, so we could take a look at the code of some functions right now, figure that their size as is is appropriate and add an assertion at the end of the pipeline (or a certain phase for that matter) that says \"this function may never get bigger than X\", this will help us not only catch bugs in the code generator as well but also in the elaborator of lean (this is how we call the process that goes from the highly sugared version of lean to plain <code>Expr</code>s) etc.</li>\n<li>in general functions that make assertions about statistics, count how many join points are around, how many lets are around, Yuri brought up the idea of a cost model, if we had that we could also make assertions about costs etc.</li>\n<li>find further functions that we always want to be inlined</li>\n<li>other fun ideas you come up with :P</li>\n</ul>\n<p>regarding what functions we want to run tests against:</p>\n<ul>\n<li>handcrafted examples that try to expose some weakness/bug in the compilation pipeline (these are obviously the hardest to build)</li>\n<li>functions where a human can very clearly predict what is going to happen, and basically assert that the things we expected to happen happen, this is mostly for making sure the compiler remains sort of stable</li>\n<li>biiiig functions from the Lean compiler itself which make use of these huge monad stacks etc. where we want to know that the monad stack is getting properly optimized, e.g. its binds getting inlined into matched instead of function calls etc.</li>\n</ul>\n<p><span class=\"user-mention\" data-user-id=\"463095\">@Yuri de Wit</span> <span class=\"user-mention\" data-user-id=\"515083\">@Tom</span></p>",
        "id": 298469340,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1663012866
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> and <span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> is there an inventory of all the passes to be done for base but also for the other two phases?</p>",
        "id": 298496147,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1663026911
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> </p>\n<blockquote>\n<p>What is the plan for unboxed values in the new compiler?</p>\n</blockquote>\n<p>We are preserving more type information and planning to allocate values, such as <code>Prod</code> and <code>Exception</code>, on the stack. </p>\n<blockquote>\n<p>Would it be possible to somehow know that a type is 'plain old data' and have function to read and write them to ByteArray?</p>\n</blockquote>\n<p>We are considering having arrays of primitive types and structures. However, we are still figuring out what is the right interface when typing information is lost. For example, suppose we are representing <code>Array (Prod UInt32 UInt32)</code> as an array of pairs instead of an array of pointers to pairs (as it is now). Now, suppose we have <code>x : Array (Prod UInt32 UInt32)</code>, and <code>g ... x ...</code>, where the corresponding parameter in <code>g</code> has the  <code>Any</code> type because typing information was lost when converting to LCNF. We could produce a compilation error or add code to coerce the array of pairs into an array of pointers, but this is a linear time operation. We are also trying to decide whether we should provide mechanisms for controlling the process or not. In many cases, an array of pointers is a better runtime representation.</p>\n<blockquote>\n<p>-- Am I getting just addition on Vec2?</p>\n</blockquote>\n<p>If you add <code>@[inline]</code> at <code>FloatVector.add</code> and get today's bug fixes, then yes.</p>\n<p>As soon as we add support for user-defined rewriting rules in the compiler. You will also be able to write a theorem for the compiler stating that <br>\n<code>@FloatVector.add 2 x y = Vec2.add x y</code></p>",
        "id": 298503639,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663033691
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"463095\">Yuri de Wit</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes/near/298496147\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> and <span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> is there an inventory of all the passes to be done for base but also for the other two phases?</p>\n</blockquote>\n<p>For phase 1, the only remaining must-have pass is</p>\n<ul>\n<li><code>Specialize.lean</code> (it is not completed yet)</li>\n</ul>\n<p>We also want to have support for applying rewriting rules proved by the user, and constant propagation based on an interpreter for LCNF code.<br>\nWe also have the phase 0 <code>optimize_by</code> feature we discussed today that should be applied before we convert to LCNF.</p>\n<p>The phase 1 to phase 2 step will eliminate type parameters. That is, type parameters will be replaced with the <code>any</code> type if they have not been specialized by now. We will also remove universe levels, and will eliminate inductive types that have only one constructor that contains only one computationally relevant type (e.g., <code>Subtype</code>). We have to make sure <code>InferType</code> and <code>Check</code> also work for the phase 2 representation.</p>\n<p>The essential passes for phase 2 are </p>\n<ul>\n<li>Lambda lifting </li>\n<li>Dead parameter elimination</li>\n<li>Make sure <code>LCNF/Simp.lean</code> also works in phase 2</li>\n<li>Apply <code>implementedBy</code> attached to <code>casesOn</code> (we need it for the new computed fields feature)</li>\n<li>Eliminate dead branches in <code>cases</code> (it uses a small static analyzer that computes the shape of the objects a function can return</li>\n</ul>\n<p>In phase 3, the code is not considered pure anymore since we will insert reference counting operations</p>\n<ul>\n<li>Insert reset / reuse operations</li>\n<li>Infer additional borrow annotations</li>\n<li>Generate auxiliary definitions for creating closures. </li>\n<li>Insert inc / dec operations</li>\n<li>Inline (cheap) reset / reuse operations</li>\n<li>Eliminate the BaseIO monad overhead</li>\n<li>Eliminate redundant inc / dec operations using basic static analysis</li>\n</ul>",
        "id": 298504601,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663034748
    },
    {
        "content": "<p>Phase 3 is currently implemented at <code>src/Lean/Compiler/IR</code>, we want to redo it to using LCNF datastructures we discussed today, and preserving all type information we have left in phase 2.</p>",
        "id": 298504688,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663034830
    },
    {
        "content": "<p>Getting <code>Prod</code> on stack would be amazing!</p>",
        "id": 298515424,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1663046517
    },
    {
        "content": "<p>We were also planning on having a pass in phase 1 (it could easily also live in phase 2 though) that checks for duplication in the cases branches and turns the one with the most duplication into the \"default\" branch</p>",
        "id": 298519702,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1663049534
    },
    {
        "content": "<p>Is there also plan for having <code>Sum</code> on the stack? The programming language <a href=\"https://github.com/google-research/dex-lang\">Dex</a> is doing some cool things with arrays indices and using products and sums of indices for it.</p>",
        "id": 298615526,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1663084281
    },
    {
        "content": "<blockquote>\n<p>Is there also plan for having Sum on the stack? </p>\n</blockquote>\n<p>Yes.</p>\n<blockquote>\n<p>The programming language Dex is doing some cool things with arrays indices and using products and sums of indices for it.</p>\n</blockquote>\n<p>Do you want to present the main ideas at the next meeting?</p>",
        "id": 298615895,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663084404
    },
    {
        "content": "<p>I need to look at the language a big more closely to give a reasonable overview, so maybe next week or the one after that.</p>",
        "id": 298617493,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1663084897
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> I ran the compile test against the biggest lean declarations:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Core</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">envOfImports</span> <span class=\"o\">(</span><span class=\"n\">imports</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Environment</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n <span class=\"n\">importModules</span> <span class=\"o\">(</span><span class=\"n\">imports.map</span> <span class=\"o\">(</span><span class=\"n\">Import.mk</span> <span class=\"bp\">·</span> <span class=\"n\">false</span><span class=\"o\">))</span> <span class=\"n\">Options.empty</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Expr.size</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">bvar</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">lit</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">fvar</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">mdata</span> <span class=\"n\">_</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">size</span> <span class=\"n\">e</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">letE</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">v</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">size</span> <span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"n\">size</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">lam</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">body</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">size</span> <span class=\"n\">body</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">fn</span> <span class=\"n\">arg</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">size</span> <span class=\"n\">fn</span> <span class=\"bp\">+</span> <span class=\"n\">size</span> <span class=\"n\">arg</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">proj</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">size</span> <span class=\"n\">e</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">forallE</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">sort</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">mvar</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">isBlackListedAux</span> <span class=\"o\">(</span><span class=\"n\">declName</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"bp\">←</span><span class=\"n\">findDeclarationRanges</span><span class=\"bp\">?</span> <span class=\"n\">declName</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">getEnv</span>\n    <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">declName.isInternal</span><span class=\"o\">)</span>\n    <span class=\"bp\">&lt;||&gt;</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">isAuxRecursor</span> <span class=\"n\">env</span> <span class=\"n\">declName</span><span class=\"o\">)</span>\n    <span class=\"bp\">&lt;||&gt;</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">isNoConfusion</span> <span class=\"n\">env</span> <span class=\"n\">declName</span><span class=\"o\">)</span>\n    <span class=\"bp\">&lt;||&gt;</span> <span class=\"n\">isRec</span> <span class=\"n\">declName</span>\n    <span class=\"bp\">&lt;||&gt;</span> <span class=\"n\">isMatcher</span> <span class=\"n\">declName</span>\n    <span class=\"bp\">&lt;||&gt;</span> <span class=\"n\">isInstance</span> <span class=\"n\">declName</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">isBlackListed</span> <span class=\"o\">(</span><span class=\"n\">declName</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">env</span> <span class=\"o\">:</span> <span class=\"n\">Environment</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">isBlackListedAux</span> <span class=\"n\">declName</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">ret</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">foo.toIO</span> <span class=\"o\">{</span> <span class=\"n\">fileName</span> <span class=\"o\">:=</span> <span class=\"s2\">\"CompileBiggest\"</span><span class=\"o\">,</span> <span class=\"n\">fileMap</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">source</span> <span class=\"o\">:=</span> <span class=\"s2\">\"foo\"</span><span class=\"o\">,</span> <span class=\"n\">positions</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[],</span> <span class=\"n\">lines</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">env</span> <span class=\"o\">:=</span> <span class=\"n\">env</span> <span class=\"o\">}</span> <span class=\"o\">{}</span>\n  <span class=\"n\">return</span> <span class=\"n\">ret</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">limit</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">envOfImports</span> <span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">Lean</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">Init</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">candidates</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n  <span class=\"n\">for</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">const</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">env.constants.toList</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"bp\">!</span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">isBlackListed</span> <span class=\"n\">name</span> <span class=\"n\">env</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n      <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">defnInfo</span> <span class=\"n\">info</span> <span class=\"o\">:=</span> <span class=\"n\">const</span> <span class=\"k\">then</span>\n        <span class=\"k\">let</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">info.value</span>\n        <span class=\"k\">if</span> <span class=\"n\">Expr.size</span> <span class=\"n\">val</span> <span class=\"bp\">&gt;</span> <span class=\"n\">limit</span> <span class=\"k\">then</span>\n          <span class=\"n\">candidates</span> <span class=\"o\">:=</span> <span class=\"n\">candidates.push</span> <span class=\"n\">name</span>\n  <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"Compiling the top {candidates.size} functions\"</span>\n  <span class=\"n\">for</span> <span class=\"n\">c</span> <span class=\"k\">in</span> <span class=\"n\">candidates</span> <span class=\"k\">do</span>\n    <span class=\"n\">try</span>\n      <span class=\"n\">discard</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Compiler.compile</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">toIO</span> <span class=\"o\">{</span> <span class=\"n\">fileName</span> <span class=\"o\">:=</span> <span class=\"s2\">\"CompileBiggest\"</span><span class=\"o\">,</span> <span class=\"n\">fileMap</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">source</span> <span class=\"o\">:=</span> <span class=\"s2\">\"foo\"</span><span class=\"o\">,</span> <span class=\"n\">positions</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[],</span> <span class=\"n\">lines</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">env</span> <span class=\"o\">:=</span> <span class=\"n\">env</span> <span class=\"o\">}</span>\n    <span class=\"n\">catch</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{c} threw: {e}\"</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">foo</span> <span class=\"mi\">500</span>\n</code></pre></div>\n<p>its quite a primitive and arbitrary heuristic of course but it still exposed about 2 terminal screens of bugs caught by our checkers (hurray) for me so I wont paste them here^^</p>\n<p>How do you think we should deal with those?</p>",
        "id": 298638999,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1663092250
    },
    {
        "content": "<p>Great.</p>\n<blockquote>\n<p>How do you think we should deal with those?</p>\n</blockquote>\n<p>A new gist with them?<br>\nHopefully they are many instances of a small set of bugs.</p>",
        "id": 298646063,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663094728
    },
    {
        "content": "<p>Yeah I'd hope that as well, the question on how to deal with them was meant as in will you just try to kill them all by yourself? Or shall we try and split work up here? Or something else?</p>",
        "id": 298651219,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1663096649
    },
    {
        "content": "<p><a href=\"https://gist.github.com/hargoniX/30b6fb49af15797e664fdd86eb91a5dc\">https://gist.github.com/hargoniX/30b6fb49af15797e664fdd86eb91a5dc</a></p>",
        "id": 298652188,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1663096977
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Your help is very welcome. If you have time to investigate, please go ahead, and I will continue working on <code>Specialize.lean</code>.</p>",
        "id": 298658959,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663099421
    },
    {
        "content": "<p>I'll try to take a shot then <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 298659093,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1663099456
    },
    {
        "content": "<p>I minimized the first issue to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">ReaderM</span> <span class=\"n\">Unit</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">true</span> <span class=\"k\">then</span>\n    <span class=\"k\">match</span> <span class=\"n\">true</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">true</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">pure</span> <span class=\"o\">()</span>\n</code></pre></div>\n<p>it will fail right in the init pass because the jp transformation on alternatives isnt working properly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Compiler.init</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">32</span>\n    <span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"n\">a.1</span> <span class=\"o\">:=</span>\n      <span class=\"k\">let</span> <span class=\"n\">_x.2</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n      <span class=\"k\">let</span> <span class=\"n\">_x.3</span> <span class=\"o\">:=</span> <span class=\"n\">instDecidableEqBool</span> <span class=\"n\">_x.2</span> <span class=\"n\">_x.2</span>\n      <span class=\"n\">jp</span> <span class=\"n\">_jp.28</span> <span class=\"n\">_y.26</span> <span class=\"o\">:=</span>\n        <span class=\"k\">let</span> <span class=\"n\">_x.27</span> <span class=\"o\">:=</span> <span class=\"n\">_y.26</span> <span class=\"n\">a.1</span>\n        <span class=\"n\">_x.27</span>\n      <span class=\"n\">jp</span> <span class=\"n\">_jp.34</span> <span class=\"n\">_y.32</span> <span class=\"o\">:=</span>\n        <span class=\"k\">let</span> <span class=\"n\">_x.33</span> <span class=\"o\">:=</span> <span class=\"n\">_alt.19</span> <span class=\"n\">_y.32</span>\n        <span class=\"n\">goto</span> <span class=\"n\">_jp.28</span> <span class=\"n\">_x.33</span>\n      <span class=\"n\">jp</span> <span class=\"n\">_jp.31</span> <span class=\"n\">_y.29</span> <span class=\"o\">:=</span>\n        <span class=\"k\">let</span> <span class=\"n\">_x.30</span> <span class=\"o\">:=</span> <span class=\"n\">_alt.20</span> <span class=\"n\">_y.29</span>\n        <span class=\"n\">goto</span> <span class=\"n\">_jp.28</span> <span class=\"n\">_x.30</span>\n      <span class=\"n\">cases</span> <span class=\"n\">_x.3</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Decidable.isFalse</span> <span class=\"n\">x.4</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">let</span> <span class=\"n\">_x.5</span> <span class=\"o\">:=</span> <span class=\"n\">Id.instMonadId</span>\n        <span class=\"k\">let</span> <span class=\"n\">_x.6</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">ReaderT.instApplicativeReaderT</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_x.5</span>\n        <span class=\"k\">let</span> <span class=\"n\">_x.7</span> <span class=\"o\">:=</span> <span class=\"n\">_x.6</span> <span class=\"bp\">#</span> <span class=\"mi\">1</span>\n        <span class=\"k\">let</span> <span class=\"n\">_x.8</span> <span class=\"o\">:=</span> <span class=\"n\">_x.7</span> <span class=\"bp\">#</span> <span class=\"mi\">0</span>\n        <span class=\"k\">let</span> <span class=\"n\">_x.9</span> <span class=\"o\">:=</span> <span class=\"o\">()</span>\n        <span class=\"k\">let</span> <span class=\"n\">_x.10</span> <span class=\"o\">:=</span> <span class=\"n\">_x.8</span> <span class=\"n\">_</span> <span class=\"n\">_x.9</span>\n        <span class=\"n\">goto</span> <span class=\"n\">_jp.28</span> <span class=\"n\">_x.10</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Decidable.isTrue</span> <span class=\"n\">x.11</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">fun</span> <span class=\"n\">_f.18</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n          <span class=\"k\">let</span> <span class=\"n\">_x.12</span> <span class=\"o\">:=</span> <span class=\"n\">Id.instMonadId</span>\n          <span class=\"k\">let</span> <span class=\"n\">_x.13</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">ReaderT.instApplicativeReaderT</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_x.12</span>\n          <span class=\"k\">let</span> <span class=\"n\">_x.14</span> <span class=\"o\">:=</span> <span class=\"n\">_x.13</span> <span class=\"bp\">#</span> <span class=\"mi\">1</span>\n          <span class=\"k\">let</span> <span class=\"n\">_x.15</span> <span class=\"o\">:=</span> <span class=\"n\">_x.14</span> <span class=\"bp\">#</span> <span class=\"mi\">0</span>\n          <span class=\"k\">let</span> <span class=\"n\">_x.16</span> <span class=\"o\">:=</span> <span class=\"o\">()</span>\n          <span class=\"k\">let</span> <span class=\"n\">_x.17</span> <span class=\"o\">:=</span> <span class=\"n\">_x.15</span> <span class=\"n\">_</span> <span class=\"n\">_x.16</span>\n          <span class=\"n\">_x.17</span>\n        <span class=\"k\">let</span> <span class=\"n\">_alt.19</span> <span class=\"o\">:=</span> <span class=\"n\">_f.18</span>\n        <span class=\"k\">let</span> <span class=\"n\">_alt.20</span> <span class=\"o\">:=</span> <span class=\"n\">_f.18</span>\n        <span class=\"n\">cases</span> <span class=\"n\">_x.2</span>\n        <span class=\"bp\">|</span> <span class=\"n\">Bool.false</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"k\">let</span> <span class=\"n\">_x.21</span> <span class=\"o\">:=</span> <span class=\"o\">()</span>\n          <span class=\"n\">goto</span> <span class=\"n\">_jp.31</span> <span class=\"n\">_x.21</span>\n        <span class=\"bp\">|</span> <span class=\"n\">Bool.true</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"k\">let</span> <span class=\"n\">_x.23</span> <span class=\"o\">:=</span> <span class=\"o\">()</span>\n          <span class=\"n\">goto</span> <span class=\"n\">_jp.34</span> <span class=\"n\">_x.23</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">out</span> <span class=\"n\">of</span> <span class=\"n\">scope</span> <span class=\"n\">free</span> <span class=\"kd\">variable</span> <span class=\"n\">_alt.19</span>\n</code></pre></div>\n<p>so _jp.34 (as well as _jp.31) are incorrectly referring to out of scope variables that are defined when they are called. As I understand it we need to improve tracking of dependencies in the body of the jp in order to fix this?</p>",
        "id": 298672604,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1663105621
    },
    {
        "content": "<p>Thanks a lot for isolating the problem. It was super useful. I pushed a fix for it.<br>\n<a href=\"https://github.com/leanprover/lean4/commit/8f2ab82408788611bbc261a6c1779430cf3d7074\">https://github.com/leanprover/lean4/commit/8f2ab82408788611bbc261a6c1779430cf3d7074</a></p>",
        "id": 298678086,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663108826
    },
    {
        "content": "<p>It was a dependency issue as you conjectured (line 128 at <code>ToLCNF.lean</code>).</p>",
        "id": 298678172,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663108883
    },
    {
        "content": "<p>Re the non termination issue, this is even provokable in the current compiler even though a little more elaborate:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">C</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">c1</span> <span class=\"bp\">|</span> <span class=\"n\">c2</span> <span class=\"bp\">|</span> <span class=\"n\">c3</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">C</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">c1</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">c2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g1</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">g2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c1</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c2</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g1simp</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">@[csimp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">g1</span> <span class=\"bp\">=</span> <span class=\"n\">g1simp</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">funext</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span>\n  <span class=\"n\">apply</span> <span class=\"n\">funext</span>\n  <span class=\"n\">intro</span> <span class=\"n\">f</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">g1</span><span class=\"o\">,</span> <span class=\"n\">g2</span><span class=\"o\">,</span> <span class=\"n\">g1simp</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">dontTerminate</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">dontTerminate</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"Hello, {g1 0 dontTerminate}!\"</span>\n</code></pre></div>\n<p>will:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Hello</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"bp\">!</span>\n</code></pre></div>",
        "id": 299218818,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1663352879
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Thanks for posting the example. <br>\nI think we need to discuss in the compiler documentation this example and the other ones we covered in today's meeting.<br>\nI think we both agreed during the meeting that it is ok to eliminate a very expensive dead code. For example, it should be ok to quickly return <code>Hello, 0!</code> in the following variant of your example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">exp</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ack</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">10000</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">10000</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"Hello, {g1 0 exp}!\"</span>\n</code></pre></div>\n<p>where <code>ack</code> is the Ackermann function. <br>\nThen, the issues we discussed today and the example above are fine if we interpret <code>partial</code> as a total function that terminates after an insanely huge amount of \"fuel\" has been exhausted. The result in this case that cannot be observed is the \"default\" value. Lean only allows us to use <code>partial</code> if the type is inhabited. <br>\nThe <code>dontTerminate</code> function above would morally be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">dontTerminate</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">go</span> <span class=\"n\">hugeFuel</span> <span class=\"n\">x</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">go</span> <span class=\"o\">(</span><span class=\"n\">fuel</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">fuel</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">default</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">fuel</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">go</span> <span class=\"n\">fuel</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 299227178,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663356044
    },
    {
        "content": "<p>If we use this interpretation of <code>partial</code>, all examples we discussed today should be fine.</p>",
        "id": 299228708,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663356686
    },
    {
        "content": "<p>Here are the examples discussed in today's meeting</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">C</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">c1</span> <span class=\"bp\">|</span> <span class=\"n\">c2</span> <span class=\"bp\">|</span> <span class=\"n\">c3</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span>\n\n<span class=\"kd\">@[inline]</span> <span class=\"kd\">def</span> <span class=\"n\">g2</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>   <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">c1</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">c1</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">g1</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">g2</span> <span class=\"o\">(</span><span class=\"n\">g1</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c1</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c2</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span>   <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n\n\n<span class=\"c1\">-- The old and new code generators convert `g1` into the constant function that always return `0`</span>\n<span class=\"c1\">-- Now, what about?</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">g1'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">g2</span> <span class=\"o\">(</span><span class=\"n\">g1'</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c1</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span>   <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n\n<span class=\"c1\">-- `g1'` is the function that always returns `default Nat`, and prints the unreachale code has been reached.</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">g1''</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">g2</span> <span class=\"o\">(</span><span class=\"n\">g1''</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c1</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False.elim</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span>   <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n\n<span class=\"c1\">-- `g1''` produces a fatal error since it reached the `False.elim sorry`</span>\n<span class=\"c1\">-- #eval g1'' 0</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">ack</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span>   <span class=\"n\">y</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">y</span><span class=\"bp\">+</span><span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">ack</span> <span class=\"n\">x</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ack</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">ack</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bad1</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">g2</span> <span class=\"o\">(</span><span class=\"n\">ack</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1000</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1000</span><span class=\"o\">))</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c1</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c2</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span>   <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bad2</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">g2</span> <span class=\"o\">(</span><span class=\"n\">ack</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1000</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1000</span><span class=\"o\">))</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c1</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span>   <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bad3</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">g2</span> <span class=\"o\">(</span><span class=\"n\">ack</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1000</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1000</span><span class=\"o\">))</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c1</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False.elim</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span>   <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 299228860,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663356731
    },
    {
        "content": "<p>Thinking about this semantics a bit more, I think it should be legal to optimize</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">dontTerminate</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">dontTerminate</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">dontTerminate</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">default</span>\n</code></pre></div>\n<p>because the compiler can see that the only possible return value of the function is <code>default</code> (after a <code>hugeFuel</code> number of iterations of a side-effect-free function)</p>",
        "id": 299627062,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663614055
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Yes, the code generator is allowed to do that. It is not capable of applying this kind of transformation right now, but it is a valid one. We should make clear to users that this is the semantics we are using, and <code>dontTerminate</code> is a pure and total function in Lean.</p>",
        "id": 299628409,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663614554
    },
    {
        "content": "<p>BTW, there is a bug in the current/old code generator that is related to the partial semantics and related to the transformation you suggested above. <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> created the following <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> for it</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">swipc</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">swipc</span> <span class=\"o\">()</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>In the current/old code generator, we have the following transformation. <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/IR/ElimDeadBranches.lean#L315\">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/IR/ElimDeadBranches.lean#L315</a><br>\nIt uses a static analyzer that computes abstract values representing possible result values: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/IR/ElimDeadBranches.lean#L13\">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/IR/ElimDeadBranches.lean#L13</a><br>\nThis static analyzer is not taking the semantics we have above into account. The default value must be taken into account for functions marked as <code>partial</code>.</p>",
        "id": 299631593,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663615885
    },
    {
        "content": "<p>I think there is another issue related to this, which is that you could end up returning <code>default</code> even though you only used a <code>Nonempty A</code> proof of existence</p>",
        "id": 299634235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663617005
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">computableChoice</span> <span class=\"o\">[</span><span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">computableChoice</span>\n</code></pre></div>\n<p>What is the semantics of calling this function?</p>",
        "id": 299634432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663617116
    },
    {
        "content": "<p>I think it is still okay to say that this function returns an unknown value (specifically, <code>Classical.choice α</code>), and if that makes it all the way to codegen then we can still use a loop to implement it</p>",
        "id": 299634921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663617297
    },
    {
        "content": "<p>but you would also have to take this into account in that ElimDeadBranches optimization pass</p>",
        "id": 299635022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663617349
    },
    {
        "content": "<p>I don't recall why we added support for <code>Nonempty</code> at <code>partial</code>, it is sufficient for ensuring we are preserving logical integrity, but is just creating problems for the code generator.</p>",
        "id": 299635097,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663617364
    },
    {
        "content": "<p>Another complication is that we also use </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mkInhabitantFor</span> <span class=\"o\">(</span><span class=\"n\">declName</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n   <span class=\"bp\">...</span>\n    <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">findAssumption</span><span class=\"bp\">?</span> <span class=\"n\">xs</span> <span class=\"n\">type</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"n\">xs</span> <span class=\"n\">x</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span>   <span class=\"bp\">=&gt;</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>for showing that the type is inhabited. We will also have to track this one. This one is easier to support, but we have to remember to support it too.</p>",
        "id": 299635405,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663617511
    },
    {
        "content": "<p>I think the best way to handle both problems is for the compiler to assume that the result of a partial function \"at the end\" is an arbitrary opaque value of the type rather than trying to use properties of it in CFG value analysis</p>",
        "id": 299635722,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663617632
    },
    {
        "content": "<p>That is, the semantics would be more like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">dontTerminate</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">go</span> <span class=\"n\">hugeFuel</span> <span class=\"n\">x</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">go</span> <span class=\"o\">(</span><span class=\"n\">fuel</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">fuel</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nondeterministicChoice</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">fuel</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">go</span> <span class=\"n\">fuel</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>where <code>nondeterministicChoice</code> is validly refined by any value of the type</p>",
        "id": 299636036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663617746
    },
    {
        "content": "<p>Yes, I agree this is the simplest solution, but any tail-recursive function marked as <code>partial</code> is now essentially returning <code>Top</code> (\"any\") from the point of view of <code>ElimDeadBranches</code>.</p>",
        "id": 299636345,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663617857
    },
    {
        "content": "<p>In a production application setting, I would be quite concerned about the compiler automatically turning non-terminating partials into a <code>default</code>result. In this case, this non-termination is like a bug and it needs to be fixed not by the compiler, but by the developer. It better be caught by some unit or integration tests. Or am I missing something?</p>",
        "id": 299636631,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1663617975
    },
    {
        "content": "<p>I think the \"correct\" answer to that is that if you want proper nontermination you should be in a monad with effects like <code>BaseIO</code></p>",
        "id": 299636747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663618032
    },
    {
        "content": "<p>the compiler can and will assume that any pure function is terminating</p>",
        "id": 299636775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663618045
    },
    {
        "content": "<p>Unfortunately, diagnosing UB (which this basically is) is a really hard thing in general, so while it would be nice to report this surprising behavior to the programmer I doubt we can promise that in general</p>",
        "id": 299636957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663618117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes/near/299636747\">said</a>:</p>\n<blockquote>\n<p>I think the \"correct\" answer to that is that if you want proper nontermination you should be in a monad with effects like <code>BaseIO</code></p>\n</blockquote>\n<p>Exactly. Non-termination is an effect, and the <code>partial</code> keyword is not providing this effect. If users want this effect and a guarantee that it is preserved by the compiler, they must use a monad that provides it.</p>",
        "id": 299637161,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663618205
    },
    {
        "content": "<p>I think one source of confusion is the keyword name: <code>partial</code>. Perhaps, we should pick a new name that makes clear the semantics we are using. BTW, I think the current name is also responsible for the following recurrent question: \"why is <code>f</code> not marked as <code>partial</code> if it is using a partial function?\"</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">g</span> <span class=\"n\">x</span>\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">g</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 299639464,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663619169
    },
    {
        "content": "<p>I feel like I'm starting to regret not making the meeting :) . Was there a specific use case that triggered this discussion?</p>",
        "id": 299639919,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663619360
    },
    {
        "content": "<p>the first half of the meeting was discussing Leo's proposed semantics for partiality <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes/near/299227178\">https://leanprover.zulipchat.com/#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20first.20meeting.20notes/near/299227178</a> and potential issues and consequences of this decision</p>",
        "id": 299640551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663619592
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> The topic appeared in the last two meetings. I brought it up because of the issue <a href=\"https://github.com/leanprover/lean4/issues/1529\">https://github.com/leanprover/lean4/issues/1529</a>. The issue is triggered by a static analyzer that does not take into account the semantics we have for <code>partial</code>. Then, while preparing material to discuss this issue last Friday, I created a few examples (posted above) that show how the compiler simplifier can eliminate non-termination too using: inlining, dead code elimination, and cases on constructor reduction.</p>",
        "id": 299640733,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663619654
    },
    {
        "content": "<p>During today's meeting, we also discussed the possibility of having a <code>Partial</code> monad. I think this is useful for users that want the \"non-termination\" effect. However, we have many instances of <code>partial</code> in Lean's own implementation, and I don't want to have this extra overhead there.</p>",
        "id": 299641408,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663619897
    },
    {
        "content": "<p>Ahh, it looks like I missed quite a few messages. Though I have to say that to me there is a profound difference between the examples in this thread, where non-termination is eliminated as dead code, and the linked issue, where non-termination is eliminated solely because it is non-termination. The former seems generally agreeable, the latter is a bit more surprising but somewhat understandable from an implementation perspective.</p>",
        "id": 299643646,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663620875
    },
    {
        "content": "<p>Though what the Boxing pass does in the linked issue could of course be seen as DCE as well, so I can see how the fuel proposal could be the most sensible consistent semantics</p>",
        "id": 299644749,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663621340
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> Yes, they are different. The examples in this thread suggest we have to make it clear to users the semantics of the <code>partial</code> keyword used by the compiler. The issue on GitHub is a reminder that we (the developers) should take the same semantics into account when implementing static analyzers and other transformations. I agree with <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> that assuming an arbitrary opaque value is the simplest solution when implementing and justifying code transformations.</p>",
        "id": 299644940,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663621415
    },
    {
        "content": "<p>what, concretely, would happen to Gabriel's <code>swipc</code> example though? Would it just not be changed, or would it be replaced by <code>def swipc := lcLoop</code> and then <code>lcLoop</code> replaced for an infinite loop in codegen?</p>",
        "id": 299645305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663621558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299645305\">said</a>:</p>\n<blockquote>\n<p>what, concretely, would happen to Gabriel's <code>swipc</code> example though? Would it just not be changed, or would it be replaced by <code>def swipc := lcLoop</code> and then <code>lcLoop</code> replaced for an infinite loop in codegen?</p>\n</blockquote>\n<p>It will not change. The fix will affect the static analyzer which will now return <code>Top</code> (\"any\") for <code>swipc</code>, and with this information, no simplification will be performed.</p>",
        "id": 299645747,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663621794
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299627062\">said</a>:</p>\n<blockquote>\n<p>Thinking about this semantics a bit more, I think it should be legal to optimize</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">dontTerminate</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">dontTerminate</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">dontTerminate</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">default</span>\n</code></pre></div>\n<p>because the compiler can see that the only possible return value of the function is <code>default</code> (after a <code>hugeFuel</code> number of iterations of a side-effect-free function)</p>\n</blockquote>\n<p>This transformation is problematic precisely because of the <code>Nonempty</code>-issue that Mario mentioned.  Recall that we're intentionally allowing <code>Nonempty</code> as a witness for <code>partial def</code> to support FFI values, which do not have a (VM-computable) default value.</p>\n<p>What should the reference returned by <code>dontTerminate (x : Nat) : IO.Ref</code> point to?  Should <code>dontTerminate (x : Nat) : FS.Handle</code> return an invalid handle?</p>",
        "id": 299700174,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1663660533
    },
    {
        "content": "<p>Another fun quiz: what do the following functions compile to?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">function1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Id.run</span> <span class=\"k\">do</span> <span class=\"n\">StateT.run'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n    <span class=\"n\">repeat</span> <span class=\"n\">modify</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"n\">get</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">function2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Id.run</span> <span class=\"k\">do</span> <span class=\"n\">StateT.run'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n    <span class=\"n\">repeat</span> <span class=\"n\">modify</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"n\">pure</span> <span class=\"mi\">42</span>\n</code></pre></div>",
        "id": 299701097,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1663660972
    },
    {
        "content": "<p>Broadly speaking, my preferences for the semantics of <code>dontTerminate</code> are:<br>\nruntime error message &gt; nontermination &gt; crash &gt; returning a made-up value</p>",
        "id": 299705793,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1663663056
    },
    {
        "content": "<p>You say \"runtime error message\" but this would probably be detected at compile time. If it makes it to runtime then it will almost certainly manifest as nontermination because the compiler wasn't able to solve the halting problem in this case</p>",
        "id": 299730325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663673583
    },
    {
        "content": "<p>also, is this a <code>panic!</code> like message where something else happens after the message, and if so, what?</p>",
        "id": 299730564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663673691
    },
    {
        "content": "<p>It can't be like <code>panic!</code> because we don't necessarily have a default value.  It would have to be stack unwinding, but we don't do that anywhere else.</p>\n<blockquote>\n<p>but this would probably be detected at compile time.</p>\n</blockquote>\n<p>Yes, however the compiler shouldn't fail because it has detected nonterminating code.  I would imagine that this can easily happen in generic code, and it is perfectly fine to have a nonterminating function, as long as it is never called.</p>",
        "id": 299731420,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1663674044
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299730564\">said</a>:</p>\n<blockquote>\n<p>also, is this a <code>panic!</code> like message where something else happens after the message, and if so, what?</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299731420\">said</a>:</p>\n<blockquote>\n<p>It can't be like <code>panic!</code> because we don't necessarily have a default value.  It would have to be stack unwinding, but we don't do that anywhere else.</p>\n</blockquote>\n<p>Could we use a a variant of <code>panic!</code> defined with <code>Nonempty</code> instead of <code>Inhabited</code> that always aborts so that the physical default value does not matter?</p>",
        "id": 299744692,
        "sender_full_name": "Mac",
        "timestamp": 1663679049
    },
    {
        "content": "<p>It could also loop instead of abort</p>",
        "id": 299744796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663679083
    },
    {
        "content": "<p>or deadlock if you want to be good to the planet</p>",
        "id": 299744995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663679157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> Sure, though I imagine aborting would generally be desired over a loop in most use cases. Except, I guess, if it is in a separate thread and the user just wants that thread to stall rather than killing the whole program.</p>",
        "id": 299745395,
        "sender_full_name": "Mac",
        "timestamp": 1663679286
    },
    {
        "content": "<p>Looping would also be more semantically correct in the sense that this alternate <code>panic!</code> is meant for nonterminating functions which are technically suppose to loop.</p>",
        "id": 299745518,
        "sender_full_name": "Mac",
        "timestamp": 1663679330
    },
    {
        "content": "<blockquote>\n<p>This transformation is problematic precisely because of the Nonempty-issue that Mario mentioned. Recall that we're intentionally allowing Nonempty as a witness for partial def to support FFI values, which do not have a (VM-computable) default value.</p>\n</blockquote>\n<p>I believe <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> suggested the transformation as a hypothetical one. One that would be correct based on the semantics we discussed yesterday. That being said, I want to make it clear that the compiler old and new is not going to do that.</p>",
        "id": 299750916,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663681034
    },
    {
        "content": "<blockquote>\n<p>What should the reference returned by dontTerminate (x : Nat) : IO.Ref point to? Should dontTerminate (x : Nat) : FS.Handle return an invalid handle?</p>\n</blockquote>\n<p>After yesterday's discussion, we are moving towards using an opaque value instead of the default because of the <code>Nonempty</code>. <br>\nNote that the information is only used by the static analyzers.</p>",
        "id": 299751190,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663681161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299701097\">said</a>:</p>\n<blockquote>\n<p>Another fun quiz: what do the following functions compile to?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">function1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Id.run</span> <span class=\"k\">do</span> <span class=\"n\">StateT.run'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n    <span class=\"n\">repeat</span> <span class=\"n\">modify</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"n\">get</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">function2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Id.run</span> <span class=\"k\">do</span> <span class=\"n\">StateT.run'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n    <span class=\"n\">repeat</span> <span class=\"n\">modify</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"n\">pure</span> <span class=\"mi\">42</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Note that both examples are instances of <a href=\"https://github.com/leanprover/lean4/issues/1529\">https://github.com/leanprover/lean4/issues/1529</a><br>\nThe static analyzer is saying that the code corresponding to <code>repeat modify (.+1)</code> returns nothing (<code>bottom</code>). This is incorrect. <br>\nThe new static analyzer will say they return \"any\" (<code>top</code>), and the continuation will not be removed, and both will loop.</p>",
        "id": 299751857,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663681384
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299750916\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>This transformation is problematic precisely because of the Nonempty-issue that Mario mentioned. Recall that we're intentionally allowing Nonempty as a witness for partial def to support FFI values, which do not have a (VM-computable) default value.</p>\n</blockquote>\n<p>I believe <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> suggested the transformation as a hypothetical one. One that would be correct based on the semantics we discussed yesterday. That being said, I want to make it clear that the compiler old and new is not going to do that.</p>\n</blockquote>\n<p>I prefer to avoid this kind of thing though when possible. If our semantics justifies the transformation and it's an \"optimization\" then we should always be licensed to do it, or our semantics needs revision</p>",
        "id": 299752092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663681447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/299705793\">said</a>:</p>\n<blockquote>\n<p>Broadly speaking, my preferences for the semantics of <code>dontTerminate</code> are:<br>\nruntime error message &gt; nontermination &gt; crash &gt; returning a made-up value</p>\n</blockquote>\n<p>In the new code generator, nontermination may be eliminated if it is dead code, or may loop at runtime.</p>",
        "id": 299752289,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663681504
    },
    {
        "content": "<blockquote>\n<p>I prefer to avoid this kind of thing though when possible. If our semantics justifies the transformation and it's an \"optimization\" then we should always be licensed to do it, or our semantics needs revision</p>\n</blockquote>\n<p>I am open to suggestions. My main constraint is: the code generator at the LCNF level should be able to treat code as pure.</p>",
        "id": 299753088,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663681737
    },
    {
        "content": "<blockquote>\n<p>Yes, however the compiler shouldn't fail because it has detected nonterminating code. I would imagine that this can easily happen in generic code, and it is perfectly fine to have a nonterminating function, as long as it is never called.</p>\n</blockquote>\n<p>I agree, the compiler should not fail.</p>",
        "id": 299753479,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663681850
    },
    {
        "content": "<blockquote>\n<p>Could we use a a variant of panic! defined with Nonempty instead of Inhabited that always aborts so that the physical default value does not matter?</p>\n</blockquote>\n<p>This is an important topic, and we should create a thread for it. We have discussed <code>panic!</code> many times and never reached a consensus. <br>\nIn the current system, we have flags to control its behavior: aborting, disabling error message, etc. The flags represent different views about what <code>panic</code> should do.</p>",
        "id": 299753963,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663682023
    },
    {
        "content": "<p>Here's an elaboration of the semantics for nontermination, a more abstract version of Leo's fuel semantics, that I was discussing with <span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span> :</p>\n<p>Fix a (large) natural number <code>C</code>. We consider a nondeterministic model for computation of lean expressions as follows: Each call to a partial function uses up one \"recursion token\". Prior to consuming <code>C</code> recursion tokens all partial functions must be called as normal. Once the model has used up <code>C</code> recursion tokens starting from <code>main</code>, a subsequent call to a partial function has the following nondeterministic options: it can either call the function again, or return any value of the target type (even a noncomputable one).</p>\n<p>Larger values of <code>C</code> yield less nondeterminism in the model, but even the intersection of all choices of <code>C</code> yields nondeterminism where <code>def loop : A := loop</code> returns any value of type <code>A</code>.</p>\n<p>The compiler fixes a choice for <code>C</code> (this is a fixed constant in the vicinity of 2^2^64, which is allowed to be compiler and architecture dependent) and promises that it will produce an execution consistent with <em>every</em> possible nondeterministic outcome of the <code>C</code>-model. In the event that different nondeterministic executions disagree, the compiler is required to exhaust resources or output a looping computation.</p>",
        "id": 299756652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663682799
    },
    {
        "content": "<p>I am happy with this semantics.</p>",
        "id": 299815849,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663696497
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Jitsi links 2022-09-23</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Siddharth Bhat<br>\nSiddharth Bhat says:<br>\n<a href=\"http://www.cse.chalmers.se/~peterd/papers/Inductive_Families.pdf\">http://www.cse.chalmers.se/~peterd/papers/Inductive_Families.pdf</a></p>\n<p>19:03<br>\nHenrik Boeving<br>\nHenrik Boeving says:<br>\n<a href=\"https://reader.elsevier.com/reader/sd/pii/S0167642397000294?token=86635F7D899212AD0A6A793EDAAD9E7416F713F7DA2DB1ED2DA63F292FE7B57415E27D28D657785EEBC0DB36963E3152&amp;originRegion=us-east-1&amp;originCreation=20220808183502\">https://reader.elsevier.com/reader/sd/pii/S0167642397000294?token=86635F7D899212AD0A6A793EDAAD9E7416F713F7DA2DB1ED2DA63F292FE7B57415E27D28D657785EEBC0DB36963E3152&amp;originRegion=us-east-1&amp;originCreation=20220808183502</a></p>\n<p><a href=\"https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=DB7AF69CF92D72308A6609FB71056D6B?doi=10.1.1.51.3123&amp;rep=rep1&amp;type=pdf\">https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=DB7AF69CF92D72308A6609FB71056D6B?doi=10.1.1.51.3123&amp;rep=rep1&amp;type=pdf</a></p>\n<p><a href=\"http://www.cin.ufpe.br/~alms/ps/thesis.ps.gz\">http://www.cin.ufpe.br/~alms/ps/thesis.ps.gz</a></p>\n<p><a href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/compiling-without-continuations.pdf\">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/compiling-without-continuations.pdf</a></p>\n<p>19:19<br>\nTom<br>\nTom says:<br>\n<a href=\"https://hackage.haskell.org/package/recursion-schemes\">https://hackage.haskell.org/package/recursion-schemes</a></p>\n<p><a href=\"https://deque.blog/2017/01/20/catamorph-your-dsl-deep-dive/\">https://deque.blog/2017/01/20/catamorph-your-dsl-deep-dive/</a></p>\n<p>Tom says:Not necessarily:</p>\n<p><a href=\"https://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf\">https://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf</a></p>\n</div></div>\n<p>I didn't want to include any other messages without asking.</p>",
        "id": 300425318,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1663956932
    },
    {
        "content": "<p>A few of the links I posted regarding the composition of passes/optimizations:</p>\n<p><a href=\"https://hackage.haskell.org/package/recursion-schemes\">https://hackage.haskell.org/package/recursion-schemes</a></p>\n<p>Here's a good intro article:<br>\n<a href=\"https://deque.blog/2017/01/20/catamorph-your-dsl-deep-dive/\">https://deque.blog/2017/01/20/catamorph-your-dsl-deep-dive/</a></p>\n<p>Also, during the discussion about the deep nested lets for lists, I remembered this.  This is not applicable because the IR is different but thought it may be interesting nonetheless:</p>\n<p><a href=\"https://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf\">https://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf</a></p>",
        "id": 300425384,
        "sender_full_name": "Tom",
        "timestamp": 1663956961
    },
    {
        "content": "<p>Some additional notes</p>\n<ul>\n<li>We mentioned \"confluence\" during the meeting. <a href=\"https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)\">https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)</a> Knuth-Bendix is an algorithm for transforming a rewriting system into a confluent one: <a href=\"https://www.cs.tufts.edu/~nr/cs257/archive/don-knuth/knuth-bendix.pdf\">https://www.cs.tufts.edu/~nr/cs257/archive/don-knuth/knuth-bendix.pdf</a>  Remark: I don't think we need this in the near future.</li>\n<li>The data structure used in the new code generator is based on the one use in GHC. The paper \"Compiling  without continuations\" <a href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/compiling-without-continuations.pdf\">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/compiling-without-continuations.pdf</a> I am very happy with this data structure.</li>\n</ul>",
        "id": 300427553,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663957740
    },
    {
        "content": "<p>We have also discussed whether we want to support big list/array/matrix literals in the code generator. We also don't have good support for them in the kernel. That is, we may get a stack overflow in the kernel when type checking this kind of literal. I hope we don't have real use-cases for this feature, and if we do, then we can work around by loading them from a data file. If this is not a satisfactory solution, I think an option is to extend the <code>Literal</code> type we have at <code>src/Lean/Expr.lean</code>.</p>",
        "id": 300435619,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663960683
    },
    {
        "content": "<p>Recall that we need more tests that make heavy use of dependent types and/or may confuse the code generator. For example,  <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> mentioned functions that may return data or proofs depending on the input arguments. This is a great example. Here is another example that triggered a bug earlier this week in the new cod generator: <a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/fieldTypeBug.lean\">https://github.com/leanprover/lean4/blob/master/tests/lean/run/fieldTypeBug.lean</a></p>",
        "id": 300437436,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663961411
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span> You mentioned issues in GHC when one is using rewriting rules as optimization rules. I have assumed the issue was due to the fact that the rewriting rules are probably not confluent, but I am now not sure whether this is the problem you were referring to. Do you have a link where we can read more about these issues?</p>",
        "id": 300439173,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1663962183
    },
    {
        "content": "<p>Regarding big literals and stack overflow: One thing that the rust compiler does to handle big / deep expressions is to use <a href=\"https://docs.rs/stacker/latest/stacker/\"><code>stacker</code></a> to spill the C stack onto the heap when it gets too large. The interface for this is fairly light: you just wrap any recursive functions that you think are subject to deep recursion and stack overflow in a call to the <code>maybe_grow</code> function which takes a callback where you put the body of the function. I think we could do something like this for lean, and it comes up in enough cases that it would probably be worthwhile. It's certainly a lot easier than rewriting everything to be tail recursive.</p>",
        "id": 300483278,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663994134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/300483278\">said</a>:</p>\n<blockquote>\n<p>Regarding big literals and stack overflow: One thing that the rust compiler does to handle big / deep expressions is to use <a href=\"https://docs.rs/stacker/latest/stacker/\"><code>stacker</code></a> to spill the C stack onto the heap when it gets too large. The interface for this is fairly light: you just wrap any recursive functions that you think are subject to deep recursion and stack overflow in a call to the <code>maybe_grow</code> function which takes a callback where you put the body of the function. I think we could do something like this for lean, and it comes up in enough cases that it would probably be worthwhile. It's certainly a lot easier than rewriting everything to be tail recursive.</p>\n</blockquote>\n<p>It is worth investigating how the APIs are implemented. I am assuming they need special code for different platforms. </p>\n<blockquote>\n<p>It's certainly a lot easier than rewriting everything to be tail recursive.</p>\n</blockquote>\n<p>YES! </p>\n<p>BTW, when we started the Lean project we added support for \"-fsplit_stack\" (<a href=\"https://github.com/leanprover/lean4/blob/master/src/CMakeLists.txt#L184\">https://github.com/leanprover/lean4/blob/master/src/CMakeLists.txt#L184</a>). Not sure whether it still works. At the time, only gcc / linux had support for this. The C compiler generates code that uses the heap to implement the call stack. This was almost 10 years ago, I am assuming the support should be much better today.</p>",
        "id": 300542981,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1664028486
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> I was thinking of a general class of performance bug, where rewrite rules break across compiler versions, and across syntactic changes of code. causing performance problems: </p>\n<ul>\n<li><a href=\"https://gitlab.haskell.org/ghc/ghc/-/issues/19557\">https://gitlab.haskell.org/ghc/ghc/-/issues/19557</a></li>\n<li>How do we test fusion <a href=\"https://github.com/haskell/vector/issues/229\">issue at <code>haskell/vector</code></a>. </li>\n<li>Haskell's <code>Data.Text</code> <a href=\"https://github.com/haskell/text/pull/348\">moved away from using rewrite rules entirely</a>.</li>\n</ul>",
        "id": 300562161,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1664038872
    },
    {
        "content": "<p>Regarding the testing of fusion that should just be trivially possible by inserting a test pass that looks for cases that could have been fused shouldn't it?</p>",
        "id": 300563419,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1664039661
    },
    {
        "content": "<p>Looking it up, it seems like <code>-fsplit_stack</code> requires recompiling everything with that option, including possibly the standard library, which sounds like it's making some global changes which affect all function calls. The stacker approach doesn't suffer from this issue, since it is explicitly put on individual functions and everything else is unaffected</p>",
        "id": 300577656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664048942
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130575\">Siddharth Bhat</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/.5BCompiler.5D.20meeting.20notes/near/300562161\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112857\">Leonardo de Moura</span> I was thinking of a general class of performance bug, where rewrite rules break across compiler versions, and across syntactic changes of code. causing performance problems: </p>\n<ul>\n<li><a href=\"https://gitlab.haskell.org/ghc/ghc/-/issues/19557\">https://gitlab.haskell.org/ghc/ghc/-/issues/19557</a></li>\n<li>How do we test fusion <a href=\"https://github.com/haskell/vector/issues/229\">issue at <code>haskell/vector</code></a>. </li>\n<li>Haskell's <code>Data.Text</code> <a href=\"https://github.com/haskell/text/pull/348\">moved away from using rewrite rules entirely</a>.</li>\n</ul>\n</blockquote>\n<p>Thanks for posting the links. The Haskell thread is huge. Could you please summarize the issue? How could it happen in Lean? Here are some issues we aware of:</p>\n<ul>\n<li>The optimization rules may form a non-confluent rewriting system. </li>\n<li>Local vs global optimum. That is some transformations improve the code locally, but may make things worse overall (e.g., destroying sharing).</li>\n</ul>\n<p>Is is the Haskell issue an instance of one of these? I skimmed through the thread and they mention <code>Text</code> a lot.</p>",
        "id": 300578394,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1664049485
    },
    {
        "content": "<p>The <code>Data.Text</code> issue is about something a bit more concrete: the composition of two O(1) rules got rewritten into an O(n) stream/unstream thing. The problem here seems to be more that \"stream fusion\" in haskell refers to a specific pattern where things are rewritten into stream operations and combined with the hope that the overheads will be removed when all is said and done</p>",
        "id": 300579024,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664049964
    },
    {
        "content": "<p>Needless to say, I don't think it would be a good idea for lean to rewrite all operations into \"transform to list -&gt; apply operation -&gt; transform back\"</p>",
        "id": 300579095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664050052
    },
    {
        "content": "<p>this is a library design question though, it's not an indictment of rewrite rules altogether AFAICT</p>",
        "id": 300579170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1664050100
    },
    {
        "content": "<p>-fsplit-stack will cause a lot of issues, esp with calling into native C/C++ code.  <br>\nActually, originally Rust also used this approach but abandoned it because it was too complicated and causing performance problems.</p>",
        "id": 300589792,
        "sender_full_name": "Tom",
        "timestamp": 1664059344
    },
    {
        "content": "<p>Found a reference; interestingly the claim is that Go also abandoned segmented stacks but I can’t confirm that: </p>\n<p><a href=\"https://news.ycombinator.com/item?id=6679918\">https://news.ycombinator.com/item?id=6679918</a></p>",
        "id": 300590076,
        "sender_full_name": "Tom",
        "timestamp": 1664059600
    },
    {
        "content": "<p>Constant Folder: <a href=\"https://github.com/leanprover/lean4/pull/1652\">https://github.com/leanprover/lean4/pull/1652</a></p>\n<p>CC <span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span></p>",
        "id": 300912777,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1664233191
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> I got a response from Ocaml:</p>\n<p>Hello Henrik, thanks for your email about your interest in using inlining heuristics similar to Flambda in Lean 4.  I'm replying from my work account and have copied in two colleagues, Pierre Chambart and Leo White, who were really the original designers of the actual heuristics themselves (Pierre for the version of Flambda that is released in upstream OCaml and Leo for the forthcoming Flambda 2 version, which is developed here: <a href=\"https://github.com/ocaml-flambda/flambda-backend\">https://github.com/ocaml-flambda/flambda-backend</a>)</p>\n<p>I'm not sure there exists any documentation as to the actual heuristics except for the code.  We tried to simplify the heuristics for Flambda 2 and it's pretty straightforward to see the implementation of those here:</p>\n<p><a href=\"https://github.com/ocaml-flambda/flambda-backend/blob/main/middle_end/flambda2/simplify/inlining/call_site_inlining_decision.ml\">https://github.com/ocaml-flambda/flambda-backend/blob/main/middle_end/flambda2/simplify/inlining/call_site_inlining_decision.ml</a><br>\n<a href=\"https://github.com/ocaml-flambda/flambda-backend/blob/main/middle_end/flambda2/simplify/inlining/function_decl_inlining_decision.ml\">https://github.com/ocaml-flambda/flambda-backend/blob/main/middle_end/flambda2/simplify/inlining/function_decl_inlining_decision.ml</a></p>\n<p>The decision code for Flambda 1 is here:</p>\n<p><a href=\"https://github.com/ocaml/ocaml/blob/trunk/middle_end/flambda/inlining_decision.ml\">https://github.com/ocaml/ocaml/blob/trunk/middle_end/flambda/inlining_decision.ml</a></p>\n<p>Please let us know if there are any specific questions...</p>\n<p>Best regards<br>\nMark</p>",
        "id": 301059287,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1664297106
    },
    {
        "content": "<p>Semi-related: I recompiled OCaml with flambda support (...one-line change thanks to Nix <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span>) for our RC paper evaluation, but found that it did not beat the standard optimizer at that point. Maybe I should try again when flambda 2 is released <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> ... would also be nice to test a version of <code>binarytrees</code> that uses Multicore OCaml instead of interprocess communication <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span> .</p>",
        "id": 301059982,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1664297331
    },
    {
        "content": "<p>MLIR + Lean paper by <span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span> &amp; <span class=\"user-mention\" data-user-id=\"122318\">@Tobias Grosser</span> : <a href=\"https://grosser.science/static/0b1eb3ff397733a16e3f3e0e2429cab5/bhat-2022-Lambda-the-Ultimate-SSA.pdf\">https://grosser.science/static/0b1eb3ff397733a16e3f3e0e2429cab5/bhat-2022-Lambda-the-Ultimate-SSA.pdf</a></p>",
        "id": 302909594,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1665166438
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span> and <span class=\"user-mention\" data-user-id=\"122318\">@Tobias Grosser</span> really interesting read! I think there might be a typo on page 171 in the Code Duplication example, the <code>// 0 2 _ -&gt; 40 </code> comment is on the wrong switch statement</p>",
        "id": 302945250,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1665182929
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 302975161,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1665213321
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Here's a proof of that theorem you mentioned:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">log2_le_self</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat.log2</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Nat.log2</span><span class=\"bp\">;</span> <span class=\"n\">split</span>\n  <span class=\"bp\">·</span> <span class=\"n\">next</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">log2_le_self</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Nat.lt_of_le_of_lt</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">Nat.div_lt_self</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_of_lt</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">))</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.zero_le</span>\n<span class=\"n\">decreasing_by</span> <span class=\"n\">exact</span> <span class=\"n\">Nat.log2_terminates</span> <span class=\"n\">_</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span>\n</code></pre></div>",
        "id": 311448886,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669057586
    },
    {
        "content": "<p>That's gonna be the first time i saw a decreasing_by on a theorem.</p>",
        "id": 311448951,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1669057614
    },
    {
        "content": "<p>it's often convenient to prove theorems about definitions by well founded recursion, also by well founded recursion with the same metric</p>",
        "id": 311449019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669057647
    },
    {
        "content": "<p>Because it more closely resembles the recursion that is actually going on I guess?</p>",
        "id": 311449077,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1669057679
    },
    {
        "content": "<p>yeah, the inductive hypothesis talks about the same term that appears in the definition body</p>",
        "id": 311449171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1669057711
    },
    {
        "content": "<p>That makes sense, thank you. I'll just steal this then if you allow :P</p>",
        "id": 311449509,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1669057862
    },
    {
        "content": "<p>This is the \"fast Lua interpreter\" blog post btw <a href=\"https://sillycross.github.io/2022/11/22/2022-11-22/\">https://sillycross.github.io/2022/11/22/2022-11-22/</a></p>",
        "id": 313135193,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1669835664
    },
    {
        "content": "<p>This reminds me of HolyJit: <a href=\"https://github.com/nbp/holyjit\">https://github.com/nbp/holyjit</a> and <a href=\"https://yoric.github.io/post/holyjit/\">https://yoric.github.io/post/holyjit/</a></p>",
        "id": 313185562,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1669855721
    },
    {
        "content": "<p><a href=\"https://v2.ocaml.org/manual/flambda.html\">https://v2.ocaml.org/manual/flambda.html</a> it seems flambda finally got some documentation on top of the code the OCaml folk sent us the other day, I'll try to get something going with the optimizations they are describing in the coming days.</p>",
        "id": 314792470,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1670542331
    },
    {
        "content": "<p>Also I won't be able to attend Wednesday's meeting because of a Christmas event. If <span class=\"user-mention\" data-user-id=\"221921\">@Marc Huisinga</span> ends up doing his presentation it would be cool if you could post the slides somewhere (If there are slides :P) or alternatively at least a little summary!</p>",
        "id": 315428241,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1670868511
    },
    {
        "content": "<p>As I am currently sick with a flu, I don't think I'll be able to present anything this wednesday either :(</p>",
        "id": 315433487,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1670870074
    },
    {
        "content": "<p>I won't be able to attend tomorrow, FWIW.</p>",
        "id": 315661123,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1670957401
    },
    {
        "content": "<p>So that's another one dropped? :D</p>",
        "id": 315661517,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1670957520
    },
    {
        "content": "<p>I am sitting on (what I believe to be) the meeting link and no one is here. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>  I am mistaken about the link, was the meeting cancelled, or was everyone (except me) just unable to make it?</p>",
        "id": 315881127,
        "sender_full_name": "Mac",
        "timestamp": 1671041149
    },
    {
        "content": "<p>Ah yeah, like Henrik I assumed it was basically cancelled</p>",
        "id": 315884442,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1671041423
    },
    {
        "content": "<p>Ah, okay.</p>",
        "id": 315884569,
        "sender_full_name": "Mac",
        "timestamp": 1671041469
    },
    {
        "content": "<p>Are there plans for the meeting next week yet? Will we drop it because of Christmas or w/e? I'm free.</p>",
        "id": 316099257,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1671125762
    },
    {
        "content": "<p>My time for lean-fun has been cut shorter, so slower progress on my part but I will be able to attend</p>",
        "id": 316250439,
        "sender_full_name": "Yuri de Wit",
        "timestamp": 1671192848
    },
    {
        "content": "<p>I'm free too</p>",
        "id": 316250995,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1671193045
    },
    {
        "content": "<p>Is there a meeting today? It seems the room is empty</p>",
        "id": 317009001,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1671559877
    },
    {
        "content": "<p>Meetings are on Wednesdays</p>",
        "id": 317209183,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1671643524
    },
    {
        "content": "<p>aka today</p>",
        "id": 317209210,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1671643530
    },
    {
        "content": "<p>Riiight? <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> <span class=\"user-mention\" data-user-id=\"130575\">@Siddharth Bhat</span></p>",
        "id": 317216610,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1671645666
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Let's restart the compiler meetings Wednesday next week <time datetime=\"2023-01-11T18:00:00Z\">2023-01-11T10:00:00-08:00</time></p>",
        "id": 319286531,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1672783045
    },
    {
        "content": "<p>Alright <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 319286832,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1672783169
    },
    {
        "content": "<p>I am sorry, but I am currently overwhelmed and have to interrupt the weekly compiler meetings.</p>",
        "id": 320585464,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1673407483
    },
    {
        "content": "<p>Do other people have something they want to talk about? Otherwise I think we can just drop the meeting for today.</p>",
        "id": 320613184,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1673420155
    },
    {
        "content": "<p>I would be curious to talk about the LLVM annotations, but happy to do that next week.</p>",
        "id": 320618721,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1673421655
    },
    {
        "content": "<p>I'd wanted to see what the upcoming plans are, but happy to wait till next week as well!</p>",
        "id": 320754463,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1673457333
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> we're at the meeting at <a href=\"https://meet.jit.si/moderated/d0b396c2c5c4b52a8c56808a0e0496708721485296975d95f40ebf1a17b58890\">https://meet.jit.si/moderated/d0b396c2c5c4b52a8c56808a0e0496708721485296975d95f40ebf1a17b58890</a></p>",
        "id": 320764329,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1673460350
    },
    {
        "content": "<p>Oh I'm sorry I got caught up with work today.</p>",
        "id": 320793373,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1673469741
    },
    {
        "content": "<p>There was nothing new on my side though</p>",
        "id": 320793409,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1673469753
    },
    {
        "content": "<p>No worries! I was interested to describe a possible way to implement inline LLVM, but we can do that on chat as well :)</p>",
        "id": 320794403,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1673470105
    }
]