[
    {
        "content": "<p>For some moderately cursed metaprogramming I'm trying to do, I need to decide equality on <code>Lean.Expr</code>s. I'm thus trying to derive the appropriate <code>DecidableEq</code> instance, but I get a rather weird error, specifically when trying to derive <code>DecidableEq</code> for <code>Lean.Syntax</code>:<br>\n\"default handlers have not been implemented yet, class: 'DecidableEq' types: [Lean.Syntax]\"</p>\n<p>Now, normally I interpret this error as meaning there is no handler to derive instances of <code>DecidableEq</code>, but that's obviously not true. What does this error mean if it only gets triggered for a specific type?</p>\n<p>Here's the MWE. All derives work, except for <code>Syntax</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Name</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">FVarId</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Literal</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">MVarId</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">LevelMVarId</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Level</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">BinderInfo</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Substring</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">SourceInfo</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Syntax</span><span class=\"bp\">.</span><span class=\"n\">Preresolved</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">default handlers have not been implemented yet, class: 'DecidableEq' types: [Lean.Syntax]</span>\n<span class=\"cm\">-/</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Syntax</span>\n\n\n<span class=\"c1\">-- If we assume some instance exists, the rest works fine</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">DataValue</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">KVMap</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Expr</span>\n</code></pre></div>",
        "id": 511649019,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1744377267
    },
    {
        "content": "<p>Aha, to answer my own question: <code>deriving DecidableEq</code> doesn't seem to support nested inductive types. The following also fails</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Foo</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Foo</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n</code></pre></div>",
        "id": 511649926,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1744377513
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> has marked this topic as resolved.</p>",
        "id": 511650004,
        "sender_full_name": "Notification Bot",
        "timestamp": 1744377538
    },
    {
        "content": "<p>Note that the derived <code>DecidableEq</code> is going to be notably slower than the <code>BEq</code> instance on <code>Expr</code> as pointer equality and other optimizations won't be considered: <a href=\"https://github.com/leanprover/lean4/blob/c672934f116e301d3ef3c019531a16012ef58d3c/src/kernel/expr_eq_fn.cpp#L145\">https://github.com/leanprover/lean4/blob/c672934f116e301d3ef3c019531a16012ef58d3c/src/kernel/expr_eq_fn.cpp#L145</a>. So I would suggest to generally avoid this in favor of <code>BEq</code> if possible or write out a proper <code>DecidableEq</code> instance that at least uses pointer equality as a fast path.  For example as done in bv_decide: <a href=\"https://github.com/leanprover/lean4/blob/fafd381c90598fe9969f3cb8f1df9b3d1b87a219/src/Std/Tactic/BVDecide/Bitblast/BVExpr/Basic.lean#L247-L355\">https://github.com/leanprover/lean4/blob/fafd381c90598fe9969f3cb8f1df9b3d1b87a219/src/Std/Tactic/BVDecide/Bitblast/BVExpr/Basic.lean#L247-L355</a></p>",
        "id": 511662512,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1744380825
    },
    {
        "content": "<p>Thanks for the bv_decide pointer! In my case I expect the expressions to be very simple (basically either a Nat literal, an fvar or an mvar) so am not too worried about the performance. In fact, I sidestepped the whole issue by using a custom inductive with those three cases instead of Expr.</p>",
        "id": 512371655,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1744736335
    }
]