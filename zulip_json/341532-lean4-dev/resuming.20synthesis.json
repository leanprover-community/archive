[
    {
        "content": "<p>Johan and I looked into one instance-related performance issue a while back, where specifying an \"obvious\" type explicitly was the difference between succeeding instantly and a timeout.</p>\n<p>Say that trying to apply a lemma causes the creation of two new metavariables <code>?t : Type</code> and <code>?i : Ring ?t</code>. In the example we were looking at Lean decided to try to synthesize <code>?i</code> first, which wouldn't have occured to a human as the thing to do, but needn't have been fatal. As soon as it tried to use any specific <code>Ring</code> instance it determined it needed more information about <code>?t</code>.</p>\n<p>At this point it switched to unification, quickly learning that <code>?t</code> had to be in this case <code>Real</code>. But then it kept doing unification, which turned out to be a really bad idea for various reasons, related in part to eta for structures and the issues related to <a href=\"https://github.com/leanprover/lean4/pull/2003\">lean4#2003</a>, meaning that by the time we give up and synthesize the instance instead, we've created a hugely expanded set of unification problems.</p>\n<p>If, instead, we provided the type <code>?t := Real</code> explicitly, then instance synthesis was fast and the defeq test was also fast (it involved just a couple layers of unfolding).</p>\n<p>Has there been consideration of a mechanism whereby, if instance synthesis blocks because we don't yet have enough information about a metavariable, we eagerly resume it when that metavariable gets assigned?</p>",
        "id": 324544817,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675065804
    },
    {
        "content": "<p>This seems not only likely better for performance but also truer to the original intent (we wanted to determine <code>?i</code> by instance synthesis in the first place).</p>",
        "id": 324545012,
        "sender_full_name": "Reid Barton",
        "timestamp": 1675065876
    }
]