[
    {
        "content": "<p>Currently the proof mode context is defined as a branching tree</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Hyps</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">BI</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">emp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">emp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hyps</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sep</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"n\">elhs</span><span class=\"w\"> </span><span class=\"n\">erhs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">iprop</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">elhs</span><span class=\"w\"> </span><span class=\"bp\">∗</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">erhs</span><span class=\"o\">))</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hyps</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"n\">elhs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hyps</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"n\">erhs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hyps</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hyp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"n\">uniq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">prop</span><span class=\"o\">))</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">iprop</span><span class=\"o\">(</span><span class=\"bp\">□?$</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hyps</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"n\">e</span>\n</code></pre></div>\n<p>In contrast, the proof mode in Rocq is defined as a list.<br>\nWhat is the reason that iris-lean uses a tree instead of a list? Why is the branching useful?<br>\nI found <a href=\"https://github.com/leanprover-community/iris-lean/commit/4d812ef740b7559f9a83be590af70dc2a65ee501\">https://github.com/leanprover-community/iris-lean/commit/4d812ef740b7559f9a83be590af70dc2a65ee501</a> , which says</p>\n<blockquote>\n<p>The tree is not assumed to have any particular structure, but it will<br>\ntypically be a left-leaning list.</p>\n</blockquote>\n<p>Concretely, would it be possible to change the definition of Hyps to something like the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Hyps</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">BI</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">emp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">emp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hyps</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hyp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"n\">erhs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"n\">uniq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">prop</span><span class=\"o\">))</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hyps</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"n\">erhs</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">iprop</span><span class=\"o\">(</span><span class=\"bp\">□?$</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">∗</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">erhs</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hyps</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"n\">e</span>\n</code></pre></div>\n<p>I am asking because using a tree instead of a list makes writing tactics quite a bit more complex. For example, consider the implementation of <code>iassumption</code>. There the implementation of the <code>.sep</code> case is quite complex.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">BI</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">assumptionSlow</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">assume</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">Hyps</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AssumptionSlow</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">emp</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">Pure</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">affine</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">emp_affine</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">hyp</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">fromAssum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">:</span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">synthInstanceQ</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">FromAssumption</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">Q</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">try?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">synthInstanceQ</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Affine</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">out</span><span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">FromAssumption</span><span class=\"bp\">.</span><span class=\"n\">from_assumption</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">inst</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">affine</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">:</span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">affine</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">synthInstanceQ</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Affine</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">out</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">assume</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">fromAssum</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"n\">catch</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">affine</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"n\">catch</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">affine</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"n\">catch</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">fromAssum</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"n\">catch</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">sep</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">elhs</span><span class=\"w\"> </span><span class=\"n\">erhs</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">assumptionSlow</span><span class=\"w\"> </span><span class=\"k\">assume</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">affine</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">assumptionSlow</span><span class=\"w\"> </span><span class=\"k\">assume</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">affine</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">affine</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">sep_affine</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"n\">lpf</span><span class=\"w\"> </span><span class=\"n\">linst</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">assumption_l</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">lpf</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">linst</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">sep_affine</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">elhs</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">erhs</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"n\">rpf</span><span class=\"w\"> </span><span class=\"n\">rinst</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">assumptionSlow</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rinst</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">affine</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rinst</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">rinst</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">assumption_r</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">rpf</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">rinst</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">sep_affine</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">elhs</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">erhs</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"n\">lpf</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">assumption_l</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">lpf</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">none</span>\n</code></pre></div>\n<p>The Rocq implementation of the same tactic is a lot simpler:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Lemma</span><span class=\"w\"> </span><span class=\"n\">tac_assumption</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">envs_lookup</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">  </span><span class=\"n\">FromAssumption</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">Δ'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">envs_delete</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"w\">   </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">env_spatial_is_nil</span><span class=\"w\"> </span><span class=\"n\">Δ'</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">TCTrue</span>\n<span class=\"w\">   </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">TCOr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Absorbing</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AffineEnv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">env_spatial</span><span class=\"w\"> </span><span class=\"n\">Δ'</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">  </span><span class=\"n\">envs_entails</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"bp\">.</span>\n</code></pre></div>",
        "id": 527111443,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1751608307
    },
    {
        "content": "<p><del>I don't know enough to say which way is better, but the \"why\" is explained in Lars's thesis <a href=\"/user_uploads/3121/b3nC2KGmyxtyIHlmb-quRDVh/Screenshot_20250704-061407.png\">Screenshot_20250704-061407.png</a></del></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/b3nC2KGmyxtyIHlmb-quRDVh/Screenshot_20250704-061407.png\" title=\"Screenshot_20250704-061407.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"864x854\" src=\"/user_uploads/thumbnail/3121/b3nC2KGmyxtyIHlmb-quRDVh/Screenshot_20250704-061407.png/840x560.webp\"></a></div>",
        "id": 527150668,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1751624293
    },
    {
        "content": "<p>How does the Rocq proofmode separate the spatial and intuitionistic contexts?</p>",
        "id": 527150972,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1751624435
    },
    {
        "content": "<p>It's essentially just a pair of lists, one being the spatial environment and the other being the intuitionistic environment (where environment ~= context)</p>",
        "id": 527154142,
        "sender_full_name": "Remy Seassau",
        "timestamp": 1751625622
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574718\">Michael Sammler</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Why.20are.20Hyps.20a.20tree.20instead.20of.20a.20list.3F/near/527111443\">said</a>:</p>\n<blockquote>\n<p>The Rocq implementation of the same tactic is a lot simpler:</p>\n</blockquote>\n<p>FYI we also have <a href=\"https://github.com/leanprover-community/iris-lean/blob/56cf8c26c78455eb45b4155254273c2a9d842122/src/Iris/ProofMode/Expr.lean#L124C5-L124C22\">Hyps.findWithInfo</a> (kind of like <code>envs_lookup</code>) and <a href=\"https://github.com/leanprover-community/iris-lean/blob/56cf8c26c78455eb45b4155254273c2a9d842122/src/Iris/ProofMode/Tactics/Remove.lean#L79\">Hyps.remove</a> (kind of like <code>envs_delete</code>). I think <code>iassumption</code> might be inlining and optimizing these?</p>",
        "id": 527154344,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1751625714
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933925\">Remy Seassau</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Why.20are.20Hyps.20a.20tree.20instead.20of.20a.20list.3F/near/527154142\">said</a>:</p>\n<blockquote>\n<p>It's essentially just a pair of lists, one being the spatial environment and the other being the intuitionistic environment (where environment ~= context)</p>\n</blockquote>\n<p>Ah right, I think I was asking about the wrong thing actually since iris-lean uses two <code>Env</code>s too</p>",
        "id": 527155196,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1751626004
    },
    {
        "content": "<p>Lars' thesis brings up this example: <br>\n<a href=\"/user_uploads/3121/8Jj1DBIF9sYMUGVoP4hOO_w9/Screenshot-2025-07-04-at-6.48.17AM.png\">Screenshot 2025-07-04 at 6.48.17 AM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/8Jj1DBIF9sYMUGVoP4hOO_w9/Screenshot-2025-07-04-at-6.48.17AM.png\" title=\"Screenshot 2025-07-04 at 6.48.17 AM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1738x386\" src=\"/user_uploads/thumbnail/3121/8Jj1DBIF9sYMUGVoP4hOO_w9/Screenshot-2025-07-04-at-6.48.17AM.png/840x560.webp\"></a></div><p>How is this represented in a Rocq iris list?</p>",
        "id": 527155591,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1751626130
    },
    {
        "content": "<p>My understanding is that you only have multiplicative combination between elements of the list. <br>\nSo Q₁ ∧ Q₂ would have to be one single element: [ P ; Q₁ ∧ Q₂ ]</p>",
        "id": 527156865,
        "sender_full_name": "Remy Seassau",
        "timestamp": 1751626609
    },
    {
        "content": "<p>My understanding is that it used to be two lists in the original iris-lean implementation by Lars, but then <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> changed it to use this tree version in <a href=\"https://github.com/leanprover-community/iris-lean/commit/4d812ef740b7559f9a83be590af70dc2a65ee501\">this commit</a>. The commit message describes some justification for the change, which makes sense, but I do not understand why iris-lean does not use a more list-like version instead of the tree-structure.</p>",
        "id": 527158951,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1751627450
    },
    {
        "content": "<p>Oh brother, you're right. Sorry for the misunderstanding!</p>",
        "id": 527159912,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1751627820
    },
    {
        "content": "<p>it was a performance optimization. It means that you don't have to do as much administrative pushing of variables around. This is actually a performance issue when you have a long context</p>",
        "id": 527160243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751627957
    },
    {
        "content": "<p>I understand that there was a performance optimization in the commit from switching from reduction in the proof to traversing the term at the meta level and not storing the identifiers in the proof term. But I do not see why it is necessary to use a tree with arbitrary branching instead of a left-leaning tree where one side is always a hypothesis for this.</p>\n<p>Concretely, would using the following definition for <code>Hyps</code> also work? (This is just a specialized version of the current <code>Hyps</code> where the <code>.sep</code> and <code>.hyp</code> constructors are merged.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Hyps</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">BI</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">emp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">emp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hyps</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hyp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"n\">erhs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"n\">uniq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">prop</span><span class=\"o\">))</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hyps</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"n\">erhs</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">iprop</span><span class=\"o\">(</span><span class=\"bp\">□?$</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">∗</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">erhs</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hyps</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"n\">e</span>\n</code></pre></div>",
        "id": 527166778,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1751630348
    },
    {
        "content": "<p>I'm saying there is a performance advantage from not needing to renormalize the shape of the tree to be left leaning, in the underlying expression</p>",
        "id": 527239202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751672237
    },
    {
        "content": "<p>oh and your list is forcing the expression to be right leaning, which is actually much worse because most action happens at the end of the list so enforcing the wrong lean will add O(n) shuffles on every operation</p>",
        "id": 527240687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751673767
    },
    {
        "content": "<p>Thank you for this answer, though I have to admit I still don't fully understand the situation.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Why.20are.20Hyps.20a.20tree.20instead.20of.20a.20list.3F/near/527239202\">said</a>:</p>\n<blockquote>\n<p>I'm saying there is a performance advantage from not needing to renormalize the shape of the tree to be left leaning, in the underlying expression</p>\n</blockquote>\n<p>Is there actually any case where the tree is not full left-leaning? I do not know which Iris tactic would create such a tree. Note that you still need to convert a separation logic expression to a Hyps to add it to the context, which means traversing it, so you don't actually add a full tree at once.</p>\n<p>To test this, I modified  <code>parseIrisGoal?</code> to check whether the <code>Hyps</code> are left-leaning as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Hyps</span><span class=\"bp\">.</span><span class=\"n\">isLeaning?</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Hyps</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">emp</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">hyp</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">sep</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">sep</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"bp\">.</span><span class=\"n\">isLeaning?</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">parseIrisGoal?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">IrisGoal</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">prop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">appM?</span><span class=\"w\"> </span><span class=\"ss\">``Entails'</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">getAppFn</span><span class=\"bp\">.</span><span class=\"n\">constLevels!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hyps</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">parseHyps?</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"n\">P</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"n\">hyps</span><span class=\"bp\">.</span><span class=\"n\">isLeaning?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hyps</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>With this change, everything still builds. So it seems like at least all tactics that currently exist only create left-leaning <code>Hyps</code>.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Why.20are.20Hyps.20a.20tree.20instead.20of.20a.20list.3F/near/527240687\">said</a>:</p>\n<blockquote>\n<p>oh and your list is forcing the expression to be right leaning, which is actually much worse because most action happens at the end of the list so enforcing the wrong lean will add O(n) shuffles on every operation</p>\n</blockquote>\n<p>Are you saying that with this definition of <code>Hyps</code> the top most <code>.hyp</code> in <code>Hyps</code> would be the displayed at the top of the goal? In that case one indeed wants to make it left-leaning instead of right-leaning such that tactics first look at the hypothesis at the bottom not at the one at the top. (But that is an easy change.)</p>",
        "id": 527405011,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1751868102
    },
    {
        "content": "<p>the hypotheses are ordered: the ones on the left appear on top of the hypothesis goal view. So you would want the list to be left leaning.</p>",
        "id": 527460438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751888689
    },
    {
        "content": "<p>As for whether there are any tactics that don't produce a left-leaning list, no I never got around to that. These observations actually stem from some work I did in a different system that had analogous concerns. I think there might be advantages to spontaneously introducing a tree structure to keep it balanced, but beyond that if you do operations that pull items out of the middle that can be a good reason to introduce a branch there. It's easier to implement the version of the tactic that doesn't do this, but you can get quadratic overhead in bad cases.</p>\n<p>When it comes to traversing the list it doesn't really matter whether it's a tree or not, they are both linear. But the proof term will end up proportional to the depth of the target item if you are pulling one out.</p>",
        "id": 527461301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751889003
    },
    {
        "content": "<p>Lean itself is using a considerably more sophisticated data structure for the actual local context (a persistent hash map), so I feel the least we can do is try to make the linear context also a bit more treeish.</p>",
        "id": 527461901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751889232
    },
    {
        "content": "<p>I see, thanks for the explanation. I would be interested to hear if there is any tactic in the Iris proof mode that would actually generate a tree. (See <a href=\"https://gitlab.mpi-sws.org/iris/iris/-/blob/master/docs/proof_mode.md?ref_type=heads\">here</a> for the list of tactics.)</p>\n<p>The idea of replacing Hyps with something more efficient like a hashmap also sounds intriguing. For this, I guess it would be good if <code>Hyps</code> has a clearly defined interface. At the moment, tactics like <code>assumption</code> are a bit of a mess (as shown in the initial message of this thread), but with a proper interface for <code>Hyps</code> this could be a lot nicer (and then one could also more easily change out the definition of <code>Hyps</code>).</p>",
        "id": 527527830,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1751910396
    },
    {
        "content": "<p>Because the term has to be part of the expression, you don't have the shortcut of being able to use different <code>.fvar</code> names to refer to hypotheses directly, and as a result the programming model is closer to a pure functional setting, where balanced trees represent the best case scenario. If you assume searches not in the kernel are cheap, then it doesn't even need to be a sorted tree, you just reach in and grab the element you want because you know where it is. The limiting cost becomes the number of tree rotations you have to do to move an element to the root and that's basically linear in the max depth.</p>\n<p>So you would think the optimal would be a balanced binary tree, but it's not actually because it's O(log n) to add elements to a perfect binary tree (or worse depending on how much perfection you ask for), while you can get O(1) with a left leaning path. It turns out you can actually get the best of both worlds, with O(1) amortized append and O(log n) depth, by using a left leaning tree where the k'th node on the spine from the root has a complete binary tree of size 2^k hanging off it. (Alternatively, you can think of this as what you get if you take a complete binary tree and rotate the root all the way right until you have what used to be the rightmost leaf at the root.)</p>",
        "id": 527529567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751910999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574718\">Michael Sammler</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Why.20are.20Hyps.20a.20tree.20instead.20of.20a.20list.3F/near/527527830\">said</a>:</p>\n<blockquote>\n<p>The idea of replacing Hyps with something more efficient like a hashmap also sounds intriguing</p>\n</blockquote>\n<p>Just to register it in text, my advisor (Joe Tassarotti) also mentioned this as something that iris-lean may be able to meaningfully improve over Iris-Rocq. The speed of the proofmode has apparently caused issues for some of his projects in the past.</p>",
        "id": 527559917,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1751921275
    }
]