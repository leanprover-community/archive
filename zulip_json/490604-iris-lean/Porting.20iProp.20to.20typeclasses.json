[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  I'm getting kind of stuck on some Lean details for porting <code>iProp</code> and I'm wondering if you might have any ideas on how to proceed. </p>\n<p>Basically, <code>iProp</code> in Rocq does equational reasoning about a global list of RFunctors, using a typeclass to specify that the <code>i</code>th entry in the list gives a specific <code>CMRA</code> when applied to the fixpoint <code>iProp</code>. This is straightforward to specify in Rocq since they are using bundled structures. Remy tried porting it the same way (bundling RFunctor instances in the list of GFunctors), but this leads to a bunch of CMRA transports I was not sure how to deal with. </p>\n<p>The central issue is that if we need to be able to relate lemmas about a particular <code>CMRA</code>, say <code>ConstOF Unit (IProp FF) (IProp FF)</code>, to the <code>iProp</code> constructions where the typeclass instances come from an <code>IsGFunctors</code> instance. I tried another approach <a href=\"https://github.com/leanprover-community/iris-lean/blob/f2d696b60616f87a1fb59bc2b4966075cc4d49bc/src/Iris/Instances/IProp/Instance.lean#L42\">here</a> where I used a typeclass to specify what the <code>i</code>th entry in the list of <code>OFunctorPre</code>'s is, though this also leads to CMRA's not being defeq that I would expect to be so. </p>\n<p>Do you have any ideas about the right way to mechanize this? I can't think of a good way which allows us to describe the global list of OFunctors using equations.</p>",
        "id": 541900593,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759073535
    },
    {
        "content": "<p>I've been wanting to refactor the RFunctors thing to avoid needing an explicit finite list of functors and instead do something more abstract like a type (which will ultimately be instantiated as a finite product of CMRAs) from which individual CMRAs can be projected, with each projection being its own typeclass (or maybe one typeclass parameterized by the CMRA to project out). This should eliminate the equational reasoning</p>",
        "id": 542976134,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759506782
    },
    {
        "content": "<p>I'm looking at the file now and I am not sure how much of this is your work vs what is in iris</p>",
        "id": 542978420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759507469
    },
    {
        "content": "<p>I assume you want to fix the sorries in that file?</p>",
        "id": 542978556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759507511
    },
    {
        "content": "<p>My file is mostly my work. Remy's fork is closer to Iris (bundled structures, etc)</p>",
        "id": 542978607,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759507526
    },
    {
        "content": "<p>The sorry's are one thing but I think the problem I'm describing is exemplified by the example on line 55 (the rfl fails)</p>",
        "id": 542978759,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759507576
    },
    {
        "content": "<p>I'm not sure I understand how your idea allows us to have impredicative resources, the construction is not abstract specifically for that purpose?</p>",
        "id": 542979400,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759507777
    },
    {
        "content": "<p>I might be missing a design constraint, can you explain more about that?</p>",
        "id": 542979519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759507814
    },
    {
        "content": "<p>Like, the Iris construction uses RFunctors for <code>UPred</code> and <code>gmap</code> so that the fixpoint is a <code>UPred</code> resource, whose UCMRA is a map, and where each projection of this map is a particular <code>RFunctor</code> applied to the fixpoint. Solving the fixpoint and is integrated with how the map of resources are represented.</p>",
        "id": 542980169,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759508026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"721721\">Markus de Medeiros</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Porting.20iProp.20to.20typeclasses/near/542978759\">said</a>:</p>\n<blockquote>\n<p>The sorry's are one thing but I think the problem I'm describing is exemplified by the example on line 55 (the rfl fails)</p>\n</blockquote>\n<p>I thought a bit about this, and I think it's expected behavior. <code>GFunctors</code> is essentially a map keyed by type, which means when you have a type which is not unique or in this case overlaps a general purpose type then you get overlapping instances. These aren't even equal, not just not defeq</p>",
        "id": 542980429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759508107
    },
    {
        "content": "<p>Agreed</p>",
        "id": 542980481,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759508126
    },
    {
        "content": "<p>The solution is to ensure that any functor you use in a <code>GFunctors</code> is specifically intended for use in one</p>",
        "id": 542980522,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759508138
    },
    {
        "content": "<p>i.e. don't put <code>ConstOF Unit</code> in a GFunctors directly, put <code>MyFunctor (ConstOF Unit)</code> instead</p>",
        "id": 542980652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759508178
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"721721\">Markus de Medeiros</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Porting.20iProp.20to.20typeclasses/near/542980169\">said</a>:</p>\n<blockquote>\n<p>Like, the Iris construction uses RFunctors for <code>UPred</code> and <code>gmap</code> so that the fixpoint is a <code>UPred</code> resource, whose UCMRA is a map, and where each projection of this map is a particular <code>RFunctor</code> applied to the fixpoint. Solving the fixpoint and is integrated with how the map of resources are represented.</p>\n</blockquote>\n<p>This is fine I think, the ultimate implementation can still be a finite list of functors as before. You just abstract that in the API so that this is only visible in the construction and at the end when you \"tie the knot\" to prove that there exists some GFunctors which contains four specific functors corresponding to various modalities you wanted to use in your heaplang etc</p>",
        "id": 542981221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759508343
    },
    {
        "content": "<p>and we can provide a macro to do the latter part</p>",
        "id": 542981272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759508358
    },
    {
        "content": "<p>For the in between stuff we just have a typeclass saying that you can somehow extract a <code>MyFunctor</code> from <code>FF</code> which is used in the <code>myModality</code> theory file</p>",
        "id": 542981624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759508447
    },
    {
        "content": "<p>What is <code>MyFunctor</code> supposed to mean?</p>",
        "id": 542981694,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759508473
    },
    {
        "content": "<p>That's ultimately <code>FF 2 : MyFunctor</code> extracted from <code>FF : GFunctors</code></p>",
        "id": 542981844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759508520
    },
    {
        "content": "<p>but we hide all the details about the fact that we are applying a function or what index it is</p>",
        "id": 542981962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759508559
    },
    {
        "content": "<p>I believe <code>MyFunctor</code> is the <code>F</code> in <code>ElemG FF τ F</code>  in your code</p>",
        "id": 542982126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759508610
    },
    {
        "content": "<p>instantiated in the particular case for some specific F</p>",
        "id": 542982233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759508641
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Porting.20iProp.20to.20typeclasses/near/542980652\">said</a>:</p>\n<blockquote>\n<p>i.e. don't put <code>ConstOF Unit</code> in a GFunctors directly, put <code>MyFunctor (ConstOF Unit)</code> instead</p>\n</blockquote>\n<p>I'm not sure how to reconcile that with this</p>",
        "id": 542982569,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759508759
    },
    {
        "content": "<p>Let's say you want to have a GFunctors containing functors MyF1, MyF2, MyF3 which each give you some kind of capability. There will be a file talking about MyF1 and the operations associated with having one; this will have a typeclass assumption <code>[ElemG FF MyF1]</code> (I don't think it is necessary to expose the <code>τ</code> parameter in the typeclass). Most of the work will therefore have assumptions <code>[ElemG FF MyF1] [ElemG FF MyF2] [ElemG FF MyF3]</code>, and then there is a macro which constructs some <code>MyFF</code> definition with instances <code>ElemG MyFF MyF1, ElemG MyFF MyF2, ElemG MyFF MyF3</code></p>",
        "id": 542983249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759508976
    },
    {
        "content": "<p>you would never write <code>[ElemG FF (ConstOF Unit)]</code> because this would cause a diamond problem with the pre-existing <code>ConstOF Unit</code> instance</p>",
        "id": 542983536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759509061
    },
    {
        "content": "<p>How do we specify that we have access to <code>ConstOF Unit</code> resources in this system?</p>",
        "id": 542984425,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759509367
    },
    {
        "content": "<p>maybe I misunderstood, but I think the Inst1 instance says that <code>ConstOF Unit</code> resources exist in every system?</p>",
        "id": 542984542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759509410
    },
    {
        "content": "<p>aha, I did misunderstand</p>",
        "id": 542984654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759509459
    },
    {
        "content": "<p><code>instCMRAElemG</code> is a bad instance, you should always have an alternative route to prove that</p>",
        "id": 542984701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759509478
    },
    {
        "content": "<p>I agree that it is a problematic instance I just don't really see a way around it...</p>",
        "id": 542985034,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759509601
    },
    {
        "content": "<p>Why are <code>GFunctors</code> and <code>IsGFunctors</code> separate?</p>",
        "id": 542985064,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759509610
    },
    {
        "content": "<p>the name is not great</p>",
        "id": 542985092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759509618
    },
    {
        "content": "<p>because it's not obvious what it means to assert that a <code>GFunctors</code> <code>IsGFunctors</code>, it sounds like it should always be the case</p>",
        "id": 542985170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759509647
    },
    {
        "content": "<p>Definitely agreed</p>",
        "id": 542985193,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759509657
    },
    {
        "content": "<p>moreover it seems <code>IsGFunctors</code> is additional dependent data</p>",
        "id": 542985344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759509697
    },
    {
        "content": "<p>Right. So should we use bundled structures for this then?</p>",
        "id": 542985482,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759509733
    },
    {
        "content": "<p>I guess it's the actual instance and stuff, more than just the type</p>",
        "id": 542985496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759509736
    },
    {
        "content": "<p>yeah, I think it would make sense to bundle <code>GFunctors</code></p>",
        "id": 542985592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759509766
    },
    {
        "content": "<p>we don't want to use its projections directly as discussed anyway</p>",
        "id": 542985647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759509784
    },
    {
        "content": "<p>we instead want to use separate variables which already have instances of their own (like <code>F := ConstOF Unit</code>), with a typeclass saying that they can be extracted from <code>FF</code></p>",
        "id": 542985842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759509855
    },
    {
        "content": "<p>which is where we hide the equality assumption</p>",
        "id": 542985874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759509867
    },
    {
        "content": "<p>OH I get it now, <code>ElemG</code> is taking a lawless GFunctors so it's actually wrong</p>",
        "id": 542986124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759509945
    },
    {
        "content": "<p>it should take both the GFunctors and IsGFunctors because it needs to assert that the cmra part is also equal to the pre-existing cmra on F</p>",
        "id": 542986209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759509974
    },
    {
        "content": "<p>(or alternatively bundle everything)</p>",
        "id": 542986244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759509985
    },
    {
        "content": "<p>Yeah, right. This is the tricky part though. I tried adding a CMRA equality constraint to the <code>ElemG</code> typeclass at one point and having to rewrite by equations for both the CMRA and the type on that CMRA was difficult. I also couldn't figure out how to relate lemmas about the base <code>CMRA</code> (for example, <code>validN unit</code>) to the versions specified by <code>ElemG</code>. </p>\n<p>I will revisit the bundling idea then.</p>",
        "id": 542987259,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759510281
    },
    {
        "content": "<p>bundling will definitely make it easier to write that equality</p>",
        "id": 542987315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759510305
    },
    {
        "content": "<p>OK. To give concrete code, Remy was working on that <a href=\"https://github.com/leanprover-community/iris-lean/pull/76\">here</a>.</p>",
        "id": 542987578,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759510390
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"721721\">Markus de Medeiros</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Porting.20iProp.20to.20typeclasses/near/542987259\">said</a>:</p>\n<blockquote>\n<p>I also couldn't figure out how to relate lemmas about the base <code>CMRA</code> (for example, <code>validN unit</code>) to the versions specified by <code>ElemG</code>.</p>\n</blockquote>\n<p>You shouldn't need to do this, you should only ever be using the CMRA structure coming from F and not the one you can obtain by transport out of <code>GF i</code></p>",
        "id": 542987588,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759510393
    },
    {
        "content": "<p>But the lemmas in the algebra library are (rightly) are written in terms of the regular CMRA's</p>",
        "id": 542987724,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759510434
    },
    {
        "content": "<p>exactly, that's why you use F which is a regular CMRA</p>",
        "id": 542987767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759510450
    },
    {
        "content": "<p>we might need a bit of automation to make it easy to declare newtype CMRAs</p>",
        "id": 542987911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759510491
    },
    {
        "content": "<p>if all of the GFunctor types are different (and I don't see why you would want to have the same type twice since the GMap already lets you make as many instances of a given type as you want) then it should be fine even to not use newtypes and just use the types you actually want</p>",
        "id": 542988190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759510578
    },
    {
        "content": "<p>I think I'm starting to get on the same page as you, though at some level the <code>own</code> primitive will need to be written in terms of the projected-out CMRA <code>GF i</code></p>",
        "id": 542988497,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759510684
    },
    {
        "content": "<p>if you have some relevant half written code I can try to be more concrete</p>",
        "id": 542988569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759510712
    },
    {
        "content": "<p>I don't like this argument <code>v : FF τ (IProp FF) (IProp FF)</code></p>",
        "id": 542988698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759510755
    },
    {
        "content": "<p>it's exposing <code>FF τ</code></p>",
        "id": 542988749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759510772
    },
    {
        "content": "<p>I think it should look like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">iOwn</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">GF</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OFunctor</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ElemG</span><span class=\"w\"> </span><span class=\"n\">GF</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GName</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">ap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IProp</span><span class=\"w\"> </span><span class=\"n\">GF</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IProp</span><span class=\"w\"> </span><span class=\"n\">GF</span>\n</code></pre></div>",
        "id": 542989239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759510922
    },
    {
        "content": "<p>I get it now (though here we would also need a <code>[IsGFunctors GF]</code> instance, or to be bundled, but I believe that either of those are possible).</p>",
        "id": 542989858,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759511125
    },
    {
        "content": "<p>using this definition of <code>ElemG</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BundledGFunctors</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">GType</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">COFE</span><span class=\"bp\">.</span><span class=\"n\">OFunctorPre</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">OFunctor</span><span class=\"w\"> </span><span class=\"n\">F</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">ElemG</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FF</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BundledGFunctors</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OFunctorPre</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OFunctor</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">τ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GType</span>\n<span class=\"w\">  </span><span class=\"n\">transp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FF</span><span class=\"w\"> </span><span class=\"n\">τ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">F</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‹_›⟩</span>\n</code></pre></div>",
        "id": 542989923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759511142
    },
    {
        "content": "<p>Yes. So then under the hood <code>iOwn</code> will be the singleton map where the <code>γ</code>th entry of the<code>τ</code>th entry of the ghost map is the transported version of <code>v</code>.</p>",
        "id": 542990481,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759511328
    },
    {
        "content": "<p>(you might need <code>F</code> explicit in <code>iOwn</code>, not sure if that will always be inferred correctly)</p>",
        "id": 542990491,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759511331
    },
    {
        "content": "<p>yeah, I'm not sure which side of the ElemG abstraction results in shorter code for <code>iSingleton</code></p>",
        "id": 542990814,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759511431
    },
    {
        "content": "<p>but I think the approach you are taking there basically makes sense</p>",
        "id": 542990886,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759511455
    },
    {
        "content": "<p>at some point you obviously do need to do something with that equality argument</p>",
        "id": 542991003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759511489
    },
    {
        "content": "<p>there is already a cast in <code>iSingleton</code> so maybe it would be better to have the cmra cast there too</p>",
        "id": 542991184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759511549
    },
    {
        "content": "<p>Yeah okay, this makes sense to me. Thanks for hashing it out!</p>",
        "id": 542991345,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759511602
    },
    {
        "content": "<p>One last thing, do you have any tricks for working with <code>cast</code>? It is difficult to work with, my best attempts have relied on using the <code>subst</code> tactic basically whenever I could though this is a little inelegant.</p>",
        "id": 542991665,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759511706
    },
    {
        "content": "<p>that's the universal technique for this</p>",
        "id": 542991736,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759511733
    },
    {
        "content": "<p>make sure one side of your equality is a variable, then subst it until the equality is refl and the casts will go away. This is how you prove anything about a cast</p>",
        "id": 542991814,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759511767
    },
    {
        "content": "<p>if you are very lucky you might have some other kind of compositional abstraction which can push casts around like <code>eqToHom</code>. I don't think we are lucky in this case</p>",
        "id": 542991919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1759511813
    },
    {
        "content": "<p>Understood, thanks!</p>",
        "id": 542992254,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1759511891
    },
    {
        "content": "<p>I still have quite a few sorry's to work through on my branch but now I think we are getting close to something that looks a lot like iProp :) </p>\n<p><a href=\"/user_uploads/3121/AtljiKD7RmVIjPZDaOaCf1D8/Screenshot-2025-10-10-at-3.54.40PM.png\">Screenshot 2025-10-10 at 3.54.40 PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/AtljiKD7RmVIjPZDaOaCf1D8/Screenshot-2025-10-10-at-3.54.40PM.png\" title=\"Screenshot 2025-10-10 at 3.54.40 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1200x980\" src=\"/user_uploads/thumbnail/3121/AtljiKD7RmVIjPZDaOaCf1D8/Screenshot-2025-10-10-at-3.54.40PM.png/840x560.webp\"></a></div>",
        "id": 544238517,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1760126222
    }
]