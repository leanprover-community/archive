[
    {
        "content": "<p>Anyone have any clue why <code>sForall</code> and <code>sExists</code> in <code>BIBase</code> are defined like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">sForall</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PROP</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PROP</span>\n<span class=\"w\">  </span><span class=\"n\">sExists</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PROP</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PROP</span>\n</code></pre></div>\n<p>instead of the way it's done in König's thesis as well as Rocq Iris? </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">sForall</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PROP</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PROP</span>\n<span class=\"w\">  </span><span class=\"n\">sExists</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PROP</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PROP</span>\n</code></pre></div>",
        "id": 509017971,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1743334965
    },
    {
        "content": "<p>The reason for this is because the type of <code>{A}</code> there is hidden and important</p>",
        "id": 509018782,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743335726
    },
    {
        "content": "<p>it's <code>{A : Type u}</code>, and it causes a universe bump in BIBase and also restricts the usage of forall to that particular type universe</p>",
        "id": 509018821,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743335761
    },
    {
        "content": "<p>this is actually a problem in iris as well, it's just more well hidden there because of the use of template universe polymorphism</p>",
        "id": 509018905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743335800
    },
    {
        "content": "<p>by using sets instead and defining indexed forall in terms of set forall, it's possible to get the best of both worlds: no universe bump and you can index over types in any universe, even larger than the BIBase itself</p>",
        "id": 509018962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743335848
    },
    {
        "content": "<p>We have analogous difficulties when defining complete lattices in mathlib</p>",
        "id": 509019140,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743335989
    },
    {
        "content": "<p>Okay, cool. Am I understanding correctly that the \"set\" in the \"set forall\" is analogous to image of the function in the \"Rocq forall\"?</p>",
        "id": 509019217,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1743336018
    },
    {
        "content": "<p>yes</p>",
        "id": 509019226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743336027
    },
    {
        "content": "<p>For posterity: Here is a concrete <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> demonstrating a universe problem present in the indexed representation that is not present in the set-based representation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Indexed</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Indexed quantifiers -/</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">BI</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PROP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">iQuantifier</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PROP</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PROP</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">BI</span><span class=\"w\">             </span><span class=\"c1\">-- Indexed.BI.{u_1, u_2} (PROP : Type u_1) : Type (max u_1 (u_2 + 1))</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">BI</span><span class=\"bp\">.</span><span class=\"n\">iQuantifier</span><span class=\"w\"> </span><span class=\"c1\">-- Indexed.BI.iQuantifier.{u_1, u_2} {PROP : Type u_1} [self : BI PROP] {A : Type u_2} : (A → PROP) → PROP</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PROP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BI</span><span class=\"w\"> </span><span class=\"n\">PROP</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PROP</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">BI</span><span class=\"bp\">.</span><span class=\"n\">iQuantifier</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">BI</span><span class=\"bp\">.</span><span class=\"n\">iQuantifier</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Breaks when the universes for X and Y disagree</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Indexed</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Set-based quantifiers -/</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">BI</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PROP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">sQuantifier</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PROP</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PROP</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BI</span><span class=\"bp\">.</span><span class=\"n\">iQuantifier</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">PROP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BI</span><span class=\"w\"> </span><span class=\"n\">PROP</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PROP</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PROP</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">BI</span><span class=\"bp\">.</span><span class=\"n\">sQuantifier</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">BI</span><span class=\"w\">              </span><span class=\"c1\">-- Set.BI.{u_1} (PROP : Type u_1) : Type u_1</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">BI</span><span class=\"bp\">.</span><span class=\"n\">sQuantifier</span><span class=\"w\">  </span><span class=\"c1\">-- Set.BI.sQuantifier.{u_1} {PROP : Type u_1} [self : BI PROP] : (PROP → Prop) → PROP</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">BI</span><span class=\"bp\">.</span><span class=\"n\">iQuantifier</span><span class=\"w\">  </span><span class=\"c1\">-- Set.BI.iQuantifier.{u_1, u_2} {PROP : Type u_1} [BI PROP] {ι : Type u_2} (I : ι → PROP) : PROP</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PROP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BI</span><span class=\"w\"> </span><span class=\"n\">PROP</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PROP</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">BI</span><span class=\"bp\">.</span><span class=\"n\">iQuantifier</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">BI</span><span class=\"bp\">.</span><span class=\"n\">iQuantifier</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Works no matter the universe levels for X, Y and PROP</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n</code></pre></div>",
        "id": 561215395,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1764607355
    },
    {
        "content": "<p>also FYI <a href=\"https://gitlab.mpi-sws.org/iris/iris/-/merge_requests/1111\">https://gitlab.mpi-sws.org/iris/iris/-/merge_requests/1111</a></p>",
        "id": 562262758,
        "sender_full_name": "Alex Bai",
        "timestamp": 1765051518
    },
    {
        "content": "<p>I am having some trouble trying to instantiate <code>BIBase</code> in a way I believe is because of iris-lean's sForall type <code>(PROP → Prop) → PROP</code>. I would like to keep the syntax and semantics of <code>PROP</code> (propositions in separation logic), separate. So an excerpt of my instantiation looks like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BIBase</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Assertion</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Entails</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\">    </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">Heap</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"bp\">.</span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">and</span><span class=\"w\">         </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Assertion</span><span class=\"bp\">.</span><span class=\"n\">and</span>\n</code></pre></div>\n<p>where <code>denote</code> is a inductively defined on <code>Assertion</code>, defining the satsifiability relation giving semantics to the syntax of Assertions in separation logic. To be clear I define <code>PROP := Assertion</code>. I run into problems defining Assertion though for the <code>sForall</code> and <code>sExists</code> because of positivity.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Assertion</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sForall</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ψ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Assertion</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Assertion</span>\n</code></pre></div>\n<p>I want to note that the distinction between the syntax and semantics in <code>Assertion</code> seems standard in separation logic papers. But the classical separation logic example just directly provides the semantics in the BIBase instantiation. I might be able to do this as well which would avoid definition of (syntax) <code>Assertion</code> and the positivity violation entirely. But I don't think this is ideal, the code becomes difficult to write correctly and read, and the split between syntax and semantics aids in understanding of complicated separation logics.</p>\n<p>And since <code>sForall</code> is more general than <code>iForall</code>, I'm unable to just define iForall in the syntax instead. I wanted to ask if there's some trivial workaround, whether you think this may be a disadvantage of sForall as <code>(PROP → Prop) → PROP</code>. Happy to provide more info on something in particular and I might just be making a silly mistake</p>",
        "id": 570904658,
        "sender_full_name": "Edwin Fernando",
        "timestamp": 1769724541
    },
    {
        "content": "<p>Indeed, the BI interface assumes that you have impredicative quantification in your logic, which prevents syntactic assertions as far as I can tell. The standard in Iris is to use semantic assertions as shown by the classical separation logic example. I would recommend that you try the semantic approach. It has worked very well for complicated separation logics as shown by Iris / iProp.</p>",
        "id": 570984426,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1769767034
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"933925\">@Remy Seassau</span> did some work in this direction, maybe he could chime in?</p>",
        "id": 571022253,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1769778162
    },
    {
        "content": "<p>Ah yes, we also ran into this issue</p>",
        "id": 571460715,
        "sender_full_name": "Remy Seassau",
        "timestamp": 1770045928
    },
    {
        "content": "<p>We ended up using a semantic definition of sForall to tie it to our syntactic definition of forall</p>",
        "id": 571461671,
        "sender_full_name": "Remy Seassau",
        "timestamp": 1770046140
    },
    {
        "content": "<p>Thank you very much for the answers, and sorry for the late response.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"574718\">Michael Sammler</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Why.20are.20sForall.20and.20sExists.20defined.20the.20way.20they.20are.3F/near/570984426\">said</a>:</p>\n<blockquote>\n<p>Indeed, the BI interface assumes that you have impredicative quantification in your logic, which prevents syntactic assertions as far as I can tell. The standard in Iris is to use semantic assertions as shown by the classical separation logic example. I would recommend that you try the semantic approach. It has worked very well for complicated separation logics as shown by Iris / iProp.</p>\n</blockquote>\n<p>Okay I didn't know the direct semantic way (henceforth I'll refer to as deep embedding) is standard and the syntax + semantics way (shallow embedding) is not generally possible. But I still want to try to figure it out to thoroughly understand the technical details. Also I want to note that I only want to use MoSeL, and not the whole of Iris, as that probably makes a difference.</p>\n<p>I think there's a way around this impredicativity, by including in the syntax an sForall (lean) or iForall (rocq) constructor. This constructor takes as arguments semantics of other assertions. I think this is exactly what the below approach is</p>\n<p><span class=\"user-mention silent\" data-user-id=\"933925\">Remy Seassau</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Why.20are.20sForall.20and.20sExists.20defined.20the.20way.20they.20are.3F/near/571461671\">said</a>:</p>\n<blockquote>\n<p>We ended up using a semantic definition of sForall to tie it to our syntactic definition of forall</p>\n</blockquote>\n<p>I tried something like this already. And the problem I run into is violation of positivity (of inductive definitions).</p>\n<p>(original definition)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Assertion</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">TyDet</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">TyRand</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">iForall</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Assertion</span><span class=\"w\"> </span><span class=\"n\">ds</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Assertion</span><span class=\"w\"> </span><span class=\"n\">ds</span><span class=\"w\"> </span><span class=\"n\">rs</span>\n</code></pre></div>\n<p>(iris-lean's Set predicate definition)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Assertion</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">TyDet</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">TyRand</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sForall</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Assertion</span><span class=\"w\"> </span><span class=\"n\">ds</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Assertion</span><span class=\"w\"> </span><span class=\"n\">ds</span><span class=\"w\"> </span><span class=\"n\">rs</span>\n</code></pre></div>\n<p>The former compiles and the latter does not: <code>arg #5 of 'Assertion.sForall' has a non positive occurrence of the datatypes being declared</code>. So could you let me know what you had done <span class=\"user-mention\" data-user-id=\"933925\">@Remy Seassau</span> , or just share me a link on GitHub perhaps so I could study an example?</p>",
        "id": 571684692,
        "sender_full_name": "Edwin Fernando",
        "timestamp": 1770130830
    }
]