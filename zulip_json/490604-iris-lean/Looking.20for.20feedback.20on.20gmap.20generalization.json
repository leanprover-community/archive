[
    {
        "content": "<p>I've been working on my <a href=\"https://github.com/leanprover-community/iris-lean/blob/heaps/src/Iris/Algebra/Heap.lean\">heaps PR</a> for a few days now and I'm hoping to get some feedback on it. </p>\n<p><code>Algebra/heap.lean</code> contains a general interface for data structures which behave like partial functions, and defines a CMRA over them analogous to the <code>gmap</code> CMRA from Rocq Iris. Doing it this way removes several restrictions imposed by the <code>gmap</code> type, namely:</p>\n<ul>\n<li>The restriction that the type of keys be countable</li>\n<li>The restriction that each heap can only have a finite number of allocated elements<br>\nI've actually ran into both of these issues in my research. I wrote two models of this type, <code>Algebra/Lib/ClassicalHeaps.lean</code> and <code>Algebra/Lib/FiniteHeaps.lean</code>, the latter being closer to <code>gmap</code>. </li>\n</ul>\n<p>I had to do a couple new tricks to get the general construction to work, and I'm wary of over-indexing on the few models I'm thinking about. Most of the <code>heaps.lean</code> file right now is a trainwreck but if anyone wants to look at the typeclasses at the top of that file and think of types that behave like a partial function but do not fit into this framework, it would be very helpful :)</p>",
        "id": 529480092,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752851226
    },
    {
        "content": "<p>Oh and just to point out another reason this may be of interest: the definition of <code>iProp</code> in Rocq uses the <code>gmap</code> CMRA to manage its dynamically allocated ghost state (the <code>iProp</code> CMRA is a <code>gmap</code> from <code>gname</code> to CMRA's). This heaps CMRA generalizes the Iris model as a whole.</p>",
        "id": 529481436,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752851692
    },
    {
        "content": "<p>one small quibble as I skim the file. You have lines like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">em</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">k'</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rename_i</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Store</span><span class=\"bp\">.</span><span class=\"n\">get_set_eq</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"bp\">.</span><span class=\"n\">get_set_eq</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Ht</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rename_i</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Store</span><span class=\"bp\">.</span><span class=\"n\">get_set_ne</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"bp\">.</span><span class=\"n\">get_set_ne</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Hv</span><span class=\"w\"> </span><span class=\"n\">k'</span>\n</code></pre></div>\n<p>I have two suggestions:</p>\n<ol>\n<li>You can name the cases hypothesis like <code>cases h : &lt;something&gt;</code>. This is is better than using <code>rename_i</code>. I really wish we had the batteries import so you would get the matches style syntax with a code action. </li>\n<li>I think in this instance you can simply use the <code>by_cases</code> tactic.</li>\n</ol>",
        "id": 529483123,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1752852256
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 529483221,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1752852291
    },
    {
        "content": "<p>Yeah no definitely. And there's no need to use classical there either. I will fix the proofs later.</p>",
        "id": 529483641,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752852440
    },
    {
        "content": "<p>At the moment I'm more interested in making sure the interface is right.</p>",
        "id": 529483724,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752852467
    },
    {
        "content": "<p><del>There is an implementation of partial functions in mathlib to get some inspiration for API : <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/PFun.html#PFun\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/PFun.html#PFun</a> </del>  never mind. I think it won't be useful here.</p>",
        "id": 529483747,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1752852475
    },
    {
        "content": "<p>I think <code>RepFunStore</code> isn't a good idea, that's baking in a validity predicate which will lead to some noncomputable code (which is fine but probably not necessary and will make some mess)</p>",
        "id": 529483748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752852475
    },
    {
        "content": "<p>Can you summarize the problem to be solved here?</p>",
        "id": 529483805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752852493
    },
    {
        "content": "<p>What's the API you can't change which grounds the typeclasses?</p>",
        "id": 529483942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752852537
    },
    {
        "content": "<p>Yeah. <code>RepFunStore</code> (and <code>IsoFunStore</code>) is not actually necessary for the CMRA (and I don't think either of my models end up using it) but it's a necessary condition for getting a <code>Leibniz</code> OFE when the value types are <code>Leibniz</code>.</p>",
        "id": 529484062,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752852585
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">Heap_COFE</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Heap</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">COFE</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">COFE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>\n<p>I don't think this will actually work as a typeclass instance</p>",
        "id": 529484085,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752852598
    },
    {
        "content": "<blockquote>\n<p>What's the API you can't change which grounds the typeclasses?</p>\n</blockquote>\n<p><code>gmap</code>? The API here does not exist in Iris-Rocq.</p>",
        "id": 529484328,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752852684
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Looking.20for.20feedback.20on.20gmap.20generalization/near/529484085\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">Heap_COFE</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Heap</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">COFE</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">COFE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>\n<p>I don't think this will actually work as a typeclass instance</p>\n</blockquote>\n<p>Really? I was able to write a <code>CMRA</code> so I assumed it was working</p>",
        "id": 529484436,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752852725
    },
    {
        "content": "<p>I think it might only work when <code>T</code> is a constant or local variable</p>",
        "id": 529484519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752852758
    },
    {
        "content": "<p>I'm trying to figure out what requires a meta-typeclass like <code>Heap</code> in the first place. Why can't we just have a CMRA on a partial functions type?</p>",
        "id": 529484831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752852875
    },
    {
        "content": "<p>I suspect that the general thing you want is a type that can be mapped to the type of partial functions</p>",
        "id": 529484996,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752852935
    },
    {
        "content": "<p><code>gmap</code> is not the same as a partial function, it's a partial function which internalizes the fact that its domain is finite. </p>\n<p>On the other hand, I also have more complex data structures coming from my operational semantics in NML which aren't partial functions but do behave like it. It would be nice to directly get the heap-like CMRA on this structure without having to make a complicated model of it using many different pieces of ghost state.</p>",
        "id": 529485344,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752853063
    },
    {
        "content": "<p>gmap is really just <code>TreeMap</code> IIUC</p>",
        "id": 529485396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752853082
    },
    {
        "content": "<p>but is the finiteness something the CMRA can detect?</p>",
        "id": 529485475,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752853111
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Looking.20for.20feedback.20on.20gmap.20generalization/near/529484996\">said</a>:</p>\n<blockquote>\n<p>I suspect that the general thing you want is a type that can be mapped to the type of partial functions</p>\n</blockquote>\n<p>This is how I would expect to handle things like TreeMap and HashMap</p>",
        "id": 529485561,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752853139
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Looking.20for.20feedback.20on.20gmap.20generalization/near/529485475\">said</a>:</p>\n<blockquote>\n<p>but is the finiteness something the CMRA can detect?</p>\n</blockquote>\n<p>As in making partial functions with infinite allocated elements invalid? I do not want this, because I have applications where I do want to allocate an infinite number of cells.</p>",
        "id": 529485678,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752853182
    },
    {
        "content": "<p>no I mean the opposite, just let things be infinite and does this cause a problem</p>",
        "id": 529485745,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752853205
    },
    {
        "content": "<p>It means that you can't define (a total) <code>alloc</code> function on your type</p>",
        "id": 529485827,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752853233
    },
    {
        "content": "<p>This is baked pretty deeply into a lot of Iris code</p>",
        "id": 529485956,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752853271
    },
    {
        "content": "<p>Is it supposed to always be possible to alloc, or are unallocable heaps also relevant?</p>",
        "id": 529486185,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752853343
    },
    {
        "content": "<p>I do think I can define a general instance of the non-alloc classes for types which having a mapping into partial functions though!</p>",
        "id": 529486186,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752853343
    },
    {
        "content": "<p>You could make that part of the validity predicate</p>",
        "id": 529486239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752853355
    },
    {
        "content": "<p>i.e. in a valid partial function there are always an infinite number of free slots</p>",
        "id": 529486293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752853371
    },
    {
        "content": "<p>Unallocable heaps are relevant too (eg. finite key types). We want the CMRA to work for both models.</p>",
        "id": 529486534,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752853461
    },
    {
        "content": "<p>The CMRA itself doesn't actually depend on any of this though. I had to do some tricks to get around this.</p>",
        "id": 529486761,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752853536
    },
    {
        "content": "<p>Does <code>Heap</code> need to be a predicate on a type function?</p>",
        "id": 529487759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752853853
    },
    {
        "content": "<p>I initially tried <code>class Heap (T K V : Type _) extends Store T K (Option V)</code> but got stuck.</p>",
        "id": 529488082,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752853961
    },
    {
        "content": "<p>Though, that was on an early version. I could try that again if you think it's a better idea.</p>",
        "id": 529488528,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752854108
    },
    {
        "content": "<p>I don't recall exactly what went wrong.</p>",
        "id": 529488557,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752854118
    },
    {
        "content": "<p>I see <code>hmap</code> being used, not sure what it is doing</p>",
        "id": 529488677,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752854163
    },
    {
        "content": "<p>Right. To get the CMRA constructions to work you need a definition of map which ensures that unallocated elements stay unallocated. That's the core of what makes all of the CMRA proofs work.</p>",
        "id": 529489159,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752854325
    },
    {
        "content": "<p>but CMRA doesn't have map?</p>",
        "id": 529489481,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752854426
    },
    {
        "content": "<p>Yup. Its mainly  for proofs involving <code>inc/incN</code>.</p>",
        "id": 529489665,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752854485
    },
    {
        "content": "<p>And the COFE.</p>",
        "id": 529489753,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752854514
    },
    {
        "content": "<p>In both of these cases you need to construct a heap, and the trick is that you can construct them by mapping out of one of the heaps you are given. The property you need to prove all of the CMRA properties is that unallocated elements stay unallocated.</p>",
        "id": 529490043,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752854613
    },
    {
        "content": "<p>They way they do this construction in Rocq-lean is specific to gmap, doing induction over the number of allocated elements. It's weird and definitely does not generalize to the infinitely allocated cases.</p>",
        "id": 529490195,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752854670
    },
    {
        "content": "<p>can you point to the theorem name?</p>",
        "id": 529490217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752854678
    },
    {
        "content": "<p><code>conv_compl</code> in the COFE instance is one example,<code>lookup_included</code>/<code>lookup_includedN</code> are two more</p>",
        "id": 529490403,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752854747
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/iris-lean/blob/14cf4d4ed4b734ebbdd2ccda72de2a99aab882db/src/Iris/Algebra/Heap.lean#L195\">here</a> is the mapping trick used in the definition of <code>compl</code>.</p>",
        "id": 529490643,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752854843
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"721721\">Markus de Medeiros</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Looking.20for.20feedback.20on.20gmap.20generalization/near/529486534\">said</a>:</p>\n<blockquote>\n<p>Unallocable heaps are relevant too (eg. finite key types). We want the CMRA to work for both models.</p>\n</blockquote>\n<p>Are these always total functions?</p>",
        "id": 529494134,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752856355
    },
    {
        "content": "<p>It is for gmap (and in my finite heaps instance you can see that my hasRoom predicate is True). But in general no. My definition of fresh takes a hasRoom argument</p>",
        "id": 529495090,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752856765
    },
    {
        "content": "<p>I guess we could change it to return Option instead, and have another term that says fresh on heaps with hasRoom is some</p>",
        "id": 529495207,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752856812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"721721\">Markus de Medeiros</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Looking.20for.20feedback.20on.20gmap.20generalization/near/529488082\">said</a>:</p>\n<blockquote>\n<p>I initially tried <code>class Heap (T K V : Type _) extends Store T K (Option V)</code> but got stuck.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Just to check, would this formulation be better? Happy to try again if so!</p>",
        "id": 529498010,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752858107
    },
    {
        "content": "<p>The main thing you will miss with that version of the class is <code>hmap</code></p>",
        "id": 529498200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752858178
    },
    {
        "content": "<p>You could have a class for that though (this also has the advantage of giving you the universe generic map function)</p>",
        "id": 529498301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752858224
    },
    {
        "content": "<p>btw you could also write the hmap axiom as <code>get (hmap f t) k = (get t k).bind (f k)</code></p>",
        "id": 529498588,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752858359
    },
    {
        "content": "<p>also the match statement in <code>get_merge</code> should be extracted as a function, and it already exists as the aptly named <code>Option.merge</code></p>",
        "id": 529498778,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1752858430
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Looking.20for.20feedback.20on.20gmap.20generalization/near/529498301\">said</a>:</p>\n<blockquote>\n<p>You could have a class for that though (this also has the advantage of giving you the universe generic map function)</p>\n</blockquote>\n<p><del>Yeah okay. I think that I only need self-maps, so I may be able to get away with (something like) a <code>[StoreMap T T K (Option V) (Option V)]</code> instance, plus a predicate that that map obeys the <code>hmap</code> rule. I'll give it try.</del> (Ignore this, it does not work &amp; I am trying something else)</p>",
        "id": 529499953,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752858978
    },
    {
        "content": "<p>Updated everything with your suggestions so far and it seems much more right: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Heap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"w\">  </span><span class=\"n\">hmap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"w\">  </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"w\">  </span><span class=\"n\">get_empty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"n\">get_hmap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hmap</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">get_merge</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 529513933,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1752865885
    }
]