[
    {
        "content": "<p>Hi, I've been looking into the proof mode and in particular how the proof mode uses typeclasses. As part of this, I noticed some differences between how typeclasses work in Rocq and Lean and some issues caused by this. Does someone with more knowledge about typeclasses in Lean have thoughts on the points below and how one can resolve them?</p>\n<h1>Issue 1: Typeclasses in Lean cannot instantiate mvars</h1>\n<p>The first issue is that typeclasses in Lean do no instantiate mvars that were created before the search was started while in Rocq the typeclass search can instantiate mvars. In general, I think that Lean has taken the right choice here, however this causes problems when implementing the proof mode via typeclasses as in Rocq. In particular, it is very common in Iris proofs to first create a bunch of mvars and then instantiate them via proof mode tactics.</p>\n<p>The following example illustrates the problem (the equivalent Rocq code works):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">error: failed to synthesize</span>\n<span class=\"sd\">  ProofMode.FromAssumption false (Q 1) (Q ?w)</span>\n\n<span class=\"sd\">Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.</span>\n<span class=\"sd\">---</span>\n<span class=\"sd\">trace: [Meta.synthInstance] üí•Ô∏è ProofMode.FromAssumption false (Q 1) (Q ?w)</span>\n<span class=\"sd\">  [Meta.synthInstance] new goal ProofMode.FromAssumption false (Q 1) (Q ?w)</span>\n<span class=\"sd\">    [Meta.synthInstance.instances] #[@ProofMode.fromAssumption_exact]</span>\n<span class=\"sd\">  [Meta.synthInstance] üí•Ô∏è apply @ProofMode.fromAssumption_exact to ProofMode.FromAssumption false (Q 1) (Q ?w)</span>\n<span class=\"sd\">    [Meta.synthInstance.tryResolve] üí•Ô∏è ProofMode.FromAssumption false (Q 1)</span>\n<span class=\"sd\">          (Q ?w) ‚âü ProofMode.FromAssumption ?m.25 ?m.27 ?m.27</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">exact_lean_test</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BI</span><span class=\"w\"> </span><span class=\"n\">PROP</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">PROP</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">  </span><span class=\"n\">iintro</span><span class=\"w\"> </span><span class=\"n\">HQ</span>\n<span class=\"w\">  </span><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"w\">  </span><span class=\"n\">iexact</span><span class=\"w\"> </span><span class=\"n\">HQ</span>\n</code></pre></div>\n<p><strong>Question 1: Is there a way to instantiate mvars using typeclasses in Lean?</strong></p>\n<h1>Issue 2: Typeclasses in Lean cannot create new mvars</h1>\n<p>The dual of the previous issue: Typeclasses in Rocq can <em>create</em> new mvars and the proof mode uses this, for example for the <a href=\"https://gitlab.mpi-sws.org/iris/iris/-/blob/846ed45bed6951035c6204fef365d9a344022ae6/iris/proofmode/class_instances.v#L509\"><code>IntoWand</code> instance for ‚àÄ quantifiers</a> (notice the <code>x</code>). Iris Lean has the corresponding instance <a href=\"https://github.com/leanprover-community/iris-lean/blob/6138de80fcaa32673730204007c2074f62b4d530/src/Iris/ProofMode/Instances.lean#L66\">here</a>, but this instance cannot be used to create new goals with mvars in them since Lean rejects typeclass search solutions that introduce mvars with the <a href=\"https://github.com/leanprover/lean4/blob/9d4ad1273f6cea397c3066c2c83062a4410d16bf/src/Lean/Meta/SynthInstance.lean#L402C34-L402C70\">\"skip answer containing metavariables\" error</a>. However, this instance is quite important for the proof mode to automatically handle magic wands that start with a universal quantifier without forcing the user to create an mvar for the quantifier explicitly.</p>\n<p><strong>Question 2: Is there a way to create mvars using typeclasses in Lean?</strong></p>\n<h1>Issue 3: Input / Output handling of typeclasses is more rigid in Lean than in Rocq</h1>\n<p>Lean allows only one set of input / output annotations per typeclass whereas in Rocq a typeclass can be used with different sets of inputs and outputs and the Iris proof mode make use of this feature. For example, for <code>FromAssumption</code> the argument <code>P</code> is sometimes an input and sometimes an output. (Shown a bit by the <code>Hint Mode</code> <a href=\"https://gitlab.mpi-sws.org/iris/iris/-/blob/846ed45bed6951035c6204fef365d9a344022ae6/iris/proofmode/classes.v#L17\">here</a>.) When translated to Lean, this can cause infinite loops in the typeclass search. In particular, <a href=\"https://github.com/leanprover-community/iris-lean/blob/6138de80fcaa32673730204007c2074f62b4d530/src/Iris/ProofMode/Instances.lean#L420\"><code>fromAssumption_intuitionistically_l</code></a> can create such a loop since it just adds a persistent modality in front of the output <code>P</code> in a loop. The Rocq version resolves this by introducing the <code>KnownLFromAssumption</code> typeclass with a <a href=\"https://gitlab.mpi-sws.org/iris/iris/-/blob/846ed45bed6951035c6204fef365d9a344022ae6/iris/proofmode/classes.v#L23\"><code>Hint Mode</code></a> that prevents <code>fromAssumption_intuitionistically_l</code> to apply when <code>P</code> is an output.<br>\nAlso for <a href=\"https://gitlab.mpi-sws.org/iris/iris/-/blob/846ed45bed6951035c6204fef365d9a344022ae6/iris/proofmode/classes.v#L151\"><code>IntoWand</code></a>, the argument <code>P</code> can be an input (when an explicit hypothesis is given to <code>iSpecialize</code> / <code>iApply</code>) or an output (when no explicit hypothesis is given to <code>iSpecialize</code> / <code>iApply</code>).</p>\n<p><strong>Question 3: What is the best way to implement such typeclasses with multiple different input / output specifications in Lean?</strong></p>\n<p>Overall, given all these questions, I am wondering if the type class system in Lean is the best match for implementing the proof mode of Iris or if one should use some other meta programming feature in Lean instead. Any thoughts on this?</p>",
        "id": 562983794,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1765380728
    },
    {
        "content": "<p>I don't have the technical knowledge to answer your questions (I'm not even sure who does actually) but re. your overall point I get the impression that the typeclass search in Iris-Rocq is only really used as a well-supported and extensible way to do a backtracking search. You're more experienced with this, do you feel the same? </p>\n<p>If so, then yeah I think we could try rolling our own to avoid some of these problems.</p>",
        "id": 563081736,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765410824
    },
    {
        "content": "<p>For the questions, maybe <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> or <span class=\"user-mention\" data-user-id=\"395550\">@Henrik B√∂ving</span> might be able to say something?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"721721\">Markus de Medeiros</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Issues.20with.20typeclasses.20in.20the.20proof.20mode/near/563081736\">said</a>:</p>\n<blockquote>\n<p>I get the impression that the typeclass search in Iris-Rocq is only really used as a well-supported and extensible way to do a backtracking search. You're more experienced with this, do you feel the same?</p>\n</blockquote>\n<p>My feeling is that typeclasses are basically the only extensible proof search mechanism in Rocq so all kind of proof search gets shoehorned into typeclasses and this is why the proof mode uses them. That said, if you can use the existing type class mechanism it is quite nice since one can reuse quite a bit of infrastructure. In Lean, we have the advantage that we can implement our own extensible mechanism if we want to, but this is quite a bit of work. So before doing this, I would like to make sure that this is indeed the best option and there is no way to use existing mechanisms (like type classes) to do what we want.</p>",
        "id": 563119940,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1765438921
    },
    {
        "content": "<p>I think Issue 1 is not correct. Lean can (and has to) instantiate mvars based on type class search sometimes. Though it might of course be that it doesn't work for the specific mvars that you are interested in.</p>\n<p>Issue 2 is correct I think.</p>\n<p>For issue 3 you can try to split it up into multiple type classes to simulate the different fundeps that you are interested in.</p>\n<p>More generally speaking though, if you are interested in an extensible proof search mechanism I think doing aesop annotations could be just fine?</p>",
        "id": 563126849,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1765441580
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik B√∂ving</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Issues.20with.20typeclasses.20in.20the.20proof.20mode/near/563126849\">said</a>:</p>\n<blockquote>\n<p>I think Issue 1 is not correct. Lean can (and has to) instantiate mvars based on type class search sometimes. Though it might of course be that it doesn't work for the specific mvars that you are interested in.</p>\n</blockquote>\n<p>Could you clarify in which cases Lean's type class search can instantiate mvars? My understanding is that tc search increases the mvar depth so no mvar that was instantiated before the tc search can be instantiated by the search. Is this correct? Is there a way to prevent this increase of the depth?</p>\n<p>Here is a pure Lean example that shows the issue. I would be interested if there is a way to make this example work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Impl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">impl_correct</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">B</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Impl</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">HP</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">  </span><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Impl</span><span class=\"bp\">.</span><span class=\"n\">impl_correct</span><span class=\"w\"> </span><span class=\"n\">HP</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- error here since the instance does not apply</span>\n</code></pre></div>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik B√∂ving</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Issues.20with.20typeclasses.20in.20the.20proof.20mode/near/563126849\">said</a>:</p>\n<blockquote>\n<p>For issue 3 you can try to split it up into multiple type classes to simulate the different fundeps that you are interested in.</p>\n</blockquote>\n<p>This could work, but it would probably require duplicating some instances for the multiple type classes. I will need to look into this.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik B√∂ving</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Issues.20with.20typeclasses.20in.20the.20proof.20mode/near/563126849\">said</a>:</p>\n<blockquote>\n<p>More generally speaking though, if you are interested in an extensible proof search mechanism I think doing aesop annotations could be just fine?</p>\n</blockquote>\n<p>Thanks for the pointer! I've not looked into aesop yet, but will do so.</p>",
        "id": 563143918,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1765446941
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574718\">Michael Sammler</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Issues.20with.20typeclasses.20in.20the.20proof.20mode/near/563143918\">said</a>:</p>\n<p>Here is a pure Lean example that shows the issue. I would be interested if there is a way to make this example work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Impl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">impl_correct</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">B</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Impl</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">HP</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">  </span><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Impl</span><span class=\"bp\">.</span><span class=\"n\">impl_correct</span><span class=\"w\"> </span><span class=\"n\">HP</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- error here since the instance does not apply</span>\n</code></pre></div>\n<p>In this specific example, can you make <code>B</code> an output parameter?</p>",
        "id": 563146075,
        "sender_full_name": "Zongyuan Liu",
        "timestamp": 1765447545
    },
    {
        "content": "<blockquote>\n<p>Could you clarify in which cases Lean's type class search can instantiate mvars?</p>\n</blockquote>\n<p>It can instantiate mvars for <code>outParam</code> parameters. In fact the way in which they are implemented is that, even if they are already determined at the call site, the argument to an <code>outParam</code> gets forcibly swapped with a metavariable that TC search is expected to fill. If you can't do <code>outParam</code>s it becomes more difficult though yes.</p>",
        "id": 563149306,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1765448528
    },
    {
        "content": "<p>Thanks for pointing this out! The example indeed works if <code>B</code> is an <code>outParam</code> (but not for a <code>semiOutParam</code>). I will have to see if I can use this to address the problem.</p>",
        "id": 563167061,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1765453620
    },
    {
        "content": "<p>Just one other thing I will throw in which I've already told Michael about but I want to put in text.</p>\n<p>In Lean it does not seem possible or idiomatic to mix typeclass backtracking search and  tactic-level backtracking search <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/Search.20for.20typeclass.20with.20Qq/near/520299216\">#general &gt; Search for typeclass with Qq @ üí¨</a>. Iris-Rocq tactics frequently use the <a href=\"https://plv.mpi-sws.org/coqdoc/stdpp/stdpp.base.html\">tc_solve</a> tactic from stdpp, which searches over the set of all possible typeclass solutions, and consequently is used to search for a typeclass instance such that a higher-level Iris tactic (like apply) succeeds. </p>\n<p>If it's possible to move all of the typeclass synthesis upfront, or if there is only ever one solution to to the typeclass search problem, then this is no problem and the same design as Rocq works in Lean. For the simple tactics this is the case. But if we really want (or need) to preserve the possibility that the typeclass search returns an solution that we want to reject for other reasons, then this might be another reason to write our own search.</p>",
        "id": 563173500,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765455737
    },
    {
        "content": "<p>For that, you don't necessarily need to write your own search; you just need to call a more low-level entrypoint to TC search</p>",
        "id": 563208037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765465045
    },
    {
        "content": "<p>This sounds interesting. Could you elaborate what you mean with \"that\" and which low-level entrypoint to TC search?<br>\nIn fact, I looked for more low-level entry points to TC search that might give more control but only found the functions <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Meta/SynthInstance.html\">here</a> and I am not sure which one I can call except the toplevel <code>synthInstance</code> family of functions.</p>",
        "id": 563209571,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1765465377
    },
    {
        "content": "<p>We might have to write it ourselves, but the capability fundamentally exists</p>",
        "id": 563210775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765465660
    },
    {
        "content": "<p>it would probably be best to get it upstreamed though</p>",
        "id": 563210959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765465703
    },
    {
        "content": "<p>I see. Just to clarify, which of the issues do you think one could solve by tweaking type class search (with a more low-level entry point)? The issue of calling tactics that Markus mentioned or (one of) the 3 issues in the original post or all of them?</p>",
        "id": 563211983,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1765465951
    },
    {
        "content": "<p>Markus's issue, not your 3</p>",
        "id": 563212208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765466006
    },
    {
        "content": "<p>I think it may be possible to solve 1 and/or 2 by setting a flag which allows setting metavariables outside the usual stack discipline</p>",
        "id": 563212392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765466049
    },
    {
        "content": "<p>I think issue 3 is under control already, I don't see evidence it's a major hindrance</p>",
        "id": 563212737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1765466125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574718\">Michael Sammler</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Issues.20with.20typeclasses.20in.20the.20proof.20mode/near/563143918\">said</a>:</p>\n<blockquote>\n<p>Henrik B√∂ving <a href=\"#narrow/channel/490604-iris-lean/topic/Issues.20with.20typeclasses.20in.20the.20proof.20mode/near/563126849\">said</a>:</p>\n<blockquote>\n<p>More generally speaking though, if you are interested in an extensible proof search mechanism I think doing aesop annotations could be just fine?</p>\n</blockquote>\n<p>Thanks for the pointer! I've not looked into aesop yet, but will do so.</p>\n</blockquote>\n<p>I've looked into aesop and it seems like it would probably indeed be possible to use it for the proof automation. It allows instantiating mvars (issue 1) and can also create new evars (issue 2). The proof search can also be customized with custom tactics.</p>\n<p>My main concern about aesop is performance since it does a lot of things that we do not need / want. E.g. it calls simp at every step of the proof search. I've not looked into this, but maybe with the right flags one can get a stripped down version of aesop that is similar to what tc search does, but more customizable.</p>",
        "id": 563410548,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1765527192
    }
]