[
    {
        "content": "<p>Hi I was looking for an example of implementation of reasoning with Hoare triples, but realised that HeapLang is still not implemented. My goal is to implement a probabilistic separation logic for my masters project and I was hoping to use Iris Lean for this. I don't want to use the whole of Iris but just MoSeL.</p>\n<p>I'm wondering if there are some common abstractions for supporting reasoning with <code>wp</code>/Hoare triples, that belong in Iris-lean rather than my instantiation of it. Any thoughts about that?</p>\n<p>I'm also wondering whether there might be any obvious blockers to this kind of instantiation. I'm happy to contribute to the Iris-lean project directly as well!</p>",
        "id": 547005848,
        "sender_full_name": "Edwin Fernando",
        "timestamp": 1761343841
    },
    {
        "content": "<p>Currently not really. We are still getting iprop done</p>",
        "id": 547009616,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1761347174
    },
    {
        "content": "<p>I am implementing heaplang piece by piece but this is currently stalled. I can finish my first PR if it would help you</p>",
        "id": 547009669,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1761347214
    },
    {
        "content": "<p>It has been on the back burner</p>",
        "id": 547009684,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1761347224
    },
    {
        "content": "<p>But if you just want to use MoSeL and build your own abstraction that‚Äôs already viable in a repo downstream of iris-lean and mathlib.   I believe <span class=\"user-mention\" data-user-id=\"721721\">@Markus de Medeiros</span> has some ideas on how to do probabilistic verification</p>",
        "id": 547009751,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1761347287
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Hoare.20Triples.20in.20Iris-Lean/near/547009616\">said</a>:</p>\n<blockquote>\n<p>Currently not really. We are still getting iprop done</p>\n</blockquote>\n<p>Could you elaborate what iprop is? Is it an Iris proposition? That's not relevant for MoSeL right?</p>",
        "id": 547010132,
        "sender_full_name": "Edwin Fernando",
        "timestamp": 1761347583
    },
    {
        "content": "<p>Hi! Always cool to see people interested in Iris-Lean, I'm happy to help clear some things up.</p>\n<ul>\n<li>There is no common <code>wp</code> predicate defined yet. The Iris-Rocq project defines one, however, forks of the Iris project often re-define it for domain specific applications. For example, and since you mentioned probability <a href=\"https://github.com/logsem/clutch/blob/d76d0e33029e89041a7b92fc95fafc06ff32cfc7/theories/eris/weakestpre.v#L680\">here</a> is how it is defined in the Eris (Rocq) logic. </li>\n<li><code>iProp</code> is the type that Iris uses to instantiate the proof interface with (ie. the proof interface manipulates <code>iProp</code> expressions). You can instanstiate MoSeL this with a different type if you'd like. An example of doing this is the <a href=\"https://github.com/leanprover-community/iris-lean/blob/master/src/Iris/Instances/Classical/Instance.lean\">classical</a> instance. </li>\n<li>The project Shreyas is referring to is KLR. KLR instanstiates MoSeL with <code>UPred</code>, which you can think of as a more basic form of <code>iProp</code>. The definition for a weakest precondition in KLR is <a href=\"https://github.com/leanprover/KLR/blob/301f9692fa3540eb514cdfd663223b8886116600/KLR/Semantics/Logic.lean#L124\">here</a>. </li>\n<li>Both KLR, Eris, and many other Iris-based logics define weakest preconditions <em>internally</em>, as in they first define a logic, and then they express what a weakest precondition <em>means</em> inside that logic. For this reason, the KLR and Eris weakest preconditions are very similar in their definition. If you wanted to work inside the Iris framework, your definition could be similar as well. </li>\n</ul>\n<p>There is nothing stopping you from instantiating MoSeL with a different type, perhaps one which represents a weakest precondition <em>externally</em>. In that case, you're right that <code>iProp</code> will have nothing to do with your logic, and you can use MoSeL on its own!</p>",
        "id": 547010961,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1761348297
    },
    {
        "content": "<p>Thanks for the info and links! I believe according to this description that I would be defining <code>wp</code> <em>internally</em> to the logic. I aim to formalise <a href=\"https://arxiv.org/pdf/2304.01339\">Lilac</a> by the way. And I plan to instantiate MoSeL with a different type (not <code>iprop</code>), since Iris has many things which I believe aren't required for the language and logic I want to formalise.</p>",
        "id": 547011894,
        "sender_full_name": "Edwin Fernando",
        "timestamp": 1761349260
    },
    {
        "content": "<p>Oh excellent!!! You may be interested to see that the zkEVM people have started porting <a href=\"https://github.com/Verified-zkEVM/iris-lean\">Bluebell</a> (though I don't know how much is going on there). I've actually chatted with John Li about formalizing Lilac in Iris-Lean, not to put words in his mouth but I get the impression that it's well within the realm of possibility. </p>\n<p>Probabilistic separation logic was the main reason I got into Iris-Lean so I'll be interested in hearing what comes of this! I'm hoping to port some parts of Eris when I have the time, maybe we can even share some work later on!</p>",
        "id": 547012654,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1761350088
    },
    {
        "content": "<p>I'm roughly at the middle (of material before appendix) of <a href=\"https://arxiv.org/abs/2402.18708\">BlueBell paper</a>. It's getting more interesting as I follow the pages.</p>",
        "id": 557911262,
        "sender_full_name": "Yoichi Hirai",
        "timestamp": 1763467016
    },
    {
        "content": "<p>I'm confused on how contexts and environments work in Iris-lean and I thought I'd ask here.<br>\nI'm used to semantics of assertions being given in the form <code>s, h ‚ä® P</code>. My confusion is in figuring out how to model <code>s</code>, which is not present in the classical instantiation for example.  <br>\n1) I've noticed a difference between the MoSeL paper + rocq implementation vs the lean implementation in how quantification works.<br>\n<a href=\"https://gitlab.mpi-sws.org/iris/iris/-/blob/master/iris/bi/interface.v?ref_type=heads#L18\"><code>bi_forall : ‚àÄ A, (A ‚Üí PROP) ‚Üí PROP</code></a>        (in rocq)<br>\n<a href=\"https://github.com/leanprover-community/iris-lean/blob/master/src/Iris/BI/BIBase.lean#L26\"><code>sForall : (PROP ‚Üí Prop) ‚Üí PROP</code></a>        (in lean)</p>\n<p>2) I believe the rocq implementation atleast, supports environments as a <a href=\"https://gitlab.mpi-sws.org/iris/iris/-/blob/master/iris/proofmode/environments.v#L7\">maps from strings to a fixed type A</a>. (I understand this as working in an untyped calculus). But I would really like to work with environments which allow mapping an index to some type in a type family <code>(Œ≤ : Œ± ‚Üí Type u)</code> where <code>Œ±</code> is the syntax of a type in the language and <code>Type u</code> is the donation of the type, in Lean. I understand this as working with strongly typed environments. I'm making guesses here but was the change in 1) perhaps meant to enable 2)</p>\n<p>3) Could you explain which parts of the lean code I should look at to see, how environments now work. <code>Environments.lean</code> is not there. I'm guessing the comments/<a href=\"https://github.com/leanprover-community/iris-lean/blob/master/proofmode.md?plain=1#L125\">proofmode.md</a> are a little out of date. There is mention of an <a href=\"https://github.com/leanprover-community/iris-lean/blob/master/src/Iris/ProofMode/Display.lean#L16\"><code>EnvsEntail</code> function here</a>, which I couldn't find, which I thought might be important for me.</p>\n<p>I also wanted to note that lilac assertions have two intuitionistic contexts, one for deterministic and the other for random variables (so I'm trying to figure out how to represent that with this question).</p>",
        "id": 566966850,
        "sender_full_name": "Edwin Fernando",
        "timestamp": 1767885248
    },
    {
        "content": "<p>Happy to try and help!<br>\n1) See <a class=\"stream-topic\" data-stream-id=\"490604\" href=\"/#narrow/channel/490604-iris-lean/topic/Why.20are.20sForall.20and.20sExists.20defined.20the.20way.20they.20are.3F/with/562262758\">#iris-lean &gt; Why are sForall and sExists defined the way they are?</a> <br>\n2) This I'm not too sure of. Iris-Rocq does have the ability to combine multiple different BI instances: we haven't tested this in Iris-Lean and I'm not 100% sure what you describe is well-supported in Iris-Rocq either. Could you maybe describe this in more detail? It's common in Iris to define the denotation of a type using a logical relation, you can do this as long as all of your denotations live in the same BI instance.<br>\n3) The representation the proofmode uses is <code>[*] [spatial context] * pers [^] [Intuitionistic context]</code>.  Names are attached to each term in this expression at the meta-level, and the tactics parse this form into the <code>Hyps</code> data structure from <a href=\"https://github.com/leanprover-community/iris-lean/blob/master/src/Iris/ProofMode/Expr.lean\">Expr.lean</a>. That's probably where you want to look, though you might also want to just look through some of the tactic implementations to see which metaprograms are used to manipulate <code>Hyps</code>. </p>\n<p>And re. your last note: I don't think there are any plans to support multiple intuitionistic contexts, though I'd guess you can simulate this inside one context, no?</p>",
        "id": 566973078,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1767886759
    },
    {
        "content": "<blockquote>\n<p>The representation the proofmode uses is <code>[*] [spatial context] * pers [^] [Intuitionistic context]</code>.</p>\n</blockquote>\n<p>I would like to clarify that Iris Lean does not use this representation (this is used by Iris Rocq). Instead, Iris Lean uses the <a href=\"https://github.com/leanprover-community/iris-lean/blob/master/src/Iris/ProofMode/Expr.lean#L29\">Hyps</a> data structure that represents the context as a tree where each node can be persistent or not. I am also currently working on refactoring the proof mode so this might change in the future.</p>",
        "id": 567093580,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1767948350
    },
    {
        "content": "<p>Oh whoops, yeah this is right. It has this representation logically (as in that's what hyps represents in terms of BI), and it has the capability to go back and forth between hyps and this representation (with the istop and istart tactics), but it's not this representation literally. Thanks for chiming in Michael!</p>",
        "id": 567117758,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1767956609
    },
    {
        "content": "<p>Sorry for the confusing previous question. Thanks, for the answers! I was using the wrong terminology I think, and didn't really want to refer to the spatial or intuitionistic contexts. I wanted to refer to the <code>s</code> in the <code>s, h ‚ä® P</code> used to give semantics to assertions in a classical separation logic, through the satisfiability relation.<br>\nI think there is no need for an <code>s</code> (program variable environment) in classical instance provided as an example by Iris-lean. I would expect it to be seen only when HeapLang is introduced and when reasoning about HeapLang programs. I think I should perhaps port HeapLang, to understand things better? Particularly the definition of the PROP parameter of <code>BI</code> and <code>BIBase</code>. Would it be of the form <code>PROP := Store ‚Üí Heap ‚Üí Prop</code>? Would this shape for <code>PROP</code> be standard?</p>\n<p>And following on from the previous suggested shape from <code>PROP</code>, question 2), was about the type <code>Store</code> (which is a typing context Œì, hence my use of the word context). I don't at the moment have a question about this anymore since I wanted to think about it more first, particularly about logical relations. For more context, in the Lilac paper it is given like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"bp\">::=</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">ùë•</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">ùëÜ</span><span class=\"w\">     </span><span class=\"o\">(</span><span class=\"bp\">ùëÜ</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">)</span>\n<span class=\"bp\">‚ü¶ùë•</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">ùëÜ</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">ùë•ùëõ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">ùëÜùëõ</span><span class=\"w\"> </span><span class=\"bp\">‚üß</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">ùëÜ</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"bp\">ùëÜùëõ</span>\n</code></pre></div>\n<p>example usage in an inference rule for defining probability specific SL connective <code>Own E</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">ùê∏</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"bp\">‚ü¶</span><span class=\"n\">Œì</span><span class=\"bp\">‚üß</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"bp\">‚ü¶</span><span class=\"n\">Œî</span><span class=\"bp\">‚üß</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">m</span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"bp\">ùê¥</span><span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">m</span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">measurable</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Œî</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">typing</span><span class=\"w\"> </span><span class=\"n\">context</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">random</span><span class=\"w\"> </span><span class=\"n\">variables</span><span class=\"o\">)</span>\n<span class=\"c1\">---------------------------</span>\n<span class=\"n\">Œì</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">Œî</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"w\"> </span><span class=\"n\">own</span><span class=\"w\"> </span><span class=\"bp\">ùê∏</span>\n</code></pre></div>",
        "id": 567124267,
        "sender_full_name": "Edwin Fernando",
        "timestamp": 1767959084
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"951712\">Edwin Fernando</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Hoare.20Triples.20in.20Iris-Lean/near/567124267\">said</a>:</p>\n<blockquote>\n<p>Would it be of the form <code>PROP := Store ‚Üí Heap ‚Üí Prop</code>? Would this shape for <code>PROP</code> be standard?</p>\n</blockquote>\n<p>Yes, I think this would be the way to get a standard separation logic. See <a href=\"https://gitlab.mpi-sws.org/iris/iris/-/blob/master/tests/heapprop.v?ref_type=heads\">here</a> for an example that does this in Iris Rocq.<br>\nI do not understand Liliac / what you are trying to do enough to say something there. Maybe you can give it a try and see what issues you run into?</p>",
        "id": 567167452,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1767972574
    }
]