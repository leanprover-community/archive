[
    {
        "content": "<p>Hi!</p>\n<p>First post here, apologies if this is the wrong location for this. I saw <a href=\"https://github.com/leanprover-community/iris-lean/issues/46\">this issue on mutual fixpoints</a> was tagged as beginner friendly, and figured it would be a good way to get my feet wet/learn a little about the ecosystem. </p>\n<p>I've been using <a href=\"https://plv.mpi-sws.org/coqdoc/iris/iris.algebra.ofe.html\">the rocq OFE page</a> as a roadmap to port the <code>FixpointAB</code>  section, but was running into some issues such that I would ask here. I'm also flying a little in the dark as I don't fully understand the underlying COFE theory and am just symbol-pushing, so please bear with me if the question doesn't fully type check.</p>\n<p>I'm trying to port </p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Local</span> <span class=\"kn\">Definition</span> <span class=\"n\">fixpoint_AB</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">fixpoint</span> <span class=\"o\">(</span><span class=\"n\">fB</span> <span class=\"n\">x</span><span class=\"o\">).</span>\n  <span class=\"kn\">Local</span> <span class=\"kn\">Instance</span> <span class=\"n\">fixpoint_AB_contractive</span> <span class=\"o\">:</span> <span class=\"n\">Contractive</span> <span class=\"n\">fixpoint_AB</span><span class=\"o\">.</span>\n  <span class=\"kn\">Proof</span><span class=\"o\">.</span>\n    <span class=\"k\">intros</span> <span class=\"n\">n</span> <span class=\"n\">x</span> <span class=\"n\">x'</span> <span class=\"n\">Hx</span><span class=\"o\">;</span> <span class=\"k\">rewrite</span> <span class=\"o\">/</span><span class=\"n\">fixpoint_AB</span><span class=\"o\">.</span>\n    <span class=\"k\">apply</span> <span class=\"n\">fixpoint_ne</span><span class=\"bp\">⇒</span> <span class=\"n\">y</span><span class=\"o\">.</span> <span class=\"kp\">by</span> <span class=\"n\">f_contractive</span><span class=\"o\">.</span>\n  <span class=\"kn\">Qed</span><span class=\"o\">.</span>\n</code></pre></div>\n<p>and am using the <code>OFE.ContractiveHom.fixpoint</code> to do so. As such, I can apply <code>OFE.ContractiveHom.fixpoint_ne.ne</code> to unroll outside the fixpoint definition, but I'm now on the hook to show that 2 <code>ContractiveHom</code>s are <code>n</code> equivalent.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fB</span><span class=\"w\"> </span><span class=\"n\">y1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ne</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">contractive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">≡</span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fB</span><span class=\"w\"> </span><span class=\"n\">y2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ne</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">contractive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>From my understanding, there don't seem to be rewrite rules about <code>n</code> equivalence that would allow me to convert this goal to a pointwise <code>n</code>-equivalence check on the application of the function on all points (I'm not fully sure this is even the correct definition of <code>n</code> equivalence for functions). </p>\n<p>The Rocq version seems to use this <code>f_contractive</code> tactic for this -- is that what I should focus on porting to get this working?</p>\n<p>Thanks!</p>",
        "id": 563542055,
        "sender_full_name": "Pranav S",
        "timestamp": 1765565594
    },
    {
        "content": "<p>Hi, this issue is probably not very friendly if you are not familiar with the theory. For your question, I don't think you need to port the tactic for this. The Rocq lemma can also be proven as the following</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code>  <span class=\"kn\">Local</span> <span class=\"kn\">Instance</span> <span class=\"n\">fixpoint_AB_contractive</span> <span class=\"o\">:</span> <span class=\"n\">Contractive</span> <span class=\"n\">fixpoint_AB</span><span class=\"o\">.</span>\n  <span class=\"kn\">Proof</span><span class=\"o\">.</span>\n    <span class=\"k\">intros</span> <span class=\"n\">n</span> <span class=\"n\">x</span> <span class=\"n\">x'</span> <span class=\"n\">Hx</span><span class=\"o\">;</span> <span class=\"k\">rewrite</span> <span class=\"o\">/</span><span class=\"n\">fixpoint_AB</span><span class=\"o\">.</span>\n    <span class=\"k\">apply</span> <span class=\"n\">fixpoint_ne</span><span class=\"o\">=&gt;</span> <span class=\"n\">y</span><span class=\"o\">.</span>\n    <span class=\"k\">apply</span> <span class=\"n\">fB_contractive</span><span class=\"o\">.</span>\n    <span class=\"o\">-</span> <span class=\"kp\">exact</span> <span class=\"n\">Hx</span><span class=\"o\">.</span>\n    <span class=\"o\">-</span> <span class=\"kp\">reflexivity</span><span class=\"o\">.</span>\n  <span class=\"kn\">Qed</span><span class=\"o\">.</span>\n</code></pre></div>\n<p>The key is to apply <code>fB_contractive</code>.</p>",
        "id": 563550702,
        "sender_full_name": "Zongyuan Liu",
        "timestamp": 1765569121
    },
    {
        "content": "<p>Noted, thanks for the response -- I'll try tinkering a bit more before giving up and trying something else:</p>\n<p>Was able to get it working in Lean for this instance, however, thank you for your help!</p>",
        "id": 563553142,
        "sender_full_name": "Pranav S",
        "timestamp": 1765570029
    },
    {
        "content": "<p>It's totally fine to ask! If you have a draft PR somewhere it also makes it easier to answer technical questions about your implementation like this one.</p>",
        "id": 563553850,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765570331
    },
    {
        "content": "<p>I was able to get through the rest of the proofs in the ROCQ implementation, though I skipped the <code>Proper</code> proofs as those were also not implemented for regular fixpoints. I've opened a <a href=\"https://github.com/leanprover-community/iris-lean/pull/104\">PR</a> and am happy to tweak naming or condense things. Please bear with me for any beginner mistakes, and thanks for the help :)</p>",
        "id": 563908121,
        "sender_full_name": "Pranav S",
        "timestamp": 1765827123
    },
    {
        "content": "<p><del>Also, for my own edification, circling back to the above question I had:</del></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fB</span><span class=\"w\"> </span><span class=\"n\">y1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ne</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">contractive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">≡</span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fB</span><span class=\"w\"> </span><span class=\"n\">y2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ne</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">contractive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p><del>When dealing with this proof obligation, what I was having trouble with was converting this from a fact about <code>Dist</code> between contractive functions to <code>Dist</code> between the underlying types via extensionality, and I incorrectly assumed that the <code>f_contractive</code> tactic was somehow doing this. What I missed was that I could convert this goal to a pointwise goal by simply performing <code>intro y</code>. However, I cannot figure out how <code>intro</code> knows how to do this. There doesn't seem to be an extentionality tactic attached to any of the relevant types, so I am a tad confused.</del> nvm found it: <code>Dist n f g := ∀ x, f x ≡{n}≡ g x</code> for the function instance.</p>",
        "id": 563914526,
        "sender_full_name": "Pranav S",
        "timestamp": 1765829105
    },
    {
        "content": "<p>Awesome thanks for contributing! I'll take a closer look and do a cleanup pass sometime but this looks good. Just re. your comment since it's been asked by a few people already: <code>Proper ((≡) ==&gt; (≡))</code> in Rocq is a corollary of <code>NonExpansive</code> (this follows from the <code>equiv_dist</code>) field of <code>OFE</code>. Rocq adds this in as an explicit typeclass instance to make use of generalized rewriting, but we don't have/use that, so we don't port them if we have <code>NonExpansive</code> or <code>Contractive</code> proven.</p>",
        "id": 563921252,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765831458
    },
    {
        "content": "<p>Would you be interested in porting more OFE stuff?</p>",
        "id": 563921328,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765831487
    },
    {
        "content": "<p>Thanks! I just realized that the <code>fixpointA_ne</code> and <code>fixpointB_ne</code> can probably be rephrased in terms of <code>NonExpansive₂</code>, so will push that change to the PR as well if I can get it working.</p>\n<p>I'd be happy to port some more stuff here as well! Are there other sections that should be moved over?</p>",
        "id": 563921801,
        "sender_full_name": "Pranav S",
        "timestamp": 1765831673
    },
    {
        "content": "<p>Yeah there are a couple things left to port in <code>OFE.v</code>! You could do the OFE for sigma types, or look through the CMRA's that for ones missing OFunctors and port those.</p>",
        "id": 563923117,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765832149
    },
    {
        "content": "<p>These should hopefully be around the same level of difficulty but do ask if there's anything confusing</p>",
        "id": 563923232,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765832191
    },
    {
        "content": "<p>Sounds good, i'll take a look!</p>",
        "id": 563924392,
        "sender_full_name": "Pranav S",
        "timestamp": 1765832580
    }
]