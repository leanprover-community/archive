[
    {
        "content": "<p>Thanks Mario for making this channel! It'll be good to have somewhere central to discuss this project. </p>\n<p>For people who want to contribute I think that there's a number of results that are within reach: </p>\n<ul>\n<li>The lemmas about (C)OFE's from <code>ofe.v</code> and CMRA's from <code>cmra.v</code>, many of which are self-contained</li>\n<li>The definition of the UPred CMRA, and the connectives defining a <code>BIBase</code> instance </li>\n<li>oFunctor/rFunctor instances, we have a definition for oFunctors and the fixpoint theorem but no instances! </li>\n</ul>\n<p>Once more <code>COFE</code> and <code>CMRA</code> lemmas are ported, much more of <code>algebra/</code> will be accessible: <code>local_updates.v</code>, <code>algebra/lib/</code> etc. </p>\n<p>If anyone else has any ideas of easy tasks to point people to maybe you can put them here too. Sadly I'll be too busy to contribute for the next few weeks but I'm hoping to pick it back up afterwards!</p>",
        "id": 505213360,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1741803281
    },
    {
        "content": "<p>As a long-term goal: port <a href=\"https://gitlab.mpi-sws.org/iris/lambda-rust\">λRust</a>?</p>",
        "id": 505216967,
        "sender_full_name": "suhr",
        "timestamp": 1741804164
    },
    {
        "content": "<p>I guess I can try my hand at lambda rust because I worked with very similar code and if I have trouble understanding it, Derek’s group is in a very nearby building</p>",
        "id": 505251669,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1741814134
    },
    {
        "content": "<p>I’ll probably not get to it before end of March though (possibly even middle of April)</p>",
        "id": 505251846,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1741814179
    },
    {
        "content": "<p>By the way, HeapLang also needs porting?</p>",
        "id": 505447944,
        "sender_full_name": "suhr",
        "timestamp": 1741878366
    },
    {
        "content": "<p>Indeed, both of these things should eventually be done! At the moment we don't even have a definition for <code>iProp</code> so there's more foundational work to do <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n<p>One could probably port the operational semantics of HeapLang (<code>HeapLang/lang.v</code>) or the language hierarchy (<code>iris/program_logic/langauge.v</code>, <code>iris/program_logic/ectx*</code>) but I don't think there is not enough Iris ported yet to even state lemmas about the HeapLang program logic.</p>",
        "id": 505450532,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1741878951
    },
    {
        "content": "<p>I was curious what exercises could I do to get familiar with Iris in Lean, but it seems like not too many yet.</p>\n<p>Porting the whole thing is not exactly a quick exercise to do in a spare time.</p>",
        "id": 505451443,
        "sender_full_name": "suhr",
        "timestamp": 1741879154
    },
    {
        "content": "<p>Definitely haha. How familiar are you with Iris? </p>\n<p>The most accessible lemmas to port are probably the lemmas from <code>algebra/ofe.v</code> and <code>algebra/cmra.v</code> since Mario already has the relevant definitions stated and the lemmas are mostly self-contained (I know this from <a href=\"https://github.com/markusdemedeiros/Eileen/blob/main/Eileen/Ofe.lean\">experience</a>). If you're more familiar with Iris, you could pick and port a CMRA from <code>Algebra/</code> like Leo did a few weeks ago.</p>",
        "id": 505453449,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1741879575
    },
    {
        "content": "<p>By the way, seems like <a href=\"https://github.com/logsem/iris-tutorial/blob/master/exercises/basics.v\">https://github.com/logsem/iris-tutorial/blob/master/exercises/basics.v</a> needs only iProp, so when iProp is ported I could try to do it.</p>\n<blockquote>\n<p>How familiar are you with Iris?</p>\n</blockquote>\n<p>“Heard about it” level of familiarity.</p>",
        "id": 505458460,
        "sender_full_name": "suhr",
        "timestamp": 1741880686
    },
    {
        "content": "<p>Judging from imports, there's the following dependency chain iprop → gmap → gset → crma. So iProp port is far away.</p>",
        "id": 505464036,
        "sender_full_name": "suhr",
        "timestamp": 1741881890
    },
    {
        "content": "<p>There's already some definition CMRA in the repo, so I guess it only needs a ton of lemmas to be ported. But <a href=\"https://github.com/leanprover-community/iris-lean/pull/11\">https://github.com/leanprover-community/iris-lean/pull/11</a> suggests a different definition.</p>",
        "id": 505465293,
        "sender_full_name": "suhr",
        "timestamp": 1741882201
    },
    {
        "content": "<p>Yep. For context:<code>iProp</code> is <code>uPred</code> instantiated with a particular <code>CMRA</code>; the <code>gmap</code> and <code>gset</code> <code>OFE</code>'s are used to construct this <code>CMRA</code> (alongside the fixpoint solver which Mario has already ported!). I think that <code>uPred</code> is accessible to us in the short term, but most stuff is blocked by <code>CMRA</code> and <code>COFE</code> lemmas so porting that is helpful!</p>\n<p>Once I have time again, and if nobody else has picked it up, porting CMRA lemmas is where I'll start.</p>",
        "id": 505477640,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1741885302
    },
    {
        "content": "<p>As for that PR, don't worry about it. There's a new definition of <code>CMRA</code> that is (as far as I can tell) in the process of being upstreamed to Iris, and we're waiting until they upstream it to do the same.</p>",
        "id": 505477916,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1741885362
    },
    {
        "content": "<p>All right, basic lemmas are very straightforward. I proved a few: <a href=\"https://github.com/leanprover-community/iris-lean/pull/14\">https://github.com/leanprover-community/iris-lean/pull/14</a>.</p>\n<p>The Coq proof of <code>cmra_pcore_l'</code> looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Lemma</span> <span class=\"n\">cmra_pcore_l'</span> <span class=\"n\">x</span> <span class=\"n\">cx</span> <span class=\"o\">:</span> <span class=\"n\">pcore</span> <span class=\"n\">x</span> <span class=\"bp\">≡</span> <span class=\"n\">Some</span> <span class=\"n\">cx</span> <span class=\"o\">→</span> <span class=\"n\">cx</span> <span class=\"bp\">⋅</span> <span class=\"n\">x</span> <span class=\"bp\">≡</span> <span class=\"n\">x</span><span class=\"o\">.</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span> <span class=\"k\">intros</span> <span class=\"o\">(</span><span class=\"n\">cx'</span><span class=\"o\">&amp;?&amp;&lt;-)%</span><span class=\"n\">Some_equiv_eq</span><span class=\"o\">.</span> <span class=\"kp\">by</span> <span class=\"k\">apply</span> <span class=\"n\">cmra_pcore_l</span><span class=\"o\">.</span> <span class=\"kn\">Qed</span><span class=\"o\">.</span>\n</code></pre></div>\n<p>But I don't quite understand <code>Some_equiv_eq</code> here. How equivalence is turned into equality?</p>",
        "id": 505517041,
        "sender_full_name": "suhr",
        "timestamp": 1741896909
    },
    {
        "content": "<p>By the way, it seems like in Coq there's a some kind of rewriting tactic for equivalences which simplifies proofs quite a bit.</p>",
        "id": 505517358,
        "sender_full_name": "suhr",
        "timestamp": 1741897012
    },
    {
        "content": "<p>iris-lean has a <code>rw'</code> tactic which you can use, although I prefer to avoid it most of the time</p>",
        "id": 505533009,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741902786
    },
    {
        "content": "<p>I think that theorem <code>Some_equiv_eq</code> is saying that the <code>≡</code> relation on option is the same as <code>=</code> when one side is a <code>Some</code></p>",
        "id": 505533290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741902905
    },
    {
        "content": "<p>because keep in mind that this <code>≡</code> relation is not the one on the cmra, it's a lifted version of it operating on options</p>",
        "id": 505533364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741902941
    },
    {
        "content": "<p>I think in lean this proof would look something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">cmra_pcore_l'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pcore</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"n\">Some</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"w\"> </span><span class=\"bp\">⋅</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">cmra_pcore_l</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Some_equiv_eq</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which is why I wouldn't bother with <code>rw'</code> for this</p>",
        "id": 505533637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741903064
    },
    {
        "content": "<p>it's not even clear whether this theorem is really needed, the two are probably defeq</p>",
        "id": 505533760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741903112
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Next.20steps/near/505533364\">said</a>:</p>\n<blockquote>\n<p>because keep in mind that this <code>≡</code> relation is not the one on the cmra, it's a lifted version of it operating on options</p>\n</blockquote>\n<p>I see, thanks.</p>",
        "id": 505541633,
        "sender_full_name": "suhr",
        "timestamp": 1741906811
    },
    {
        "content": "<p>Lemma <code>cmra_pcore_idemp'</code> is more tricky than I expected, I don't quite see how to prove it.</p>",
        "id": 505629421,
        "sender_full_name": "suhr",
        "timestamp": 1741945901
    },
    {
        "content": "<p>If <code>pcore ≡ some cx</code>, then that means <code>pcore = some cx'</code> for some <code>cx' ≡ cx</code>. Then <code>pcore cx ≡ pcore cx'</code> because pcore is nonexpansive, and <code>pcore cx' ≡ some cx'</code> from <code>pcore_idem</code>, so <code>pcore cx ≡ some cx</code> by transitivity</p>",
        "id": 505650697,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741951946
    },
    {
        "content": "<p>This requires proving a different tricky lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">pcore_ne_equiv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">cmr</span><span class=\"bp\">.</span><span class=\"n\">pcore</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">cy</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">cmr</span><span class=\"bp\">.</span><span class=\"n\">pcore</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">cy</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"w\"> </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"n\">cy</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Because <code>CRMA.pcore_ne</code> has the following type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">pcore_ne</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≡</span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">pcore</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">cy</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pcore</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">cy</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"w\"> </span><span class=\"bp\">≡</span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"n\">cy</span>\n</code></pre></div>\n<p>So one needs to somehow convert <code>≡{n}≡</code> into <code>≡</code>.</p>",
        "id": 505660359,
        "sender_full_name": "suhr",
        "timestamp": 1741954799
    },
    {
        "content": "<p>Anyway, in <a href=\"https://github.com/leanprover-community/iris-lean/pull/14\">https://github.com/leanprover-community/iris-lean/pull/14</a> I proved almost all lemmas I was going to prove except for three tricky ones. There's so much more to port from Coq, but I already did a dangerous amount of procrastination.</p>\n<p>Coq naming is a mess, I hope you figure out better names for all these lemmas.</p>",
        "id": 505684796,
        "sender_full_name": "suhr",
        "timestamp": 1741961345
    },
    {
        "content": "<p>Unlike Coq proofs, Coq proof terms are somewhat readable. So maybe I will figure out proofs for other lemmas.</p>",
        "id": 505895137,
        "sender_full_name": "suhr",
        "timestamp": 1742080842
    },
    {
        "content": "<p>Thinking a bit ahead: which Lean types should be used for <code>gset</code>, <code>gmap</code> and <code>gmultiset</code> from Coq's stdpp?</p>",
        "id": 505953548,
        "sender_full_name": "suhr",
        "timestamp": 1742128811
    },
    {
        "content": "<p>Why not use mathlib's existing <code>Finset</code> and <code>Multiset</code> APIs? And for efficiency there's also <code>Std.HashMap</code></p>",
        "id": 505962877,
        "sender_full_name": "Quang Dao",
        "timestamp": 1742135567
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Next.20steps/near/505895137\">said</a>:</p>\n<blockquote>\n<p>Unlike Coq proofs, Coq proof terms are somewhat readable. So maybe I will figure out proofs for other lemmas.</p>\n</blockquote>\n<p>FYI one big source of difficulty when porting is that Rocq has generalized rewriting and Lean doesn't (yet). So if you see a rewrite or apply that doesn't seem to make sense, it's possible that Rocq is applying some lemmas under the hood.</p>",
        "id": 505963183,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1742135812
    },
    {
        "content": "<p>I think in this part of the development these are typically <code>Proper</code> instances. For now, we need to do all of this by hand.</p>",
        "id": 505963242,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1742135881
    },
    {
        "content": "<p>I'm not sure why Iris uses <code>gset</code>/<code>gmap</code> for the ghost resources, I agree with Quang that we should use the regular finite set/map API's for this before overcomplicating our lives. If they're just resources, efficiency doesn't matter.</p>",
        "id": 505963476,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1742136061
    },
    {
        "content": "<p>This means adding mathlib since finsets are in mathlib afaik</p>",
        "id": 506124370,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1742211485
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset#doc\">docs#Finset</a></p>",
        "id": 506124407,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1742211496
    },
    {
        "content": "<p>In the other thread the discussion seems to be tending against adding mathlib</p>",
        "id": 506124677,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1742211571
    },
    {
        "content": "<p>Ah okay--it's probably not that hard to write our own interface for finsets and finmaps anyways (it would be nice to have the ghost constructions support mathlib types by instantiating a typeclass; all of the projects I have in mind personally involve mathlib heavily). As long as we avoid reimplementing gmap and gset I'm happy.</p>",
        "id": 506138634,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1742215004
    },
    {
        "content": "<p>Tbh I would like to see a computationally easier to use fin map like coq</p>",
        "id": 506145697,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1742216685
    },
    {
        "content": "<p>It was easier to toy around with than mathlib’s finmap last year</p>",
        "id": 506145976,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1742216758
    },
    {
        "content": "<p>By the way, my pull request is complete (no <code>sorry</code>ies) and ready for a review.</p>",
        "id": 506230773,
        "sender_full_name": "suhr",
        "timestamp": 1742236047
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"721721\">Markus de Medeiros</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Next.20steps/near/505963183\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Next.20steps/near/505895137\">said</a>:</p>\n<blockquote>\n<p>Unlike Coq proofs, Coq proof terms are somewhat readable. So maybe I will figure out proofs for other lemmas.</p>\n</blockquote>\n<p>FYI one big source of difficulty when porting is that Rocq has generalized rewriting and Lean doesn't (yet). So if you see a rewrite or apply that doesn't seem to make sense, it's possible that Rocq is applying some lemmas under the hood.</p>\n</blockquote>\n<p>you might already be aware, but just in case, there are some efforts to port Rocq's generalized rewriting, see this thread: <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/Rewriting.20congruent.20relations/with/302284881\">#lean4 &gt; Rewriting congruent relations</a></p>",
        "id": 506538789,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1742318743
    },
    {
        "content": "<p>Ah yes--Leo Stefanesco <a href=\"https://github.com/ineol/iris-lean/blob/grw-tests/src/Iris/Algebra/CMRA.lean\">did try it out</a> a couple weeks ago</p>",
        "id": 506783154,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1742403499
    },
    {
        "content": "<p>While generalized rewriting would be very nice to have, I'm not sure if it's such a big deal. One can always dance with <code>calc</code> like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mono</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"n\">y1</span><span class=\"w\"> </span><span class=\"n\">y2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">≼</span><span class=\"w\"> </span><span class=\"n\">y1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">≼</span><span class=\"w\"> </span><span class=\"n\">y2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">≼</span><span class=\"w\"> </span><span class=\"n\">y1</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">y2</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"bp\">λ</span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hw</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"bp\">;</span><span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ht</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">l2</span>\n<span class=\"w\">      </span><span class=\"n\">suffices</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y1</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">y2</span><span class=\"w\"> </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span>\n<span class=\"w\">      </span><span class=\"k\">calc</span>\n<span class=\"w\">        </span><span class=\"n\">y1</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">y2</span><span class=\"w\"> </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">y2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">op_left_equiv</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hw</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\">       </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">op_right_equiv</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">ht</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\">       </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cmr</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\">       </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">op_right_equiv</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cmr</span><span class=\"bp\">.</span><span class=\"n\">comm</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\">       </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cmr</span><span class=\"bp\">.</span><span class=\"n\">assoc</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\">       </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">op_left_equiv</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">cmr</span><span class=\"bp\">.</span><span class=\"n\">assoc</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\">       </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cmr</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\">       </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">op_right_equiv</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cmr</span><span class=\"bp\">.</span><span class=\"n\">comm</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The difficult part for me was the case where you seem to need <code>=</code>, but you only have <code>≡</code>, so you need to play with lemmas that give you some kind of existence from which you can finally get what you need. Compared with that, chaining a few <code>≡</code> is not a big deal.</p>\n<p>Hopefully, with enough lemmas having too many kinds of equality stops being painful.</p>",
        "id": 506827454,
        "sender_full_name": "suhr",
        "timestamp": 1742418115
    },
    {
        "content": "<p>In draft PR <a href=\"https://github.com/leanprover-community/iris-lean/pull/21\">iris-lean#21</a> I wrote stubs for everything in the first half of <code>CMRA.v</code> (building on top of the great work <span class=\"user-mention\" data-user-id=\"394485\">@suhr</span> did of course!)</p>\n<p>There are 70 sorry's and many of them are very easy, if you're thinking of contributing this would be a good way to get your feet wet!</p>",
        "id": 509049508,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1743356472
    },
    {
        "content": "<p>Check it out y'all: an Iris proof that everybody agrees that iris-lean is great :) </p>\n<p><a href=\"/user_uploads/3121/3nCf8dn3akz1-H1QN5Rdq2da/Screenshot-2025-04-13-at-5.20.41PM.png\">Screenshot 2025-04-13 at 5.20.41 PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/3nCf8dn3akz1-H1QN5Rdq2da/Screenshot-2025-04-13-at-5.20.41PM.png\" title=\"Screenshot 2025-04-13 at 5.20.41 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1908x1524\" src=\"/user_uploads/thumbnail/3121/3nCf8dn3akz1-H1QN5Rdq2da/Screenshot-2025-04-13-at-5.20.41PM.png/840x560.webp\"></a></div><p>The <code>iProp</code> PR is pretty sizable, but after it's done being reviewed and merged, there's going to be a lot of new opportunities for things to work on. In particular, finishing <code>iProp</code> meant getting the rest of the core definitions in <code>Algebra</code> right, so I think a lot of that folder could be ported independently now. I will post another list of independent jobs soon. </p>\n<p>We're not quite at the point where we can comfortably work inside the base logic yet, I think that's the  next big milestone. This involves mechanizing updates, refining the tactic suite (imod, iapply...), and refining the way we construct <code>gFunctors</code> (which above is done by hand and is very nasty). If anyone has a burning desire to take ownership of any of these, do let me know!</p>",
        "id": 511945847,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1744581108
    },
    {
        "content": "<p>I wonder if it's possible to make some kind of term syntax for iris-lean. I like my <code>λh ↦ ...</code>, it would be nice to have something similar in iris proofs.</p>",
        "id": 511948221,
        "sender_full_name": "suhr",
        "timestamp": 1744583077
    },
    {
        "content": "<p>Ah that's quite an interesting thought!</p>",
        "id": 511948725,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1744583521
    },
    {
        "content": "<p>I just pushed a bunch of cleanup and golf stuff. The PR is too big to merge in one go, I suggest you break it up into pieces roughly along file boundaries</p>",
        "id": 511950598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744584893
    },
    {
        "content": "<p>Sounds good, I'll look it over with some fresh eyes tomorrow</p>",
        "id": 511951752,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1744585732
    }
]