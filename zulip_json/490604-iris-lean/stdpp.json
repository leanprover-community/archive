[
    {
        "content": "<p>What is the plan for porting the relevant parts of stdpp?<br>\nI understand it will depend on batteries, but not cslib. Does that seem correct?</p>",
        "id": 561145045,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1764592144
    },
    {
        "content": "<p>There is currently no plan to port stdpp, we will evaluate what we need from stdpp on a case-by-case basis. For example, we did not port the <code>gmap</code> CMRA, we developed a CMRA for generic maps instead.  </p>\n<p>Iris-Lean does depend on batters but not cslib, yes. I can imagine writing a program logic for cslib languages at some point, but as of now I don't think that justifies another dependency.</p>",
        "id": 561146188,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1764592452
    },
    {
        "content": "<p>So, you would expect cslib to make some duplication of the lean-iris-stdpp.</p>",
        "id": 561147114,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1764592677
    },
    {
        "content": "<p>I'd like to avoid it if possible. As it stands it looks like there isn't much duplication in \"core Iris\". If down the road there is more substantial duplications, then we could either try to move it upstream to batteries (our common dependency) or downstream to an iris-lean-cslib.</p>",
        "id": 561148259,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1764592975
    },
    {
        "content": "<p>The latter is the plan for Iris+mathlib stuff.</p>",
        "id": 561148343,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1764593000
    },
    {
        "content": "<p>Note that batteries is intended to morally serve the same role as  stdpp</p>",
        "id": 561151848,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764593971
    },
    {
        "content": "<p>So the right place to port something from stdpp is directly to batteries, after checking that the corresponding material doesn't already exist in some <code>Data</code> folder of mathlib. EDIT : or in the <code>Lean</code>/<code>Std</code> namespace of the main lean4 repository.</p>",
        "id": 561151998,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764594010
    },
    {
        "content": "<p>Cslib is not playing quite the same role as stdpp. It's largely formalising CS curriculum stuff. It sits downstream of mathlib.</p>",
        "id": 561152322,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764594093
    },
    {
        "content": "<p>Is there a conclusion on what the correspondence of stdpp <code>gmap</code> is in Lean? I plan to port <code>big_op</code>s for maps, and am still not quite sure what I should use. Should I use the generic map API or a concrete map implementation?</p>",
        "id": 563462018,
        "sender_full_name": "Zongyuan Liu",
        "timestamp": 1765542297
    },
    {
        "content": "<p>Unless you really need something specific about gmaps, you should try to generalize the constructions to use the generic API.</p>",
        "id": 563463370,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765542777
    },
    {
        "content": "<p>I've been wondering about this question as well. My understanding is that <a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Data/ExtTreeMap/Basic.html#Std.ExtTreeMap\">ExtTreeMap</a> is the closest analogue to gmap.<br>\nIs <a href=\"https://github.com/leanprover-community/iris-lean/blob/c9d7a7519cd51b0b594169b6edf682d2c15b2a02/src/Iris/Std/Heap.lean\">this</a> the generic map  API that you are referring to? At the moment this interface looks very minimal. Is it intended to be the equivalent of the <code>FinMap</code> interface of std++? (Note that there is <a href=\"https://gitlab.mpi-sws.org/iris/stdpp/-/issues/156\">discussion</a> to get rid of FinMap in std++ since basically everyone uses gmap directly.)</p>",
        "id": 563551375,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1765569413
    },
    {
        "content": "<p>I think it is good to use an interface (like the heap API you linked) rather than a specific type (like ExtTreeMap) wherever possible. In my work I have run into situations where the restrictions on <code>gmap</code> have been too restrictive (a countable type of keys, and having only finitely many elements allocated at once) and as a consequence I've had to redevelop all the theory on top of gmaps to use a different data structure. </p>\n<p>The API is indeed relatively close to FinMap.</p>",
        "id": 563553708,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765570265
    },
    {
        "content": "<p>I actually prefer removing this layer of abstraction and just using the closest thing to <code>gmap</code>.  A concrete map with a rich API simplifies and speeds up porting.  IMHO, catching up with Iris-Rocq is more important at this project stage.</p>",
        "id": 563555324,
        "sender_full_name": "Zongyuan Liu",
        "timestamp": 1765571040
    },
    {
        "content": "<p>Do you have an example of somewhere that gmap is easier than using generic API? My experience with the heap_view CMRA is exactly the opposite</p>",
        "id": 563555611,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765571156
    },
    {
        "content": "<p>In Iris-Rocq they do some strange proofs by induction over the number of allocated keys in a gmap. I suspect that this is to avoid classical logic, so we could technically avoid this with gmaps as well, but I also haven't encountered a case where using a concrete type instead would give any benefit</p>",
        "id": 563555824,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765571258
    },
    {
        "content": "<p>I think the main benefit of using an existing definition is that one does not need to duplicate / reprove the API. For example, a quick look at the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Data/ExtTreeMap/Lemmas.html\">lemmas of ExtTreeMap</a> suggests that there are around ~700 theorems that one would want to / need to duplicate. (The Std lib seems to indeed duplicate all these lemmas for the 4+ different maps using a process I do not understand.)</p>",
        "id": 563557763,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1765572066
    },
    {
        "content": "<p>I could get behind that! I did not know much about Std.ExtTreeMap but the restrictions on the type seem pretty liberal which is good.</p>",
        "id": 563559113,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765572701
    },
    {
        "content": "<p>Do these tree maps have an analogue of \"allocation\" for maps with infinitely many unallocated values? I don't see any such thing.</p>",
        "id": 563559249,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765572758
    },
    {
        "content": "<p>Ah, I see there are a number of lemmas for finding keys of a certain size <a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Data/ExtTreeMap/Basic.html#Std.ExtTreeMap.maxKey\">Std.ExtTreeMap.maxKey</a> and this <a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Data/ExtTreeMap/Basic.html#Std.ExtTreeMap.filterMap\">Std.ExtTreeMap.filterMap</a> which I think is enough to simulate it. </p>\n<p>I'd guess that the Ordering field is always able to be trivially instantiated, so I think the only way this is less general than the one we've implemented is about the universe levels of <code>Ext(D)TreeMap</code> with respect to the keys and values. But somehow I doubt this is a problem. I can give porting the old stuff to the Std maps a try sometime.</p>",
        "id": 563561115,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765573561
    },
    {
        "content": "<p>Indeed, I think giving Ext(D)TreeMap a try sounds like the best option to find out how well it works. If someone has experience with the different map types and their advantages and disadvantages, please chime in! I would be interested.</p>",
        "id": 563561539,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1765573758
    },
    {
        "content": "<p>Ah--If I'm understanding the code correctly, Ext(D)TreeMaps can only represent maps that have a finite number of allocated elements. For example, I don't believe that there is a way to represent a heap with keys in the natural numbers that has every odd element allocated. Even if this sounds silly, this kind of thing is done in probability (splitting sources of randomness, for example) and I think it's important that we keep the library of Iris CMRA's as generalized as we reasonably can.</p>",
        "id": 563927267,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765833738
    },
    {
        "content": "<p>That said, the abstract heap interface only needs to be rich enough for internal clients, for example <code>HeapView</code> (already completed). I've added an issue <a href=\"https://github.com/leanprover-community/iris-lean/pull/105\">iris-lean#105</a> to instantiate this interface with the Lean map types, so that external clients are free to use maps that have a more well-developed API if they want to do so. I also think we could use the Lean map types for IProp without any real loss of generality, and I agree with Zongyuan in this case that using a type closer to <code>gmap</code> could make the port go faster, so we should do it!</p>",
        "id": 563927274,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765833741
    },
    {
        "content": "<blockquote>\n<p>For example, I don't believe that there is a way to represent a heap with keys in the natural numbers that has every odd element allocated.</p>\n</blockquote>\n<p>Does this imply a need for a generic interface based <code>big_sepM</code> for your heap points-tos?  However, <code>big_op</code> for maps requires a rich API for the lemmas on its various operations.</p>",
        "id": 563939067,
        "sender_full_name": "Zongyuan Liu",
        "timestamp": 1765838709
    },
    {
        "content": "<p>Is there anything stopping us from having a generic interface? Big ops are just folds over finite data structures, whether you're folding to construct terms in the heap API or a concrete implementation seems immaterial. </p>\n<p>I browsed <code>big_ops.v</code> and nothing  jumped out to me as being missing, but I think you are more familiar than I am. Do you have examples of where using a specific map type would help?</p>",
        "id": 563939855,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765839252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"721721\">Markus de Medeiros</span> <a href=\"#narrow/channel/490604-iris-lean/topic/stdpp/near/563927267\">said</a>:</p>\n<blockquote>\n<p>Ah--If I'm understanding the code correctly, Ext(D)TreeMaps can only represent maps that have a finite number of allocated elements. For example, I don't believe that there is a way to represent a heap with keys in the natural numbers that has every odd element allocated. Even if this sounds silly, this kind of thing is done in probability (splitting sources of randomness, for example) and I think it's important that we keep the library of Iris CMRA's as generalized as we reasonably can.</p>\n</blockquote>\n<p>How would you do this in Rocq? There also gmap also only represents finite maps. E.g. the ghost_map constructions are specific to gmap and cannot represent infinite maps. For me this has never been a problem, but I also never did any probablistic verification.</p>",
        "id": 563985308,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1765873355
    },
    {
        "content": "<p>Yeah that's my problem exactly--I couldn't, without rewriting parts of the core Iris libraries.</p>",
        "id": 564013990,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765882753
    },
    {
        "content": "<p>Even though, mathematically, something like ghost map does (did) easily generalize beyond gmap.</p>",
        "id": 564014507,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1765882908
    },
    {
        "content": "<p>I see, then it probably makes sense to define ghost_map over the generic interface as you already did. But I guess one would only use this interface if one actually needs this generality. For a concrete heap of like heaplang, one can still use ExtTreeMap and then just use the fact that it implements the generic interface. This means that the generic interface does not provide the full API of ExtTreeMap, but only what is necessary for ghost_map (which is hopefully a lot less).</p>",
        "id": 564051492,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1765894353
    },
    {
        "content": "<p>Excuse me, I want to use an extensional finite map inside an inductive definition. I am not sure which one to use. It seems I cannot use <code>Std.Ext(D)TreeMap</code>?</p>",
        "id": 565085703,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1766450112
    },
    {
        "content": "<p>In Rocq, I would simply use <code>gmap</code>.</p>",
        "id": 565085745,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1766450178
    },
    {
        "content": "<p>I tried the following but get error \"application type mismatch\"</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">vl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">vl</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtTreeMap</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">vl</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">vl</span>\n</code></pre></div>",
        "id": 565085805,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1766450289
    },
    {
        "content": "<p>Interesting, when I use an association list <code>List (String × vl)</code> (which satisfies the abstract heap interface) it works. It also works for </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">FiniteDomFunction</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FiniteDomFunction</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FiniteDomFunction</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FiniteDomFunction</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">remove</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FiniteDomFunction</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FiniteDomFunction</span><span class=\"w\"> </span><span class=\"n\">V</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">vl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">vl</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FiniteDomFunction</span><span class=\"w\"> </span><span class=\"n\">vl</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">vl</span>\n</code></pre></div>\n<p>which I have proven satisfies the abstract heaps interface in <a href=\"https://github.com/leanprover-community/iris-lean/pull/89\">iris-lean#89</a>. Thanks for pointing this out, sticking to the abstract heaps interface for the library seems to be a good idea.</p>",
        "id": 565196520,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1766513654
    },
    {
        "content": "<p>If anyone understand the error in Ka Wing Lei's code I'd be curious to hear an explanation, it seems like something odd with the quotient in ExtTreeMap.</p>",
        "id": 565196597,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1766513718
    },
    {
        "content": "<p><code>ExtTreeMap</code> can indeed not be used with nested inductive definitions. The doc string recommends to use <code>TreeMap.Raw</code> instead. See <a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Data/ExtTreeMap/Basic.html#Std.ExtTreeMap\">here</a></p>\n<blockquote>\n<p>These tree maps contain a bundled well-formedness invariant, which means that they cannot be used in nested inductive types. For these use cases, <code>Std.TreeMap.Raw</code> and <code>Std.TreeMap.Raw.WF</code> unbundle the invariant from the tree map.</p>\n</blockquote>",
        "id": 565662827,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1767011822
    },
    {
        "content": "<p>Hi, I tried to port some of the big op stuff for lists, maps, and sets in my branch <a href=\"https://github.com/lzy0505/iris-lean/tree/big_op_map/set\">https://github.com/lzy0505/iris-lean/tree/big_op_map/set</a> (using Claude’s help). To avoid using concrete map and set implementations, I defined abstract interfaces in Std/FiniteMap.lean and Std/FiniteSet.lean. These interfaces are quite complex. Are they even close to what we want?</p>",
        "id": 566939925,
        "sender_full_name": "Zongyuan Liu",
        "timestamp": 1767878440
    },
    {
        "content": "<p>Interesting... thanks for trying! Yes I agree that this interface is quite complicated. Since you're just defining a finite set as being in correspondence to a list, do you think the interface could be simplified (ie. define the basic operations in terms of the mapping into lists, so that an instance just has to provide this mapping?)</p>",
        "id": 566952061,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1767881751
    },
    {
        "content": "<p>To put some concrete terms: I feel like we should be able to do a big separating conjunction over at least lists and a mathlib <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finset/Basic.html\">finset</a>.</p>",
        "id": 566952271,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1767881813
    },
    {
        "content": "<p>Just at a glance, the Iris part of this looks great :)</p>",
        "id": 566952915,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1767881962
    },
    {
        "content": "<p>I would taking Mathlib's approach and just defining </p>\n<ol>\n<li><code>Set A</code> as <code>A -&gt; Prop</code></li>\n<li>Finite sets as below</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">FiniteSet</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">      </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">      </span><span class=\"n\">fin</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>",
        "id": 566954578,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767882360
    },
    {
        "content": "<p>I regularly use Finsets and they are a royal pain</p>",
        "id": 566954797,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767882410
    },
    {
        "content": "<p>You might also have to define <code>\\equiv</code> but you can see mathlib's version</p>",
        "id": 566954987,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767882448
    },
    {
        "content": "<p>See : <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finite/Defs.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finite/Defs.html</a></p>",
        "id": 566955140,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767882496
    },
    {
        "content": "<p>and equiv is here : <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Logic/Equiv/Defs.html#Equiv\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Logic/Equiv/Defs.html#Equiv</a></p>",
        "id": 566955257,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767882532
    },
    {
        "content": "<p>This is not an interface, and it confers no advantages over what Zongyuan has already implemented tbh. </p>\n<blockquote>\n<p>I regularly use Finsets and they are a royal pain</p>\n</blockquote>\n<p>You don't have to use Finsets if you don't want to. But as an example, if I want to define resources associated to network packets by taking a separating conjunction over <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/SimpleGraph/Basic.html#SimpleGraph.edgeFinset\">SimpleGraph.edgeFinset</a> then yes, it would be nice to be able to instantiate big ops with a finset.</p>",
        "id": 566958452,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1767883291
    },
    {
        "content": "<p>You can use the separating conjunction on the map you get from the Finite typeclass (<code>Fin n -&gt; set</code>)</p>",
        "id": 566959712,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767883586
    },
    {
        "content": "<p>you simply mark <code>SimpleGraph.edgeSet</code> with <code>Finite</code> (the typeclass in mathlib or from your interface definition)</p>",
        "id": 566959789,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767883603
    },
    {
        "content": "<p>Trust me, you don't want to go down the Finset route for this. It is a road filled with pain.</p>",
        "id": 566959863,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767883623
    },
    {
        "content": "<p>also you can always make it an interface with minor changes</p>",
        "id": 566959957,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767883646
    },
    {
        "content": "<p>To be clear, I think bikeshedding over which definition of finite to take as canonical is kind of pointless since they're all equivalent. Zongyuan: thanks for trying to write this interface--I trust your judgement on what the best implementation would look like. As long as it's not too hard to take some random finite data structure and do a big conjunction over it, I think that's good enough for iris-lean :)</p>",
        "id": 566964104,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1767884611
    },
    {
        "content": "<p>Thanks for the feedback! I will see if I can simplify the interface, and instantiate the interface with some data structures to test it.</p>",
        "id": 566965617,
        "sender_full_name": "Zongyuan Liu",
        "timestamp": 1767884931
    },
    {
        "content": "<p>Okay fair, but you should know this is a topic that comes up now and then. These definitions are very different under the hood and it makes a difference when writing API for them and using them.</p>\n<p>Also Zongyuan thanks for this work :)</p>",
        "id": 566965626,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767884932
    },
    {
        "content": "<p>Thanks for exploring this, Zongyuan! It seems like you ported a lot of lemmas. How complete is the port of the lemmas? Are all bigop lemmas from Rocq Iris there or are some missing? </p>\n<p>I also looked at the FiniteMap interface <a href=\"https://github.com/lzy0505/iris-lean/blob/2749f0f5251cc413cc7e2d32f9a88d57f96bf049/src/Iris/Std/FiniteMap.lean\">here</a> and I am not sure about the motivation for it instead of using a concrete map (e.g. <code>ExtTreeMap</code>). <a href=\"#narrow/channel/490604-iris-lean/topic/stdpp/near/563927267\">Previously</a>, Markus made a good point that there are cases where one wants to have non-finite maps, but these maps would not satisfy the FiniteMap interface since they are non-finite (and bigops crucially rely on finiteness).<br>\nWhich instantiations for the FiniteMap interface do you have in mind?</p>",
        "id": 567092950,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1767948085
    },
    {
        "content": "<blockquote>\n<p>How complete is the port of the lemmas? Are all bigop lemmas from Rocq Iris there or are some missing?</p>\n</blockquote>\n<p>My goal was to port as many lemmas in Rocq's <a href=\"https://gitlab.mpi-sws.org/iris/iris/-/blob/master/iris/bi/big_op.v?ref_type=heads\">big_op.v</a> as possible. So far, I have ported most of the lemmas (~90%) on <code>big_[and/or/sep]L</code>, <code>big_sepL2</code>, <code>big_[sep/and]M</code>, and <code>big_sepS</code>. The remaining ones are mostly blocked by missing BI definitions and laws. All results on <code>big_sepM2</code>, <code>big_sepMS</code> are missing at the moment.</p>\n<blockquote>\n<p>I also looked at the FiniteMap interface <a href=\"https://github.com/lzy0505/iris-lean/blob/2749f0f5251cc413cc7e2d32f9a88d57f96bf049/src/Iris/Std/FiniteMap.lean\">here</a> and I am not sure about the motivation for it instead of using a concrete map (e.g. <code>ExtTreeMap</code>).</p>\n</blockquote>\n<p><a href=\"#narrow/channel/490604-iris-lean/topic/stdpp/near/563939855\">Seemed like</a> Markus wanted to use a generic interface for big ops, so I tried it. I was mostly following stdpp's <code>fin_map.v</code>. If we now all agree that the interface is too complex, I'm happy to switch to <code>ExtTreeMap</code>.</p>",
        "id": 567101667,
        "sender_full_name": "Zongyuan Liu",
        "timestamp": 1767951437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"883069\">Zongyuan Liu</span> <a href=\"#narrow/channel/490604-iris-lean/topic/stdpp/near/567101667\">said</a>:</p>\n<blockquote>\n<p>My goal was to port as many lemmas in Rocq's <a href=\"https://gitlab.mpi-sws.org/iris/iris/-/blob/master/iris/bi/big_op.v?ref_type=heads\">big_op.v</a> as possible. So far, I have ported most of the lemmas (~90%) on <code>big_[and/or/sep]L</code>, <code>big_sepL2</code>, <code>big_[sep/and]M</code>, and <code>big_sepS</code>.</p>\n</blockquote>\n<p>Very nice!</p>\n<p><span class=\"user-mention silent\" data-user-id=\"883069\">Zongyuan Liu</span> <a href=\"#narrow/channel/490604-iris-lean/topic/stdpp/near/567101667\">said</a>:</p>\n<blockquote>\n<p><a href=\"#narrow/channel/490604-iris-lean/topic/stdpp/near/563939855\">Seemed like</a> Markus wanted to use a generic interface for big ops, so I tried it. I was mostly following stdpp's <code>fin_map.v</code>. If we now all agree that the interface is too complex, I'm happy to switch to <code>ExtTreeMap</code>.</p>\n</blockquote>\n<p>That makes sense. I am not sure what the best approach is. I guess this heavily depends on whether in practice one will use always a single map type (e.g. <code>ExtTreeMap</code>) or a bunch of different maps (<code>ExtTreeMap</code>, <code>ExtDTreeMap</code>, <code>ExtHashMap</code>, <code>ExtDHashMap</code>). I don't have a good feeling for this.</p>\n<p>Your interface currently forces the map to non-dependent. How hard do you think it would be to to support the type of values to depend on the type of keys? (I.e. modeling <code>ExtDTreeMap</code> instead of <code>ExtTreeMap</code>)</p>",
        "id": 567104247,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1767952315
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"883069\">Zongyuan Liu</span> <a href=\"#narrow/channel/490604-iris-lean/topic/stdpp/near/567101667\">said</a>:</p>\n<blockquote>\n<p><a href=\"#narrow/channel/490604-iris-lean/topic/stdpp/near/563939855\">Seemed like</a> Markus wanted to use a generic interface for big ops, so I tried it. I was mostly following stdpp's <code>fin_map.v</code>. If we now all agree that the interface is too complex, I'm happy to switch to <code>ExtTreeMap</code>.</p>\n</blockquote>\n<p>Yep, thanks again for trying this but I'm convinced now that's there's no advantage to this for big ops!</p>",
        "id": 567118642,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1767956954
    },
    {
        "content": "<p><code>ExtTreeMap</code>and related kv map  may not be the best idea. I wish we can have something like <a href=\"https://plv.mpi-sws.org/coqdoc/stdpp/stdpp.gmap.html\">gmap</a>. Unless a dependent KV map is required.</p>",
        "id": 567296890,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1768025398
    },
    {
        "content": "<p>Good job for the finmap interface btw.</p>",
        "id": 567297018,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1768025589
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"939203\">Ka Wing Li</span> <a href=\"#narrow/channel/490604-iris-lean/topic/stdpp/near/567296890\">said</a>:</p>\n<blockquote>\n<p><code>ExtTreeMap</code>and related kv map may not be the best idea</p>\n</blockquote>\n<p>Can you be more specific why?</p>",
        "id": 567409382,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1768157592
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"939203\">Ka Wing Li</span> <a href=\"#narrow/channel/490604-iris-lean/topic/stdpp/near/565085703\">said</a>:</p>\n<blockquote>\n<p>Excuse me, I want to use an extensional finite map inside an inductive definition. I am not sure which one to use. It seems I cannot use <code>Std.Ext(D)TreeMap</code>?</p>\n</blockquote>\n<p>In case one want to use the kv map in some inductive definition.</p>",
        "id": 567524153,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1768222428
    },
    {
        "content": "<p>I simplified the <code>FiniteMap</code> interface dramatically and instantiated it with <code>ExtTreeMap</code>. I didn't just replace it with <code>ExtTreeMap</code> because the behaviours of some operations of <code>ExtTreeMap</code> are not aligned with <code>gmap</code>, so I think <code>FiniteMap</code> as a wrapper is necessary. </p>\n<p>See the new <code>FiniteMap</code> in this <a href=\"https://github.com/leanprover-community/iris-lean/pull/113/changes#diff-07ea251d744cbb49bc68f14b2cc54238cedb9c5e2dcdadff290dcc5837454f05\">draft PR</a></p>",
        "id": 567631048,
        "sender_full_name": "Zongyuan Liu",
        "timestamp": 1768247619
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574718\">Michael Sammler</span> <a href=\"#narrow/channel/490604-iris-lean/topic/stdpp/near/567104247\">said</a>:</p>\n<blockquote>\n<p>How hard do you think it would be to to support the type of values to depend on the type of keys?</p>\n</blockquote>\n<p>I think it is possible to do it now</p>",
        "id": 567631781,
        "sender_full_name": "Zongyuan Liu",
        "timestamp": 1768247878
    },
    {
        "content": "<p>What is the equivalence of <code>base.v</code> in <code>Iris.Std</code>? In particular, I was looking at <span class=\"user-mention\" data-user-id=\"883069\">@Zongyuan Liu</span> <a href=\"https://github.com/leanprover-community/iris-lean/pull/113\">https://github.com/leanprover-community/iris-lean/pull/113</a> and was trying to use some axioms like:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Class</span> <span class=\"n\">SemiSet</span> <span class=\"n\">A</span> <span class=\"n\">C</span> <span class=\"o\">`{</span><span class=\"n\">ElemOf</span> <span class=\"n\">A</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n    <span class=\"n\">Empty</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">Singleton</span> <span class=\"n\">A</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">Union</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">not_elem_of_empty</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span><span class=\"o\">@{</span><span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"bp\">∅</span><span class=\"o\">;</span> <span class=\"c\">(* We prove</span>\n<span class=\"c\">  [elem_of_empty : x ∈@{C} ∅ ↔ False] in [sets.v], which is more convenient for</span>\n<span class=\"c\">  rewriting. *)</span>\n  <span class=\"n\">elem_of_singleton</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span><span class=\"o\">@{</span><span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{[</span> <span class=\"n\">y</span> <span class=\"o\">]}</span> <span class=\"o\">↔</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n  <span class=\"n\">elem_of_union</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"n\">Y</span> <span class=\"o\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">X</span> <span class=\"o\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Y</span>\n<span class=\"o\">}.</span>\n</code></pre></div>",
        "id": 569963150,
        "sender_full_name": "Alex Bai",
        "timestamp": 1769356765
    },
    {
        "content": "<p>I don’t believe it exists, and I don’t think we should port the entire file. I’ve only ported the minimum I need for the draft PR. What do you need from the file?</p>",
        "id": 569977603,
        "sender_full_name": "Zongyuan Liu",
        "timestamp": 1769370091
    },
    {
        "content": "<p>I wanted to use this version of <a href=\"https://gitlab.mpi-sws.org/iris/stdpp/-/blob/master/stdpp/fin_map_dom.v?ref_type=heads#L103\"><code>dom_insert</code></a> that's in stdpp, which uses <code>elem_of_union</code> that comes from the SemiSet axiomatization</p>",
        "id": 569980999,
        "sender_full_name": "Alex Bai",
        "timestamp": 1769373515
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"707238\">Alex Bai</span> <a href=\"#narrow/channel/490604-iris-lean/topic/stdpp/near/569980999\">said</a>:</p>\n<blockquote>\n<p>I wanted to use this version of <a href=\"https://gitlab.mpi-sws.org/iris/stdpp/-/blob/master/stdpp/fin_map_dom.v?ref_type=heads#L103\"><code>dom_insert</code></a> that's in stdpp, which uses <code>elem_of_union</code> that comes from the SemiSet axiomatization</p>\n</blockquote>\n<p>The <code>elem_of_union</code> is available at <a href=\"https://github.com/leanprover-community/iris-lean/pull/113/changes#diff-093a641124fa1dc70725f4e2829fdcb337bd27cb1d631f1abba016f8368e6e33R348\">https://github.com/leanprover-community/iris-lean/pull/113/changes#diff-093a641124fa1dc70725f4e2829fdcb337bd27cb1d631f1abba016f8368e6e33R348</a>. If your work is blocked by many missing set lemmas, I can try to create a separate PR for just <code>FiniteSet</code> and <code>FiniteMap</code>. This way they can be reviewed and merged first. Alternatively, if you only require a few set axioms, you can simply try using a set implementation for now.</p>",
        "id": 569982717,
        "sender_full_name": "Zongyuan Liu",
        "timestamp": 1769375361
    },
    {
        "content": "<p>If you break up the PR into smaller chunks, ideally with some that are ready to review, I could start reviewing stuff tomorrow</p>",
        "id": 569982881,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1769375502
    },
    {
        "content": "<p>Another thing that I want from <code>base.v</code> is leibniz equality:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"c\">(** The type class [LeibnizEquiv] collects setoid equalities that coincide</span>\n<span class=\"c\">with Leibniz equality. We provide the tactic [fold_leibniz] to transform such</span>\n<span class=\"c\">setoid equalities into Leibniz equalities, and [unfold_leibniz] for the</span>\n<span class=\"c\">reverse.</span>\n\n<span class=\"c\">Various std++ tactics assume that this class is only instantiated if [≡]</span>\n<span class=\"c\">is an equivalence relation. *)</span>\n<span class=\"kn\">Class</span> <span class=\"n\">LeibnizEquiv</span> <span class=\"n\">A</span> <span class=\"o\">`{</span><span class=\"n\">Equiv</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n  <span class=\"n\">leibniz_equiv</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≡</span> <span class=\"n\">y</span> <span class=\"o\">→</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"o\">.</span>\n<span class=\"kn\">Global</span> <span class=\"kn\">Hint</span> <span class=\"n\">Mode</span> <span class=\"n\">LeibnizEquiv</span> <span class=\"o\">!</span> <span class=\"o\">!</span> <span class=\"o\">:</span> <span class=\"n\">typeclass_instances</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Lemma</span> <span class=\"n\">leibniz_equiv_iff</span> <span class=\"o\">`{</span><span class=\"n\">LeibnizEquiv</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"o\">!</span><span class=\"n\">Reflexive</span> <span class=\"o\">(</span><span class=\"bp\">≡</span><span class=\"o\">@{</span><span class=\"n\">A</span><span class=\"o\">})}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">≡</span> <span class=\"n\">y</span> <span class=\"o\">↔</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"o\">.</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span> <span class=\"k\">split</span><span class=\"o\">;</span> <span class=\"o\">[</span><span class=\"k\">apply</span> <span class=\"n\">leibniz_equiv</span><span class=\"o\">|].</span> <span class=\"k\">intros</span> <span class=\"o\">-&gt;;</span> <span class=\"kp\">reflexivity</span><span class=\"o\">.</span> <span class=\"kn\">Qed</span><span class=\"o\">.</span>\n</code></pre></div>",
        "id": 569997931,
        "sender_full_name": "Alex Bai",
        "timestamp": 1769391968
    },
    {
        "content": "<p>Might I ask why?</p>",
        "id": 570000010,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1769393897
    },
    {
        "content": "<p>If the equivalence is OFE equivalence, the OFE Leibniz class does this. Another common way to identify equivalent terms is with a quotient, which may also serve your purposes.</p>",
        "id": 570000133,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1769394042
    },
    {
        "content": "<p>Oh wait let me guess. Are you porting <code>auth_auth_dfrac_op_inv_L</code>?</p>",
        "id": 570000317,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1769394257
    },
    {
        "content": "<p>no not that, i was trying to rewrite based on set equivalences<br>\n(in particular I was looking into <a href=\"https://gitlab.mpi-sws.org/FP/semantics-course/-/blob/new/theories/type_systems/stlc/logrel.v?ref_type=heads#L223\">this</a>)</p>",
        "id": 570000489,
        "sender_full_name": "Alex Bai",
        "timestamp": 1769394456
    },
    {
        "content": "<p>Ah</p>",
        "id": 570000659,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1769394639
    },
    {
        "content": "<p>Generally speaking, it's easiest to port <code>rewrite H.</code> into refine <code>.trans (... H ...) ?_</code> assuming your ≡ is well behaved enough for that</p>",
        "id": 570000825,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1769394776
    }
]