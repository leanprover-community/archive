[
    {
        "content": "<p>I'm running into some typeclass problems with functors, and I'm looking for the best way to fix it. As it stands, here are the typeclasses we use to represent functors (parameterized by their object map <code>F</code> of type <code>(α : Type _) → (β : Type _) -&gt; [OFE α] → [OFE β] → Type _</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">OFunctor</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">OFE</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"n\">OFunctorContractive</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"ss\">`OFunctor</span><span class=\"bp\">`</span>\n<span class=\"n\">RFunctor</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">CMRA</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"n\">RFunctorContractive</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"ss\">`RFunctor</span><span class=\"bp\">`</span>\n<span class=\"n\">URFunctor</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">UCMRA</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"n\">URFunctorContractive</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"ss\">`URFunctor</span><span class=\"bp\">`</span>\n</code></pre></div>\n<p>I think the source of my issues comes from the fact that, right now, <code>O/R/UR</code> functors are all separate typeclasses with instances for each other. I'd like to put them together into one <code>extends</code> chain, but since<code>CMRA</code> extends <code>OFE</code> and <code>UCMRA</code> extends <code>CMRA</code> (rather than taking <code>OFE</code>/<code>CMRA</code> as a typeclass constraint), I don't know how to resolve the inheritance diamonds for eg. the <code>OFE</code> instance for <code> F α β</code> given some RFunctor <code>F</code>.</p>\n<p>What's the usual way to fix this situation? I think if instead of <code>CMRA</code> extending <code>OFE</code> we used typeclasses <code>IsCMRA </code> or <code>IsUCMRA</code> (similar to <code>IsCOFE</code>) then each one of these structures could extend each other, but because the typeclasses contain data I'm not sure if this is a the right move.</p>",
        "id": 510983214,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1744131230
    },
    {
        "content": "<p>(cc <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, but I'm sure this is a general problem that has been solved before)</p>",
        "id": 510984397,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1744131630
    },
    {
        "content": "<p>With this setup, you don't want them to be <code>extends</code>, the data of an RFunctor already include everything you need to build an OFunctor, so you want an instance instead that constructs one from the other</p>",
        "id": 511077603,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744175694
    },
    {
        "content": "<p>How can I make sure that lean knows <code>(RFunctor.cmra F α β _ _).toOFE</code> and <code>OFunctor.cofe (OFunctor_of_RFunctor F _) α β _ _</code> are the same OFE? I've hit a few lemmas already where this has come up</p>",
        "id": 511142850,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1744197280
    },
    {
        "content": "<p>Because that is the definition of the <code>cofe</code> field of <code>OFunctor_of_RFunctor</code></p>",
        "id": 511168930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744204210
    },
    {
        "content": "<p>or it should be</p>",
        "id": 511168951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744204215
    },
    {
        "content": "<p>(it seems to be true by definition)</p>",
        "id": 511169621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744204403
    },
    {
        "content": "<p>Ah okay I didn't know Lean could compare them by unfolding! It's possible that my issues were due to some definitions being sorry'd out. I'll play around with it some more, thanks</p>",
        "id": 511170094,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1744204528
    }
]