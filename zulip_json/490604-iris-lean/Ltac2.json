[
    {
        "content": "<p>Parts of the iris proof mode are already implemented in the new Ltac2 tactic language. Has anyone considered porting Ltac2 to Lean? Something similar was done for the SSR tactic language already.<br>\nThis might facilitate future porting.</p>",
        "id": 561155275,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1764594814
    },
    {
        "content": "<p>From a tactic programming point of view, the current lean framework seems better than the Ltac family</p>",
        "id": 561157653,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764595403
    },
    {
        "content": "<p>Source : I played with both<br>\nCaveat : My \"experience\"  with Rocq is less than with lean, although in iris, it is the other way around.</p>",
        "id": 561157726,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764595420
    },
    {
        "content": "<p>Basically you program all the neatly typed stuff inside the MetaM monad after collecting arguments from the TacticM monad as metavariables. If you want quoting, there's Qq.</p>",
        "id": 561158880,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764595685
    },
    {
        "content": "<p>Ltac2 is very different from Ltac2. It's very close to ML.<br>\n<a href=\"https://rocq-prover.org/docs/metaprogramming-ltac2\">https://rocq-prover.org/docs/metaprogramming-ltac2</a></p>\n<p>If you have concrete suggestions on where Lean's tactic language is better, that would be useful. Rocq has several other possibilities of tactic programming, precise evaluation between them has started, but not concluded.</p>",
        "id": 561161437,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1764596264
    },
    {
        "content": "<p>The links for tutorials on that page all seem to link to github issues</p>",
        "id": 561162356,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764596488
    },
    {
        "content": "<p>and some of those issues lead to broken links like this one : <a href=\"https://github.com/rocq-prover/platform-docs/blob/main/src/Tutorial_Ltac2_types_and_thunking.v\">https://github.com/rocq-prover/platform-docs/blob/main/src/Tutorial_Ltac2_types_and_thunking.v</a></p>",
        "id": 561162500,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764596519
    },
    {
        "content": "<p>Here's a structural comparison:<br>\n<a href=\"https://hal.science/hal-05024207v3/preview/main.pdf#page=8.69\">https://hal.science/hal-05024207v3/preview/main.pdf#page=8.69</a></p>",
        "id": 561162610,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1764596546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Ltac2/near/561162356\">said</a>:</p>\n<blockquote>\n<p>The links for tutorials on that page all seem to link to github issues</p>\n</blockquote>\n<p>Thanks. I'll report that.</p>",
        "id": 561162890,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1764596616
    },
    {
        "content": "<p>I am not sure I understand these lines in the lean section below:</p>\n<blockquote>\n<p>Meta-programs can thus only build recursive functions using<br>\nprimitive recursors. In practice recursors for nested inductives quickly become unwieldy. Generating<br>\nconcrete syntax (instead of abstract syntax) solves this particular issue with fixpoints and case<br>\nexpressions, but concrete syntax is very difficult to manipulate, and most functions in the Lean<br>\nmeta-programming API (such as unification or type inference) do not work with concrete syntax</p>\n</blockquote>",
        "id": 561163712,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764596788
    },
    {
        "content": "<p>One can easily work with <code>TSyntax</code> in the lean metaprogramming API. Is that what they mean by abstract syntax (I always thought that was <code>Expr</code>)</p>",
        "id": 561163781,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764596807
    },
    {
        "content": "<p>CC : <span class=\"user-mention\" data-user-id=\"432410\">@Arthur Adjedj</span>  and <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span></p>",
        "id": 561164116,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764596887
    },
    {
        "content": "<p>I don't know the details, but likely related to this recent article about an approved treatment of nested inductives in type theory <a href=\"https://hal.science/hal-05366368v1\">https://hal.science/hal-05366368v1</a></p>",
        "id": 561164216,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1764596917
    },
    {
        "content": "<p>For context there is ongoing work on a <code>mutual_induction</code> tactic</p>",
        "id": 561164313,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764596943
    },
    {
        "content": "<p>and I am not sure about nested inductives, but I never ran into issues with those (to be fair I didn't metaprogram with those).</p>",
        "id": 561164433,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764596976
    },
    {
        "content": "<p>But I think it's best someone who knows these tactic languages deeply responds. I am more like an end-user of them (and more lean than Rocq), hence the CC.</p>",
        "id": 561165463,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764597204
    },
    {
        "content": "<p>Found a good explanation of how nested inductive type recursors are compiled here : <a href=\"https://lean-lang.org/doc/reference/latest/The-Type-System/Inductive-Types/#nested-inductive-types\">https://lean-lang.org/doc/reference/latest/The-Type-System/Inductive-Types/#nested-inductive-types</a></p>",
        "id": 561178844,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764600004
    },
    {
        "content": "<p>They are translated to mutual inductive types</p>",
        "id": 561179145,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764600069
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Ltac2/near/561162610\">said</a>:</p>\n<blockquote>\n<p>Here's a structural comparison:<br>\n<a href=\"https://hal.science/hal-05024207v3/preview/main.pdf#page=8.69\">https://hal.science/hal-05024207v3/preview/main.pdf#page=8.69</a></p>\n</blockquote>\n<p>Their main complaint seems to be that Lean compiles pattern matching down to <code>casesOn</code> and <code>match</code> decls and there is no primitive in <code>Expr</code> if I'm seeing that correctly? While that is true this doesn't really strike me as an issue that occurs much in practice. I cannot recall people on this Zulip ever asking how to do this from the top of my head (doesn't mean it didn't happen, just to give an indicator of how often this is necessary). But it is indeed true that the API for getting your own <code>PreDefinition</code> in (from which these <code>casesOn</code> and friends are derived) is lacking, this might change in the future.</p>\n<p>Regarding the porting of Rocq's tactic DSLs to Lean, the SSR tactic language port to Lean was done and, to the best of my knowledge, completely rejected by the community. Even the group that built the port (Ilya Sergey's team) has stopped using it for future projects. It feels rather likely that a hypothetical Ltac2 port would meet a similar fate. The comfort from just being able to write Lean all the time is far too compelling. The case study also understates how important this is IMHO. The fact that Lean tactics are written in Lean causes countless synergy effects:</p>\n<ul>\n<li>you get amazing editor support for free when writing a tactic. People porting Ltac2 would have to invest a ton of effort into integrating the language with all of this</li>\n<li>all of the work done by the FRO stdlib team directly benefits you in your tactic writing, you get all the latest and greatest convenience APIs for free</li>\n<li>all of the work done by the FRO on optimization, in the elaborator, the compiler etc. also directly benefits your work for free</li>\n<li>you get logging, profiling etc. all for free</li>\n</ul>\n<p>In summary, the decision to have Lean be extensible with Lean is not because core was too lazy to develop another DSL or something like that, it is a calculated decision that has benefited Lean 4 tremendously over the years.</p>\n<p>Also, just from a glance at the Lean section I'm a bit wary of this case study, e.g. the claim that <code>Option.casesOn</code> is a primitive recursor is wrong (check the output of <code>#print Option.casesOn</code>), there might be more things I didn't catch at first sight:<br>\n<a href=\"/user_uploads/3121/94G0FCwP_LdciXJemkzJbl6O/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/94G0FCwP_LdciXJemkzJbl6O/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1247x68\" src=\"/user_uploads/thumbnail/3121/94G0FCwP_LdciXJemkzJbl6O/image.png/840x560.webp\"></a></div>",
        "id": 561196152,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1764603474
    },
    {
        "content": "<p>Thanks! <br>\nI wasn't suggesting Ltac2 as a replacement for the Lean tactic language, just as a possibility to facilitate porting Rocq code to Lean.<br>\nHaving said that, Ltac2 is still not widely used, so it's unclear how much it would help right now, but it may be convenient for parallel Rocq/lean development, as in iris.</p>\n<p>Alternatively, maybe there should be a direct translation from Ltac2 to lean's tactic language.</p>",
        "id": 561200836,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1764604466
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Ltac2/near/561196152\">said</a>:</p>\n<blockquote>\n<p>I cannot recall people on this Zulip ever asking how to do this from the top of my head</p>\n</blockquote>\n<p>I think the main questions asked about this aspect of the work were in <a href=\"#narrow/channel/270676-lean4/topic/Recursive.20definition.20in.20.60Expr.60\">#lean4 &gt; Recursive definition in &#96;Expr&#96;</a>  (but I might be wrong, I just searched for questions <span class=\"user-mention\" data-user-id=\"763287\">@Mathis Bouverot-Dupuis</span> asked here)</p>",
        "id": 561204159,
        "sender_full_name": "Yannick Forster",
        "timestamp": 1764605122
    },
    {
        "content": "<p>Also I / we agree with your list of pros Henrik :) One clear conclusion of the case study was that one definitely wants to work in the language of the ITP itself -- in Lean that means one wants to use Lean as meta-programming language, no external language or DSL</p>",
        "id": 561204582,
        "sender_full_name": "Yannick Forster",
        "timestamp": 1764605222
    },
    {
        "content": "<p>If we actually got something wrong about the treatment of PreDefinition / Expr / casesOn we're more than happy to fix it :)</p>",
        "id": 561204849,
        "sender_full_name": "Yannick Forster",
        "timestamp": 1764605282
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Ltac2/near/561200836\">said</a>:</p>\n<blockquote>\n<p>Thanks! <br>\nI wasn't suggesting Ltac2 as a replacement for the Lean tactic language, just as a possibility to facilitate porting Rocq code to Lean.<br>\nHaving said that, Ltac2 is still not widely used, so it's unclear how much it would help right now, but it may be convenient for parallel Rocq/lean development, as in iris.</p>\n</blockquote>\n<p>I think the needs of a good Lean tactic diverge quite a bit from what you can reasonably express in an auto translation from ltac. You will want to have logging/profiling nodes, in particular also proper management of contexts for that logging, potentially managing error locations etc. It might be good if you want to get a prototype in Lean but if you really want to build something that works well it will have to be lean specific. In which case, why not use Lean anyway.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"444411\">Yannick Forster</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Ltac2/near/561204582\">said</a>:</p>\n<blockquote>\n<p>Also I / we agree with your list of pros Henrik :) One clear conclusion of the case study was that one definitely wants to work in the language of the ITP itself -- in Lean that means one wants to use Lean as meta-programming language, no external language or DSL</p>\n</blockquote>\n<p>That's great to hear!</p>\n<p><span class=\"user-mention silent\" data-user-id=\"444411\">Yannick Forster</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Ltac2/near/561204849\">said</a>:</p>\n<blockquote>\n<p>If we actually got something wrong about the treatment of PreDefinition / Expr / casesOn we're more than happy to fix it :)</p>\n</blockquote>\n<p>Nothing apart from the fact that <code>Option.casesOn</code> is not a primitive recursor jumped at me right away.</p>",
        "id": 561207320,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1764605814
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Ltac2/near/561163712\">said</a>:</p>\n<blockquote>\n<p>I am not sure I understand these lines in the lean section below:</p>\n<blockquote>\n<p>Meta-programs can thus only build recursive functions using<br>\nprimitive recursors. In practice recursors for nested inductives quickly become unwieldy. Generating<br>\nconcrete syntax (instead of abstract syntax) solves this particular issue with fixpoints and case<br>\nexpressions, but concrete syntax is very difficult to manipulate, and most functions in the Lean<br>\nmeta-programming API (such as unification or type inference) do not work with concrete syntax<br>\n</p>\n</blockquote>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"444411\">@Yannick Forster</span> : for me the question is, what does it mean to be difficult to work with concrete syntax here. Like what's the typical example that's easier in a different tactic language than lean</p>",
        "id": 561209967,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764606298
    },
    {
        "content": "<p>You can build non trivial recursive functions in Rocq easier than in Lean because its <code>Expr</code> equivalent has a fixpoint operator</p>",
        "id": 561210187,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1764606343
    },
    {
        "content": "<p>Off the top of my head, it seems correct if you mean I can't just, 1. get the goal 2. match is syntactically without quoting and lifting monads, then it seems right.</p>",
        "id": 561210195,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764606345
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Ltac2/near/561210187\">said</a>:</p>\n<blockquote>\n<p>You can build non trivial recursive functions in Rocq easier than in Lean because its <code>Expr</code> equivalent has a fixpoint operator</p>\n</blockquote>\n<p>Oh okay, so the concern is less with superficial syntax, specifically the bit about \"but concrete syntax is very difficult to manipulate, and most functions in the Lean<br>\nmeta-programming API (such as unification or type inference) do not work with concrete syntax\"</p>",
        "id": 561210343,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764606372
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/490604-iris-lean/topic/Ltac2/near/561207320\">said</a>:</p>\n<blockquote>\n<p>Nothing apart from the fact that <code>Option.casesOn</code> is not a primitive recursor jumped at me right away.</p>\n</blockquote>\n<p>Indeed it's a wrapper around the actual recursor <code>Option.rec</code>! Thanks for pointing this out.</p>",
        "id": 561216478,
        "sender_full_name": "Mathis Bouverot-Dupuis",
        "timestamp": 1764607560
    }
]