[
    {
        "content": "<p>The Lean implementation defines OFE equivalence (<code>≡</code>) on BI propositions as definitionally equal to bi-entailment (<code>⊣⊢</code>): <code>Equiv P Q := P ⊣⊢ Q</code>. The Rocq implementation takes a different approach: <code>≡</code> comes from the OFE structure, <code>⊣⊢</code> is defined separately, and <code>bi_mixin_equiv_entails</code> connects the two. </p>\n<ol>\n<li>I think both enforce the same constraint, but what was the rationale for defining <code>Equiv P Q := P ⊣⊢ Q</code> rather than following Rocq's approach?</li>\n</ol>\n<p>I'm porting <code>big_ops</code>, but the Rocq proofs extensively use generalized rewriting which is currently missing in Lean.</p>\n<ol start=\"2\">\n<li>Was the <code>rw'</code> tactic intended to support <code>⊣⊢</code> rewriting? If so, what's the path forward — extend <code>rw'</code> or a different approach?</li>\n<li>In the meantime, what's the recommended approach for porting proofs that rely on generalized rewriting?</li>\n</ol>",
        "id": 565019365,
        "sender_full_name": "Zongyuan Liu",
        "timestamp": 1766415219
    },
    {
        "content": "<p>1: I'm not sure why exactly it is like this but it is equivalent. <br>\n2: There was some discussion of this in Lars König's original development which we have moved to <a href=\"https://github.com/leanprover-community/iris-lean/blob/b8835e6bc81f5d37d3195c2306111ffd2c3bdece/proofmode.md\">proofmode.md</a>. <code>rw'</code> is pretty limited. If you search in this channel there was some experiments with supporting generalized rewriting (search the Zulip for various attempts). You're free to pick this up if you want. <br>\n3: Generalized rewriting just searches for appropriate <code>NonExpansive</code> lemmas to apply around the your rewrite. We have been doing this by hand, and so far it has not been too hard. How bad is it in big_ops?</p>",
        "id": 565024016,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1766416675
    },
    {
        "content": "<p>To rewrite <code>R</code> under a nonexpansive function <code>f</code> the pattern is generally something like <code>refine .trans (f_ne.ne R) ?_)</code>. Generalized rewriting just automates the search for <code>f_ne.ne</code>.</p>",
        "id": 565024500,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1766416836
    },
    {
        "content": "<p>I'm far from an expert on this matter, but I thought I'd mention that mathlib has had a generalised rewriting tactic <code>grw</code> for a while now, see <a href=\"https://github.com/leanprover-community/mathlib4/blob/1c119a384d559bccba90477b0ef3a645d77c5bd7/Mathlib/Tactic/GRewrite/Elab.lean\">here</a> for the implementation and documentation.</p>\n<p>Unlike Rocq's generalised rewriting, <code>grw</code> (as with <code>rw</code>) doesn't support rewriting under binders. I'm not sure how big of a limitation this is as I'm not an expert here. I also wonder if Iris could benefit from using this instead of <code>rw'</code>, though I imagine this tactic (along with its dependencies) would need to be moved out of mathlib for that.</p>",
        "id": 565334848,
        "sender_full_name": "Joe Watt",
        "timestamp": 1766632386
    }
]