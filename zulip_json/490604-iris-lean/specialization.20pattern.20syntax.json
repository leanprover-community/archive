[
    {
        "content": "<p>As already came up in multiple places, we should discuss what syntax we want to use for specialization patterns. Based on <a href=\"#narrow/channel/490604-iris-lean/topic/proof.20mode.20terms.20for.20icases/with/564255452\">https://leanprover.zulipchat.com/#narrow/channel/490604-iris-lean/topic/proof.20mode.20terms.20for.20icases/with/564255452</a> I thought a bit more about what syntax to use for the specialization patterns and collected the following ideas based on the suggestions in the thread. What do you think about these options? Any other ideas?</p>\n<p>As the example, consider <code>h : ∀ x, ⊢ ∀ y, ⌜A x⌝ -∗ P x -∗ Q y -∗ R</code>.</p>",
        "id": 564824344,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1766232985
    },
    {
        "content": "<p>Option 1: h a $! b with [%] H1 [H2, H3]<br>\npro:</p>\n<ul>\n<li>same notation as in Rocq</li>\n<li>clearly separated what is a Lean hypothesis vs Iris universal quantifier vs Iris hypothesis</li>\n</ul>\n<p>con:</p>\n<ul>\n<li>\"with\" conflicts with \"with\" of icases</li>\n<li>does not support universal quantifiers after wands</li>\n</ul>",
        "id": 564824352,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1766232995
    },
    {
        "content": "<p>Option 2: h a b [%] H1 [H2, H3]<br>\npro:</p>\n<ul>\n<li>no symbols like $!</li>\n<li>does not conflict with another notation</li>\n<li>supports universal quantifiers after wands</li>\n</ul>\n<p>con:</p>\n<ul>\n<li>hard to see what are Lean hypothesis / quantifiers vs Iris</li>\n<li>might have weird edge cases in parsing since one cannot use the normal term parser (or can one?)<ul>\n<li>I am worried about e.g. passing implicit or named arguments to h, i.e. the case when it is not just a list of space separated terms</li>\n</ul>\n</li>\n<li>ambigous if [H2, H3] refers to a list or the specialization pattern<ul>\n<li>maybe one can find another notation?</li>\n</ul>\n</li>\n</ul>",
        "id": 564824360,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1766233004
    },
    {
        "content": "<p>Option 3: h a $! b [%] H1 [H2, H3]<br>\npro:</p>\n<ul>\n<li>only one symbol $!</li>\n<li>does not conflict with another notation</li>\n<li>clearly delimits lean arguments from Iris arguments</li>\n<li>supports universal quantifiers after wands</li>\n</ul>\n<p>con:</p>\n<ul>\n<li>one has to remember $!</li>\n</ul>",
        "id": 564824369,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1766233010
    },
    {
        "content": "<p>Option 4: h %a b % H1 [H2, H3]<br>\npro:</p>\n<ul>\n<li>no $!</li>\n<li>does not conflict with another notation</li>\n<li>distingushes lean arguments from Iris arguments</li>\n<li>supports universal quantifiers after wands</li>\n</ul>\n<p>con:</p>\n<ul>\n<li>might be hard to parse?</li>\n<li>usage of % might conflict with % for creating pure goals</li>\n</ul>",
        "id": 564824375,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1766233017
    },
    {
        "content": "<p>Option 5: h %a %b % H1 [H2, H3]<br>\npro:</p>\n<ul>\n<li>no $!</li>\n<li>does not conflict with another notation</li>\n<li>% uniformly means pure (either type / ∀ or prop / ⌜_⌝)</li>\n<li>supports universal quantifiers after wands</li>\n</ul>\n<p>con:</p>\n<ul>\n<li>might be hard to parse?</li>\n</ul>",
        "id": 564824382,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1766233026
    },
    {
        "content": "<p>Why not use lean syntax?</p>",
        "id": 564828446,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766237405
    },
    {
        "content": "<p>For patterns I mean</p>",
        "id": 564828455,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766237415
    },
    {
        "content": "<p>With angular braces.</p>",
        "id": 564828461,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766237421
    },
    {
        "content": "<p>To make sure that we are one the same page: The lean syntax for instantiating a hypothesis of type <code>h : ∀ x y, A x → P x → Q y → R</code> would be <code>h a b _ H1 _</code>. (There is no equivalent of <code>[H2, H3]</code> in Lean since there it is not necessary to split the context.) Option 2 is probably closest to this (but maybe also confusing because of this).</p>",
        "id": 564829229,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1766238186
    },
    {
        "content": "<p>Option 2 looks good.</p>",
        "id": 564829833,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766238753
    },
    {
        "content": "<p>But I am also sure we can find some unicode separator like \\|  or \\|-</p>",
        "id": 564829867,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766238785
    },
    {
        "content": "<p>Do we not need to separate   iris universal quantifiers from lean universal quantifiers?</p>",
        "id": 564830457,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766239288
    },
    {
        "content": "<p>Thanks for writing this all out! I'll give my 2¢, but I'll go with whatever the most people like. </p>\n<ul>\n<li>Universal quantifiers after wands would be a nice feature, I like this. </li>\n<li>I also like the ability to cleanly distinguish Lean and Iris terms since it could afford us more flexibility in terms of mixing in Lean terms.<ul>\n<li>For example, maybe the <code>[%]</code> in Option 3 could be extended to a syntax  like <code>[%(...)]</code> which refines the proof goal with the terms, or holes in <code>...</code></li>\n<li>Then it would be completely idiomatic to write <code>h a $! b [%(⟨?_, ?_⟩)] H1 [H2, H3]</code> or even<code>h a $! b [%(by grind)] H1 [H2, H3]</code>. Anyways, just some food for thought. </li>\n</ul>\n</li>\n<li>I mentioned above my main gripe with <code>$!</code> is that I find it hard to remember... seeing the upsides and downsides I think my main issue is the the symbol itself. From your list it seems that having a delimiter between the Iris and Lean terms makes our lives simpler. I'd be happy with this if we just used an English word instead (<code>as</code>? <code>from</code>? <code>using</code>? <code>whence</code>? Alright that last one is a joke.) </li>\n<li>The uniformity of pure patterns in Option 5 is satisfying, but I think you're correct that parsing could be tricky. </li>\n</ul>\n<p>Overall, your Option 3 (with an English version of <code>$!</code>) seems to have the most upsides. Interested in hearing other's opinions!</p>",
        "id": 564834071,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1766242650
    },
    {
        "content": "<p>I also like Option 3 the most. I am open to bikeshedding which word / symbol to use for the delimiter. Shreyas suggested <code>∣</code> (i.e. <code>\\|</code>), but I think this looks too close to <code>|</code> and will confuse people. But maybe just <code>|</code> could work? Alternatively, maybe we can use <code>$</code>? (a bit like how it is used in Haskell for application)<br>\nI think the problem of <code>$!</code> in Iris Rocq is that it is used very seldomly, so if one needs it it is hard to remember. But the symbol we pick will be used very often (almost all calls to <code>iapply</code>), so I think people will be able to remember it (or find an <code>iapply</code> call close by that uses the symbol).<br>\nIf we use a word, it should be clear that it means function application. Maybe <code>using</code> would work? (<code>with</code> would also be good, but we cannot use it because of the conflict with cases)</p>",
        "id": 564897135,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1766327282
    },
    {
        "content": "<p>Great, I agree completely!</p>",
        "id": 564903088,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1766334754
    },
    {
        "content": "<p>My two cents on <code>\\|</code> vs <code>|</code> : At least in vscode, hovering the mouse pointer over a symbol tells you how to enter it.  I have this confusion with unicode symbols with other theorem provers which don't provide these helpful tooltips yet, so I can see why you might be concerned. With good docstrings finding the notation and the shortcuts shouldn't be too hard. <code>\\|</code> is used as the divisibility operator in mathlib for example. I recommend against plain | because that might interact badly with the <code>|</code> used in arms of matches for example. Since Iris syntax is still in the <code>term</code> syntax category, this might cause headaches later</p>",
        "id": 564917251,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766353863
    },
    {
        "content": "<p>I implemented the unified proof mode patterns (Option 3) in <a href=\"https://github.com/leanprover-community/iris-lean/pull/109\">https://github.com/leanprover-community/iris-lean/pull/109</a><br>\nThis PR uses <code>$$</code> as the delimiter, but this is open to bikeshedding.<br>\nIt worked surprisingly well. You can do things like <code>  ispecialize H $$ %(by grind)</code> and get a working proof mode inside the <code>by </code></p>",
        "id": 564977682,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1766400430
    },
    {
        "content": "<p>I'm in favour of Option 5. Can you remind me why we want to delimit lean arguments from Iris arguments?</p>",
        "id": 564980396,
        "sender_full_name": "Zongyuan Liu",
        "timestamp": 1766401471
    },
    {
        "content": "<p>One problem with Option 5 is that parsing becomes harder. With Option 3 we can just elaborate everything on the left of <code>$$</code> / <code>$!</code> as a normal Lean term, so all lean term notation works without problem (e.g. specifying implicit arguments via <code>(A:=A)</code>. For Option 5, it is a bit less clear how parsing work. Do we only allow identifiers for <code>h</code> or more?<br>\nAnother difference of Option 3 vs Option 5 is that Option 3 allows one to skip all Lean arguments. If we have <code>h : ∀ x y z, |- ∀ a, P</code>, with Option 3 we can write <code>h $$ %a</code> to specify just <code>a</code>, while for Option 5 we need to write <code>h %_ %_ %_ %a</code>. This might make a difference for lemmas with many parameters that one wants to fill with underscores (this is how it works in Rocq).</p>",
        "id": 564990735,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1766405403
    },
    {
        "content": "<p>Thanks. I now agree that option 3 seems to be the best. I however prefer a one-character separator, since one would have to type it a lot. For instance the proposed <code>$</code>?</p>",
        "id": 565001096,
        "sender_full_name": "Zongyuan Liu",
        "timestamp": 1766409252
    },
    {
        "content": "<p><code>$</code> is already used as an alias for <code>|&gt;</code> in terms, so we sadly cannot use it. But I would also like a single character if we can find a good one.</p>",
        "id": 565002370,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1766409711
    },
    {
        "content": "<p>I still think \\| is a good candidate. Also wow that was blazing fast <span aria-label=\"scream\" class=\"emoji emoji-1f631\" role=\"img\" title=\"scream\">:scream:</span></p>",
        "id": 565005286,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766410733
    },
    {
        "content": "<p>If <code>$</code> doesn't work, why not <code>€</code>, <code>£</code> or <code>¥</code> (or <code>¢</code>?) /j</p>",
        "id": 567331354,
        "sender_full_name": "Ayhon",
        "timestamp": 1768062544
    },
    {
        "content": "<p>On a more serious note, this made me go through the <a href=\"https://github.com/leanprover/vscode-lean4/blob/a45318523691329a325301826e3d20b2c7f6e864/lean4-unicode-input/src/abbreviations.json\">list of symbols abbreviations supported by Lean</a>, so I collected a list of symbols that I think could work, beyond the already proposed ones. I tried to choose those that wouldn't bee too much of a pain to write down while typing.</p>\n<ul>\n<li><code>‖</code>: <code>\\Vert</code></li>\n<li><code>‡</code>: <code>\\ddagger</code>, <code>\\ddag</code></li>\n<li><code>⅌</code>: <code>\\per</code></li>\n<li><code>¡</code>: <code>\\!</code></li>\n<li><code>∷</code>: <code>\\::</code></li>\n<li><code>✂</code>: <code>\\8&lt;</code></li>\n</ul>",
        "id": 567332045,
        "sender_full_name": "Ayhon",
        "timestamp": 1768063232
    },
    {
        "content": "<p>Ok, it seems like Zulip is not a big fan of <a href=\"https://github.com/leanprover/vscode-lean4/blob/a45318523691329a325301826e3d20b2c7f6e864/lean4-unicode-input/src/abbreviations.json#L595\"><code>\\per</code></a>, <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 567332088,
        "sender_full_name": "Ayhon",
        "timestamp": 1768063268
    }
]