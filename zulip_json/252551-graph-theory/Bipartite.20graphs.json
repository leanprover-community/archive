[
    {
        "content": "<p>I am about to prove Erdös-Stone from SRL and for this I need the Embedding lemma, hence some API for containment.</p>",
        "id": 310806917,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668773805
    },
    {
        "content": "<p>Now, the Zarankiewicz problem is about maximizing the number of edges of a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>K</mi><mrow><mi>t</mi><mo separator=\"true\">,</mo><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">K_{t,t}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>-free bipartite graph.</p>",
        "id": 310808029,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668774024
    },
    {
        "content": "<p>Hence I wonder whether I should write API for both containment of simple graphs and containment of bipartite graphs.<br>\nThose notions are genuinely different. There are less containments of bipartite graphs than of the corresponding simple graphs, because each of the two parts of the contained graph must be mapped in the corresponding part of the containing graph. The thing is that those notions agree when the graph is complete bipartite (and that covers Zarankiewicz for example), as this forbids edges within a given part.</p>",
        "id": 310809075,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668774329
    },
    {
        "content": "<p>TLDR: Do we care about containing non-complete bipartite graphs?</p>",
        "id": 310809146,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668774357
    },
    {
        "content": "<p>I'm not really familiar with SRL and how containment is used. What sorts of notions do you need to support?</p>",
        "id": 310828547,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668780082
    },
    {
        "content": "<p>Is this the generalization of \"triangle-free\" for other patterns?</p>",
        "id": 310828823,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668780145
    },
    {
        "content": "<p>One version of a bipartite graph is a graph that has a graph homomorphism to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>K</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">K_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. If keeping track of the partition is what you need, perhaps you want to model this as injective graph homomorphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> such that their maps to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>K</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">K_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> commute?</p>",
        "id": 310829329,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668780280
    },
    {
        "content": "<p>Interesting...</p>",
        "id": 310829565,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668780354
    },
    {
        "content": "<p>Not much about containment is needed, really. What we need is</p>\n<ul>\n<li>containment can be pulled back along injective homs (which is immediate if we define containment as the presence of an injective hom)</li>\n<li>we can ensure no containment of H by removing one edge from each potential copy of H</li>\n<li>the number of potential copies of H is (|G| choose |H|)</li>\n</ul>",
        "id": 310830189,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668780534
    },
    {
        "content": "<p>Graph colorings are already defined to be graph homomorphisms to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>K</mi><mi>t</mi></msub></mrow><annotation encoding=\"application/x-tex\">K_t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, so maybe what you're doing justifies developing coloring-preserving graph homomorphisms. This is a slice category of the category of simple graphs, if you want to think of it that way.</p>",
        "id": 310830742,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668780714
    },
    {
        "content": "<p>I think for now I will stick to simple graphs, and revisit this design decision when doing Zarankiewicz.</p>",
        "id": 310831125,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668780832
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Bipartite.20graphs/near/310809146\">said</a>:</p>\n<blockquote>\n<p>TLDR: Do we care about containing non-complete bipartite graphs?</p>\n</blockquote>\n<p>Even cycles are an interesting example. See, e.g., <a href=\"https://www.its.caltech.edu/~dconlon/EGT10.pdf\">https://www.its.caltech.edu/~dconlon/EGT10.pdf</a></p>",
        "id": 310832556,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1668781313
    },
    {
        "content": "<p>Seeing a bipartite graph as a simple graph still works in this case, right?</p>",
        "id": 310834989,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668782012
    },
    {
        "content": "<p>Actually, the only way it breaks would be if we tried to contain a disconnected graph, as a connected graph is either 2-colored (in which case containing it as a bipartite graph and as a simple graph are the same thing, up to picking a color), or it is not (in which case it can't be contained according to either)</p>",
        "id": 310835650,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668782213
    },
    {
        "content": "<p>So a better question would be \"Do we ever want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub><mo>=</mo><mo stretchy=\"false\">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>Y</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>E</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G_1 = (X_1 \\cup Y_1, E_1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> containing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>G</mi><mn>2</mn></msub><mo>=</mo><mo stretchy=\"false\">(</mo><msub><mi>X</mi><mn>2</mn></msub><mo>∪</mo><msub><mi>Y</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><msub><mi>E</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G_2 = (X_2 \\cup Y_2, E_2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> to mean that we have injections <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>2</mn></msub><mo>→</mo><msub><mi>X</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">X_2 \\rightarrow X_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>Y</mi><mn>2</mn></msub><mo>→</mo><msub><mi>Y</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">Y_2 \\rightarrow Y_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>?\"</p>",
        "id": 310836281,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668782422
    },
    {
        "content": "<p>What's \"it\" that might break?</p>",
        "id": 310837012,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668782649
    },
    {
        "content": "<p>Seeing a bipartite graph on <code>α</code> and <code>β</code> as a simple graph on <code>α ⊕ β</code>.</p>",
        "id": 310838379,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668783084
    },
    {
        "content": "<p>I don't know any interesting theorems that vare about disconnected bipartite graphs in the extremal setting. Counting embeddings respecting the bipartition appears in places such as the KŁR conjecture (see, e.g., <a href=\"https://arxiv.org/abs/1305.2516\">https://arxiv.org/abs/1305.2516</a>), where they're called \"canonical copies\", but I think it's too early to think about that in mathlib.</p>",
        "id": 310847394,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1668785505
    },
    {
        "content": "<p>I know this thread is from a while ago but I had some thoughts recently that I wanted to try to reason through with other people.</p>\n<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> made a comment in some other thread about whether we want graphs to be defined on different vertex types, which got me thinking - there are often cases where we use graph theory to reason about sets with different types. I'm thinking it might be interesting to experiment with a sort of graph hierarchy (that doesn't have edges as first class objects, sorry <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span>) that looks something like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">WeirdDef</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V₁</span><span class=\"w\"> </span><span class=\"n\">V₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V₁</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V₂</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">Rev</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V₂</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V₁</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">WeirdDef</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Rev</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\">  </span><span class=\"c1\">-- this part is a bit silly/awkward</span>\n<span class=\"w\">  </span><span class=\"n\">irrefl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>\n<p>Some advantages that I can think of with this definition is we're \"bundling\" the opposite direction for edges, but a disadvantage is we'd have to consider two cases for every edge: <code>Adj u v</code> or <code>Rev u v</code>, which will lead to a ton of code duplication. Another option is to use an idea Peter mentioned a while back for defining undirected graphs as a quotient over the edge orientations in directed graphs. Zooming out to having distinct types, maybe we could develop something resembling <code>sym2</code> that works for different types for this? </p>\n<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>'s graded rings paper also makes me wonder whether we should have graphs over more vertex types that are indexed, which would introduce some awkward dependent type theory, but allow for distinct adjacency definitions between different pairs of types where we don't have to use <code>if then else</code> that splits over different sets. One drawback I can see is it would introduce a lot of dependent type problems and/or code duplication in the case of e.g. objects that are defined in a single type where we do actually need to use <code>if then else</code> over sets. </p>\n<p>Another huge drawback is code duplication and/or awkwardness between bipartite defined over types vs bipartite as a property of simple graphs. </p>\n<p>Something else I keep wondering is whether the properties of adjacency relations should be unbundled/instances. </p>\n<p>I don't know, does anyone have any thoughts on this? I feel like these might be some problematic definitions but I'm wondering if there's something there. I'm fairly convinced that we need to allow for different vertex types in a single graph. Allowing for distinct types is the sort of approach we had in one of the formulations of Hall's Marriage Theorem.</p>",
        "id": 524292793,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1750091510
    },
    {
        "content": "<p>Why not just use a disjoint sum of types when we need different types of vertices</p>",
        "id": 524304392,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750095396
    },
    {
        "content": "<p>Or define a more complex network of relations and conversion functions to SimpleGraph or Digraph as needed</p>",
        "id": 524304691,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750095487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/252551-graph-theory/topic/Bipartite.20graphs/near/524304392\">said</a>:</p>\n<blockquote>\n<p>Why not just use a disjoint sum of types when we need different types of vertices</p>\n</blockquote>\n<p>You'd still need to be able to define the adjacency relation as between the distinct types though, no? I guess you could coerce back and forth between the sum type and the individual types, but I think the type coercion will also get messy/awkward</p>",
        "id": 524305365,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1750095680
    },
    {
        "content": "<p>I am just a bit wary about types as a solution to anything because so far I have found that working with Sets and partitions is much simpler than type theoretic things</p>",
        "id": 524306316,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750095936
    },
    {
        "content": "<p>Even the absence of vertex sets in the current SimpleGraph definitions leads to a lot of inconvenience</p>",
        "id": 524306435,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750095970
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/252551-graph-theory/topic/Bipartite.20graphs/near/524306435\">said</a>:</p>\n<blockquote>\n<p>Even the absence of vertex sets in the current SimpleGraph definitions leads to a lot of inconvenience</p>\n</blockquote>\n<p>I do agree with that</p>",
        "id": 524306488,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1750095984
    },
    {
        "content": "<p>I was thinking you could somehow use this same approach but combine it with the set requirement, i.e. everything related by adjacency has to belong to carrier sets</p>",
        "id": 524306937,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1750096114
    },
    {
        "content": "<p>I think you could write that requirement in an abstract way, like if the types are indexed and we had a sym sort of object defined on distinct types</p>",
        "id": 524307061,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1750096156
    },
    {
        "content": "<p>Here's a way to avoid <code>Rev</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">WeirderDef</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">partite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span>\n</code></pre></div>",
        "id": 524307232,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750096208
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/252551-graph-theory/topic/Bipartite.20graphs/near/524307232\">said</a>:</p>\n<blockquote>\n<p>Here's a way to avoid <code>Rev</code>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">WeirderDef</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">partite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Oh yes, this is what I was thinking but I was having trouble figuring out how to express it - the indexed types allow for a good amount of generality</p>",
        "id": 524307603,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1750096313
    },
    {
        "content": "<p>We could have one definition that doesn't include <code>symm</code> or <code>partite</code> but that does have the carrier set requirement, so that it can be generalized to types that do overlap</p>",
        "id": 524307709,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1750096341
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">WeirderDef</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">Carrier</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">  </span><span class=\"n\">adjSet</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"c1\">-- or something</span>\n</code></pre></div>",
        "id": 524307816,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1750096372
    },
    {
        "content": "<p>and then that could be generalized to the undirected or partite requirements, etc</p>",
        "id": 524308157,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1750096470
    },
    {
        "content": "<p>and for a single vertex type we just specify a singleton index set and make an alias for it, or for a graph that we want to be bipartite in the same vertex type we'd have the partite requirement be on the carrier sets (belonging to the same type) instead of the types (code duplication for sets vs types - problem?). Would we want the partite condition to be a typeclass? I guess edge contractions would become really really messy then, but I don't think they're too nice in the single vertex type case either because you still have to quotient over two vertices and get a new type</p>",
        "id": 524308247,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1750096505
    },
    {
        "content": "<p>This might be too expressive though, what if the vertex types are all singletons</p>",
        "id": 524312294,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1750098189
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Bipartite.20graphs/near/524307232\">said</a>:</p>\n<blockquote>\n<p>Here's a way to avoid <code>Rev</code>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">WeirderDef</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">partite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Interesting. I did something similar in my definition of the port numbering model of distributed graph algorithms.</p>",
        "id": 524317751,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750100588
    },
    {
        "content": "<p>There each vertex labels its adjacent edges differently and the type of the labelling depends on the degree of the vertex.</p>",
        "id": 524317819,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750100620
    },
    {
        "content": "<p>I also use an indexing notation to construct a uniform type of vertex and edge labellings which describe inputs and outputs to algorithms.</p>",
        "id": 524318071,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750100747
    },
    {
        "content": "<p>@Alena : perhaps we could use labels to classify vertices into different “types”?</p>",
        "id": 524318267,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750100851
    },
    {
        "content": "<p>Here: <a href=\"https://github.com/Shreyas4991/DGAlgorithms/blob/main/DGAlgorithms/Models/PortNumbering.lean#L11\">https://github.com/Shreyas4991/DGAlgorithms/blob/main/DGAlgorithms/Models/PortNumbering.lean#L11</a></p>",
        "id": 524318486,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750100948
    },
    {
        "content": "<p>The good thing with labellings is that one can simply extend SimpleGraph with a structure that adds labels. Additionally one can continue working on the underlying SimpleGraph when convenient.</p>",
        "id": 524318916,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750101147
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/252551-graph-theory/topic/Bipartite.20graphs/near/524318267\">said</a>:</p>\n<blockquote>\n<p>@Alena : perhaps we could use labels to classify vertices into different “types”?</p>\n</blockquote>\n<p>The vertex labeling version of n-partite is already done using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Coloring#doc\">docs#SimpleGraph.Coloring</a></p>\n<p>The IsBipartite predicate is defined using it: <a href=\"https://github.com/leanprover-community/mathlib4/blob/1a83ec9d7a74f9063014411a530bdbdbb3b86a38/Mathlib/Combinatorics/SimpleGraph/Bipartite.lean#L252\">https://github.com/leanprover-community/mathlib4/blob/1a83ec9d7a74f9063014411a530bdbdbb3b86a38/Mathlib/Combinatorics/SimpleGraph/Bipartite.lean#L252</a></p>\n<p>There's always going to be a tension between using indexed families of types and a projection function from a \"total type\". They're dual to each other.</p>",
        "id": 524320739,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750102096
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Bipartite.20graphs/near/524320739\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/252551-graph-theory/topic/Bipartite.20graphs/near/524318267\">said</a>:</p>\n<blockquote>\n<p>@Alena : perhaps we could use labels to classify vertices into different “types”?</p>\n</blockquote>\n<p>The vertex labeling version of n-partite is already done using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Coloring#doc\">docs#SimpleGraph.Coloring</a></p>\n<p>The IsBipartite predicate is defined using it: <a href=\"https://github.com/leanprover-community/mathlib4/blob/1a83ec9d7a74f9063014411a530bdbdbb3b86a38/Mathlib/Combinatorics/SimpleGraph/Bipartite.lean#L252\">https://github.com/leanprover-community/mathlib4/blob/1a83ec9d7a74f9063014411a530bdbdbb3b86a38/Mathlib/Combinatorics/SimpleGraph/Bipartite.lean#L252</a></p>\n<p>There's always going to be a tension between using indexed families of types and a projection function from a \"total type\". They're dual to each other.</p>\n</blockquote>\n<p>Yeah that's kind of why I was wondering whether indexed families of types is something we want for our graphs. I'm still inclined to think we might want it, <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> pointed out to me that it could be useful for cographs or if we ever want to work with graded graphs (which I didn't know was a thing, whoops) but one big issue is having graphs with singleton vertex types, or graphs with empty types floating around, etc and the awkward lack of defeqs between them graphs that should be the same</p>",
        "id": 524482323,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1750174990
    },
    {
        "content": "<p>You could maybe impose a nontrivial instance on the types but another problem is the indexing function imposes an ordering on the types, and otherwise identical graphs with different indexing will not be defeq</p>",
        "id": 524482726,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1750175128
    },
    {
        "content": "<p>Which brings me back to the weird sym2 idea, if we have something like that where order doesn't matter we could sort of avoid that problem, if it's built into the definition somehow. But then that might be awkward to work with, and you probably still want an indexing function to be able to put arbitrarily many types</p>",
        "id": 524483108,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1750175251
    },
    {
        "content": "<p>I'll look at the category theory library later today to see what I can learn from it for this stuff, I'm sure someone's already done that before/done work inspired by it but it'll be more for my own understanding of what we can do. Thanks for indulging my train of thought lol</p>",
        "id": 524485391,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1750176023
    }
]