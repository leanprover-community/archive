[
    {
        "content": "<p>I was trying to imagine how a formalization of basics of the theory of sparse graphs (aka sparsity, see these lecture notes: <a href=\"https://www.mimuw.edu.pl/~mp248287/sparsity3/\">https://www.mimuw.edu.pl/~mp248287/sparsity3/</a>) and I realized I don't know what the correct way of stating a property of a graph class is. And the essence of this theory are graph classes, not individual graphs.</p>\n<p>For example, let's look at the notion of degeneracy. I want to say that a graph class is degenerate if there exists d such that every graph in the graph class is degenerate. How this statement should look like with the design of SimpleGraph that each has a separate type for its vertex set?</p>",
        "id": 572312352,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1770364481
    },
    {
        "content": "<p>I think you just define a <code>Set (SimpleGraph V)</code></p>",
        "id": 572319827,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770367158
    },
    {
        "content": "<p>You can also take <code>Set G.Subgraph</code> for a given <code>(G : SimpleGraph V)</code> if you want each member to be able to have a different vertex set (at least until a refactor of <code>SimpleGraph</code> happens that adds vertex sets)</p>",
        "id": 572320728,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770367469
    },
    {
        "content": "<p>Like <code>abbrev sparse1 (d :Nat)  := { G : SimpleGraph V | G.mad \\leq d}</code></p>\n<p>And then you can take <code>(H : sparse d)</code>as an element of this graph in the type theoretic sense</p>",
        "id": 572320756,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770367479
    },
    {
        "content": "<p>It will automatically coerce H to an element of the subtype.</p>",
        "id": 572320803,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770367494
    },
    {
        "content": "<p>Or you can <code>Set (Σ (V : Type*), SimpleGraph V)</code> for maximum generality, though note that a graph class still has to choose a specific universe of types</p>",
        "id": 572320965,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770367542
    },
    {
        "content": "<p>Btw I created a PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/33466\">#33466</a> to refactor digraphs to have vertex sets. It’s still sitting in cold storage. Reason no. (n + 1) to have vertex sets. CC :@<strong>Yaël Dillies</strong></p>",
        "id": 572321158,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770367603
    },
    {
        "content": "<p>If you don't request my review, I won't review it. I forget about things that don't end up in my github notifications</p>",
        "id": 572322103,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1770367866
    },
    {
        "content": "<p>Until then we won’t be able to split a graph class into subclasses of a specific vertex set conveniently. You can use <span class=\"user-mention\" data-user-id=\"933054\">@Snir Broshi</span> ‘s Subgraph trick by setting G to be the  completeGraph. But because of this ugly separation between SimpleGraph and Subgraph you will have issues like last time.</p>",
        "id": 572322133,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770367878
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/252551-graph-theory/topic/reasoning.20about.20graph.20classes/near/572322103\">said</a>:</p>\n<blockquote>\n<p>If you don't request my review, I won't review it. I forget about things that don't end up in my github notifications</p>\n</blockquote>\n<p>Ah sorry. Can I actually explicitly request your review? I thought I had to pick from one of the suggestions. Currently only copilot is suggested for me.</p>",
        "id": 572322393,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770367972
    },
    {
        "content": "<p>Do you not have triage rights? If not, we probably should give them to you!</p>",
        "id": 572322539,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1770368020
    },
    {
        "content": "<p>I don’t think I have any specific rights</p>",
        "id": 572322601,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770368043
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> : I don’t see any option to request reviews to anyone on GitHub other than copilot. So for now I have made a comment tagging you on GitHub</p>",
        "id": 572327604,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770369688
    },
    {
        "content": "<p>To return to Marcin’s question I think we need vertex sets to stratify graph classes by cardinality of vertex sets</p>",
        "id": 572327833,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770369761
    },
    {
        "content": "<p>Yep, that worked. It's in my inbox now</p>",
        "id": 572329381,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1770370244
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/252551-graph-theory/topic/reasoning.20about.20graph.20classes/near/572319827\">said</a>:</p>\n<blockquote>\n<p>I think you just define a <code>Set (SimpleGraph V)</code></p>\n</blockquote>\n<p>It forces me to use the same vertex set in every graph? That won't work, we need infinite graph classes of finite graphs, so the number of vertices is unbounded.</p>",
        "id": 572362350,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1770380394
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/252551-graph-theory/topic/reasoning.20about.20graph.20classes/near/572320728\">said</a>:</p>\n<blockquote>\n<p>You can also take <code>Set G.Subgraph</code> for a given <code>(G : SimpleGraph V)</code> if you want each member to be able to have a different vertex set (at least until a refactor of <code>SimpleGraph</code> happens that adds vertex sets)</p>\n</blockquote>\n<p>Yes, using finite subgraphs of complete (SimpleGraph Nat) would work to some extent, but we will hit annoying problems with for example graph products, where it is natural to label vertices by pairs of vertices of the ingredient of the product. With this, one would probably need to explicitly keep track of some functions relabelling the vertices.</p>",
        "id": 572362716,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1770380507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/252551-graph-theory/topic/reasoning.20about.20graph.20classes/near/572320965\">said</a>:</p>\n<blockquote>\n<p>Or you can <code>Set (Σ (V : Type*), SimpleGraph V)</code> for maximum generality, though note that a graph class still has to choose a specific universe of types</p>\n</blockquote>\n<p>For a moment, this looks good enough :-)</p>\n<p>In graph theory, we usually do not care about \"names\" the vertices have, and treat isomorphic graphs as the same graphs. This is not formally representable in ZFC, because you cannot have a set of all possible vertex sets, so a formal representation needs to restrict the scope of \"labels\" for vertices somehow. I guess this is best we can hope for.</p>",
        "id": 572363051,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1770380596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"972923\">Marcin Pilipczuk</span> <a href=\"#narrow/channel/252551-graph-theory/topic/reasoning.20about.20graph.20classes/near/572363051\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/252551-graph-theory/topic/reasoning.20about.20graph.20classes/near/572320965\">said</a>:</p>\n<blockquote>\n<p>Or you can <code>Set (Σ (V : Type*), SimpleGraph V)</code> for maximum generality, though note that a graph class still has to choose a specific universe of types</p>\n</blockquote>\n<p>For a moment, this looks good enough :-)</p>\n<p>In graph theory, we usually do not care about \"names\" the vertices have, and treat isomorphic graphs as the same graphs. This is not formally representable in ZFC, because you cannot have a set of all possible vertex sets, so a formal representation needs to restrict the scope of \"labels\" for vertices somehow. I guess this is best we can hope for.</p>\n</blockquote>\n<p>This is true in real math, but in formal math you have to deal with explicit types or sets of vertices, and the mess of equivalences and isomorphisms, congruence of properties over isomoprhisms etc.</p>",
        "id": 572364803,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770381150
    },
    {
        "content": "<p>I get your point about being stuck with <code>V</code>. This is why I have been advocating for vertex sets  in SimpleGraph since last year.</p>",
        "id": 572364877,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770381174
    }
]