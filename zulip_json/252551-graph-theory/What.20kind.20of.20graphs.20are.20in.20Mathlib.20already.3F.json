[
    {
        "content": "<p>Hi, I'm trying to figure out which types of graphs are defined already in Mathlib and where to find them, and which ones are not. </p>\n<p>So far, I've seen <code>SimpleGraph</code>, <code>Digraph</code>, and <code>Quiver</code>.  These give rise to two questions.</p>\n<p>1) In the first two definitions, I would have expected that <code>SimpleGraph</code> would extend <code>Digraph</code>, and that things like <code>walk</code> would be defined on <code>Digraph</code>, but that seems not to be the case. Is this just a matter of <code>did not happen yet</code> or is there a rationale behind that? And how does this community go about refactoring efforts - if it is indeed a matter of <code>did not happen yet</code>?</p>\n<p>2) The definition of <code>Quiver</code> is the next step up from <code>Digraph</code> and generalizes <code>Prop</code> to <code>sort</code> as a way of generating different edges between vertices. I understand that this is helpful as a step towards defining <code>Category</code> later, but in some of the graph theoretic work that I encounter considering a MultiGraph (I think it would be called) as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MultiGraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vertex</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Edge</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"n\">source</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Edge</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Vertex</span>\n<span class=\"w\">   </span><span class=\"n\">destination</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Edge</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Vertex</span>\n</code></pre></div>\n<p>seems helpful, in that it seems a lot easier to me when I want to consider all the edges in the graph at the same time. When I use <code>Quiver</code> I always have to first identify the source and destination explicitly, which is sometimes cumbersome. Does that definition (or similar) exist under a different name perhaps? Is there a reason not to have it? And if not to both, should I try setting up a PR for it?</p>",
        "id": 508789911,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743177401
    },
    {
        "content": "<p>Regarding part (1), it is a case of \"nobody did it yet\". It shouldn't be too hard, feel free to do it!</p>",
        "id": 508794612,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1743178617
    },
    {
        "content": "<p>Actually \"nobody did it\" is technically wrong, <span class=\"user-mention\" data-user-id=\"598052\">@Jeremy Tan</span> did it here <a href=\"https://github.com/leanprover-community/mathlib4/pull/16018\">#16018</a>, but that PR got closed and nobody worked on it after that.</p>\n<p>Digraphs are relatively recent compared to simple graphs, and that part is still lacking, I wanted to port parts of simple graph to digraphs but got too busy with other things, I would be happy to help if somebody else starts working on it.</p>\n<p>I think this is worth it because there are a lot of important results on, for instance, tournaments, directed SRGs, flow networks, etc and this part of the library can be the foundation for formalizing them.</p>",
        "id": 508796208,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1743179031
    },
    {
        "content": "<p>cc. <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> regarding point (2).</p>",
        "id": 508797357,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1743179331
    },
    {
        "content": "<p>With 1, it's that it's not necessarily useful to have it literally <code>extend</code> Digraph. If you're thinking about this in terms of object-oriented programming and subtyping, Lean doesn't work the same way. You wouldn't be able to pass a SimpleGraph to a function expecting a Digraph, except in special cases (via dot notation), and you can't use dot notation to make Digraph functions that operate on SimpleGraphs that return SimpleGraphs.</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a> has a <code>class</code>-based approach to unify the API, but as you can see it's quite an old PR. I think I have a branch somewhere with a more updated version, but it might be on my desktop computer...</p>",
        "id": 508801779,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743180556
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I do get that the subtyping doesn't work in exactly the same way, but if the notion of 'walk' was defined on Digraphs, it would automatically be defined on SimpleGraphs, so it would prevent duplication of code - right?</p>\n<p>The tricky part, I think, that in some cases the concepts may generalize, but the proofs would go via a different route. Worse, the formulation of the concepts may be different. For example my question on Multigraphs vs Quivers is an example of that. The two definitions may - up to some details - be equivalent (up to some type-theoretic differences), but the proofs of some theorems will be awkward on one, while going smoothly on the other, and vice versa. In such a situation, people may prefer one basic definition over another, and there is no clear decision anymore on how the inheritance should go.</p>",
        "id": 508806762,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743181617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/508796208\">said</a>:</p>\n<blockquote>\n<p>Actually \"nobody did it\" is technically wrong, <span class=\"user-mention silent\" data-user-id=\"598052\">Jeremy Tan</span> did it here <a href=\"https://github.com/leanprover-community/mathlib4/pull/16018\">#16018</a>, but that PR got closed and nobody worked on it after that.</p>\n<p>Digraphs are relatively recent compared to simple graphs, and that part is still lacking, I wanted to port parts of simple graph to digraphs but got too busy with other things, I would be happy to help if somebody else starts working on it.</p>\n<p>I think this is worth it because there are a lot of important results on, for instance, tournaments, directed SRGs, flow networks, etc and this part of the library can be the foundation for formalizing them.</p>\n</blockquote>\n<p>Hm... that is not too encouraging... hence my question \"how does refactoring work\" in this community? Is there a way to avoid that such an effort \"fails\" (if that is the right word).</p>",
        "id": 508807328,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743181797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"563058\">Pieter Cuijpers</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/508806762\">said</a>:</p>\n<blockquote>\n<p>it would automatically be defined on SimpleGraphs, so it would prevent duplication of code - right?</p>\n</blockquote>\n<p>No, not exactly. If <code>G : SimpleGraph V</code>, you can't write <code>Digraph.Walk G u v</code>. However, the dot notation elaboration would let you write <code>G.Walk u v</code> to get <code>Digraph.Walk G.toDigraph u v</code>.</p>\n<p>The class system I mentioned in the PR I linked to is the way to go to get the unified interface you want (or maybe not done exactly like in the PR, but the general idea). That's how homomorphisms work in mathlib; they have similar issues, since you want, for example, a homomorphism that's both multiplicative and additive to \"be\" a multiplicative homomorphism and an additive homomorphism.</p>",
        "id": 508807469,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743181827
    },
    {
        "content": "<p><code>extends</code> is a very very weak concept, and it's not worth it here I think. That's not to say that no one wants a unified interface for graphs! It's just that <code>extends</code> isn't the correct mechanism.</p>",
        "id": 508807861,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743181951
    },
    {
        "content": "<p><code>extends</code> works a lot better for <code>class</code> than <code>structure</code>, since the parents each give a projection instance, and that simulates the OO-like subtyping. For graphs, what we want are classes that provide the interface for what it means to be a graph with certain kinds of features, and then definitions can make use of these classes. They would not be in terms of a concrete data type.</p>",
        "id": 508807956,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743181983
    },
    {
        "content": "<p>The reason I stopped pursuing <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a> is (1) I wasn't sure about some of the interface I was developing (e.g. should the vertex type of a graph type be allowed to vary with the graph? or does the graph type itself fix the vertex type? I ran into some Lean bugs here, and they might be fixed by now) and (2) I like dot notation and don't want to give it up, which the <code>class</code>-based system requires, and in the meantime I've been working on Lean features to preserve dot notation.</p>",
        "id": 508809125,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743182342
    },
    {
        "content": "<p>I'm a bit lost on why <code>extends</code> does not work on <code>structure</code>, but that aside I think it is indeed the unified interface that I'm looking for, which usually is created either by <code>extends</code> or by an <code>instance</code> theorem (which is also fine with me). And both give the dot notation elaboration, which is I think quite an okay way to achieve the interface we need.</p>\n<p>(I'm probably not enough of a programmer to use all the jargon correctly.)</p>",
        "id": 508809198,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743182362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/508809125\">said</a>:</p>\n<blockquote>\n<p>The reason I stopped pursuing <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a> is (1) I wasn't sure about some of the interface I was developing (e.g. should the vertex type of a graph type be allowed to vary with the graph? or does the graph type itself fix the vertex type? I ran into some Lean bugs here, and they might be fixed by now) and (2) I like dot notation and don't want to give it up, which the <code>class</code>-based system requires, and in the meantime I've been working on Lean features to preserve dot notation.</p>\n</blockquote>\n<p>You have my full support on liking dot notation and prioritizing that :-)</p>\n<p>What you mention about <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a> sounds like the decision between <code>Multigraph</code> as I proposed it above and <code>Quiver</code> as it is in the library to me, or am I mistaken? There may be value to both. And strictly speaking, a Multigraph would be a Quiver, but not necessarily the other way around?</p>",
        "id": 508809943,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743182568
    },
    {
        "content": "<p>I may be overlooking important details here.</p>",
        "id": 508810000,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743182584
    },
    {
        "content": "<blockquote>\n<p>I'm a bit lost on why <code>extends</code> does not work on <code>structure</code></p>\n</blockquote>\n<p>I invite you to experiment here with using <code>extends</code> on <code>structure</code>. It \"works\", but there are some deep usability problems, because you don't get a coercion from <code>SimpleGraph</code> to <code>Digraph</code> that actually works. This is why I point out that it's not like the OO concept of extension — the OO one is how people think it will work, even if they aren't consciously thinking about it that way.</p>\n<p>There's also a fundamental conceptual issue: a simple graph <em>isn't</em> a digraph. Sure, you can model a simple graph as a symmetric irreflexive relation, but that doesn't mean that there are edges going in both directions. For simplicity's sake we may as well take the perspective that simple graphs are digraphs, but I think it's worth keeping this in mind. It has a big impact on how you name functions. E.g., you want the neighbor set of a vertex, right? Is that the set of heads or tails from a given vertex?</p>",
        "id": 508810658,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743182771
    },
    {
        "content": "<blockquote>\n<p>What you mention about <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a> sounds like the decision between <code>Multigraph</code> as I proposed it above and <code>Quiver</code> as it is in the library to me, or am I mistaken?</p>\n</blockquote>\n<p>It's different. With <code>Quiver</code>/<code>MultiGraph</code>, you're putting a fixed structure on a given Vertex and Edge type. With my PR, you have an actual type of graphs under consideration, and each term of that type has a graph structure.</p>\n<p>We care about the lattice structure on SimpleGraph and Digraph for example, and we might have general theorems about it.</p>\n<p>Multigraphs generally don't have a good lattice structure however, so your <code>MultiGraph</code> type could be workable. You just need to keep in mind that you should never have two graphs with the same <code>Vertex</code> and <code>Edge</code> types. (It's possible to have a <code>Multigraph</code> type with a lattice structure; recall that there are two definitions of a multigraph, one is that the edge set is a multiset of unordered pairs, and the other is what you have. That is, indistinguishable vs distinguishable multiedges. They're slightly different, and I think we should be able to support both.)</p>",
        "id": 508811626,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743183062
    },
    {
        "content": "<blockquote>\n<p>You just need to keep in mind that you should never have two graphs with the same <code>Vertex</code> and <code>Edge</code> types</p>\n</blockquote>\n<p>I disagree on this point. For instance, I could remove an edge from multigraph, and add it back somewhere else.</p>",
        "id": 508812021,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743183214
    },
    {
        "content": "<p>What are you disagreeing with? I'm pointing this out as a problem with the arrangement.</p>",
        "id": 508812076,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743183237
    },
    {
        "content": "<p>I interpreted 'should' as a design mandate. If it's not that, I have no disagreement.</p>",
        "id": 508812181,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743183265
    },
    {
        "content": "<p>It's a \"should\" as in \"class instances are supposed to be canonical, so you shouldn't violate that\"</p>",
        "id": 508812264,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743183299
    },
    {
        "content": "<p>This goes against the design of matroids that seems to be working very well - for instance, operations like truncation, and results like the matroid intersection theorem, use different matroids on the same ground set (type).</p>",
        "id": 508812509,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743183378
    },
    {
        "content": "<p>Ah, the difference is the 'class' part.</p>",
        "id": 508812624,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743183422
    },
    {
        "content": "<p>Yes, I'm saying why the <code>MultiGraph</code> class from the beginning of this thread has some difficulties. It's workable, and I'm sure it's great for certain applications, but it's not necessarily what everyone would want.</p>",
        "id": 508812740,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743183473
    },
    {
        "content": "<p>We want a <code>class</code> (or a system of <code>classe</code>es) that describes a generic <code>Multigraph</code> interface. Concrete implementations of multigraphs would then implement these classes, and each person can use their favorite kind of multigraph with the generic library.</p>",
        "id": 508813063,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743183588
    },
    {
        "content": "<p>Got that, but I would be fine with making <code>MultiGraph</code> a <code>structure</code> as well. I was not aware of a cannonical \"<code>lattice</code> of <code>Digraph</code>s\", but it makes sense to consider it as a structure too.</p>",
        "id": 508813173,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743183617
    },
    {
        "content": "<p><code>Digraph V</code> and <code>SimpleGraph V</code> have lattice structures, via edge containment</p>",
        "id": 508813345,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743183674
    },
    {
        "content": "<p>The plan my student and I have at the moment is something like the following: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"c1\">-- vertex set</span>\n<span class=\"w\">  </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"c1\">-- edge set</span>\n<span class=\"w\">  </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"c1\">-- edge-vertex incidence</span>\n<span class=\"w\">  </span><span class=\"n\">Inc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">vertex_support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">edge_support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">E</span>\n<span class=\"c1\">-- extra propositional stuff, such as the fact that each edge is incident with at most two vertices.</span>\n</code></pre></div>",
        "id": 508815226,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743184318
    },
    {
        "content": "<p>This uses the 'embedded set' design that has worked well for matroids. I am growing more and more convinced that this will be the best way to formalize real-world proofs involving minors. </p>\n<p>If contracting an edge of a graph forces passing to a new graph with a different vertex type, then any vaguely complicated 'contract an edge, apply induction'-type proof will descend to DTT hell.</p>",
        "id": 508815769,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743184486
    },
    {
        "content": "<p>Seems reasonable. I think this basically what's in <a href=\"https://link.springer.com/chapter/10.1007/3-540-58450-1_40\">https://link.springer.com/chapter/10.1007/3-540-58450-1_40</a>, but with types for the elements of the V and E sets. (I can't check right now.)</p>",
        "id": 508816244,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743184636
    },
    {
        "content": "<p>Here's another definition I experimented with: <a href=\"https://github.com/leanprover-community/mathlib3/blob/3c940418e050f85795b91778aa17fdf7c354c700/src/combinatorics/multigraph/basic.lean#L58-L60\">https://github.com/leanprover-community/mathlib3/blob/3c940418e050f85795b91778aa17fdf7c354c700/src/combinatorics/multigraph/basic.lean#L58-L60</a></p>\n<p>I think it might be equivalent; it uses, basically, a set of triples <code>V x V x E</code> that's symmetric in the first two components, rather than an Inc relation.</p>",
        "id": 508816642,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743184771
    },
    {
        "content": "<p>(As always, you'll have to decide how you want to define the degree of a vertex that has a loop. The topologist in me wants it to be 2, but with all these proposals the easiest answer is 1.)</p>",
        "id": 508817259,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743184945
    },
    {
        "content": "<p>It's 2!</p>",
        "id": 508817285,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743184953
    },
    {
        "content": "<p>(Provided you want a handshake theorem, at least)</p>",
        "id": 508818343,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743185265
    },
    {
        "content": "<p>(and nice linear algebra over Z2)</p>",
        "id": 508818914,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743185448
    },
    {
        "content": "<p>How do you define degree to get 2 though?</p>",
        "id": 508818939,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743185459
    },
    {
        "content": "<p>edit : nevermind</p>",
        "id": 508820205,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743185854
    },
    {
        "content": "<p>Yeah, it's annoying. Define a function <code>f</code> from edges to Sym2; then the degree of a vertex is obtained by the sum over <code>e</code> of the sum over <code>f e</code> of an indicator function.</p>",
        "id": 508825737,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743187830
    },
    {
        "content": "<p>But the rewards are obvious!</p>",
        "id": 508826050,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743187932
    },
    {
        "content": "<p>This might be look a bit heavy-handed, but I think it works.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→₀</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"n\">sum_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"n\">vertex_support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">edge_support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">E</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">IsLoopAt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">IsNonloopAt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 508834932,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743191309
    },
    {
        "content": "<p>The handshake theorem should naturally be true with no fussing with loops, and I think even contractions will work nicely.</p>",
        "id": 508835125,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743191397
    },
    {
        "content": "<p>What is <code>sum_eq : ∀ e ∈ E, (inc e).sum (fun _ x ↦ x) = 2</code> for?</p>",
        "id": 508835272,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743191454
    },
    {
        "content": "<p>Why not just have <code>inc : β → Sym2 α</code> instead?</p>",
        "id": 508835530,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743191566
    },
    {
        "content": "<p>The sum of the incidences for the vertices at each edge e is either 1+1=2 (for a nonloop e) or 2=2 (for a loop e)</p>",
        "id": 508835531,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743191566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/508835530\">said</a>:</p>\n<blockquote>\n<p>Why not just have <code>inc : β → Sym2 α</code> instead?</p>\n</blockquote>\n<p>Because that will be ugly for nonelements of <code>E</code>.</p>",
        "id": 508835618,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743191615
    },
    {
        "content": "<p>(In my opinion) the design should allow for deleting edges in a <code>Graph a b</code> to get  another <code>Graph a b</code>, without changing the edge type.</p>",
        "id": 508835762,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743191675
    },
    {
        "content": "<p>You could also go hypergraph and drop it and then edges connect arbitrarily many vertices</p>",
        "id": 508835988,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743191799
    },
    {
        "content": "<p>You can also allow for digraphs by having the incidence function be <code>Int</code>-valued (plus or minus 1) and summing absolute values.</p>",
        "id": 508836158,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743191879
    },
    {
        "content": "<p>The annoyance is that this will require Decidable in places that Prop-valued predicates won’t</p>",
        "id": 508840335,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743193584
    },
    {
        "content": "<p>I believe there is no way to avoid the decidability assumption in the following : </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">edgeDel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">D</span>\n<span class=\"w\">  </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"n\">sum_eq</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">he</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">he</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">sum_eq</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">he</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">vertex_support</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">vertex_support</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span>\n<span class=\"w\">  </span><span class=\"n\">edge_support</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edge_support</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 508911096,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743245433
    },
    {
        "content": "<p>Ok, I was wrong; you can make it mostly invisible this way. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">edgeDel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">D</span>\n<span class=\"w\">  </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">dec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"n\">sum_eq</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">he</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">he</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">sum_eq</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">he</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">vertex_support</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">vertex_support</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span>\n<span class=\"w\">  </span><span class=\"n\">edge_support</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edge_support</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 508911869,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743246024
    },
    {
        "content": "<p><a href=\"https://github.com/Jun2M/Kura/blob/master/Kura/FinsuppGraph.lean\">This file</a> uses the above to define multigraphs, edge deletions, extensionality with prop-valued incidence, loops, nonloops, images under maps that merge vertices, and the handshake theorem (with no special-casing for loops) in just over 200 lines.</p>",
        "id": 508952840,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743277816
    },
    {
        "content": "<p>Ahh! The discussion is spiralling in quite a different direction then I would have expected, but it does give me some answer as to why there is no clear-cut definition yet <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> . I was just being happily naive.</p>",
        "id": 509155081,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743415725
    },
    {
        "content": "<p>But why the explicit addition of having sets of vertices and edges?<br>\nWould something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">whatever</span><span class=\"w\"> </span><span class=\"n\">needs</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">here</span>\n</code></pre></div>\n<p>already give you enough structure to work with?</p>\n<p>From the remarks you're making, you have experience with how the proofs will go further down the line.<br>\nI'm trying to understand why you make the choices the way you do here.</p>",
        "id": 509159401,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743417019
    },
    {
        "content": "<p>Yes, there is a reasonable discussion to be had about design here, and on this matter I’m expressing one particular point of view, which is informed by my work on matroids. I discuss this at length in this post: <a href=\"#narrow/stream/287929-mathlib4/topic/The.20design.20of.20matroids\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/The.20design.20of.20matroids</a></p>\n<p>The issues in graph theory aren’t the same, but the analogies are there.</p>\n<p>The shorter version: in real-world graph theory proofs, you might do something like contract an edge <code>e</code>, delete a vertex <code>x</code>, and consider the role of a vertex <code>v</code> and a path <code>P</code>, before and after the contractions and deletions were performed. If the graphs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>−</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">G-x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">/</mi><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">G / e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">e</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>G</mi><mo>−</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">(G-x)/e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">e</span></span></span></span> are all modeled using different types, then there are already four ‘versions’ of <code>v</code> and <code>P</code>, related by a mess of invisible canonical maps. The more involved the proof, the worse this picture gets, and in my opinion this is a road to disaster.</p>\n<p>To avoid this, you want the four graphs to have the same type. I don’t know a better choice for this type than simply  <code>Graph a b</code> with vertex and edge sets as structure fields.</p>",
        "id": 509163629,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743418215
    },
    {
        "content": "<p>I see. Would there, alternatively, be a way to turn the bookkeeping over all these invisible canonical maps into a tactic?</p>\n<p>Personally, I like it when the definitions are kept as simple as possible, sometimes at the cost of a bit of bookkeeping in the proofs. In my work on process algebras (computer science) the bookkeeping is usually unavoidable, which is the very reason I like theorem provers. They do that bookkeeping for me. But it's only fun if it remains readable indeed.</p>",
        "id": 509171032,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743420174
    },
    {
        "content": "<p>I see that in the other discussion, there were also people who usually have fixed graphs they are studying, in which case my definition seems preferable.</p>",
        "id": 509171442,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743420297
    },
    {
        "content": "<p>Perhaps there is a general trend here... \"fixed structures\" versus \"mutable structures\", requiring different definitions even while they belong to the same branch of mathematics.</p>",
        "id": 509171625,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743420362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/509163629\">said</a>:</p>\n<blockquote>\n<p>To avoid this, you want the four graphs to have the same type. I don’t know a better choice for this type than simply  <code>Graph a b</code> with vertex and edge sets as structure fields.</p>\n</blockquote>\n<p>You could bundle the type, so you have <code>Graph.{v, u} : Type max u v</code>, and for <code>g : Graph</code> you would talk about <code>g.Vertex</code> and <code>g.Edge</code>.</p>",
        "id": 509172090,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743420494
    },
    {
        "content": "<p>Maybe a bookkeeping tactic is possible. But it is hard to even precisely delineate the intended scope of such a tactic,  and often it is the <em>statements</em> rather than the proofs of theorems that become horrible. Think about statements of the form 'minor operations commute' for example. </p>\n<p>In my approach, the bookkeeping tactic needed is one that is capable of proving using existing assumptions that things are 'real' vertices and edges (members of <code>G.V</code> and <code>G.E</code> respectively). This is much more limited in scope, and can be implemented in practice. </p>\n<p>Also, the model where the edges and vertices are types are easy to describe in terms of the more general one. Have propositional typeclasses <code>[FullVertex G]</code> and <code>[FullEdge G]</code> for <code>G : Graph a b</code> that state <code>G.V = Set.univ</code> and <code>G.E = Set.univ</code>. A lot of the API can be shared with the general case, and there can be specialized sugar API for the <code>FullVertex</code>/<code>FullEdge</code> cases where it is needed.</p>",
        "id": 509173058,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743420779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/509172090\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/509163629\">said</a>:</p>\n<blockquote>\n<p>To avoid this, you want the four graphs to have the same type. I don’t know a better choice for this type than simply  <code>Graph a b</code> with vertex and edge sets as structure fields.</p>\n</blockquote>\n<p>You could bundle the type, so you have <code>Graph.{v, u} : Type max u v</code>, and for <code>g : Graph</code> you would talk about <code>g.Vertex</code> and <code>g.Edge</code>.</p>\n</blockquote>\n<p>If I remove a vertex <code>v</code>, then how do the types <code>G.vertex</code> and <code>(G-v).vertex</code> relate?</p>",
        "id": 509173674,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743420961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/509173058\">said</a>:</p>\n<blockquote>\n<p>Think about statements of the form 'minor operations commute' for example. </p>\n</blockquote>\n<p>This seems relatively pain-free to write out, what problem are you seeing?</p>",
        "id": 509173756,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743420973
    },
    {
        "content": "<p>Suppose I have two edges <code>e, f</code>, and I want to contract them in one order versus another. How do I state that I have 'the same' graph both ways?</p>",
        "id": 509173999,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743421042
    },
    {
        "content": "<p>This is a <code>def contractCommIso : (g.contract e).contract (map (contractGraphHom g e) f) ≃g (g.contract f).contract (map (contractGraphHom g f) e)</code></p>",
        "id": 509174705,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743421212
    },
    {
        "content": "<p>hmmm, this turned out longer than I thought it would be</p>",
        "id": 509174821,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743421247
    },
    {
        "content": "<p>And it's the beginning of DTT hell. Now you are pushing forward paths along that map, taking initial subsegments of the paths, etc etc.</p>",
        "id": 509174906,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743421272
    },
    {
        "content": "<p>It should be an <code>=</code> if at all possible, and for this example, <code>=</code> is possible.</p>",
        "id": 509175035,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743421306
    },
    {
        "content": "<p>I don't see how using <code>=</code> makes it any better though...</p>",
        "id": 509175239,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743421352
    },
    {
        "content": "<p>It means that pushforward/pullback API stops being API, and becomes <code>rw</code>.</p>",
        "id": 509175573,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743421445
    },
    {
        "content": "<p>(newb question: what is DTT?)</p>",
        "id": 509177435,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743421942
    },
    {
        "content": "<p>Dependent type theory.</p>",
        "id": 509177512,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743421964
    },
    {
        "content": "<p>To give a concrete example on this point, I was recently looking at the definition <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Subgraph.Connected#doc\">docs#SimpleGraph.Subgraph.Connected</a> . There is roughly 500 lines of API for it (and it's still incomplete), even though it is just <code>SimpleGraph.Connected</code> modulo some mathematically invisible maps. </p>\n<p>If the vertex set for <code>SimpleGraph</code> were a<code>Set</code>, there would have been no need to have separate <code>SimpleGraph</code> and <code>Subgraph</code> types at all, and this kind of API nearly disappears.</p>",
        "id": 509989148,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743698525
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/24122\">#24122</a></p>",
        "id": 512685881,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744837520
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/stream/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/508911096\">said</a>:</p>\n<blockquote>\n<p>I believe there is no way to avoid the decidability assumption in the following : </p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">edgeDel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">D</span>\n<span class=\"w\">  </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"n\">sum_eq</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">he</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">he</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">sum_eq</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">he</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">vertex_support</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">vertex_support</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span>\n<span class=\"w\">  </span><span class=\"n\">edge_support</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edge_support</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"bp\">⟩</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I don't see any harm in keeping it? Decidability isn't inherently evil, but inserting Classical.decEq can cripple <code>decide</code> and <code>#eval</code> downstream</p>",
        "id": 516191033,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746450355
    },
    {
        "content": "<p>I was thinking about definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Graph#doc\">docs#Graph</a> specifically for application in minors. I feel like the definition still isn't good for that purpose, as this doesn't allow for a natural definition of contraction. I think, to be able to define contraction, we would want <code>Quotient α</code>, and to allow contraction and subgraphs, probably <code>Set (Quotient α)</code> (I don't think we have partial quotient in mathlib?).<br>\nWith just <code>Set</code> you need to arbitrarily chose one of two vertices to keep.</p>",
        "id": 562585582,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765244173
    },
    {
        "content": "<p>I think there is a case to be made that choosing one of the two ends as the contracted vertex is natural, a la retracts in topology. What practical issues do you see with defining a minor this way?</p>\n<p>I am concerned that quotients, which change the vertex type every time an edge is contracted, will just be too hard to work with.</p>",
        "id": 562605286,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765260486
    },
    {
        "content": "<p>One problem with using <code>Quotient</code> directly is that you will end up in a situation where you quotient and then remove a vertex and will get a type which is canonically isomorophic, but not equal, to the type you get by removing a vertex and then quotienting. This is constant problem when doing graph theory in Lean's dependent type theory. Another example: quotienting to identify a and b, and then quotienting again to identify c and d, will not be equal to quotienting to identify c and d, and then a and b. </p>\n<p>It almost feels like one needs different definitions of graphs depending on what you want to do with them, but this would very much go against Mathlib's design principles (\"one definition for everything\"). Perhaps Peter's suggestion is worth experimenting with.</p>",
        "id": 562636528,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765273207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562636528\">said</a>:</p>\n<blockquote>\n<p>quotienting to identify a and b, and then quotienting again to identify c and d, will not be equal to quotienting to identify c and d, and then a and b.</p>\n</blockquote>\n<p>This will result in a different relation, but orbits will be the same in both cases. And equality of functions is pointwise in Lean, so actually both relations would be equal.</p>",
        "id": 562667758,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765282270
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562605286\">said</a>:</p>\n<blockquote>\n<p>What practical issues do you see with defining a minor this way?</p>\n</blockquote>\n<p>I'm not sure if this would result in practical issues or not. I was thinking about the case, where you have a graph <code>G</code>, its vertex <code>v</code>, and its minor <code>G'</code>. Now, you want to get the vertex in <code>G'</code> that came from <code>v</code>. With Set approach, you would have to go through each contraction one-by-one, check if one of the contracted vertices is <code>v</code>, and choose the correct one of two. With Quotient approach you would take representative of a class of <code>v</code>, and take its class in <code>G'</code>. In other words, the difference is, that Quotient doesn't forget either of the two contracted vertices. But of course, this operation of taking vertex from a graph to its minor can be implemented as part of API, so I don't know it this is a practical issue or not.</p>",
        "id": 562669497,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765282820
    },
    {
        "content": "<p>Actually, maybe it is a problem, because, where would you get the list of contracted pairs from, in a Set approach?</p>",
        "id": 562669849,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765282908
    },
    {
        "content": "<p>You would have to define another type for minors, to keep the list of contractions around, and now we again have the same problem as with Subgraph, that the type of minors is different than that of an original graph.</p>",
        "id": 562670218,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765283024
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562636528\">said</a>:</p>\n<blockquote>\n<p>It almost feels like one needs different definitions of graphs depending on what you want to do with them.</p>\n</blockquote>\n<p>Indeed. One other useful graph operation, is duplicating the vertex in two. To support that, and keep the same type for the graph, we probably want to have Multiset, insteaf of a Set. (though, Multiset is finite, is there an infinite Multiset in mathlib?)</p>",
        "id": 562671390,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765283356
    },
    {
        "content": "<p>One could probably come with something else, that would require adjusting definition of a Graph further. So maybe, adjusting the definition of a graph to suit all the operations any graph theorist would ever need is not feasible approach? And instead we should learn how to design the API to work with different types of graph.</p>",
        "id": 562672279,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765283644
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562605286\">said</a>:</p>\n<blockquote>\n<p>I am concerned that quotients, which change the vertex type every time an edge is contracted, will just be too hard to work with.</p>\n</blockquote>\n<p>You can't really take a vertex from a graph and treat it like it's a vertex of its minor anyway. Actually, maybe having different type would even be helpful, cause it would avoid doing accidental confusion like this.</p>",
        "id": 562674200,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765284219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562674200\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562605286\">said</a>:</p>\n<blockquote>\n<p>I am concerned that quotients, which change the vertex type every time an edge is contracted, will just be too hard to work with.</p>\n</blockquote>\n<p>You can't really take a vertex from a graph and treat it like it's a vertex of its minor anyway. Actually, maybe having different type would even be helpful, cause it would avoid doing accidental confusion like this.</p>\n</blockquote>\n<p>This kind of thing is quite common - see Lemma 3.2.4 from Diestel’s book, for example: <a href=\"https://www.math.uni-hamburg.de/home/diestel/books/graph.theory/preview/Ch3.pdf\">https://www.math.uni-hamburg.de/home/diestel/books/graph.theory/preview/Ch3.pdf</a></p>\n<p>Of course one needs a proof that the vertex of the minor is actually there in the graph, but in many contexts this will be clear, such as when it is neither end of a single contracted edge.</p>",
        "id": 562709896,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765292821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562669497\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562605286\">said</a>:</p>\n<blockquote>\n<p>What practical issues do you see with defining a minor this way?</p>\n</blockquote>\n<p>I'm not sure if this would result in practical issues or not. I was thinking about the case, where you have a graph <code>G</code>, its vertex <code>v</code>, and its minor <code>G'</code>. Now, you want to get the vertex in <code>G'</code> that came from <code>v</code>. With Set approach, you would have to go through each contraction one-by-one, check if one of the contracted vertices is <code>v</code>, and choose the correct one of two. With Quotient approach you would take representative of a class of <code>v</code>, and take its class in <code>G'</code>. In other words, the difference is, that Quotient doesn't forget either of the two contracted vertices. But of course, this operation of taking vertex from a graph to its minor can be implemented as part of API, so I don't know it this is a practical issue or not.</p>\n</blockquote>\n<p>You don’t need to do anything one by one. If H is a minor of G in my sense, then there is an associated idempotent function from V to V that says where every vertex of G ends up, and is the identity on V(H).</p>\n<p>In practice, the cost of changing types when taking minors is huge. (I learnt this from working with matroids, even though their minor operation is less technical - I experienced a lot of pain before switching designs). The <code>Set</code> approach allows for actual DTT-free <code>Eq</code> looking at a graph G and all sorts of mutations of G, whether they be minors or something else. It comes with tradeoffs, of course, but this advantage is substantial.</p>",
        "id": 562713305,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765293513
    },
    {
        "content": "<p>Vertex duplication, which you bring up, is a little more annoying, but can be done without changing types if one adds an assumption that the vertex set of G is not the whole vertex type. So <code>G.Dup u v</code> creates a copy of vertex <code>u</code> with label <code>v</code>,  and behaves well if it is known that <code>v</code> is not a member of  <code>V(G)</code>.</p>",
        "id": 562714761,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765293807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562709896\">said</a>:</p>\n<blockquote>\n<p>Of course one needs a proof that the vertex of the minor is actually there in the graph, but in many contexts this will be clear, such as when it is neither end of a single contracted edge.</p>\n</blockquote>\n<p><del>Yes, but when neither vertex is an end of a single contracted edge, then you get equality of elements in the Quotient approach too.</del><br>\nAh, nvm, I see, you're point is that these are different types, because there are elements of Quotient with different Setoid.</p>",
        "id": 562721739,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765295226
    },
    {
        "content": "<p>Hmm, maybe then, instead of using Quotient, we should use sets as vertices (and these sets would represent equivalence classes). Or Finset or Multiset?</p>",
        "id": 562722914,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765295464
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 562724402,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765295770
    },
    {
        "content": "<p>Forcing vertices to be sets works, and gives canonical contraction, but leads to weird syntax and theorem statements, and awkward things like enforcing disjointness. I think that the way to go is allowing an arbitrary vertex type with a more permissive notion of contraction, that allows for a notion of contraction the setting where vertices are secretly sets , as well as a retraction-like one where you pick an end of the edge.</p>\n<p>My student <span class=\"user-mention\" data-user-id=\"479089\">@Jun Kwon</span> has been working on this, and has been quite successful in working with nontrivial proofs involving minors.</p>",
        "id": 562726389,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765296133
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562726389\">said</a>:</p>\n<blockquote>\n<p>My student <span class=\"user-mention silent\" data-user-id=\"479089\">Jun Kwon</span> has been working on this, and has been quite successful in working with nontrivial proofs involving minors.</p>\n</blockquote>\n<p>That's interesting. Which of the two approaches to contraction does he work with?</p>",
        "id": 562727533,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765296365
    },
    {
        "content": "<p>I’m not sure exactly where he is at with definitions at this minute, so I’ll let him weigh in. He is certainly more familiar than me with the practical issues here.</p>",
        "id": 562727774,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765296413
    },
    {
        "content": "<p>I also have a question, was such definition considered?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">isLink_symm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Symmetric</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">eq_or_eq_of_isLink_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">w</span>\n</code></pre></div>",
        "id": 562731592,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765297166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562727533\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562726389\">said</a>:</p>\n<blockquote>\n<p>My student <span class=\"user-mention silent\" data-user-id=\"479089\">Jun Kwon</span> has been working on this, and has been quite successful in working with nontrivial proofs involving minors.</p>\n</blockquote>\n<p>That's interesting. Which of the two approaches to contraction does he work with?</p>\n</blockquote>\n<p>Hi! The different ways to contact has been a bit of a headache. I am working to support both ways if possible. That is, if you do not have assumptions available,  then you can contract by specifying the vertex choice, but if you have more assumptions that allow a canonical contraction, you can do that too.</p>",
        "id": 562742062,
        "sender_full_name": "Jun Kwon",
        "timestamp": 1765299405
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562731592\">said</a>:</p>\n<blockquote>\n<p>I also have a question, was such definition considered?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">isLink_symm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Symmetric</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">eq_or_eq_of_isLink_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">w</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Are you thinking that every object of type V is a real vertex? Otherwise, how do you distinguish an isolated vertices with non-existent one?</p>",
        "id": 562742460,
        "sender_full_name": "Jun Kwon",
        "timestamp": 1765299493
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479089\">Jun Kwon</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562742460\">said</a>:</p>\n<blockquote>\n<p>Are you thinking that every object of type V is a real vertex? Otherwise, how do you distinguish an isolated vertices with non-existent one?</p>\n</blockquote>\n<p>Yes,  every object of type V is a vertex. Buy you can have <code>V : Set α</code> if you want to be able to remove vertices.</p>",
        "id": 562744094,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765299841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562744094\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"479089\">Jun Kwon</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562742460\">said</a>:</p>\n<blockquote>\n<p>Are you thinking that every object of type V is a real vertex? Otherwise, how do you distinguish an isolated vertices with non-existent one?</p>\n</blockquote>\n<p>Yes,  every object of type V is a vertex. Buy you can have <code>V : Set α</code> if you want to be able to remove vertices.</p>\n</blockquote>\n<p>In that case the edge relation becomes <code>E -&gt; Set α -&gt; Set α -&gt; Prop</code></p>",
        "id": 562745607,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765300162
    },
    {
        "content": "<p>I think here <code>V : Set a</code> doesn’t mean the vertices are sets, it means the vertex set is modelled as a set within a type</p>",
        "id": 562746069,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765300254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562745607\">said</a>:</p>\n<blockquote>\n<p>In that case the edge relation becomes <code>E -&gt; Set α -&gt; Set α -&gt; Prop</code></p>\n</blockquote>\n<p>No, that would happen if you take <code>V = Set α</code>. I meant <code>V : Set α</code>.</p>",
        "id": 562747431,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765300535
    },
    {
        "content": "<p>I don't think we tried with types as a structure field as supposed to an argument. My guess would be that this definition would require talking about functions, homomorphisms and isomorphisms everywhere.</p>",
        "id": 562749530,
        "sender_full_name": "Jun Kwon",
        "timestamp": 1765301016
    },
    {
        "content": "<p>Yes, equality of graphs would then involve ‘evil’  equality of types.</p>",
        "id": 562749851,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765301079
    },
    {
        "content": "<p>That looks interesting, I might try and explore this further then.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">GraphV2</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">isLink_symm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Symmetric</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">eq_or_eq_of_isLink_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">w</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">Of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">V_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">E_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">E</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">Of</span><span class=\"bp\">.</span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hOf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Of</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hOf</span><span class=\"bp\">.</span><span class=\"n\">E_eq</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hOf</span><span class=\"bp\">.</span><span class=\"n\">V_eq</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hOf</span><span class=\"bp\">.</span><span class=\"n\">V_eq</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">Of</span><span class=\"bp\">.</span><span class=\"n\">IsLinkSet</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hOf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Of</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">he</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hOf</span><span class=\"bp\">.</span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">he</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">IsSubgraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G'</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">of_set_set</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V'</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E'</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hOf'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G'</span><span class=\"bp\">.</span><span class=\"n\">Of</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"w\"> </span><span class=\"n\">E'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hOf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Of</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">verts_subset</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">edges_subset</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E'</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">isLink_impl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">hOf'</span><span class=\"bp\">.</span><span class=\"n\">IsLinkSet</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">hOf</span><span class=\"bp\">.</span><span class=\"n\">IsLinkSet</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSubgraph</span><span class=\"w\"> </span><span class=\"n\">G'</span><span class=\"w\"> </span><span class=\"n\">G</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">of_set_type</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hOf'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G'</span><span class=\"bp\">.</span><span class=\"n\">Of</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"w\"> </span><span class=\"n\">E'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hOf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Of</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">isLink_impl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">hOf'</span><span class=\"bp\">.</span><span class=\"n\">IsLinkSet</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">hOf</span><span class=\"bp\">.</span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSubgraph</span><span class=\"w\"> </span><span class=\"n\">G'</span><span class=\"w\"> </span><span class=\"n\">G</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">of_type_type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hOf'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G'</span><span class=\"bp\">.</span><span class=\"n\">Of</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hOf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Of</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">isLink_impl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">hOf'</span><span class=\"bp\">.</span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">hOf</span><span class=\"bp\">.</span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSubgraph</span><span class=\"w\"> </span><span class=\"n\">G'</span><span class=\"w\"> </span><span class=\"n\">G</span>\n</code></pre></div>",
        "id": 562752589,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765301685
    },
    {
        "content": "<p>I think your type structure fields are setting you up for DTT hell.</p>",
        "id": 562753117,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765301813
    },
    {
        "content": "<p>My hope for that approach is that, we can hide DTT hell inside couple API functions and not have it be exposed.</p>",
        "id": 562754201,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765302088
    },
    {
        "content": "<p>Say you have vertices <code>x</code>,<code>y</code> of <code>G</code>. How do you express the fact that <code>(G - x) - y = (G - y) - x</code>?</p>",
        "id": 562754453,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765302149
    },
    {
        "content": "<p>Can I ask if you are trying this def just cause or if you have a clear benefit over other defs in mind?</p>",
        "id": 562754883,
        "sender_full_name": "Jun Kwon",
        "timestamp": 1765302246
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479089\">Jun Kwon</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562754883\">said</a>:</p>\n<blockquote>\n<p>Can I ask if you are trying this def just cause or if you have a clear benefit over other defs in mind?</p>\n</blockquote>\n<p>My concern is that, different types of graph might be needed for different operations you would want to be able to do with the graph. I want to have one type for graph that would be flexible, and allow all operations under one graph type.</p>",
        "id": 562755821,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765302485
    },
    {
        "content": "<p>Can you provide examples of the operations you mean?</p>",
        "id": 562758471,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765303162
    },
    {
        "content": "<p>E.g. duplicating a vertex. An operation, where you take a vertex of a graph, and you create a new graph by duplicating said vertex, and all incident edges. And there are two possible versions of this operation, depending on whether you also add an edge between duplicated vertices, or not.</p>",
        "id": 562759776,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765303461
    },
    {
        "content": "<p>Or an operation, where you add a completely new vertex, connected to every other vertex.</p>",
        "id": 562760116,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765303540
    },
    {
        "content": "<p>I think the subgraph definition above is not transitive. For a type a, and some subtype of a, a', and some subtype of a', a'', a graph over a'' can be a subgraph of a graph over a' by 'of_set_type' and that graph over a' can be a subgraph over a. However, a graph over a'' can't be a subgraph of one over a.</p>",
        "id": 562760235,
        "sender_full_name": "Jun Kwon",
        "timestamp": 1765303570
    },
    {
        "content": "<p>In my experience, if you are adding a new vertex <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> to a graph <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> by cloning/apexing as you describe (say to get a graph <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">G&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span>), then you are probably very interested in the fact that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>−</mo><mi>v</mi><mo>=</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G&#x27; - v = G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8352em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>. If that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">=</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">=</span></span></span></span> is not an <code>=</code>, then you are already in a very annoying place.</p>",
        "id": 562760597,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765303665
    },
    {
        "content": "<p>In any case, if the vertices are a type, it should still be before the colon rather than a structure field. So adding a new vertex would take <code>Graph V E</code> to <code>Graph (Option V) E</code> or whatever. This allows equality of graphs to be non-evil.</p>",
        "id": 562761065,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765303774
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562761065\">said</a>:</p>\n<blockquote>\n<p>In any case, if the vertices are a type, it should still be before the colon rather than a structure field. So adding a new vertex would take <code>Graph V E</code> to <code>Graph (Option V) E</code> or whatever. This allows equality of graphs to be non-evil.</p>\n</blockquote>\n<p>But that would mean that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>−</mo><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">G&#x27; - v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8352em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> have different types.</p>",
        "id": 562769893,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765305914
    },
    {
        "content": "<p>I don't think <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>−</mo><mi>v</mi><mo>=</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G&#x27; - v = G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8352em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> with equality is possible, unless you provide unused vertex when constructing <code>G'</code>.</p>",
        "id": 562770142,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765305979
    },
    {
        "content": "<p>I think hypothesizing an unused vertex is fine in a lemma statement, and will be easier to work with in a proof. A version with <code>Option V</code> can be derived from the unused vertex version at an essentially cosmetic level.</p>",
        "id": 562771904,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765306460
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562769893\">said</a>:</p>\n<blockquote>\n<p>But that would mean that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>−</mo><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">G&#x27; - v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8352em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> have different types.</p>\n</blockquote>\n<p>I am not sure I see the advantage in them having the same type, when the types in the structure fields are different.</p>",
        "id": 562772206,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1765306540
    },
    {
        "content": "<p>The symmetry of having to provide a vertex when either contracting an edge or duplicating a vertex is nice<br>\nI think having slightly awkward operations is better than dealing with <code>HEq</code></p>",
        "id": 562776762,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1765307745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/562771904\">said</a>:</p>\n<blockquote>\n<p>I think hypothesizing an unused vertex is fine in a lemma statement, and will be easier to work with in a proof.</p>\n</blockquote>\n<p>Yeah, I think it sounds promising. For finite graphs, you can work with <code>[Infinite α]</code> to always be able to find a free new vertex.</p>",
        "id": 563319322,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765510737
    },
    {
        "content": "<p>Are there plans to support a directed graph version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Graph#doc\">docs#Graph</a> ?</p>\n<p>Context: I want to prove the correctness of graph algorithms that use adjacency lists, but I've been exhausted by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quiver#doc\">docs#Quiver</a>. <span aria-label=\"melt\" class=\"emoji emoji-1fae0\" role=\"img\" title=\"melt\">:melt:</span></p>",
        "id": 565949241,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1767238216
    },
    {
        "content": "<p>for most graph algorithms <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Digraph#doc\">docs#Digraph</a> is sufficient</p>",
        "id": 565949806,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767239251
    },
    {
        "content": "<p>secondly, once you put enough finiteness conditions, you can get <code>neighborFinset</code> for a <code>SimpleGraph</code>. I'd suggest borrowing that definition and defining <code>outNeighborFinset</code> and <code>inNeighborFinset</code> for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Digraph#doc\">docs#Digraph</a> _almost_  identically</p>",
        "id": 565949855,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767239329
    },
    {
        "content": "<p>From that finset, you can get the list of vertices</p>",
        "id": 565949857,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767239336
    },
    {
        "content": "<p>To be precise, I am verifying algorithm implementations that are suitable for actual execution. There is naturally already an edge type <code>β</code> that contains some data. So it feels like an API similar to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Graph#doc\">docs#Graph</a> would be more convenient?</p>",
        "id": 565952185,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1767242792
    },
    {
        "content": "<p><del>Maybe we should define <code>Digraph'</code> in a similar fashion as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Graph#doc\">docs#Graph</a> (with sets), and have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Graph#doc\">docs#Graph</a> extend <code>Digraph'</code>?</del><br>\nAh, no, that won't work.</p>",
        "id": 565978373,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767274134
    },
    {
        "content": "<p>Why not change <code>Digraph</code> itself? Right now, it is a (IMO useless) wrapper</p>",
        "id": 565978418,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767274194
    },
    {
        "content": "<p>Someone might be using it, so we might want to have a deprecation period at least.</p>",
        "id": 565978452,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767274232
    },
    {
        "content": "<p>Maybe we could have something like this? But I don't know if <code>BaseGraph</code> would be any useful.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">BaseGraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The vertex set. -/</span>\n<span class=\"w\">  </span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The binary incidence predicate, stating that `x` and `y` are the ends of an edge `e`.</span>\n<span class=\"sd\">  If `G.IsLink e x y` then we refer to `e` as `edge` and `x` and `y` as `left` and `right`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The edge set. -/</span>\n<span class=\"w\">  </span><span class=\"n\">edgeSet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- An edge `e` is incident to something if and only if `e` is in the edge set. -/</span>\n<span class=\"w\">  </span><span class=\"n\">edge_mem_iff_exists_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">edgeSet</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- If some edge `e` is incident to `x`, then `x ∈ V`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">left_mem_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">vertexSet</span>\n<span class=\"w\">  </span><span class=\"n\">right_mem_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">vertexSet</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Graph'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">BaseGraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- If `e` goes from `x` to `y`, it goes from `y` to `x`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">isLink_symm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">edgeSet</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Symmetric</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- An edge is incident with at most one unordered pair of vertices. -/</span>\n<span class=\"w\">  </span><span class=\"n\">eq_or_eq_of_isLink_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">w</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Digraph'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">BaseGraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- An edge is incident with at most one pair of vertices. -/</span>\n<span class=\"w\">  </span><span class=\"n\">eq_and_eq_of_isLink_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">w</span>\n</code></pre></div>",
        "id": 565978760,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767274593
    },
    {
        "content": "<p>Is a type for edges better than using <code>Sym2 V</code> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.EdgeLabeling#doc\">docs#SimpleGraph.EdgeLabeling</a> if needed?</p>",
        "id": 565979155,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1767275162
    },
    {
        "content": "<p>btw, what about ordered and/or rooted graphs? <a class=\"message-link\" href=\"/#narrow/channel/513188-CSLib/topic/Parity.20is.20not.20in.20AC0/near/565976041\">#CSLib &gt; Parity is not in AC0 @ 💬</a>  could really use it</p>",
        "id": 565979239,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1767275284
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/565979155\">said</a>:</p>\n<blockquote>\n<p>Is a type for edges better than using <code>Sym2 V</code> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.EdgeLabeling#doc\">docs#SimpleGraph.EdgeLabeling</a> if needed?</p>\n</blockquote>\n<p>Yes, it allows multiedges.</p>",
        "id": 565979255,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767275307
    },
    {
        "content": "<p>So maybe you can add <code>SimpleGraph'</code> and <code>SimpleDigraph'</code> that only take in a vertex type and use <code>Sym2</code> for the edge set</p>",
        "id": 565979328,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1767275386
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/565979239\">said</a>:</p>\n<blockquote>\n<p>btw, what about ordered and/or rooted graphs? <a class=\"message-link\" href=\"/#narrow/channel/513188-CSLib/topic/Parity.20is.20not.20in.20AC0/near/565976041\">#CSLib &gt; Parity is not in AC0 @ 💬</a>  could really use it</p>\n</blockquote>\n<p>It would also be useful to define BFS tree, which would be useful for an elegant proof of bipartite iff no odd cycles.</p>",
        "id": 565979330,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767275388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/565979328\">said</a>:</p>\n<blockquote>\n<p>So maybe you can add <code>SimpleGraph'</code> and <code>SimpleDigraph'</code> that only take in a vertex type and use <code>Sym2</code> for the edge set</p>\n</blockquote>\n<p>I think it would be better to have this as a predicate, something like:<br>\n<code>(G : Graph α β) [G.NoMultiEdges]</code><br>\nand the we can define a separate API that takes <code>(G : Graph α β) [G.NoMultiEdges]</code> as arguments and uses <code>Sym2 V</code> for edges.</p>",
        "id": 565979421,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767275518
    },
    {
        "content": "<p>Oh also n-ary trees (e.g. binary trees), which are similar to ordered trees with <code>maxDegree ≤ n</code> but each vertex has <code>n</code> \"slots\" for children and they are not required to be filled in contiguously from position 0</p>",
        "id": 565979437,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1767275543
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/565979421\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/565979328\">said</a>:</p>\n<blockquote>\n<p>So maybe you can add <code>SimpleGraph'</code> and <code>SimpleDigraph'</code> that only take in a vertex type and use <code>Sym2</code> for the edge set</p>\n</blockquote>\n<p>I think it would be better to have this as a predicate</p>\n</blockquote>\n<p>I think this also applies to <code>Graph'</code> and <code>Digraph'</code>, we can have <code>[G.Loopless]</code> and <code>[G.Symmetric]</code>.<br>\nBut that's only if those properties can be inferred somehow. Which instance will <code>NoMultiEdges</code> have? It seems to me to depend on a property of <code>IsLink</code> which can't be inferred, unless we define an actual <code>SimpleGraph</code> and add the instance to it</p>",
        "id": 565979893,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1767276013
    },
    {
        "content": "<p>Oh maybe you meant that we should still have <code>SimpleGraph</code> with those 3 instances for it, but someone can define some <code>Graph</code> without <code>Sym2</code> and add instances for whichever still holds?</p>",
        "id": 565980065,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1767276105
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/565979893\">said</a>:</p>\n<blockquote>\n<p>It seems to me to depend on a property of <code>IsLink</code> which can't be inferred</p>\n</blockquote>\n<p>Hm, yeah, you're probably right, instance implicit doesn't make sense here. We could try <code>{G : Graph α β} (h : G.NoMultiEdges)</code> or <code>(G : Graph α β) (h : G.NoMultiEdges := by grind)</code>?</p>",
        "id": 565986241,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767282823
    },
    {
        "content": "<p>Currently the digraph api is so thin that we should add the vertexSet</p>",
        "id": 565989324,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767286983
    },
    {
        "content": "<p>Any disruption it causes will be minimal</p>",
        "id": 565989333,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767286991
    },
    {
        "content": "<p>I can make a PR for that since I am already using a definition like that</p>",
        "id": 565989349,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767287015
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> may I?</p>",
        "id": 565989542,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767287319
    },
    {
        "content": "<p>Sure yes!</p>",
        "id": 565990605,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767288626
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/565986241\">said</a>:</p>\n<blockquote>\n<p>Hm, yeah, you're probably right, instance implicit doesn't make sense here. We could try <code>{G : Graph α β} (h : G.NoMultiEdges)</code> or <code>(G : Graph α β) (h : G.NoMultiEdges := by grind)</code>?</p>\n</blockquote>\n<p>Does the following code make sense? I tried to use instances anyway (the first half is your code):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">BaseGraph</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The vertex set. -/</span>\n<span class=\"w\">  </span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The binary incidence predicate, stating that `x` and `y` are the ends of an edge `e`.</span>\n<span class=\"sd\">  If `G.IsLink e x y` then we refer to `e` as `edge` and `x` and `y` as `left` and `right`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The edge set. -/</span>\n<span class=\"w\">  </span><span class=\"n\">edgeSet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- An edge `e` is incident to something if and only if `e` is in the edge set. -/</span>\n<span class=\"w\">  </span><span class=\"n\">edge_mem_iff_exists_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">edgeSet</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- If some edge `e` is incident to `x`, then `x ∈ V`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">left_mem_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">vertexSet</span>\n<span class=\"w\">  </span><span class=\"n\">right_mem_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">vertexSet</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Graph'</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">BaseGraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- If `e` goes from `x` to `y`, it goes from `y` to `x`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">isLink_symm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">edgeSet</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Symmetric</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- An edge is incident with at most one unordered pair of vertices. -/</span>\n<span class=\"w\">  </span><span class=\"n\">eq_or_eq_of_isLink_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">w</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Digraph'</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">BaseGraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- An edge is incident with at most one pair of vertices. -/</span>\n<span class=\"w\">  </span><span class=\"n\">eq_and_eq_of_isLink_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">w</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkDigraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BaseGraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">vertexSet</span>\n<span class=\"w\">  </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">left_mem_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n<span class=\"w\">  </span><span class=\"n\">right_mem_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkSemisimpleGraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BaseGraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sym2</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">vertexSet</span>\n<span class=\"w\">  </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">left_mem_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n<span class=\"w\">  </span><span class=\"n\">right_mem_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">NoMultiEdges</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BaseGraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">subsingleton_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NoMultiEdges</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkDigraph</span><span class=\"w\"> </span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">subsingleton_isLink</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e₁</span><span class=\"w\"> </span><span class=\"n\">e₂</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">injEq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e₁</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e₂</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NoMultiEdges</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkSemisimpleGraph</span><span class=\"w\"> </span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">subsingleton_isLink</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e₁</span><span class=\"w\"> </span><span class=\"n\">e₂</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">injEq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e₁</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e₂</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 565991056,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1767289318
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/565990605\">said</a>:</p>\n<blockquote>\n<p>Sure yes!</p>\n</blockquote>\n<p>Ran into a weird issue. As you know, the complement of a graph is a graph with the same vertex set but the edge set complemented (w.r.t the complete graph on the vertex set)</p>",
        "id": 566004877,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767309429
    },
    {
        "content": "<p>But the subgraph relation requires the vertices to have a subset relation</p>",
        "id": 566004890,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767309448
    },
    {
        "content": "<p>This becomes a point of pain when filling out the completeBooleanAlgebra instance</p>",
        "id": 566004903,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767309468
    },
    {
        "content": "<p>since it's bottom would have a vertex set that is empty</p>",
        "id": 566004919,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767309506
    },
    {
        "content": "<p>Now one fix is to set the vertex set of an empty graph to <code>Set.univ</code> which is not unheard of in some circles</p>",
        "id": 566004927,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767309532
    },
    {
        "content": "<p>But diestel's empty graphs have empty vertex sets iirc</p>",
        "id": 566004946,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767309554
    },
    {
        "content": "<p>In fact this option also causes problems since <code>\\bot \\leq G</code> is no longer true for arbitrary <code>G</code></p>",
        "id": 566004999,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767309700
    },
    {
        "content": "<p>All this makes me think <code>CompleteAtomicBooleanAlgebra</code> is not a good typeclass to be used for <code>Digraph</code>s but I never studied order theory beyond textbook level stuff.</p>",
        "id": 566005026,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767309759
    },
    {
        "content": "<p>Here's the PR : <a href=\"https://github.com/leanprover-community/mathlib4/pull/33466\">https://github.com/leanprover-community/mathlib4/pull/33466</a></p>",
        "id": 566005170,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767309991
    },
    {
        "content": "<p>Yes indeed it is expected that you will have to drop the <code>CompleteBooleanAlgebra</code> instance</p>",
        "id": 566037265,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767346049
    },
    {
        "content": "<p>You still have an instance <code>CompleteBooleanAlgebra (Iic G)</code> for each <code>G</code> though.</p>",
        "id": 566090310,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1767379998
    },
    {
        "content": "<p>What's <code>Iic</code>?</p>",
        "id": 566095027,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767383186
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Iic#doc\">docs#Set.Iic</a></p>",
        "id": 566095107,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767383252
    },
    {
        "content": "<p>the left-infinite right-closed interval</p>",
        "id": 566095116,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767383260
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Iic#doc\">docs#Set.Iic</a></p>",
        "id": 566095158,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1767383291
    },
    {
        "content": "<p>Wait what does <code>Set.Iic G</code> even mean in simple terms?</p>",
        "id": 566097207,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767384762
    },
    {
        "content": "<p>The set of graphs that are a subgraph of G</p>",
        "id": 566097250,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1767384793
    },
    {
        "content": "<p>Ah okay.</p>",
        "id": 566097356,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767384901
    },
    {
        "content": "<p>Is there a clean way to derive most of the fields of an instance where many of its fields are direct applications of a different typeclass instance?</p>",
        "id": 566105004,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767391508
    },
    {
        "content": "<p>Can you give an example?</p>",
        "id": 566105695,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767392139
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> is there hover functionality? It seems like it would be good to be able to have an answer for that kind of question pop up on mouse hover</p>",
        "id": 566105910,
        "sender_full_name": "Matthew Coke",
        "timestamp": 1767392281
    },
    {
        "content": "<p>I have no idea what hover functionality you are referring to.</p>",
        "id": 566111823,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767398708
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> : I have a WIP hand construction of the <code>CompleteBooleanAlgebra</code> instance. I know I am occasionally using tactics to construct terms, but in this case it's merely ergonomics and it can be changed.</p>\n<p>Concretely I need help on two points : </p>\n<ol>\n<li>I need to know if the instance construction makes sense in principle. For instance I defined <code>compl</code> of <code>Set.Iic H</code> as <code>Set.Iic H'</code> such that <code>H'</code> contains the same vertices in <code>H</code> and all edges in <code>G</code> which are not in <code>H</code> and are only incident on <code>H.verts</code></li>\n</ol>",
        "id": 566117487,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767406609
    },
    {
        "content": "<ol start=\"2\">\n<li>Just a sanity check that I am not taking a circuitous path to this instance.</li>\n</ol>",
        "id": 566117511,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767406648
    },
    {
        "content": "<p>PR : <a href=\"https://github.com/leanprover-community/mathlib4/pull/33466\">mathlib4#33466</a></p>",
        "id": 566117524,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767406675
    },
    {
        "content": "<p>At this point I am taking a pause to sleep. So I don't mind it if you push some commits</p>",
        "id": 566117610,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767406882
    },
    {
        "content": "<p>I am confused why <code>compl</code> can't be defined at the levels of simple graphs, rather than subgraphs</p>",
        "id": 566136002,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767431043
    },
    {
        "content": "<p>Oh I see that's what you did. I pushed a golf</p>",
        "id": 566141043,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767437607
    },
    {
        "content": "<p>Apologies for the delay, but for some reason, vscode has been crawling to a halt at every minor edit on this file.</p>",
        "id": 566193622,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767496208
    },
    {
        "content": "<p>Editing a big file full of errors is still pretty slow. I always suggest to sprinkle an <code>#exit</code> every 30 lines or so in such cases</p>",
        "id": 566200454,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767506313
    },
    {
        "content": "<p>Small update : I ran into a problem with the CompleteBooleanAlgebra for <code>Set.Iic G</code>. Basically the vertex set of the complement of a subgraph <code>H</code> w.r.t <code>G</code> could be </p>\n<ol>\n<li><code>G.verts \\ H.verts</code> : But this means edges are only between vertices in this set</li>\n<li><code>G.verts</code> : This is the normal definition of complement w.r.t super-graph G</li>\n<li><code>H.verts</code> : Most morally correct definition.<br>\nEither choice breaks some field</li>\n</ol>",
        "id": 566263978,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767576942
    },
    {
        "content": "<ol>\n<li>breaks <code>top_le_sup_compl</code></li>\n<li>breaks <code>inf_le_compl_bot</code>, because ofc the vertex set is exactly (G.verts \\inter H.verts)</li>\n<li>Breaks almost everything related to <code>compl</code></li>\n</ol>",
        "id": 566264030,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767576984
    },
    {
        "content": "<p>Recall that <code>H : Set.Iic G</code> is identified with its upper bound <code>H.val</code><br>\nEither I am making a trivial blunder that I am too silly to see or this is the wrong typeclass</p>",
        "id": 566264132,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767577098
    },
    {
        "content": "<p>CC : <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  and <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span></p>",
        "id": 566264145,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767577110
    },
    {
        "content": "<p>I have uploaded it with <code>1.</code> which was my last attempt, though I largely worked with 2, since that's the only sensible definition of a complement of <code>H</code> w.r.t <code>G</code></p>",
        "id": 566264222,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767577190
    },
    {
        "content": "<p>commits are welcome. I am not touching this PR for several hours</p>",
        "id": 566264378,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767577323
    },
    {
        "content": "<p>I think my short comment from earlier was simply incorrect. There is no sensible boolean algebra structure on the type of all subgraphs of a graph, because of exactly the issues you describe. Sorry about this! </p>\n<p>The natural <code>CompleteBooleanAlgebra</code> should be on <code>{H // H \\le G /\\ V(H) = V(G)}</code> (i.e the type of spanning subgraphs of G) rather than the type of subgraphs of G.</p>",
        "id": 566419548,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1767639317
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/566419548\">said</a>:</p>\n<blockquote>\n<p>I think my short comment from earlier was simply incorrect. There is no sensible boolean algebra structure on the type of all subgraphs of a graph, because of exactly the issues you describe. Sorry about this! </p>\n<p>The natural <code>CompleteBooleanAlgebra</code> should be on <code>{H // H \\le G /\\ V(H) = V(G)}</code> (i.e the type of spanning subgraphs of G) rather than the type of subgraphs of G.</p>\n</blockquote>\n<p>I spent too much time on that instance then. I have uploaded the new one partially. If someone wants to fill in the remaining fields and errors, feel free to make commits. I might not have much time in the upcoming days.</p>",
        "id": 566462920,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767661521
    },
    {
        "content": "<p>Brief update : The usual definition of <code>sInf</code> doesn't make sense when the set is empty.</p>",
        "id": 567439696,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768192624
    },
    {
        "content": "<p>CC : <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  and <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span></p>",
        "id": 567439712,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768192634
    },
    {
        "content": "<p>The proof of <code>left_mem_of_verts</code> and <code>right_mem_of_verts</code> breaks down if I allow <code>\\McH</code> to be empty in the definition of <code>sInf</code>. See the <code>sorry</code>s</p>",
        "id": 567440037,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768192795
    },
    {
        "content": "<p>Another update: I want to ask what the correct definition of <code>sInf</code> ought to be for a <code>SpanningSubgraph</code> (see the PR)</p>",
        "id": 567675927,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768272591
    },
    {
        "content": "<p>Specifically the breaking case is when the set of graphs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">H</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{H}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.00965em;\">H</span></span></span></span> is empty</p>",
        "id": 567675947,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768272616
    },
    {
        "content": "<p>Every reasonable choice breaks something. Just <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi>d</mi><mi>j</mi><mtext> </mtext><mi>v</mi><mtext> </mtext><mi>w</mi><mo>:</mo><mo>=</mo><mi mathvariant=\"normal\">∀</mi><mi>H</mi><mo>∈</mo><mi mathvariant=\"script\">H</mi><mo separator=\"true\">,</mo><mi>H</mi><mi mathvariant=\"normal\">.</mi><mi>A</mi><mi>d</mi><mi>j</mi><mtext> </mtext><mi>v</mi><mtext> </mtext><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">Adj\\ v\\ w := \\forall H \\in \\mathcal{H}, H.Adj\\ v\\ w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.0391em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.00965em;\">H</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> means we can't show the <code>left_mem_of_verts</code> and <code>right_mem_of_verts</code>. Everything else breaks one lemma or the other.</p>",
        "id": 567676019,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768272700
    },
    {
        "content": "<p>Btw, a <code>BooleanAlgebra</code> works as is.</p>",
        "id": 567676065,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768272754
    },
    {
        "content": "<p>Additionally, I need help with:</p>\n<ol>\n<li>The Fintype instance </li>\n<li><del>The decidable instance for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>G</mi><mi>c</mi></msup><mi mathvariant=\"normal\">.</mi><mi>A</mi><mi>d</mi><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">G^{c}.Adj</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span><span class=\"mord\">.</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> </del> : Done</li>\n</ol>",
        "id": 567676104,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768272811
    },
    {
        "content": "<p>commits welcome</p>",
        "id": 567676117,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768272827
    },
    {
        "content": "<p>You need to specify a base case one way or another. You can do <code>G.Adj v w ∧ ∀ H ∈ ℋ, Adj H.val v w</code>.</p>",
        "id": 567676482,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768273135
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/567676482\">said</a>:</p>\n<blockquote>\n<p>You need to specify a base case one way or another. You can do <code>G.Adj v w ∧ ∀ H ∈ ℋ, Adj H.val v w</code>.</p>\n</blockquote>\n<p>Oh wow that actually worked. Thanks :)</p>",
        "id": 567677477,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768274157
    },
    {
        "content": "<p>To be concrete I knew a base case was necessary, but adding <code>G.Adj v w \\and ...</code> was not what I thought of</p>",
        "id": 567677540,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768274195
    },
    {
        "content": "<p>Only the Fintype instance remains now <a href=\"https://github.com/leanprover-community/mathlib4/pull/33466\">mathlib4#33466</a></p>",
        "id": 567679733,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768275988
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 567679760,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768276009
    },
    {
        "content": "<p>Btw, I have not edited the author list since technically this is only a refactor, though I basically rewrote half the file.</p>",
        "id": 567680561,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768276689
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> : I put the PR up for review</p>",
        "id": 567733947,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768301565
    },
    {
        "content": "<p>Github copilot actually gave a decent first review</p>",
        "id": 567821331,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768324997
    },
    {
        "content": "<p>Its utility diminishes with subsequent rounds of reviews. I have left two of the comments made by copilot open for reviewers</p>",
        "id": 567824723,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768326015
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> : this is one of the threads where we most recently discussed adding sets. <span class=\"user-mention\" data-user-id=\"933054\">@Snir Broshi</span> linked to another recently active thread. </p>\n<p>Rather than repeat my points from the GitHub PR comments I’d like to ask why you believe it is worthwhile having separate types for definitions of graphs and subgraphs as well as a separate IsSubgraph relation (and in the future possibly even a Subgraph.IsSubgraph relation). </p>\n<p>Subgraphs are also graphs and this relation is natural when there is already a vertex set in subgraphs. The new definition makes it trivial by not having to coerce at all. Further we get to make a distinction between graphs in which different sets of vertices are included in the graphs, including as isolated vertices, without getting into type index unification headaches, and being able to compare subgraphs of different vertex sets. Further graph theorists don’t treat subgraphs as a conceptually separate concept. They are also graphs. I have already mentioned in the PR comments how the current state of affairs leads to annoying and tedious duplication of efforts. </p>\n<p>Thus if anything, it is upto someone to defend the current horrendous definition that doesn’t give us flexibility to pick our vertex sets.</p>",
        "id": 568112985,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768442115
    },
    {
        "content": "<p>Also is there a chance we might get this PR reviewed quickly <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> and <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span>. This PR already ran into merge conflicts today, and I would like to next propose a definition of walks for Digraphs if possible. I don’t know how the queue system works anymore since I haven’t PRed to mathlib in most of 2025.</p>",
        "id": 568113148,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768442245
    }
]