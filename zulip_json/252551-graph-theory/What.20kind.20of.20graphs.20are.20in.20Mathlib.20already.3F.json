[
    {
        "content": "<p>Hi, I'm trying to figure out which types of graphs are defined already in Mathlib and where to find them, and which ones are not. </p>\n<p>So far, I've seen <code>SimpleGraph</code>, <code>Digraph</code>, and <code>Quiver</code>.  These give rise to two questions.</p>\n<p>1) In the first two definitions, I would have expected that <code>SimpleGraph</code> would extend <code>Digraph</code>, and that things like <code>walk</code> would be defined on <code>Digraph</code>, but that seems not to be the case. Is this just a matter of <code>did not happen yet</code> or is there a rationale behind that? And how does this community go about refactoring efforts - if it is indeed a matter of <code>did not happen yet</code>?</p>\n<p>2) The definition of <code>Quiver</code> is the next step up from <code>Digraph</code> and generalizes <code>Prop</code> to <code>sort</code> as a way of generating different edges between vertices. I understand that this is helpful as a step towards defining <code>Category</code> later, but in some of the graph theoretic work that I encounter considering a MultiGraph (I think it would be called) as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MultiGraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vertex</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Edge</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"n\">source</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Edge</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Vertex</span>\n<span class=\"w\">   </span><span class=\"n\">destination</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Edge</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Vertex</span>\n</code></pre></div>\n<p>seems helpful, in that it seems a lot easier to me when I want to consider all the edges in the graph at the same time. When I use <code>Quiver</code> I always have to first identify the source and destination explicitly, which is sometimes cumbersome. Does that definition (or similar) exist under a different name perhaps? Is there a reason not to have it? And if not to both, should I try setting up a PR for it?</p>",
        "id": 508789911,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743177401
    },
    {
        "content": "<p>Regarding part (1), it is a case of \"nobody did it yet\". It shouldn't be too hard, feel free to do it!</p>",
        "id": 508794612,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1743178617
    },
    {
        "content": "<p>Actually \"nobody did it\" is technically wrong, <span class=\"user-mention\" data-user-id=\"598052\">@Jeremy Tan</span> did it here <a href=\"https://github.com/leanprover-community/mathlib4/pull/16018\">#16018</a>, but that PR got closed and nobody worked on it after that.</p>\n<p>Digraphs are relatively recent compared to simple graphs, and that part is still lacking, I wanted to port parts of simple graph to digraphs but got too busy with other things, I would be happy to help if somebody else starts working on it.</p>\n<p>I think this is worth it because there are a lot of important results on, for instance, tournaments, directed SRGs, flow networks, etc and this part of the library can be the foundation for formalizing them.</p>",
        "id": 508796208,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1743179031
    },
    {
        "content": "<p>cc. <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> regarding point (2).</p>",
        "id": 508797357,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1743179331
    },
    {
        "content": "<p>With 1, it's that it's not necessarily useful to have it literally <code>extend</code> Digraph. If you're thinking about this in terms of object-oriented programming and subtyping, Lean doesn't work the same way. You wouldn't be able to pass a SimpleGraph to a function expecting a Digraph, except in special cases (via dot notation), and you can't use dot notation to make Digraph functions that operate on SimpleGraphs that return SimpleGraphs.</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a> has a <code>class</code>-based approach to unify the API, but as you can see it's quite an old PR. I think I have a branch somewhere with a more updated version, but it might be on my desktop computer...</p>",
        "id": 508801779,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743180556
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I do get that the subtyping doesn't work in exactly the same way, but if the notion of 'walk' was defined on Digraphs, it would automatically be defined on SimpleGraphs, so it would prevent duplication of code - right?</p>\n<p>The tricky part, I think, that in some cases the concepts may generalize, but the proofs would go via a different route. Worse, the formulation of the concepts may be different. For example my question on Multigraphs vs Quivers is an example of that. The two definitions may - up to some details - be equivalent (up to some type-theoretic differences), but the proofs of some theorems will be awkward on one, while going smoothly on the other, and vice versa. In such a situation, people may prefer one basic definition over another, and there is no clear decision anymore on how the inheritance should go.</p>",
        "id": 508806762,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743181617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/508796208\">said</a>:</p>\n<blockquote>\n<p>Actually \"nobody did it\" is technically wrong, <span class=\"user-mention silent\" data-user-id=\"598052\">Jeremy Tan</span> did it here <a href=\"https://github.com/leanprover-community/mathlib4/pull/16018\">#16018</a>, but that PR got closed and nobody worked on it after that.</p>\n<p>Digraphs are relatively recent compared to simple graphs, and that part is still lacking, I wanted to port parts of simple graph to digraphs but got too busy with other things, I would be happy to help if somebody else starts working on it.</p>\n<p>I think this is worth it because there are a lot of important results on, for instance, tournaments, directed SRGs, flow networks, etc and this part of the library can be the foundation for formalizing them.</p>\n</blockquote>\n<p>Hm... that is not too encouraging... hence my question \"how does refactoring work\" in this community? Is there a way to avoid that such an effort \"fails\" (if that is the right word).</p>",
        "id": 508807328,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743181797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"563058\">Pieter Cuijpers</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/508806762\">said</a>:</p>\n<blockquote>\n<p>it would automatically be defined on SimpleGraphs, so it would prevent duplication of code - right?</p>\n</blockquote>\n<p>No, not exactly. If <code>G : SimpleGraph V</code>, you can't write <code>Digraph.Walk G u v</code>. However, the dot notation elaboration would let you write <code>G.Walk u v</code> to get <code>Digraph.Walk G.toDigraph u v</code>.</p>\n<p>The class system I mentioned in the PR I linked to is the way to go to get the unified interface you want (or maybe not done exactly like in the PR, but the general idea). That's how homomorphisms work in mathlib; they have similar issues, since you want, for example, a homomorphism that's both multiplicative and additive to \"be\" a multiplicative homomorphism and an additive homomorphism.</p>",
        "id": 508807469,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743181827
    },
    {
        "content": "<p><code>extends</code> is a very very weak concept, and it's not worth it here I think. That's not to say that no one wants a unified interface for graphs! It's just that <code>extends</code> isn't the correct mechanism.</p>",
        "id": 508807861,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743181951
    },
    {
        "content": "<p><code>extends</code> works a lot better for <code>class</code> than <code>structure</code>, since the parents each give a projection instance, and that simulates the OO-like subtyping. For graphs, what we want are classes that provide the interface for what it means to be a graph with certain kinds of features, and then definitions can make use of these classes. They would not be in terms of a concrete data type.</p>",
        "id": 508807956,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743181983
    },
    {
        "content": "<p>The reason I stopped pursuing <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a> is (1) I wasn't sure about some of the interface I was developing (e.g. should the vertex type of a graph type be allowed to vary with the graph? or does the graph type itself fix the vertex type? I ran into some Lean bugs here, and they might be fixed by now) and (2) I like dot notation and don't want to give it up, which the <code>class</code>-based system requires, and in the meantime I've been working on Lean features to preserve dot notation.</p>",
        "id": 508809125,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743182342
    },
    {
        "content": "<p>I'm a bit lost on why <code>extends</code> does not work on <code>structure</code>, but that aside I think it is indeed the unified interface that I'm looking for, which usually is created either by <code>extends</code> or by an <code>instance</code> theorem (which is also fine with me). And both give the dot notation elaboration, which is I think quite an okay way to achieve the interface we need.</p>\n<p>(I'm probably not enough of a programmer to use all the jargon correctly.)</p>",
        "id": 508809198,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743182362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/508809125\">said</a>:</p>\n<blockquote>\n<p>The reason I stopped pursuing <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a> is (1) I wasn't sure about some of the interface I was developing (e.g. should the vertex type of a graph type be allowed to vary with the graph? or does the graph type itself fix the vertex type? I ran into some Lean bugs here, and they might be fixed by now) and (2) I like dot notation and don't want to give it up, which the <code>class</code>-based system requires, and in the meantime I've been working on Lean features to preserve dot notation.</p>\n</blockquote>\n<p>You have my full support on liking dot notation and prioritizing that :-)</p>\n<p>What you mention about <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a> sounds like the decision between <code>Multigraph</code> as I proposed it above and <code>Quiver</code> as it is in the library to me, or am I mistaken? There may be value to both. And strictly speaking, a Multigraph would be a Quiver, but not necessarily the other way around?</p>",
        "id": 508809943,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743182568
    },
    {
        "content": "<p>I may be overlooking important details here.</p>",
        "id": 508810000,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743182584
    },
    {
        "content": "<blockquote>\n<p>I'm a bit lost on why <code>extends</code> does not work on <code>structure</code></p>\n</blockquote>\n<p>I invite you to experiment here with using <code>extends</code> on <code>structure</code>. It \"works\", but there are some deep usability problems, because you don't get a coercion from <code>SimpleGraph</code> to <code>Digraph</code> that actually works. This is why I point out that it's not like the OO concept of extension — the OO one is how people think it will work, even if they aren't consciously thinking about it that way.</p>\n<p>There's also a fundamental conceptual issue: a simple graph <em>isn't</em> a digraph. Sure, you can model a simple graph as a symmetric irreflexive relation, but that doesn't mean that there are edges going in both directions. For simplicity's sake we may as well take the perspective that simple graphs are digraphs, but I think it's worth keeping this in mind. It has a big impact on how you name functions. E.g., you want the neighbor set of a vertex, right? Is that the set of heads or tails from a given vertex?</p>",
        "id": 508810658,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743182771
    },
    {
        "content": "<blockquote>\n<p>What you mention about <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a> sounds like the decision between <code>Multigraph</code> as I proposed it above and <code>Quiver</code> as it is in the library to me, or am I mistaken?</p>\n</blockquote>\n<p>It's different. With <code>Quiver</code>/<code>MultiGraph</code>, you're putting a fixed structure on a given Vertex and Edge type. With my PR, you have an actual type of graphs under consideration, and each term of that type has a graph structure.</p>\n<p>We care about the lattice structure on SimpleGraph and Digraph for example, and we might have general theorems about it.</p>\n<p>Multigraphs generally don't have a good lattice structure however, so your <code>MultiGraph</code> type could be workable. You just need to keep in mind that you should never have two graphs with the same <code>Vertex</code> and <code>Edge</code> types. (It's possible to have a <code>Multigraph</code> type with a lattice structure; recall that there are two definitions of a multigraph, one is that the edge set is a multiset of unordered pairs, and the other is what you have. That is, indistinguishable vs distinguishable multiedges. They're slightly different, and I think we should be able to support both.)</p>",
        "id": 508811626,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743183062
    },
    {
        "content": "<blockquote>\n<p>You just need to keep in mind that you should never have two graphs with the same <code>Vertex</code> and <code>Edge</code> types</p>\n</blockquote>\n<p>I disagree on this point. For instance, I could remove an edge from multigraph, and add it back somewhere else.</p>",
        "id": 508812021,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743183214
    },
    {
        "content": "<p>What are you disagreeing with? I'm pointing this out as a problem with the arrangement.</p>",
        "id": 508812076,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743183237
    },
    {
        "content": "<p>I interpreted 'should' as a design mandate. If it's not that, I have no disagreement.</p>",
        "id": 508812181,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743183265
    },
    {
        "content": "<p>It's a \"should\" as in \"class instances are supposed to be canonical, so you shouldn't violate that\"</p>",
        "id": 508812264,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743183299
    },
    {
        "content": "<p>This goes against the design of matroids that seems to be working very well - for instance, operations like truncation, and results like the matroid intersection theorem, use different matroids on the same ground set (type).</p>",
        "id": 508812509,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743183378
    },
    {
        "content": "<p>Ah, the difference is the 'class' part.</p>",
        "id": 508812624,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743183422
    },
    {
        "content": "<p>Yes, I'm saying why the <code>MultiGraph</code> class from the beginning of this thread has some difficulties. It's workable, and I'm sure it's great for certain applications, but it's not necessarily what everyone would want.</p>",
        "id": 508812740,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743183473
    },
    {
        "content": "<p>We want a <code>class</code> (or a system of <code>classe</code>es) that describes a generic <code>Multigraph</code> interface. Concrete implementations of multigraphs would then implement these classes, and each person can use their favorite kind of multigraph with the generic library.</p>",
        "id": 508813063,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743183588
    },
    {
        "content": "<p>Got that, but I would be fine with making <code>MultiGraph</code> a <code>structure</code> as well. I was not aware of a cannonical \"<code>lattice</code> of <code>Digraph</code>s\", but it makes sense to consider it as a structure too.</p>",
        "id": 508813173,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743183617
    },
    {
        "content": "<p><code>Digraph V</code> and <code>SimpleGraph V</code> have lattice structures, via edge containment</p>",
        "id": 508813345,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743183674
    },
    {
        "content": "<p>The plan my student and I have at the moment is something like the following: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"c1\">-- vertex set</span>\n<span class=\"w\">  </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"c1\">-- edge set</span>\n<span class=\"w\">  </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"c1\">-- edge-vertex incidence</span>\n<span class=\"w\">  </span><span class=\"n\">Inc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">vertex_support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">edge_support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">E</span>\n<span class=\"c1\">-- extra propositional stuff, such as the fact that each edge is incident with at most two vertices.</span>\n</code></pre></div>",
        "id": 508815226,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743184318
    },
    {
        "content": "<p>This uses the 'embedded set' design that has worked well for matroids. I am growing more and more convinced that this will be the best way to formalize real-world proofs involving minors. </p>\n<p>If contracting an edge of a graph forces passing to a new graph with a different vertex type, then any vaguely complicated 'contract an edge, apply induction'-type proof will descend to DTT hell.</p>",
        "id": 508815769,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743184486
    },
    {
        "content": "<p>Seems reasonable. I think this basically what's in <a href=\"https://link.springer.com/chapter/10.1007/3-540-58450-1_40\">https://link.springer.com/chapter/10.1007/3-540-58450-1_40</a>, but with types for the elements of the V and E sets. (I can't check right now.)</p>",
        "id": 508816244,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743184636
    },
    {
        "content": "<p>Here's another definition I experimented with: <a href=\"https://github.com/leanprover-community/mathlib3/blob/3c940418e050f85795b91778aa17fdf7c354c700/src/combinatorics/multigraph/basic.lean#L58-L60\">https://github.com/leanprover-community/mathlib3/blob/3c940418e050f85795b91778aa17fdf7c354c700/src/combinatorics/multigraph/basic.lean#L58-L60</a></p>\n<p>I think it might be equivalent; it uses, basically, a set of triples <code>V x V x E</code> that's symmetric in the first two components, rather than an Inc relation.</p>",
        "id": 508816642,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743184771
    },
    {
        "content": "<p>(As always, you'll have to decide how you want to define the degree of a vertex that has a loop. The topologist in me wants it to be 2, but with all these proposals the easiest answer is 1.)</p>",
        "id": 508817259,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743184945
    },
    {
        "content": "<p>It's 2!</p>",
        "id": 508817285,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743184953
    },
    {
        "content": "<p>(Provided you want a handshake theorem, at least)</p>",
        "id": 508818343,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743185265
    },
    {
        "content": "<p>(and nice linear algebra over Z2)</p>",
        "id": 508818914,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743185448
    },
    {
        "content": "<p>How do you define degree to get 2 though?</p>",
        "id": 508818939,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743185459
    },
    {
        "content": "<p>edit : nevermind</p>",
        "id": 508820205,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743185854
    },
    {
        "content": "<p>Yeah, it's annoying. Define a function <code>f</code> from edges to Sym2; then the degree of a vertex is obtained by the sum over <code>e</code> of the sum over <code>f e</code> of an indicator function.</p>",
        "id": 508825737,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743187830
    },
    {
        "content": "<p>But the rewards are obvious!</p>",
        "id": 508826050,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743187932
    },
    {
        "content": "<p>This might be look a bit heavy-handed, but I think it works.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→₀</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"n\">sum_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"n\">vertex_support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">edge_support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">E</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">IsLoopAt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">IsNonloopAt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 508834932,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743191309
    },
    {
        "content": "<p>The handshake theorem should naturally be true with no fussing with loops, and I think even contractions will work nicely.</p>",
        "id": 508835125,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743191397
    },
    {
        "content": "<p>What is <code>sum_eq : ∀ e ∈ E, (inc e).sum (fun _ x ↦ x) = 2</code> for?</p>",
        "id": 508835272,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743191454
    },
    {
        "content": "<p>Why not just have <code>inc : β → Sym2 α</code> instead?</p>",
        "id": 508835530,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743191566
    },
    {
        "content": "<p>The sum of the incidences for the vertices at each edge e is either 1+1=2 (for a nonloop e) or 2=2 (for a loop e)</p>",
        "id": 508835531,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743191566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/508835530\">said</a>:</p>\n<blockquote>\n<p>Why not just have <code>inc : β → Sym2 α</code> instead?</p>\n</blockquote>\n<p>Because that will be ugly for nonelements of <code>E</code>.</p>",
        "id": 508835618,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743191615
    },
    {
        "content": "<p>(In my opinion) the design should allow for deleting edges in a <code>Graph a b</code> to get  another <code>Graph a b</code>, without changing the edge type.</p>",
        "id": 508835762,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743191675
    },
    {
        "content": "<p>You could also go hypergraph and drop it and then edges connect arbitrarily many vertices</p>",
        "id": 508835988,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743191799
    },
    {
        "content": "<p>You can also allow for digraphs by having the incidence function be <code>Int</code>-valued (plus or minus 1) and summing absolute values.</p>",
        "id": 508836158,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743191879
    },
    {
        "content": "<p>The annoyance is that this will require Decidable in places that Prop-valued predicates won’t</p>",
        "id": 508840335,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743193584
    },
    {
        "content": "<p>I believe there is no way to avoid the decidability assumption in the following : </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">edgeDel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">D</span>\n<span class=\"w\">  </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"n\">sum_eq</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">he</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">he</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">sum_eq</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">he</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">vertex_support</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">vertex_support</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span>\n<span class=\"w\">  </span><span class=\"n\">edge_support</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edge_support</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 508911096,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743245433
    },
    {
        "content": "<p>Ok, I was wrong; you can make it mostly invisible this way. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"bp\">.</span><span class=\"n\">edgeDel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">D</span>\n<span class=\"w\">  </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">dec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"n\">sum_eq</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">he</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">he</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">sum_eq</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">he</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">vertex_support</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">vertex_support</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span>\n<span class=\"w\">  </span><span class=\"n\">edge_support</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edge_support</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 508911869,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743246024
    },
    {
        "content": "<p><a href=\"https://github.com/Jun2M/Kura/blob/master/Kura/FinsuppGraph.lean\">This file</a> uses the above to define multigraphs, edge deletions, extensionality with prop-valued incidence, loops, nonloops, images under maps that merge vertices, and the handshake theorem (with no special-casing for loops) in just over 200 lines.</p>",
        "id": 508952840,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743277816
    },
    {
        "content": "<p>Ahh! The discussion is spiralling in quite a different direction then I would have expected, but it does give me some answer as to why there is no clear-cut definition yet <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> . I was just being happily naive.</p>",
        "id": 509155081,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743415725
    },
    {
        "content": "<p>But why the explicit addition of having sets of vertices and edges?<br>\nWould something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">inc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">whatever</span><span class=\"w\"> </span><span class=\"n\">needs</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">here</span>\n</code></pre></div>\n<p>already give you enough structure to work with?</p>\n<p>From the remarks you're making, you have experience with how the proofs will go further down the line.<br>\nI'm trying to understand why you make the choices the way you do here.</p>",
        "id": 509159401,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743417019
    },
    {
        "content": "<p>Yes, there is a reasonable discussion to be had about design here, and on this matter I’m expressing one particular point of view, which is informed by my work on matroids. I discuss this at length in this post: <a href=\"#narrow/stream/287929-mathlib4/topic/The.20design.20of.20matroids\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/The.20design.20of.20matroids</a></p>\n<p>The issues in graph theory aren’t the same, but the analogies are there.</p>\n<p>The shorter version: in real-world graph theory proofs, you might do something like contract an edge <code>e</code>, delete a vertex <code>x</code>, and consider the role of a vertex <code>v</code> and a path <code>P</code>, before and after the contractions and deletions were performed. If the graphs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>−</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">G-x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">/</mi><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">G / e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">e</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>G</mi><mo>−</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">(G-x)/e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">e</span></span></span></span> are all modeled using different types, then there are already four ‘versions’ of <code>v</code> and <code>P</code>, related by a mess of invisible canonical maps. The more involved the proof, the worse this picture gets, and in my opinion this is a road to disaster.</p>\n<p>To avoid this, you want the four graphs to have the same type. I don’t know a better choice for this type than simply  <code>Graph a b</code> with vertex and edge sets as structure fields.</p>",
        "id": 509163629,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743418215
    },
    {
        "content": "<p>I see. Would there, alternatively, be a way to turn the bookkeeping over all these invisible canonical maps into a tactic?</p>\n<p>Personally, I like it when the definitions are kept as simple as possible, sometimes at the cost of a bit of bookkeeping in the proofs. In my work on process algebras (computer science) the bookkeeping is usually unavoidable, which is the very reason I like theorem provers. They do that bookkeeping for me. But it's only fun if it remains readable indeed.</p>",
        "id": 509171032,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743420174
    },
    {
        "content": "<p>I see that in the other discussion, there were also people who usually have fixed graphs they are studying, in which case my definition seems preferable.</p>",
        "id": 509171442,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743420297
    },
    {
        "content": "<p>Perhaps there is a general trend here... \"fixed structures\" versus \"mutable structures\", requiring different definitions even while they belong to the same branch of mathematics.</p>",
        "id": 509171625,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743420362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/509163629\">said</a>:</p>\n<blockquote>\n<p>To avoid this, you want the four graphs to have the same type. I don’t know a better choice for this type than simply  <code>Graph a b</code> with vertex and edge sets as structure fields.</p>\n</blockquote>\n<p>You could bundle the type, so you have <code>Graph.{v, u} : Type max u v</code>, and for <code>g : Graph</code> you would talk about <code>g.Vertex</code> and <code>g.Edge</code>.</p>",
        "id": 509172090,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743420494
    },
    {
        "content": "<p>Maybe a bookkeeping tactic is possible. But it is hard to even precisely delineate the intended scope of such a tactic,  and often it is the <em>statements</em> rather than the proofs of theorems that become horrible. Think about statements of the form 'minor operations commute' for example. </p>\n<p>In my approach, the bookkeeping tactic needed is one that is capable of proving using existing assumptions that things are 'real' vertices and edges (members of <code>G.V</code> and <code>G.E</code> respectively). This is much more limited in scope, and can be implemented in practice. </p>\n<p>Also, the model where the edges and vertices are types are easy to describe in terms of the more general one. Have propositional typeclasses <code>[FullVertex G]</code> and <code>[FullEdge G]</code> for <code>G : Graph a b</code> that state <code>G.V = Set.univ</code> and <code>G.E = Set.univ</code>. A lot of the API can be shared with the general case, and there can be specialized sugar API for the <code>FullVertex</code>/<code>FullEdge</code> cases where it is needed.</p>",
        "id": 509173058,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743420779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/509172090\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/509163629\">said</a>:</p>\n<blockquote>\n<p>To avoid this, you want the four graphs to have the same type. I don’t know a better choice for this type than simply  <code>Graph a b</code> with vertex and edge sets as structure fields.</p>\n</blockquote>\n<p>You could bundle the type, so you have <code>Graph.{v, u} : Type max u v</code>, and for <code>g : Graph</code> you would talk about <code>g.Vertex</code> and <code>g.Edge</code>.</p>\n</blockquote>\n<p>If I remove a vertex <code>v</code>, then how do the types <code>G.vertex</code> and <code>(G-v).vertex</code> relate?</p>",
        "id": 509173674,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743420961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/509173058\">said</a>:</p>\n<blockquote>\n<p>Think about statements of the form 'minor operations commute' for example. </p>\n</blockquote>\n<p>This seems relatively pain-free to write out, what problem are you seeing?</p>",
        "id": 509173756,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743420973
    },
    {
        "content": "<p>Suppose I have two edges <code>e, f</code>, and I want to contract them in one order versus another. How do I state that I have 'the same' graph both ways?</p>",
        "id": 509173999,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743421042
    },
    {
        "content": "<p>This is a <code>def contractCommIso : (g.contract e).contract (map (contractGraphHom g e) f) ≃g (g.contract f).contract (map (contractGraphHom g f) e)</code></p>",
        "id": 509174705,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743421212
    },
    {
        "content": "<p>hmmm, this turned out longer than I thought it would be</p>",
        "id": 509174821,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743421247
    },
    {
        "content": "<p>And it's the beginning of DTT hell. Now you are pushing forward paths along that map, taking initial subsegments of the paths, etc etc.</p>",
        "id": 509174906,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743421272
    },
    {
        "content": "<p>It should be an <code>=</code> if at all possible, and for this example, <code>=</code> is possible.</p>",
        "id": 509175035,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743421306
    },
    {
        "content": "<p>I don't see how using <code>=</code> makes it any better though...</p>",
        "id": 509175239,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743421352
    },
    {
        "content": "<p>It means that pushforward/pullback API stops being API, and becomes <code>rw</code>.</p>",
        "id": 509175573,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743421445
    },
    {
        "content": "<p>(newb question: what is DTT?)</p>",
        "id": 509177435,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1743421942
    },
    {
        "content": "<p>Dependent type theory.</p>",
        "id": 509177512,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743421964
    },
    {
        "content": "<p>To give a concrete example on this point, I was recently looking at the definition <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Subgraph.Connected#doc\">docs#SimpleGraph.Subgraph.Connected</a> . There is roughly 500 lines of API for it (and it's still incomplete), even though it is just <code>SimpleGraph.Connected</code> modulo some mathematically invisible maps. </p>\n<p>If the vertex set for <code>SimpleGraph</code> were a<code>Set</code>, there would have been no need to have separate <code>SimpleGraph</code> and <code>Subgraph</code> types at all, and this kind of API nearly disappears.</p>",
        "id": 509989148,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743698525
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/24122\">#24122</a></p>",
        "id": 512685881,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744837520
    }
]