[
    {
        "content": "<p>The title. I want to prove something for training purposes about simple graphs (and too lazy to browse Mathlib documentation, at least right now <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>).</p>\n<p>Cheers! <span aria-label=\"tea\" class=\"emoji emoji-1f375\" role=\"img\" title=\"tea\">:tea:</span></p>",
        "id": 398282369,
        "sender_full_name": "Lessness",
        "timestamp": 1698151819
    },
    {
        "content": "<p>I don't know how low this is, but given that a formulation already exists in Isabelle: Berge's Lemma</p>",
        "id": 398282492,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698151868
    },
    {
        "content": "<p>Oh, thank you! Will try doing it.</p>",
        "id": 398282632,
        "sender_full_name": "Lessness",
        "timestamp": 1698151918
    },
    {
        "content": "<p>Do you know where to find the Isabelle proof of Berge's Lemma? I only found the arXiv publication <a href=\"https://arxiv.org/abs/1907.04065\">here</a>. It states that their proof was different from standard proof and shorter than it.</p>",
        "id": 398306618,
        "sender_full_name": "Lessness",
        "timestamp": 1698159537
    },
    {
        "content": "<p>They describe their shorter proof there. I thought there was an AFP entry for it. I'll ask the author.</p>",
        "id": 398359521,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698181046
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 398464045,
        "sender_full_name": "Lessness",
        "timestamp": 1698232813
    },
    {
        "content": "<p>Does this formulation of Berge's Lemma makes sense?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Init.Function</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Matching</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Finsubgraph</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Connectivity</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">IsMaximum</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Finsubgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">M.val.IsMatching</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">M'</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Finsubgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H'</span><span class=\"o\">:</span> <span class=\"n\">M'.val.IsMatching</span><span class=\"o\">),</span>\n  <span class=\"n\">exists</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">M'.val.verts</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">M.val.verts</span><span class=\"o\">),</span> <span class=\"n\">Function.Injective</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">mutual</span>\n  <span class=\"kd\">def</span> <span class=\"n\">AlternatingWalkFalse</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Finsubgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}:</span> <span class=\"n\">SimpleGraph.Walk</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">SimpleGraph.Walk.nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">SimpleGraph.Walk.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">M.val.Adj</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"bp\">/\\</span> <span class=\"n\">AlternatingWalkTrue</span> <span class=\"n\">M</span> <span class=\"n\">p</span>\n  <span class=\"kd\">def</span> <span class=\"n\">AlternatingWalkTrue</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Finsubgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}:</span> <span class=\"n\">SimpleGraph.Walk</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">SimpleGraph.Walk.nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">SimpleGraph.Walk.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">M.val.Adj</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"bp\">/\\</span> <span class=\"n\">AlternatingWalkFalse</span> <span class=\"n\">M</span> <span class=\"n\">p</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">AugmentingPath</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Finsubgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Path</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">Set.Mem</span> <span class=\"n\">x</span> <span class=\"n\">M.val.verts</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"bp\">/\\</span>\n  <span class=\"o\">(</span><span class=\"n\">Set.Mem</span> <span class=\"n\">y</span> <span class=\"n\">M.val.verts</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"bp\">/\\</span>\n  <span class=\"n\">AlternatingWalkFalse</span> <span class=\"n\">M</span> <span class=\"n\">P.val</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Berge's_lemma</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Finsubgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">M.val.IsMatching</span><span class=\"o\">):</span>\n  <span class=\"n\">IsMaximum</span> <span class=\"n\">H</span> <span class=\"bp\">&lt;-&gt;</span> <span class=\"o\">(</span><span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Path</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">AugmentingPath</span> <span class=\"n\">M</span> <span class=\"n\">P</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 398464336,
        "sender_full_name": "Lessness",
        "timestamp": 1698232949
    },
    {
        "content": "<p>Especially definition of <code>IsMaximum</code> which, probably, could be defined in some better way.</p>",
        "id": 398464474,
        "sender_full_name": "Lessness",
        "timestamp": 1698233040
    },
    {
        "content": "<p>So first a little bit of notational clean up:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">IsMaximum</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Finsubgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">:</span> <span class=\"n\">M.val.IsMatching</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">M'</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Finsubgraph</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">M'.val.IsMatching</span> <span class=\"bp\">→</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">M'.val.verts</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">M.val.verts</span><span class=\"o\">),</span> <span class=\"n\">Function.Injective</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">mutual</span>\n  <span class=\"kd\">def</span> <span class=\"n\">AlternatingWalkFalse</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Finsubgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}:</span> <span class=\"n\">SimpleGraph.Walk</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">SimpleGraph.Walk.nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">SimpleGraph.Walk.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">M.val.Adj</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">AlternatingWalkTrue</span> <span class=\"n\">M</span> <span class=\"n\">p</span>\n  <span class=\"kd\">def</span> <span class=\"n\">AlternatingWalkTrue</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Finsubgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}:</span> <span class=\"n\">SimpleGraph.Walk</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">SimpleGraph.Walk.nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">SimpleGraph.Walk.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">M.val.Adj</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"bp\">∧</span>  <span class=\"n\">AlternatingWalkFalse</span> <span class=\"n\">M</span> <span class=\"n\">p</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">AugmentingPath</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Finsubgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Path</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">M.val.verts</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>  <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">∉</span> <span class=\"n\">M.val.verts</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n  <span class=\"n\">AlternatingWalkFalse</span> <span class=\"n\">M</span> <span class=\"n\">P.val</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Berge's_lemma</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Finsubgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">M.val.IsMatching</span><span class=\"o\">):</span>\n  <span class=\"n\">IsMaximum</span> <span class=\"n\">H</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Path</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">AugmentingPath</span> <span class=\"n\">M</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>\n</code></pre></div>",
        "id": 398468156,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698234527
    },
    {
        "content": "<p>Secondly, I am not sure how Berge's theorem applies to infinite graphs, but this is partly because I have not touched this area in a long time. The proof that I mentioned works naturally for the case of finite graphs. SimpleGraph V is not finite by default</p>",
        "id": 398468526,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698234688
    },
    {
        "content": "<p>You can always just assume <code>Finite V</code>.</p>",
        "id": 398468619,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698234723
    },
    {
        "content": "<p>Yeah that's what I wanted to say</p>",
        "id": 398468672,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698234733
    },
    {
        "content": "<p>Further, when you limit yourself to finite graphs (perhaps with Finite or Finset), you can use the cardinality based definition of maximum matching</p>",
        "id": 398468886,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698234822
    },
    {
        "content": "<p>And then consider the definition of augmenting path</p>",
        "id": 398469060,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698234878
    },
    {
        "content": "<p>It it based on alternating walks.</p>",
        "id": 398469407,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698235000
    },
    {
        "content": "<p>which need not terminate even in finite graphs</p>",
        "id": 398469431,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698235011
    },
    {
        "content": "<p>Also, I am not sure why you are calling IsMaximum on a proof that M is a matching without using the proof.</p>",
        "id": 398470441,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698235384
    },
    {
        "content": "<p>Aren't walks basically a finite list, which always terminate? Or I'm misunderstanding something.</p>",
        "id": 398478596,
        "sender_full_name": "Lessness",
        "timestamp": 1698238429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Any.20low.20hanging.20fruits.20related.20to.20SimpleGraph.3F/near/398470441\">said</a>:</p>\n<blockquote>\n<p>Also, I am not sure why you are calling IsMaximum on a proof that M is a matching without using the proof.</p>\n</blockquote>\n<p>Fixed.</p>",
        "id": 398478827,
        "sender_full_name": "Lessness",
        "timestamp": 1698238515
    },
    {
        "content": "<p>A walk can loop indefinitely.</p>",
        "id": 398479422,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698238729
    },
    {
        "content": "<p>unlike a path.</p>",
        "id": 398479460,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698238744
    },
    {
        "content": "<p>A path requires a sequence of distinct vertices which form a walk. walks don't have the distinctness requirement.</p>",
        "id": 398479858,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698238872
    },
    {
        "content": "<p>An alternating walk which is looping at the end won't be augmenting.</p>",
        "id": 398480549,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698239089
    },
    {
        "content": "<p>One can't define infinitely long walk, as I believe, even if there are loops. At least in Lean it will be finite, as inductive datatypes do.</p>",
        "id": 398481383,
        "sender_full_name": "Lessness",
        "timestamp": 1698239378
    },
    {
        "content": "<p>No it is not just about infinite walks. Berge's theorem holds for augmenting paths, not augmenting walks.</p>",
        "id": 398483006,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698239929
    },
    {
        "content": "<p>An augmenting walk can loop back to the beginning and it will meet the definition of an augmenting walk (be alternating with both endpoints unmatched). But augmenting the matching with this path will not give you a larger matching.</p>",
        "id": 398483503,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698240099
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">AugmentingPath</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Path</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">M.verts</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">∉</span> <span class=\"n\">M.verts</span> <span class=\"bp\">∧</span> <span class=\"n\">AlternatingWalkFalse</span> <span class=\"n\">M</span> <span class=\"n\">P.val</span>\n</code></pre></div>\n<p>Here I have <code>P: SimpleGraph.Path G x y</code>, so that should be okay, imho. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 398483881,
        "sender_full_name": "Lessness",
        "timestamp": 1698240211
    },
    {
        "content": "<p>yes that should work</p>",
        "id": 398488665,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698241614
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"658873\">Lessness</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Any.20low.20hanging.20fruits.20related.20to.20SimpleGraph.3F/near/398478827\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Any.20low.20hanging.20fruits.20related.20to.20SimpleGraph.3F/near/398470441\">said</a>:</p>\n<blockquote>\n<p>Also, I am not sure why you are calling IsMaximum on a proof that M is a matching without using the proof.</p>\n</blockquote>\n<p>Fixed.</p>\n</blockquote>\n<p>Fixed it back (and changed <code>Finsubgraph</code> to simply <code>Subgraph</code>).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IsMaximum</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">:</span> <span class=\"n\">M.IsMatching</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">M'</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Subgraph</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">M'.IsMatching</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">M'.verts</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">M.verts</span><span class=\"o\">),</span> <span class=\"n\">Function.Injective</span> <span class=\"n\">f</span>\n</code></pre></div>\n<p>Imho, if I remove both <code>M.IsMatching</code>it goes wrong. I need these hypothesis to talk specifically about <code>Matching</code>s, not some general subgraph.</p>",
        "id": 398489532,
        "sender_full_name": "Lessness",
        "timestamp": 1698241849
    },
    {
        "content": "<p>It's similar to this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IsMaximum'</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Subgraph</span> <span class=\"n\">G</span> <span class=\"bp\">//</span> <span class=\"n\">M.IsMatching</span> <span class=\"o\">}):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">H'</span><span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">M'</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Subgraph</span> <span class=\"n\">G</span> <span class=\"bp\">//</span> <span class=\"n\">M'.IsMatching</span> <span class=\"o\">}),</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">H'.val.verts</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">H.val.verts</span><span class=\"o\">),</span> <span class=\"n\">Function.Injective</span> <span class=\"n\">f</span>\n</code></pre></div>",
        "id": 398490871,
        "sender_full_name": "Lessness",
        "timestamp": 1698242205
    },
    {
        "content": "<p>A simpler way to do that is to attach the matching condition to the body of the definition.</p>",
        "id": 398502074,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698245235
    },
    {
        "content": "<p>Because you don't have to destructure the object of the subtype all the time.</p>",
        "id": 398502467,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698245346
    },
    {
        "content": "<p>Current version is such:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">IsMaximum</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">:</span> <span class=\"n\">M.IsMatching</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">M'</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Subgraph</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">M'.IsMatching</span> <span class=\"bp\">→</span>\n  <span class=\"n\">M'.support.ncard</span> <span class=\"bp\">≤</span> <span class=\"n\">M.support.ncard</span>\n\n<span class=\"kd\">mutual</span>\n  <span class=\"kd\">def</span> <span class=\"n\">AlternatingWalkFalse</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}:</span> <span class=\"n\">SimpleGraph.Walk</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">SimpleGraph.Walk.nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">SimpleGraph.Walk.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">¬</span> <span class=\"n\">M.Adj</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"bp\">∧</span> <span class=\"n\">AlternatingWalkTrue</span> <span class=\"n\">M</span> <span class=\"n\">p</span>\n  <span class=\"kd\">def</span> <span class=\"n\">AlternatingWalkTrue</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}:</span> <span class=\"n\">SimpleGraph.Walk</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">SimpleGraph.Walk.nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">SimpleGraph.Walk.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">M.Adj</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"bp\">∧</span> <span class=\"n\">AlternatingWalkFalse</span> <span class=\"n\">M</span> <span class=\"n\">p</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">AugmentingPath</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Path</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">M.support</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">∉</span> <span class=\"n\">M.support</span> <span class=\"bp\">∧</span> <span class=\"n\">AlternatingWalkFalse</span> <span class=\"n\">M</span> <span class=\"n\">P.val</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Berge's_lemma</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Subgraph</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">M.IsMatching</span><span class=\"o\">):</span>\n  <span class=\"n\">IsMaximum</span> <span class=\"n\">H</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Path</span> <span class=\"n\">G</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"bp\">¬</span> <span class=\"n\">AugmentingPath</span> <span class=\"n\">M</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 398514587,
        "sender_full_name": "Lessness",
        "timestamp": 1698248619
    },
    {
        "content": "<p>Will start tinkering with proving this lemma now.</p>",
        "id": 398514818,
        "sender_full_name": "Lessness",
        "timestamp": 1698248684
    },
    {
        "content": "<p>are you comfortable with mutually inductive definitions?</p>",
        "id": 398522557,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698251171
    },
    {
        "content": "<p>Personally I am not.</p>",
        "id": 398522604,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698251195
    },
    {
        "content": "<p>It was the easiest way (for me) to define the <code>AugmentingPath</code>. I believe I have no problems with mutual definitions.</p>\n<p>Do you have some better suggestion?</p>",
        "id": 398525315,
        "sender_full_name": "Lessness",
        "timestamp": 1698252224
    },
    {
        "content": "<p>I'd say feel free to use the mutually inductive definitions if you have no problems proving things about them, at least for the experience.</p>",
        "id": 398526247,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698252593
    },
    {
        "content": "<p>You can also make the <code>False</code>/<code>True</code> suffixes be an actual <code>Bool</code> argument to a single definition</p>",
        "id": 398526338,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698252613
    },
    {
        "content": "<p>I've found before that alternating walks are a real pain to deal with. My last attempt, I made a custom inductive type for them along with maps to plain Walks, since that way you can do <code>cases</code> on the alternating walk and make progress without needing to wrestle with unfolding a definition. <a href=\"https://github.com/leanprover-community/mathlib/blob/a5c872475ef4a299a616d5eb1fc6723128741158/src/hamiltonian2.lean#L458\">https://github.com/leanprover-community/mathlib/blob/a5c872475ef4a299a616d5eb1fc6723128741158/src/hamiltonian2.lean#L458</a></p>",
        "id": 398526858,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698252803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Any.20low.20hanging.20fruits.20related.20to.20SimpleGraph.3F/near/398526338\">said</a>:</p>\n<blockquote>\n<p>You can also make the <code>False</code>/<code>True</code> suffixes be an actual <code>Bool</code> argument to a single definition</p>\n</blockquote>\n<p>Great idea! Done.</p>",
        "id": 398527685,
        "sender_full_name": "Lessness",
        "timestamp": 1698253124
    },
    {
        "content": "<p>you might benefit here from an index which tracks the path length</p>",
        "id": 398534403,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698255921
    },
    {
        "content": "<p>What did I do wrong here? Or, probably better question, what should I use instead of <code>SimpleGraph.Subgraph.degree</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">SimpleGraph.Subgraph.degree</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">aux0</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">}:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span> <span class=\"bp\">→</span> <span class=\"n\">M.degree</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It gives me an error: <code>failed to synthesize instance Fintype ↑(SimpleGraph.Subgraph.neighborSet M x)</code>.</p>",
        "id": 399050780,
        "sender_full_name": "Lessness",
        "timestamp": 1698499397
    },
    {
        "content": "<p>Replace <code>[Finite V]</code> by <code>[Fintype V] [DecidableEq V]</code></p>",
        "id": 399050878,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698499463
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 399050983,
        "sender_full_name": "Lessness",
        "timestamp": 1698499553
    },
    {
        "content": "<p>Another possible option is, I believe, such:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">aux0</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">}:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">M.neighborSet</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ncard</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 399051172,
        "sender_full_name": "Lessness",
        "timestamp": 1698499686
    },
    {
        "content": "<p>Please don't use <code>ncard</code> when you know the set is finite. This is going to prove painful further down the line.</p>",
        "id": 399051208,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698499741
    },
    {
        "content": "<p>Oh, thank you</p>",
        "id": 399051314,
        "sender_full_name": "Lessness",
        "timestamp": 1698499809
    },
    {
        "content": "<p>I am still not sure that using functions with junk values won't result in proving statements that look wrong (emphasis on 'look') and mess with people's minds.</p>",
        "id": 399051362,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698499855
    },
    {
        "content": "<p>At least in graph theory, the correct default can vary according to the problem.</p>",
        "id": 399052256,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698500558
    },
    {
        "content": "<p>Hmm, it still don't work for me. Lean still announces that it can't synthesize the instance. :(<br>\nDoes it work for you?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">aux0</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">):</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span> <span class=\"bp\">→</span> <span class=\"n\">M.degree</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 399052513,
        "sender_full_name": "Lessness",
        "timestamp": 1698500747
    },
    {
        "content": "<p>You probably need <code>[DecidableRel G.Adj]</code> (I take that back, it's unclear which decidability assumption is needed/best)</p>",
        "id": 399052613,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698500806
    },
    {
        "content": "<p>I think <a href=\"http://SimpleGraph.Subgraph.instFintypeElemNeighborSet\">this instance</a> is the one that's not firing because you don't have enough assumptions to get that DecidablePred instance</p>",
        "id": 399052956,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698501066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Any.20low.20hanging.20fruits.20related.20to.20SimpleGraph.3F/near/399051362\">said</a>:</p>\n<blockquote>\n<p>I am still not sure that using functions with junk values won't result in proving statements that look wrong (emphasis on 'look') and mess with people's minds.</p>\n</blockquote>\n<p>If you've got a concrete example of this causing an issue in one of your mathlib formalization projects, then feel free to create a new topic explaining it!</p>",
        "id": 399053468,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698501465
    },
    {
        "content": "<p>What's solution to this? Defining necessary instances by hand?</p>\n<p>Anyway, reading/learning about type classes now in \"Theorem Proving in Lean 4\"... with hope to solve the problem myself, maybe.</p>",
        "id": 399059992,
        "sender_full_name": "Lessness",
        "timestamp": 1698505944
    },
    {
        "content": "<p>This works.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">aux0</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">M.Adj</span><span class=\"o\">]:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span> <span class=\"bp\">→</span> <span class=\"n\">M.degree</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 399066598,
        "sender_full_name": "Lessness",
        "timestamp": 1698511324
    },
    {
        "content": "<p>Yes, some progress! <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> <span aria-label=\"partying face\" class=\"emoji emoji-1f973\" role=\"img\" title=\"partying face\">:partying_face:</span> </p>\n<p>Did long proof (probably could be shortened very much when I get more experience) of the lemma</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">aux0</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M1</span> <span class=\"n\">M2</span><span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H1</span><span class=\"o\">:</span> <span class=\"n\">M1.IsMatching</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H2</span><span class=\"o\">:</span> <span class=\"n\">M2.IsMatching</span><span class=\"o\">):</span>\n  <span class=\"k\">let</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">M1.SymmDiff</span> <span class=\"n\">M2</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S.verts</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">S.neighborSet</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">encard</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span>\n</code></pre></div>",
        "id": 399146881,
        "sender_full_name": "Lessness",
        "timestamp": 1698580979
    },
    {
        "content": "<p>Any hints how to approach lemma <code>aux1</code>?<br>\nIt's <a href=\"https://github.com/LessnessRandomness/Learning/blob/master/Berge.lean\">here</a> at Github.</p>",
        "id": 399152733,
        "sender_full_name": "Lessness",
        "timestamp": 1698585323
    },
    {
        "content": "<p>404 on that link for me</p>",
        "id": 399152839,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698585421
    },
    {
        "content": "<p>Ow, sorry, yes, it's still private. One minute.</p>",
        "id": 399152879,
        "sender_full_name": "Lessness",
        "timestamp": 1698585469
    },
    {
        "content": "<p>Fixed the link</p>",
        "id": 399153011,
        "sender_full_name": "Lessness",
        "timestamp": 1698585579
    },
    {
        "content": "<p>I probably should at first prove that for all graphs with maximum vertex degree 2 there is only three types of connected components... and then use this information to prove their properties for the symmetrical difference of two matchings.</p>",
        "id": 399153158,
        "sender_full_name": "Lessness",
        "timestamp": 1698585691
    },
    {
        "content": "<p>On my phone right now, but isn't aux0 a theorem?</p>",
        "id": 399153406,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698585874
    },
    {
        "content": "<p>Yes. Changed <code>def</code> to <code>theorem</code>.</p>",
        "id": 399153481,
        "sender_full_name": "Lessness",
        "timestamp": 1698585945
    },
    {
        "content": "<p>Simplified <code>aux1</code> formulation to such:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">aux1</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">):</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">M.neighborSet</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">encard</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">M.coe.ConnectedComponent</span><span class=\"o\">),</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">W</span><span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">W.IsTrail</span> <span class=\"bp\">∧</span> <span class=\"n\">W.toSubgraph</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span><span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">induce</span> <span class=\"n\">c.supp</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>If I manage to prove this (big if), then the three types of connected components should be easy to prove. Just reason about the length and equality or inequality of the endpoints.</p>",
        "id": 399161477,
        "sender_full_name": "Lessness",
        "timestamp": 1698591741
    },
    {
        "content": "<p>It seems I need to exclude possibility of infinitely big connected components, otherwise it will be impossible to prove the theorem <code>aux1</code>. What's the best way to do that?<br>\n<code>Finite V</code>, <code>Finite M.verts</code> or maybe even <code>Finite M.support</code>?</p>",
        "id": 399169270,
        "sender_full_name": "Lessness",
        "timestamp": 1698597994
    },
    {
        "content": "<p>I chose to use <code>Finite V</code>, as it seemed the best (subjectively) to me.</p>",
        "id": 399173938,
        "sender_full_name": "Lessness",
        "timestamp": 1698602157
    },
    {
        "content": "<p>Quoting Yaël's advice:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Any.20low.20hanging.20fruits.20related.20to.20SimpleGraph.3F/near/399050878\">said</a>:</p>\n<blockquote>\n<p>Replace <code>[Finite V]</code> by <code>[Fintype V] [DecidableEq V]</code></p>\n</blockquote>",
        "id": 399174174,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1698602403
    },
    {
        "content": "<p>I understand this is not exactly what you're asking, but it just seemed relevant</p>",
        "id": 399174236,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1698602438
    },
    {
        "content": "<p>Right, yes.</p>",
        "id": 399174455,
        "sender_full_name": "Lessness",
        "timestamp": 1698602542
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 399174525,
        "sender_full_name": "Lessness",
        "timestamp": 1698602576
    },
    {
        "content": "<p>In need of suggestions/hints for proof of theorem <code>aux1</code>... Thanks in advance.</p>\n<p>Graph theory is harder than it seems at the first sight. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 399344034,
        "sender_full_name": "Lessness",
        "timestamp": 1698685501
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"658873\">Lessness</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Any.20low.20hanging.20fruits.20related.20to.20SimpleGraph.3F/near/399152733\">said</a>:</p>\n<blockquote>\n<p>It's <a href=\"https://github.com/LessnessRandomness/Learning/blob/master/Berge.lean\">here</a> at Github.</p>\n</blockquote>",
        "id": 399344274,
        "sender_full_name": "Lessness",
        "timestamp": 1698685585
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"658873\">Lessness</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Any.20low.20hanging.20fruits.20related.20to.20SimpleGraph.3F/near/399344034\">said</a>:</p>\n<blockquote>\n<p>Graph theory is harder than it seems at the first sight. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n</blockquote>\n<p>Yup, Lean even had perfectoid spaces before it had graphs!</p>",
        "id": 399344381,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698685625
    },
    {
        "content": "<p>Interesting!</p>",
        "id": 399345047,
        "sender_full_name": "Lessness",
        "timestamp": 1698685828
    },
    {
        "content": "<p>As a first simplification, after you have all the finiteness conditions, don't use encard. This is only going to add extra steps.</p>",
        "id": 399345355,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698685951
    },
    {
        "content": "<p>For further help I will have to play with the proof first.</p>",
        "id": 399346202,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698686277
    },
    {
        "content": "<p>Ok, so the first step is to get rid of the encard. That I can do.</p>",
        "id": 399346687,
        "sender_full_name": "Lessness",
        "timestamp": 1698686448
    },
    {
        "content": "<p>I feel like <code>encard</code> is the least of your worries -- all you need is some lemma that can go back and forth between <code>(M.neighborSet x).encard ≤ 2</code> and some other convenient representation, and applying that lemma is hardly a step compared to a full proof of <code>aux1</code>.</p>\n<p>Do you have a paper proof yet of <code>aux1</code>, one where you don't cheat and use your intuition about how obvious it is? I find that's usually the biggest problem... Lots of this stuff is a lot more technical than you might think.</p>",
        "id": 399346993,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698686580
    },
    {
        "content": "<p>You might benefit from just plugging in the interval_cases version of that claim namely that the degree of x is 0, 1, or 2</p>",
        "id": 399347366,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698686755
    },
    {
        "content": "<p>One argument I can see is that you do induction on the number of edges of <code>M</code>, build up theory for what happens to connected components when you add/delete edges, and then argue that if the edge is joining the connected components then the trails from each connected component's trail must start/end at the vertices being joined since those vertices must be degree &lt;= 1, and so you can join them to make the trail for the joined connected component.</p>",
        "id": 399347498,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698686822
    },
    {
        "content": "<p>Then you have a separate theorem to prove that a connected graph in which all nodes have degree exactly 2 is a cycle.</p>",
        "id": 399347528,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698686830
    },
    {
        "content": "<p>Then a slight generalisation says \" if G is a connected graph with all its vertices having degrees 1 or 2, then it is a cycle or a path\"</p>",
        "id": 399347778,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698686938
    },
    {
        "content": "<p>I forgot to handle the case of an edge that isn't a bridge between connected components -- in that case you argue you can just extend the trail for the connected-component-without-the-edge by the edge. Incidentally that's a cycle, but the fact it's a cycle isn't so important for the proof.</p>",
        "id": 399347782,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698686940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Any.20low.20hanging.20fruits.20related.20to.20SimpleGraph.3F/near/399347778\">said</a>:</p>\n<blockquote>\n<p>Then a slight generalisation says \" if G is a connected graph with all its vertices having degrees 1 or 2, then it is a cycle or a path\"</p>\n</blockquote>\n<p>These are simpler theorems that are show that a graph is one of so many kinds.</p>",
        "id": 399348029,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698687030
    },
    {
        "content": "<p>Then extend them to subgraphs</p>",
        "id": 399348144,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698687077
    },
    {
        "content": "<p>(This is a trivial step)</p>",
        "id": 399348164,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698687087
    },
    {
        "content": "<p>Okay I now see Kyle's message (thanks zulip's android app). His argument is useful for applying the lemmas I described in the subgraphs while handling the connected component related details.</p>",
        "id": 399348938,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698687459
    },
    {
        "content": "<p>OK, you were right that getting rid of <code>S.encard &lt;= 2</code> will be easy.<br>\nProved that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">encard_aux1</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">S</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">S.encard</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span><span class=\"o\">):</span>\n  <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">})</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">})</span>\n</code></pre></div>",
        "id": 399348970,
        "sender_full_name": "Lessness",
        "timestamp": 1698687475
    },
    {
        "content": "<p>(And because getting rid of it is easy, it's harmless keeping it in the definition.)</p>",
        "id": 399349047,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698687500
    },
    {
        "content": "<p>I just think it becomes a tedious distraction</p>",
        "id": 399349105,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698687534
    },
    {
        "content": "<p>It's harmless distraction right now thanks to the theorem (<code>encard_aux1</code>), I believe. Now looking forward the hardest part.</p>\n<p>Will make some kind of paper proof for the start, maybe.<br>\nI like to tinker directly in a proof assistant, without doing paper proofs, but that works only for simplest situations, probably. Must get rid of this habit.</p>",
        "id": 399349524,
        "sender_full_name": "Lessness",
        "timestamp": 1698687716
    },
    {
        "content": "<p>Now reading your suggestions and hints, thank you all!</p>",
        "id": 399349605,
        "sender_full_name": "Lessness",
        "timestamp": 1698687739
    },
    {
        "content": "<p>For <code>aux1</code>, another strategy, rather than futzing too much with connected components, is to reduce to the case that <code>M</code> is connected somehow (going to a connected component, you still have the same degree condition, with the same degrees), and then prove by contradiction. You want to prove that given \"forall x y : V and W : G.walk x y, then if W.toSubgraph is equal to the subgraph, then W is not a trail\" you can prove False. Since G is finite, there must be some walk W such that W.toSubgraph is equal to the subgraph. So then take a least-length such walk. This is not a trail by assumption. Now it's a simple matter of combinatorics <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> (More seriously, you use this to somehow argue you have a vertex of degree at least three, and if there isn't one, to argue that your walk is not of least length.)</p>",
        "id": 399350721,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698688201
    },
    {
        "content": "<p>How can M be connected? It is a matching</p>",
        "id": 399351873,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698688708
    },
    {
        "content": "<p>Not in <code>aux1</code>. (<span class=\"user-mention\" data-user-id=\"658873\">@Lessness</span> There seems to be a bug in the <code>aux1</code> statement. Do you mean <code>M.induce c.supp</code> rather than <code>(⊤: G.Subgraph).induce c.supp</code>?)</p>",
        "id": 399352306,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698688883
    },
    {
        "content": "<p>Ouw. Have to check definition of <code>induce</code>, but it's possible that I have made a bug.</p>",
        "id": 399353403,
        "sender_full_name": "Lessness",
        "timestamp": 1698689290
    },
    {
        "content": "<p><code>(⊤: G.Subgraph).induce c.supp</code> gives you the induced subgraph relative to <code>G</code> itself, and it might have more edges than <code>M.induce c.supp</code> (in particular, edges outside of <code>M</code>). If you want <code>c</code>-as-a-subgraph, then since <code>c : M.coe.ConnectedComponent</code>, it seems that <code>M.induce c.supp</code> is capturing the intent.</p>\n<p>(Side note: at some point I was working on building up API around the set of connected components as subgraphs -- maybe I'll try to find it again and see if it's worth salvaging.)</p>",
        "id": 399354039,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698689562
    },
    {
        "content": "<p>Yes, it seems that <code>M.induce c.supp</code> is the right, not what I had for now.</p>",
        "id": 399354260,
        "sender_full_name": "Lessness",
        "timestamp": 1698689660
    },
    {
        "content": "<p>The first part of <code>aux1</code> - where the connected component has node with degree 0 - is proven (with some ugly proof, imho)<br>\n<a href=\"https://github.com/LessnessRandomness/Learning/blob/106b7d4d349a5b4f84a9b155dec7aeb520ef2385/Berge.lean#L220C1-L220C1\">Here</a></p>\n<p>That's some progress <span aria-label=\"partying face\" class=\"emoji emoji-1f973\" role=\"img\" title=\"partying face\">:partying_face:</span></p>",
        "id": 399726198,
        "sender_full_name": "Lessness",
        "timestamp": 1698845582
    },
    {
        "content": "<p>Erm, should probably restructure the proof somewhat... I mean, prove that connected component with some node of degree zero is trail. In different theorem.<br>\nThen look at connected components with some node of degree 1 (all nodes has degree 1 or 2). Probably another separate theorem.<br>\nAnd then the final theorem where all nodes has degree of 2.</p>\n<p>Then combine them into one - the current formulation of <code>aux1</code>.</p>",
        "id": 399733680,
        "sender_full_name": "Lessness",
        "timestamp": 1698847991
    },
    {
        "content": "<p>Restructuring done.</p>\n<p>Now I have two theorems with <code>sorry</code> and <code>aux1</code> proved assuming these two are correct and will be proved too.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">aux1_subcase_2</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">):</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H0</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">M.neighborSet</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">}),</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">W</span><span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"o\">),</span> <span class=\"n\">W.IsTrail</span> <span class=\"bp\">∧</span>\n  <span class=\"n\">W.toSubgraph</span> <span class=\"bp\">=</span> <span class=\"n\">M.induce</span> <span class=\"o\">(</span><span class=\"n\">M.coe.connectedComponentMk</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">supp</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">aux1_subcase_3</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">G.Subgraph</span><span class=\"o\">):</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">M.coe.ConnectedComponent</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">c.supp</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">x1</span> <span class=\"n\">x2</span><span class=\"o\">,</span> <span class=\"n\">x1</span> <span class=\"bp\">≠</span> <span class=\"n\">x2</span> <span class=\"bp\">∧</span> <span class=\"n\">M.neighborSet</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x1</span><span class=\"o\">,</span> <span class=\"n\">x2</span><span class=\"o\">}),</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">W</span><span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">W.IsCycle</span> <span class=\"bp\">∧</span> <span class=\"n\">W.toSubgraph</span> <span class=\"bp\">=</span> <span class=\"n\">M.induce</span> <span class=\"n\">c.supp</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 399790403,
        "sender_full_name": "Lessness",
        "timestamp": 1698867462
    },
    {
        "content": "<p><code>encard</code> is the correct generality for that  lemma - any connected graph with maximum degree at most 2 is a cycle or (possibly infinite) path.</p>",
        "id": 400157951,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1699025882
    },
    {
        "content": "<p>Hello, currently I'm trying to prove the theorem about graph with max degree 2 and got stuck a bit.<br>\nIn this case I'm going to ask for some help.</p>\n<p>At the file <code>Berge.lean</code>, line 640, I have commented at the place.<br>\nPart of the proof state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">W_1</span><span class=\"o\">:</span> <span class=\"n\">SimpleGraph.Walk</span> <span class=\"o\">(</span><span class=\"n\">SimpleGraph.Subgraph.coe</span> <span class=\"o\">(</span><span class=\"n\">SimpleGraph.Subgraph.deleteVerts</span> <span class=\"n\">M</span> <span class=\"o\">{</span><span class=\"bp\">↑</span><span class=\"n\">v</span><span class=\"o\">}))</span>\n  <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">x_2</span><span class=\"o\">,</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">x_2</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span> <span class=\"bp\">\\</span> <span class=\"o\">{</span><span class=\"bp\">↑</span><span class=\"n\">v</span><span class=\"o\">})</span> <span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">H7</span> <span class=\"o\">}</span>\n<span class=\"n\">H12</span><span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">SimpleGraph.Walk</span> <span class=\"o\">(</span><span class=\"n\">SimpleGraph.Subgraph.coe</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">x_2</span><span class=\"o\">,</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">x_2</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n  <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">H12</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Here I want to do induction on W_1 and construct Walk in the subgraph M using parts of W_1. But the induction doesn't work and I can't find a way to fix that (for now).<br>\nThe error message is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">index</span> <span class=\"k\">in</span> <span class=\"n\">target's</span> <span class=\"n\">type</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">a</span> <span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">consider</span> <span class=\"n\">using</span> <span class=\"n\">the</span> <span class=\"bp\">`</span><span class=\"n\">cases</span><span class=\"bp\">`</span> <span class=\"n\">tactic</span> <span class=\"n\">instead</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">x_2</span><span class=\"o\">,</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">x_2</span> <span class=\"bp\">∈</span> <span class=\"n\">M.verts</span> <span class=\"bp\">\\</span> <span class=\"o\">{</span><span class=\"bp\">↑</span><span class=\"n\">v</span><span class=\"o\">})</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 400373124,
        "sender_full_name": "Lessness",
        "timestamp": 1699172367
    },
    {
        "content": "<p>How are you calling induction?</p>",
        "id": 400405632,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1699200545
    },
    {
        "content": "<p><code>induction W_1</code>... are there other ways, too?</p>",
        "id": 400405727,
        "sender_full_name": "Lessness",
        "timestamp": 1699200643
    },
    {
        "content": "<p>Probably the simple induction isn't going to work even after generalizing a bit. Something to think about.</p>\n<p>Taking a pause because Monday means studying other stuff and tests at university.</p>",
        "id": 400413123,
        "sender_full_name": "Lessness",
        "timestamp": 1699208385
    },
    {
        "content": "<p>I am sorry I forgot about this entirely</p>",
        "id": 402090584,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700005079
    },
    {
        "content": "<p>I was reading the hitchhikers guide to logical verification and came across this exact issue</p>",
        "id": 402090673,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700005117
    },
    {
        "content": "<p>Page 92</p>",
        "id": 402090674,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700005121
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 402090998,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700005303
    },
    {
        "content": "<p>The simplest trick (not described there explicitly) is to take whatever expression lean is complaining about as not a variable (say e), and use the <code>set</code> tactic from mathlib to assign a new variable to it.</p>",
        "id": 402091097,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700005331
    },
    {
        "content": "<p><code>set x:=e with h</code>  will assign a variable x to expression e, replace all occurrences of e with <code>x</code>  in all hypothesis and the goal and insert an equality <code>h: x=e</code> in your hypothesis, which you can use for <code>rw</code></p>",
        "id": 402091239,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700005425
    },
    {
        "content": "<p>Yeah, <code>set</code> or <code>generalize</code> are tricks for this index problem</p>",
        "id": 402091673,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700005636
    },
    {
        "content": "<p>Thank you! I managed to prove auxiliary lemma to use instead of <code>set</code> or <code>generalize</code>, but next time will try them out too.</p>",
        "id": 402729972,
        "sender_full_name": "Lessness",
        "timestamp": 1700237151
    },
    {
        "content": "<p>Anyway, I'm abandoning this Berge's lemma for now (probably at least for two and half months... I have exams at university during January and, if anything goes successfully, then will return to this).</p>\n<p>I believe that anything up to formulation of <code>aux_experiment</code> and the <code>Berge's_lemma</code> at the end is good enough to use for someone who is interesting finishing what I started (if there's anyone, of course). I will be glad to learn from this person, if that happens. :)</p>\n<p>Sorry! And cheers!</p>",
        "id": 402730909,
        "sender_full_name": "Lessness",
        "timestamp": 1700237421
    },
    {
        "content": "<p>Ah well, I hope you had fun struggling with simple graphs, and I hope to see you back!</p>\n<p>(These might be low-hanging fruit, but there's something about combinatorial objects where, you can see the fruit, you can see that you can reach the fruit, but somehow you're not allowed to just go and pick it. There's always some additional complexity you have to sort out first... It's not quite the same, but I'm suddenly reminded of that hilarious babel fish puzzle in the old The Hitchhiker's Guide To The Galaxy text adventure game.)</p>\n<p>To remind myself where you are so far, I think you've got it <a href=\"https://github.com/LessnessRandomness/Learning/blob/master/Berge.lean\">here</a></p>",
        "id": 402757574,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700247204
    },
    {
        "content": "<p><a href=\"https://github.com/LessnessRandomness/Learning/blob/master/FirstProject.lean\">https://github.com/LessnessRandomness/Learning/blob/master/FirstProject.lean</a> - rewrote it so that it works with latest Lean version etc. Will return to it more this week, I believe.</p>\n<p>Just to be sure - the Berge's lemma still isn't proven in Lean, right?</p>",
        "id": 443822062,
        "sender_full_name": "Ilmārs Cīrulis",
        "timestamp": 1718040069
    },
    {
        "content": "<p>I don't think so</p>",
        "id": 443822754,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1718040326
    },
    {
        "content": "<p>No, we still don't have it</p>",
        "id": 443823031,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718040415
    },
    {
        "content": "<p>The file is on Github again. <a href=\"https://github.com/LessnessRandomness/BasicGraphTheory/blob/master/BasicGraphTheory/Berge.lean\">Here</a>.<br>\n(For some reason I had removed the repository.)</p>\n<p>I will learn to prove more basic things about simple graphs now, because it was reason why I couldn't prove Berge's Lemma.</p>",
        "id": 453187186,
        "sender_full_name": "Ilmārs Cīrulis",
        "timestamp": 1721658034
    },
    {
        "content": "<p>On the contrary, targets like Berge's lemma are a good idea. You can start with a high level proof that uses sorried out lemmas and then recurse on the smaller lemmas until you have a proof. With a high level target you have a better idea of what smaller lemmas you want to prove</p>",
        "id": 453212439,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721663005
    },
    {
        "content": "<p>Ultimately, more modular proofs are better because the proof structure is less difficult to parse and easier to fix if something changes in say some tactics or underlying Mathlib lemmas</p>",
        "id": 453212693,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721663081
    }
]