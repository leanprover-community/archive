[
    {
        "content": "<p>We have <code>SimpleGraph.IsPath</code> and <code>SimpleGraph.Path</code> is a structure that bundles this property. When using it I often find myself converting between path and walk. This can be greatly improved by adding more defs and theorems for <code>SimpleGraph.Path</code> (e.g. <code>Path.length</code>). But, do we really need <code>Path</code>? What gains do we get from it, instead of having just <code>Walk</code> and <code>IsPath</code> as assumption?</p>",
        "id": 538000141,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1757162647
    },
    {
        "content": "<p>I didn't realize we had a <code>SimpleGraph.Path</code>, it does seem unnecessary to me, though perhaps I'm missing something. I'd vote for deprecating it.</p>",
        "id": 538003372,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1757165852
    },
    {
        "content": "<p>I did some things with paths, and I used everywhere <code>Walk</code> with <code>IsPath</code> assumption precisely because all the definitions and lemmas that are only available for <code>Walk</code>. I also thought that <code>Path</code> in its current form is unnecessary</p>",
        "id": 538015878,
        "sender_full_name": "IvÃ¡n Renison",
        "timestamp": 1757176660
    },
    {
        "content": "<p>I think, if someone were to make an effort, to make API for <code>Path</code>, it could be usable. I wanted to ask, whether it's worth the effort at all. I.e., imagine there's a full API for <code>Path</code>, what would we gain from it?</p>\n<p>I think that abstracting away definition makes sense, when the definition is an implementation detail, or when you treat your new object as something separate.<br>\nBut I don't see any need to hide the fact that <code>Path</code> is a <code>Walk</code>.</p>",
        "id": 538016824,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1757177699
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"660493\">@Niklas Mohrin</span><br>\nI'm looking at the possibility of deprecating <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Path#doc\">docs#SimpleGraph.Path</a>. Not sure what to do with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Path.instFintype#doc\">docs#SimpleGraph.Path.instFintype</a>. Would <code>Fintype { w : G.Walk u v // w.IsPath }</code> be ok four your usage?<br>\nWe might also want to have <code>instFinite</code> that doesn't require <code>DecidableRel</code> and <code>DecidableEq</code>.</p>",
        "id": 556941011,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1763417986
    },
    {
        "content": "<p>I am using SimpleGraph.Path because in one of my repos. It is actually quite useful in keeping things succinct</p>",
        "id": 556941583,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1763418226
    },
    {
        "content": "<p>If it didn't exist, I would reinvent it.</p>",
        "id": 556941614,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1763418240
    },
    {
        "content": "<p>Would you like to contribute API for <code>Path</code>? Currently, I find it very lacking for it to be useful.</p>",
        "id": 556941974,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1763418380
    },
    {
        "content": "<p>Other people said, they're ok with using <code>Walk</code> and <code>IsPath</code>, have you tried it?</p>",
        "id": 556942206,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1763418474
    },
    {
        "content": "<p>using the walk API in Path is not super hard since Path is just a subtype of Walk. It works with a coercion. The default coercion is to Walk.</p>",
        "id": 556942419,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1763418570
    },
    {
        "content": "<p>Yes, but then any definition will return Walk, not Path. So you're back with Walk and you have to prove IsPath if you want to get back to having Path.</p>",
        "id": 556942508,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1763418610
    },
    {
        "content": "<p>I have trouble with the coercion approach.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆƒ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Walk</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Neither <code>Walk.length p</code> nor <code>p.length</code> works here. Doing coercion manually, i.e. <code>p.val.length</code> works.</p>",
        "id": 556945057,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1763419722
    },
    {
        "content": "<p>FWIW I also vote for deprecating <code>Path</code></p>",
        "id": 556967756,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1763433664
    },
    {
        "content": "<p>Thanks for reaching out, I can provide my thoughts: I always found that passing walks together with their Path-ness makes nicer signatures; it more closely resembles how I think about a definition. I do agree though that trying to always bundle the IsPath (or further hypotheses) does make the code awkward sometimes. Maybe, in our project back then, it would have actually been better to not bother about packing facts up, but I don't know. I did end up just adding convenience definitions like <code>Path.transfer</code> here: <a href=\"https://github.com/niklasmohrin/lean-seminar-2023/blob/5a53c8e067632017bded4fbf24b346b2ffddb84d/FlowEquivalentForest/SimpleGraph/Path.lean#L123\">https://github.com/niklasmohrin/lean-seminar-2023/blob/5a53c8e067632017bded4fbf24b346b2ffddb84d/FlowEquivalentForest/SimpleGraph/Path.lean#L123</a></p>\n<p>Ultimately, I don't care much about the decision, since I am not working with Lean at the moment. I think any work to improve ergonomics around paths would be nice and either having a more thorough Path api or having IsPath instances easily synthesized (or <code>by simp</code> or whatever) when needed would help on that front. Changing the fintype instance to match the rest seems sensible <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 557893634,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1763462191
    },
    {
        "content": "<p>(of course, the project code would break, but that is totally expected; it is not maintained anyways)</p>",
        "id": 557893825,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1763462266
    },
    {
        "content": "<p>I can see some advantages in this deprecration since one can carry <code>IsPath</code> around. But if we do this, I would like to reserve the name <code>Path</code> for an inductive definition of paths. Something roughly like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p_ind</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">new_u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"n\">notin</span><span class=\"w\"> </span><span class=\"n\">p_ind</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">w</span>\n</code></pre></div>",
        "id": 557918668,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1763469027
    },
    {
        "content": "<p>That's pretty much the same as what <code>Path</code> is now. With sufficient API definition doesn't matter in most case. E.g. you can have the <code>cases</code> and <code>induction</code> tactic work just as with the structure you wrote above, by writing custom recursor like this: <a class=\"message-link\" href=\"/#narrow/channel/113489-new-members/topic/Custom.20recursor.20in.20term.20mode/near/556964386\">#new members &gt; Custom recursor in term mode @ ðŸ’¬</a> <br>\nFor <code>match</code> you need to create <code>@[match_pattern]</code>.</p>",
        "id": 558013680,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1763490434
    }
]