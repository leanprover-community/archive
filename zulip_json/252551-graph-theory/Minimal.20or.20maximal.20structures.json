[
    {
        "content": "<p>In graph theory (at least for finite graphs),  we often work with proofs which start by saying \"Consider a maximal/maximum structure with such and such property (for example maximal/maximum length simple path)\". Usually for finite graphs, such structures exist because there are only a finite number of them in an <code>n</code> vertex graph. How do you do express this in lean? My best guess is that one needs to have a theorem saying, for example \"there exists a maximal length path in any finite graph\" or \"there exists a cut which has minimum cut-size\" . Is there a better, more general way to do it?</p>",
        "id": 350500473,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1681735099
    },
    {
        "content": "<p>One of the basic lessons of order theory is that maximum/minimum principles are the same as induction. So the most general way to do this is well-foundedness, but of course that's not a very concrete answer. The cases you're mentioning all can be expressed using a function to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">N</mi></mrow><annotation encoding=\"application/x-tex\">ℕ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span></span></span></span> so I assume you would be happy using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.find\">docs#nat.find</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.find_greatest\">docs#nat.find_greatest</a>?</p>",
        "id": 350501198,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1681735275
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Minimal.20or.20maximal.20structures/near/350501198\">said</a>:</p>\n<blockquote>\n<p>One of the basic lessons of order theory is that maximum/minimum principles are the same as induction. So the most general way to do this is well-foundedness, but of course that's not a very concrete answer. The cases you're mentioning all can be expressed using a function to $$ℕ so I assume you would be happy using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.find\">docs#nat.find</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.find_greatest\">docs#nat.find_greatest</a>?</p>\n</blockquote>\n<p>Is there a version for partial orders?</p>",
        "id": 350506140,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1681736340
    },
    {
        "content": "<p>For example, when I want to make an argument which requires choosing a  maximal matching or maximal path.</p>",
        "id": 350506831,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1681736469
    },
    {
        "content": "<p>My best guess is there might be some theorem in mathlib that makes it possible  to choose the maximal or minimal subset according to the  subset ordering on<code> finset</code>s</p>",
        "id": 350507512,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1681736615
    },
    {
        "content": "<p>Well, you have Zorn's lemma for finding maximal elements in partial orders, but you will to be more precise for me to come up with concrete answers.</p>",
        "id": 350509232,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1681736992
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">maximal_set_exists</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n   <span class=\"o\">(</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">U</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n      <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"n\">T</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"bp\">∧</span> <span class=\"n\">T</span> <span class=\"bp\">⊂</span> <span class=\"n\">V</span>  <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 350512503,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1681737691
    },
    {
        "content": "<p>Isn't Zorn's lemma overkill for finite structures?</p>",
        "id": 350513113,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1681737810
    }
]