[
    {
        "content": "<p>I was reviewing <a href=\"https://github.com/leanprover-community/mathlib4/pull/33121\">#33121</a> and got thinking that maybe we should pick one of these two forms as preferred one?</p>\n<p>With the current API there is a problem with <code>p.support[n]</code>. We have simp-lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/SimpleGraph/Walks/Basic.html#SimpleGraph.Walk.length_support\">SimpleGraph.Walk.length_support</a> which can break automatic index proofs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">error: failed to prove index is valid, possible solutions:</span>\n<span class=\"sd\">  - Use `have`-expressions to prove the index is valid</span>\n<span class=\"sd\">  - Use `a[i]!` notation instead, runtime check is performed, and 'Panic' error message is produced if index is not valid</span>\n<span class=\"sd\">  - Use `a[i]?` notation instead, result is an `Option` type</span>\n<span class=\"sd\">  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid</span>\n<span class=\"sd\">V : Type ?u.243</span>\n<span class=\"sd\">u v : V</span>\n<span class=\"sd\">G : SimpleGraph V</span>\n<span class=\"sd\">w : G.Walk u v</span>\n<span class=\"sd\">n : ℕ</span>\n<span class=\"sd\">h : n ≤ w.length</span>\n<span class=\"sd\">⊢ n &lt; w.support.length</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n</code></pre></div>\n<p>I can think of these possible approaches:</p>\n<ol>\n<li>\n<p>Prefer <code>p.getVert n</code>.<br>\nThis would mean keeping <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/SimpleGraph/Walks/Basic.html#SimpleGraph.Walk.length_support\">SimpleGraph.Walk.length_support</a> as simp-lemma and also adding <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/SimpleGraph/Walks/Traversal.html#SimpleGraph.Walk.support_getElem_eq_getVert\">SimpleGraph.Walk.support_getElem_eq_getVert</a> as a simp-lemma (but with <code>n &lt; p.length + 1</code> assumption instead).</p>\n</li>\n<li>\n<p>Prefer <code>p.support[n]</code> if possible and <code>p.getVert n</code> when <code>n</code> can be out-of-bounds.<br>\nWe would have to either add reversed version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/SimpleGraph/Walks/Basic.html#SimpleGraph.Walk.length_support\">SimpleGraph.Walk.length_support</a> as a simp-lemma, or instruct automatic bounds proofs to use the this reversed lemma (I don't know how, but that should be possible somehow?).</p>\n</li>\n<li>\n<p>Prefer <code>p.support[n]</code> if possible and <code>p.support[n]?</code> or <code>p.support.getD n</code> when <code>n</code> can be out-of-bounds.<br>\nThis is similar to option <code>2.</code>. In this case we might also want to deprecate <code>p.getVert</code>.</p>\n</li>\n</ol>",
        "id": 568656064,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768734142
    },
    {
        "content": "<p>I'm not really sure what would be the best, but I'm leaning towards option 3.</p>",
        "id": 568656129,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768734193
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> You added <code>get_vert</code> so maybe you remember some insight to share on this?</p>",
        "id": 568656479,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768734576
    },
    {
        "content": "<p>I've used both in my work and they are both useful, in the case where we deprecate either many statements will become messy.</p>",
        "id": 568659163,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1768737905
    },
    {
        "content": "<p>I do agree with having a \"canonical\" one though, for example, at the moment we have multiple <code>ext</code> lemmas for walks, like <code>ext_support</code> and <code>ext_getVert</code>, but the <code>ext</code> tactic doesn't call either of them because at the moment we do not prefer one over the other.</p>",
        "id": 568659215,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1768737987
    },
    {
        "content": "<p>So I vote for making <code>support</code> the preferred option, while not depricating <code>getVert</code>.</p>",
        "id": 568659489,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1768738328
    },
    {
        "content": "<p>If you show some examples of how you find <code>.getVert</code> useful then we could work on them. And either you'll convince me it's useful, or I'll convince you that <code>.support</code> can be used instead.</p>\n<p>One reason why <code>.getVert</code> might sometimes be more useful is that some lemmas are stated in terms of <code>.getVert</code>, but not <code>.support</code>. The first one I could find is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/SimpleGraph/Walks/Traversal.html#SimpleGraph.Walk.adj_getVert_succ\">SimpleGraph.Walk.adj_getVert_succ</a>. We could add<br>\n<code>SimpleGraph.Walk.adj_support_getElem_succ {V : Type u} {G : SimpleGraph V} {u v : V} (w : G.Walk u v) {i : ℕ} (hi : i &lt; w.length) : G.Adj w.support[i] w.support[i+1]</code> (currently, bounds check in this statement would fail, so we would have to fix that first).</p>",
        "id": 568660382,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768739311
    },
    {
        "content": "<p>And I'm not saying to deprecate <code>getVert</code> immediately. But if we choose to prefer <code>p.support.getElem</code>, then I think we can slowly work towards deprecating it.</p>",
        "id": 568660524,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768739461
    },
    {
        "content": "<p>I vote (3), I support deprecating <code>getVert</code> (pun intended).<br>\nThe point of <a href=\"https://github.com/leanprover-community/mathlib4/pull/30205\">#30205</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/30225\">#30225</a> was to deprecate <code>getVert</code> but I was hesitant to suggest such a massive change.<br>\nIn general I prefer reusing existing defs rather than adding separate inductive definitions; <code>getVert</code> can be redefined as <code>w.support.getD n</code>.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/252551-graph-theory/topic/.60p.2EgetVert.20n.60.20vs.20.60p.2Esupport.5Bn.5D.60/near/568660382\">said</a>:</p>\n<blockquote>\n<p>We could add<br>\n<code>SimpleGraph.Walk.adj_support_getElem_succ {V : Type u} {G : SimpleGraph V} {u v : V} (w : G.Walk u v) {i : ℕ} (hi : i &lt; w.length) : G.Adj w.support[i] w.support[i+1]</code></p>\n</blockquote>\n<p>See <code>adj_of_infix_support</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/32160\">#32160</a>. Also thanks to <a href=\"https://github.com/leanprover-community/mathlib4/pull/31780\">#31780</a> most bound checks can be <code>...[...]'(by grind)</code> which is nice and short.</p>\n<p>This also feels like a good time to bring up <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span>'s <code>Walk</code> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/560507104\">definition</a>, where a walk is defined directly through its support.</p>",
        "id": 568700185,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768777643
    }
]