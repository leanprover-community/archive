[
    {
        "content": "<p>I haven't touched SimpleGraph in a bit but if I recall correctly there is no standard way of encoding that one walk is a sub-walk of another? I'm not sure if this was previously discussed, searching \"subwalk\" doesn't get many results. There are many equivalent formulations for sub-paths, for sub-walks I'm not sure off the top of my head what the right formulation should be.</p>",
        "id": 526676287,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1751400706
    },
    {
        "content": "<p>I needed this in <a href=\"https://github.com/leanprover-community/mathlib4/pull/25834\">#25834</a> and used <code>support.Sublist</code>, also see if the lemmas you need are in that PR and feel free to use them in separate PRs, just lmk so I make my PR depends on yours</p>",
        "id": 526677023,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1751401055
    },
    {
        "content": "<p>Basically you express both walks as subgraphs (there is a conversion function for this).</p>",
        "id": 526684861,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1751404947
    },
    {
        "content": "<p>subgraphs of the same SimpleGraph</p>",
        "id": 526684899,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1751404968
    },
    {
        "content": "<p>And then you declare that one subgraph is a subgraph of the other</p>",
        "id": 526684915,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1751404978
    },
    {
        "content": "<p>that sounds a bit round about, but you get the edge and vertex subset relations out of it</p>",
        "id": 526684977,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1751405007
    },
    {
        "content": "<p>(Aside : I would also suggest working on an extended definition of SimpleGraph that includes a vertex set and containment relations for vertices and incident edges.)</p>",
        "id": 526685084,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1751405066
    },
    {
        "content": "<p>The reason I prefer this representation is because it immediately helps me connect to other notions defined on subgraphs and simplegraphs like connectivity, matching, reachability etc.</p>",
        "id": 526685263,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1751405152
    },
    {
        "content": "<p>I ended up doing <a href=\"https://github.com/leanprover-community/mathlib4/pull/26614\">#26614</a> which proves some \"sub-walk\" lemmas related to <code>take</code>/<code>drop</code>.<br>\nDo people think its worth it having a <code>subwalk</code> definition in math? It might be a good idea if we will have more such lemmas.</p>",
        "id": 526713293,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1751426802
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> honestly I don't think that approach is good because if you are talking about sub-walks, you are mostly interested in properties of <code>walk</code>s instead of properties of <code>subgraph</code>s, so for example <code>IsPath</code>, <code>IsCycle</code>, etc, these are usually stated in terms of the <code>support</code>.</p>",
        "id": 526714054,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1751427452
    },
    {
        "content": "<p>Two candidate definitions are <code>p.support.Sublist q.support</code>, or using a new inductive type analogous to <code>Sublist</code>. <br>\nThe advantage of the first definition is that we get properties such as <code>IsPath</code> from a subwalk of an <code>IsPath</code> immediately.<br>\n<span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> what do you think is the correct approach here?</p>",
        "id": 526715488,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1751428812
    },
    {
        "content": "<p>I think having a predicate would be nice. It feels like we are already trying to do this in a number of places, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk.support_takeUntil_subset#doc\">docs#SimpleGraph.Walk.support_takeUntil_subset</a> and the following ~9 lemmas are really saying <code>(p.dropUntil ...).IsSubwalk p</code> and <code>(p.takeUntil ...).IsSubwalk p</code> and the statements about support/edges/darts/length are just properties of sub-walk.</p>\n<p>Then things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk.IsPath.of_append_left#doc\">docs#SimpleGraph.Walk.IsPath.of_append_left</a> or the IsTrail equivalent can be stated for subwalks, and it's easier to use that then possibly finding a decomposition of your Path into two pieces to pass into such a lemma. Also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk.IsTrail.dropUntil#doc\">docs#SimpleGraph.Walk.IsTrail.dropUntil</a> and the take/Path equivalents are really again about subwalks.</p>",
        "id": 526717430,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1751430469
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"580947\">@Rida Hamadani</span> Using the support definition sounds reasonable to me. Custom inductively-defined predicates require some extra work to make sure they're actually encoding what you think they do. I like definitions that are 'obviously' correct.</p>\n<p>Another reasonable definition would be that <code>p.IsSubwalk q</code> is defined to be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"bp\">.</span><span class=\"n\">IsSubwalk</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ru</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ru</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">rv</span>\n</code></pre></div>\n<p>In any case, so long as we have a theorem that states that the definition is equivalent to this, then we are good.</p>",
        "id": 526831513,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751470812
    },
    {
        "content": "<p>Oh, nevermind, I got the \"obvious\" definition wrong :-)</p>",
        "id": 526831644,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751470854
    },
    {
        "content": "<p>I wasn't thinking about a subwalk as being a walk that's a subgraph of another walk. I think we need theorems that use the concept to motivate how this should be formalized.</p>",
        "id": 526831987,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751470970
    },
    {
        "content": "<p>Possible variants of the subwalk concept:</p>\n<ul>\n<li>what I wrote, that <code>p</code> is derived from <code>q</code> by removing some prefix and suffix</li>\n<li>what Rida wrote, that <code>p</code> visits some possibly non-contiguous subsequence of vertices of <code>q</code> in order (note: it's possible that <code>p</code> will have edges that <code>q</code> doesn't!)</li>\n<li>a definition where <code>p</code> is a subgraph of <code>q</code> (note: <code>p</code> might visit vertices and edges in a different order, or in reverse!)</li>\n</ul>",
        "id": 526832347,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751471092
    },
    {
        "content": "<p>Neither was I, and I thought Rida wasn't either though I just realized List.Sublist is for non-contiguous sub-lists. I thought we were talking about the first case.</p>",
        "id": 526832610,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1751471192
    },
    {
        "content": "<p>(The exact formulation Kyle used is exactly the case I needed for the lemma which inspired me to ask, though I thought it was too ugly to be a hypothesis and should really be a predicate, the definition of which is unimportant as long as there's an ext lemma for that walk decomposition.)</p>",
        "id": 526833006,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1751471332
    },
    {
        "content": "<p>The list predicate is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.IsInfix#doc\">docs#List.IsInfix</a> then</p>",
        "id": 526833022,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1751471334
    },
    {
        "content": "<p>I thought it is okay for a subwalks to contain non-contiguous sublist, but rethinking this, not including them is probably better. <code>p.support.IsInfix q.support</code> would be useful to have (so we can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.IsInfix.sublist#doc\">docs#List.IsInfix.sublist</a> immediately), perhaps as the definition or as a lemma saying that it is equivalent to Kyle's first point.</p>",
        "id": 526841937,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1751474259
    },
    {
        "content": "<p>(Sublists would admit the following: consider a triangle graph ABC and the walk q from A to B to C. If p is the walk from A to C, then it would be a subwalk of q. )</p>",
        "id": 526842641,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751474536
    },
    {
        "content": "<p>I used Kyle's first definition in <a href=\"https://github.com/leanprover-community/mathlib4/pull/26655\">#26655</a> and then proved that it is equivalent to <code>p.support.IsInfix q.support</code>, but the proof is so unnecessarily big right now, if anybody has ideas to make it smaller please lmk!</p>",
        "id": 526938315,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1751529653
    },
    {
        "content": "<p>Following up on some discussion from <a href=\"https://github.com/leanprover-community/mathlib4/pull/26655\">#26655</a> about what to call contiguous subwalks / non-contiguous subwalks. <br>\nI don't have a strong opinon about exactly what to call contiguous subwalks, (e.g. <code>Walk.IsInfix</code> or <code>IsContiguous</code> etc..) but it might be good to reserve <code>Walk.Subwalk</code> for not-necessarily contiguous subwalks? (The only obvious example of such a non-contiguous subwalk currently in Mathlib would be <code>Walk.bypass</code> but they are pretty natural.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- `p.Subwalk q` if `p` is a (not necessarily contiguous) subwalk of `q`</span>\n<span class=\"sd\">(This definition is modelled on `List.Sublist`.) -/</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Subwalk</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The nil walk `u` is a Subwalk of any `u - v` walk. -/</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Walk</span><span class=\"bp\">.</span><span class=\"n\">nil'</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Subwalk</span><span class=\"w\"> </span><span class=\"n\">q</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- If `p` is a Subwalk of `q`, then it is also a Subwalk of `q.cons h`. -/</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">      </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Subwalk</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Subwalk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- If `p` is a Subwalk of `q`, then `p.cons h` is a Subwalk of `q.cons h`. -/</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons₂</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">      </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Subwalk</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Subwalk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 528853982,
        "sender_full_name": "John Talbot",
        "timestamp": 1752584097
    },
    {
        "content": "<p>I don’t like naming it Infix just because I myself never remember List.Infix, I have to hover over &lt;:+: to remember it. So I think something with subwalk and contiguous or something that’s more directly descriptive seems better to me, but I  don’t feel too strongly about it</p>",
        "id": 528870093,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1752588474
    },
    {
        "content": "<p>One reason I'm hesitant to reserve the name \"subwalks\" for non-contiguous subwalks is that they do not contain the edges of the walk.</p>",
        "id": 528893510,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1752595159
    },
    {
        "content": "<p>Perhaps we’re talking about different things, but my model is that they do contain a subset. If a walks support is (v1, v2, v3, v4, v2, v5) a non contiguous sub walk would be (v1, v2, v5) and all those edges are in the original walk</p>",
        "id": 528894205,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1752595378
    },
    {
        "content": "<p>I was thinking about something more along the lines of the previously proposed <code>p.support.IsSublist q.support</code> definition.</p>",
        "id": 528894823,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1752595581
    },
    {
        "content": "<p>But in the case where its a non-contiguous sub-walk that contains the edges, we can name it something like <code>IsBypass</code>, although honestly I cannot think of cases where this will be useful other than <code>Walk.bypass</code>.</p>",
        "id": 528895314,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1752595722
    },
    {
        "content": "<p>I think there will be more examples. For instance if you have a contiguous closed subwalk <code>p : G.Walk x x</code> of a walk <code>w</code> then it seems natural to talk about the walk constructed from <code>w</code> by removing <code>p</code>. This would be a non-contiguous subwalk.</p>",
        "id": 528896047,
        "sender_full_name": "John Talbot",
        "timestamp": 1752595946
    },
    {
        "content": "<p>Yes, that's a fair point.<br>\nI propose <code>Walk.IsShortening</code> as another candidate name too.</p>",
        "id": 528896567,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1752596090
    },
    {
        "content": "<p>In case anyone cares, just noting that <a href=\"https://github.com/leanprover-community/mathlib4/pull/29369\">#29369</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/29376\">#29376</a> makes some small additions to the <code>IsSubwalk</code> API (and <a href=\"https://github.com/leanprover-community/mathlib4/pull/29375\">#29375</a> is a bit of golf)</p>",
        "id": 537982604,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1757143277
    }
]