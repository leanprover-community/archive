[
    {
        "content": "<p>How do you recommend returning Walk from a function, when its endpoints cannot be (easily) derived from the arguments?<br>\nI couldn't find an example in mathlib of this. Maybe partially because people usually work around this somehow, or just give up on contributing. Here's a function I have (for a context, I want to contribute proof of has odd cycle iff not bipartite):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">odd_cycle_of_odd_walk</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>\n<p>The problem is that returning a dependant pair from a function is usually discouraged and I can confirm that working with this function is a bit painful.<br>\nDo you have some ideas what would be the best thing to do in this case?</p>\n<p>In my opinion, the problem stems from how <code>Walk</code> is defined. IMO, endpoints should be fields and not part of its type signature. Would it be desirable for mathlib to introduce something like <code>SimpleGraph.Walk' : Type*</code> or <code>SimpleGraph.GenericWalk : Type*</code> (with some API)?<br>\nAlthough, maybe something like this shouldn't be introduced to <code>SimpleGraph</code> and it should be introduced to <code>Graph</code> instead, where (I suspect one reason being similar) also vertex set is a field of <code>Graph</code> instead of part of its type signature.</p>",
        "id": 555004429,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1762900895
    },
    {
        "content": "<p>One other weird idea I have, is to maybe have <code>SimpleGraph.Walk' : Set V → Set V → Type*</code>. And have two fields with proofs that the first vertex belongs to the first set, and the last vertex belongs to the second set. Then, <code>SimpleGraph.Walk' {u} {v}</code> would be logically equivalent to <code>SimpleGraph.Walk u v</code> and <code>SimpleGraph.Walk' ⊤ ⊤</code> would be logically equivalent to the version without any arguments.</p>",
        "id": 555006154,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1762902106
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/555004429\">said</a>:</p>\n<blockquote>\n<p>for a context, I want to contribute proof of has odd cycle iff not bipartite</p>\n</blockquote>\n<p>This already exists as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.two_colorable_iff_forall_loop_even#doc\">docs#SimpleGraph.two_colorable_iff_forall_loop_even</a> (<code>G.IsBipartite</code> is defined to be <code>G.Colorable 2</code>), unless you're talking about <a href=\"https://github.com/leanprover-community/mathlib4/blob/00eaaa3d57d9ef1413d9a2bbd86b2fd1ce3853f2/Mathlib/Combinatorics/SimpleGraph/Bipartite.lean#L55-L56\">this TODO</a> which formulates the statement a bit differently.<br>\nIf you're planning to solve that TODO and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.two_colorable_iff_forall_loop_even#doc\">docs#SimpleGraph.two_colorable_iff_forall_loop_even</a> isn't helping, you can try using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finTwoEquiv#doc\">docs#finTwoEquiv</a> to convert <code>G.IsBipartite</code> which is <code>Nonempty (G.Coloring (Fin 2))</code> to <code>Nonempty (G.Coloring Bool)</code> and then use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Coloring.even_length_iff_congr#doc\">docs#SimpleGraph.Coloring.even_length_iff_congr</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Coloring.odd_length_iff_not_congr#doc\">docs#SimpleGraph.Coloring.odd_length_iff_not_congr</a>.<br>\nAdditionally, theorems from <a href=\"https://github.com/leanprover-community/mathlib4/pull/29579\">#29579</a> (e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.chromaticNumber_eq_two_iff#doc\">docs#SimpleGraph.chromaticNumber_eq_two_iff</a>) might be relevant, not sure.<br>\nWhy do you need the <code>def</code> above to prove this theorem?</p>",
        "id": 555016502,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1762910813
    },
    {
        "content": "<p>As for the walk suggestions, I think <code>Walk</code> is good as it is now, but the set suggestion sounds quite good tbh (as long as we're not replacing the existing <code>Walk</code>), as it might be helpful for working with cuts in graphs.</p>",
        "id": 555016763,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1762910994
    },
    {
        "content": "<p>Concrete suggestion: you can maybe split the function in two, one that returns a vertex and then another that returns a closed walk on that vertex.<br>\nI'm interested to learn how you managed to get an odd cycle from an odd walk, can you share the body of that function? This might enhance <a href=\"https://github.com/leanprover-community/mathlib4/pull/31217\">#31217</a></p>",
        "id": 555017212,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1762911307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/555016502\">said</a>:</p>\n<blockquote>\n<p>This already exists as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.two_colorable_iff_forall_loop_even#doc\">docs#SimpleGraph.two_colorable_iff_forall_loop_even</a> (<code>G.IsBipartite</code> is defined to be <code>G.Colorable 2</code>), unless you're talking about <a href=\"https://github.com/leanprover-community/mathlib4/blob/00eaaa3d57d9ef1413d9a2bbd86b2fd1ce3853f2/Mathlib/Combinatorics/SimpleGraph/Bipartite.lean#L55-L56\">this TODO</a> which formulates the statement a bit differently.</p>\n</blockquote>\n<p>I wanted to make this topic to just focus the discussion on Walk API. You can check the discussion here to discuss the theorem: <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/bipartite.20iff.20does.20not.20contain.20an.20odd.20cycle/with/537048797\">#Is there code for X? &gt; bipartite iff does not contain an odd cycle</a>. The theorem in mathlib is not exactly the same, see <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/bipartite.20iff.20does.20not.20contain.20an.20odd.20cycle/near/536810721\">this message</a>. As for the TODO, I have <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/bipartite.20iff.20does.20not.20contain.20an.20odd.20cycle/near/536817520\">one implication</a>. I strongly suspect the second implication is easy with the stronger version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.two_colorable_iff_forall_loop_even#doc\">docs#SimpleGraph.two_colorable_iff_forall_loop_even</a> (and I have this mostly completed, I'm struggling with Lean, the problem with Walk being main blocker).</p>\n<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/555016502\">said</a>:</p>\n<blockquote>\n<p>Why do you need the <code>def</code> above to prove this theorem?</p>\n</blockquote>\n<p>Specifically to have the stronger version with cycles, not any walk.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/555017212\">said</a>:</p>\n<blockquote>\n<p>Concrete suggestion: you can maybe split the function in two, one that returns a vertex and then another that returns a closed walk on that vertex.</p>\n</blockquote>\n<p>The problem is, that this would be basically duplicating most of the code. Although, maybe I could try defining a private function that returns a pair, and then use it to define the two separate functions. Not sure if that would fix any problems. But it might only contain them to theorems regarding just this function.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/555016763\">said</a>:</p>\n<blockquote>\n<p>As for the walk suggestions, I think <code>Walk</code> is good as it is now, but the set suggestion sounds quite good tbh (as long as we're not replacing the existing <code>Walk</code>), as it might be helpful for working with cuts in graphs.</p>\n</blockquote>\n<p>I don't know what example specifically you have in mind, but I think that both the Set arguments version, and version without any arguments, will help in every case when working with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Walk#doc\">docs#Walk</a> where the endpoints have to change in some non-trivial way. Not sure if the Set idea is good. Basically instead of <code>G.Walk' s t</code> you can have smth like <code>(w : G.Walk') → w.fst ∈ s → w.last ∈ t</code>, in the case where <code>G.Walk' s t</code> is argument. And if <code>G.Walk' s t</code> is being returned, than you can prove <code>w.fst ∈ s</code> and <code>w.last ∈ t</code> in separate theorems. The fields-instead-of-arguments version is more flexible, you can easily plug-in any statement about the vertices, not just Set membership. Although, with the Set version, you can still do smth like <code>(w : G.Walk' ⊤ ⊤) → p w.fst → q w.last</code>, to use some non-trivial statements about vertices. I think the Set version only makes sense if the Set membership covers most of typical use-cases.</p>",
        "id": 555220147,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1762980612
    },
    {
        "content": "<p>Sounds like a similar problem, although with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NFA.Path#doc\">docs#NFA.Path</a>: <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/dependent.20product.20as.20return.20type/with/522923992\">#mathlib4 &gt; dependent product as return type</a></p>",
        "id": 555222426,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1762981483
    },
    {
        "content": "<p>I changed my mind, I now support adding a version of <code>Walk</code> with no endpoints (and no sets).<br>\nSomething like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Walk'</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toWalk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"n\">snd</span>\n</code></pre></div>\n<p>but with a better name. <code>G.Walk'</code> is to <code>G.Walk</code> what <code>G.Dart</code> is to <code>G.Adj</code>.<br>\nThough I prefer adding a generic wrapper for these kinds of unbundled structures:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ProdWithData</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">inner</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"n\">snd</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Walk'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ProdWithData</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Walk'</span><span class=\"bp\">.</span><span class=\"n\">toWalk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">inner</span>\n</code></pre></div>\n<p><code>ProdWithData</code> can then be used on <code>SimpleGraph.Walk</code>, <code>SimpleGraph.Adj</code> (for <code>Dart</code>), <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Path#doc\">docs#Path</a> (topology), <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NFA.Path#doc\">docs#NFA.Path</a> that you mentioned, and probably many path-y things.</p>",
        "id": 560500504,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1764205816
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover-community/mathlib4/pull/30293/files#r2566794849\">#30293</a> for another possible use-case of a generic <code>Walk</code></p>",
        "id": 560500584,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1764205888
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/560500504\">said</a>:</p>\n<blockquote>\n<p>I changed my mind, I now support adding a version of <code>Walk</code> with no endpoints (and no sets).<br>\nSomething like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Walk'</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toWalk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"n\">snd</span>\n</code></pre></div>\n<p>but with a better name.</p>\n</blockquote>\n<p>You probably shouldn't <code>extends V × V</code></p>",
        "id": 560500824,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764206105
    },
    {
        "content": "<p>What's the point of extending product, instead of just having structure with two additional fields? And what's the point of <code>ProdWithData</code>?</p>",
        "id": 560500907,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764206169
    },
    {
        "content": "<p>You would still need to write boilerplate for the API with <code>ProdWithData</code>. I guess it might be slightly less work if we have this generic structure.</p>",
        "id": 560501052,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764206299
    },
    {
        "content": "<p>Not sure if <code>match</code> allows somehow writing custom <code>@[match_pattern]</code> for structure pattern syntax? If not, then I think you lose potentially useful feature of having custom names for the elements of the product in structure pattern.</p>\n<p>E.g. this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Walk'</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">toWalk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"n\">last</span>\n</code></pre></div>\n<p>you can match like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">last</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toWalk</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>But <code>ProdWithData G.Walk</code> you would have to match as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">fst</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">snd</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inner</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>And, afaik, Lean currently doesn't give any way to change this.</p>\n<p>Also, when <code>F</code> in the definition of <code>ProdWithData</code> is a conjunction, then it would likely be simpler to have it as a two separate fields.</p>",
        "id": 560501671,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764206802
    },
    {
        "content": "<p>If you think generalizing this would be useful to avoid work in the future, then maybe having <code>prod_with_data</code> as macro would be a better approach? E.g. something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Walk'</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">toWalk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"n\">last</span>\n\n<span class=\"n\">prod_with_data</span><span class=\"w\"> </span><span class=\"n\">Walk'</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Walk</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">prod_with_data</span><span class=\"w\"> </span><span class=\"n\">Walk</span><span class=\"kd\">]</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Walk'</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">toWalk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"n\">last</span>\n</code></pre></div>\n<p>And <code>prod_with_data</code> macro would take care of creating some common API.</p>",
        "id": 560501989,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764207121
    },
    {
        "content": "<p>But having macros that generate code is potentially sketchy. Lean ensures correctness of proofs, so it's fine to generate proofs with tactics. But Lean doesn't ensure correctness of your definitions. You must still read them carefully. Generating them through macros, means, you either need to prove correctness of your macro somehow (sound very hard, Lean semantics aren't even formalized), or just read the code generated my macro.</p>",
        "id": 560502799,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764207858
    },
    {
        "content": "<p>You could actually kick out the indices and you would lose nothing in the current definition of a walk. The end points could simply be deduced from it</p>\n<p>EDIT: I mean you can deduce the Walk (and its indices) by returning something else. See below.</p>",
        "id": 560504905,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764209217
    },
    {
        "content": "<p>I actually tried this for Digraphs.</p>",
        "id": 560504922,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764209234
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> I couldn't understand what do you mean.</p>",
        "id": 560504990,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764209311
    },
    {
        "content": "<p>Isn't kicking out indices the point of this whole <code>Walk'</code> discussion?</p>",
        "id": 560505019,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764209341
    },
    {
        "content": "<p>There is a function in mathlib to convert walks to edgelists</p>",
        "id": 560505144,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764209460
    },
    {
        "content": "<p>you can simply reconstruct the walk from the edge list.</p>",
        "id": 560505156,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764209474
    },
    {
        "content": "<p>the <code>List (Sym2 V)</code> requires no indices, so you can return that from your function.</p>",
        "id": 560505187,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764209492
    },
    {
        "content": "<p>Or since you are using SimpleGraph, you could also just return <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk.support#doc\">docs#SimpleGraph.Walk.support</a></p>",
        "id": 560505283,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764209584
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/560504990\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> I couldn't understand what do you mean.</p>\n</blockquote>\n<p>Sorry I am focused on the function you initially described</p>",
        "id": 560505295,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764209597
    },
    {
        "content": "<p>So you don't really need indices and dependent sums to return a walk</p>",
        "id": 560505389,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764209688
    },
    {
        "content": "<p>For the wider discussion, here's a more abstract definition of a walk:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">AltWalk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">st</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"n\">len_atleast_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">st_prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">st</span>\n<span class=\"w\">  </span><span class=\"n\">en_prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">en</span>\n<span class=\"w\">  </span><span class=\"n\">adj_prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 560505858,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764210187
    },
    {
        "content": "<p>or better yet:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">ListWalk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">len_prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">adj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\">  </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 560506490,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764210724
    },
    {
        "content": "<p>Even better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">ListChainWalk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">chainAdj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">support</span>\n</code></pre></div>",
        "id": 560507104,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764211235
    },
    {
        "content": "<p>From this, you get the adjacency relation in terms of indices for <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/List/Chain.html#List.isChain_iff_get\">free</a></p>",
        "id": 560507156,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764211279
    },
    {
        "content": "<p>I prefer one of the last two definitions for the reason that sometimes you want to return the equivalent of <code>Walk.nil</code> which is of type <code>G.Walk u u</code> and your function has a generic return type <code>G.Walk u v</code> and now you have to insert an extra <code>Eq.subst</code> to prove to lean that <code>u = v</code>, which is tedious. This doesn't seem to happen with IsChain since it has only one index.</p>",
        "id": 560507286,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764211420
    },
    {
        "content": "<p>and of course a bunch of the current API just duplicates the theorems of <code>IsChain</code> and Lists anyway. So the last definition is the ideal definition of a walk (perhaps with a <code>support \\neq []</code> condition)</p>",
        "id": 560507331,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764211449
    },
    {
        "content": "<p>The inductive definition does have some benefit of simplicity, in terms that many basic definition are simple to define too. Though, we can still get the recursor for induction/cases even with non-inductive definition. Non-inductive definition might be better in the long run.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/560505187\">said</a>:</p>\n<blockquote>\n<p>the <code>List (Sym2 V)</code> requires no indices, so you can return that from your function.</p>\n</blockquote>\n<p>You can't recover Walk from <code>List (Sym2 V)</code> in some (infinite number of) cases. Although, it's not case for this particular function, which always returns a cycle.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/560507286\">said</a>:</p>\n<blockquote>\n<p>I prefer one of the last two definitions for the reason that sometimes you want to return the equivalent of <code>Walk.nil</code> which is of type <code>G.Walk u u</code> and your function has a generic return type <code>G.Walk u v</code> and now you have to insert an extra <code>Eq.subst</code> to prove to lean that <code>u = v</code>, which is tedious. This doesn't seem to happen with IsChain since it has only one index.</p>\n</blockquote>\n<p>I also often have problems witch matching <code>.nil</code>. Being tedious because of having to add <code>subst</code> in proofs is one thing. But in definitions <code>match</code> will just fail in the <code>.nil</code> case which just blocked me from writing what I needed multiple times. But with bundled data I think that problem with <code>match</code> won't manifest?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/560506490\">said</a>:</p>\n<blockquote>\n<p>or better yet:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">ListWalk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">len_prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">adj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\">  </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Do we want to enforce <code>support.length &gt; 0</code>? Maybe it would make sense to support walk that has vertex-length equal to zero as well as walks that have vertex-length equal to one?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/560507104\">said</a>:</p>\n<blockquote>\n<p>Even better:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">ListChainWalk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">chainAdj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">IsChain</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">support</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I agree, this one seems the best from your propositions. I also already did some experiments with exactly the same definition using <code>List.IsChain</code>.</p>",
        "id": 560508823,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764212760
    },
    {
        "content": "<p>Basically when it comes to multiple indices of the same type, match, cases and everything else will just give up trying to check it they are equal</p>",
        "id": 560508947,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764212860
    },
    {
        "content": "<p>With<code> cases</code> you get a “dependent elimination failed” error</p>",
        "id": 560508975,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764212887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/560508823\">said</a>:</p>\n<blockquote>\n<p>I also often have problems witch matching <code>.nil</code>. Being tedious because of having to add <code>subst</code> in proofs is one thing. But in definitions <code>match</code> will just fail in the <code>.nil</code> case which just blocked me from writing what I needed multiple times. But with bundled data I think that problem with <code>match</code> won't manifest?</p>\n</blockquote>\n<p>Does it work if you add the indices as match discriminants?</p>",
        "id": 560509051,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764212963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/560509051\">said</a>:</p>\n<blockquote>\n<p>Does it work if you add the indices as match discriminants?</p>\n</blockquote>\n<p>That's what I always try, and sometimes it does, sometimes it doesn't.</p>",
        "id": 560509083,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764212997
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/560508975\">said</a>:</p>\n<blockquote>\n<p>With<code> cases</code> you get a “dependent elimination failed” error</p>\n</blockquote>\n<p><code>cases</code> doesn't fail I think? It just won't do a substitution, but won't fail. You can use <code>cases h : w</code> and then <code>rw! [h]</code>, cause <code>rw!</code> does better job then <code>cases</code>.</p>",
        "id": 560509138,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764213046
    },
    {
        "content": "<p>For the general case of multigraphs, instead of using <code>G.Adj</code> as the chain relation you have a list of <code>(v : V) x (e : E)  x (w : V)  x (Adj v e w) </code> and the chain relation is something like <code>fun x y =&gt; x.snd.snd = y.fst</code></p>",
        "id": 560509183,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764213095
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/560509183\">said</a>:</p>\n<blockquote>\n<p>For the general case of multigraphs, instead of using <code>G.Adj</code> as the chain relation you have a list of <code>(v : V) x (e : E)  x (w : V)  x (Adj v e w) </code> and the chain relation is something like <code>fun x y =&gt; x.snd.snd = y.fst</code></p>\n</blockquote>\n<p>That won't admit 1-vertex-length walks I think?</p>",
        "id": 560509314,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764213207
    },
    {
        "content": "<p>Sadly yes.</p>",
        "id": 560509478,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764213391
    },
    {
        "content": "<p>But that’s the Diestel definition. </p>\n<p>Anyway,  I am currently interested in something I can use with SimpleGraph and Digraph. I think it is a mistake to try to aim for a common API via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Graph#doc\">docs#Graph</a></p>",
        "id": 560509534,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764213450
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/560509534\">said</a>:</p>\n<blockquote>\n<p>But that’s the Diestel definition. </p>\n</blockquote>\n<p>Diestel's definition does admit 1-vertex-length walks:</p>\n<blockquote>\n<p>A walk (of length k) in a graph G is a non-empty alternating sequence v0e0v1e1 . . . ek−1vk of vertices and edges in G such that ei = { vi, vi+1 } for all i &lt; k.</p>\n</blockquote>",
        "id": 560509635,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764213565
    },
    {
        "content": "<p>Yeah but the problem is you want to fit diestels definition without getting into dependent type hell or heterogenous lists.</p>",
        "id": 560509948,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764213870
    },
    {
        "content": "<p>I just modified the basic defs file of my Digraph.Walk and Path API to this definition. Lemmas still need changing. Feel free to use this with changes. It might be easier to add the Digraph API fresh and then retrofit only the necessary pieces of SimpleGraph API (and delete the rest)</p>\n<p>Just give the required license/author attribution if you plan to make a PR.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Digraph.Walk basic defs only</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">Copyright (c) 2025 Shreyas Srinivas. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: Shreyas Srinivas</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Digraph</span>\n\n<span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">Digraph.Walk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Digraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">chainAdj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List.IsChain</span><span class=\"w\"> </span><span class=\"n\">G.Adj</span><span class=\"w\"> </span><span class=\"n\">support</span>\n\n\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">IsCircuit</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Digraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.Walk</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">W.support.length</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">W.support.head</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">W.support.getLast</span>\n\n\n<span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">Digraph.Path</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Digraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kd\">extends</span><span class=\"w\"> </span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">nodup</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List.Nodup</span><span class=\"w\"> </span><span class=\"n\">support</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">IsCycle</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Digraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.Path</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">IsCircuit</span><span class=\"w\"> </span><span class=\"n\">P.toWalk</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Digraph.Walk.Length</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Digraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.Walk</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">W.support.length</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Digraph.Walk.Single</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Digraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.Walk</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">chainAdj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">List.IsChain.singleton</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Digraph.Path.Single</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Digraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.Path</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">chainAdj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">List.IsChain.singleton</span>\n<span class=\"w\">  </span><span class=\"n\">nodup</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp_all</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Digraph.Walk.cons</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Digraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.Walk</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hAdj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hnempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">W.support</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\">    </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G.Adj</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">W.support.head</span><span class=\"w\"> </span><span class=\"n\">hnempty</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.Walk</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">W.support</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">vs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">vs</span>\n<span class=\"w\">  </span><span class=\"n\">chainAdj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hchainW</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">W.chainAdj</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">hW</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">W.support</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hW</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">hchainW</span><span class=\"w\"> </span><span class=\"n\">hAdj</span>\n<span class=\"w\">        </span><span class=\"n\">constructor</span>\n<span class=\"w\">        </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ne_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">reduceCtorEq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List.head_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">forall_const</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">assumption</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Digraph.Walk.tail</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Digraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.Walk</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.Walk</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">W.support.tail</span>\n<span class=\"w\">  </span><span class=\"n\">chainAdj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">List.IsChain.tail</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">W.chainAdj</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Digraph.Path.cons</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Digraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.Path</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hnewvertex</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List.Nodup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">W.support</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hAdj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hnempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">W.support</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\">    </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G.Adj</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">W.support.head</span><span class=\"w\"> </span><span class=\"n\">hnempty</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.Path</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">W.support</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">vs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">vs</span>\n<span class=\"w\">  </span><span class=\"n\">chainAdj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hchainW</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">W.chainAdj</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">hW</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">W.support</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hW</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">hchainW</span><span class=\"w\"> </span><span class=\"n\">hAdj</span>\n<span class=\"w\">        </span><span class=\"n\">constructor</span>\n<span class=\"w\">        </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ne_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">reduceCtorEq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List.head_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">forall_const</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">assumption</span>\n<span class=\"w\">  </span><span class=\"n\">nodup</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">hW</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">W.support</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">simp_all</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">edgeList</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Digraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.Walk</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">hW</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">W.support</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">_</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">edgeList</span><span class=\"w\"> </span><span class=\"n\">W.tail</span>\n<span class=\"w\">  </span><span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">W.support.length</span>\n<span class=\"w\">  </span><span class=\"n\">decreasing_by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Walk.tail</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hW</span><span class=\"o\">]</span>\n</code></pre></div>\n</div></div>",
        "id": 560512456,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764216063
    },
    {
        "content": "<p>We should probably ask the graph theory maintainers/reviewers : CC <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span></p>",
        "id": 560512804,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764216361
    },
    {
        "content": "<blockquote>\n<p>The inductive definition does have some benefit of simplicity, in terms that many basic definition are simple to define too. Though, we can still get the recursor for induction/cases even with non-inductive definition. Non-inductive definition might be better in the long run.<br>\n ``````</p>\n</blockquote>",
        "id": 560517716,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764220388
    },
    {
        "content": "<p>The <code>List.IsChain</code> based definition is inductive. See how IsChain is defined</p>",
        "id": 560517792,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764220455
    },
    {
        "content": "<p>It just has one index. The list itself.</p>",
        "id": 560517817,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764220476
    },
    {
        "content": "<p>Update :  I have started work on formalising combinatorial flow algorithms. The repository is here. It is still an early WIP, but it uses my definition of walks. I still think some refining is needed in the ford Fulkerson description (which is largely because I haven’t actually implemented Edmond’s Karp path selection and I haven’t checked the start and terminal vertices of paths. But these are trivial to fix</p>\n<p>Repo : <a href=\"https://github.com/Shreyas4991/LeanFlows\">https://github.com/Shreyas4991/LeanFlows</a></p>",
        "id": 560896055,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764405603
    },
    {
        "content": "<p>The goal is to finish push relabelling. Then it can be extended (with a lot of additional graph theory to the recent FOCS 2025 paper albeit only for correctness).</p>",
        "id": 560896125,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764405662
    },
    {
        "content": "<p>Also CC : <span class=\"user-mention\" data-user-id=\"759386\">@Sorrachai Yingchareonthawornchai</span>  you might be interested.</p>",
        "id": 560896186,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764405716
    },
    {
        "content": "<p>I have different definitions in mind, but please go ahead, and let us know how it goes. The design space is quite large. It is good to have attempts and discuss the strengths/weaknesses of the design.</p>",
        "id": 560896724,
        "sender_full_name": "Sorrachai Yingchareonthawornchai",
        "timestamp": 1764406261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"759386\">Sorrachai Yingchareonthawornchai</span> <a href=\"#narrow/channel/252551-graph-theory/topic/How.20to.20return.20Walk/near/560896724\">said</a>:</p>\n<blockquote>\n<p>I have different definitions in mind, but please go ahead, and let us know how it goes. The design space is quite large. It is good to have attempts and discuss the strengths/weaknesses of the design.</p>\n</blockquote>\n<p>Apologies for the late reply. I have been travelling. I already wrote one half of the max flow-min cut theorem 1.5 years ago using the definitions available in mathlib at that time ( I am not recovering that code now, it was written before lean4 had the notion of stable versions). Since then lean and its tactics have come a long way. Part of my motivation is to see how far I can go this time and to test my definition of a walk over the mathlib simplegraph version</p>",
        "id": 561283133,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764626154
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 561283507,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764626335
    },
    {
        "content": "<p>small update : This definition of walks is a breeze to work with. I am missing the code action with fun_induction though.</p>",
        "id": 561524867,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764711829
    }
]