[
    {
        "content": "<p>At NYC Lean after a few weeks fighting with rearranging finset.sums we proved the Graham-Pollak theorem. In order to do so we needed edge partitions, which Mathlib doesn't have (<code>Partition</code> is vertex partitions) and I couldn't find any prior discussion of.</p>\n<p>Is there a reason not to PR them, and to do so as below along with some API:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- An edge partition of a simple graph `G`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">EdgePartition</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- `parts`: sets of subsets of the edges of `G`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">parts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edgeSet</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- `isPartition`: a proof that `parts` is a proper partition of the edges. -/</span>\n<span class=\"w\">  </span><span class=\"n\">isPartition</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"bp\">.</span><span class=\"n\">IsPartition</span><span class=\"w\"> </span><span class=\"n\">parts</span>\n</code></pre></div>\n<p>And then secondarily, is Graham-Pollak itself suitable for Mathlib, or is there a generalization of it which we would want instead? I don't know much graph theory but my quick googling seemed to suggest that generalizing too far away from it leads quickly to open problems... The statement we proved is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">The Graham-Pollak theorem:</span>\n\n<span class=\"sd\">In a complete graph on `|V|` vertices, any edge partition into complete bipartite subgraphs has</span>\n<span class=\"sd\">at least `|V| - 1` parts.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">card_le_card_parts_add_one_of_CompleteBipartite</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">EdgePartition</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"bp\">.</span><span class=\"n\">parts</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">completeBipartiteOf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">CompleteBipartite</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"bp\">.</span><span class=\"n\">graph</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"bp\">.</span><span class=\"n\">parts</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 567399109,
        "sender_full_name": "Julian Berman",
        "timestamp": 1768147374
    },
    {
        "content": "<p>I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.EdgeLabeling#doc\">docs#SimpleGraph.EdgeLabeling</a> is equivalent to <code>EdgePartition</code>, though I'm not sure how to convert a function <code>α → β</code> to <code>Set (Set α)</code> + a proof of <code>Setoid.IsPartition</code>. Perhaps <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Setoid.ker#doc\">docs#Setoid.ker</a>, or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.preimage#doc\">docs#Set.preimage</a> of singletons (<code>{ f ⁻¹' {b} | b : β }</code>).<br>\n(<code>EdgeLabeling</code> was upstreamed for Ramsey's theorem)<br>\nThe <a href=\"https://en.wikipedia.org/wiki/Graham%E2%80%93Pollak_theorem\">Wikipedia page</a> links to <a href=\"https://en.wikipedia.org/wiki/Graph_labeling\">Graph labeling</a>, and it does seem vaguely similar to Ramsey stuff.<br>\nI prefer having just one definition (i.e. <code>EdgeLabeling</code>), and it also feels more constructive in some sense. Unless the <code>Set (Set _))</code> version is easier to work with in some places?</p>",
        "id": 567415205,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768164741
    },
    {
        "content": "<p>Aha, I indeed missed that definition, let's see if I can slot it in easily, thanks for the pointer.</p>",
        "id": 567415372,
        "sender_full_name": "Julian Berman",
        "timestamp": 1768165013
    },
    {
        "content": "<p>I didn't know about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Partition#doc\">docs#SimpleGraph.Partition</a>, and in contrast to your <code>EdgePartition</code> they have a condition requiring every part is an independent set. So now I'm wondering:</p>\n<ul>\n<li>Why do we have an equivalent formulation of coloring? They were even added together (<a href=\"https://github.com/leanprover-community/mathlib3/pull/10287\">mathlib3#10287</a>), and there are conversion functions between them (both ways).</li>\n<li>There seem to be 3 binary choices here which can make 8 possible definitions: vertex/edge, function/set-of-sets, whether to restrict it with a coloring-like condition.<br>\n  We have <code>Coloring</code> (001), <code>Partition</code> (011), <code>EdgeLabeling</code> (100), <code>EdgeColoring</code> (101) in PR, and you're suggesting <code>EdgePartition</code> (110).<br>\n  Should we have all 8? I'm not sure what to make of this</li>\n</ul>",
        "id": 567417137,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768167416
    },
    {
        "content": "<p>(my opinion is to deprecate <code>Partition</code> since it's old and doesn't seem used, whereas colorings are known to be useful concepts, and maybe a definition for <code>EdgeLabeling</code> is a bit weird but Ramsey theory is a great justification IMO)</p>",
        "id": 567417271,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768167572
    },
    {
        "content": "<p>It seems like no matter what happens it'd be nice to sprinkle words like \"decomposition\" and \"partition\" into a few more docstrings to help whichever definitions remain be a bit easier to find.</p>",
        "id": 567418128,
        "sender_full_name": "Julian Berman",
        "timestamp": 1768168572
    },
    {
        "content": "<p>FWIW it turned out to be completely trivial to drop in <code>EdgeLabeling</code>, and the API / lemmas I'd written for our thing basically lined up more or less exactly with lemmas that existed for it.</p>\n<p>What seems a bit less obvious to me still is how to handle the next bit, which is expressing complete bipartiteness. We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.IsCompleteMultipartite#doc\">docs#SimpleGraph.IsCompleteMultipartite</a>, but in our case we defined</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsCompleteWith</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">parts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">parts</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">parts</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">CompleteBipartite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">bipartite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsBipartiteWith</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"n\">right</span>\n<span class=\"w\">  </span><span class=\"n\">complete</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsCompleteWith</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and worked with that -- I don't yet see an easy way to make use of <code>IsCompleteMultipartite</code>. I know Mathlib also currently has separate implementations of bipartite and multipartiteness for reasons I haven't fully digested yet.</p>",
        "id": 567844788,
        "sender_full_name": "Julian Berman",
        "timestamp": 1768332897
    },
    {
        "content": "<p>Possibly though we're close enough to a PR that I'll just file one and see what a reviewer recommends.</p>",
        "id": 567845553,
        "sender_full_name": "Julian Berman",
        "timestamp": 1768333091
    },
    {
        "content": "<p>You could try getting partition from <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/SimpleGraph/CompleteMultipartite.html#SimpleGraph.IsCompleteMultipartite.setoid\">SimpleGraph.IsCompleteMultipartite.setoid</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Setoid/Partition.html#Setoid.classes\">Setoid.classes</a>.</p>",
        "id": 567865329,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768341089
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/channel/252551-graph-theory/topic/Edge.20partitions.20.2F.20Graham-Pollak/near/567844788\">said</a>:</p>\n<blockquote>\n<p>I know Mathlib also currently has separate implementations of bipartite and multipartiteness for reasons I haven't fully digested yet.</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/SimpleGraph/Bipartite.html#SimpleGraph.IsBipartite\">SimpleGraph.IsBipartite</a> is just defined as 2-colorable in terms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/SimpleGraph/Coloring.html#SimpleGraph.Coloring\">SimpleGraph.Coloring</a>. I think bipartite case is common enough in graph theory to justify having it, but maybe most of the theory about bipartite graphs generalizes to multipartite?</p>",
        "id": 567866787,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768341734
    },
    {
        "content": "<p><code>IsCompleteMultipartite</code> is not the right tool here because e.g. an edgeless graph is complete multipartite so you'd need <code>IsBipartite</code> + an additional hypothesis saying that every vertex has an edge to get complete bipartiteness. In this setting I think you want to define a <code>IsCompleteMultipartiteWith s</code> predicate where s is a partition of the vertices similarly to <code>IsBipartite</code>/<code>IsBipartiteWith</code>. Then you get an easy proof of <code>IsBipartiteWith</code> when #s = 2</p>",
        "id": 567904263,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1768366608
    },
    {
        "content": "<p>And I just realized that that is exactly what Julian's <code>IsCompleteWith</code> does, modulo the fact that it allows overlapping partitions. Overlapping partitions are impossible to realize anyways because simple graphs don't allow self-loops so perhaps the definition should be changed to force specifying a single partition for every element?</p>",
        "id": 567905136,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1768367059
    },
    {
        "content": "<p>It also seems to allow edges inside each partition</p>",
        "id": 567970030,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768392269
    },
    {
        "content": "<p>We can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsCompleteMultipartiteWith</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>\n<p>or equivalently</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsCompleteMultipartiteWith</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Ne</span><span class=\"bp\">.</span><span class=\"n\">onFun</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>",
        "id": 567970163,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768392318
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/252551-graph-theory/topic/Edge.20partitions.20.2F.20Graham-Pollak/near/567970030\">said</a>:</p>\n<blockquote>\n<p>It also seems to allow edges inside each partition</p>\n</blockquote>\n<p>You mean <code>IsCompleteMultipartite</code>? I think it doesn't? Partitions are equivalence classes where relation is contained in non-adjacency relation.</p>",
        "id": 567988193,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768398001
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/252551-graph-theory/topic/Edge.20partitions.20.2F.20Graham-Pollak/near/567988193\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/252551-graph-theory/topic/Edge.20partitions.20.2F.20Graham-Pollak/near/567970030\">said</a>:</p>\n<blockquote>\n<p>It also seems to allow edges inside each partition</p>\n</blockquote>\n<p>You mean <code>IsCompleteMultipartite</code>?</p>\n</blockquote>\n<p><code>IsCompleteWith</code></p>",
        "id": 567989253,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768398305
    },
    {
        "content": "<p>So would we add 3 (possibly 4 including <code>CompleteMultipartite</code>?) definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsCompleteMultipartiteWith</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Ne</span><span class=\"bp\">.</span><span class=\"n\">onFun</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsCompleteBipartiteWith</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsCompleteMultipartiteWith</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">CompleteBipartite</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsCompleteBipartiteWith</span><span class=\"w\"> </span><span class=\"n\">left</span>\n</code></pre></div>\n<p>I haven't fully fixed my proof yet but this seems to reasonably easily drop into it now if I restate a bunch of helper lemmas into API for these.</p>",
        "id": 568008026,
        "sender_full_name": "Julian Berman",
        "timestamp": 1768402874
    },
    {
        "content": "<p>I don't think I have a good enough sense for the mathlib-preferred design patterns to say. (I would prefer Snir's first definition to the second one though, I think it's harder to read and apply)</p>",
        "id": 568392940,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1768556468
    },
    {
        "content": "<p>I put up <a href=\"https://github.com/leanprover-community/mathlib4/pull/34050\">#34050</a> with the entirety of the fixed proof, even though it's not ready for merge yet clearly -- but the definitions above worked fairly well in the lemmas I needed -- more API is presumably needed before they're usable in general, so I'll split them off into a new PR most likely, but if anyone has immediate feedback who's helped me already here (or sees a mistake) feel free to let me know!</p>\n<blockquote>\n<p>I would prefer Snir's first definition to the second one though, I think it's harder to read and apply</p>\n</blockquote>\n<p>Not that I disagree strongly, what do I know, but the definition of <code>IsCompleteMultipartite</code> is already pretty obtuse, no? It's <code>Transitive (¬ G.Adj · ·)</code>. I think as long as there's some sane lemma you can rewrite with to get to a <code>G.Adj</code> version quickly that it doesn't matter what the \"real definition\" is? (but tell me if you feel more sure than I am!)</p>",
        "id": 568454711,
        "sender_full_name": "Julian Berman",
        "timestamp": 1768575694
    },
    {
        "content": "<p>Also allow me to jump on the \"oh god I love grind\" bandwagon.</p>",
        "id": 568455039,
        "sender_full_name": "Julian Berman",
        "timestamp": 1768575775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/channel/252551-graph-theory/topic/Edge.20partitions.20.2F.20Graham-Pollak/near/568454711\">said</a>:</p>\n<blockquote>\n<p>I think as long as there's some sane lemma you can rewrite with to get to a <code>G.Adj</code> version quickly that it doesn't matter what the \"real definition\" is? (but tell me if you feel more sure than I am!)</p>\n</blockquote>\n<p>For users of the API sure, but I think it's easier to understand and has better defeqs for setting-up the theory so why not.</p>\n<p>Also I agree that the definition <code>IsCompleteMultipartite</code> is unintuitive, but I'm not sure how one would make it clearer. I think the difficulty is that it's easiest to define a multipartite graph in terms of its complement being a sum of cliques and that's really what the definition means though it takes a bit to unravel it.</p>",
        "id": 568459142,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1768576896
    },
    {
        "content": "<p>Ah good I certainly had no intuition for which definition had better defeqs, I still don't know how to intuit that, but I'm certainly willing to trust you and try it.</p>",
        "id": 568459575,
        "sender_full_name": "Julian Berman",
        "timestamp": 1768576997
    },
    {
        "content": "<p>I think you can imagine being in the middle of a proof and saying \"I have a hypothesis that u and v are in different partitions and I want to show they are adjacent\" and now you just get that by <code>(hmultipartite u v).mpr hpartitionne</code> or the other way around without being forced to specifically use a chain of rewrites.</p>",
        "id": 568460181,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1768577150
    },
    {
        "content": "<p>or really the def should probably be <code>∀ ⦃u v : V⦄, ...</code> so that you get <code>hmultipartite.mpr hpartitionne</code></p>",
        "id": 568460557,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1768577252
    }
]