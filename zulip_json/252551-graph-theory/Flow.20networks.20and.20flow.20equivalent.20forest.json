[
    {
        "content": "<p>Hi all! Over the last couple of months, we have been working on proving one side of the characterization of flow matrices in Lean 4. As of Wednesday, we are done with no sorries left! If anyone is interested, the code can be found at <a href=\"https://github.com/niklasmohrin/lean-seminar-2023\">https://github.com/niklasmohrin/lean-seminar-2023</a> . The theorem we proved is the following: Given an undirected flow network G, we define its flow matrix to be the Matrix M with M[u, v] = \"max flow in G from u to v\". Then, for any Matrix, it holds that M is the flow matrix of some network G if and only if M is symmetrical and forall u, v, w we have min{M[u,v], M[v,w]} &lt;= M[u,w]. One implication follows directly from MinCutMaxFlow theorem, the other one is more interesting, because it turns out that not only is it possible to construct a flow network from a matrix (for which the assumptions hold) with said matrix as its flow matrix, but we can even construct a network whose only non-null capacity edges form a forest! (This is the motivation for the Gomory-Hu-Tree algorithm, which computes such a flow equivalent tree efficiently). We will maybe try to upstream some of the useful stuff into mathlib, but most of our definitions would probably need some work first before being able to be merged into mathlib (for example flows taking values in the natural numbers turns out to be cause more pain than joy - a type parameter would be better).</p>",
        "id": 418292104,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1706281225
    },
    {
        "content": "<p>The first PR is <a href=\"https://github.com/leanprover-community/mathlib4/pull/13685\">#13685</a>. I think it looks very good, but I am not an expert in network flows and have a hard time deciding whether the setup is general enough, eg <a href=\"https://github.com/leanprover-community/mathlib4/pull/13685\">#13685</a> currently doesn't apply to multigraphs.</p>",
        "id": 463425920,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724079105
    },
    {
        "content": "<p>Could people who know more about it than me comment on the PR? Maybe <span class=\"user-mention\" data-user-id=\"245078\">@Apurva Nakade</span>, <span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span>, <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>?</p>",
        "id": 463426196,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724079150
    },
    {
        "content": "<p>There is another PR to add directed graphs. Couldn't that definition be extended to provide the definition of Networks?</p>",
        "id": 463429971,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724079875
    },
    {
        "content": "<p>You mean <a href=\"https://github.com/leanprover-community/mathlib4/pull/14091\">#14091</a> ?</p>",
        "id": 463431000,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724080108
    },
    {
        "content": "<p>yes</p>",
        "id": 463431210,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724080161
    },
    {
        "content": "<p>Could lead to API clutter if not harmonised</p>",
        "id": 463431259,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724080171
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"660493\">@Niklas Mohrin</span>, see the discussion above</p>",
        "id": 463431353,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724080193
    },
    {
        "content": "<p>About multigraphs. The max flow min cut theorem trivially extends to (at least finite) multigraphs. Just clump all the multi-edges into one edge while adding their flows and capacities.</p>",
        "id": 463432182,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724080384
    },
    {
        "content": "<p>the Ford Fulkerson method would still apply.</p>",
        "id": 463432359,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724080439
    },
    {
        "content": "<p>That being said, encoding multigraphs in matrices is definitely more painful.</p>",
        "id": 463432496,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724080470
    },
    {
        "content": "<p>To be precise there is the incidence matrix which applies as is, but not sure how the others are used.</p>",
        "id": 463432882,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724080562
    },
    {
        "content": "<p>The convex optimisation folks do use the flow incidence matrix. See  chapter 1  of <a href=\"https://convex-optimization.github.io/\">https://convex-optimization.github.io/</a> (There is a free but password protected pdf with the password on this webpage, which is why I am not linking to the PDF).</p>",
        "id": 463433920,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724080808
    },
    {
        "content": "<p>So, I don't see any obvious way or reason to generalise this work to multigraphs. It seems fine to me as is.</p>",
        "id": 463435908,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724081306
    },
    {
        "content": "<p>What I would suggest is to call the Flow matrices <code>FlowAdjMatrices</code></p>",
        "id": 463437530,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724081714
    },
    {
        "content": "<p>As far as generalization goes, I think that multigraphs could only become interesting if we add more parameters to each edge, for example if we wanted to model flows with costs associated with each edge (which is not too uncommon). For everything else, just summing the capacities of each edge from u to v and merging it into one edge should be equivalent.</p>\n<p>Some textbooks define networks as a graph combined with a capacity function c: E -&gt; N (or similar), however, this did not seem appropriate at the time of writing since we wanted to be able to write <code>N.cap u v</code> directly (and would need an extra implication <code>not Adj -&gt; cap = 0</code>, when really the network does just fine without tying it to graphs.</p>\n<p>If you want to take a look at some more involved theorems, take a look at the <code>ring</code> branch of the github repository linked above, this is where I worked on replacing <code>Nat</code> (and <code>Int</code>) with rings like in my PR. This also contains one half of Min Cut Max Flow - I got stuck proofing the other direction (i.e. implementing some max-flow algorithm, see the <code>maxflow</code> branch for my last status)</p>",
        "id": 463489172,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724094982
    },
    {
        "content": "<p>Directed graphs in mathlib would be great (if all of the <code>Walk</code> and <code>Path</code> stuff is ported to them). For our seminar theorem, we came up with <code>UndirectedNetwork.asSimpleGraph</code> where <code>Adj u v = 0 &lt; cap u v</code>. This had the disadvantage that this only forms a simple graph for undirected networks and all the decomposition theorems also only held for undirected networks because they used <code>N.asSImpleGraph.Walk</code> frequently. Later, when I generalized everything, I also changed the decomposition to use <code>(fullGraph V).Walk</code> instead and this worked to generalize to undirected networks too. I still find the first version more intuitive though, so having directed graphs would make this a lot nicer</p>",
        "id": 463490404,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724095217
    },
    {
        "content": "<p>So the design goal would be to not redefine any graph related stuff, but to have a conversion to graphs and frequently talk about objects related to this conversion, just like for example the bottleneck along a path of a graph is currently defined in the seminar repository as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">UndirectedNetwork.bottleneck</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UndirectedNetwork</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N.asSimpleGraph.NonemptyPath</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 463493231,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724095740
    },
    {
        "content": "<p>About the mathlib direct graph API : Currently it is still in PR. I suggest that the two PRs be coordinated in some way since we probably do not benefit from duplicate API. About max flow min cut: I would suggest picking the Edmonds karp algorithm since there is already a formalisation in Isabelle for guidance: <a href=\"https://www.isa-afp.org/entries/EdmondsKarp_Maxflow.html\">https://www.isa-afp.org/entries/EdmondsKarp_Maxflow.html</a></p>",
        "id": 463493872,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724095895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Flow.20networks.20and.20flow.20equivalent.20forest/near/463437530\">said</a>:</p>\n<blockquote>\n<p>What I would suggest is to call the Flow matrices <code>FlowAdjMatrices</code></p>\n</blockquote>\n<p>Are you referring to the \"flow matrix\" mentioned in the seminar repository and the theorem there, or is this about my open PR and the definitions from there? If it is the former, I think <code>Adj</code> is not really appropriate in there, because the matrix cells refer to max flow values between vertices that may only be connected through multiple edges (or not at all). If you mean the latter, I am not sure I understand what definition is meant that needs renaming - can you clarify?</p>",
        "id": 463494111,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724095965
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Flow.20networks.20and.20flow.20equivalent.20forest/near/463493872\">said</a>:</p>\n<blockquote>\n<p>About the mathlib direct graph API : Currently it is still in PR. I suggest that the two PRs be coordinated in some way since we probably do not benefit from duplicate API. About max flow min cut: I would suggest picking the Edmonds karp algorithm since there is already a formalisation in Isabelle for guidance: <a href=\"https://www.isa-afp.org/entries/EdmondsKarp_Maxflow.html\">https://www.isa-afp.org/entries/EdmondsKarp_Maxflow.html</a></p>\n</blockquote>\n<p>Do take into consideration that you don't need to prove the complexity bound like they do. Implementing the algorithm as noncomputable  lean functions is sufficient for proof purposes.</p>",
        "id": 463494297,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724096024
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Flow.20networks.20and.20flow.20equivalent.20forest/near/463493872\">said</a>:</p>\n<blockquote>\n<p>About the mathlib direct graph API : Currently it is still in PR. I suggest that the two PRs be coordinated in some way since we probably do not benefit from duplicate API. About max flow min cut: I would suggest picking the Edmonds karp algorithm since there is already a formalisation in Isabelle for guidance: <a href=\"https://www.isa-afp.org/entries/EdmondsKarp_Maxflow.html\">https://www.isa-afp.org/entries/EdmondsKarp_Maxflow.html</a></p>\n</blockquote>\n<p>Ah, very cool! I was trying for quite some time to prove termination of Dinitz Algorithm, but failed as all proofs I know are reasoning about the changes made throughout multiple phases - and I didn't want to track the phases in the algorithm, but rather iterate like I would when implementing in another language. I considered Edmonds Karp too, but the argument seemed even more difficult to me, since also here we talk about increase of a function over a handful of iterations. I didn't really know how to formalize this argument cleanly and ultimately lost interest</p>",
        "id": 463494860,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724096181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"660493\">Niklas Mohrin</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Flow.20networks.20and.20flow.20equivalent.20forest/near/463494111\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Flow.20networks.20and.20flow.20equivalent.20forest/near/463437530\">said</a>:</p>\n<blockquote>\n<p>What I would suggest is to call the Flow matrices <code>FlowAdjMatrices</code></p>\n</blockquote>\n<p>Are you referring to the \"flow matrix\" mentioned in the seminar repository and the theorem there, or is this about my open PR and the definitions from there? If it is the former, I think <code>Adj</code> is not really appropriate in there, because the matrix cells refer to max flow values between vertices that may only be connected through multiple edges (or not at all). If you mean the latter, I am not sure I understand what definition is meant that needs renaming - can you clarify?</p>\n</blockquote>\n<p>It is not quite an adjacency matrix but flow constraints can be represented using incidence matrices. I am suggesting that these be distinguished somehow. Maybe calling Vertex Flow matrices helps</p>",
        "id": 463494874,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724096189
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Flow.20networks.20and.20flow.20equivalent.20forest/near/463494297\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Flow.20networks.20and.20flow.20equivalent.20forest/near/463493872\">said</a>:</p>\n<blockquote>\n<p>About the mathlib direct graph API : Currently it is still in PR. I suggest that the two PRs be coordinated in some way since we probably do not benefit from duplicate API. About max flow min cut: I would suggest picking the Edmonds karp algorithm since there is already a formalisation in Isabelle for guidance: <a href=\"https://www.isa-afp.org/entries/EdmondsKarp_Maxflow.html\">https://www.isa-afp.org/entries/EdmondsKarp_Maxflow.html</a></p>\n</blockquote>\n<p>Do take into consideration that you don't need to prove the complexity bound like they do. Implementing the algorithm as noncomputable  lean functions is sufficient for proof purposes.</p>\n</blockquote>\n<p>But we need some kind of upper bound, otherwise the termination checker will not accept our definition, right?</p>",
        "id": 463494924,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724096212
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"660493\">Niklas Mohrin</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Flow.20networks.20and.20flow.20equivalent.20forest/near/463494860\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Flow.20networks.20and.20flow.20equivalent.20forest/near/463493872\">said</a>:</p>\n<blockquote>\n<p>About the mathlib direct graph API : Currently it is still in PR. I suggest that the two PRs be coordinated in some way since we probably do not benefit from duplicate API. About max flow min cut: I would suggest picking the Edmonds karp algorithm since there is already a formalisation in Isabelle for guidance: <a href=\"https://www.isa-afp.org/entries/EdmondsKarp_Maxflow.html\">https://www.isa-afp.org/entries/EdmondsKarp_Maxflow.html</a></p>\n</blockquote>\n<p>Ah, very cool! I was trying for quite some time to prove termination of Dinitz Algorithm, but failed as all proofs I know are reasoning about the changes made throughout multiple phases - and I didn't want to track the phases in the algorithm, but rather iterate like I would when implementing in another language. I considered Edmonds Karp too, but the argument seemed even more difficult to me, since also here we talk about increase of a function over a handful of iterations. I didn't really know how to formalize this argument cleanly and ultimately lost interest</p>\n</blockquote>\n<p>Well founded recursion</p>",
        "id": 463494932,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724096218
    },
    {
        "content": "<p>The answer to your other question is also well founded recursion</p>",
        "id": 463494981,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724096242
    },
    {
        "content": "<p>I am not saying it will be an easy proof.</p>",
        "id": 463495004,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724096253
    },
    {
        "content": "<p>Well, yes, but I couldn't find a way to prove the decreasing relation, because the argument I found was arguing about the change over multiple phases</p>",
        "id": 463495187,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724096337
    },
    {
        "content": "<p>In particular for Dinitz, the distance in the residual network between s and t increases in every phase up until <code>|V|</code>, but I failed to prove it so far</p>",
        "id": 463495381,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724096418
    },
    {
        "content": "<p>Or do you think it will be easier to construct another well founded relation that does not follow the usual upper bound for running time? I feel that every \"easy\" relation, for example the sum of values the flow function takes or the sum of distances in the residual network, either doesn't work because <code>R</code> might is not well ordered or because the relation is not strictly increasing / decreasing</p>",
        "id": 463495824,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724096590
    },
    {
        "content": "<p>you could try \"every iteration, the number of unsaturated edges strictly decreases\"</p>",
        "id": 463495998,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724096664
    },
    {
        "content": "<p>I will probably look back into this when I find time, around September, Edmonds Karp proof in Isabelle seems like a very good resource for sure <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 463496710,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724096841
    },
    {
        "content": "<p>you can probably save a lot of effort by using noncomputable and not implementing the algorithm the way they do. They have to reinvent WF iirc if they work in their DSL for algorithms</p>",
        "id": 463497150,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724096929
    },
    {
        "content": "<p>Making heavy use of sets, finsets etc</p>",
        "id": 463497242,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724096948
    },
    {
        "content": "<p>The question for my PR remains, whether we want to design it with <code>Min-Cost-Max-Flow</code> _with multiple edges, with different costs_ already, or whether that makes the normal definition too annoying to work with in the case of just working on flows</p>",
        "id": 463497262,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724096954
    },
    {
        "content": "<p>My personal opinion is that modulo the name change for Flow matrices (some disambiguation to clarify that it is vertex to vertex flow), I personally don't see the point of going down the min cost flow rabbit hole</p>",
        "id": 463497615,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724097021
    },
    {
        "content": "<p>These are meaningfully different problems</p>",
        "id": 463497724,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724097042
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Flow.20networks.20and.20flow.20equivalent.20forest/near/463497150\">said</a>:</p>\n<blockquote>\n<p>you can probably save a lot of effort by using noncomputable and not implementing the algorithm the way they do. They have to reinvent WF iirc if they work in their DSL for algorithms</p>\n</blockquote>\n<p>Yeah, for sure we also want to use <code>Classical.choice</code> to choose which augmenting path to use. We could later change it to allow supplying a computable choice function, but it is irrelevant for proving stuff</p>",
        "id": 463497906,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724097073
    },
    {
        "content": "<p>Exactly</p>",
        "id": 463497994,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724097090
    },
    {
        "content": "<p>You do need to prove the relevant choice theorem.</p>",
        "id": 463498118,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724097114
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Flow.20networks.20and.20flow.20equivalent.20forest/near/463497724\">said</a>:</p>\n<blockquote>\n<p>These are meaningfully different problems</p>\n</blockquote>\n<p>Fair enough <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 463498245,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724097132
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Flow.20networks.20and.20flow.20equivalent.20forest/near/463498118\">said</a>:</p>\n<blockquote>\n<p>You do need to prove the relevant choice theorem.</p>\n</blockquote>\n<p>What do you mean?</p>",
        "id": 463498397,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724097163
    },
    {
        "content": "<p>that there is a path to choose</p>",
        "id": 463498514,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724097184
    },
    {
        "content": "<p>for the PR I think you already distinguish between a flow and its matrix. So that should be sufficient generality for adding min cost flow later if someone wants to</p>",
        "id": 463498723,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724097228
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Flow.20networks.20and.20flow.20equivalent.20forest/near/463498514\">said</a>:</p>\n<blockquote>\n<p>that there is a path to choose</p>\n</blockquote>\n<p>The way that worked in my previous attempts was that the I branch on <code>h : Nonempty F.residualNetwork.Path s t</code> and augment and iterate, if it exists, or terminate otherwise</p>",
        "id": 463499221,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724097312
    },
    {
        "content": "<p>oh okay</p>",
        "id": 463499547,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724097365
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Flow.20networks.20and.20flow.20equivalent.20forest/near/463498723\">said</a>:</p>\n<blockquote>\n<p>for the PR I think you already distinguish between a flow and its matrix. So that should be sufficient generality for adding min cost flow later if someone wants to</p>\n</blockquote>\n<p>Okay, so what exactly should be renamed then?</p>\n<p>I am having a hard time understanding the definition from the convex optimization book and I have never seen it defined like this - I am not much into convex optimization either though. Do you think we will ever make use of the terminology from this definition, and if so, shouldn't we lean more into it or mention it in the file documentation? In my opinion, I would rather steer clear of it unless we intend to include some theory around it. Do you think that people will be confused by the definition of the PR, if there is no clarification in regards to the alternative definition from the book?</p>",
        "id": 463502204,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724098080
    },
    {
        "content": "<p>A lot of names in texts are simplified because they are understood from context. When added to a general library like Mathlib, the names must be appropriately qualified. Whether Mathlib will ever include any convex optimisation math is a different story.</p>",
        "id": 463517043,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724102327
    },
    {
        "content": "<p>Another idea that might be worth to investigate: We could also make more fine-grained definitions already, for example </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">PseudoFlow</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Pr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FlowProblem</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span>\n<span class=\"w\">  </span><span class=\"n\">nonneg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">capacity</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">N.cap</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">PreFlow</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Pr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FlowProblem</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kd\">extends</span><span class=\"w\"> </span><span class=\"n\">PseudoFlow</span><span class=\"w\"> </span><span class=\"n\">Pr</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">excess</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">Pr.s</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">Pr.t</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">flowOut</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">flowIn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">Flow</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Pr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FlowProblem</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kd\">extends</span><span class=\"w\"> </span><span class=\"n\">PseudoFlow</span><span class=\"w\"> </span><span class=\"n\">Pr</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">conservation</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">Pr.s</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">Pr.t</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">flowOut</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">flowIn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>\n<p>We probably don't need <code>PreFlow</code> for now, but it could be nice to already have the split if someone one day wants to work on the PushRelabel algorithm. One uncertainty I have with this definition is that <code>Flow</code> should probably extend <code>PreFlow</code>, but that would make the definition a bit uglier since <code>conservation</code> implies <code>excess</code>. What do you all think?</p>",
        "id": 463783099,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724179941
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span>  could you look over <a href=\"https://github.com/leanprover-community/mathlib4/pull/13685\">#13685</a> and make a suggestion on how to mention the convex optimization vocabulary? I am not sure where exactly it would best fit in</p>",
        "id": 466103387,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724961732
    },
    {
        "content": "<p>I don't see why, in your PR, you would mention convex optimisation. There they use different matrices</p>",
        "id": 466104354,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724962012
    },
    {
        "content": "<p>My only suggestion is to use an unambiguous name like \"FlowVertexMatrix\" or something you might find more suitable.</p>",
        "id": 466104482,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724962061
    },
    {
        "content": "<p>But use the name for what? Do you mean to rename <code>Flow</code> -&gt; <code>FlowVertexMatrix</code>?</p>",
        "id": 466104626,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724962101
    },
    {
        "content": "<p>Oh I see. You haven't included the flow matrices from your repo in this PR. Seems fine to me.</p>",
        "id": 466104790,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724962172
    },
    {
        "content": "<p>Alright then</p>",
        "id": 466104931,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724962226
    },
    {
        "content": "<p>I wouldn't mention something that hasn't come up yet.</p>",
        "id": 466104956,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724962236
    },
    {
        "content": "<p>I agree, I just thought that you were talking about something from the PR. It will be some time until the \"flow matrices\" from the seminar repository could make it into mathlib, there is lots of stuff to do before</p>",
        "id": 466105364,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724962419
    },
    {
        "content": "<p>Another thing about your PR.</p>",
        "id": 466105560,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724962503
    },
    {
        "content": "<p>It seems what you call a <code>Network</code> is a <code>Digraph</code>. That DiGraph API was just merged into Mathlib.</p>",
        "id": 466105611,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724962523
    },
    {
        "content": "<p>Your definition of <code>Network</code> could extend <code>Digraph</code></p>",
        "id": 466105669,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724962550
    },
    {
        "content": "<p>Currently it is simply treating the network as a complete graph with 0 capacity presumably indicating non-edges</p>",
        "id": 466105857,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724962630
    },
    {
        "content": "<p>I would recommend extending DiGraph and adding a property for the <code>cap</code> function that makes this explicit.</p>",
        "id": 466105931,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724962667
    },
    {
        "content": "<p>Also  <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> , since you are a mathlib maintainer for combi and active on this thread: It seems this PR creates a fourth graph theory related folder under the <code>Combinatorics</code> folder . The existing ones are <code>SimpleGraph</code>, <code>DiGraph</code>, and <code>Quiver</code>.  Do you think the Flow file created by this PR belongs under Digraph instead of a separate <code>Flow</code> folder?</p>",
        "id": 466106184,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724962745
    },
    {
        "content": "<p>*reviewer</p>",
        "id": 466106217,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724962760
    },
    {
        "content": "<p>I have in the past argued that we should rename the <code>SimpleGraph</code> folder to <code>Graph.Simple</code> the day mathlib acquires another kind of graphs. Seems like this day has happened</p>",
        "id": 466106360,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724962823
    },
    {
        "content": "<p>I would suggest creating a Graph Theory folder and subsuming the purely graph theory related folders into it</p>",
        "id": 466106392,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724962836
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Flow.20networks.20and.20flow.20equivalent.20forest/near/466106360\">said</a>:</p>\n<blockquote>\n<p>I have in the past argued that we should rename the <code>SimpleGraph</code> folder to <code>Graph.Simple</code> the day mathlib acquires another kind of graphs. Seems like this day has happened</p>\n</blockquote>\n<p>Right that message just appeared. Agreed.</p>",
        "id": 466106437,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724962858
    },
    {
        "content": "<p>We considered basing the <code>Network</code> type on <code>SimpleGraph</code> when we first defined it in our seminar. In fact, in the literature, flow networks are sometimes defined as a function $c : E -&gt; R$ where $E$ are the edges of some underlying graph. However, we felt that there is not much benefit, while there is the disadvantage of making the <code>Network</code> (and <code>Flow</code>) interface less ergonomic with something like <code>cap : Adj u v -&gt; R</code>. Instead, we added <code>asSimpleGraph</code> to convert the network to a graph to make statements about the underlying structure. </p>\n<p>If I understand your suggestion correctly, you would not alter the definition of <code>cap</code>, but instead add another field with <code>0 &lt; cap u v -&gt; Adj u v</code>. This sounds indeed nicer than the <code>cap : Adj u v -&gt; R</code> version, but I am still not sure whether the change is worth it. The obvious benefit would be that there is no need for <code>N.asDiGraph.Path u v</code> anymore and it would just be <code>N.Path u v</code> (or something like <code>N.asSimpleGraph.IsAcyclic</code> from our seminar code would just be <code>N.IsAcyclic</code>). The downside is that we have the potentially unnecessary complication of having to choose a graph when defining a network. I suppose we could provide <code>True</code> as a default value for <code>Adj</code> (and also one for this new condition)?</p>",
        "id": 466108569,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724963724
    },
    {
        "content": "<p>Two things:</p>\n<ol>\n<li>What I am suggesting is <code>cap : V -&gt; V -&gt; \\R</code> with <code>cap_non_edge : \\forall v w : V, \\neg G.Adj v w -&gt; cap v w = 0</code></li>\n<li>Not integrating the flow stuff with digraphs means we effectively have a parallel API for flows. Flow problems are fundamental enough to be primitives elsewhere in graph theory. Think of finding a maximum bipartite matching in a graph by turning into a flow problem for example. Not doing this step of deriving from Digraph means Mathlib doesn't get a well-integrated API. Just my two cents. Maybe <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> can chip in.</li>\n</ol>",
        "id": 466108996,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724963903
    },
    {
        "content": "<p>I don't think there would  be a parallel API, because any graph-y statements would be made through <code>asSimpleGraph</code> / <code>asDiGraph</code>. The question is whether we prefer the <code>Network extends DiGraph</code> or the <code>Network.asDiGraph</code> design</p>",
        "id": 466109488,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724964136
    },
    {
        "content": "<p>How do you go from Graph to Network?</p>",
        "id": 466109572,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724964175
    },
    {
        "content": "<p>I would say you just have to define a network with the capacities you want. I don't see how <code>extends DiGraph</code> would make this more ergonomic</p>",
        "id": 466109880,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724964314
    },
    {
        "content": "<p>It would define the network for the graph with <code>cap_non_edge</code></p>",
        "id": 466109968,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724964357
    },
    {
        "content": "<p>But what capacity do you choose?</p>",
        "id": 466110044,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724964382
    },
    {
        "content": "<p>that's beside the point. A network of flows makes little sense without being consistent with a graph structure. In Mathlib we are only proving theorems anyway</p>",
        "id": 466110201,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724964440
    },
    {
        "content": "<p>It is upto users to instantiate the capacity function such that <code>cap_non_edge</code> holds.</p>",
        "id": 466110272,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724964464
    },
    {
        "content": "<p>I am not sure I agree; although flows are of course tightly related to graphs, we have evidence that the definition of networks that does not include graphs in the definition can work in the seminar repository. I don't see how only having theorems should influence our design, in fact, I think we should strive to allow usage of these types for downstream projects that _do_ want to run the code. As far as I see it, the decision boils down to opinion on which interface we think is nicer</p>",
        "id": 466111279,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724964922
    },
    {
        "content": "<p>I actually think that using <code>Network extends DiGraph</code> to allow for <code>N.Path u v</code> is a very fair reason to go with this design, I am just curious whether it will make for awkward usages later</p>",
        "id": 466111450,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724964996
    },
    {
        "content": "<p>The seminar repository doesn't have to integrate with the rest of Mathlib. A mathlib flow library must be usable for graph flows without excess effort.</p>",
        "id": 466111494,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724965027
    },
    {
        "content": "<p>Also my impression of mathlib is that computing is a tertiary or quaternary concern. Usability for proofs and connecting with other relevant parts of the library matters much more.</p>",
        "id": 466111550,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724965063
    },
    {
        "content": "<p>Okay, but what excess effort do you predict we will have?</p>",
        "id": 466111641,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724965099
    },
    {
        "content": "<p>Anyway, these design decisions are upto the official reviewers and maintainers. My opinion is that Mathlib's flow library must integrate with digraphs</p>",
        "id": 466111653,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724965106
    },
    {
        "content": "<p>Just to clarify my point from earlier, for the bipartite matching example that was mentioned, I would expect the definition to be something like the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">Ends</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">source</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sink</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Network.maxFlow</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Network</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">maxCardinalityMatching</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Network</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">Ends</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">cap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"n\">nonneg</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"n\">loopless</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">N.maxFlow</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">Ends.source</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">Ends.sink</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>in the current version. Using <code>Network extends DiGraph</code>, the only change I can see is that the definition of <code>N</code> would change to the following (with all <code>sorry</code>s containing the same code as before):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Network</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">Ends</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"c1\">-- &lt;-- change here</span>\n<span class=\"w\">  </span><span class=\"n\">cap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">nonneg</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">loopless</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">cap_non_edge</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- &lt;-- change here</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>... or the definition would stay the same and implicitly use <code>completeGraph V</code> as the underlying graph.</p>",
        "id": 466114238,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724966361
    },
    {
        "content": "<p>Anyways, I agree that it must integrate with digraphs in some way and I suppose that fixing a graph with the <code>Network extends DiGraph</code> approach can be nice to for example keep this graph consistent between transformations of the network and to have all of the graph connectivity definitions directly available on <code>Network</code>. I just don't think there are many more reasons than these two</p>",
        "id": 466114729,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1724966606
    },
    {
        "content": "<p>What will change is that when writing theorems that involve graphs and their network, cap_non_edge will exist where it should.</p>",
        "id": 466126214,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724972883
    },
    {
        "content": "<p>Indeed you do want to keep your network consistent with the graph in theorem statements by default</p>",
        "id": 466126751,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724973204
    },
    {
        "content": "<p>I think this PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/13685\">#13685</a> is technically sound. I haven't checked docstrings and other stuff so far. This PR introduces a new folder under <code>Combinatorics</code>. But I think this folder structure management is something for a future PR to handle</p>",
        "id": 466275962,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725026691
    },
    {
        "content": "<p>Is it still the convention to require multi-line docstrings to start on a new line after the <code>/--</code>?</p>",
        "id": 466276868,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725026965
    },
    {
        "content": "<p>It's rather the convention <em>not</em> to</p>",
        "id": 466276963,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725026998
    },
    {
        "content": "<p>Overall, we are undecided</p>",
        "id": 466277098,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725027025
    },
    {
        "content": "<p>Also, I read the discussion about the subset notation. In many areas that I deal with it would be most unnatural to mix up order and subset notation.</p>",
        "id": 466279836,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725027843
    },
    {
        "content": "<p>In fact for substructure orders, we use subset notation much more than the order notation. Either way, I wonder whether your comment means there won't be a normal subset/subseteq notation from Mathlib in the future for Finsets and Sets.</p>",
        "id": 466280135,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725027945
    },
    {
        "content": "<p>Yes, the plan is to scrape it off. It's somewhat challenging to the extent that we would like to keep it showing as <code>⊆</code>/<code>⊂</code>  but have it be <code>≤</code>/<code>&lt;</code> underneath</p>",
        "id": 466281845,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725028457
    },
    {
        "content": "<p>Okay, this is a big deal in math that comes from TCS like game theory stuff.</p>",
        "id": 466281978,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725028493
    },
    {
        "content": "<p>One of the nice things about math in lean is being able to use familiar notation</p>",
        "id": 466282253,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725028563
    },
    {
        "content": "<p>what effort is required to keep it in? Why is it being removed (probably needs a separate thread)?</p>",
        "id": 466282349,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725028589
    },
    {
        "content": "<p>I mean, the plan is to keep <code>⊆</code>/<code>⊂</code>, but make it be notation for <code>≤</code>/<code>&lt;</code>. Nothing should change visually</p>",
        "id": 466282449,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725028622
    },
    {
        "content": "<p>so all the subset theorems work as is?</p>",
        "id": 466282525,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725028649
    },
    {
        "content": "<p>That's the plan, at least</p>",
        "id": 466282567,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725028662
    },
    {
        "content": "<p>As long as the user facing API doesn't change I have no worries. TCS folks are a very siloed lot. So unless someone actively works with lattices, orders, or domain theory, they are unlikely to be comfortable with them anymore than many math people will be with type theory. Having to work with Order theorems and notation will be confusing when they are working with finite sets.</p>",
        "id": 466283464,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725028893
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Flow.20networks.20and.20flow.20equivalent.20forest/near/466276868\">said</a>:</p>\n<blockquote>\n<p>Is it still the convention to require multi-line docstrings to start on a new line after the <code>/--</code>?</p>\n</blockquote>\n<p>related topic: <a href=\"#narrow/stream/270676-lean4/topic/style.20guide.20for.20comments.3F\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/style.20guide.20for.20comments.3F</a></p>",
        "id": 466415653,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1725065341
    },
    {
        "content": "<p>I haven't followed this whole conversation in detail - but does the solution eventually arrived at involve multigraphs? </p>\n<p>The 'merge edges to stop it being a multigraph' solution is really just a band-aid. Edges in flow problems can be combinatorially significant (for example, two paralllel edges could correspond to different roads) and there are natural variants of flow problems that will be impossible to state if only single edges are allowed between a given pair.</p>",
        "id": 466730970,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1725208817
    },
    {
        "content": "<p>I think for describing max flow and min cut, this API is sufficient. Multigraphs become relevant in min cost flow like problems. My opinion is that this current API should be kept as is, for the same reason we treat Simplegraphs separatelyz rather than a special digraph</p>",
        "id": 466731377,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725208971
    },
    {
        "content": "<p>It keeps the API uncluttered</p>",
        "id": 466731428,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725208982
    },
    {
        "content": "<p>Uncluttered, but it also encourages continued development and accrual of technical debt at the wrong level of generality. </p>\n<p>The relationship between simple and non-simple graphs is complicated, and I think what is appropriate should be carefully considered in each given setting. It's not correct to just do absolutely everything for multigraphs, but I also worry that 'do it for simple graphs, and worry about the generalization later' is setting things up for disaster.</p>",
        "id": 466731999,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1725209200
    },
    {
        "content": "<p>Imho, flow problems  on a simple digraphs are a sufficiently interesting in their own right to merit a separate and simple API</p>",
        "id": 466732335,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725209367
    },
    {
        "content": "<p>Further, in this case, the flow vertex matrix doesn't naturally generalise to multigraphs</p>",
        "id": 466732498,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725209423
    },
    {
        "content": "<p>Which I think is the end goal for this PR and the ones to come</p>",
        "id": 466732675,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725209498
    },
    {
        "content": "<p>I already posted this on <a href=\"https://github.com/leanprover-community/mathlib4/pull/13685#issuecomment-2320922774\">github</a> a while back, but no one has responded to it yet, so I will pick your brains over here:</p>\n<blockquote>\n<p>[...] One might want a network to refer to a more specialized version of Digraph, which I think is not possible in the <code>Network extends Digraph</code> design.</p>\n<p>I suppose the most flexible design to have all kinds of networks carry along all kinds of graphs would be <code>structure Network (G : Digraph V) (R : Type u_R)</code>. However, this would defeat the main purpose for the move to the Network extends Digraph design <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>\n</blockquote>\n<p>Any opinions?</p>",
        "id": 470042512,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1726258348
    },
    {
        "content": "<p>I don't have any opinions on this.</p>",
        "id": 470394355,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726440166
    },
    {
        "content": "<p>Some time has passed, so I want to ramp up the discussion about my PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/13685\">#13685</a> again: I think the biggest question still is how <code>Network</code>s should interact with <code>Digraph</code>s and <code>SimpleGraph</code>s. I have pushed a handful of commits that each present a different formalization. The main question is whether <code>Network</code> should be nested under <code>Digraph</code> or be a parallel thing. I think that having <code>Network</code> extend <code>Digraph</code> would be unneeded for a lot of theory on flows. On the other hand, it should be easy to formulate flow theorems for special classes of networks. On the current version of my branch, I added a structure <code>NetworkOn (G : Digraph V) extends Network V R</code> which takes some digraph as a parameter for the type. </p>\n<p>We could also dismiss any connection to graphs for now and just add the plain <code>Network</code>. This would suffice to get started with flows in mathlib. What do you all think?</p>",
        "id": 498605205,
        "sender_full_name": "Niklas Mohrin",
        "timestamp": 1739112178
    }
]