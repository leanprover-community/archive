[
    {
        "content": "<p>Hi all, I'm planning on over the next few months to slowly tackle the formalization of the attached proof <br>\n<a href=\"/user_uploads/3121/0dmGmvG-zdCTh8o7y0c3Des9/diam.webp\">diam.webp</a> <br>\n[The proof that the girth of a graph is less than or equal to twice its diameter + 1]<br>\nI wanted to seek some advice from more experienced Lean users as to what are your thoughts on the best way to tackle this in regards to what type of object could be best suited for this problem. Would it be best to begin the implementation of it using a cycle graph, or by ways of using a cyclic subgraph, or moreover simply by defining it as a walk that starts and ends at the same vertex and then going from there? I appreciate any advice or thoughts on this matter.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/0dmGmvG-zdCTh8o7y0c3Des9/diam.webp\" title=\"diam.webp\"><img data-original-dimensions=\"1345x622\" src=\"/user_uploads/thumbnail/3121/0dmGmvG-zdCTh8o7y0c3Des9/diam.webp/840x560.webp\"></a></div>",
        "id": 487266251,
        "sender_full_name": "Kiril Vinogradov",
        "timestamp": 1733841732
    },
    {
        "content": "<p>I think it will be easiest to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk.IsCycle#doc\">docs#SimpleGraph.Walk.IsCycle</a></p>",
        "id": 487268566,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1733842379
    },
    {
        "content": "<p>I proved this lemma 6 months ago (<a href=\"https://github.com/leanprover-community/mathlib4/pull/25834\">#25834</a>), but the proof is too messy to be merged into mathlib. Currently I'm working on tidying it up and would like to hear your opinions considering how to do it:<br>\nThe proof relies on the fact that we can get a cycle by gluing two paths together (given that they start and end on the same vertex), and we should be able to say that such a cycle would have a size at most the sum of the paths.<br>\nI've noticed that <span class=\"user-mention\" data-user-id=\"387244\">@YaÃ«l Dillies</span> has added <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk.cycleBypass#doc\">docs#SimpleGraph.Walk.cycleBypass</a> recently which is close to what we want.<br>\nOn <a href=\"https://github.com/Rida-Hamadani/mathlib4/blob/rida/getCycle/Mathlib/Combinatorics/SimpleGraph/GirthDiam.lean\">this</a>) branch I've uploaded some code defining the following:</p>\n<ul>\n<li><code>DivergentPt</code>: the point where two walks that started from the same vertex stop agreeing. This is necessary if we want to create a cycle from two paths, because we should specify where the cycle starts/ends, and this point does that.</li>\n<li><code>getCycle</code>: this takes two walks <code>p q : G.Walk u v</code> and returns a walk <code>G.Walk (DivergentPt p q) (DivergentPt p q)</code>. The process is as follows: drop all vertices from p and q up to (DivergentPt p q), append p to the reverse of q, then perform <code>cycleBypass</code> on it.<br>\nWhen <code>p</code> and <code>q</code> are both paths, and then are not identical, <code>getCycle</code> gives a cycle. This is proven in my branch at <code>getCycle_isCycle</code> (module a <code>sorry</code>).<br>\nI would like to hear your opinions on this approach, do you think these definitions are worth adding to mathlib? Are there are suggestions to make it more modular or tidier? Do you think these additions deserve to be in a separate file and/or PR from the rest of the girth-diameter inequality proof?</li>\n</ul>",
        "id": 565785025,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1767098859
    },
    {
        "content": "<p>Another approach I've thought about in order to get cycles from 2 paths is to define a \"<code>Z</code>-module of cycles on <code>G </code>\" and then prove that <code>G.Walk u v</code> is an affine space over this <code>Z-module</code>, thus there exists a unique cycle <code>v</code> such that <code>p = q + v</code> for any <code>p q : Walk u v</code>. This is more elegant (and perhaps reusable in case someone wants to use graph homology in the future) but unfortunately I couldn't get it to work because in order to have a <code>Z</code>-modile of cycles, we will need to consider union of cycles and figure 8 as cycles which doesn't work with our definition of <code>IsCycle</code>, but I'm sharing this in case someone might have an idea to make this work.</p>",
        "id": 565785404,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1767099138
    },
    {
        "content": "<p>I was hoping we would be rid of the indexed version of walks tbh. This proof would be much shorter in the List.ischain version</p>",
        "id": 565788201,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767100964
    },
    {
        "content": "<p>Why not just start with edge disjoint paths directly?</p>",
        "id": 565788491,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767101186
    },
    {
        "content": "<p>Part of the reason for why the proof is long is having to construct cycles (and dealing with edge cases), I would like to be able to say \"take these two walks, both of them are paths, and they aren't identical, thus they make a sufficiently small cycle\", but if I wanted to prove that the paths are edge disjoint I'll probably have to construct them explicitly again in such a way that it would be similar to constructing the cycles.<br>\nI will think about how List.ischain can shorten the proof.</p>",
        "id": 565789179,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1767101641
    },
    {
        "content": "<p>Indeed, <code>cycleBypass</code> isn't quite enough for your purposes. Note that whatever you come up with will also greatly help <a class=\"stream-topic\" data-stream-id=\"144837\" href=\"/#narrow/channel/144837-PR-reviews/topic/.2333257.20Odd.20Cycle.20Theorem/with/565764293\">#PR reviews &gt; #33257 Odd Cycle Theorem</a>, cc <span class=\"user-mention\" data-user-id=\"877182\">@Nick_adfor</span></p>",
        "id": 565811818,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1767114975
    },
    {
        "content": "<p>Whoops, cc <span class=\"user-mention\" data-user-id=\"877182\">@Nick_adfor</span></p>",
        "id": 565811840,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1767114985
    },
    {
        "content": "<p>I've noticed some of <code>bypass</code> work in Mathlib and tried to understand its math background. What textbook should I refer to?</p>",
        "id": 565813617,
        "sender_full_name": "Nick Adfor",
        "timestamp": 1767115983
    },
    {
        "content": "<p>I am not sure we followed any textbook</p>",
        "id": 565813775,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1767116060
    },
    {
        "content": "<p>The picture in this post may be from some textbook that I can follow</p>",
        "id": 565814753,
        "sender_full_name": "Nick Adfor",
        "timestamp": 1767116568
    },
    {
        "content": "<p>Yet it might be right that for code in PR and Mathlib I cannot just refered to one book.</p>",
        "id": 565815551,
        "sender_full_name": "Nick Adfor",
        "timestamp": 1767116981
    },
    {
        "content": "<p>The picture is from Diestel, but it does not define bypass like we do, Diestel's argument is not formalizable as it is and had to be modified quite a bit</p>",
        "id": 565816378,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1767117479
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">YaÃ«l Dillies</span> <a href=\"#narrow/channel/252551-graph-theory/topic/Girth.20and.20Diameter.20Proof/near/565811818\">said</a>:</p>\n<blockquote>\n<p>Indeed, <code>cycleBypass</code> isn't quite enough for your purposes. Note that whatever you come up with will also greatly help <a class=\"stream-topic\" data-stream-id=\"144837\" href=\"/#narrow/channel/144837-PR-reviews/topic/.2333257.20Odd.20Cycle.20Theorem/with/565764293\">#PR reviews &gt; #33257 Odd Cycle Theorem</a>, cc <span class=\"user-mention silent\" data-user-id=\"877182\">Nick_adfor</span></p>\n</blockquote>\n<p>Thank you for pointing that out! In this case I will PR <code>getCycle</code> in a separate file (or maybe add it to <code>Operations.lean</code> in case that file doesn't get too big)</p>",
        "id": 565816617,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1767117567
    },
    {
        "content": "<p>I like the divergent-point solution, but it's weird that we have multiple defs that manipulate walks (like <code>bypass</code>/<code>cycleBypass</code> and this suggestion) and there is no one-size-fits-all. for example, I think none of the above cover <span class=\"user-mention\" data-user-id=\"870257\">@Jakub Nowak</span>'s walk manipulation in <a class=\"message-link\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/bipartite.20iff.20does.20not.20contain.20an.20odd.20cycle/near/555369802\">#Is there code for X? &gt; bipartite iff does not contain an odd cycle @ ðŸ’¬</a>, which can convert any odd walk to an odd cycle.<br>\nIt's similar to <code>cycleBypass</code>, but it works in more cases.<br>\nIt also seems pretty similar to <code>getCycle</code>, but it doesn't require any path assumptions.<br>\nI feel like surely there must be some magic function that generalizes all these super specific walk manipulations. They all revolve around converting walks to paths/cycles by deleting some parts</p>",
        "id": 565839996,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1767134692
    },
    {
        "content": "<p>That is precisely what prompted me to think about trying to do this by proving that <code>G.Walk u v</code> forms an affine space over the <code>Z</code>-module of \"cycles\". Perhaps another approach to try to make a more general tool is instead of defining a divergent point, we define a list of divergent points and another of convergent points, then prove that each index of the list induces a cycle, then we can for instance choose the smallest one, etc. This won't help with the manipulation you link but perhaps finding a one size that fits all is hopeless here and the best we can do is find a size that fits as most as possible.</p>",
        "id": 565859415,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1767156853
    },
    {
        "content": "<p>For now I will implement the single divergent point approach but I'll keep the list approach in head as a possible generalization that I might do in the future (perhaps once I'm done with making the girth-diameter proof mergeable).</p>",
        "id": 565859457,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1767156920
    },
    {
        "content": "<p>I've noticed that Rida has become the of reviewer of <a href=\"https://github.com/leanprover-community/mathlib4/pull/33257\">#33257</a>. Is there anything to merge in <a href=\"https://github.com/leanprover-community/mathlib4/pull/25834\">#25834</a>?</p>",
        "id": 565875588,
        "sender_full_name": "Nick Adfor",
        "timestamp": 1767170885
    },
    {
        "content": "<p>Maybe theory about rooted BFS trees would also be useful for this proof? See my comment here: <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Formalizing.20Graph.20Theory.20-.20The.20Odd.20Cycle.20Theorem.20in.20Lean/near/565060312\">#mathlib4 &gt; Formalizing Graph Theory - The Odd Cycle Theorem in Lean @ ðŸ’¬</a></p>",
        "id": 565990137,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767287987
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"580947\">@Rida Hamadani</span> Can we bring talk about depth into the proof by making the claim that gluing two paths together produces two vertices that have a depth of 2 in contrast to the other vertices which have a depth of 1? I find it useful to associate depth with \"anchor points\"</p>",
        "id": 565990367,
        "sender_full_name": "Matthew Coke",
        "timestamp": 1767288325
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/channel/252551-graph-theory/topic/Girth.20and.20Diameter.20Proof/near/565789179\">said</a>:</p>\n<blockquote>\n<p>Part of the reason for why the proof is long is having to construct cycles (and dealing with edge cases), I would like to be able to say \"take these two walks, both of them are paths, and they aren't identical, thus they make a sufficiently small cycle\", but if I wanted to prove that the paths are edge disjoint I'll probably have to construct them explicitly again in such a way that it would be similar to constructing the cycles.<br>\nI will think about how List.ischain can shorten the proof.</p>\n</blockquote>\n<p>Okay, as now my <a href=\"https://github.com/leanprover-community/mathlib4/pull/33257\">#33257</a> has all finished (the goal of this PR is to prove TODO in Bipartite.lean) , if there are some shortened proof in <a href=\"https://github.com/leanprover-community/mathlib4/pull/25834\">#25834</a>, should <a href=\"https://github.com/leanprover-community/mathlib4/pull/33257\">#33257</a> be a branch of <a href=\"https://github.com/leanprover-community/mathlib4/pull/25834\">#25834</a> or conversely?</p>",
        "id": 566010890,
        "sender_full_name": "Nick Adfor",
        "timestamp": 1767318828
    },
    {
        "content": "<p>I've noticed that your <code>takeAt</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Walk</span><span class=\"bp\">.</span><span class=\"n\">takeAt</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">â‰¤</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">getVert</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">getVert</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">drop</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">take</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">copy</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">drop_getVert</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sub_add_cancel</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>may introduce a new method to define lastCommonVertex in my post <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Formalizing.20Graph.20Theory.20-.20The.20Odd.20Cycle.20Theorem.20in.20Lean/near/565094255\">#mathlib4 &gt; Formalizing Graph Theory - The Odd Cycle Theorem in Lean @ ðŸ’¬</a> </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">lastCommonVertex</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">IsPath</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">IsPath</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hp_min</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hq_min</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>But as now your def Walk.takeAt cannot run as Nat.sub_add_cancel h showing</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"ss\">`rewrite</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Did</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">occurrence</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">pattern</span>\n<span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">target</span><span class=\"w\"> </span><span class=\"n\">expression</span>\n<span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">getVert</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">getVert</span><span class=\"w\"> </span><span class=\"n\">j</span>\n</code></pre></div>\n<p>so I cannot finish my def.</p>",
        "id": 566011824,
        "sender_full_name": "Nick Adfor",
        "timestamp": 1767319877
    },
    {
        "content": "<p>Jakub said \"\"Since the first vertex of each of these walks is x there is a vertex z that is the last common vertex of these two walks\" is not true.\" But the definition can be fixed to make it true. I don't know if it is workable and if you want to do more work (or co-work) to make your takeAt usable in the future PR.</p>",
        "id": 566012131,
        "sender_full_name": "Nick Adfor",
        "timestamp": 1767320386
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/252551-graph-theory/topic/Girth.20and.20Diameter.20Proof/near/565990137\">said</a>:</p>\n<blockquote>\n<p>Maybe theory about rooted BFS trees would also be useful for this proof? See my comment here: <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Formalizing.20Graph.20Theory.20-.20The.20Odd.20Cycle.20Theorem.20in.20Lean/near/565060312\">#mathlib4 &gt; Formalizing Graph Theory - The Odd Cycle Theorem in Lean @ ðŸ’¬</a></p>\n</blockquote>\n<p>Interesting idea, I'll give it more thought next week after I'm done with my exams.</p>",
        "id": 566049806,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1767354908
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1009479\">Matthew Coke</span> <a href=\"#narrow/channel/252551-graph-theory/topic/Girth.20and.20Diameter.20Proof/near/565990367\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> Can we bring talk about depth into the proof by making the claim that gluing two paths together produces two vertices that have a depth of 2 in contrast to the other vertices which have a depth of 1? I find it useful to associate depth with \"anchor points\"</p>\n</blockquote>\n<p>I'm not sure what you mean by depth, is it the same as the distance between two vertices?</p>",
        "id": 566049860,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1767354944
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"877182\">Nick Adfor</span> <a href=\"#narrow/channel/252551-graph-theory/topic/Girth.20and.20Diameter.20Proof/near/566011824\">said</a>:</p>\n<blockquote>\n<p>I've noticed that your <code>takeAt</code></p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Walk</span><span class=\"bp\">.</span><span class=\"n\">takeAt</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">â‰¤</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">getVert</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">getVert</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">drop</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">take</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">copy</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">drop_getVert</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sub_add_cancel</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This will be fixed, in fact I'm hoping that I will be able to remove <code>takeAt</code> completely in favor of <code>getCycle</code>. I'm currently busy but will have more time to work on it in the upcoming weeks.</p>",
        "id": 566050086,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1767355093
    },
    {
        "content": "<p><code>takeAt</code> feels a bit clunky to me, do you think it will be useful to you? Feel free to take it from my PR and add it to yours if it is.</p>",
        "id": 566050717,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1767355342
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"580947\">@Rida Hamadani</span> it would be more comparable to vertex degree rather than distance between vertices. Starting from a path, it could be considered to be how many vertices are stacked on top of each other creating \"branch points\" from any specific vertex</p>",
        "id": 566057541,
        "sender_full_name": "Matthew Coke",
        "timestamp": 1767360158
    },
    {
        "content": "<p>I'm unfamiliar with this terminology, do we have it in mathlib?</p>",
        "id": 566058027,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1767360480
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"580947\">@Rida Hamadani</span> doubtful. Some of the choices I make in how I relate to graph theory might be somewhat unique</p>",
        "id": 566059525,
        "sender_full_name": "Matthew Coke",
        "timestamp": 1767361427
    },
    {
        "content": "<p>It will be difficult for me to include a concept that I'm not familiar with, if this is important to your work, perhaps you can open a PR to mathlib defining it and developing an API for it, and after that I will think about whether it is realistic for me to relate it to this work.</p>",
        "id": 566061353,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1767362515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"580947\">@Rida Hamadani</span> I agree with you. I'm relatively new here and don't know how to open a PR to mathlib yet. I'm not convinced that it's important to my work in digital space and with interactive theorem provers yet</p>",
        "id": 566063578,
        "sender_full_name": "Matthew Coke",
        "timestamp": 1767363936
    },
    {
        "content": "<p>There was mention of bipartite iff no odd cycle theorem, unfortunately I think that Rida's <code>getCycle</code> won't work as is for that purpose, because the returned cycle won't necessarily have the same mod 2 value as the sum of length of <code>p</code> and <code>q</code>.</p>",
        "id": 566206771,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767514686
    },
    {
        "content": "<p>That depends on <code>p</code> and <code>q</code>,  do they have any intersections other than starting and ending points? If not then the returned cycle will satisfy that.</p>",
        "id": 566209182,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1767517762
    },
    {
        "content": "<p>This can be generalized: we can define the convergence point, in a similar fashion to the divergent point, to be the first point where the two paths meet after being separated, let <code>p q : G.Walk u v</code> be two paths, note that <code>p.subgraph.dist u (DivergentPt p q) = q.subgraph.dist u (DivergentPt p q)</code>, then the equation becomes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">getCycle</span><span class=\"w\">  </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\">  </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">subgraph</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DivergentPt</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">subgraph</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ConvergentPt</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">subgraph</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ConvergentPt</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 566210052,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1767518762
    },
    {
        "content": "<p>Maybe later on January 25th-27th (my co-authors will have a conference with me) we can hold an online meeting about how many definitions we have and which one to choose...</p>",
        "id": 566211492,
        "sender_full_name": "Nick Adfor",
        "timestamp": 1767520528
    },
    {
        "content": "<p>I'm not available in January and especially not on these days. I'm more available in February, however, I think that it is easier to navigate this in text form since it keeps track of everything discussed and gives as much time as necessary to think and try things out.</p>",
        "id": 566212076,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1767521093
    },
    {
        "content": "<p>Thanks to a very cool proof plan suggested by <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>,  <a href=\"https://github.com/leanprover-community/mathlib4/pull/33506\">#33506</a> now has a complete proof of the fact that a cycle could be constructed given two unequal paths, of length less or equal to the sum.<br>\nInstead of using the <code>getCycle</code> definition that was described above, it uses an existential statement.<br>\nHowever, the current proof depends on some ugly <code>isPath_append_isCycle</code> lemma that also depends on two other ugly lemmas, does anyone have any suggestions on what to do with these? Perhaps golfing ideas, or maybe an approach that removes the need for them?<br>\nI'd like to especially get rid of <code>IsPath.exists_of_edges</code>, or at least golf it and find a proper place for it in mathlib.</p>",
        "id": 567477619,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1768210559
    }
]