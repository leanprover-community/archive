[
    {
        "content": "<p>Hey, I am trying to implement the max-flow min-cut theorem in my branch in mathlib <a href=\"https://github.com/leanprover-community/mathlib/blob/max_flow_min_cut/src/combinatorics/quiver/max_flow_min_cut.lean\">https://github.com/leanprover-community/mathlib/blob/max_flow_min_cut/src/combinatorics/quiver/max_flow_min_cut.lean</a>, but I need some help.<br>\nIn the lemmas flow_value_global_ver and weak_duality there are commands, which I believe should work, but they don't. The commands, which I am talking about are all commented out after a sorry or give a direct error (like lines 374 and 468). All of the commented-out code in these two lemmas apart from lines 392 and 394, where I am still struggling to sum over pairs, I believe should be very close to what is needed to make the code work. Unfortunately, I don't know how to fix these errors (mentioning meta-variables, asking for types and not recognising finset.sum_le_sum), so I would be very grateful if you can help me. If necessary, I can show the error messages on different pieces of code.<br>\nLast, but not least, there is a strange error on line 1022 because of an up arrow arriving in front of a real number. Everything else is the same, but because of the arrow the code doesn't work and I don't even know why it is arriving (I haven't used it anywhere). This really should be a minor mistake, but I don't have a clue how to fix it. <br>\nAny help will be appreciated! The only lemma, which is logically not ready is no_augm_path, I am currently working on it, but I believe the others should be made to work easily by people proficient in working with Lean. I am open to any other advice as well! Thank you in advance for the help!</p>",
        "id": 343670614,
        "sender_full_name": "Aleksandar Milchev",
        "timestamp": 1679490282
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"572391\">@Aleksandar Milchev</span>  : I am working on lean4 version of your proof. This is still a WIP. See this repository : <a href=\"https://gitlab.com/Shreyas941/maxflowmincutlean4\">https://gitlab.com/Shreyas941/maxflowmincutlean4</a></p>\n<p>I am  trying to following the same structure as yours with some convenient defintion changes and I was able to golf down many of your proofs. Thus far I have reached the theorem you call <code>set_flow_conservation</code>.</p>",
        "id": 344561814,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1679783706
    },
    {
        "content": "<p>For good measure I started with basic lemmas to get a grip on Finsets, hence the first hundred or so lines are about the degree sum result for digraphs. But as you go down further, to <code>set_flow_conservation</code>,(roughly around line 200), the proofs seem significantly shorter.</p>",
        "id": 344561978,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1679783808
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"572391\">@Aleksandar Milchev</span><br>\nOne general comment is that several times you have the pattern</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"bp\">...</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">exact</span> <span class=\"n\">some_term</span><span class=\"o\">},</span>\n</code></pre></div>\n<p>But you can shorten it to just:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"bp\">...</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"o\">:=</span> <span class=\"n\">some_term</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>The tactic <code>have</code> expects a term after <code>:=</code>, and <code>by {...}</code>is a way to construct a term using tactics, and <code>exact ...</code> is the tactic which supplies a term directly. So you can skip the <code>by {...}</code> and <code>exact ...</code>, and just give the term directly.</p>\n<p>This saves you some typing, but also sometimes works better. For example, on line 374, this gives me an error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">union</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">exact</span> <span class=\"n\">set.singleton_union</span><span class=\"o\">},</span>  <span class=\"c1\">-- error</span>\n</code></pre></div>\n<p>The error makes me think that Lean is unable to infer some implicit argument of <code>set.singleton_union</code>, possibly because of the interaction with <code>by {...}</code> and <code>exact ...</code>. And indeed, if I use <code>@</code> notation and give the arguments explicitly, the proof works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">union</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">set.singleton_union</span> <span class=\"n\">V</span> <span class=\"n\">s</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">}},</span>  <span class=\"c1\">-- ok</span>\n</code></pre></div>\n<p>But Lean is able to infer all the implicit arguments if you give the term directly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">union</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">set.singleton_union</span><span class=\"o\">,</span> <span class=\"c1\">-- ok</span>\n</code></pre></div>",
        "id": 344565822,
        "sender_full_name": "Mathieu Guay-Paquet",
        "timestamp": 1679786379
    },
    {
        "content": "<p>Also, I am not quite sure why you have a separate structure for Cut. This adds a few extra steps and theorems.</p>",
        "id": 344566097,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1679786554
    },
    {
        "content": "<p>For line 343, I think I see some of your confusion between <code>set</code> and <code>finset</code>. The current line is an error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- \"meta\" errors occur, how is finset handled?</span>\n<span class=\"k\">have</span> <span class=\"n\">hS</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">set.singleton_subset_iff</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">sInS</span><span class=\"o\">},</span>\n</code></pre></div>\n<p>(Incidentally, on my computer the main error I get is <code>invalid type ascription</code>, and the error about <code>meta</code> is later in the list of errors.)<br>\nBut in this context, <code>S</code> is a <code>finset V</code> rather than a <code>set V</code>. Thankfully, the <code>finset</code> type has a similar lemma to the <code>set</code> type, and this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">hS</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">finset.singleton_subset_iff</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">sInS</span><span class=\"o\">},</span>\n</code></pre></div>",
        "id": 344566471,
        "sender_full_name": "Mathieu Guay-Paquet",
        "timestamp": 1679786864
    },
    {
        "content": "<p>I think possibly for several of your proofs, you could get through the <code>set</code> versus <code>finset</code> difficulties by looking at the <a href=\"https://leanprover-community.github.io/mathlib_docs/data/finset/basic.html#set-coercion\">section on finset-to-set coercion</a>. In particular, the lemma <code>finset.mem_coe</code> says that the elements of a finset (on the right-hand side) are the same as the elements of the underlying not-necessarily-finite set (on the left-hand side).</p>",
        "id": 344567074,
        "sender_full_name": "Mathieu Guay-Paquet",
        "timestamp": 1679787342
    },
    {
        "content": "<p>Also, possibly part of the confusion is that for literal set notation, like <code>{a}</code> and <code>{a, b}</code>, the notation works to specify a <code>set</code>, or a <code>finset</code>, or any type which implements <code>has_singleton</code> and <code>has_insert</code> (I think). Unless you specify it somehow, Lean will guess whether you mean <code>set</code> or <code>finset</code>, and it will look fine, until you come to use it, if it turns out that you wanted the other one.</p>",
        "id": 344568628,
        "sender_full_name": "Mathieu Guay-Paquet",
        "timestamp": 1679788688
    },
    {
        "content": "<p>Similarly, the <code>∈</code> notation \"works\" for <code>set</code> and for <code>finset</code>, but <em>means</em> something different, and you have to be careful which one you want.</p>",
        "id": 344568708,
        "sender_full_name": "Mathieu Guay-Paquet",
        "timestamp": 1679788780
    },
    {
        "content": "<p>About <a href=\"https://github.com/leanprover-community/mathlib/blob/1b01848de994120c0a014d85352c118219fa5ea7/src/combinatorics/quiver/max_flow_min_cut.lean#L391\">this</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> The next two equalities use sum over two elements, so I am not sure how to resolve them. -/</span>\n  <span class=\"k\">have</span> <span class=\"n\">sum1</span><span class=\"o\">:</span> <span class=\"n\">mk_out</span> <span class=\"n\">afn.f</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">+</span> <span class=\"n\">mk_out</span> <span class=\"n\">afn.f</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">\\</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">})</span>  <span class=\"bp\">=</span> <span class=\"n\">mk_out</span> <span class=\"n\">afn.f</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- {unfold mk_out, rw finset.sum_sdiff hS},</span>\n  <span class=\"k\">have</span> <span class=\"n\">sum2</span><span class=\"o\">:</span> <span class=\"n\">mk_in</span> <span class=\"n\">afn.f</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">\\</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">})</span> <span class=\"bp\">+</span> <span class=\"n\">mk_in</span> <span class=\"n\">afn.f</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">mk_in</span> <span class=\"n\">afn.f</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- {unfold mk_in, rw finset.sum_sdiff hS},</span>\n</code></pre></div>\n<p>You can't prove them because they are not true. <code>mk_out afn.f {s}</code> counts the flow on those edges which leave <code>{s}</code> into the rest of the graph, including <code>S \\ {s}</code>.  The flow of these internal edges don't get counted in <code> mk_out afn.f S</code>. Same problem with <code>sum2</code>.  For context for other readers here's the definition of <code>mk_out</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">mk_out</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"bp\">∑</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∑</span> <span class=\"n\">y</span> <span class=\"k\">in</span> <span class=\"n\">finset.univ</span> <span class=\"bp\">\\</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>I am writing this at 1:45 am in the morning, so I apologise if I am missing something.</p>",
        "id": 344572578,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1679791497
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344572578\">said</a>:</p>\n<blockquote>\n<p>About <a href=\"https://github.com/leanprover-community/mathlib/blob/1b01848de994120c0a014d85352c118219fa5ea7/src/combinatorics/quiver/max_flow_min_cut.lean#L391\">this</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> The next two equalities use sum over two elements, so I am not sure how to resolve them. -/</span>\n  <span class=\"k\">have</span> <span class=\"n\">sum1</span><span class=\"o\">:</span> <span class=\"n\">mk_out</span> <span class=\"n\">afn.f</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">+</span> <span class=\"n\">mk_out</span> <span class=\"n\">afn.f</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">\\</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">})</span>  <span class=\"bp\">=</span> <span class=\"n\">mk_out</span> <span class=\"n\">afn.f</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- {unfold mk_out, rw finset.sum_sdiff hS},</span>\n  <span class=\"k\">have</span> <span class=\"n\">sum2</span><span class=\"o\">:</span> <span class=\"n\">mk_in</span> <span class=\"n\">afn.f</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">\\</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">})</span> <span class=\"bp\">+</span> <span class=\"n\">mk_in</span> <span class=\"n\">afn.f</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">mk_in</span> <span class=\"n\">afn.f</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- {unfold mk_in, rw finset.sum_sdiff hS},</span>\n</code></pre></div>\n<p>You can't prove them because they are not true. <code>mk_out afn.f {s}</code> counts the flow on those edges which leave <code>{s}</code> into the rest of the graph, including <code>S \\ {s}</code>.  The flow of these internal edges don't get counted in <code> mk_out afn.f S</code>. Same problem with <code>sum2</code>.  For context for other readers here's the definition of <code>mk_out</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">mk_out</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"bp\">∑</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∑</span> <span class=\"n\">y</span> <span class=\"k\">in</span> <span class=\"n\">finset.univ</span> <span class=\"bp\">\\</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>I am writing this at 1:45 am in the morning, so I apologise if I am missing something.</p>\n</blockquote>\n<p>Thank you for that, I found that out myself, and I proved the correct one yesterday.  I was missing  ∑ x in {s}, ∑ y in S \\ {s}, (f x y + f y x).</p>",
        "id": 344653176,
        "sender_full_name": "Aleksandar Milchev",
        "timestamp": 1679834473
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344561814\">said</a>:</p>\n<blockquote>\n<p>Hi <span class=\"user-mention silent\" data-user-id=\"572391\">Aleksandar Milchev</span>  : I am working on lean4 version of your proof. This is still a WIP. See this repository : <a href=\"https://gitlab.com/Shreyas941/maxflowmincutlean4\">https://gitlab.com/Shreyas941/maxflowmincutlean4</a></p>\n<p>I am  trying to following the same structure as yours with some convenient defintion changes and I was able to golf down many of your proofs. Thus far I have reached the theorem you call <code>set_flow_conservation</code>.</p>\n</blockquote>\n<p>Thank you very much for sending that over! Maybe we can work together on proving the rest of the theorem, I am currently stuck on aug_path. I believe that my other errors shouldn't be too hard to fix. I will follow your progress on that, I have my own <a href=\"https://github.com/amilchew/Max-Flow_Min-Cut\">repo</a>, which usually has the most updated code.</p>",
        "id": 344653865,
        "sender_full_name": "Aleksandar Milchev",
        "timestamp": 1679834726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"572391\">Aleksandar Milchev</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344653865\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344561814\">said</a>:</p>\n<blockquote>\n<p>Hi <span class=\"user-mention silent\" data-user-id=\"572391\">Aleksandar Milchev</span>  : I am working on lean4 version of your proof. This is still a WIP. See this repository : <a href=\"https://gitlab.com/Shreyas941/maxflowmincutlean4\">https://gitlab.com/Shreyas941/maxflowmincutlean4</a></p>\n<p>I am  trying to following the same structure as yours with some convenient defintion changes and I was able to golf down many of your proofs. Thus far I have reached the theorem you call <code>set_flow_conservation</code>.</p>\n</blockquote>\n<p>Thank you very much for sending that over! Maybe we can work together on proving the rest of the theorem, I am currently stuck on aug_path. I believe that my other errors shouldn't be too hard to fix. I will follow your progress on that, I have my own <a href=\"https://github.com/amilchew/Max-Flow_Min-Cut\">repo</a>, which usually has the most updated code.</p>\n</blockquote>\n<p>This sounds good to me. We can work on this. A quick observation : many of the intermediate steps you are using in the (net cut flow = net source flow) theorem seem to be useful otherwise. Basically these are flow versions of various finset properties about partitioning and combining and rearranging sums. It might be useful to have them as separate lemmas.</p>",
        "id": 344803203,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1679907854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344803203\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"572391\">Aleksandar Milchev</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344653865\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344561814\">said</a>:</p>\n<blockquote>\n<p>Hi <span class=\"user-mention silent\" data-user-id=\"572391\">Aleksandar Milchev</span>  : I am working on lean4 version of your proof. This is still a WIP. See this repository : <a href=\"https://gitlab.com/Shreyas941/maxflowmincutlean4\">https://gitlab.com/Shreyas941/maxflowmincutlean4</a></p>\n<p>I am  trying to following the same structure as yours with some convenient defintion changes and I was able to golf down many of your proofs. Thus far I have reached the theorem you call <code>set_flow_conservation</code>.</p>\n</blockquote>\n<p>Thank you very much for sending that over! Maybe we can work together on proving the rest of the theorem, I am currently stuck on aug_path. I believe that my other errors shouldn't be too hard to fix. I will follow your progress on that, I have my own <a href=\"https://github.com/amilchew/Max-Flow_Min-Cut\">repo</a>, which usually has the most updated code.</p>\n</blockquote>\n<p>This sounds good to me. We can work on this. A quick observation : many of the intermediate steps you are using in the (net cut flow = net source flow) theorem seem to be useful otherwise. Basically these are flow versions of various finset properties about partitioning and combining and rearranging sums. It might be useful to have them as separate lemmas.</p>\n</blockquote>\n<p>Nice! As for the intermediate sums, I see what you mean. I will consider which one can be used later and probably put them in separate lemmas.</p>",
        "id": 344818507,
        "sender_full_name": "Aleksandar Milchev",
        "timestamp": 1679911941
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"572391\">Aleksandar Milchev</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344818507\">said</a>:</p>\n<blockquote>\n<p>Nice! As for the intermediate sums, I see what you mean. I will consider which one can be used later and probably put them in separate lemmas.</p>\n</blockquote>\n<p>Flows are very basic in theoretical CS. Many graph problems can be treated as flow problems in disguise. So being able to perform basic reasoning about flows is a crucial building block for many algorithmic verification tasks.</p>",
        "id": 344837983,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1679917313
    },
    {
        "content": "<p>For example, being able to split the flows from S to V \\ S, into S to T and V\\S\\T (for T \\subset V \\ S)  is a trivial but frequent stepping stone for many algorithmic solutions. I am working on my side on some of these theorems. I'll see how far I get by tomorrow night.</p>",
        "id": 344839589,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1679917745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252278\">Mathieu Guay-Paquet</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344565822\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"572391\">Aleksandar Milchev</span><br>\nOne general comment is that several times you have the pattern</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"bp\">...</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">exact</span> <span class=\"n\">some_term</span><span class=\"o\">},</span>\n</code></pre></div>\n<p>But you can shorten it to just:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"bp\">...</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"o\">:=</span> <span class=\"n\">some_term</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>The tactic <code>have</code> expects a term after <code>:=</code>, and <code>by {...}</code>is a way to construct a term using tactics, and <code>exact ...</code> is the tactic which supplies a term directly. So you can skip the <code>by {...}</code> and <code>exact ...</code>, and just give the term directly.</p>\n<p>This saves you some typing, but also sometimes works better. For example, on line 374, this gives me an error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">union</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">exact</span> <span class=\"n\">set.singleton_union</span><span class=\"o\">},</span>  <span class=\"c1\">-- error</span>\n</code></pre></div>\n<p>The error makes me think that Lean is unable to infer some implicit argument of <code>set.singleton_union</code>, possibly because of the interaction with <code>by {...}</code> and <code>exact ...</code>. And indeed, if I use <code>@</code> notation and give the arguments explicitly, the proof works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">union</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">set.singleton_union</span> <span class=\"n\">V</span> <span class=\"n\">s</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">}},</span>  <span class=\"c1\">-- ok</span>\n</code></pre></div>\n<p>But Lean is able to infer all the implicit arguments if you give the term directly:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">union</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">set.singleton_union</span><span class=\"o\">,</span> <span class=\"c1\">-- ok</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"252278\">Mathieu Guay-Paquet</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344566471\">said</a>:</p>\n<blockquote>\n<p>For line 343, I think I see some of your confusion between <code>set</code> and <code>finset</code>. The current line is an error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- \"meta\" errors occur, how is finset handled?</span>\n<span class=\"k\">have</span> <span class=\"n\">hS</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">set.singleton_subset_iff</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">sInS</span><span class=\"o\">},</span>\n</code></pre></div>\n<p>(Incidentally, on my computer the main error I get is <code>invalid type ascription</code>, and the error about <code>meta</code> is later in the list of errors.)<br>\nBut in this context, <code>S</code> is a <code>finset V</code> rather than a <code>set V</code>. Thankfully, the <code>finset</code> type has a similar lemma to the <code>set</code> type, and this works:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">hS</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">finset.singleton_subset_iff</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">sInS</span><span class=\"o\">},</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thank you very much! Both of your comments were very very useful! I managed to implement everything apart from proving {s} ∪ {t} = {s,t}. I have to use finset.cons, and I can't prove that finset.cons t {s} h = {s,t}. Also, when I write {t}.disj_union {s} h it gives me the error message:</p>\n<p>invalid field notation, type is not of the form (C ...) where C is a constant<br>\n  {t}<br>\nhas type<br>\n  ?m_1</p>\n<p>Otherwise, if I just use set.singleton_union, I get a typo error on line <a href=\"https://github.com/amilchew/Max-Flow_Min-Cut/blob/master/src/max_flow_min_cut.lean\">515</a> because it treats {s,t} as a set, instead of finset. <br>\nDo you have any ideas about what should I do? Thank you in advance!</p>",
        "id": 344913676,
        "sender_full_name": "Aleksandar Milchev",
        "timestamp": 1679934496
    },
    {
        "content": "<p>have you tried <code>to_finset</code>?</p>",
        "id": 344914769,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1679934772
    },
    {
        "content": "<p>In mathlib4 there is a <code>Set.toFinset</code>. Following naming conventions there should be something like <code>set.to_finset</code> in mathlib</p>",
        "id": 344914892,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1679934809
    },
    {
        "content": "<blockquote>\n<p>I managed to implement everything apart from proving {s} ∪ {t} = {s,t}. </p>\n</blockquote>\n<p>The best way to ask a question on this site is to make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> . So, in your file, make a new lemma stating precisely what you want, sorry the proof, and check that you can apply the lemma in your example to solve your problem. Then make a new file containing only that lemma, make sure it compiles, and post the fully working code and ask for help. This is a really efficient way to get a solution.</p>",
        "id": 344914967,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679934835
    },
    {
        "content": "<p>That specific equality should be refl.</p>",
        "id": 344916029,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1679935103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344916029\">said</a>:</p>\n<blockquote>\n<p>That specific equality should be refl.</p>\n</blockquote>\n<p>I just tried it, and it gives the error message:</p>\n<p>invalid apply tactic, failed to unify<br>\n  {s} ∪ {t} = {s, t}<br>\nwith<br>\n  ?m_8 = ?m_8</p>",
        "id": 344918196,
        "sender_full_name": "Aleksandar Milchev",
        "timestamp": 1679935644
    },
    {
        "content": "<p>Then post the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> and we'll debug from there.</p>",
        "id": 344918280,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679935667
    },
    {
        "content": "<p>ext; simp will also do it</p>",
        "id": 344918522,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1679935714
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344918280\">said</a>:</p>\n<blockquote>\n<p>Then post the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> and we'll debug from there.</p>\n</blockquote>\n<p>It should be:</p>\n<p>import data.finset.basic</p>\n<p>universe u</p>\n<p>variable (V : Type u)</p>\n<p>open finset</p>\n<p>lemma union : ∀ (s t : V), {s} ∪ {t} = {s,t} := by sorry,</p>\n<p>However, I get an error message saying: 'don't know how to synthesize placeholder context' and don't know why. I tried to fix it, but I can't, apologies for that.</p>",
        "id": 344928603,
        "sender_full_name": "Aleksandar Milchev",
        "timestamp": 1679938425
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n<span class=\"bp\">.</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"o\">({</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 344929042,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1679938555
    },
    {
        "content": "<p>Indeed refl works here, how are you dealing with decidability in your original problem?<br>\nDo you have open locale classical or some explicit decidability hypotheses?</p>",
        "id": 344929380,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1679938653
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344929042\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n<span class=\"bp\">.</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"o\">({</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thank you very much for that, could you tell me how you put code in your message, please? <br>\nAs for decidability, I have open_locale classical.</p>",
        "id": 344929886,
        "sender_full_name": "Aleksandar Milchev",
        "timestamp": 1679938813
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> for the code</p>",
        "id": 344929942,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1679938831
    },
    {
        "content": "<p>Something else must be different between your example and this one then, <code>by intros s t; refl</code> works here</p>",
        "id": 344930061,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1679938871
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"572391\">Aleksandar Milchev</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344918196\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344916029\">said</a>:</p>\n<blockquote>\n<p>That specific equality should be refl.</p>\n</blockquote>\n<p>I just tried it, and it gives the error message:</p>\n<p>invalid apply tactic, failed to unify<br>\n  {s} ∪ {t} = {s, t}<br>\nwith<br>\n  ?m_8 = ?m_8</p>\n</blockquote>\n<p>what happens here with <code>set_option pp.all true</code> turned on (before the lemma)</p>",
        "id": 344930194,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1679938922
    },
    {
        "content": "<p>I would guess that one side of the equality uses classical decidability and the other doesn't</p>",
        "id": 344930337,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679938962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344930194\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"572391\">Aleksandar Milchev</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344918196\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/344916029\">said</a>:</p>\n<blockquote>\n<p>That specific equality should be refl.</p>\n</blockquote>\n<p>I just tried it, and it gives the error message:</p>\n<p>invalid apply tactic, failed to unify<br>\n  {s} ∪ {t} = {s, t}<br>\nwith<br>\n  ?m_8 = ?m_8</p>\n</blockquote>\n<p>what happens here with <code>set_option pp.all true</code> turned on (before the lemma)</p>\n</blockquote>\n<p>I managed to fix it by writing ({s} : finset V) instead of {s}. refl works now, thank you very much!</p>",
        "id": 344931279,
        "sender_full_name": "Aleksandar Milchev",
        "timestamp": 1679939246
    },
    {
        "content": "<p>Hello there! I am currently trying to implement the no_aug_path theorem, but I need to take the minimum flow, which can be pushed in the residual network. For that purpose, I need somehow to have all flow values in the augmenting path (the flow in the residual network between x and y is f' x y) in order to take the minimum one. I have all vertices in the residual network in a set called 'vertices', and I tried </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">set</span> <span class=\"n\">flows</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"o\">(</span><span class=\"n\">rsn.f'</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span> <span class=\"bp\">∧</span> <span class=\"n\">exists_path.in</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>but I have an error saying: 'invalid binder, '(', '{', '[', '{{', '⦃' or identifier expected' when I hover on forall and then unknown identifiers for x,y, vertices and exists_path (defined to be an augmenting path). Can that be fixed or can you please suggest other ways I can construct a set with all flows in the augmenting path.</p>",
        "id": 348506153,
        "sender_full_name": "Aleksandar Milchev",
        "timestamp": 1681229556
    },
    {
        "content": "<p>I'm not sure what you mean your set to be, to be quite honest. You have <code>x</code> and <code>y</code> on the left of the <code>|</code>, then you introduce two other <code>x</code> and <code>y</code> with the forall.</p>",
        "id": 348508784,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1681230253
    },
    {
        "content": "<p>Am I right in thinking you didn't mean the forall to introduce new variables and your set can be written as <code>function.uncurry rsn.f' '' {xy \\in vertices \\times\\^s vertices | exists_path.in xy.1 xy.2}</code>?</p>",
        "id": 348509213,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1681230382
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/348509213\">said</a>:</p>\n<blockquote>\n<p>Am I right in thinking you didn't mean the forall to introduce new variables and your set can be written as <code>function.uncurry rsn.f' '' {xy \\in vertices \\times\\^s vertices | exists_path.in xy.1 xy.2}</code>?</p>\n</blockquote>\n<p>You are right, I don't actually want to introduce new variables with the forall (it's actually not needed).<br>\nThank you very much for the code, it seems to work, but I am confused with  '\\times\\^s', what does that stand for?</p>",
        "id": 348514326,
        "sender_full_name": "Aleksandar Milchev",
        "timestamp": 1681231595
    },
    {
        "content": "<p>In Lean 3, you should be able to do <code>{ (rsn.f' x y) | (x y : V), (x ∈ vertices ∧ y ∈ vertices ∧ exists_path.in x y) }</code> without the forall, if I got the syntax right.</p>",
        "id": 348515381,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681231868
    },
    {
        "content": "<p>It's <code>{(expression in parentheses) | binders, condition}</code></p>",
        "id": 348515489,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681231904
    },
    {
        "content": "<p>I had no idea that there was a <code>, condition</code> term</p>",
        "id": 348653359,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681288562
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> No, unfortunately I misremembered, and I just had the opportunity to check. The way you encode this is that you add an extra binder. Simpler example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)}</span>\n</code></pre></div>",
        "id": 348705324,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681300754
    },
    {
        "content": "<p>In principle you could have an extra <code>, condition</code> term, but <a href=\"https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/brackets.cpp#L51\">in the current implementation</a> it's just <code>{(expression in parentheses) | binders}</code>.</p>",
        "id": 348705836,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681300855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/348509213\">said</a>:</p>\n<blockquote>\n<p>Am I right in thinking you didn't mean the forall to introduce new variables and your set can be written as <code>function.uncurry rsn.f' '' {xy \\in vertices \\times\\^s vertices | exists_path.in xy.1 xy.2}</code>?</p>\n</blockquote>\n<p>Thank you very much, I defined the set that way but had to use set.to_finset because I it is more convenient for the whole structure of the code and I needed that it is nonempty after. However, I have issues proving it, I am not sure how to prove that vertices are in this set.  I was searching for more information in the documentation on how to use properties of sets, defined that way and the minimality of d, but couldn't find any. That is why, I need help with proving the theorems below, they shouldn't be really hard. I am currently working on proving that if the flow is maximal, there isn't an augmenting path in the residual network, so g can be treated as a function showing if (u,v) is an edge in the augmenting path (assuming one exists) and f is the flow in the residual network (always bigger than zero, that is why the lemma 'fact' can be used directly). Later on, I have two bigger problems, one is picking the edge going out of the source in the augmenting path and using it to prove that if an augmenting path exists, then a better flow can be created, and proving the flow conservation for a vertex v in the set vertices. I am feeling that I am really close to proving the theorem as these are the final issues, anything else works, but I need to resolve the small issues below first, and the two major issues later. I will be grateful if someone is keen to help me with that and at least resolves the lemmas, but please message me if you want to know more about the other two issues. My code can be found <a href=\"https://github.com/amilchew/Max-Flow_Min-Cut/blob/master/src/max_flow_min_cut.lean\">in this repository</a>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.induction</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.order</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">fact</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- can be used as a fact</span>\n  <span class=\"n\">set</span> <span class=\"n\">vertices</span> <span class=\"o\">:=</span> <span class=\"n\">set.to_finset</span> <span class=\"o\">({</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">}),</span> <span class=\"c1\">--all vertices in the augmenting path</span>\n  <span class=\"c1\">-- set of all flow values in the augmenting path</span>\n  <span class=\"n\">set</span> <span class=\"n\">flows</span> <span class=\"o\">:=</span> <span class=\"n\">set.to_finset</span> <span class=\"o\">(</span><span class=\"n\">function.uncurry</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"o\">{</span><span class=\"n\">xy</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">vertices</span> <span class=\"bp\">|</span> <span class=\"n\">g</span> <span class=\"n\">xy.1</span> <span class=\"n\">xy.2</span><span class=\"o\">}),</span>\n  <span class=\"k\">have</span> <span class=\"n\">nonemp</span><span class=\"o\">:</span> <span class=\"n\">flows.nonempty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- has to be proven!</span>\n  <span class=\"n\">set</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"n\">flows.min'</span> <span class=\"n\">nonemp</span><span class=\"o\">,</span> <span class=\"c1\">-- the minimum flow in the augmenting path</span>\n  <span class=\"k\">have</span> <span class=\"n\">pos</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- has to be proven!</span>\n  <span class=\"k\">have</span> <span class=\"n\">noPath</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">:</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"bp\">∉</span> <span class=\"n\">vertices</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">exists_path.in</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">exists_path.in</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- has to be proven!</span>\n  <span class=\"k\">have</span> <span class=\"n\">minimality</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">d</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- has to be proven!</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 353519509,
        "sender_full_name": "Aleksandar Milchev",
        "timestamp": 1682634549
    },
    {
        "content": "<p>Aren't you missing some finiteness assumption on <code>V</code>?</p>",
        "id": 353648981,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1682659300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/353648981\">said</a>:</p>\n<blockquote>\n<p>Aren't you missing some finiteness assumption on <code>V</code>?</p>\n</blockquote>\n<p>Yes, I am, sorry, so the code should be: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.induction</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.order</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst'</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">fact</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- can be used as a fact</span>\n  <span class=\"n\">set</span> <span class=\"n\">vertices</span> <span class=\"o\">:=</span> <span class=\"n\">set.to_finset</span> <span class=\"o\">({</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">}),</span> <span class=\"c1\">--all vertices in the augmenting path</span>\n  <span class=\"c1\">-- set of all flow values in the augmenting path</span>\n  <span class=\"n\">set</span> <span class=\"n\">flows</span> <span class=\"o\">:=</span> <span class=\"n\">set.to_finset</span> <span class=\"o\">(</span><span class=\"n\">function.uncurry</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"o\">{</span><span class=\"n\">xy</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">vertices</span> <span class=\"bp\">|</span> <span class=\"n\">g</span> <span class=\"n\">xy.1</span> <span class=\"n\">xy.2</span><span class=\"o\">}),</span>\n  <span class=\"k\">have</span> <span class=\"n\">nonemp</span><span class=\"o\">:</span> <span class=\"n\">flows.nonempty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- has to be proven!</span>\n  <span class=\"n\">set</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"n\">flows.min'</span> <span class=\"n\">nonemp</span><span class=\"o\">,</span> <span class=\"c1\">-- the minimum flow in the augmenting path</span>\n  <span class=\"k\">have</span> <span class=\"n\">pos</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- has to be proven!</span>\n  <span class=\"k\">have</span> <span class=\"n\">noPath</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">:</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"bp\">∉</span> <span class=\"n\">vertices</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">g</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- has to be proven!</span>\n  <span class=\"k\">have</span> <span class=\"n\">minimality</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">d</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- has to be proven!</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- just elliminates true</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 353822590,
        "sender_full_name": "Aleksandar Milchev",
        "timestamp": 1682682964
    },
    {
        "content": "<p>Hello everyone! I am still working on the implementation of the max-flow min-cut theorem in Lean 3 and I have a good progress. Currently, I need help with the following MWE: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.induction</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.order</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst'</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">fact</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- can be used as a fact</span>\n  <span class=\"n\">set</span> <span class=\"n\">vertices</span> <span class=\"o\">:=</span> <span class=\"n\">set.to_finset</span> <span class=\"o\">({</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">}),</span> <span class=\"c1\">--all vertices in the augmenting path</span>\n  <span class=\"c1\">-- set of all flow values in the augmenting path</span>\n  <span class=\"n\">set</span> <span class=\"n\">flows</span> <span class=\"o\">:=</span> <span class=\"n\">set.to_finset</span> <span class=\"o\">(</span><span class=\"n\">function.uncurry</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"o\">{</span><span class=\"n\">xy</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">vertices</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">xy.1</span> <span class=\"n\">xy.2</span><span class=\"o\">}),</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">foo</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">flows</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- has to be proven!</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">nonemp</span><span class=\"o\">:</span> <span class=\"n\">flows.nonempty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- can be used as a fact, can be proven directly using foo</span>\n  <span class=\"n\">set</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"n\">flows.min'</span> <span class=\"n\">nonemp</span><span class=\"o\">,</span> <span class=\"c1\">-- the minimum flow in the augmenting path</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">bar</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">flows</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- just elliminates true</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I will appreciate it if someone can help me resolve the lemmas foo and bar above. Moreover, I will be really grateful if someone has a better look at <a href=\"https://github.com/amilchew/Max-Flow_Min-Cut/blob/master/src/max_flow_min_cut.lean\">my code</a> and helps me to resolve the issues on lines 865 (another lemma with the name bar), 1031-1040 (should follow <a href=\"https://github.com/amilchew/Max-Flow_Min-Cut/blob/master/Max-Flow_Min-Cut_Proof.pdf\">my proof</a>, 1047 (lemma ancestor) and 1147 (just need to pick the edge (s,v) in the augmenting path. I believe that all issues apart from 1031-1040 should be resolved relatively quickly. Please let me know if someone decides to have a better look at my code and if any questions arise.</p>",
        "id": 355250553,
        "sender_full_name": "Aleksandar Milchev",
        "timestamp": 1683056565
    },
    {
        "content": "<p>Sorry, I wish I had time, but my finals are in a month!</p>",
        "id": 355271495,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1683064179
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/355271495\">said</a>:</p>\n<blockquote>\n<p>Sorry, I wish I had time, but my finals are in a month!</p>\n</blockquote>\n<p>Wish you good luck with that! My project deadline is the end of this week, but I believe I will continue with the implementation after because I want to finish the proof, it has been fascinating working so far.</p>",
        "id": 355274821,
        "sender_full_name": "Aleksandar Milchev",
        "timestamp": 1683065747
    },
    {
        "content": "<p>I did the first one, there is some really weird behavior with cases being slow though, the second I got a bit confused by what happens if the vertices are equal, it seems <a href=\"http://path.in\">path.in</a> allows this but I'm not sure what happens to f then <a href=\"https://gist.github.com/alexjbest/d2adba680b8e20540874ad77b2aebb4a\">https://gist.github.com/alexjbest/d2adba680b8e20540874ad77b2aebb4a</a></p>",
        "id": 355288580,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1683073314
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/252551-graph-theory/topic/max-flow.20min-cut.20help/near/355288580\">said</a>:</p>\n<blockquote>\n<p>I did the first one, there is some really weird behavior with cases being slow though, the second I got a bit confused by what happens if the vertices are equal, it seems <a href=\"http://path.in\">path.in</a> allows this but I'm not sure what happens to f then <a href=\"https://gist.github.com/alexjbest/d2adba680b8e20540874ad77b2aebb4a\">https://gist.github.com/alexjbest/d2adba680b8e20540874ad77b2aebb4a</a></p>\n</blockquote>\n<p>Hey, Alex! The first solution is working, thank you very much! As for your question, the non-symmetric property implies that there are no self-loops in the initial graph. Afterwards, the flow in the residual network is zero if there is no edge between two vertices in the initial graph, which is the case if the vertices are equal. I will have a look as well, but hope that helps!</p>",
        "id": 355429537,
        "sender_full_name": "Aleksandar Milchev",
        "timestamp": 1683118600
    }
]