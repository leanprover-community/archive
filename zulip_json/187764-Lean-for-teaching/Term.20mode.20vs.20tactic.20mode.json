[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"529807\">Frédéric Tran Minh</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Lean.20courses.20around.20the.20world/near/342313435\">said</a>:</p>\n<blockquote>\n<p>We used proof-term style in Lean.</p>\n</blockquote>\n<p>Can you comment on why you chose to use proof-terms? This seems very counter-intuitive for a math course.</p>",
        "id": 342499247,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1679042664
    },
    {
        "content": "<p>Hi Patrick and thanks for sharing. As you know I'm quite new is the universe of PA (we saw each other in Paris about 1 year ago... remember?) . Sorry in advance for the quite long reply.  Good question....</p>\n<p>In preamble: I made this choice without any background knowledge of how usually people use PA for teaching. <br>\nThis was even one of the reasons for which I chose Lean over Coq, because at that time I didn't know that Coq could use proof term style as well, introduced by exact tactic (and even it seems less 'native'). <br>\n(Aside from that I would probably be interested in opening a topic about why people here chose Lean over Coq for teaching, maybe this topic already exists).</p>\n<p>To try to actually answer the question, I had the feeling that proof term style emphasizes the structured / hierarchical aspect  of a proof. Terms being functionnally nested, the proof does not appear as sequence of imperative instructions. The scope of symbols is naturally highlighted by the structure of the term. <br>\n(Also I try to teach a very 'decorated' term style , with all the types made redundantly apparent : assume (h:P), ..., which is if I'm not mistaking something you're sort of forcing in your \"Lean-Verbose\" package -- but I could do that also in tactic-style) <br>\nIn tactic mode to prove P \\and Q  you ask, say, 'split', and you have to mentally keep track of the following structure in 2 blocks, and the interactive display of tactic state helps you.<br>\nIn proof term you write   'and.intro (...) (...)'  which in a sense is identical, but the structure is imposed by the syntax of the langage.<br>\nI have a slightly different feeling between 'the proof is unfinished because there's a goal left to prove'  and  'the term is syntaxically incorrect because I gave only 1 argument to function and.intro which expects 2'.<br>\nI must add that my students are and will keep studying CS during 5 years (algorithmics, langages, theory of langages: grammars...) and are supposed to be gradually sensitized to formal syntaxics issues. (and I'm myself a former dev engineer reconverted in teaching maths &amp; CS...)<br>\nI don't know what is really intuitive or counter intuitive for 1st year students with quasi no proof practice. But the tactic style kind of mixes the \"necessary condition\" direction (work on hypothesis) and the \"sufficient condition\" direction (work on the goal) and to me, this seems confusing for students that do not clearly distinguish forward and backward reasoning.<br>\nFinally, even if the use of tactics is 'in fine' inevitable in practice, the sense that you could develop the whole term using lemmas gives, I find, sort of confidence in a proof, as opposed to the quite 'opaque' 'black box' philosophy of tactics.  If you #print the term produced by 'simp' or 'finish' you often get a term the no normal human would write, nor easily reads. (I would be interested to know if it's possible to write tactics the produces human-readable terms....). </p>\n<p>I admit that the difference could be tiny and also I may have made a mistake. Still hesitating for next time.<br>\nMay I ask you why you chose tactic-style for teaching ?</p>",
        "id": 342538195,
        "sender_full_name": "Frédéric Tran Minh",
        "timestamp": 1679053625
    },
    {
        "content": "<p>Because <code>ring</code> represents how mathematicians think much better than <code>rw add_assoc</code>, and <code>linarith</code> much better than <code>refine lt_of_le_of_lt h _</code></p>",
        "id": 342645494,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679079752
    },
    {
        "content": "<p>The question simply does not apply in a course involving actual math. Term mode is good enough only for pure logic or micro proofs combining known facts.</p>",
        "id": 342969878,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1679247565
    },
    {
        "content": "<p>About structuring, there is nothing enforced by tactic mode. It all depends on the tactics you choose to use and how you choose to use them.</p>",
        "id": 342969952,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1679247600
    },
    {
        "content": "<p>I do however give a few term mode proofs and also some in both modes and/or print the ones in tactic mode so that students know what is going on in tactics.</p>",
        "id": 343009033,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1679275093
    },
    {
        "content": "<p>Thank you for your clear-cut answer! I'll think about it.</p>",
        "id": 343098445,
        "sender_full_name": "Frédéric Tran Minh",
        "timestamp": 1679313656
    },
    {
        "content": "<p>A great feature of Lean 4 is an ability to combine both style easily. In term mode you can write something like <code>add.intro (by ring) (...)</code>, while in the proof mode you can do <code>refine add_intro ?_ ?_</code> to get the goals you need.</p>\n<p>I prefer term mode for a simple reason: I prefer to embrace type theory rather than hide it under tactics and pretend it's a some kind of set theory.</p>\n<p>As an example of a style, consider <code>mul_left_cancel</code> from Natural Number Game:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mul_left_cancel</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}(</span><span class=\"n\">pn</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">suffices</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"k\">from</span> <span class=\"n\">h</span> <span class=\"n\">k</span>\n  <span class=\"n\">refine</span> <span class=\"n\">p.recOn</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">nk</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">mul_eq_zero</span> <span class=\"n\">nk</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">pn</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">)</span> <span class=\"n\">id</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">p</span> <span class=\"n\">h</span>\n    <span class=\"k\">show</span> <span class=\"bp\">∀</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">p.succ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">p.succ</span>\n    <span class=\"n\">refine</span> <span class=\"bp\">λ</span><span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">k.casesOn</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">pn</span> <span class=\"bp\">$</span> <span class=\"n\">add_eq_zero_right</span> <span class=\"n\">e.symm</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n      <span class=\"n\">exact</span> <span class=\"n\">congrArg</span> <span class=\"n\">Nat.succ</span> <span class=\"bp\">$</span> <span class=\"n\">h</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">add_right_cancel</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Compared to <a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/blob/master/src/game/world9/level4.lean#L54\">a proof in NNG</a> it has the following features:</p>\n<ol>\n<li>You can actually read it without starting Lean</li>\n<li>The reason why it's possible to read is because of sufficient amount of type annotations</li>\n<li>Only structuring tactics are used. No tactics like <code>split</code> or <code>induction</code>, since there are functions for that</li>\n<li>And I would argue it's closer to <em>both</em> a human proof and a proof term than the proof in NNG</li>\n</ol>",
        "id": 360770146,
        "sender_full_name": "suhr",
        "timestamp": 1684930018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Term.20mode.20vs.20tactic.20mode/near/360770146\">said</a>:</p>\n<blockquote>\n<p>I prefer term mode for a simple reason: I prefer to embrace type theory rather than hide it under tactics and pretend it's a some kind of set theory.</p>\n</blockquote>\n<p>I don't understand what tactics have to do with pretending type theory is set theory (except <em>potentially</em> <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#lift\">tactic#lift</a>).</p>\n<p>I'm also not sure why you think <code>p.recOn ?_ ?_</code> is more readable than some version using the <code>induction</code> tactic, or how using <code>Or.elim</code> hidden behind dot notation is more readable than a proof with <code>cases</code>. I'm not saying the NNG proof you linked is the ideal in terms of readability, but certainly there are cases where sophisticated tactics (beyond <code>intro</code>, <code>exact</code> or <code>refine</code>) truly aid in readability of a proof, especially when you get past things as simple as natural numbers.</p>",
        "id": 360898058,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1684962705
    },
    {
        "content": "<p><code>Nat</code> is an inductive type, defined by its constructors and eliminated by its recursor. So <code>p.recOn</code> emphasis that induction is not some kind of special thing in type theory, it's literally just using the recursor of an inductive type.</p>\n<p>Same for <code>Or.elim</code>: reasoning by cases is not some kind of special rule, but simply applying a function to the value of the <code>Or</code> type. And <code>Or</code> is again just an inductive type.</p>\n<blockquote>\n<p>but certainly there are cases where sophisticated tactics (beyond intro, exact or refine) truly aid in readability of a proof</p>\n</blockquote>\n<p>True. But in this cases you need <code>simp</code>, <code>ring</code> or <code>aesop</code> rather than <code>cases</code>.</p>",
        "id": 361015875,
        "sender_full_name": "suhr",
        "timestamp": 1685010975
    },
    {
        "content": "<p>I'm rather new to Lean so I can't comment on the benefits that tactic mode may give you over term mode. That being said, from a beginner's perspective, comparatively I like term mode over tactics (although both are quite difficult to read). </p>\n<p>Tactics hide a lot of information that you only see when the lean server is running, which makes <em>understanding</em> a proof very difficult. While the kernel checks the correctness of the proof, a lot of the times the thing I am more interested in is the strategy the user took to develop the proof. Which means being able to easily read a proof is a priority for me.</p>",
        "id": 364379184,
        "sender_full_name": "Petur Vetle",
        "timestamp": 1686166582
    },
    {
        "content": "<p>If you want to write a mathematically non-trivial proof, then it's really hard without tactics.</p>",
        "id": 364382121,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686167497
    },
    {
        "content": "<p>Also, <code>simp only [inter_univ]</code> is more readable than some complicated expression with <code>congr_arg</code> and <code>congr_fun</code>.</p>",
        "id": 364382376,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686167561
    },
    {
        "content": "<p>I think you must mean a different thing to me when you say \"<em>understanding</em> a proof\". The term corresponding to a proof of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mi>y</mi><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">(x+y)^2=x^2+2xy+y^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> is incomprehensible to me, whereas the tactic <code>ring</code> is highly comprehensible as an explanation of what is actually going on.</p>",
        "id": 364385628,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1686168535
    },
    {
        "content": "<p>Tactics are definitely better in situations where the details of the proof are a burden to the reader (and hence the writer). But the <a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/blob/master/src/game/world9/level4.lean#L54\">link</a> that <span class=\"user-mention\" data-user-id=\"394485\">@suhr</span>  gave to the <code>mul_left_cancel</code> proof in the natural number game is good example of why I don't like tactics. For me, its very difficult to parse the proof, even with vs code open and running the lean server. I'm sure that'll change as I learn more about lean. On the other hand, term mode isn't much better, but at least all of the details involved in the proof are visible. To me at least, its easier to see the structure and motivation behind a proof when its written in term mode.</p>",
        "id": 364387774,
        "sender_full_name": "Petur Vetle",
        "timestamp": 1686169238
    },
    {
        "content": "<p>That's because it's better to write this proof with some abstractions.</p>",
        "id": 364388709,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686169582
    },
    {
        "content": "<p>E.g., if you use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Injective.eq_iff#doc\">docs4#Function.Injective.eq_iff</a>, then you need to prove only one implication.</p>",
        "id": 364388755,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686169604
    },
    {
        "content": "<p>The other is in fact some <code>congr_arg</code></p>",
        "id": 364388829,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686169625
    },
    {
        "content": "<p>Then it may be useful to prove that <code>(a * ·)</code> is strictly monotone, not just injective.</p>",
        "id": 364388996,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686169687
    },
    {
        "content": "<p>(of course in the NNG you're not building a library, you're heading for a goal)</p>",
        "id": 364389040,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686169712
    },
    {
        "content": "<p>For results that basic I guess my instinct would be that I had no desire to actually see the details of the proof :-) The term behind that tactic mode proof will be much worse than the tactic, because it uses the <code>rw</code> tactic which generates horrible terms.</p>\n<p>Here's my attempt to read that proof without VS Code (disclaimer: I wrote the proof). </p>\n<p>Every variable is a natural. Fix <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≠</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">a\\not=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>. Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(c)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span></span></span></span> denote the statement that for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>b</mi><mo>=</mo><mi>a</mi><mi>c</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>b</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">ab=ac\\implies b=c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">ab</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.549em;vertical-align:-0.024em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span>. We prove it by induction. Base case: we need to check that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>=</mo><mi>a</mi><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">0=ac</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span></span></span></span> implies <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>=</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">0=c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span> given <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≠</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">0\\not=a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span>, but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>c</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">ac=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> implies <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">a=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">c=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> (that's what <code>eq_zero_or_eq_zero_of_mul_eq_zero</code> is going to say) so we're done.</p>\n<p>Inductive step: we assume \"for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>b</mi><mo>=</mo><mi>a</mi><mi>d</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>b</mi><mo>=</mo><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">ab=ad\\implies b=d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">ab</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7184em;vertical-align:-0.024em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span>\" and we want \"for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>b</mi><mo>=</mo><mi>a</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>b</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>d</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ab=a(d+1)\\implies b=(d+1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">ab</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>\". So let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> be arbitrary. If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">b=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">a(d+1)=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> and this is a contradiction because neither <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> nor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">d+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> are zero. If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo>≠</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">b\\not=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> then we can write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo>=</mo><mi>c</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">b=c+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> (sorry for reusing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span>!) and now our goal is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mi>a</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>c</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>d</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">a(c+1)=a(d+1)\\implies c+1=d+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> and expanding out the brackets (<code>mul_succ</code>) and cancelling <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> (<code>add_right_cancel</code>) means that we need to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>c</mi><mo>=</mo><mi>a</mi><mi>d</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>c</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>d</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">ac=ad\\implies c+1=d+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7184em;vertical-align:-0.024em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>, which follows from the inductive hypothesis.</p>\n<p>Note that I just read the tactic proof and I could guess what the lemmas were saying because of Lean's super-cool naming convention.</p>",
        "id": 364389433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1686169861
    },
    {
        "content": "<p>The experts have already weighed in. However, since this is about teaching and learning, I'll try to offer the perspective of someone who started with lean recently, and has also dabbled in other provers. That is to say, a learner and beginner.</p>\n<p>TL DR: Term mode is worth it for basic stuff and understanding what to do and what tactics mean. It has some pedagogical value. However, once you get past basic propositions and start dabbling in predicates involving other data types, it quickly becomes tedious with messy details that distract from the actual proof. Sticking with term mode can be very boring for students.</p>\n<p><strong>Very Long Response</strong>: <br>\nFirstly, I understand where you are coming from. When I started with tpil, I too was enthusiastic about using term mode and retained that enthusiasm for a few months. Why? I had tried Coq before (Software Foundations) and dabbled a bit in Isabelle (although back then I gave it up very quickly). In both of them, the tactic language confused me a lot because every tactic seemed to be doing its own thing and the only handle the teaching materials gave to me was the intuitive idea of what they did. This might be fine for pen and paper proofs where one can work out the details in one's mind or scribble them in enough detail to understand things. But when you are writing something in a theorem prover (which is an exercise in programming and, at sufficient scale engineering, no matter what mathematicians say), you know you need to formulate something precise. At that point the vague intuition about tactics that tutorials provide is not sufficient. How does one reason about what's going on? What's really happening under the hood for some tactic code to be considered a proof? What even is a proof, and what is the prover checking? How does one debug the proof if something doesn't work? In contrast, lean's <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a> starts out with two chapters on term mode proofs of propositions and predicates. This is a minimal simple programming language and with practice, one can learn to program proofs for almost any propositional statement. Suddenly proof assistants feel less like unwieldy magic and more like a systematic, comprehensible programming exercise. I wouldn't be surprised if subconsciously this was the factor that made me stick with lean, although my normal response to such questions includes other factors. Since then I have taken another shot at Coq and Isabelle and got through the learning material and exercises much more quickly. So there is clearly some pedagogical value in understanding the term language</p>\n<p>However, having sung the glories of term mode, I have to admit that I very quickly hit a wall. As soon as I hit some \"real\" math (read : simple things involving numbers, equalities, inequalities etc), the proving process very quickly degenerated into long and tedious sequences of using <code>Nat</code>,  <code>Eq</code>'s, <code>LT</code>s constructors and recursors. Any high level structure in the proof got drowned in a morass of irrelevant details. This is when I warmed to chapter 5. The term mode chapters definitely helped me better structure my understanding of what these tactics were doing. I am guessing I am not the only one who went through this experience.</p>\n<p>Additionally,  I have known quite a few students who went through theorem prover courses in a CS context. Many of these courses focus mostly on how to work with logic and never touch upon any serious math. The students came out these courses scarred. One of them, doesn't want to see a theorem prover again for a few years. This is not some statistically representative sample. But it is not hard to guess why someone might say this.</p>",
        "id": 364395547,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1686172080
    }
]