[
    {
        "content": "<p>We are currently about to attempt to add (Verbose) Lean support to the <a href=\"https://impermeable.github.io/\">Waterproof</a> project. We're having some internal discussion about the file format, and we're looking for some community input. (In particular, <span class=\"user-mention\" data-user-id=\"354934\">@David Thrane Christiansen</span> and <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> ) Any input is welcome, but especially if you see any major advantages/problems with these approaches.</p>\n<p>The key question: What file structure should we use for exercise sheets as the basis Lean for Waterproof?<br>\nOptions:</p>\n<ul>\n<li>A (custom) Verso Genre</li>\n<li>A regular lean file with magic comments</li>\n<li>A Lean Verbose file, with magic comments (if needed?)</li>\n<li>Something else entirely?</li>\n</ul>\n<p>If there is a feasible migration path and a good reason for it, we could also start with one format and migrate to another, but this is not our preference.</p>\n<p>Example of the current file format <a href=\"https://github.com/impermeable/waterproof-exercise-sheets/blob/main/ch2_metric_spaces.mv\">here</a></p>\n<p>Current file format features:</p>\n<ul>\n<li>Marking input areas for students</li>\n<li>Collapsible sections with titles for pedagogical hints</li>\n<li>Collapsible sections with titles for hiding technical code</li>\n<li>Markdown with LaTeX for explanatory text.</li>\n</ul>\n<p>Goals of the choice for the Lean format:</p>\n<ul>\n<li>Good LSP support for the raw file format</li>\n<li>Well-specified format for interleaving code and text</li>\n<li>Connect to the Lean ecosystem in the appropriate \"spot\"</li>\n<li>Future possibilities of building on top of this format (e.g. interactive websites)</li>\n</ul>\n<p>Some optional context:</p>\n<ul>\n<li>We currently split code cells for input areas, which is currently not supported by Verso (<a href=\"https://github.com/leanprover/verso/issues/135\">issue</a>). <a href=\"https://github.com/impermeable/introduction-to-proof-sheets/blob/bcd5bb481f889d55ecec99e023603214773b18f6/lecture1/sheet1_conjunction.mv#L133\">Example here</a></li>\n<li>There's prior art for using magic comments for <a href=\"https://github.com/leanprover/verso/blob/main/examples/anchor-examples/AnchorExamples.lean\">Anchors</a> in Verso. We suspect this means that we could in the future likely render a magic-comment version with Verso with a similar setup as in for example Tao's <a href=\"https://github.com/teorth/analysis/\">analysis</a></li>\n<li>Currently, our editor connects to the LSP and uses that information. Building the whole document with Verso is likely too long of a feedback loop at this point, and is only relevant for the prospect of building future (interactive) website versions.</li>\n</ul>",
        "id": 540964764,
        "sender_full_name": "Pim Otte",
        "timestamp": 1758618712
    },
    {
        "content": "<p>I want to give this a proper think before responding, but I do want to let you know that I've seen the question and am pondering</p>",
        "id": 540965536,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1758618952
    },
    {
        "content": "<p>I am very happy that you are working on this, but indeed I think this is a question for David rather than me.</p>",
        "id": 541316900,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1758742939
    },
    {
        "content": "<p>As a side note, in lean4game we use regular Lean files with magic, custom commands (<code>elab</code>s), but this dates from a time before verso existed. In a recent discussion with <span class=\"user-mention\" data-user-id=\"662452\">@Jason Reed</span> from the FRO, it has been discussed that this could change to a custom verso genre in the far future.</p>\n<p>The issue with that is that last time I checked, verso was still very much in progress with documentation only being created, so I haven't yet learned how it works in detail.</p>",
        "id": 541379315,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1758782383
    },
    {
        "content": "<p>We discussed this thoroughly at today's team meeting. I have to go pick up my kid but I will report back soon!</p>",
        "id": 541462590,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1758807929
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"385895\">@Jon Eugster</span> , what are the chances that verbose can be combined with the game server?... :)</p>",
        "id": 541553376,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1758839266
    },
    {
        "content": "<p>OK, first off, here's a summary of my understanding of your needs. If these assumptions are wrong, let me know so I can revise the thoughts!</p>\n<p>Assumptions:</p>\n<ol>\n<li>You need to edit these files both as text files and through the Waterproof interface</li>\n<li>Your input areas are always editable code, rather than e.g. a sequence of rich text and code that's interleaved</li>\n<li>It's important to be able to interject explanatory text into the middle of code. A proof by cases might need to have substantial text along with each case.</li>\n<li>The borders between code and rich text are always aligned with a newline (there's no inline rich text in the middle of a single line of code, eg <code>let x := /-RICHTEXT-/ 5; x</code>).</li>\n<li>\"Good LSP support for the raw file format\" includes support for the non-Lean parts as well as the Lean parts, e.g. giving code actions, catching markup syntax errors with red squigglies, etc.</li>\n</ol>\n<p>Next, a key bit of info: Verso is really a collection of fairly reusable parts. It's a Lean library first and foremost, rather than a program you run. In particular, you can use the Verso markup language without using any of the other parts of it. The genre system is probably not relevant to you, as it's concerned with things like generating output, controlling user extensibility, and tracking cross-references within and between documents.</p>\n<p>One thing that's not a huge impact here, but would be good to know: should we think of a Waterproof document as being a sequence of interleaved snippets of code and rich text, or should we think of it as hierarchically organized, so that a bit of text in the middle of a proof is considered \"part of\" or \"subordinate to\" said proof? We suspected the former but confirmation would be good.</p>\n<p>All right, all that said: you should be able to use the Verso markup language to build the frontend you need, for interactive use. This isn't something you'll get out of the box, but we thought about the likely challenges:</p>\n<ol>\n<li>No \"proper\" literate programming support. We don't yet have a way to start the Lean parser out in Verso mode, which means that you'll have to use a hack of some kind to control the rendering of imports. If it's just a simple \"show/no show\" flag, then this won't be so bad; if you need something more, then it might require a bit of special-purpose comment processing.</li>\n<li>Processing Lean blocks independently won't work well. Right now, \"pausing\" the Lean parser at the end of a block and resuming in the next one is not so easy to do. Because a Lean proof is a single syntactic form, rather than a sequence of top-level commands, a solution must be found. Here's some ways to explore:</li>\n</ol>\n<ul>\n<li>Have a pre-processing step on the Verso syntax tree that produces \"plain\" Lean syntax, and use this with the language server. There's a few ways to do this, including replacing each character in the original file that's not part of Lean code with a <code>\" \"</code> or <code>\"  \"</code> (depending on weird UTF-16 specifics), causing the LSP source positions to still line up. If you don't have inline code with column positions to preserve, then you can just replace whole lines with blank lines and the whole thing is easier. You can do all this without generating extra files, but incrementality will be a bit of a challenge. The Verso LSP server extensions can be mostly reused here, I think - if not, we can generalize them.</li>\n<li>Write an LSP proxy for your frontend syntax that forwards the Lean commands on to the Lean language server. This could use the Verso parser. You can write this in Lean - we have a good library for writing LSP servers, after all ;-) This means that the student code is truly \"pristine Lean\", it gets rid of any challenges with import syntax not being extensible. I've never written such a thing, but it seems manageable, if substantial.</li>\n<li>Use magic comments to interleave into Lean. This seems to be a bad choice, but it's here for completeness. This would mean there were two ways of including text, and the LSP support in the comments would be bad.</li>\n<li>Use custom syntax to escape Lean to Markup, as <span class=\"user-mention\" data-user-id=\"385895\">@Jon Eugster</span> mentioned. I tried this pretty seriously for code examples in Verso, and it didn't work well in practice - I'm working towards eliminating the feature. The problem is that we'd need these custom syntax formers in many, many syntax categories, some of which aren't extensible, and they are hard to make look nice while reading the code. I really think some kind of approach outside Lean's syntax is best for what you're doing here.</li>\n</ul>\n<p>You probably can't get parsing to be resumable by serializing parser states to restart them on the next block. While most parser state is represented in <code>Parser.State</code>, there's also an implicit call stack that we don't have a good performant way to capture, which is relevant for things like <code>&lt;|&gt;</code>. Making the parser pauseable while still being fast would be a cool research project, but I suspect it's not one that you're interested in embarking on.</p>\n<p>So, in summary: it seems that using Verso's markup language is a fairly short path to getting something with good LSP support, because the Verso parser already does things like tracking source positions, and it already integrates into Lean. The rest of Verso is probably not relevant to you right now and can be ignored, but it'll be there waiting if you ever find a use for it (e.g. turning some Waterproof-based materials into a printed textbook, or automatically adding links to the reference manual). These pieces are fairly orthogonal and can be used on their own.</p>\n<p>A downside is that using Verso means your file is \"mostly Markdown\" rather than \"markdown\". If you need to process it with something else, parsing it outside Lean will be difficult. I can help you write an exporter, though.</p>\n<p>Happy to have a call about this sometime if that'd be easier, or to answer questions here.</p>",
        "id": 541628096,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1758880402
    },
    {
        "content": "<p>Thanks so much, this is very thorough and enlightening!</p>\n<p>About the assumptions:</p>\n<ol>\n<li>Correct</li>\n<li>Is effectively true right now, but the Rocq version does support the sequence. (To clarify, this means input areas for students, teachers can edit the whole document through our interface)</li>\n<li>The reason the splitting is an issue is because we have exercise sheets with partial proofs followed by an input area. That being said, the thing you are mentioning is something that is very nice to have, but not a blocker if we don't.</li>\n<li>Correct</li>\n<li>Correct</li>\n</ol>\n<p>On interleaved vs hierarchical:</p>\n<p>I think functionally most current exercise sheets fit the interleaved model. We translate the document to prosemirror, which does have a more hierarchical bend. My personal view is: interleaved code and text, with a hierachy for input areas and hints. These effectively give only one level though, we're not nesting these.</p>\n<p>Challenge 1: We've thought about this and we figured we need some sort of hack for this, but we also suspect it won't yield any fundamental issues.<br>\nChallenge 2: The pre-processing option seems the most promising to me. A couple of questions about this option:</p>\n<ol>\n<li>The whitespace is single-space and double-space? or is it something more esoteric? (I suspect we can do whole lines, but still wanted to check this)</li>\n<li>Do you have any pointers to code that might be useful as examples for this approach? (I have found <a href=\"https://github.com/leanprover/verso/blob/main/src/verso/Verso/Doc/Lsp.lean\">this</a> and <a href=\"https://github.com/leanprover/lean4/blob/49cff79712af7d9ecdda2bc7a786ca0ae00cf5c6/src/Lean/Server/Requests.lean#L556\">this</a>, but we might not even need to dig in so deep if the LSP extensions can be reused)</li>\n<li>What do you suspect are the consequences of incrementality being a challenge? Would this even be a challenge at the lemma level or just inside proofs?</li>\n</ol>",
        "id": 541685780,
        "sender_full_name": "Pim Otte",
        "timestamp": 1758897990
    },
    {
        "content": "<p>Also, am I right in assuming we could trade off some complexity by initially dropping Assumption 3, disallowing text in proofs, and doing input areas with magic comments? Then we could still use the verso parser to structure most of the document, but we don't have to do the LSP extension business.</p>",
        "id": 541689394,
        "sender_full_name": "Pim Otte",
        "timestamp": 1758898877
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"354934\">@David Thrane Christiansen</span> friendly tag to ensure you saw the messages above:)</p>",
        "id": 542672660,
        "sender_full_name": "Pim Otte",
        "timestamp": 1759390569
    },
    {
        "content": "<p>Thanks for the ping!</p>\n<p><span class=\"user-mention silent\" data-user-id=\"519269\">Pim Otte</span> <a href=\"#narrow/channel/187764-Lean-for-teaching/topic/Lean.20for.20Waterproof.20file.20format.20design/near/541685780\">said</a>:</p>\n<blockquote>\n<p>Challenge 2: The pre-processing option seems the most promising to me. A couple of questions about this option:</p>\n<ol>\n<li>The whitespace is single-space and double-space? or is it something more esoteric? (I suspect we can do whole lines, but still wanted to check this)</li>\n</ol>\n</blockquote>\n<p>It's just single vs double space, depending on whether the character being replaced takes one or two bytes in 16-bit Unicode. If all boundaries are on line boundaries, this may not even be necessary, and you can try just having the line numbers line up. That should be a quick experiment.</p>\n<blockquote>\n<ol start=\"2\">\n<li>Do you have any pointers to code that might be useful as examples for this approach? (I have found <a href=\"https://github.com/leanprover/verso/blob/main/src/verso/Verso/Doc/Lsp.lean\">this</a> and <a href=\"https://github.com/leanprover/lean4/blob/49cff79712af7d9ecdda2bc7a786ca0ae00cf5c6/src/Lean/Server/Requests.lean#L556\">this</a>, but we might not even need to dig in so deep if the LSP extensions can be reused)</li>\n</ol>\n</blockquote>\n<p>The former is an example of writing custom LSP handlers that hook in to the Lean LSP server. It may have some useful techniques, but it's not really what I was thinking of. The latter is part of Lean, which gives you good datatypes for the protocol.</p>\n<p>An LSP proxy would be a language server just for Waterproof that invoked the Lean language server as a subprocess. When it received Lean messages from either side, it'd forward them on. This would be a significant amount of work, and result in something flexible, but there's likely to be many corner cases.</p>\n<blockquote>\n<ol start=\"3\">\n<li>What do you suspect are the consequences of incrementality being a challenge? Would this even be a challenge at the lemma level or just inside proofs?</li>\n</ol>\n</blockquote>\n<p>Both. By \"incrementality\" I mean that Lean doesn't need to re-check a whole file in response to changes. It can \"rewind\" to a known-good state prior to the changes and respond much faster. Incrementality exists at the level of commands (lemmas, definitions, etc) and at the level of tactics within proofs. Without it, Lean is much less pleasant to use. The preprocessing version would need to take this seriously to give a good user experience. Delegating to Lean's own incrementality is doable, but constrains the design space; writing your own is possible but very challenging and I'm not sure we have the bandwidth to provide quite enough support on that.</p>",
        "id": 542677000,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1759392008
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"519269\">Pim Otte</span> <a href=\"#narrow/channel/187764-Lean-for-teaching/topic/Lean.20for.20Waterproof.20file.20format.20design/near/541689394\">said</a>:</p>\n<blockquote>\n<p>Also, am I right in assuming we could trade off some complexity by initially dropping Assumption 3, disallowing text in proofs, and doing input areas with magic comments? Then we could still use the verso parser to structure most of the document, but we don't have to do the LSP extension business.</p>\n</blockquote>\n<p>Yes, this would make it much simpler. If Lean commands don't span code blocks (that is, if it's more tree structured than interleaved segments) then much of the difficulty evaporates. Having an implementation to iterate on is always good, and if the restriction is relaxed, then it should be quick to write a Python script to migrate older documents.</p>",
        "id": 542677533,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1759392147
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"354934\">@David Thrane Christiansen</span> Thanks! Maybe to clarify, in my question 2 with \"This approach\" I meant the preprocessing idea, not the proxy.</p>",
        "id": 542679746,
        "sender_full_name": "Pim Otte",
        "timestamp": 1759392787
    },
    {
        "content": "<p>Oh, sorry!</p>\n<p>Here's an implementation of the string whitespace edits <a href=\"https://github.com/leanprover/verso/blob/e6f4ef92163a8a10f40924f2cfa8098d0c243759/src/verso/Verso/SyntaxUtils.lean#L132-L153\">in Verso</a>.</p>",
        "id": 542681273,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1759393220
    },
    {
        "content": "<p>I don't  have an implementation of the whole thing anywhere that I know of.</p>",
        "id": 542681426,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1759393261
    },
    {
        "content": "<p>I'm likely to get rid of that code soon now, because the Lean parser now supports stop positions prior to the actual EOF, so I'll be able to just parse Lean blocks directly instead parsing a \"shadow string\" like this</p>",
        "id": 542681711,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1759393334
    },
    {
        "content": "<p>I ended up coding up a hacky version of the <a href=\"https://github.com/pimotte/wp-lean-format-prototype/blob/834f1fae7be1c3f351ef51c4962d64d307081872/VersoProofFlow.lean#L139\">multilean directive</a>, and built two sample files: one with <a href=\"https://github.com/pimotte/wp-lean-format-prototype/blob/834f1fae7be1c3f351ef51c4962d64d307081872/VersoProofFlow/VerboseDemo.lean\">Verbose</a> and <a href=\"https://github.com/pimotte/wp-lean-format-prototype/blob/834f1fae7be1c3f351ef51c4962d64d307081872/VersoProofFlow/Demo.lean\">one more</a> to have some syntax examples.</p>",
        "id": 546924964,
        "sender_full_name": "Pim Otte",
        "timestamp": 1761319830
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"354934\">@David Thrane Christiansen</span> Thanks for the pointers, they helped a lot:)</p>\n<p>Unless I am mistaken, it is not possible to nest directives. Is this something you would consider in scope for Verso?</p>",
        "id": 546925445,
        "sender_full_name": "Pim Otte",
        "timestamp": 1761319971
    },
    {
        "content": "<p>They can absolutely be nested - just like you nest code blocks by using more backticks, you nest directives by using more colons. E.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">````</span>\n<span class=\"bp\">`</span><span class=\"ss\">``lean</span>\n<span class=\"n\">blah</span>\n<span class=\"bp\">```</span>\n<span class=\"bp\">````</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">::::</span><span class=\"n\">outer</span>\n<span class=\"n\">Text</span><span class=\"w\"> </span><span class=\"n\">text</span>\n<span class=\"bp\">::</span><span class=\"o\">:</span><span class=\"n\">inner</span>\n<span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">More</span><span class=\"w\"> </span><span class=\"n\">text</span>\n<span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"n\">yet</span><span class=\"w\"> </span><span class=\"n\">more</span>\n<span class=\"bp\">::</span><span class=\"o\">:</span>\n<span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">outer</span><span class=\"w\"> </span><span class=\"n\">directive</span><span class=\"w\"> </span><span class=\"n\">again</span>\n<span class=\"bp\">::::</span>\n</code></pre></div>",
        "id": 547189686,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1761541665
    },
    {
        "content": "<p>Ahh, great! I did try varying the number of colons, but I put more on the inside rather than the outside.</p>",
        "id": 547190234,
        "sender_full_name": "Pim Otte",
        "timestamp": 1761541993
    },
    {
        "content": "<p>That makes sense!</p>\n<p>I think we should relax the syntax a bit and just require a distinct number of colons for each matching pair, rather than a strict hierarchy. That would accept both variants, and be more convenient.</p>",
        "id": 547190372,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1761542078
    }
]