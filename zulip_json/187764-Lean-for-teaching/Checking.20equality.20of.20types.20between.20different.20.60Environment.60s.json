[
    {
        "content": "<p>I am writing a Gradescope autograder for Lean (the <a href=\"https://github.com/robertylewis/lean4-autograder-main\">existing one</a> wasn't quite suitable for my needs), but I'm struggling to figure out the best way to check whether the type of the submission is definitionally the exact same as that of the problem.<br>\nLooking over the existing solutions I've found, <a href=\"https://github.com/robertylewis/lean4-autograder-main\">robertylewis</a> merely compares the <code>ConstantInfo.type</code> <code>Expr</code>, which I believe enables cheating if the submission changes the definition of anything used in the type. For example, <code>theorem exercise1 : Foo := /- ... -/</code> would be said to have the same type under this check, regardless of whether <code>Foo := False</code> or <code>Foo := True</code>. I think this could be fixed by having definitions be placed in another file that is required to be imported by the submission, though this is not very ergonomic (I'd rather the relevant definitions be either built-in/from Mathlib, or in the same file).<br>\nThe other solution I've found is the one by <a href=\"https://github.com/adamtopaz/lean_grader\">adamtopaz</a>, where the type of the submission is ignored, and instead the value is re-evaluated in a clean <code>Environment</code>, whose type is then compared to the correct type. The issue I see with this one is that the submission would be unable to use anything not in the clean environment, including imports (though that could be fixed with just an <code>import Mathlib</code> in the clean environment) and custom auxiliary lemmas.<br>\nDoes anyone have any other ideas on how to solve this? I think the ideal solution would be to check for equality recursively, by confirming whether the two types have the same <code>Expr</code>, then checking whether anything referenced therein are also defined the same, so on and so forth, though I'm not sure how to do this.</p>",
        "id": 463709555,
        "sender_full_name": "Ricardo Prado Cunha",
        "timestamp": 1724162264
    },
    {
        "content": "<p>Some thoughts:</p>\n<ul>\n<li>I think when you get to the point of trying to control a provided environment, you have already lost. The work you will put in will exceed the value you extract. You have already entered a very long tail for those returns and a clever and determined enough adversary will always push you further. </li>\n<li>There have been improvements with <code>lake test</code> in the interim. For many languages, the natural entry point for auto-grading is the native testing framework.</li>\n</ul>",
        "id": 463719600,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1724164476
    },
    {
        "content": "<p>For reference, I have a class of 26 that works in groups of size 5-6. I am using the Batteries library test driver and some <code>guard_msg</code>s  with GitHub classroom. The class is an introduction to cryptography. I am more concerned about them being to implement things in Lean than prove correctness. So my tests are analogous to standard tests in other languages.</p>",
        "id": 463720669,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1724164812
    },
    {
        "content": "<p>Given the number of weekly submissions, I will be looking at the code of everyone and be able to notice changes to the test files.</p>",
        "id": 463720848,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1724164864
    },
    {
        "content": "<p>All that said: mathlib uses <a href=\"https://github.com/leanprover/lean4checker\">https://github.com/leanprover/lean4checker</a> as part of its CI</p>",
        "id": 463721516,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1724165060
    },
    {
        "content": "<p>There is a function <code>isDefEq</code> (at Meta level) that checks whether two types are definitionally equal. Could you simply use it?</p>",
        "id": 463935262,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1724214422
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266304\">Siddhartha Gadgil</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Checking.20equality.20of.20types.20between.20different.20.60Environment.60s/near/463935262\">said</a>:</p>\n<blockquote>\n<p>There is a function <code>isDefEq</code> (at Meta level) that checks whether two types are definitionally equal. Could you simply use it?</p>\n</blockquote>\n<p>Do you mean this one <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Meta/Basic.html#Lean.Meta.isDefEq\">https://leanprover-community.github.io/mathlib4_docs/Lean/Meta/Basic.html#Lean.Meta.isDefEq</a> ? I don't think it supports checking for equality across different environments.</p>",
        "id": 464084581,
        "sender_full_name": "Ricardo Prado Cunha",
        "timestamp": 1724252913
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Checking.20equality.20of.20types.20between.20different.20.60Environment.60s/near/463719600\">said</a>:</p>\n<blockquote>\n<p>I think when you get to the point of trying to control a provided environment, you have already lost. The work you will put in will exceed the value you extract. You have already entered a very long tail for those returns and a clever and determined enough adversary will always push you further. </p>\n</blockquote>\n<p>Yeah, that's fair. It's probably worth skimming through every submission, not just to check for cheating, but also to adapt teaching and provide feedback occasionally.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Checking.20equality.20of.20types.20between.20different.20.60Environment.60s/near/463721516\">said</a>:</p>\n<blockquote>\n<p>All that said: mathlib uses <a href=\"https://github.com/leanprover/lean4checker\">https://github.com/leanprover/lean4checker</a> as part of its CI</p>\n</blockquote>\n<p>Isn't this just to re-evaluate definitions in the original environment, rather than compare types across environments? Or am I misunderstanding it?</p>",
        "id": 464085538,
        "sender_full_name": "Ricardo Prado Cunha",
        "timestamp": 1724253141
    },
    {
        "content": "<p>This is in the \"sanitize an environment handed to me\" vein. If you are happy with the sanitization checks, then checking across environments can be avoided.</p>",
        "id": 464642081,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1724416959
    }
]