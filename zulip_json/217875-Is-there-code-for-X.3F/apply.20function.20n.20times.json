[
    {
        "content": "<p>Is there a function with the type <code>ℕ → (α → α) → α → α</code> that applied the second argument to the third the amount of times given? Also, why does Lean call the induction principle of a given type <code>rec</code>, e.g. <code>nat.rec</code>, I'd expect <code>rec</code> to refer to the given recursor. Does Lean generate the recursor, if so, under which name?</p>",
        "id": 203150033,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1594150692
    },
    {
        "content": "<p>There is, because I was told about it at Xena last Thursday. We ended up making an int one, which took an int and an equiv :-) I only half remember the name -- was it <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.iterate\">docs#nat.iterate</a> ?</p>",
        "id": 203150278,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594150843
    },
    {
        "content": "<p>Aah, it's function.swap applied to nat.iterate :-)</p>",
        "id": 203150320,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594150870
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 203150341,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1594150885
    },
    {
        "content": "<p>i think this is notation for <code>iterate</code></p>",
        "id": 203150359,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1594150894
    },
    {
        "content": "<p>Yes! There is also <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.repeat\">docs#nat.repeat</a>, which is also cool.</p>",
        "id": 203150373,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1594150902
    },
    {
        "content": "<p>I don't understand your question about <code>nat.rec</code> though. <code>nat.rec</code> is exactly what I thought computer scientists called the recursor for nat. Because <code>Prop = Sort 0</code>, the recursor can also be used as the induction principle.</p>",
        "id": 203150497,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594150957
    },
    {
        "content": "<p>It's interesting that <code>nat.iterate</code> has that argument order.  If it were <span class=\"user-mention\" data-user-id=\"298376\">@Pedro Minicz</span>'s, then it would be the map from Lean's naturals to Church-encoded naturals.</p>",
        "id": 203150558,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1594150998
    },
    {
        "content": "<p>A distinction between the recursor and the induction principle is usually made (at least where I've read), Coq and HoTT book do that distinction at least.</p>",
        "id": 203150601,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1594151023
    },
    {
        "content": "<p>But I think they have more elaborate set-ups with Prop.</p>",
        "id": 203150665,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594151045
    },
    {
        "content": "<p>In book HoTT the recursor is the non-dependent version of the induction principle (and the induction principle is what Lean calls <code>rec</code>).</p>",
        "id": 203150699,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1594151066
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"n\">C</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"n\">n</span>\n</code></pre></div>\n\n\n<p>I was taught as a mathematician that one defines things by recursion and proves them by induction. Induction is inherently dependent. <code>Sort u</code> is precisely Lean's way of saying \"Type or Prop, I don't care\".</p>",
        "id": 203150821,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594151143
    },
    {
        "content": "<p>I believe Coq's Prop is about the same as Lean's. In book HoTT there is no impredicative universe, so the distinction between the induction principle and the recursor does not necessarily have to do with <code>Sort</code>.</p>",
        "id": 203150845,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1594151158
    },
    {
        "content": "<p>I'd expect Lean to generate a recursor of with the type <code>ℕ → α → (α → α) → α</code> for <code>nat</code>.</p>",
        "id": 203151037,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1594151247
    },
    {
        "content": "<p>Which, of course, is just an specialization of <code>nat.rec</code>.</p>",
        "id": 203151065,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1594151262
    },
    {
        "content": "<p>Just checked, I was mistaken, Coq does not make such distinction. I guess book HoTT just left an impression on me.</p>",
        "id": 203151285,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1594151360
    },
    {
        "content": "<p>It seems to me that <code>nat.rec</code> is one function which covers everything. It would not surprise me at all if there were specialised versions which cover more specialised use cases.</p>",
        "id": 203151333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594151381
    },
    {
        "content": "<p>I think that when one makes a new inductive type, Lean generates a constant for the type, a constant for each constructor, and then a constant for the recursor (aka the eliminator). An algorithm then generates a bunch of helper functions, but each of these have definitions which depend on these undefined constants.</p>",
        "id": 203194462,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594151452
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">inductive</span> <span class=\"n\">mynat</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span> <span class=\"bp\">→</span> <span class=\"n\">mynat</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"kn\">prefix</span> <span class=\"n\">mynat</span> <span class=\"c1\">-- about 20 things</span>\n\n<span class=\"c1\">-- these have no definitions</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">mynat</span>\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">mynat</span><span class=\"bp\">.</span><span class=\"n\">zero</span>\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">mynat</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">mynat</span><span class=\"bp\">.</span><span class=\"n\">rec</span>\n\n<span class=\"c1\">-- everything else has a definition</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">mynat</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span>\n</code></pre></div>\n\n\n<p>All you need is <code>mynat.rec</code> and then you can make anything else you need by yourself.</p>",
        "id": 203194732,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594151604
    },
    {
        "content": "<p>Indeed. Coq defines a few recursors because of its universes. I mistook the distinction that book HoTT makes for it.</p>",
        "id": 203198433,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1594153530
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"298376\">Pedro Minicz</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Apply.20function.20N.20times/near/203151065\">said</a>:</p>\n<blockquote>\n<p>Which, of course, is just an specialization of <code>nat.rec</code>.</p>\n</blockquote>\n<p>Working through this to understand it better, it looks like you get <code>nat.repeat</code> with reordered arguments.  That's interesting.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">repeat&#39;</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 203198742,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1594153699
    },
    {
        "content": "<p>Indeed. If you want to go deeper into lambda calculus you can also compare it to Church encoded natural numbers.</p>",
        "id": 203201048,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1594155006
    },
    {
        "content": "<p>What is described as the \"recursor\" on book HoTT is I believe always (almost) equivalent to the Church encoded version of the type.</p>",
        "id": 203201155,
        "sender_full_name": "Pedro Minicz",
        "timestamp": 1594155064
    },
    {
        "content": "<p>Is there a tactic that can take an n : ℕ, f : α → β, and x : α and produce f (f ... (f x)...), where f appears n times.</p>",
        "id": 272552879,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645316770
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 272552894,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645316801
    },
    {
        "content": "<p>There's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.iterate\">docs#nat.iterate</a> (assuming you mean <code>f : α → α</code>) -- why do you need a tactic?</p>",
        "id": 272553029,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645316977
    },
    {
        "content": "<p>I can't use iterate because f is polymorphic and each application of f produce different types.</p>",
        "id": 272553115,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645317055
    },
    {
        "content": "<p>For example, suppose <code>f</code> is <code>functor.map</code>.</p>",
        "id": 272553147,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645317092
    },
    {
        "content": "<p>If the codomain and domain of <code>f</code> are different then I can make no sense of your question. What do the <code>...</code> mean in your first post?</p>",
        "id": 272553570,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645317596
    },
    {
        "content": "<p>How do you know that the <code>n + 1</code>-th application will be polymorphic enough to accept the <code>n</code>-th output?</p>",
        "id": 272553654,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645317681
    },
    {
        "content": "<p>A more concrete example: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">nat</span><span class=\"o\">))</span>\n<span class=\"kd\">constant</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">string</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ex</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">string</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">list.map</span> <span class=\"o\">(</span><span class=\"n\">list.map</span> <span class=\"o\">(</span><span class=\"n\">list.map</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"n\">xs</span>\n</code></pre></div>",
        "id": 272554201,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645318255
    },
    {
        "content": "<p>I want a tactic where I can write something like <code>(iterate 3 list.map f) xs</code></p>",
        "id": 272554226,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645318300
    },
    {
        "content": "<p><code>iterate 3 { apply list.map f }, exact xs</code>?</p>",
        "id": 272554332,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645318430
    },
    {
        "content": "<p>What is<code>iterate</code> in that line of code?</p>",
        "id": 272554528,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645318634
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.interactive.iterate\">docs#tactic.interactive.iterate</a></p>",
        "id": 272554547,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645318663
    },
    {
        "content": "<p>Ah, OK. I tried</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ex</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">string</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n   <span class=\"n\">iterate</span> <span class=\"mi\">3</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">list.map</span> <span class=\"n\">f</span> <span class=\"o\">},</span> <span class=\"n\">exact</span> <span class=\"n\">xs</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>but it complains about <code>apply</code>.</p>",
        "id": 272554756,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645318854
    },
    {
        "content": "<p>actually you aren't applying directly to the goal in that example so you have to modify it a bit</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ex</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">string</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">revert</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">iterate</span> <span class=\"mi\">3</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">list.map</span> <span class=\"o\">},</span> <span class=\"n\">exact</span> <span class=\"n\">f</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 272555661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645319963
    },
    {
        "content": "<p>Nice. I tried the following, but it does not work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">ex</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat.iterate</span> <span class=\"n\">list</span> <span class=\"n\">n</span> <span class=\"n\">string</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">revert</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">iterate</span> <span class=\"n\">n</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">list.map</span> <span class=\"o\">},</span> <span class=\"n\">exact</span> <span class=\"n\">f</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 272583789,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645354302
    },
    {
        "content": "<p>what's the type of <code>xs</code> here?</p>",
        "id": 272583896,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645354415
    },
    {
        "content": "<p>Oops. I forgot to change that one.</p>",
        "id": 272583906,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645354431
    },
    {
        "content": "<p>the way you're mixing the levels doesn't make sense here, you should just be able to use induction on n though</p>",
        "id": 272583911,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645354434
    },
    {
        "content": "<p>Let me try again.</p>",
        "id": 272583915,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645354437
    },
    {
        "content": "<p>I feel like the answers involving the <code>iterate</code> tactic were possibly misleading, but then, it's also quite unclear what you want to do or why</p>",
        "id": 272584011,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645354547
    },
    {
        "content": "<p>Here you go:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ex</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">nat.iterate</span> <span class=\"n\">list</span> <span class=\"n\">n</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat.iterate</span> <span class=\"n\">list</span> <span class=\"n\">n</span> <span class=\"n\">string</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">revert</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">iterate</span> <span class=\"n\">n</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">list.map</span> <span class=\"o\">},</span> <span class=\"n\">exact</span> <span class=\"n\">f</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 272584091,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645354617
    },
    {
        "content": "<p>I guess you should move all arguments (except optionally <code>f</code>) to the right of the colon and use recursion</p>",
        "id": 272584178,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645354713
    },
    {
        "content": "<p>That's a good idea actually. But why does it not work with the <code>iterate</code> tactic. Does that tactic only work with hard-code <code>n</code>?</p>",
        "id": 272584323,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645354823
    },
    {
        "content": "<p>Right, it just doesn't make sense</p>",
        "id": 272584355,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645354844
    },
    {
        "content": "<p><code>iterate</code> needs to know how many times to run the body, that number cannot be an internal variable</p>",
        "id": 272584364,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645354859
    },
    {
        "content": "<p>Bummer... Oh well.</p>",
        "id": 272584383,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645354885
    },
    {
        "content": "<p>There is a phase distinction here</p>",
        "id": 272584397,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645354901
    },
    {
        "content": "<p>What do you mean by \"phase\"?</p>",
        "id": 272584504,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645355015
    },
    {
        "content": "<p>e.g. compile-time vs run-time</p>",
        "id": 272584576,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645355072
    },
    {
        "content": "<p>The tactic runs before the function itself (notionally) runs. So <code>n</code> doesn't refer to anything when the tactic executes, it's literally just the letter \"n\".</p>",
        "id": 272584599,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645355105
    },
    {
        "content": "<p>It's like C macros, you cannot have a program expand a macro <code>n</code> times where <code>n</code> is a number the program read from stdin, because the macro expansion already had to be finished long ago</p>",
        "id": 272584720,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645355227
    },
    {
        "content": "<p>In Lean it would make even less sense because the tactic block could be constructing a proof, and proofs don't even run at all.</p>",
        "id": 272584843,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645355371
    },
    {
        "content": "<p>Yes, that makes sense. For some reason, I thought I could get away with doing this sort of thing in Lean. I have come across this limitation with other macro systems. I guess this is a fundametal issue with macros in general.</p>",
        "id": 272584920,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645355408
    },
    {
        "content": "<p>So, I trying this, but I'm getting errors that I don't know how to fix:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ex</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">string</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">([])</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">list.cons</span> <span class=\"n\">m</span> <span class=\"n\">ms</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 272585299,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645355878
    },
    {
        "content": "<p>Hmm, I think <code>nat.iterate</code> is defined inconveniently for this purpose</p>",
        "id": 272585627,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645356210
    },
    {
        "content": "<p>You would prefer to have <code>list^[n+1] nat = list (list^[n] nat)</code></p>",
        "id": 272585639,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645356234
    },
    {
        "content": "<p>OK. Let me define my own <code>nat.iterate</code> then and see if that helps.</p>",
        "id": 272585757,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645356334
    },
    {
        "content": "<p>Maybe you can also work with this definition by also generalizing over the types <code>nat</code> and <code>string</code> and the function <code>f</code>, and writing something like <code>| (n + 1) f xs := ex n (list.map f) xs</code></p>",
        "id": 272585823,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645356366
    },
    {
        "content": "<p>I feel like one of these is less efficient than the other, but I'm not sure which or whether that matters to you.</p>",
        "id": 272585936,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645356483
    },
    {
        "content": "<p>Progress!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">iter</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">iter</span> <span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ex</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">iter</span> <span class=\"n\">list</span> <span class=\"n\">n</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">iter</span> <span class=\"n\">list</span> <span class=\"n\">n</span> <span class=\"n\">string</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">::</span> <span class=\"n\">ms</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ex</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">::</span> <span class=\"n\">list.map</span> <span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ms</span>\n</code></pre></div>",
        "id": 272586624,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645357232
    },
    {
        "content": "<p>You should be able to use <code>list.map</code> in the <code>(n + 1)</code> case without doing a case split on the list as well.</p>",
        "id": 272586738,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645357352
    },
    {
        "content": "<p>Good catch. Thanks a lot.</p>",
        "id": 272586885,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645357558
    },
    {
        "content": "<p>If I have a proof of <code>list^[n+1] nat = list (list^[n] nat)</code>, could I use that with the <code>nat.iterate</code> version somehow?</p>",
        "id": 272586970,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645357619
    },
    {
        "content": "<p>So I tried to generalize the <code>ex</code> example, but it doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">iter</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">iter</span> <span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">map</span> <span class=\"o\">[</span><span class=\"n\">functor</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">iter</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">iter</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">m</span> <span class=\"n\">val</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">functor.map</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">val</span>\n</code></pre></div>",
        "id": 272607292,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645380444
    },
    {
        "content": "<p>It's probably not obvious to Lean what functor you want to <code>map</code> until you unfold <code>iter</code></p>",
        "id": 272607413,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645380597
    },
    {
        "content": "<p>Yes. Should I pass the <code>functor f</code> instance to <code>functor.map</code>?</p>",
        "id": 272607490,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645380667
    },
    {
        "content": "<p>Yeah, that works.</p>",
        "id": 272607511,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1645380709
    }
]