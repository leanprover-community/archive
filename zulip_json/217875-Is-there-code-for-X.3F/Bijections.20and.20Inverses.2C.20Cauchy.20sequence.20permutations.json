[
    {
        "content": "<p>I would like code for this lemma and decided to check if someone already did something similar (and probably more general)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- order of inverse does not matter when canceling to the identity function -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">inv_order_not_matter</span>\n      <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">perm_inv</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_inv</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">perm_inv</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n      <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">perm_inv</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 271641597,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1644615578
    },
    {
        "content": "<p>This lemma is wrong. Take <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.pred\">docs#nat.pred</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.succ\">docs#nat.succ</a></p>",
        "id": 271641780,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644615703
    },
    {
        "content": "<p>You need <code>perm_inv</code> to be injective.</p>",
        "id": 271641844,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1644615725
    },
    {
        "content": "<p>Okay, so what is the proper way to declare a bijection on \\N and the inverse function?</p>",
        "id": 271641931,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1644615786
    },
    {
        "content": "<p>Have a look at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv\">docs#equiv</a></p>",
        "id": 271641967,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644615807
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> you mean surjective</p>",
        "id": 271642112,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644615884
    },
    {
        "content": "<p><code>perm</code> surjective</p>",
        "id": 271642150,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1644615905
    },
    {
        "content": "<p>The reason I want a bijection on \\N is so I can attempt to show that every reordering of a Cauchy sequence is another Cauchy sequence with the same limit.</p>",
        "id": 271642286,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1644615970
    },
    {
        "content": "<p>No but <code>perm</code> being injective is definitely enough.</p>",
        "id": 271642360,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1644616017
    },
    {
        "content": "<p>Argh, confused</p>",
        "id": 271642397,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1644616040
    },
    {
        "content": "<p>You should prove that for a permutation of natural numbers, <code>map f at_top = at_top</code>.</p>",
        "id": 271643406,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644616593
    },
    {
        "content": "<p>This follows from the fact that any injective map tends to infinity</p>",
        "id": 271643596,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644616686
    },
    {
        "content": "<p>And I would prove that for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.cofinite\">docs#filter.cofinite</a> and any pair of types</p>",
        "id": 271644522,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644617139
    },
    {
        "content": "<p>Is this properly stated?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- rearranging a Cauchy sequence results in a sequence that is also Cauchy with the same limit -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">rearranging_cauchy_also_cauchy</span>\n      <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">perm_inv</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">h_inv_0</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">perm_inv</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"n\">h_inv_1</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">perm_inv</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"n\">cs</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_cs_cauchy</span> <span class=\"o\">:</span> <span class=\"n\">is_cau_seq</span> <span class=\"n\">abs</span> <span class=\"n\">cs</span><span class=\"o\">)</span>\n      <span class=\"o\">:</span> <span class=\"n\">is_cau_seq</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"n\">‚Ñï</span><span class=\"o\">),</span> <span class=\"n\">cs</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>I actually wanted cs to be a complex-valued Cauchy sequence, but I don't know how to do that with mathlib.</p>",
        "id": 271646803,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1644618302
    },
    {
        "content": "<p>Why not use <code>perm ‚Ñï</code> (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.perm\">docs#equiv.perm</a>)?</p>",
        "id": 271647323,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644618615
    },
    {
        "content": "<p>Because I am a newb who did not know.</p>",
        "id": 271647413,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1644618684
    },
    {
        "content": "<p>Note that's juts another spelling for the <code>equiv</code> that Yury mentioned above</p>",
        "id": 271647499,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644618732
    },
    {
        "content": "<p>I just figured out Complex-valued Cauchy sequences.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- rearranging a Cauchy sequence results in a sequence that is also Cauchy with the same limit -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">rearranging_cauchy_also_cauchy</span>\n      <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">perm_inv</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">h_inv_0</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">perm_inv</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"n\">h_inv_1</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">perm_inv</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"n\">cs</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_cs_cauchy</span> <span class=\"o\">:</span> <span class=\"n\">is_cau_seq</span> <span class=\"n\">complex.abs</span> <span class=\"n\">cs</span><span class=\"o\">)</span>\n      <span class=\"o\">:</span> <span class=\"n\">is_cau_seq</span> <span class=\"n\">complex.abs</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"n\">‚Ñï</span><span class=\"o\">),</span> <span class=\"n\">cs</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 271648215,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1644619264
    },
    {
        "content": "<p>And have yet to figure out how to use equiv.perm.</p>",
        "id": 271648317,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1644619334
    },
    {
        "content": "<p>Is this correct?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- rearranging a Cauchy sequence results in a sequence that is also Cauchy with the same limit -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">rearranging_cauchy_also_cauchy</span>\n      <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">cs</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_cs_cauchy</span> <span class=\"o\">:</span> <span class=\"n\">is_cau_seq</span> <span class=\"n\">complex.abs</span> <span class=\"n\">cs</span><span class=\"o\">)</span>\n      <span class=\"o\">:</span> <span class=\"n\">is_cau_seq</span> <span class=\"n\">complex.abs</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"n\">‚Ñï</span><span class=\"o\">),</span> <span class=\"n\">cs</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 271648597,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1644619535
    },
    {
        "content": "<p>That looks like it might be wrong or right.</p>",
        "id": 271648679,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1644619585
    },
    {
        "content": "<p><code>is_cau_seq</code> is an \"implementation detail\", you should use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cauchy_seq\">docs#cauchy_seq</a> which has more lemmas.</p>",
        "id": 271649022,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1644619841
    },
    {
        "content": "<p>Here is the statement:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">cauchy_seq.comp_injective</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">cauchy_seq</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñï</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cauchy_seq</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">‚àò</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 271653333,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644622648
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>And the proof is</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>open function filter\n\nlemma function.injective.tendsto_at_top {f : ‚Ñï ‚Üí ‚Ñï} (hf : injective f) :\n  tendsto f at_top at_top :=\nby simpa only [‚Üê nat.cofinite_eq_at_top] using hf.tendsto_cofinite\n\nlemma cauchy_seq.comp_injective {Œ± : Type*} [uniform_space Œ±] {u : ‚Ñï ‚Üí Œ±} (hu : cauchy_seq u)\n  {f : ‚Ñï ‚Üí ‚Ñï} (hf : injective f) : cauchy_seq (u ‚àò f) :=\nhu.comp_tendsto hf.tendsto_at_top\n</code></pre></div>\n</div></div>",
        "id": 271653430,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644622705
    },
    {
        "content": "<p>This is not in mathlib yet then? <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> Would you be willing to submit your proof to mathlib? I am unable to make a better proof for the statement cauchy_seq.comp_injective.</p>",
        "id": 271655884,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1644624586
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/11986\">#11986</a></p>",
        "id": 271656948,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644625632
    },
    {
        "content": "<p>It might be good to include proof that the limit is unchanged by the permutation. I have a 'proof' in this PDF <a href=\"https://drive.google.com/file/d/1o0FP9prFpbGa6b7zvcOJeb37NldaNg-x/view?usp=sharing\">https://drive.google.com/file/d/1o0FP9prFpbGa6b7zvcOJeb37NldaNg-x/view?usp=sharing</a> , but do not know if LEAN will accept it.</p>",
        "id": 271657272,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1644625927
    },
    {
        "content": "<p>I'm looking at cau_seq.lim right now, trying to figure out how to state that the limits of the 2 Cauchy Sequences are equal.</p>",
        "id": 271657987,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1644626671
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.tendsto.comp\">docs#filter.tendsto.comp</a></p>",
        "id": 271659623,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644628240
    },
    {
        "content": "<p>So you have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">tendsto</span> <span class=\"n\">u</span> <span class=\"n\">at_top</span> <span class=\"o\">(</span><span class=\"bp\">ùìù</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñï</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tendsto</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">‚àò</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">at_top</span> <span class=\"o\">(</span><span class=\"bp\">ùìù</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">hu.comp</span> <span class=\"n\">hf.tendsto_at_top</span>\n</code></pre></div>",
        "id": 271659746,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644628354
    },
    {
        "content": "<p>I don't think that we should add this as a separate lemma.</p>",
        "id": 271659778,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644628403
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"385848\">@Mark Gerads</span> what's going on here is that the lemma you're proving is just the sort of thing which we see in undergraduate analysis textbooks, but in fact it's an easy consequence of a far more general lemma about filters on uniform spaces and mathlib is focused on proving things in this kind of large generality. Mathlib is not designed for pedagogy, it is like Bourbaki, striving for maximal generality rather than concrete examples such as your application</p>",
        "id": 271681227,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644660283
    },
    {
        "content": "<p>The very fact that you want to state the lemma for both real and complex sequences is exactly the reason we state it for neither. Next week someone will want it for sequences of p-adic numbers, the week after someone will want it for ‚Ñù^3 etc</p>",
        "id": 271681316,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644660470
    },
    {
        "content": "<p>Oh, I definitely support having every proof as general as possible. I am glad that [a much more general proof than what I had in mind] was submitted to mathlib.</p>",
        "id": 271709261,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1644699331
    }
]