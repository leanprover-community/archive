[
    {
        "content": "<p>I see we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Given subgroups H, K of groups G, N respectively, H × K as a subgroup of G × N. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">subgroup.prod</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but I don’t see corresponding notions for subgroups of pi groups (i.e. infinite products). Are they missing so far?</p>",
        "id": 270553364,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643896924
    },
    {
        "content": "<p>It would be called <code>subgroup.pi</code>, so I guess we don't!</p>",
        "id": 270553996,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643897226
    },
    {
        "content": "<p>Ok, on it.</p>",
        "id": 270554411,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643897423
    },
    {
        "content": "<p>Why is some groupy theory stuff under <code>algebra</code>(e.g. <code>algebra.group.pi</code>) and others under <code>group_theory</code>? How to decide what goes where?</p>",
        "id": 270558312,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643899068
    },
    {
        "content": "<p>It depends on whether you see <code>group</code> as an algebraic structure belonging in the algebraic hierarchy, or as an object of study of its own. The separation is quite empirical.</p>",
        "id": 270558583,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643899165
    },
    {
        "content": "<p>Before I go on proving the necessary lemmas (like those that we have for <code>subgroup.prod</code>), how is this for the definition?<br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/11801/files\">https://github.com/leanprover-community/mathlib/pull/11801/files</a></p>",
        "id": 270559963,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643899577
    },
    {
        "content": "<p>You can simplify the def of <code>carrier</code> to <code>{f | ∀ i, f i ∈ s i}</code> but I'm not sure it's terribly useful.</p>",
        "id": 270564841,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643901425
    },
    {
        "content": "<p>It would make these silly <code>trivial</code> arguments go away, and some of the lemmas would become <code>refl</code> that otherwise aren’t. But it would mean not using <code>set.pi</code>. But maybe it’s nicer indeed.</p>",
        "id": 270571024,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643903703
    },
    {
        "content": "<p>Another option is to copy API of <code>set.pi</code> and take an argument <code>I : set η</code></p>",
        "id": 270572257,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1643904097
    },
    {
        "content": "<p>Hmm, not sure how useful that’s is. <code>\\Pi</code> doesn’t have an <code>I</code>, so why expect it for subgroups. We can generalize later if needed?</p>",
        "id": 270572720,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643904253
    },
    {
        "content": "<p>I don't know if it's useful either. Depends on how often you want to restrict only some coordinates.</p>",
        "id": 270575150,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1643905192
    },
    {
        "content": "<p>If you don't go this way, then you should drop <code>set.pi</code> and do what <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> suggested.</p>",
        "id": 270575260,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1643905223
    },
    {
        "content": "<p>Agreed with everything Yury said.</p>",
        "id": 270575335,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643905262
    },
    {
        "content": "<p>Do we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.pi\">docs#submodule.pi</a>?</p>",
        "id": 270576841,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1643905842
    },
    {
        "content": "<p>Yes, we do - so the subgroup API should match</p>",
        "id": 270576931,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1643905877
    },
    {
        "content": "<p>Hmm, ok, fair point. Will adjust.</p>",
        "id": 270579986,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643907031
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> has marked this topic as resolved.</p>",
        "id": 270686778,
        "sender_full_name": "Notification Bot",
        "timestamp": 1643966004
    },
    {
        "content": "<p>Hmm, with this API it we have <code>pi ∅ H = ⊤</code> which is quite confusing and often not what I want. And trying to generalize</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⁅</span><span class=\"n\">H₁.prod</span> <span class=\"n\">H₂</span><span class=\"o\">,</span> <span class=\"n\">K₁.prod</span> <span class=\"n\">K₂</span><span class=\"bp\">⁆</span> <span class=\"bp\">=</span> <span class=\"bp\">⁅</span><span class=\"n\">H₁</span><span class=\"o\">,</span> <span class=\"n\">K₁</span><span class=\"bp\">⁆.</span><span class=\"n\">prod</span> <span class=\"bp\">⁅</span><span class=\"n\">H₂</span><span class=\"o\">,</span> <span class=\"n\">K₂</span><span class=\"bp\">⁆</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">⁅</span><span class=\"n\">subgroup.pi</span> <span class=\"n\">I</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">subgroup.pi</span> <span class=\"n\">I</span> <span class=\"n\">K</span><span class=\"bp\">⁆</span> <span class=\"bp\">=</span> <span class=\"n\">subgroup.pi</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">⁅</span><span class=\"n\">H</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">K</span> <span class=\"n\">i</span><span class=\"bp\">⁆</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>turns out to be much more involved than it sounded. It seems it only holds for finite families (because in the infinite case, <code>subgroup.pi</code> is _not_ generated by the embedding of the subgroups). And even if I restrict to finite types it seems harder than it should be… but right now I have no better idea than to push through with force.</p>",
        "id": 270716317,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643982361
    },
    {
        "content": "<p>Why is <code>pi ∅ H = ⊤</code> confusing? The smaller the set, the bigger the pi subgroup.</p>",
        "id": 270716458,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643982429
    },
    {
        "content": "<p>Hmm, I have a hard time putting my finger on it.  Maybe because I’d expect induction on <code>I</code> grow the set, rather than shrink it? <br>\nAnyways, I think I have been able to do the proof that I needed (for <code>I = univ</code> and <code>fintype</code> only, though)</p>",
        "id": 270720613,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643984275
    },
    {
        "content": "<p>Hmmm, we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.pi_mono\">docs#submodule.pi_mono</a>, but not the one with the other argument.</p>",
        "id": 270720810,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643984368
    },
    {
        "content": "<p>When a dimension is not included in <code>s</code>, <code>whatever.pi</code> takes everything in that direction. <code>s</code> is a set of constraints, if that makes sense?</p>",
        "id": 270721051,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643984471
    },
    {
        "content": "<p>Yes, it  makes sense as a generalization of <code>set.pi</code>. It just wasn’t very useful in my work so far.</p>",
        "id": 270721416,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643984639
    },
    {
        "content": "<p>In the end I got this: <a href=\"https://github.com/leanprover-community/mathlib/pull/11825/files\">https://github.com/leanprover-community/mathlib/pull/11825/files</a><br>\nI had to define <code>pi.single1</code> as a variant of <code>pi.single</code> that defaults to <code>1</code>  (not <code>0</code>). I should probably break that out into a separate PR. What would be a good name for it?</p>",
        "id": 270721529,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643984682
    },
    {
        "content": "<p>What seems reasonable to me is to rename <code>pi.single</code> to <code>pi.add_single</code> and <code>pi.single1</code> to <code>pi.single</code>, or to just rename <code>pi.single1</code> to <code>pi.mul_single</code>.</p>",
        "id": 270721744,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643984780
    },
    {
        "content": "<p>Either way, you shouldn't have to write an entire new API. Instead, you should refactor the existing API to talk about multiplicative stuff and add <code>@[to_additive]</code> on all declarations to automatically generate the additive version.</p>",
        "id": 270721847,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643984842
    },
    {
        "content": "<p>Fair point, I’ll tackle that later – today I’ll continue piling unpolished PRs on top of each other to finally close the finite nilpotent equivalence loop :-)</p>",
        "id": 270722505,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643985200
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/.E2.9C.94.20pi.20subgroups/near/270721744\">said</a>:</p>\n<blockquote>\n<p>What seems reasonable to me is to rename <code>pi.single</code> to <code>pi.add_single</code></p>\n</blockquote>\n<p>hmm, not sure that would be a great name. There isn't anything additive about <code>pi.single</code> per se, and it actually is used with multiplication as well, e.g. in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">pi.single_mul</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">mul_zero_class</span> <span class=\"bp\">$</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">single</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">single</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">single</span> <span class=\"n\">i</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>So <code>zero_single</code> or <code>one_single</code>? But that's verbose. Maybe subscript <code>0</code> and subscript <code>1</code>?</p>\n<p>Naming is hard :-)</p>",
        "id": 270822520,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1644062081
    },
    {
        "content": "<p>The point is that it would follow the parallelization of the multiplicative and additive stories. And <code>0</code> is the additive version of <code>1</code>!</p>",
        "id": 270822619,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644062223
    },
    {
        "content": "<p>So you wouldn’t be bothered if that lemma would now read</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">pi.add_single_mul</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">mul_zero_class</span> <span class=\"bp\">$</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">add_single</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">add_single</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">add_single</span> <span class=\"n\">i</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 270822691,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1644062303
    },
    {
        "content": "<p>Eh, no I guess</p>",
        "id": 270823856,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644063785
    },
    {
        "content": "<p>Ok, on it then :-)</p>",
        "id": 270826687,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1644067464
    },
    {
        "content": "<p>I think <code>single</code> and <code>mul_single</code> would be better</p>",
        "id": 270826917,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644067793
    },
    {
        "content": "<p>Unless we also want to rename <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.support\">docs#function.support</a> to add_support</p>",
        "id": 270826963,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644067814
    },
    {
        "content": "<p><code>single₀</code> and <code>single₁</code> would be another option</p>",
        "id": 270826981,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644067849
    },
    {
        "content": "<p>I'd encourage you to make a poll in <a class=\"stream\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general\">#general</a>  before actually doing any work</p>",
        "id": 270827064,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644067926
    },
    {
        "content": "<p>Ok, some preliminary work in <a href=\"https://github.com/leanprover-community/mathlib/pull/11849/files\">https://github.com/leanprover-community/mathlib/pull/11849/files</a> but I can rename based on the poll, and will better wait for the poll to conclude before updating all affected theories.</p>",
        "id": 270827458,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1644068539
    },
    {
        "content": "<p>Poll at <a href=\"#narrow/stream/113488-general/topic/quo.20vadis.20.60pi.2Esingle.60/near/270827818\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/quo.20vadis.20.60pi.2Esingle.60/near/270827818</a></p>",
        "id": 270827875,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1644068899
    }
]