[
    {
        "content": "<p>Assuming the derived categories PR is fully merged, how far off would defining the derived hom and tensor product be? I guess the biggest roadblock would be making sense of K-projective (cofibrant in projective model structure) and K-injective (fibrant in injective model structure) resolutions? I'd be happy to work on this but I want to make sure no one else has a plan in mind already (and I'm not sure what the right design decision is if we want to handle the noncommutative and commutative cases on equal footing. Should we end up with two different \"RHom\"s over a commutative ring, one a chain complex of modules and one a chain complex of abelian groups?)</p>",
        "id": 435900138,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1714329382
    },
    {
        "content": "<p>Maybe I should first ask about the underived hom and tensor of complexes? (for some reason I thought we had these)</p>",
        "id": 435901002,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1714330275
    },
    {
        "content": "<p>I already have working code for the total right derived functor on the bounded below derived category <code>K^+</code> when we have enough injectives. (I have obtained the Grothendieck spectral sequence for the composition of these.) The technical part was to obtain the CM5 factorization axiom for the model category structure on <code>C^+</code>.</p>",
        "id": 435902531,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1714331758
    },
    {
        "content": "<p>My plan for derived functors of several variables is to start with the tensor product. I should obtain very soon the \"flat derivability structure\": roughly speaking (the API will be more general), the inclusion <code>K^-(ModuleCatFlat R) ‚•§ K^-(ModuleCat R)</code> induces an equivalence on the localized categories with respect to quasi-isomorphisms. Using that, we may define derived functors of functors which preserves quasi-isos between bounded above complexes of flat objects. (I have already obtained some technical lemmas, like if <code>f</code> is a morphisms of bicomplexes (with some bounds) such that <code>f</code> induces a quasi-iso on each column, then the induced map on the total complexes is a quasi-iso.)</p>",
        "id": 435902573,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1714331766
    },
    {
        "content": "<p>Then, the plan is to obtain the monoidal category structure on the bounded above derived category of modules, and obtain a symmetric <code>Tor</code> bifunctor with long exact sequences on both variables, which would allow the development of local algebra (Koszul complexes, etc.).</p>",
        "id": 435902576,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1714331771
    },
    {
        "content": "<p>The API for derived functors in two variables that I am thinking of should be good enough to handle both the case of the derived tensor of a functor that is covariant in both variables (like the tensor product), but also <code>Hom</code>, etc.</p>",
        "id": 435902578,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1714331776
    },
    {
        "content": "<p>I have already done some PRs for the extension of functors to bicomplexes <a href=\"https://github.com/leanprover-community/mathlib4/pull/10880\">#10880</a>, compatibilities with shifts <a href=\"https://github.com/leanprover-community/mathlib4/pull/11517\">#11517</a>, etc.</p>",
        "id": 435902585,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1714331782
    },
    {
        "content": "<p>(In a more remote future, we may remove <code>+</code> and <code>-</code> in some of the constructions above. The main difficulty is to get suitable resolution lemmas, e.g. every complex admits a <code>K</code>-injective resolution.)</p>",
        "id": 435902588,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1714331789
    },
    {
        "content": "<p>Yeah, local algebra is what I wanted this for. But it's tricky to stay within just left or just right bounded complexes for that, imo. Usually we're going to start with right-bounded complexes (projective resolutions of modules) and then as soon as we want to RHom out of these we leave that world</p>",
        "id": 435903081,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1714332301
    },
    {
        "content": "<p>It sounds like this is not going to be finished in the near future, so I'll probably need to stick with juggling Ext groups to prove things about regular sequences for now</p>",
        "id": 435903173,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1714332378
    },
    {
        "content": "<p>(I would be happy to try and add K projective and K injective resolutions, but the rest of the API also seems like it'll take a minute to get set up)</p>",
        "id": 435903200,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1714332409
    },
    {
        "content": "<p>An alternative is to formalize Proposition 3.13 in <a href=\"https://arxiv.org/abs/math/0102087\">https://arxiv.org/abs/math/0102087</a> (I would be <em>very happy</em> not to work on this!).</p>\n<p>(For flat resolutions, I am starting with the <code>C^-</code> case, but <code>K</code>-flat resolutions of unbounded complexes are not so hard to get, as far as I remember.)</p>\n<p>Still, I think that there is already a <em>lot</em> of things to do using only <code>Ext</code> and <code>Tor</code> functor<strong>S</strong>.</p>",
        "id": 435903682,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1714332862
    },
    {
        "content": "<p>I have essentially obtained flat resolutions. More precisely, if <code>Œπ : A ‚•§ C</code> is a fully faithful functor from an additive category <code>A</code> to an abelian category <code>C</code> equipped with a functor <code>F : C ‚•§ A</code> (preserving zero maps, but not necessarily additive) and a natural transformation <code>œÄ : F ‚ãô Œπ ‚ü∂ ùü≠ C</code> such that <code>[Epi (œÄ.app X)]</code> for all <code>X</code> (it shall be so with <code>C := ModuleCat R</code> and <code>A</code> the full subcategory of flat modules, using a small modification of the free module functor, and this will also apply to (pre)sheaves of modules), then any bounded above cochain complex in <code>C</code> admits a functorial quasi-iso from a bounded above cochain complex in <code>A</code>. Then, I show that the bounded above derived category of <code>C</code> identifies to the localization of <code>CochainComplex.Minus A</code> with respect to the morphisms which become quasi-isomorphisms in <code>CochainComplex.Minus A</code> <a href=\"https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/Algebra/Homology/LeftResolution/DerivabilityStructure.lean#L42\">https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/Algebra/Homology/LeftResolution/DerivabilityStructure.lean#L42</a></p>\n<p>It also obviously satisfies the dual assumptions for the constructor of derivability structure I have obtained in <a href=\"https://github.com/leanprover-community/mathlib4/pull/12676\">#12676</a>, so that when I dualize the notion of right derivability structures <a href=\"https://github.com/leanprover-community/mathlib4/pull/12633\">#12633</a> to left derivability structures, we shall get the \"flat\" left derivability structure, and once the suitable API for derived functors is formalized (this depends on <a href=\"https://github.com/leanprover-community/mathlib4/pull/12206\">#12206</a>), it will be possible to derive the tensor product as a functor in two variables.</p>",
        "id": 437168991,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1714949173
    },
    {
        "content": "<p>I have just obtained the following result at <a href=\"https://github.com/leanprover-community/mathlib4/blob/773a0884841ba21e8632ff41f30a95551bc8eb26/Mathlib/CategoryTheory/Monoidal/Derived.lean\">https://github.com/leanprover-community/mathlib4/blob/773a0884841ba21e8632ff41f30a95551bc8eb26/Mathlib/CategoryTheory/Monoidal/Derived.lean</a> :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">CategoryTheory.DerivedMonoidal.instMonoidalCategory</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u_3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u_4</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">MonoidalCategory</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MorphismProperty</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">L.IsLocalization</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">W.ContainsIdentities</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">L.HasDerivedMonoidalCategory</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">MonoidalCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DerivedMonoidal</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 515692481,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1746185173
    },
    {
        "content": "<p>It says that if <code>L : C ‚•§ D</code> makes <code>D</code> the localized category of <code>C</code> with respect to <code>W : MorphismProperty C</code> and if <code>C</code> has a monoidal category structure, then there is a left derived monoidal category structure on <code>D</code> (the statement involves the type synonym <code>DerivedMonoidal L W</code>) if <code>L</code> and <code>W</code> satisfy a technical condition <code>L.HasDerivedMonoidalCategory W</code> which is that the bifunctor <code>(X‚ÇÅ, X‚ÇÇ) ‚Ü¶ L.obj (X‚ÇÅ ‚äó X‚ÇÇ)</code> has a left derived functor which satisfies some additional properties (it mostly says that the \"iterated\" versions of this bifunctor also give the left derived functor of the tensor product in 3 or 4 variables). In order to do this, I had to develop notions of left derived functors in two, three and even four variables (this is because the pentagon axiom of monoidal categories involves 4 objects), which I translated in terms of left derived functors in one variable via uncurryfication.</p>",
        "id": 515692502,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1746185181
    },
    {
        "content": "<p>In order to apply this to the derived category, my plan is to generalize the results of <a href=\"https://github.com/leanprover-community/mathlib4/pull/23915\">#23915</a> about the construction and recognition principles for derived functors using derivability structures (a notion introduced by Bruno Kahn and Georges Maltsiniotis). As I have shown that derivability structures behave well with respect to products of categories, I should get generalizations of <a href=\"https://github.com/leanprover-community/mathlib4/pull/23915\">#23915</a> for functors in two, three or four variables. What I expect to show is that if <code>Œ¶ : LocalizerMorphism W‚ÇÄ W</code> is a left derivability structure whose functor <code>Œ¶‚ÇÄ.functor : C‚ÇÄ ‚•§ C</code> is a monoidal functor which \"derives\" the tensor product on <code>C</code> with respect to <code>W</code>, then the assumptions of the previous definition will hold, which shall give a (left derived) monoidal category structure on the localized category <code>D</code>.</p>",
        "id": 515692518,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1746185188
    },
    {
        "content": "<p>With some more work polishing the flat or \"K-flat\" derivability structure on the homotopy category of complexes in suitable abelian categories <code>A</code>, I intend to obtain a monoidal category structure on <code>DerivedCategory A</code>, and hopefully this will allow a definition of <code>Tor</code>. (The \"properties\" of <code>Tor</code> would require further investigation of the compatibilities with shifts.)</p>",
        "id": 515692541,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1746185194
    },
    {
        "content": "<p>(This was outlined in <a href=\"https://hal.science/hal-04546712\">https://hal.science/hal-04546712</a> ¬ß5.3.4)</p>",
        "id": 515692819,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1746185302
    },
    {
        "content": "<p>That's really cool!</p>",
        "id": 515701624,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1746188683
    },
    {
        "content": "<p>In between, I have obtained the expected result about the existence of a (derived) monoidal structure on the localized category under the assumption that we can derive the tensor product using a left derivability structure <code>Œ¶</code> such that the underlying functor <code>Œ¶.functor</code> is monoidal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">CategoryTheory.LocalizerMorphism.DerivesMonoidalStructure.hasDerivedMonoidalCategory</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">C‚ÇÄ</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÄ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonoidalCategory</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÄ</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">MonoidalCategory</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">W‚ÇÄ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MorphismProperty</span><span class=\"w\"> </span><span class=\"n\">C‚ÇÄ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MorphismProperty</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Œ¶</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LocalizerMorphism</span><span class=\"w\"> </span><span class=\"n\">W‚ÇÄ</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">W‚ÇÄ.ContainsIdentities</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">W.ContainsIdentities</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Œ¶.IsLeftDerivabilityStructure</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Œ¶.functor.Monoidal</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">L.IsLocalization</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ¶.DerivesMonoidalStructure</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">L.HasDerivedMonoidalCategory</span><span class=\"w\"> </span><span class=\"n\">W</span>\n</code></pre></div>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/1f7a1c0960a5cb55fd9271640a7430207ac9541d/Mathlib/CategoryTheory/Localization/DerivabilityStructure/Monoidal.lean#L50\">https://github.com/leanprover-community/mathlib4/blob/1f7a1c0960a5cb55fd9271640a7430207ac9541d/Mathlib/CategoryTheory/Localization/DerivabilityStructure/Monoidal.lean#L50</a></p>",
        "id": 518154229,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1747254860
    },
    {
        "content": "<p>Then, I have formalized the K-flat derivability structure on cochain complexes (and on the homotopy category). Under the assumption that a monoidal abelian category <code>A</code> has a functorial flat resolution (i.e. for any <code>X : A</code>, there is an epimorphism <code>P ‚ü∂ X</code> with <code>P</code> flat, which is functorial in <code>X</code>) and a few basic assumptions (including that <code>A</code> has exact colimits of shape <code>‚Ñ§</code>, a property which holds for Grothendieck abelian categories), I have obtained a functorial K-flat resolution of (unbounded) complexes in <code>A</code> (the proof is similar as in Spaltenstein's original paper), and it follows that the inclusion functor from K-flat cochain complexes to cochain complexes induces a left derivability structure. Using some small facts about Guitart exact squares (a rather esoteric categorical notion which appears in the definition of a derivability structure), including <a href=\"https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/GuitartExact/Quotient.lean\">https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/GuitartExact/Quotient.lean</a> , I have deduced that there is a \"quotient\" left derivability structure given by the inclusion of the homotopy category of K-flat complexes in the whole homotopy category (as this inclusion functor is triangulated, this will have consequences about interactions between the derived tensor product and distinguished triangles...).</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/1f7a1c0960a5cb55fd9271640a7430207ac9541d/Mathlib/CategoryTheory/Abelian/Flat/KFlat.lean#L505-L516\">https://github.com/leanprover-community/mathlib4/blob/1f7a1c0960a5cb55fd9271640a7430207ac9541d/Mathlib/CategoryTheory/Abelian/Flat/KFlat.lean#L505-L516</a></p>",
        "id": 518154257,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1747254877
    },
    {
        "content": "<p>In particular, I have applied this to categories of modules:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasDerivedCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">MonoidalCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DerivedCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n</code></pre></div>\n<p>I am sorry this is not computable! and I have a new definition of <code>Tor</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">tor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñ§</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">t.homology</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">t.ŒπHeart.obj</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">‚äó</span><span class=\"w\"> </span><span class=\"n\">t.ŒπHeart.obj</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>where <code>t</code> is the canonical <code>t</code>-structure on the derived category of the category of <code>R</code>-modules. (The same will hold for categories of sheaves of modules.) The definition suggests that internally, <code>Tor</code> will be defined whenever we have a monoidal triangulated category equipped with a <code>t</code>-structure.<br>\n(I have quite precise ideas on how to show that the derived tensor product is a \"triangulated functor in two variables\", which would give the long exact sequences of <code>Tor</code>, but I will probably not work on this very soon.)<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/1f7a1c0960a5cb55fd9271640a7430207ac9541d/Mathlib/CategoryTheory/Abelian/Flat/ModuleCat.lean\">https://github.com/leanprover-community/mathlib4/blob/1f7a1c0960a5cb55fd9271640a7430207ac9541d/Mathlib/CategoryTheory/Abelian/Flat/ModuleCat.lean</a></p>",
        "id": 518154309,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1747254899
    }
]