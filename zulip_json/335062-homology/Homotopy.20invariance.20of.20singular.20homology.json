[
    {
        "content": "<p>Hi</p>\n<p>I’m considering proving homotopy invariance of singular homology using <a href=\"https://github.com/Shamrock-Frost/BrouwerFixedPoint/blob/master/src/homotopy_invariance.lean\">Brendan Murphy’s work</a> as a blueprint, porting as much as possible. Since mathlib has changed quite significantly since then, I would like to hear your opinions on whether this approach is still a good fit for mathlib. What I have in mind is that algebraic topology in mathlib is now built on top of fairly general category theory, which could in principle give more general statements than Brendan’s original proof.</p>\n<p>Specifically, his proof relies on the usual free‑<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>‑module structure on singular chains, with singular simplices as basis elements. So I would state homotopy invariance for singular homology with coefficients in a commutative ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, i.e. with target <code>ModuleCat R</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopCat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">singularHomology_map_eq_of_homotopy</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContinuousMap</span><span class=\"bp\">.</span><span class=\"n\">Homotopy</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(((</span><span class=\"n\">singularHomologyFunctor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ModuleCat</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"o\">(((</span><span class=\"n\">singularHomologyFunctor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ModuleCat</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>In addition, he uses an acyclic models theorem which (roughly) says that if two natural transformations <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo separator=\"true\">,</mo><mi>β</mi><mo>:</mo><mi>F</mi><mo>⟶</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">α, β : F ⟶ G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6943em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟶</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> have the same effect on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">H_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> on a family of model objects, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> is acyclic on these models, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span> are naturally chain‑homotopic. I’m not that deep into category theory yet, so I don’t fully understand all of this, but since this part of the proof is relatively self‑contained, I’m hoping it should be possible to reprove an appropriate version in mathlib4 as well.</p>\n<p>There are obviously more technical details in the proof that might cause problems, but my plan would be to start and address issues as they arise. I know there have been previous attempts to port Brendan’s Brouwer proof; if anyone knows what specific obstacles came up there, I would be very interested to hear about them.</p>\n<p>So, my main question is whether the statement above is general enough for mathlib or if you want to stick to the category-theory approach.</p>\n<p>I feel like it is useful to make progress on singular homology and reach some standard theorems, even if this currently means using more geometric, less obviously “optimal” categorical proofs. I also don't know if there are \"categorical\" proofs of excision, but if not, going down to the geometric level would be necessary at some point anyway.</p>",
        "id": 562115719,
        "sender_full_name": "Fabian Odermatt",
        "timestamp": 1764945402
    },
    {
        "content": "<p>For the homotopy invariance, I feel it would be better to show that if <code>f</code> and <code>g</code> are homotopic morphisms of simplicial sets, then the corresponding morphisms of chain complexes (after applying <code>SSet.singularChainComplexFunctor</code>) are homotopic. The similar result you mention for homotopies between continuous maps of topological spaces follows easily as the singular homology of a topological space <code>X</code> is obtained by taking the homology of the singular simplicial set of <code>X</code> (whose <code>n</code>-simplices are continuous maps from the standard topological <code>n</code>-simplex to <code>X</code>).<br>\nThe strategy of proof may combine two steps:</p>\n<ol>\n<li>show the result using the combinatorial definition of homotopies between morphisms of simplicial objects <a href=\"https://ncatlab.org/nlab/show/simplicial+homotopy\">https://ncatlab.org/nlab/show/simplicial+homotopy</a>;</li>\n<li>relate the combinatorial definition of homotopies with the data of a morphism <code>X ⊗ Δ[1] ⟶ Y</code>.</li>\n</ol>\n<p>(I am in the process of adding results about the simplicial sets <code>Δ[p] ⊗ Δ[q]</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/32237\">#32237</a>, and soon there will be some specialized versions for <code>Δ[n] ⊗ Δ[1]</code> which should be relevant for 2. If you work on 1., the combination of both should lead to the expected homotopy invariance result.)</p>",
        "id": 562136936,
        "sender_full_name": "Joël Riou",
        "timestamp": 1764950959
    },
    {
        "content": "<p>I'll have a look into it</p>",
        "id": 562221688,
        "sender_full_name": "Fabian Odermatt",
        "timestamp": 1765002904
    },
    {
        "content": "<p>So I think I managed to define simplicial homotopy as on the nlab page. See PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/32881\">#32881</a>.<br>\nCurrently, I'm trying to construct a chain homotopy between the induced morphisms on the alternating face map complexes, given a simplicial homotopy.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SimplicialHomotopy</span><span class=\"bp\">.</span><span class=\"n\">toChainHomotopy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimplicialHomotopy</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Homotopy</span>\n<span class=\"w\">      </span><span class=\"o\">((</span><span class=\"n\">alternatingFaceMapComplex</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">((</span><span class=\"n\">alternatingFaceMapComplex</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>which will give the corollary</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SimplicialHomotopy</span><span class=\"bp\">.</span><span class=\"n\">map_homology_eq</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">CategoryWithHomology</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimplicialHomotopy</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">HomologicalComplex</span><span class=\"bp\">.</span><span class=\"n\">homologyFunctor</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span>\n<span class=\"w\">        </span><span class=\"o\">((</span><span class=\"n\">alternatingFaceMapComplex</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">HomologicalComplex</span><span class=\"bp\">.</span><span class=\"n\">homologyFunctor</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span>\n<span class=\"w\">        </span><span class=\"o\">((</span><span class=\"n\">alternatingFaceMapComplex</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">toChainHomotopy</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">homologyMap_eq</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>This should then give the result aswell for SimplicialSets, right? </p>\n<p>Would you mind explaining in a bit more detail the step 2. of your plan? Or hint to some places where I could read about that. Thank you!</p>",
        "id": 563704102,
        "sender_full_name": "Fabian Odermatt",
        "timestamp": 1765735734
    },
    {
        "content": "<p>As a complement to your definition in <a href=\"https://github.com/leanprover-community/mathlib4/pull/32881\">#32881</a>, you could show that <code>SimplicialHomotopy</code> behaves well with respect to the postcomposition with a functor <code>C ⥤ D</code> (<code>SimplicialObject.whiskering</code>). In addition to the construction of a homotopy between the actions on alternating face map complexes, this should give that if <code>f</code> and <code>g</code> are maps of simplicial sets that are homotopic in the sense of <code>SimplicialHomotopy</code>, then the induced morphisms on the complexes which compute the singular homology are chain homotopic.<br>\nTwo things would remain:</p>\n<ul>\n<li>A homotopy in the sense of the data of a map <code>X ⊗ Δ[1] ⟶ Y</code> is the same as <code>SimplicialHomotopy</code> (possibly up to switching <code>f</code> and <code>g</code>?). For the homotopy invariance, we need only one direction. Details may become easier after I have made a few more pull requests;</li>\n<li>When we have a continuous map <code>X x [0, 1] ⟶ Y</code> between topological spaces, one may apply the singular simplicial set functor, which commutes with products, so that we should get an homotopy <code>Sing X ⊗ Δ[1] ⟶ Sing Y</code> by using a suitable <code>1</code>-simplex of <code>Sing [0, 1]</code>.</li>\n</ul>\n<p>I would suggest you continue working on the homotopy on the alternating chain map complex. The chain homotopy should be given by the alternating sum of the maps <code>h</code> (up to a sign), see p. 13 of <em>Simplicial objects in algebraic topology</em> by J. Peter May for similar material.</p>",
        "id": 563706339,
        "sender_full_name": "Joël Riou",
        "timestamp": 1765738724
    },
    {
        "content": "<p>I have added some suggestions to <a href=\"https://github.com/leanprover-community/mathlib4/pull/32881\">#32881</a>. In order to be reasonably sure that the equations are correct (in the sense that the translation from <code>ncatlab</code> is correct, and that there is no typo in this reference!), it would be good to wait for the formalisation of the chain homotopy on alternating face map complexes.<br>\n(Also, in the unfortunate case the chain homotopy on the alternating face map complexes may require an extra sign, we may want to switch the roles of <code>f</code> and <code>g</code> in the definition of <code>SimplicialHomotopy</code>.)</p>",
        "id": 563709321,
        "sender_full_name": "Joël Riou",
        "timestamp": 1765742789
    },
    {
        "content": "<p>Perfect, yes I agree</p>",
        "id": 563895395,
        "sender_full_name": "Fabian Odermatt",
        "timestamp": 1765823523
    },
    {
        "content": "<p>I added two additional files to <a href=\"https://github.com/leanprover-community/mathlib4/pull/32881\">#32881</a>. <em>ChainHomotopy</em> containing a proof of the homotopy on the alternating face map complexes and <em>HomotopyInvariance</em> in SingularHomology containing the step simplicial homotopy -&gt; same map on singular homology using the whiskering you mentioned.</p>\n<p>For the remaining results I'll probably open a new PR. I'm now trying to get a SimplicialHomotopy from a  \"Cylinder Homotopy\". You mentioned a few PR's that might come in handy?</p>",
        "id": 566441190,
        "sender_full_name": "Fabian Odermatt",
        "timestamp": 1767648394
    },
    {
        "content": "<p>Great! I will work on getting a <code>SimplicialHomotopy</code> of simplicial sets from a map from the product with <code>Δ[1]</code>.</p>",
        "id": 566513616,
        "sender_full_name": "Joël Riou",
        "timestamp": 1767694252
    },
    {
        "content": "<p>(We do not immediately need the other direction, which is more technical.)</p>",
        "id": 566513674,
        "sender_full_name": "Joël Riou",
        "timestamp": 1767694274
    },
    {
        "content": "<p>I have started working on this at <a href=\"https://github.com/leanprover-community/mathlib4/pull/33683\">#33683</a>.</p>",
        "id": 566620140,
        "sender_full_name": "Joël Riou",
        "timestamp": 1767732681
    },
    {
        "content": "<p>I have obtained a simplicial homotopy <code>SimplicialHomotopy f g</code> from a map from the product with <code>Δ[1]</code> (new type <code>SSet.Homotopy f g</code>), but I had to swap the parameters <code>f</code> and <code>g</code> of <code>SimplicialHomotopy</code> (otherwise, I would get something in <code>SimplicialHomotopy g f</code>).<br>\nThen, could you change the roles of <code>f</code> and <code>g</code> in your definition of <code>SimplicialHomotopy</code> (i.e. make <code>h_zero_comp_δ_zero</code> refer to <code>g</code> and <code>h_last_comp_δ_last</code> to <code>f</code>). (This should require changing the sign of the chain homotopy...)</p>",
        "id": 566633162,
        "sender_full_name": "Joël Riou",
        "timestamp": 1767739662
    },
    {
        "content": "<p>Ok cool! Yes I'll do that</p>",
        "id": 567013861,
        "sender_full_name": "Fabian Odermatt",
        "timestamp": 1767899402
    },
    {
        "content": "<p>I now switched the definition of toChainHomotopy aswell. From <code>SimplicialHomotopy f g</code> it gives a <code>Homotopy g f</code>. The <code>map_homology_eq</code> remains the same orientation, though, using symmetry of homotopy. I wonder if it would be better  to have additionally something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toChainHomotopy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimplicialHomotopy</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Homotopy</span>\n<span class=\"w\">      </span><span class=\"o\">((</span><span class=\"n\">alternatingFaceMapComplex</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">((</span><span class=\"n\">alternatingFaceMapComplex</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">toChainHomotopy'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>",
        "id": 567245943,
        "sender_full_name": "Fabian Odermatt",
        "timestamp": 1767986004
    },
    {
        "content": "<p>Hi, just stumbled across your PRs since I have a project for a class to show homotopy invariance of singular homology. Given your work - and the size of the project - I guess I could contribute to the construction of a simplicial homotopy from the topological homotopy (using the <code>X ⊗ Δ[1] ⟶ Y</code> characterisation)</p>\n<p>I did not find anything like that in your PRs yet, but please correct me if I am wrong.</p>",
        "id": 569561733,
        "sender_full_name": "Jasper Ganten",
        "timestamp": 1769106348
    },
    {
        "content": "<p>I have a very draft implementation of this at <a href=\"https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/TopCat/Homotopy.lean\">https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/TopCat/Homotopy.lean</a> (<code>Homotopy.toSSet</code>), but please proceed.</p>",
        "id": 569750663,
        "sender_full_name": "Joël Riou",
        "timestamp": 1769184073
    }
]