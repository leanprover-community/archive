[
    {
        "content": "<p>I have just finished preparing a series of PR which ends with the construction of the derived category of an abelian category, as a triangulated category:</p>\n<ul>\n<li><del> <a href=\"https://github.com/leanprover-community/mathlib4/pull/11740\">#11740</a> feat(CategoryTheory): triangulated subcategories</del></li>\n<li><del> <a href=\"https://github.com/leanprover-community/mathlib4/pull/11789\">#11789</a> feat(CategoryTheory): the class of morphisms whose cone belongs to a triangulated subcategory</del></li>\n<li><del> <a href=\"https://github.com/leanprover-community/mathlib4/pull/11759\">#11759</a> feat(CategoryTheory/Triangulated): homological functors</del></li>\n<li><del> <a href=\"https://github.com/leanprover-community/mathlib4/pull/11805\">#11805</a> feat(CategoryTheory/Triangulated): the long exact sequence of a homological functor</del></li>\n<li><del> <a href=\"https://github.com/leanprover-community/mathlib4/pull/11760\">#11760</a> feat: the homological functor on the homotopy category of cochain complexes in an abelian category</del></li>\n<li><del> <a href=\"https://github.com/leanprover-community/mathlib4/pull/11721\">#11721</a> feat(CategoryTheory/Localization): dualize results for right calculus of fractions</del></li>\n<li><del> <a href=\"https://github.com/leanprover-community/mathlib4/pull/11737\">#11737</a> feat(CategoryTheory): more lemmas for the calculus of fractions</del></li>\n<li><del> <a href=\"https://github.com/leanprover-community/mathlib4/pull/11728\">#11728</a> feat(CategoryTheory/Localization): the localized category is preadditive</del></li>\n<li><del> <a href=\"https://github.com/leanprover-community/mathlib4/pull/11738\">#11738</a> feat(CategoryTheory): localization of pretriangulated categories</del></li>\n<li><del> <a href=\"https://github.com/leanprover-community/mathlib4/pull/11786\">#11786</a> feat(CategoryTheory): localization of triangulated categories</del></li>\n<li><del> <a href=\"https://github.com/leanprover-community/mathlib4/pull/11764\">#11764</a> feat(CategoryTheory/Shift): the induced shift sequence</del></li>\n<li><del> <a href=\"https://github.com/leanprover-community/mathlib4/pull/11782\">#11782</a> feat(Algebra/Homology): compatibilities of homology and shifts</del></li>\n<li><del> <a href=\"https://github.com/leanprover-community/mathlib4/pull/11806\">#11806</a> feat: the derived category of an abelian category</del></li>\n</ul>",
        "id": 430436679,
        "sender_full_name": "Joël Riou",
        "timestamp": 1711850760
    },
    {
        "content": "<p>A first version of my paper <em>Formalization of derived categories in Lean/mathlib</em> is online at <a href=\"https://hal.science/hal-04546712\">https://hal.science/hal-04546712</a></p>\n<p>It is supported by a Lean file at <a href=\"https://github.com/joelriou/lean-derived-categories\">https://github.com/joelriou/lean-derived-categories</a></p>\n<p>Abstract: This paper outlines the formalization of derived categories in the mathematical library of the proof assistant Lean 4. The derived category D(C) of any abelian category C is formalized as the localization of the category of unbounded cochain complexes with respect to the class of quasi-isomorphisms, and it is endowed with a triangulated structure.</p>",
        "id": 433745246,
        "sender_full_name": "Joël Riou",
        "timestamp": 1713357329
    },
    {
        "content": "<p>I've merged <a href=\"https://github.com/leanprover-community/mathlib4/pull/11764\">#11764</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/11737\">#11737</a> above, and delegated <a href=\"https://github.com/leanprover-community/mathlib4/pull/11740\">#11740</a>.</p>",
        "id": 433898867,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1713402579
    },
    {
        "content": "<p>I delegated <a href=\"https://github.com/leanprover-community/mathlib4/pull/11728\">#11728</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/11782\">#11782</a>.</p>",
        "id": 433914487,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1713414319
    },
    {
        "content": "<p>Only two PR to go before the derived category enters mathlib: <a href=\"https://github.com/leanprover-community/mathlib4/pull/11786\">#11786</a> which shows that the localization of a triangulated category satisfies the octahedron axiom, and the final one <a href=\"https://github.com/leanprover-community/mathlib4/pull/11806\">#11806</a>.</p>",
        "id": 442878505,
        "sender_full_name": "Joël Riou",
        "timestamp": 1717617274
    },
    {
        "content": "<p>Thanks to an insight by <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> <a href=\"https://github.com/leanprover-community/mathlib4/pull/11786#discussion_r1628462240\">https://github.com/leanprover-community/mathlib4/pull/11786#discussion_r1628462240</a>, a new dependency just appeared <a href=\"https://github.com/leanprover-community/mathlib4/pull/13558\">#13558</a>: if <code>L : C ⥤ D</code> is a localization functor for a class of morphisms <code>W</code> that has a left or right calculus of fractions, then any finite composition of morphisms in <code>D</code> can be lifted up to isomorphisms in <code>C</code> (i.e. <code>L.mapComposableArrows n</code> is essentially surjective for all <code>n</code>). I had done this previously only in the case <code>n = 0</code>, <code>n = 1</code> and <code>n = 2</code> (assuming both left/right calculus of fractions).<br>\nThe consequence is that it is possible to localize a triangulated category assuming only left calculus of fractions (and other standard conditions), which is a sharper result than what was known (to me, at least).</p>",
        "id": 443025665,
        "sender_full_name": "Joël Riou",
        "timestamp": 1717670153
    },
    {
        "content": "<p>Very nice! borsificated</p>",
        "id": 443027111,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717670681
    },
    {
        "content": "<p>Having left calculus of fractions is exactly the left ore condition so it is reasonable that one side is enough.<br>\nTime to refactor Monoids in mathlib as categories with one object so that we can reuse these great localization api without duplicating them as <code>OreLocalization</code> /j</p>",
        "id": 443027944,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717671018
    },
    {
        "content": "<p>categories with one object and an nsmul field, right?</p>",
        "id": 443119470,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717695175
    },
    {
        "content": "<p>Derived categories are now in mathlib. For me, the next target will be to refactor <code>Ext</code>-groups using morphisms in derived categories, so that we get long exact sequences of <code>Ext</code> (which will allow definitions of projective/injective dimension, etc). One technical hurdle is that morphisms in the derived category may be in a larger universe, so that I intend to define first something named <code>LargeExt</code> <a href=\"https://github.com/leanprover-community/mathlib4/pull/13599\">#13599</a>, and after that, provide some API to shrink these groups (at least when there are enough projectives or enough injectives).</p>\n<p>(Note: A priori, I do not intend to define <code>projectiveDimension X : WithTop ℕ</code>, but rather a typeclass <code>ProjectiveDimensionLE X n</code>.)</p>",
        "id": 443446179,
        "sender_full_name": "Joël Riou",
        "timestamp": 1717839051
    },
    {
        "content": "<p>Thanks to all reviewers <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> <span class=\"user-mention\" data-user-id=\"519559\">@Dagur Asgeirsson</span>!</p>",
        "id": 443446334,
        "sender_full_name": "Joël Riou",
        "timestamp": 1717839216
    },
    {
        "content": "<blockquote>\n<p>(Note: A priori, I do not intend to define <code>projectiveDimension X : WithTop ℕ</code>, but rather a typeclass <code>ProjectiveDimensionLE X n</code>.)</p>\n</blockquote>\n<p>I really like that idea. Functions like the degree of a polynomial and the dimension of an algebraic variety are historically what everyone uses, but they have problems when formalising; what is the dimension of the empty variety, or the degree of the zero polynomial? And the fibres are also poorly-behaved, for example polynomials of degree n don't necessarily add or subtract to give a polynomial of degree n, and they don't necessarily multiply to give a polynomial of degree 2n if you're not over an integral domain. In contrast, polynomials of degree at most n are a very natural object, they're an R-submodule of R[X]. Arguably even more natural is \"polynomials of degree less than n\" because then you can get {0} with n=0. If you look at the API for polynomials, you can see \"&lt;= n\" everywhere and \"= n\" far more rarely. Similarly with dimension: Jujian ended up defining the Krull dimension of a topological space or commutative ring to be in WithBot(WithTop(Nat)) and here you can just do the same thing: you can ask \"is the dimension less than n\" for n any natural and now you can say everything which you can say with the WithBot(WithTop) hack (for example an infinite-dimensional ring is just something which doesn't have dimension less than n for any n) but without ever leaving the world of naturals.</p>",
        "id": 443466711,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717851983
    },
    {
        "content": "<p>I don't like this design. How you do state \"projectiveDimension M = n\" with this API? How do you state a formula which has the projective dimensions of two different modules on both sides? Also, I don't get the reasoning for using a typeclass here </p>\n<p>Coincidentally, I just started defining projective dimension (preparing for auslander buchsbaum) and intended to define it as the infimum over all projective resolutions P of the amplitide of P (defined to be 0 for the 0 resolution). I'm not sure how I should proceed now</p>",
        "id": 443500560,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1717867385
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> maybe this has been discussed before, but can we now also get bounded derived cats easily?</p>",
        "id": 443501248,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717867723
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/335062-homology/topic/Derived.20categories.20in.20mathlib/near/443501248\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> maybe this has been discussed before, but can we now also get bounded derived cats easily?</p>\n</blockquote>\n<p>After we define the homology functor from the derived category of <code>C</code> to <code>C</code>, it would be easy to define the bounded/bounded below/bounded above. However, the better definition shall be by developing more the API of t-structures, and defining this in that context. If there is a need, we may give a more direct definition as soon as it is possible. (However, showing something like the category <code>D^-</code>, as a full subcategory of <code>D</code>, is the localization of the category of bounded above complexes requires results about localizing subcategories and truncations (which I have formalised), and these ingredients are essentially what we need to construct the canonical <code>t</code>-structure.</p>",
        "id": 443507406,
        "sender_full_name": "Joël Riou",
        "timestamp": 1717870958
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110401\">Brendan Seamas Murphy</span> <a href=\"#narrow/stream/335062-homology/topic/Derived.20categories.20in.20mathlib/near/443500560\">said</a>:</p>\n<blockquote>\n<p>I don't like this design. How you do state \"projectiveDimension M = n\" with this API?</p>\n</blockquote>\n<p>I have used typeclasses for my code on truncations (saying that a complex is strictly/cohomologically less/greater than or equal to a certain <code>n</code>, and it has worked quite nicely.</p>\n<p>I think that typeclasses could be very nice in order to formalise results about categories of global dimension less and or equal to 0 (or 1) for example. Of course, if there is a need, we may also define a term <code>projectiveDimension</code>, but as Kevin suggests, it is likely that many lemmas would have <code>projectiveDimension X &lt;= n</code> as assumptions...</p>\n<p>My first idea would be to define the projective dimension in terms of the vanishing of <code>Ext</code> in big enough degrees (and show the equivalence with the definition you suggest when the category has enough projectives).</p>\n<p>At this stage, I do not want to hinder the development of applications of homological algebra. You may very well proceed with your implementation, and when more ingredients from the language of derived categories become available, we may proceed with a refactor.</p>",
        "id": 443508777,
        "sender_full_name": "Joël Riou",
        "timestamp": 1717871740
    },
    {
        "content": "<p>For what is worth, while working on <code>compute_degree</code>, I also played with a typeclass for <code>degree/natDegree</code> of polynomials at most something and it worked very well.  In fact, most of the tactic is devoted to computing <em>exact</em> degree: the upper bound you get almost immediately.  What is hard is showing that the not-known-to-be-sharp bound is indeed correct.</p>",
        "id": 443515959,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1717876699
    },
    {
        "content": "<p>I have implemented <code>HasProjectiveDimensionLT</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/19604\">#19604</a>.</p>",
        "id": 485101129,
        "sender_full_name": "Joël Riou",
        "timestamp": 1732887538
    }
]