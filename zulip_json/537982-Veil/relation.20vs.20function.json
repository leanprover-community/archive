[
    {
        "content": "<p>Could you add guidance in the <a href=\"https://github.com/verse-lab/veil/tree/veil-2.0-preview?tab=readme-ov-file#4-state-and-theory-components\">State and Theory Components</a> section of the documentation on how to choose between a relation and a function?</p>\n<p>In your blog post example <a href=\"https://github.com/verse-lab/veil/blob/veil-2.0-preview/Examples/Synchronous/FloodSet.lean\">FloodSet</a>, for example, you use <a href=\"https://github.com/verse-lab/veil/blob/06552a51fbbb34aa01eb7f023a1ee0e502800eae/Examples/Synchronous/FloodSet.lean#L63\">relation decision : node → value → Bool</a> where I would have used <code>function decision: node -&gt; value</code> so I don't have to prove that decisions are unique.</p>\n<p>I think the answer is going to be that SMT somehow performs better with relations than with functions, so the proof overhead is worth it.</p>",
        "id": 573503706,
        "sender_full_name": "Mark R. Tuttle",
        "timestamp": 1770898124
    },
    {
        "content": "<p>Will do!</p>\n<p>The gist is to always use a relation if you can. A function, if you think about it, is a relation <code>r</code> with the two following assumptions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">invariant</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">coherence</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">z</span>\n<span class=\"n\">invariant</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">totality</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>A relation with just the coherence axiom is a partial function.  If that is good enough for modelling your state, you should use that.</p>\n<blockquote>\n<p>I think the answer is going to be that SMT somehow performs better with relations than with functions.</p>\n</blockquote>\n<p>Yes. The totality assumption potentially takes your specification outside the decidable fragment of first order logic.</p>\n<p>A function is equivalent to a <code>∀∃</code> quantifier alternation (intuition: <code>∀∃</code> introduces a Skolem function in the solver), which solvers can struggle with in some cases.</p>\n<p>You can find more details at: <a href=\"https://microsoft.github.io/ivy/decidability.html\">https://microsoft.github.io/ivy/decidability.html</a></p>",
        "id": 573517046,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1770901923
    }
]