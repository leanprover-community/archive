[
    {
        "content": "<p>I've been thinking for a while about \"just\" porting functionality from other programming languages' stdlibs like e.g. <a href=\"https://std.rs\">https://std.rs</a> to std4 without any theorem support etc. whatsoever. Would that be a welcome addition? Quite often when working with Lean I just feel these...minor annoyances when I have to work around something that is there by default in the stdlib in other languages</p>",
        "id": 354039689,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1682711441
    },
    {
        "content": "<p>Sure, if it is being used as an API guide that sounds fine</p>",
        "id": 354040853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682711868
    },
    {
        "content": "<p>a lot of what is there already is copied pretty directly from the haskell standard library</p>",
        "id": 354040979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682711906
    },
    {
        "content": "<p>of course you might have trouble making the types line up if you pick a language that differs too much. Good luck writing <a href=\"https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_at_mut\"><code>split_at_mut</code></a> in lean</p>",
        "id": 354041272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682712017
    },
    {
        "content": "<p>ST.Ref I'm coming!</p>",
        "id": 354042839,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1682712590
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/std4/pull/125\">https://github.com/leanprover/std4/pull/125</a> added a bunch of splitting APIs. Rust can obviously do much better than us with pointer stuff. Do we add that in std4 as well? If so shall I add it right now or do we merge as is for now an fully optimize later?</p>",
        "id": 354395363,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1682776565
    },
    {
        "content": "<p>Sadly I noticed that many of my fav non trivial built-in APIs like the chunks and windows one do of course require an iterator abstraction to be present and simply return structs that are meant to be consumed as iterators. Is there a particular reason we do not have an iterator style API yet?</p>",
        "id": 354396813,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1682776777
    },
    {
        "content": "<p>you can do ad hoc iterators and implement <code>Stream</code> for them</p>",
        "id": 354402170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682777573
    },
    {
        "content": "<p>I mean, <code>Stream</code> and <code>ToStream</code> are basically the <code>Iterator</code> and <code>IntoIterator</code> traits from rust</p>",
        "id": 354402652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682777649
    },
    {
        "content": "<p>and in particular they hook into the do notation for multiple-for</p>",
        "id": 354402965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682777699
    },
    {
        "content": "<p>Ah! I did of course only search for Iter and Iterator /o\\</p>",
        "id": 354402970,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1682777699
    },
    {
        "content": "<p>although you can't do a for loop over a stream directly without some partial stuff</p>",
        "id": 354403334,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682777736
    },
    {
        "content": "<p>I think it wouldn't be too hard to write a wrapper which does it anyway though</p>",
        "id": 354404074,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682777845
    },
    {
        "content": "<p>Actually I take it back, this appears to already work out of the box</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Numbers</span> <span class=\"n\">where</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Stream</span> <span class=\"n\">Numbers</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n  <span class=\"n\">next</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">⟩)</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">Numbers.mk</span> <span class=\"mi\">0</span> <span class=\"k\">do</span>\n    <span class=\"n\">println</span><span class=\"bp\">!</span> <span class=\"n\">i</span>\n    <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">100</span> <span class=\"k\">then</span>\n      <span class=\"n\">break</span>\n</code></pre></div>",
        "id": 354408896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682778577
    },
    {
        "content": "<p>thanks to this instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">Stream.forIn</span> <span class=\"o\">[</span><span class=\"n\">Stream</span> <span class=\"n\">ρ</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">ForInStep</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">pure</span> <span class=\"n\">b</span><span class=\"o\">⟩</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">visit</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">match</span> <span class=\"n\">Stream.next</span><span class=\"bp\">?</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">ForInStep.done</span> <span class=\"n\">b</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">b</span>\n      <span class=\"bp\">|</span> <span class=\"n\">ForInStep.yield</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">visit</span> <span class=\"n\">s</span> <span class=\"n\">b</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">b</span>\n  <span class=\"n\">visit</span> <span class=\"n\">s</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Stream</span> <span class=\"n\">ρ</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ForIn</span> <span class=\"n\">m</span> <span class=\"n\">ρ</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">forIn</span> <span class=\"o\">:=</span> <span class=\"n\">Stream.forIn</span>\n</code></pre></div>",
        "id": 354409372,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682778652
    },
    {
        "content": "<p>As a general architectural question. If I am for example implementing the <code>Windows</code> iterator/stream. Do we want it to return <code>Array a</code> or <code>{ xs : Array a // xs.size = windowSize }</code> as to allow provable code while iterating over a <code>Windows</code></p>",
        "id": 354410615,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1682778836
    },
    {
        "content": "<p>The second one might be useful but I would give it a non-default name</p>",
        "id": 354411019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682778881
    },
    {
        "content": "<p>like <code>windowsDep</code></p>",
        "id": 354411164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682778898
    },
    {
        "content": "<p>maybe we need a naming convention for those kind of functions</p>",
        "id": 354411320,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682778918
    },
    {
        "content": "<p>Hm, actually I don't think I can denote this as a Stream instance right now? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Stream</span> <span class=\"o\">(</span><span class=\"n\">WindowsDep</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Subarray</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">next</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I don't have a <code>Windows</code> object to refer to on the outParam of <code>Stream</code> so I cannot write down the invariant :(</p>",
        "id": 354414440,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1682779307
    },
    {
        "content": "<p>Not sure exactly what the question is, but <code>WindowsDep</code> should have <code>windowSize</code> as a parameter</p>",
        "id": 354414922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682779367
    },
    {
        "content": "<p>do you have a complete example?</p>",
        "id": 354415266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682779414
    },
    {
        "content": "<p>Oh you mean it should be indexed by the windowSize instead of just carrying at as parameter, then it works out of course, thank you.</p>",
        "id": 354415797,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1682779484
    },
    {
        "content": "<p>(terminological note: the parameters of a structure are the things before the <code>where</code> , and the fields are the things after it)</p>",
        "id": 354416694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682779591
    },
    {
        "content": "<p>inductive types also have indexes, which are like parameters but they can change in recursive references. Structures can't have indexes because they are not recursive</p>",
        "id": 354417404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682779676
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> next architectural question. Do we want to imitate the full rust style stream/iterator API with the Map and Zip etc. \"Higher order\" iterators/streams? in that case do we want to add a FromStream class to imitate collect() behavior? And I am guessing it would also be nice to have things like a functor instance for streams (if that isnt a thing yet, didn't check).</p>",
        "id": 354648368,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1682848998
    },
    {
        "content": "<p>I've been thinking about a <code>WellFoundedStream</code> class which would help with making folds and things not trivially <code>partial</code></p>",
        "id": 354648627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682849090
    },
    {
        "content": "<p><code>FromStream</code> would need to handle well foundedness in some way</p>",
        "id": 354648730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682849119
    },
    {
        "content": "<p>also the lack of dot notation for typeclass methods makes it pretty unergonomic unless we take some short name in the root namespace</p>",
        "id": 354649459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682849368
    },
    {
        "content": "<p>Maybe it wouldn't be too bad to have functions like <code>Array.fromStream</code>, i.e. no <code>FromStream</code> typeclass but a collection of functions generic over the stream type</p>",
        "id": 354649732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682849476
    },
    {
        "content": "<p>and you need a default / low priority instance for collecting a non-well-founded stream via <code>partial</code></p>",
        "id": 354649897,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682849528
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/348111-std4/topic/Porting.20just.20functionality/near/354649732\">said</a>:</p>\n<blockquote>\n<p>Maybe it wouldn't be too bad to have functions like <code>Array.fromStream</code>, i.e. no <code>FromStream</code> typeclass but a collection of functions generic over the stream type</p>\n</blockquote>\n<p>I have to say I really don't like the way that many of our APIs are currently designed with functions like <code>mapM</code> <code>forM</code> etc. <code>fromList</code> <code>toList</code> (in general <code>from</code> and <code>to</code> functions you also never quite know which of the two are implemented (sometimes both) so you end up needlessly searching) just floating around. I think it would be very nice if we could consolidate at least such basic functionality in typeclasses to make it consistent and the desired API clear.</p>",
        "id": 354652337,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1682850416
    },
    {
        "content": "<p>Well we could implement the typeclasses but I don't think it would make things easier to use</p>",
        "id": 354652471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682850477
    },
    {
        "content": "<p>at least not without changes to the language</p>",
        "id": 354652536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682850487
    },
    {
        "content": "<p>it would improve discoverability, but aliases would do that too</p>",
        "id": 354652605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682850515
    },
    {
        "content": "<p>and when everything is behind a system of typeclasses it can be hard to find the definitions of things (or useful documentation to go with the definition)</p>",
        "id": 354652683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682850560
    },
    {
        "content": "<p>Here's a demo of the approach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">WellFoundedStream</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Stream</span> <span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">wf</span> <span class=\"o\">:</span> <span class=\"n\">WellFounded</span> <span class=\"k\">fun</span> <span class=\"n\">s'</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">Stream.next</span><span class=\"bp\">?</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">s'</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">FoldM</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">foldM</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">β</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">Stream.foldM</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Stream</span> <span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">Stream.next</span><span class=\"bp\">?</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">Stream.foldM</span> <span class=\"n\">s'</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ToStream</span> <span class=\"n\">ρ</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Stream</span> <span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">FoldM</span> <span class=\"n\">m</span> <span class=\"n\">ρ</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">foldM</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">Stream.foldM</span> <span class=\"o\">(</span><span class=\"n\">ToStream.toStream</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Stream.wfFoldM</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Stream</span> <span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">WellFoundedStream</span> <span class=\"n\">σ</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Stream.next</span><span class=\"bp\">?</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">next</span><span class=\"bp\">?</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n    <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">Stream.wfFoldM</span> <span class=\"n\">s'</span> <span class=\"n\">f</span>\n<span class=\"n\">termination_by'</span> <span class=\"n\">invImage</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">WellFoundedStream.wf</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ToStream</span> <span class=\"n\">ρ</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Stream</span> <span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">WellFoundedStream</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">FoldM</span> <span class=\"n\">m</span> <span class=\"n\">ρ</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">foldM</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">Stream.wfFoldM</span> <span class=\"o\">(</span><span class=\"n\">ToStream.toStream</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Array.collect</span> <span class=\"o\">[</span><span class=\"n\">FoldM</span> <span class=\"n\">Id</span> <span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Id.run</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">FoldM.foldM</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">arr</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">arr.push</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">WellFoundedStream</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">wf</span> <span class=\"o\">:=</span> <span class=\"n\">Subrelation.wf</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">measure</span> <span class=\"n\">List.length</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wf</span><span class=\"o\">)</span> <span class=\"bp\">@</span><span class=\"k\">fun</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.lt_succ_self</span> <span class=\"n\">_</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Array.collect</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"mi\">10</span><span class=\"o\">:</span><span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"c1\">-- #[1, 3, 5, 7, 9]</span>\n<span class=\"k\">#eval</span> <span class=\"n\">Array.collect</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"c1\">-- #[1, 2]</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">Array.collect</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"mi\">10</span><span class=\"o\">:</span><span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"c1\">-- gets stuck</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">Array.collect</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 354657447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682852096
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/348111-std4/topic/Porting.20just.20functionality/near/354649459\">said</a>:</p>\n<blockquote>\n<p>also the lack of dot notation for typeclass methods makes it pretty unergonomic unless we take some short name in the root namespace</p>\n</blockquote>\n<p>I mean haskell does get through with this approach right? They have stuff like <code>fmap</code> <code>fold</code> <code>traverse</code> etc. all bound at the top level. It could even be written in a way like this in Lean: <code>toStream arr |&gt; map func1 |&gt; filter func2 |&gt; fold func3</code></p>\n<p>If we decide against this I think we could provide some sort of meta programming facility too derive this functionality if possible? That is, given a <code>Stream</code> instance on a type <code>T</code> we could provide a macro that automatically figures out functions like <code>T.sMap</code>, <code>T.sFold</code> etc. For stream map, stream fold etc. that way we don't collide with existing names in case someone wants to define the functions straight on the type as well but we retain the ability to do do notation like so: <code>toStream arr |&gt;.sMap func1 |&gt;.sFilter func2 |&gt;.sFold func3</code></p>\n<p>This does ease discoverability and does not pollute the global namespace...documentation could theoretically speaking be automatically placed on the functions as well? Seeing the definition of the function would of course be a little harder but since they work the same on each type the definition should not be too interesting? Furthermore it would allow for type specific specializations right? For example if we have a clever idea on how to do <code>sMap</code> on a <code>Subarray</code> we could write a custom <code>sMap</code> there instead of the default variant.</p>\n<p>On a more general note regarding the Haskell approach I am also wondering if we do want Haskell style typeclasses like Traversable, Foldable etc.?</p>",
        "id": 354670370,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1682856422
    },
    {
        "content": "<p>Yeah I was also thinking we could have macros which stick a bunch of functions on the type namespace. You can even do some fancy footwork with declaration ranges if you want to make go to def do the right thing, whatever that is</p>",
        "id": 354671491,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682856801
    },
    {
        "content": "<p>I would not give them funny names like <code>sMap</code>, instead the macro would have enough customization options to avoid name clashes if necessary. The whole point of stamping out all these functions is to produce a convenient interface similar to what you would have done with the manual approach</p>",
        "id": 354671893,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682856924
    },
    {
        "content": "<blockquote>\n<p>On a more general note regarding the Haskell approach I am also wondering if we do want Haskell style typeclasses like Traversable, Foldable etc.?</p>\n</blockquote>\n<p>These things have been discussed at some length already, <span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> 's <a href=\"https://github.com/JamesGallicchio/LeanColls\">LeanColls</a> library is experimenting with these iterator typeclasses. It seems like a bit of a rabbit hole to design these typeclasses well, so I'm focusing on end user outcomes and working backwards to the required typeclasses to make things work.</p>",
        "id": 354672330,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682857075
    },
    {
        "content": "<p>see also <a href=\"#narrow/stream/348111-std4/topic/collection.20typeclasses\">https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/collection.20typeclasses</a></p>",
        "id": 354672561,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682857139
    },
    {
        "content": "<p>I think typeclasses also have the benefit of improving consistency. If there is a <code>From</code> typeclass, it's clear that is probably an idiomatic way to convert between types, while some free-floating <code>fromList</code> functions don't have that same clear message. For example, there's some types that have <code>fromList</code>, while others implement conversion as <code>ofList</code>. Of course, we could pick some naming convention and try to be more consistent, but I feel that typeclasses are a nice way to codify such a convention.</p>",
        "id": 354686973,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1682861668
    },
    {
        "content": "<p>Maybe a mixed approach could be used: use typeclasses for the implementation, then use a macro that re-exports the typeclass functions in the implementors namespace.</p>",
        "id": 354687335,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1682861794
    },
    {
        "content": "<p>RE: putting stuff at toplevel, I think we will almost certainly want all of the collection functions exported to root. One of the experiments of LeanColls was trying to figure out how to group collection functions into typeclasses that allow maximum flexibility (and thus make sense at top-level) without having one class for every collection function (which would make any hierarchy, explicit or otherwise, a mess).</p>\n<p>Had mixed success there -- my reference libraries (I looked at Haskell (there's multiple), Rust, Scala, &amp; F*) are all different, and there's no clear best design... :/</p>",
        "id": 354687506,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1682861874
    },
    {
        "content": "<p>I pushed the stream / collect demo to <a href=\"https://github.com/leanprover/std4/pull/127\">std4#127</a>, but I don't have time to finish it now so please consider it as up for grabs</p>",
        "id": 354692563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682863493
    },
    {
        "content": "<p>Fun fact: <code>Std.Range</code> has a stream instance but it is not well founded when the step size is 0. The <code>ForIn</code> instance arbitrarily stops running the iterator after <code>r.stop</code> iterations.</p>",
        "id": 354692854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682863591
    },
    {
        "content": "<p>Hot take: step size in ranges was a mistake. I can count on zero hands the number of times I wanted this from rust's range type</p>",
        "id": 354693314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682863769
    },
    {
        "content": "<p>Pretty sure Rust's range does have a step size, sort of. It's not exposed directly, but as some iterator wrapper that uses <code>advance_by</code> or <code>nth</code> or one of those iterator methods</p>",
        "id": 354699410,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1682865626
    },
    {
        "content": "<p>there is a step_by iterator adapter, but the range type itself doesn't have a third member</p>",
        "id": 354711448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682869306
    },
    {
        "content": "<p>(also I don't think <code>step_by</code> takes 0 as an argument)</p>",
        "id": 354711568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682869329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/348111-std4/topic/Porting.20just.20functionality/near/354693314\">said</a>:</p>\n<blockquote>\n<p>Hot take: step size in ranges was a mistake. I can count on zero hands the number of times I wanted this from rust's range type</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover/lean4/issues/1962\">https://github.com/leanprover/lean4/issues/1962</a></p>",
        "id": 354712767,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1682869826
    },
    {
        "content": "<p>Indeed, Rust docs suggest that <code>step_by(0)</code> will just panic. For Lean, it might be cleaner to define a step size of 0 to actually just be the same as step size 1 (in the same way that division by 0 is defined, even though it is wrong to do), that at least gets rid of the potential source of non-wellfoundedness in otherwise bounded ranges</p>",
        "id": 354753605,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1682889396
    },
    {
        "content": "<p>I think a better default behavior for step_by 0 is to return an empty iterator; this is also the suggested behavior in <a href=\"https://github.com/leanprover/lean4/pull/2126\">lean4#2126</a></p>",
        "id": 354802560,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682923249
    },
    {
        "content": "<p>but we don't want to check the step in the iterator next function itself, which suggests that <code>0 &lt; step</code> should be part of the data structure, and any fixup behavior is tacked on via smart constructors which either infer that <code>0 &lt; step</code> or return a completely different iterator in that case</p>",
        "id": 354802865,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1682923422
    },
    {
        "content": "<p>it is also way easier to prove things when step size is 1, moving the linear calculation into the body. I think gcc O1 is good enough to generalize the loop variable and remove the multiplications (for any users that do care that much about performance)</p>",
        "id": 355171551,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1683038281
    },
    {
        "content": "<p>so if we are going to re-visit the <code>..</code> notation and <code>Std.Range</code> I would definitely advocate for not having a step size at all</p>",
        "id": 355171876,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1683038346
    },
    {
        "content": "<p>I was also always unsatisfied with code in other languages that used non-default step sizes... I think the hard-to-prove-stuff is a code smell/red flag</p>",
        "id": 355172658,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1683038484
    },
    {
        "content": "<p>It is also so much more modular to have a generic \"every nth element\" stream combinator instead</p>",
        "id": 355175090,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1683038960
    },
    {
        "content": "<p>I guess once (if?) we allow more complicated csimp lemmas, we could even have the composition of the two simplify to the multiplication version :)</p>",
        "id": 355264328,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1683061192
    },
    {
        "content": "<p>The new code generators constant folder is extensible with custom folding rules <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 355284213,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1683070391
    },
    {
        "content": "<p>Maybe this is interesting as a general data point for how to iterator: <a href=\"https://hal.science/hal-03827702v2/\">https://hal.science/hal-03827702v2/</a></p>",
        "id": 356334120,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1683388692
    }
]