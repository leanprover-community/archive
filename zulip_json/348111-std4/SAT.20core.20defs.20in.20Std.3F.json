[
    {
        "content": "<p>Thoughts on putting the core definitions for SAT (CNF formulas, satisfiability, etc.) in Std?</p>\n<p>It's a bit outside the scope. I personally would prefer to put it in a separate library, but I'd like us to settle on one set of core defs for all SAT-related projects, for easy interop.</p>\n<p><strong>A non-exhaustive list of (not nec. equivalent) core SAT definitions from different Lean4 projects:</strong><br>\nMy encoding library: <a href=\"https://github.com/JamesGallicchio/eternity2/blob/main/lean/Eternity2/SATSolve/EncCNF.lean\">https://github.com/JamesGallicchio/eternity2/blob/main/lean/Eternity2/SATSolve/EncCNF.lean</a><br>\nMario's LRAT checker: <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/Sat/FromLRAT.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/Sat/FromLRAT.lean</a><br>\nJoe's LRAT checker: <a href=\"https://github.com/joehendrix/lean-sat-checker/blob/main/SatChecker/Core.lean\">https://github.com/joehendrix/lean-sat-checker/blob/main/SatChecker/Core.lean</a><br>\nSiddhartha's pure Lean SAT solver: <a href=\"https://github.com/siddhartha-gadgil/Saturn/blob/main/Saturn/Core.lean\">https://github.com/siddhartha-gadgil/Saturn/blob/main/Saturn/Core.lean</a><br>\nWojciech's (abandoned?) SAT core library: <a href=\"https://github.com/Vtec234/lean-sat/blob/main/LeanSat/Data/Cnf.lean\">https://github.com/Vtec234/lean-sat/blob/main/LeanSat/Data/Cnf.lean</a></p>\n<p><strong>Also some lean3 projects</strong><br>\nCayden's encoding library: <a href=\"https://github.com/ccodel/verified-encodings/blob/master/src/cnf/clause.lean\">https://github.com/ccodel/verified-encodings/blob/master/src/cnf/clause.lean</a><br>\nRyan Greenblatt's verified DPLL solver: <a href=\"https://github.com/rgreenblatt/verified_sat/blob/master/src/types.lean\">https://github.com/rgreenblatt/verified_sat/blob/master/src/types.lean</a></p>",
        "id": 319161476,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672740850
    },
    {
        "content": "<p>The main outlier I see is Cayden's, where the CNF formulas are parametric on the underlying variable type (which is Nat in all other instances). I think it's justified in the encoding library, but unnecessarily general for the other projects.</p>",
        "id": 319162289,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672741149
    },
    {
        "content": "<p>I also don't want to duplicate work with <a href=\"https://github.com/ufmg-smite/lean-smt\">https://github.com/ufmg-smite/lean-smt</a>, but I don't see any CNF-specific stuff there.</p>",
        "id": 319163032,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672741428
    },
    {
        "content": "<p>Anyways, if these defs don't fit in Std, I'll put together a separate repo for it.</p>",
        "id": 319163192,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672741493
    },
    {
        "content": "<p>I think that an obstacle to standardization is that depending on what you want to use the CNF for, there are different requirements on the representation. For example <code>List Clause</code> is okay if you only ever need to fold the whole thing but would be absurdly inefficient for a SAT solver. So realistically the library would need to include something like <code>PersistentCnf</code> and <code>Cnf</code>, like <code>List</code> vs <code>Array</code>. But even then, what if you need a clause-database type representation which isn't an Array but some more specific data structure? I think the one thing we could all agree on is the mathematical model which would just be some inductive datatype of propositional formulas :)</p>",
        "id": 319230324,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1672762859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/348111-std4/topic/SAT.20core.20defs.20in.20Std.3F/near/319162289\">said</a>:</p>\n<blockquote>\n<p>The main outlier I see is Cayden's, where the CNF formulas are parametric on the underlying variable type (which is Nat in all other instances). I think it's justified in the encoding library, but unnecessarily general for the other projects.</p>\n</blockquote>\n<p>If you want to emit efficient code, it seems the thing to do is parameterize over the <em>literal</em> type e.g. so that it can be <code>UInt64</code> and the first bit denotes the polarity. Parameterizing over the variable type forces a representation <code>Literal Î½</code> which afaik Lean will represent as boxed which is a lot of pointer dereferencing when these are accessed often.</p>",
        "id": 319231345,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1672763140
    },
    {
        "content": "<p>I would mainly want to agree on a mathematical model, but preferably one that is also reasonably efficient for any sort of program interoperation between projects.</p>",
        "id": 319251303,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672769237
    },
    {
        "content": "<p>Or, maybe if we get a good collections interface in Std, we can parameterize the CNF type by the collection types...</p>",
        "id": 319251564,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672769312
    },
    {
        "content": "<p>I agree with Wojciech, this is an area where you can't really standardize the data representation because that depends a lot on what the solver is doing or how it works. The only thing I would expect could be shared are things like <code>List.all</code> for defining the model</p>",
        "id": 319282709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672781153
    },
    {
        "content": "<p>I don't think Lean would be viable for writing high-performance SAT solvers at the moment, so I wasn't really thinking about that as an application. I'm moreso looking for us to maintain something akin to <a href=\"https://pysathq.github.io/\">PySAT</a> which is a library for encoding to CNF and interfacing with external SAT solvers.</p>\n<p>Maybe for now I just work on building out the PySAT equivalent library, and then we can see if it's a good place for mathlib's LRAT verifier and Cayden's verified encodings to be housed.</p>",
        "id": 319336637,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672817902
    },
    {
        "content": "<p>(And any other SAT-adjacent projects that we want to maintain longterm)</p>",
        "id": 319336755,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1672817990
    },
    {
        "content": "<p>I know nothing about programming but out of interest why do you not think lean would be viable for writing high-performance SAT solvers?</p>",
        "id": 319344749,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672822223
    },
    {
        "content": "<p>Maybe what we want is a type class that explains how to decode some type <code>X</code> into a SAT instance (with variables of type <code>a</code>)</p>",
        "id": 319344993,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672822335
    },
    {
        "content": "<p>that does sound more promising, although I still wonder what kind of common interface we can give to the different SAT-like types</p>",
        "id": 319345434,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672822543
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/348111-std4/topic/SAT.20core.20defs.20in.20Std.3F/near/319344749\">said</a>:</p>\n<blockquote>\n<p>I know nothing about programming but out of interest why do you not think lean would be viable for writing high-performance SAT solvers?</p>\n</blockquote>\n<p>We can probably get decently close (i.e. within an order of magnitude) to high performance SAT solvers with lean code if the compiler doesn't fail us, but to get the last bit of performance requires more control over data layout than we have any intention of providing in pure lean code. In this regime the next best thing is to link to a C function or library and axiomatize its behavior using <code>implemented_by</code>; you could still get pretty close to full verification that way if the model is fine-grained enough.</p>",
        "id": 319345941,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672822746
    },
    {
        "content": "<p>35 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"341532\" href=\"/#narrow/stream/341532-lean4-dev/topic/Lean.20LLVM.2FMLIR\">#lean4 dev &gt; Lean LLVM/MLIR</a> by <span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span>.</p>",
        "id": 319468413,
        "sender_full_name": "Notification Bot",
        "timestamp": 1672864451
    },
    {
        "content": "<p>Okay, first commit of <a href=\"https://github.com/JamesGallicchio/LeanSAT\">LeanSAT</a> has dropped :) it's currently just what I had already written for another project, but it is already pretty nice to build encodings with</p>",
        "id": 321480015,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673786479
    },
    {
        "content": "<p>I currently plan to add docs, more examples, and an IPASIR interface with (hopefully) more solvers.</p>",
        "id": 321480210,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673786563
    },
    {
        "content": "<p>And then I'll probably go in the direction of Reid's suggestion and add a SAT encodable/decodable typeclass</p>",
        "id": 321480509,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673786717
    },
    {
        "content": "<p>LMK if there's something else you'd like to see in it!</p>",
        "id": 321480620,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1673786767
    },
    {
        "content": "<p>a test suite / CI would be nice</p>",
        "id": 321480771,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673786842
    }
]