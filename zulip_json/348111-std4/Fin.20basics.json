[
    {
        "content": "<p>Is there a PR about this somewhere? I could have sworn there was something that upstreamed <code>Fin.cons</code> et al and now I need it and can't find it</p>",
        "id": 369931369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687848874
    },
    {
        "content": "<p>Not that I know of... what do you need it for now?</p>",
        "id": 369931658,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687848951
    },
    {
        "content": "<p>I started writing <code>DArray</code> :)</p>",
        "id": 369931812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687848984
    },
    {
        "content": "<p>did my scuffed implementation inspire you to rebuild a reasonable version? <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 369932180,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687849075
    },
    {
        "content": "<p>the basics aren't too hard, it's blocked on <a href=\"https://github.com/leanprover/lean4/pull/2292\">lean4#2292</a>, so I'm just going through and copying the Array interface and <code>push</code> will need some fin stuff</p>",
        "id": 369932363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687849111
    },
    {
        "content": "<p>I'm somewhat unconvinced that anybody actually wants <code>push</code> on a DArray, but I can help upstream the fin vector file if you'd like</p>",
        "id": 369932943,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687849238
    },
    {
        "content": "<p>well you have to get elements in there somehow</p>",
        "id": 369933017,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687849256
    },
    {
        "content": "<p>using <code>ofFn</code> is only suitable for static arrays</p>",
        "id": 369933117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687849279
    },
    {
        "content": "<p>\"can we have push\"<br>\n\"we have push at home\"<br>\nthe push at home: <code>.ofFn</code></p>",
        "id": 369933177,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687849292
    },
    {
        "content": "<p>Yeah. Did you have an application of DArrays where the size changes? Iirc Tomas' ArrayN also didn't really have utilities for growing.</p>",
        "id": 369933405,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687849336
    },
    {
        "content": "<p>Let me double check that though</p>",
        "id": 369933451,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687849348
    },
    {
        "content": "<p>it's a primitive operation, it should be in the file</p>",
        "id": 369933706,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687849399
    },
    {
        "content": "<p>While we are on the topic of simplifications to avoid unnecessary complexity, how do people feel about using this as the type of <code>DArray</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">`DArray sz α` is the type of [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array)</span>\n<span class=\"sd\">with size `sz`, where the element of index `i` has type `α i`.</span>\n<span class=\"sd\">This type has special support in the runtime.</span>\n\n<span class=\"sd\">An array has a size and a capacity; the size is `sz` but the capacity</span>\n<span class=\"sd\">is not observable from lean code. Arrays perform best when unshared; as long</span>\n<span class=\"sd\">as they are used \"linearly\" all updates will be performed destructively on the</span>\n<span class=\"sd\">array, so it has comparable performance to mutable arrays in imperative</span>\n<span class=\"sd\">programming languages.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">DArray</span> <span class=\"o\">(</span><span class=\"n\">sz</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Create a new array of size `sz` from a dependent function of type `∀ i : Fin sz, α i`. -/</span>\n  <span class=\"n\">ofFn</span> <span class=\"o\">::</span>\n  <span class=\"sd\">/-- A dependently typed version of `Array.get`, which returns the `i`'th element of the array. -/</span>\n  <span class=\"n\">get</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">sz</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"n\">i</span>\n</code></pre></div>",
        "id": 369936120,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687849892
    },
    {
        "content": "<p>The key point is <code>(α : Nat → Type u)</code> there</p>",
        "id": 369936200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687849907
    },
    {
        "content": "<p>does the D in DArray stand for dynamic or dependent? I thought it was for dependent</p>",
        "id": 369936577,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687849987
    },
    {
        "content": "<p>I was going to do <code>(α : Fin sz → Type u)</code> but I think this will just cause so much DTT hell it's not worth it, and you can recover the limited domain version using a type like <code>fun i =&gt; if h : i &lt; sz then α ⟨i, h⟩ else Empty</code></p>",
        "id": 369936627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687849997
    },
    {
        "content": "<p>It stands for dependent</p>",
        "id": 369936670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687850007
    },
    {
        "content": "<p>but I suppose the header doesn't make that obvious</p>",
        "id": 369936749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687850024
    },
    {
        "content": "<p>(This docstring is copied from <code>Array</code> with minor modifications)</p>",
        "id": 369936925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687850051
    },
    {
        "content": "<p>you won't have any need for <code>Fin.cons</code> if you do <code>Nat -&gt; Type u</code> :)</p>",
        "id": 369937155,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687850110
    },
    {
        "content": "<p>one of the applications i &amp; tomas have for DArray is arrays indexed by <code>FinEnum</code> types, so honestly it's probably fine to do this and then we have the finenum indexed version which you can also use to get back <code>Fin n</code> version</p>",
        "id": 369937347,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687850158
    },
    {
        "content": "<p>how is <code>FinEnum</code> defined?</p>",
        "id": 369937607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687850212
    },
    {
        "content": "<p>isomorphism with <code>Fin n</code> for some n</p>",
        "id": 369937683,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687850236
    },
    {
        "content": "<p>I guess we could have <code>DArray</code> use FinEnum as the primitive index</p>",
        "id": 369937891,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687850287
    },
    {
        "content": "<p>nope, get outta here</p>",
        "id": 369937961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687850300
    },
    {
        "content": "<p>but then push is weird :)</p>",
        "id": 369937970,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687850302
    },
    {
        "content": "<p>These function implementations are really beautiful</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[inline]</span> <span class=\"kn\">private</span> <span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">setImpl</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"n\">sz</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">sz</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"n\">sz</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">unsafeCast</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Array.set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">NonScalar</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">unsafeCast</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">unsafeCast</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">unsafeCast</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 369938700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687850467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/369936627\">said</a>:</p>\n<blockquote>\n<p>I was going to do <code>(α : Fin sz → Type u)</code> but I think this will just cause so much DTT hell it's not worth it, and you can recover the limited domain version using a type like <code>fun i =&gt; if h : i &lt; sz then α ⟨i, h⟩ else Empty</code></p>\n</blockquote>\n<p>This version will also cause DTT hell because you would need to apply a theorem <code>dif_pos</code> inside a type to know that the type of the thing stored in the array is really given by <code>α</code>.</p>",
        "id": 369941539,
        "sender_full_name": "Reid Barton",
        "timestamp": 1687851090
    },
    {
        "content": "<p>yes, but the hell is limited to those cases that actually need to use <code>Fin n</code> there</p>",
        "id": 369942169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687851216
    },
    {
        "content": "<p>The gambit here is that in most cases, you can write down the type itself without needing the <code>h</code></p>",
        "id": 369942372,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687851254
    },
    {
        "content": "<p>I think the right approach here is to try to write the programs that want to use DArray first</p>",
        "id": 369942484,
        "sender_full_name": "Reid Barton",
        "timestamp": 1687851275
    },
    {
        "content": "<p>Fair point</p>",
        "id": 369942527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687851283
    },
    {
        "content": "<p>for something like the aforementioned <code>FinEnum</code> array, I am fairly confident that the DTT hell can be confined to the implementation of the wrapper itself</p>",
        "id": 369942789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687851337
    },
    {
        "content": "<p>i agree, but only because you're never trying to change the size</p>",
        "id": 369942976,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687851371
    },
    {
        "content": "<p>if you want to change the size and you also want <code>Fin n</code> functions then you will be dealing with non-defeqs in the index type no matter what you do</p>",
        "id": 369943240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687851424
    },
    {
        "content": "<p>I don't think this is necessarily true, is it? but then the type of <code>push</code> should look like<br>\n<code>push : DArray n (α \\o Fin.cast_succ) -&gt; α \\&lt;n, _\\&gt; -&gt; DArray (n + 1) α</code></p>",
        "id": 369944886,
        "sender_full_name": "Reid Barton",
        "timestamp": 1687851732
    },
    {
        "content": "<p>yes, but you will most likely have trouble making that type work in the user code</p>",
        "id": 369945114,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687851776
    },
    {
        "content": "<p><code>α \\&lt;n, _\\&gt;</code> is unlikely to compute nicely</p>",
        "id": 369945299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687851813
    },
    {
        "content": "<p>writing well typed functions in the DArray API isn't that hard</p>",
        "id": 369945420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687851837
    },
    {
        "content": "<p>the hard part is using those types if they are too complex</p>",
        "id": 369945548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687851852
    },
    {
        "content": "<p>Well if you plan to implement <code>α \\&lt;n,h\\&gt; = f n</code> as though the API was with <code>Nat</code>, you won't have to do anything special.</p>",
        "id": 369945946,
        "sender_full_name": "Reid Barton",
        "timestamp": 1687851935
    },
    {
        "content": "<p>for one thing, you will be passing <code>f</code> into a lot of functions by hand</p>",
        "id": 369946392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687852021
    },
    {
        "content": "<p>Again I think it's kind of pointless to discuss this in the abstract, rather than writing programs (not libraries)</p>",
        "id": 369946548,
        "sender_full_name": "Reid Barton",
        "timestamp": 1687852058
    },
    {
        "content": "<p>I started to write simpler-typed versions of the <code>Fin n</code> functions along those lines, but it does simplify a lot of the code and I'd rather wait until I see the code that needs it</p>",
        "id": 369946627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687852074
    },
    {
        "content": "<p>because <code>DArray</code> is already a bit out there to me</p>",
        "id": 369946714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687852085
    },
    {
        "content": "<p>but you have to write a lot of unsafe code to get a good version working, so I'm okay with centralizing that in std</p>",
        "id": 369946959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687852130
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/369937891\">said</a>:</p>\n<blockquote>\n<p>I guess we could have <code>DArray</code> use FinEnum as the primitive index</p>\n</blockquote>\n<p>FWIW I unironically agree with this, though perhaps it should be a separate data structure (maybe one that could be implemented with DArray?)</p>",
        "id": 369950075,
        "sender_full_name": "Reid Barton",
        "timestamp": 1687852730
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> I've pushed my work to the <a href=\"https://github.com/leanprover/std4/tree/darray\"><code>darray</code></a> branch, and I have other things I need to work on, so perhaps this is a good time to hand it off and let you work on making versions of the array definitions commented out at the end of the file.</p>",
        "id": 369966462,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687855724
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/369950075\">said</a>:</p>\n<blockquote>\n<p>FWIW I unironically agree with this, though perhaps it should be a separate data structure (maybe one that could be implemented with DArray?)</p>\n</blockquote>\n<p>LeanColls does the reverse of this and reimplements dynamic arrays with static sized arrays, because the unsafe primitives for static arrays are just easier to get right. There it was pointless because there's overhead reimplementing dynamic arrays built on static arrays built on dynamic arrays <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> but maybe it would actually simplify the difficulty of getting DArray's implementation correct since you'd be able to rely on the typechecker.</p>\n<p>I'll try continuing  on the darray branch</p>",
        "id": 370120453,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687881691
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/369942484\">said</a>:</p>\n<blockquote>\n<p>I think the right approach here is to try to write the programs that want to use DArray first</p>\n</blockquote>\n<p>I strongly agree with this!</p>\n<p>The only time when I needed something like <code>DArray</code> was when I wanted to iterate over all divisors of <code>a : Nat</code>. </p>\n<p>My approach is to decompose <code>a = p₁^n₁ * ... * pₖ^nₖ</code> then define a type <a href=\"https://github.com/lecopivo/SciLean/blob/master/SciLean/Data/FinProd.lean\"><code>FinProd : List Nat → Type</code></a> taking <code>[n₁, ..., nₖ]</code> to <code>Fin n₁ × ... Fin nₖ</code>. Each element of  <code>FinProd [n₁+1, ..., nₖ+1]</code> corresponds to a divisor of <code>a</code> and it is easy to derive an instance of <code>FinEnum</code>(<code>Enumtype</code> in my code) so you can iterate over all the divisors.</p>\n<p>With <code>DArray</code> I would have to do something like  <code>DArray ns.size (fun i =&gt; Fin (ns.getD i 0))</code> where <code>ns = [n₁+1, ..., nₖ+1]</code>. In this case it would not make a sense to do <code>push</code> on such <code>DArray</code>.</p>\n<p>However,  I can imagine that I want to work with Taylor expansions for a function <code>f : X → ℝ</code>. It would be a represented as an array of elements with types<code>ℝ, X, X⊗X, X⊗X⊗X, ...</code>. Here pushing definitely makes sense.</p>\n<hr>\n<p>I would really like to have an option to index those types in <code>DArray</code> either by some finite set <code>ι</code>(no support for pushing) or by <code>Nat</code>(with support for pushing). I encountered this issue when defining a type class interface for array like types, I have <a href=\"https://github.com/lecopivo/SciLean/blob/fea6cf7d7270be9f5407a6a1f181063bebe60c63/SciLean/Data/ArrayType/GenericArrayType.lean#L51\"><code>GenericArrayType</code></a> which is an array index by some fixed type <code>Idx</code> and <a href=\"https://github.com/lecopivo/SciLean/blob/fea6cf7d7270be9f5407a6a1f181063bebe60c63/SciLean/Data/ArrayType/GenericArrayType.lean#L64\"><code>LinearGenericArrayType</code></a> which defines a class of types index by <code>Nat</code> which supports pushing.</p>",
        "id": 370190327,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1687895873
    },
    {
        "content": "<p>Note that the current <code>DArray</code> implementation is intended to be used as a low level primitive type. You get all the same benefits and performance characteristics of <code>Array</code> but where the elements can all have different types. Anything beyond that sounds suitable for a library built on top of <code>DArray</code>, which can be done fully in safe code</p>",
        "id": 370197364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687897573
    },
    {
        "content": "<p>Using it as a low level primitive makes sense.</p>",
        "id": 370200484,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1687898308
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/369942484\">said</a>:</p>\n<blockquote>\n<p>I think the right approach here is to try to write the programs that want to use DArray first</p>\n</blockquote>\n<p>I tried it, and you were right, the <code>(α : Nat → Type u)</code> version doesn't work. <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span> If you try to build the <code>(α : Fin sz → Type u)</code> version on top of it you get stuck in those <code>fun i =&gt; if h : i &lt; sz then α ⟨i, h⟩ else Empty</code> situations needing a theorem that says <code>(∀ i &lt; sz, α i = α' i) → DArray sz α = DArray sz α'</code>, which isn't provable. I reverted the <code>darray</code> branch to use <code>(α : Fin sz → Type u)</code> instead, and added some abbreviations for the more common cases:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">`DArray sz α` is the type of (dependently typed)</span>\n<span class=\"sd\">[dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array) with size `sz`,</span>\n<span class=\"sd\">where the element of index `i` has type `α i`. This type has special support in the runtime.</span>\n\n<span class=\"sd\">An array has a size and a capacity; the size is `sz` but the capacity</span>\n<span class=\"sd\">is not observable from lean code. Arrays perform best when unshared; as long</span>\n<span class=\"sd\">as they are used \"linearly\" all updates will be performed destructively on the</span>\n<span class=\"sd\">array, so it has comparable performance to mutable arrays in imperative</span>\n<span class=\"sd\">programming languages.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">DArray</span> <span class=\"o\">(</span><span class=\"n\">sz</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">sz</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Create a new array of size `sz` from a dependent function of type `∀ i : Fin sz, α i`. -/</span>\n  <span class=\"n\">ofFn</span> <span class=\"o\">::</span>\n  <span class=\"sd\">/-- A dependently typed version of `Array.get`, which returns the `i`'th element of the array. -/</span>\n  <span class=\"n\">get</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">sz</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"n\">i</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">An abbreviation for `DArray` in the special case where `α` is defined for all `i : Nat`, not</span>\n<span class=\"sd\">just `i : Fin sz`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">DNArray</span> <span class=\"o\">(</span><span class=\"n\">sz</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">DArray</span> <span class=\"n\">sz</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">An abbreviation for `DArray` in the special case where `α` is actually a constant. This is similar</span>\n<span class=\"sd\">to (and interconvertible with) `Array α`, except that `sz` is part of the type.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">CArray</span> <span class=\"o\">(</span><span class=\"n\">sz</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">DArray</span> <span class=\"n\">sz</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 370264424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687923331
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I have some time now to work on the commented out section if your updates are pushed</p>",
        "id": 370270779,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687926316
    },
    {
        "content": "<p>Is it alright if I make functions like <code>modifyM</code> take <code>Fin sz</code> instead of Nat? or was your goal to preserve the Array API as close as possible?</p>",
        "id": 370274048,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687928006
    },
    {
        "content": "<p>I think for modify I will since I can't imagine wanting the function to have any type other than <code>α i → α i</code></p>",
        "id": 370275262,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687928477
    },
    {
        "content": "<p>Another note -- I agree that the common use case is for α to remain constant across most operations where sz is constant, but I also have applications in mind where α is updated at individual indices, and I'm not sure how we plan to support that</p>",
        "id": 370275741,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687928644
    },
    {
        "content": "<p>(though, that's how you get into DTT hell... <span aria-label=\"pensive\" class=\"emoji emoji-1f614\" role=\"img\" title=\"pensive\">:pensive:</span> not really sure what to do about it)</p>",
        "id": 370277740,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687928918
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/370274048\">said</a>:</p>\n<blockquote>\n<p>Is it alright if I make functions like <code>modifyM</code> take <code>Fin sz</code> instead of Nat? or was your goal to preserve the Array API as close as possible?</p>\n</blockquote>\n<p>The pattern I have been following is that anything that does not necessarily require its input to be in bounds is translated to a <code>DNArray</code> function, and there should also be a version which has required inbounds and uses <code>DArray</code></p>",
        "id": 370280228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687929404
    },
    {
        "content": "<p>See e.g. <code>get</code> / <code>getD</code> / <code>get!</code></p>",
        "id": 370280255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687929417
    },
    {
        "content": "<p>I don't have a great naming suggestion though, maybe <code>modifyM'</code> for the out of bounds version</p>",
        "id": 370280559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687929518
    },
    {
        "content": "<p>well, this goes to my general grievance that we should stop with this unnecessary <code>get</code>/<code>getD</code>/<code>get!</code> name pollution and just return <code>Partial</code>s with <code>Partial.!</code> and <code>Partial.orDefault</code> etc defined...</p>",
        "id": 370280732,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687929586
    },
    {
        "content": "<p>but this is not the place to argue about that</p>",
        "id": 370280815,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687929607
    },
    {
        "content": "<p>indeed</p>",
        "id": 370280822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687929611
    },
    {
        "content": "<p>I think you are describing the <code>Option</code> type, and we already have that</p>",
        "id": 370280882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687929643
    },
    {
        "content": "<p>We should make a separate thread, actually, since it's probably worth discussing</p>",
        "id": 370280966,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687929677
    },
    {
        "content": "<p>But it is very important here to preserve the performance characteristics of the array functions. Only zero cost operations are allowed over the original array function</p>",
        "id": 370281035,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687929704
    },
    {
        "content": "<p>returning thunks is not an option, if that's your proposal</p>",
        "id": 370281143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687929733
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/370275741\">said</a>:</p>\n<blockquote>\n<p>Another note -- I agree that the common use case is for α to remain constant across most operations where sz is constant, but I also have applications in mind where α is updated at individual indices, and I'm not sure how we plan to support that</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> did you have thoughts about this? Many of the functions could be duplicated with <code>Function.update</code>-esque versions.</p>",
        "id": 370292217,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687933477
    },
    {
        "content": "<p>yes, that sounds fine</p>",
        "id": 370293128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687933735
    },
    {
        "content": "<p>maybe with names like <code>dSet</code>/<code>dModify</code>?? best I could come up with</p>",
        "id": 370293606,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687933851
    },
    {
        "content": "<p>they won't be the \"default\" version, of course, and we'll need a new naming convention for them. <code>setU</code>?</p>",
        "id": 370293608,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687933853
    },
    {
        "content": "<p>what does the U stand for?</p>",
        "id": 370293654,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687933866
    },
    {
        "content": "<p>update</p>",
        "id": 370293672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687933870
    },
    {
        "content": "<p>I have heard this referred to as \"strong update\"</p>",
        "id": 370293705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687933880
    },
    {
        "content": "<p>ehhhhhhhhhh i don't love it but I see the justification</p>",
        "id": 370293715,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687933883
    },
    {
        "content": "<p>that is to say, an assignment that changes the type of the referent</p>",
        "id": 370293837,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687933921
    },
    {
        "content": "<p><code>sSet</code> (strong set) has the advantage of being a homophone with ß</p>",
        "id": 370293895,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687933928
    },
    {
        "content": "<p><code>ßet</code></p>",
        "id": 370293948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687933941
    },
    {
        "content": "<p><span aria-label=\"b\" class=\"emoji emoji-1f171\" role=\"img\" title=\"b\">:b:</span>et</p>",
        "id": 370293971,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687933950
    },
    {
        "content": "<p>I think it would be <code>sset</code> if we want that name</p>",
        "id": 370294137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687933994
    },
    {
        "content": "<p>I could get behind <code>setS</code>. I wish <code>...D</code> weren't taken up as shorthand for <code>?.getD</code>, so that we could have D stand for dependent.</p>",
        "id": 370294236,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687934022
    },
    {
        "content": "<p>I'm not sure dependent is a good name though, everything is dependent</p>",
        "id": 370294376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687934045
    },
    {
        "content": "<p>yeah</p>",
        "id": 370294404,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687934052
    },
    {
        "content": "<p>of course it doesn't have to be abbreviated, e.g. <code>strongSet</code></p>",
        "id": 370294555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687934091
    },
    {
        "content": "<p>let me see if agda has a dependent array implementation somewhere</p>",
        "id": 370294566,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687934096
    },
    {
        "content": "<p>what about <code>H</code> for heterogeneous?</p>",
        "id": 370295409,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687934317
    },
    {
        "content": "<p>a la heterogeneous lists</p>",
        "id": 370295446,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687934330
    },
    {
        "content": "<p>that's no better, that's just a synonym for dependent</p>",
        "id": 370295485,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687934340
    },
    {
        "content": "<p>plus it is made worse by the fact that heterogeneous is used to mean other things in lean</p>",
        "id": 370295546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687934363
    },
    {
        "content": "<p>(it is?!)</p>",
        "id": 370295567,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687934373
    },
    {
        "content": "<p><code>HAdd</code>, <code>HEq</code></p>",
        "id": 370295617,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687934388
    },
    {
        "content": "<p>oh, but those fit the notion that heterogeneity = types are not all the same across the operation</p>",
        "id": 370295716,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687934406
    },
    {
        "content": "<p>which... isn't what is happening here</p>",
        "id": 370295781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687934420
    },
    {
        "content": "<p>in this case, the returned array does not have the same type as the argument array</p>",
        "id": 370295791,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687934423
    },
    {
        "content": "<p>that's already true of the regular <code>push</code></p>",
        "id": 370295820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687934433
    },
    {
        "content": "<p>yeah. but push doesn't have a non-heterogeneous analog <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 370295879,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687934450
    },
    {
        "content": "<p>I'm going to make an executive decision and say <code>strongSet</code> for this (and <code>strongModify</code>, <code>strongSwap</code> etc). It's a long name but it will get people to read the docs</p>",
        "id": 370296243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687934539
    },
    {
        "content": "<p>Either that or we can make a poll</p>",
        "id": 370296385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687934580
    },
    {
        "content": "<p>it seems fine to me</p>",
        "id": 370296424,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687934590
    },
    {
        "content": "<p>oh, <code>Function.update</code> is in mathlib. hm</p>",
        "id": 370297491,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687934856
    },
    {
        "content": "<p>I will delta expand for now, but I'm not sure if that has consequences for simp-ability</p>",
        "id": 370297773,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687934940
    },
    {
        "content": "<p>move <code>Function.update</code></p>",
        "id": 370298315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687935086
    },
    {
        "content": "<p><code>Std.Data.Function.Basic</code></p>",
        "id": 370298365,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687935101
    },
    {
        "content": "<p>separate PR?</p>",
        "id": 370298550,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687935143
    },
    {
        "content": "<p>this isn't a PR yet</p>",
        "id": 370298597,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687935153
    },
    {
        "content": "<p>sure, just making sure you don't mind having upstreamed stuff in the branch :)</p>",
        "id": 370298673,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687935175
    },
    {
        "content": "<p>I did Fin.Basic on the branch before rebasing / merging it to main</p>",
        "id": 370298824,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687935211
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/std4/pull/168\">std4#168</a></p>",
        "id": 370347476,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687944501
    },
    {
        "content": "<p>There's a <code>cast</code> in <code>modifyM</code> because I didn't feel like implementing it twice just to avoid the cast. But that might make proofsing a pain.</p>",
        "id": 370347865,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1687944574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/370296243\">said</a>:</p>\n<blockquote>\n<p>I'm going to make an executive decision and say <code>strongSet</code> for this (and <code>strongModify</code>, <code>strongSwap</code> etc). It's a long name but it will get people to read the docs</p>\n</blockquote>\n<p>What about <code>setT</code> (where T stands for type), since what this is doing is setting a value and updating the type? I would say those are rather long and not very informative names (the terms <code>strong</code> and <code>weak</code> generally have to do with including or excluding some check, which, imo, is something of a stretch here).</p>",
        "id": 372466459,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688534354
    },
    {
        "content": "<p>strongSet grew on me tbh</p>",
        "id": 372473737,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688537184
    },
    {
        "content": "<p>but we can poll if u want</p>",
        "id": 372473765,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688537197
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/372466459\">said</a>:</p>\n<blockquote>\n<p>(the terms <code>strong</code> and <code>weak</code> generally have to do with including or excluding some check, which, imo, is something of a stretch here)</p>\n</blockquote>\n<p>I don't think there is precedent for such meaning of the words <code>strong</code> and <code>weak</code> in lean</p>",
        "id": 372476949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688538330
    },
    {
        "content": "<p>the usage of <code>strong</code> in mathlib seems to follow the general pattern:</p>\n<ul>\n<li>On nouns / types: an object with more properties than usual</li>\n<li>On verbs / functions: an operation with fewer restrictions in the hypothesis or more properties in the consequent</li>\n</ul>\n<p>In this sense <code>strongSet</code> uses the \"fewer restrictions on hypotheses\" reading</p>",
        "id": 372477719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688538597
    },
    {
        "content": "<p>My feeling is that this use of <code>strong</code> here will not make sense to anyone else, but I also don't have a better alternative to suggest.</p>",
        "id": 372478963,
        "sender_full_name": "Reid Barton",
        "timestamp": 1688538947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/372476949\">said</a>:</p>\n<blockquote>\n<p>I don't think there is precedent for such meaning of the words <code>strong</code> and <code>weak</code> in lean</p>\n</blockquote>\n<p>I was refering to the more general CS senses of terms (e.g., strong and weak references / pointers,  strong and weak symbols, etc.)</p>",
        "id": 372495104,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688543566
    },
    {
        "content": "<p>In Haskell, these kind of operations are called \"type-changing update\"</p>",
        "id": 372495670,
        "sender_full_name": "Reid Barton",
        "timestamp": 1688543703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/372477719\">said</a>:</p>\n<blockquote>\n<p>In this sense <code>strongSet</code> uses the \"fewer restrictions on hypotheses\" reading</p>\n</blockquote>\n<p>I think it is quite a stretch to call changing the type \"fewer restrictions on hypotheses\". This is a mutation action that mutates more than just the value but also the type (EDIT: as Reid said above). It has about as much to do with hypotheses as the difference between a pure vs monadic function (i.e., it can be phrased that way, but that is not exactly the natural intuition). I think Lean's notion of heterogeneity is closer to what is going on here than strength.</p>",
        "id": 372496967,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688544028
    },
    {
        "content": "<p><code>setAndChangeType</code> (long name discourages use, which is desirable here)</p>",
        "id": 372498106,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688544317
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> I am still not sure I understand what is rational for discouraging use. A type-heterogenous mutable array seems like a generally useful alternative to the very memory-inefficient tuple product for many-element use cases.</p>",
        "id": 372498700,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688544454
    },
    {
        "content": "<p>it's a dangerous operation because it introduces <code>Function.update</code> in the type, which frequently has to be <code>cast</code> through. The common case for this type is to have different types at each index, BUT to not change those types ever. Changing the types is a pretty rare use case as far as I understand.</p>",
        "id": 372499040,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688544544
    },
    {
        "content": "<p>One use case for such a <code>DArray</code> that immediately stands out to me is for  the child nodes of a provably-correct AST parser.</p>",
        "id": 372499081,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688544561
    },
    {
        "content": "<p>Which, in the case of syntax transformations (e.g. macros) or the like very well my undergo type changing mutations.</p>",
        "id": 372499228,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688544604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/372499040\">said</a>:</p>\n<blockquote>\n<p>which frequently has to be <code>cast</code> through</p>\n</blockquote>\n<p>I remember you mentioning this before.  What is the problem with <code>cast</code>? I have found it quite useful in Lake, but maybe I am doing things wrong?</p>",
        "id": 372499582,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688544696
    },
    {
        "content": "<p>it's just hard to get rid of a <code>cast</code> when trying to prove anything about an expression that has a cast in it. I think it's usually recommended to hide the cast behind a def, and have specialized lemmas for rewriting the definition without introducing the underlying <code>cast</code> to the expression.</p>",
        "id": 372499946,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688544783
    },
    {
        "content": "<p>if you don't care about proving anything then it is ~never an issue</p>",
        "id": 372500022,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688544807
    },
    {
        "content": "<p>That sill confuses me. Isn't <code>cast h a</code> provably equal to <code>a</code> (or, more accurately <code>cast h.symm (cast h a) = a</code>)? Isn't that the whole point of cast?</p>",
        "id": 372500587,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688544936
    },
    {
        "content": "<p>only if the equality <code>h</code> can be dependently eliminated. which can be a big issue once your types get nontrivial.</p>",
        "id": 372500842,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688544989
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> I'm sorry, what does \"dependently eliminated' mean here? (Sorry, I should probably know this.)</p>",
        "id": 372501401,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688545115
    },
    {
        "content": "<p>for all i know it could be a source of incompleteness in Lean; there's been times when i had a <code>cast</code> in my goal and simply couldn't proceed after bashing my head at it, until I gave up and redesigned everything to avoid casting <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>",
        "id": 372501465,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688545130
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/372501401\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> I'm sorry, what does \"dependently eliminated' mean here? (Sorry, I should probably know this.)</p>\n</blockquote>\n<p>I think it's roughly that there's some substitution of variables in the context  such that the equality is defeq??? but someone should fact check me</p>",
        "id": 372501699,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688545199
    },
    {
        "content": "<p>i know <code>v = f x</code> can be dependently eliminated by substituting <code>[f x / v]</code>, while <code>f x = g y</code> generally can't be eliminated :P</p>",
        "id": 372501899,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688545244
    },
    {
        "content": "<p>definitely worth trying to prove some stuff with casts in it. the frustration left quite an impact on me</p>",
        "id": 372502105,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688545291
    },
    {
        "content": "<p>Oh, giving the basic example I wrote above <code>cast h.symm (cast h a) = a</code> a try, I think I might understand where the problem comes. Since type equality/inequality is generally independent of Lean's theory, proving things about casts likely requires more axioms (just like proving things about types often does). Thus, doing so poses the risk of introducing inconsistent into the axiom set of Lean.</p>",
        "id": 372504134,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688545741
    },
    {
        "content": "<p>That should be <code>cases h; rfl</code></p>",
        "id": 372505131,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1688545942
    },
    {
        "content": "<p>well the thing is all casts can be proven propositionally to be correct, cuz you have the proof <code>h</code>. so the type equality given by <code>h</code> is always provable in Lean DTT. but the cast can only be eliminated if it's defeq, which is obviously much more restrictive. Usually I think you can turn a propositional equality into a definitional one by carefully generalizing the goal, but I don't know how to always do it in general (or whether it's always possible)</p>",
        "id": 372506510,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688546237
    },
    {
        "content": "<p>Yep, that does work here. But I realized through the effort that the type equality of cast is probably often hard to eliminate and that it does not help you determine what the constructed result of the cast is in the target type.</p>",
        "id": 372506595,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688546263
    },
    {
        "content": "<p>The simplest, general way to perform this elimination does seem like it might be by a reverse cast.</p>",
        "id": 372506933,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688546340
    },
    {
        "content": "<p>Or by usual general solutions that can treat it as a variable e.g. induction on the result.</p>",
        "id": 372507297,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688546417
    },
    {
        "content": "<p>yep. but if the cast term is an argument to another function (a common case) then you can't just apply the reverse cast on both sides, and if the type is parametric you can't induct on it. so it's very very easy to hit a case where something just becomes very difficult to prove. thus, lots of lemmas to circumvent introducing <code>cast</code> in the goal!</p>",
        "id": 372507560,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688546480
    },
    {
        "content": "<p>The reverse cast is probably sufficient for my example use cases in Lake where casting is mediated by an opaque type in between so all casts are essentially guaranteed to have both a to and and a from (e.g., <code>toFamily</code>/<code>ofFamily</code> for Lake's open types).</p>",
        "id": 372507991,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688546572
    },
    {
        "content": "<p>I imagine this might even be more generally true for many dependent data-structure use cases of <code>cast</code>, where you often cast to some unwieldy type on a set (e.g., the <code>\\b</code> function of Lake's <code>DRBMap</code> or the <code>\\a</code> function of a <code>DArray</code>) and then cast back from it on a get.</p>",
        "id": 372508823,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688546747
    },
    {
        "content": "<p>anyways, let's do a poll!</p>",
        "id": 372508960,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688546769
    },
    {
        "content": "<p>/poll What to name the type-changing set function? (and other modifying operations)<br>\n<code>strongSet</code> (a stronger operation!)<br>\n<code>setStrong</code> (an operation, but stronger!)<br>\n<code>setT</code> (<strong>T</strong>ypechanging)<br>\n<code>setH</code> (<strong>H</strong>eterogeneous)<br>\n<code>setAndChangeType</code> (descriptive!)<br>\n<code>setPoly</code> (now with extra polymorphism)</p>",
        "id": 372508970,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688546772
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> If we do lean towards the descriptive <code>setAndChangeType</code>, I wonder if we could go for something a bit shorter like <code>setWithType</code>. (I will add it to the poll, but it may be a bit late as people have already voted.)</p>",
        "id": 372690189,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688583822
    },
    {
        "content": "<p>I am actually curious to hear any practical application of dependent arrays.</p>",
        "id": 372693196,
        "sender_full_name": "Reid Barton",
        "timestamp": 1688584597
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> My example above was for the children of (provably) well-formed nodes of a syntax tree.</p>",
        "id": 372693439,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688584668
    },
    {
        "content": "<p>Why not use a structure?</p>",
        "id": 372693664,
        "sender_full_name": "Reid Barton",
        "timestamp": 1688584719
    },
    {
        "content": "<p>My application is to have a concrete/efficient implementation of <code>(i : Fin n) -&gt; tau i</code>.</p>",
        "id": 372694110,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688584830
    },
    {
        "content": "<p>I understand that much of course but what is <code>tau</code>, i.e., what is it for.</p>",
        "id": 372694243,
        "sender_full_name": "Reid Barton",
        "timestamp": 1688584869
    },
    {
        "content": "<p>I've never used a language that had dependent arrays so I can't easily think of problems where they would be useful.</p>",
        "id": 372694334,
        "sender_full_name": "Reid Barton",
        "timestamp": 1688584891
    },
    {
        "content": "<p>right now in a project I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Coords</span> <span class=\"o\">(</span><span class=\"n\">sz</span> <span class=\"o\">:</span> <span class=\"n\">Dim</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">FIArray</span> <span class=\"n\">Dim</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">hval</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">val</span><span class=\"o\">[</span><span class=\"n\">d</span><span class=\"o\">]</span> <span class=\"bp\">&lt;</span> <span class=\"n\">sz</span> <span class=\"n\">d</span>\n</code></pre></div>\n<p>where <code>FIArray</code> is a finenum-indexed array and <code>Dim</code> is <code>FinEnum</code>. I had to write a bunch of wrapper functions to convert to/from <code>Fin (sz d)</code> which was a pain.</p>",
        "id": 372694622,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688584972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/372693664\">said</a>:</p>\n<blockquote>\n<p>Why not use a structure?</p>\n</blockquote>\n<p>A couple of reasons:</p>\n<ol>\n<li>The well-formedness may be layered over an existing simple representation (e.g., Lean's <code>Syntax</code>)</li>\n<li>You would need a structure for each node kind and an inductive to wrap them all up, but that inductive may be impossible to construct if syntax can be defined lazily (like in Lean).</li>\n<li>Since the syntax can be built up step-by-step by sequential parsers, you need some representation for the intermediate steps. A well-formed heterogenous array seems like the best option there.</li>\n</ol>",
        "id": 372694643,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688584977
    },
    {
        "content": "<p>Yes the main example that comes to mind is that you have a different predicate on each element of an array of some plain type. I'm not convinced it isn't better dealt with in the way you already have.</p>",
        "id": 372694960,
        "sender_full_name": "Reid Barton",
        "timestamp": 1688585063
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> They could be useful for randomly sampling pi types (setup: the domain is a <code>FinEnum</code> and each fiber is sampleable), and you need some kind of data to store the sampled values per index. It could be done as an array of sigma types, but (1) you don't really need to store the pairs since you know from the pi type what the types are supposed to be and (2) it <em>might</em> be useful having an API deal with dependent type issues from indexing and inferring the elements have the expected type.</p>",
        "id": 372695366,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1688585184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/372694960\">said</a>:</p>\n<blockquote>\n<p>I'm not convinced it isn't better dealt with in the way you already have.</p>\n</blockquote>\n<p>I do not know what you mean by this? What way?</p>",
        "id": 372695594,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688585251
    },
    {
        "content": "<p>Exactly as an ordinary array combined with a proof about each element of the array.</p>",
        "id": 372695670,
        "sender_full_name": "Reid Barton",
        "timestamp": 1688585275
    },
    {
        "content": "<p>I also want to use them in combination with the fully under-defined type <code>Uninit</code>to have partially-initialized arrays as a primitive, which is a pretty neat use. Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[implemented_by Darray.uninitUnsafe]</span>\n<span class=\"kd\">def</span> <span class=\"n\">DArray.uninit</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DArray</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Uninit</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>I think this is a notable example because you sorta <em>can't</em> do it as a structure without introducing some overhead in the form of sigma types (as Kyle brought up).</p>",
        "id": 372695680,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688585278
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/372695670\">said</a>:</p>\n<blockquote>\n<p>Exactly as an ordinary array combined with a proof about each element of the array.</p>\n</blockquote>\n<p>Isn't essentially what <code>DArray</code> is? An array with a known size and function predicate that provides proof about the type of each element of the array?</p>",
        "id": 372696132,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688585405
    },
    {
        "content": "<p>Not really; for example the first element of the array might be a float and the second one might be a function.</p>",
        "id": 372696233,
        "sender_full_name": "Reid Barton",
        "timestamp": 1688585434
    },
    {
        "content": "<p>I think Reid's point is that if the elements are all subtypes of the same concrete type then there's other simple ways to do it.</p>",
        "id": 372696261,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688585444
    },
    {
        "content": "<p>But I think there's enough examples where this genuinely saves overhead, and I also think not having to reimplement functions to get into and out of subtypes is nice.</p>",
        "id": 372696405,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688585493
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> Oh, I'm curious, what would be the simpler solution?</p>",
        "id": 372696415,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688585498
    },
    {
        "content": "<p>I think Kyle's example makes sense to me though.</p>",
        "id": 372696433,
        "sender_full_name": "Reid Barton",
        "timestamp": 1688585505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/372696415\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> Oh, I'm curious, what would be the simpler solution.</p>\n</blockquote>\n<p><a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/372694622\">https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/Fin.20basics/near/372694622</a></p>",
        "id": 372696471,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688585518
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> I am not seeing how that example translates to my use case.</p>",
        "id": 372696718,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688585580
    },
    {
        "content": "<p>It doesn't. There are applications where this doesn't work (i.e. when your array is not subtypes of the same type).</p>",
        "id": 372696807,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688585609
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> My question is, I still don't see how that translates even when they are of the same type.</p>",
        "id": 372696912,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688585642
    },
    {
        "content": "<p>How would I use that provide a different subtype predicate about each element of an array? For instance, for the simple syntax \"a + b\" where arr[0] and arr[2] are ident subtypes of <code>Syntax</code>, ar[1] is a + atom subtype of <code>Syntax</code>.</p>",
        "id": 372697779,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688585912
    },
    {
        "content": "<p>You can parametrize by a indexed predicate <code>P : Fin n -&gt; tau -&gt; Prop</code> and require that <code>P i backing[i]</code> for all <code>i</code>, if that makes sense.</p>",
        "id": 372698369,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688586079
    },
    {
        "content": "<p>In your case <code>tau = Syntax</code> and <code>P</code> describes the type of all the syntax objects.</p>",
        "id": 372698631,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688586169
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/372698369\">said</a>:</p>\n<blockquote>\n<p>You can parametrize by a indexed predicate <code>P : Fin n -&gt; tau -&gt; Prop</code> and require that <code>P i backing[i]</code> for all <code>i</code>, if that makes sense.</p>\n</blockquote>\n<p>True, but that does mean I just have to write my own custom Array type to support this (backed by <code>Array</code>), which seems mighty inconvenient as opposed to a general case already supported by Std.</p>",
        "id": 372700123,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688586645
    },
    {
        "content": "<p>Right so in this case the \"raw\" data is <code>Syntax</code>, rather than <code>Array Nat</code> or whatever. The generic version of the approach is to \"store\" a proposition stating that the data is \"well-formed\" alongside the raw data, rather than baked deeply into its type.</p>",
        "id": 372703109,
        "sender_full_name": "Reid Barton",
        "timestamp": 1688587605
    },
    {
        "content": "<p>One concrete advantage is that it's much more efficient when you have to cross a boundary between working with well-typed vs. raw data (since you don't have to copy the actual data part), or considering different amounts of well-formedness.</p>",
        "id": 372703926,
        "sender_full_name": "Reid Barton",
        "timestamp": 1688587865
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/372703109\">said</a>:</p>\n<blockquote>\n<p>Right so in this case the \"raw\" data is <code>Syntax</code>, rather than <code>Array Nat</code> or whatever. </p>\n</blockquote>\n<p>While this is true generally, this does not work while constructing the <code>Syntax</code>. The parser will build up an well-formed array of syntax that it will then convert into a well-formed <code>Syntax.node</code>. In order to create that well-formed node, the <code>Array</code> needs to carry proofs that its elements are proper constituents (and those  elements themselves need to carry the information that they are well-formed).</p>",
        "id": 372709309,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688589586
    },
    {
        "content": "<p>To me, the most obvious way to do this is to have some <code>Node</code> typeclass that constructs a well-formed node from a <code>DArray</code>-like well-formed array of children that was built up by the parser combinators.</p>",
        "id": 372709609,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688589681
    },
    {
        "content": "<p>It should work fine. The parser also simultaneously builds a proof that the <code>Array</code> is well-formed and then this proof is returned together with the <code>Syntax</code> to the parent node which uses it to build its own proof of well-formedness, recursively.</p>",
        "id": 372710703,
        "sender_full_name": "Reid Barton",
        "timestamp": 1688590068
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/372710703\">said</a>:</p>\n<blockquote>\n<p>The parser also simultaneously builds a proof that the <code>Array</code> is well-formed,</p>\n</blockquote>\n<p>How is building an array with a proof significantly different / more user-friendly than just building a <code>DArray</code> (or the like)?</p>",
        "id": 372745364,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688607387
    },
    {
        "content": "<p>E.g., the parser combinators still need to carry this information in the type because the components do not know what kind of node they are building only that they are building an array and that its elements are well-formed version of whatever type of syntax (e.g., <code>Ident</code>, <code>NumLit</code>, etc.).</p>",
        "id": 372745468,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688607480
    },
    {
        "content": "<p>You can still wrap that pair of (untyped data, well formedness proof) into a new type and have your parser combinators manipulate it as a unit</p>",
        "id": 372747750,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688608908
    },
    {
        "content": "<p>the point is that afterwards you get more flexibility to change the proof to a different kind of well formedness proof or get at the untyped data without having to deep copy everything</p>",
        "id": 372747883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688608964
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> While looking into lake refactoring stuff, I noticed that Mac is using a dependent hashmap in a fairly essential way. I'm curious what you think about it. The main \"entry point\" is <a href=\"https://github.com/leanprover/lake/blob/efbcaa0ec894c5ea48c627576bcbb1c7e74d37b6/Lake/Config/Package.lean#L197-L198\">here</a>, it's storing a map where key <code>n : Name</code> maps to an opaque family <code>F n : Type</code>. This is later manipulated by using axioms of the form <code>axiom : F `foo = Nat</code>, <code>axiom : F `bar = IO Unit</code> etc which are declared on the fly using (things that unfold to) the <code>family_def</code> macro, e.g. <a href=\"https://github.com/leanprover/lake/blob/master/Lake/Build/Facets.lean#L69-L86\">here</a></p>",
        "id": 372748542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688609380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/348111-std4/topic/Fin.20basics/near/372747750\">said</a>:</p>\n<blockquote>\n<p>You can still wrap that pair of (untyped data, well formedness proof) into a new type and have your parser combinators manipulate it as a unit</p>\n</blockquote>\n<p>Yeah, I agree with that. The problem is building up an array of those (untyped data, well formedness proof) type units.  James suggestion of (untyped data array, well formed proof predicate) seems like the correct solution also. My understanding is that later combo is much the same as <code>DArray</code> except <code>DArray</code> is more general. Thus, using <code>DArray</code> seems better than just rolling one's own. Maybe I misunderstood somewhere?</p>",
        "id": 372764067,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688617206
    },
    {
        "content": "<p>you wouldn't build up an array of such directly, you would unpack the data and the proof, array up the data and make a composite proof depending on the array</p>",
        "id": 372765849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688618264
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Huh? I do not get what you mean by that.</p>",
        "id": 372765931,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688618314
    },
    {
        "content": "<p>In the end you get something with roughly the same API as an intrinsically dependently typed version, but it is actually implemented to bubble out all the proof stuff separate from the data</p>",
        "id": 372765945,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688618325
    },
    {
        "content": "<p>maybe you can give a concrete example and I can demonstrate?</p>",
        "id": 372765993,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688618348
    },
    {
        "content": "<p>Note that this technique is limited to cases where the actual data is uniformly typed, while <code>DArray</code> handles the case where each element is a different type. But this is a rare use case and it's one of the reasons lean has a crappy ABI in the first place so I think we would want to avoid it in the long term</p>",
        "id": 372766187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688618489
    },
    {
        "content": "<p>Here is a simplified pseudocode example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Ident</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">//</span> <span class=\"n\">stx.isIdent</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">Plus</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">//</span> <span class=\"n\">stx</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">atom</span> <span class=\"s2\">\"+\"</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">WfAdd</span> <span class=\"o\">(</span><span class=\"n\">stx</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"bp\">`</span><span class=\"n\">add</span> <span class=\"n\">args</span> <span class=\"bp\">/\\</span>\n  <span class=\"n\">args.size</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"bp\">/\\</span> <span class=\"n\">args</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">isIdent</span> <span class=\"bp\">/\\</span> <span class=\"n\">args</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">atom</span> <span class=\"s2\">\"+\"</span> <span class=\"bp\">/\\</span> <span class=\"n\">args</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">isIdent</span>\n<span class=\"kd\">def</span> <span class=\"n\">Add</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">//</span> <span class=\"n\">WfAdd</span> <span class=\"n\">stx</span> <span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">WfNode</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Syntax</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"n\">add</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">WfAdd</span>\n<span class=\"bp\">|</span> <span class=\"bp\">-</span> <span class=\"bp\">...</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Node</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">//</span> <span class=\"n\">WfNode</span> <span class=\"n\">k</span> <span class=\"n\">stx</span><span class=\"o\">}</span>\n<span class=\"kd\">class</span> <span class=\"n\">MkNode</span> <span class=\"o\">(</span><span class=\"n\">kind</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">args</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n   <span class=\"n\">mkNode</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Node</span> <span class=\"n\">kind</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">MkNode</span> <span class=\"bp\">`</span><span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">Ident</span> <span class=\"n\">X</span> <span class=\"n\">Plus</span> <span class=\"n\">X</span> <span class=\"n\">Ident</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">mkNode</span> <span class=\"o\">((</span><span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">hl</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">plus</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">rhs</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">))</span> <span class=\"o\">:=</span>  <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"bp\">`</span><span class=\"n\">add</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">plus</span><span class=\"o\">,</span> <span class=\"n\">rhs</span><span class=\"o\">],</span> <span class=\"kd\">by</span> <span class=\"bp\">...</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HAndThen</span>  <span class=\"o\">(</span><span class=\"n\">Parsec</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Parsec</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Parsec</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">X</span> <span class=\"n\">B</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">hAndThen</span> <span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">&lt;-</span> <span class=\"n\">p1</span><span class=\"o\">,</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">p2</span> <span class=\"o\">())</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">Ident</span> <span class=\"o\">:=</span> <span class=\"c1\">-- ...</span>\n<span class=\"kd\">def</span> <span class=\"n\">plus</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">Plus</span> <span class=\"o\">:=</span> <span class=\"c1\">-- ...</span>\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">Add</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mkNode</span> <span class=\"bp\">`</span><span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">ident</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">plus</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">ident</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 372766865,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688618879
    },
    {
        "content": "<p>there are some missing imports, I get errors all over the place</p>",
        "id": 372767885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688619464
    },
    {
        "content": "<p>Hence \"pseudocode\" <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 372767991,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688619491
    },
    {
        "content": "<p>If you want, I can work on making a proper <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, but I'll probably post that tomorrow.</p>",
        "id": 372768177,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688619600
    },
    {
        "content": "<p>here's my closest attempt at a MWE version</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"o\">(</span><span class=\"n\">Name</span><span class=\"o\">)</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">Foo</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Syntax</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">Syntax.isIdent</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Ident</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">//</span> <span class=\"n\">stx.isIdent</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">Plus</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">//</span> <span class=\"n\">stx</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">atom</span> <span class=\"s2\">\"+\"</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">WfAdd</span> <span class=\"o\">(</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">args</span><span class=\"o\">,</span> <span class=\"n\">stx</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"bp\">`</span><span class=\"n\">add</span> <span class=\"n\">args</span> <span class=\"bp\">/\\</span>\n  <span class=\"n\">args.size</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"bp\">/\\</span> <span class=\"n\">args</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">!.</span><span class=\"n\">isIdent</span> <span class=\"bp\">/\\</span> <span class=\"n\">args</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">!</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">atom</span> <span class=\"s2\">\"+\"</span> <span class=\"bp\">/\\</span> <span class=\"n\">args</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">!.</span><span class=\"n\">isIdent</span>\n<span class=\"kd\">def</span> <span class=\"n\">WfNode</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"bp\">→</span> <span class=\"n\">Syntax</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"n\">add</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">WfAdd</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Node</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">//</span> <span class=\"n\">WfNode</span> <span class=\"n\">k</span> <span class=\"n\">stx</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">Add</span> <span class=\"o\">:=</span> <span class=\"n\">Node</span> <span class=\"bp\">`</span><span class=\"n\">add</span>\n<span class=\"kd\">class</span> <span class=\"n\">MkNode</span> <span class=\"o\">(</span><span class=\"n\">kind</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n   <span class=\"n\">mkNode</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">Node</span> <span class=\"n\">kind</span>\n<span class=\"kn\">open</span> <span class=\"n\">MkNode</span> <span class=\"o\">(</span><span class=\"n\">mkNode</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">MkNode</span> <span class=\"bp\">`</span><span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">Ident</span> <span class=\"bp\">×</span> <span class=\"n\">Plus</span> <span class=\"bp\">×</span> <span class=\"n\">Ident</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">mkNode</span> <span class=\"bp\">|</span> <span class=\"o\">(⟨</span><span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">hl</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">plus</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">rhs</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">⟩)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"bp\">`</span><span class=\"n\">add</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">plus</span><span class=\"o\">,</span> <span class=\"n\">rhs</span><span class=\"o\">],</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Parsec</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instMonadParsec</span> <span class=\"o\">:</span> <span class=\"n\">Monad</span> <span class=\"n\">Parsec</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HAndThen</span> <span class=\"o\">(</span><span class=\"n\">Parsec</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Parsec</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Parsec</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">hAndThen</span> <span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"o\">:=</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">p1</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">p2</span> <span class=\"o\">())</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">Ident</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">plus</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">Plus</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">Add</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mkNode</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"o\">(</span><span class=\"n\">ident</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">plus</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">ident</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 372769484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688620122
    },
    {
        "content": "<p>That's pretty good, but I would structure it a bit more like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"o\">(</span><span class=\"n\">Name</span><span class=\"o\">)</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">Foo</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Syntax</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">ident</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Syntax.IsIdent</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsIdent</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ident</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Syntax.IsAtom</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">IsAtom</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">atom</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Syntax.IsExpr</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">IsIdent</span> <span class=\"n\">stx</span> <span class=\"bp\">→</span> <span class=\"n\">IsExpr</span> <span class=\"n\">stx</span>\n  <span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">IsExpr</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">IsAtom</span> <span class=\"s2\">\"+\"</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">IsExpr</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">IsExpr</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"bp\">`</span><span class=\"n\">add</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">])</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Ident</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">//</span> <span class=\"n\">stx.IsIdent</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">Atom</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">//</span> <span class=\"n\">stx.IsAtom</span> <span class=\"n\">k</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">//</span> <span class=\"n\">stx.IsExpr</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">Ident</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">stx</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">stx</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">ident</span> <span class=\"n\">h</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Parsec</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"gr\">sorry</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">Parsec</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Monad</span> <span class=\"n\">Parsec</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Alternative</span> <span class=\"n\">Parsec</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HAndThen</span> <span class=\"o\">(</span><span class=\"n\">Parsec</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Parsec</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Parsec</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">hAndThen</span> <span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"o\">:=</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">p1</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">p2</span> <span class=\"o\">())</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">atom</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"o\">(</span><span class=\"n\">Atom</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">Ident</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">str</span><span class=\"bp\">;</span> <span class=\"n\">return</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">s</span><span class=\"o\">⟩</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">expr</span> <span class=\"o\">:</span> <span class=\"n\">Parsec</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">))</span> <span class=\"bp\">&lt;|&gt;</span>\n  <span class=\"o\">(</span><span class=\"n\">return</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">expr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">atom</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">expr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">⟩)</span>\n</code></pre></div>",
        "id": 372771461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688621074
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Cool! <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span>   However, that version does not use <code>&gt;&gt;</code> for joining parsers, which is a major disadvantage when e.g. translating from <code>syntax</code>.</p>",
        "id": 372967673,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688662928
    },
    {
        "content": "<p>It is possible to write an instance to make <code>&gt;&gt;</code> work, I just didn't see the point because it involves an extra <code>MkNode</code> instance that is used in exactly one place, so my instinct is to not create a useless indirection. Ideally, if you were translating from syntax, there would be a macro that just mines the declarations themselves to construct both the inductive type <code>IsExpr</code> as well as the <code>expr</code> parser. If it's being done manually, I think one line for the inductive and one line for the parser is a quite reasonable overhead. Maintaining syntactic parity with the untyped formulation wasn't really a goal in the first place.</p>",
        "id": 373027212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688679940
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I can understand that logic. Obviously, in a real example, there would be more than one node kind and nodes may also be constructed manually outside the parser, so the <code>MkNode</code> is more useful. One thing I did notice while looking through the example more is that this assumes the syntax of a well-formed entirely determined by its well-formedness. In a real example, the syntax would also have non-determined information (e.g., <code>SourceInfo</code>), so the code would still need to construct the array as well as the proof in the node -- making the lack of utilities like <code>&gt;&gt;</code> more inconvenient.</p>",
        "id": 373031568,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688681610
    },
    {
        "content": "<p>The presence of <code>SourceInfo</code> is actually exactly why I wrote it with <code>IsAtom k</code> which is just a singleton instead of inlining <code>.atom \"+\"</code> for <code>b</code> in <code>IsExpr.add</code></p>",
        "id": 373075645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688703955
    },
    {
        "content": "<p>there can be other arguments to the function determined by other monadic things</p>",
        "id": 373075737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688704011
    },
    {
        "content": "<p>I am not sure of the details since <code>Parsec</code> isn't defined in this MWE</p>",
        "id": 373075779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688704033
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Just FYI, I was using <code>Parsec</code> to invoke something e.g. <code>Lean.Data.Parsec</code>-like.</p>",
        "id": 373112300,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688716494
    },
    {
        "content": "<p>I know</p>",
        "id": 373112342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688716501
    },
    {
        "content": "<p>but the details affect how exactly you would write these things</p>",
        "id": 373112409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688716524
    },
    {
        "content": "<p>or what is the least cumbersome thing</p>",
        "id": 373112471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688716538
    },
    {
        "content": "<p>Makes sense.</p>",
        "id": 373113281,
        "sender_full_name": "Mac Malone",
        "timestamp": 1688716719
    }
]