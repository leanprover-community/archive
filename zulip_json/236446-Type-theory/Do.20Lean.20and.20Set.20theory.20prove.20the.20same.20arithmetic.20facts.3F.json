[
    {
        "content": "<p>We know Lean (with the 3 axioms) is equiconsistent with ZFC + {there are n inaccessibles | n &lt; ω} by Mario's thesis (and Sebastian's dissertation on Lean 4).  But what do we know about the stronger claim that they have the same provable theorems of arithmetic?  For now, let's talk about first order theorems in the language of Peano Arithmetic, but if those are the same, we can address higher order <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"normal\">Π</mi><mi>n</mi><mi>k</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">\\Pi^k_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0961em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord\">Π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-2.453em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span> theorems.  Does Mario's set theoretic interpretation say anything obvious about this?  (I've sort of took it for granted that this is true, and <a href=\"https://proofassistants.stackexchange.com/a/2385\">said it at least one place online</a>, but now I'm second guessing myself, and despite being trained as a logician and having a proof theorist as an advisor, I'm sort of bad at this stuff.)</p>",
        "id": 565894051,
        "sender_full_name": "Jason Rute",
        "timestamp": 1767184931
    },
    {
        "content": "<p>Wait, does the proof go like this?  Take a formula phi provable in ZFC plus n innaccessibles.  Then in Lean make a model of it where Nat in the model is isomorphic to Nat in Lean.   So we have a proof in Lean that phi holds of Nat.  conversely, do the same constructing models of Lean + n universes in ZFC plus n+1 (or more) innaccessibles.  This works right?</p>",
        "id": 565927297,
        "sender_full_name": "Jason Rute",
        "timestamp": 1767210051
    },
    {
        "content": "<p>This is true because the equiconsistency goes via modeling one inside the other, and these models keep isomorphic natural numbers. (I am not imagining building a model of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span></span></span></span>) For example, we have a class-size model of Lean inside ZFC+inaccessibles. The natural numbers inside (let's call them <code>ℕ</code>) are isomorphic to the standard <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span> in ZFC. So every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span></span></span></span> about <code>ℕ</code> which is provable in Lean must be true in the model by a proof in ZFC (these class-sized models translate provability), and by isomorphism provable about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span> in ZFC.</p>",
        "id": 565940387,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1767224153
    },
    {
        "content": "<p>I think we are in agreement.  I hadn’t considered class models.  That simplifies things a bit.  Otherwise you just need a model big enough to model enough axioms (or deduction rule instances) to prove phi (and make it so that the isomorphism holds).  I assume you are also implying we need to run your argument both ways, i.e. building a model of ZFC plus inaccessibles in Lean.  I don’t know what the Lean analogue of a class model would be?  (A universe polymorphic model like <code>ZFSet.{u}</code>?)  But regardless, if needed we again can use a slightly smaller model which is large enough to prove phi.)</p>\n<p>And this approach seems really general in that it works for any sufficiently strong “set theory” or “set-like” type theory.   I think this also works for any level of the hyper-arithmetic hierarchy, i.e. a Pi^k_n sentence, but maybe I am missing something subtle.</p>",
        "id": 565945479,
        "sender_full_name": "Jason Rute",
        "timestamp": 1767232199
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Do.20Lean.20and.20Set.20theory.20prove.20the.20same.20arithmetic.20facts.3F/near/565945479\">said</a>:</p>\n<blockquote>\n<p>I don’t know what the Lean analogue of a class model would be?</p>\n</blockquote>\n<p>You don't really need a Lean analog of a class model because you don't need to build a model of ZFC + {\"there are n inaccessible cardinals\" : n &lt; ω} all at once. Any given arithmetic consequence of that theory is provable from ZFC + \"there are n inaccessible cardinals\" for some n (depending on the statement). For each n, you can build an arithmetically standard 'small' model of this theory in Lean, so any arithmetic consequence of the full theory is provable in Lean.</p>",
        "id": 565948632,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767236956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Do.20Lean.20and.20Set.20theory.20prove.20the.20same.20arithmetic.20facts.3F/near/565945479\">said</a>:</p>\n<blockquote>\n<p>I think this also works for any level of the hyper-arithmetic hierarchy, i.e. a Pi^k_n sentence, but maybe I am missing something subtle.</p>\n</blockquote>\n<p>You should actually be able to prove a lot more than this. Given any first-order language <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">L</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{L}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\">L</span></span></span></span> and any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">L</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{L}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\">L</span></span></span></span>-structure <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> that is definable in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">Z</mi><mi mathvariant=\"sans-serif\">F</mi><mi mathvariant=\"sans-serif\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{ZFC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">ZFC</span></span></span></span></span> and provably unique up to unique isomorphism, Lean and the relevant version of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">Z</mi><mi mathvariant=\"sans-serif\">F</mi><mi mathvariant=\"sans-serif\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{ZFC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">ZFC</span></span></span></span></span> will prove the same statements about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> in \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> th-order logic\" for any definable ordinal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span>.</p>",
        "id": 565948761,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767237180
    },
    {
        "content": "<p>Note though that this is specifically not including theorems whose statements include <code>Classical.choice</code> (even if the proof might).</p>",
        "id": 565948813,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767237293
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Do.20Lean.20and.20Set.20theory.20prove.20the.20same.20arithmetic.20facts.3F/near/565948761\">said</a>:</p>\n<blockquote>\n<p>You should actually be able to prove a lot more than this. Given any first-order language <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">L</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{L}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\">L</span></span></span></span> and any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">L</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{L}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\">L</span></span></span></span>-structure <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> that is definable in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">Z</mi><mi mathvariant=\"sans-serif\">F</mi><mi mathvariant=\"sans-serif\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{ZFC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">ZFC</span></span></span></span></span> and provably unique up to unique isomorphism, Lean and the relevant version of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">Z</mi><mi mathvariant=\"sans-serif\">F</mi><mi mathvariant=\"sans-serif\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{ZFC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">ZFC</span></span></span></span></span> will prove the same statements about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> in \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> th-order logic\" for any definable ordinal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span>.</p>\n</blockquote>\n<p>I would try to phrase it as an isomorphism between a specific Lean structure (the Lean structure is a bit missing in that statement), and ZFC-structure. For example, Lean has <code>Real</code> defined in some way, we can define it also in ZFC in another way (say through dedekind cuts), but because the pure-ZFC construction will be isomorphic with the Lean-model construction in ZFC, and vice versa the ZFC construction in a Lean model of ZFC will be isomorphic through Lean with <code>Real</code>.</p>",
        "id": 565964443,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1767258638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Do.20Lean.20and.20Set.20theory.20prove.20the.20same.20arithmetic.20facts.3F/near/565948813\">said</a>:</p>\n<blockquote>\n<p>Note though that this is specifically not including theorems whose statements include <code>Classical.choice</code> (even if the proof might).</p>\n</blockquote>\n<p>This can be a bit more subtle. Excluding all uses of <code>choice</code> is a bit too harsh because unique choice should be allowed, and Lean currently doesn't care about the distinction of unique choice &amp; choice at all.  We were  <a href=\"#narrow/channel/113488-general/topic/Fintype.20vs.2E.20Finite/near/560666497\">discussing</a>) that there could be perhaps a keyword <code>arbitrary</code> in the future denoting that an arbitrary choice was made in the definition but it is still a little tricky:</p>\n<ul>\n<li>Arbitrary choice doesn't matter if it hidden in a proof</li>\n<li>There is no way to make <code>Ordinal.ToType</code> or <code>Cardinal.out</code>non-arbitrary in Lean due to universe constraints (although it doesn't feel like making arbitrary choices).</li>\n<li><code>choice</code> is sometimes used for dummy values (for example in <code>limUnder</code>) which is unfortunate. If Lean starts caring about arbitrary definitions at some point, it should perhaps reconsider such cases</li>\n</ul>",
        "id": 565965007,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1767259343
    },
    {
        "content": "<p>I decided to open a dedicated thread about <a href=\"#narrow/channel/113488-general/topic/marking.20definitions.20as.20aritrary/near/565967158\">arbitrary definitions</a>. It is a complex topic on its own.</p>",
        "id": 565967949,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1767262874
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Do.20Lean.20and.20Set.20theory.20prove.20the.20same.20arithmetic.20facts.3F/near/565965007\">said</a>:</p>\n<blockquote>\n<p>This can be a bit more subtle.</p>\n</blockquote>\n<p>Okay then I think the best approach would be to think of <code>Classical.choice</code> as a parameter on the ZFC side.</p>",
        "id": 565999027,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767300332
    }
]