[
    {
        "content": "<p>For a proposition inductive type to have large elimination it needs to \"clearly\" have at most 1 instance, clearly basically meaning that all of its arguments are propositions, which are guaranteed to be subsingletons by lean's type theory. It's also not difficult to fill these 2 sorries by splitting to the case that <code>α</code> is empty and the case it is not, proving large elimination for subsingletons that are not propositions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Foo</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">rec</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ∀ {α : Type} {motive : Foo α → Prop}, (∀ (a : α), motive (Foo.c a)) → ∀ (t : Foo α), motive t</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">betterRec</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">betterRec</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But splitting into cases uses the axiom of choice (via LEM), and I'm trying to figure out if this is true without it as well. I think it isn't but I can't show that it implies any form of choice.</p>",
        "id": 483779818,
        "sender_full_name": "Nir Paz",
        "timestamp": 1732219459
    },
    {
        "content": "<p>I assume that if this is true without choice then so is every similar large elimination with subsingletones, so I'm talking about the general \"scheme\" and not just <code>Foo</code>.</p>",
        "id": 483780161,
        "sender_full_name": "Nir Paz",
        "timestamp": 1732219579
    },
    {
        "content": "<p>Your type <code>Foo</code> is basically <code>Nonempty</code>. With the <code>subsingleton</code> instance, <code>Foo.betterRec</code> is basically what people call Unique Choice. It will never be computable in Lean because Lean forgets proofs. If we use <code>betterRec</code> to try to just return the unique element of <code>α</code> we will be recovering the data used to prove <code>Foo</code> which will have been forgotten by Lean.</p>\n<p>So the answer to your question is that no, it's not provable in Lean without choice, although it only requires Unique Choice which is weaker but will still not allow computation.</p>\n<p>Type theorists do have notions of computable Unique Choice, but these also won't be computable unless I only use contructive principles to prove <code>Nonempty</code>.</p>",
        "id": 483793653,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1732225241
    }
]