[
    {
        "content": "<p>Are dependent functions and dependent products in Lean parametrically polymorphic?</p>",
        "id": 476112165,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1728560648
    },
    {
        "content": "<p>Parametricity is not provable in Lean, and it's not true in all models of Lean + mathlib axioms; in particular, it's inconsistent with the axiom of choice. Check out also previous discussions <a href=\"#narrow/stream/270676-lean4/topic/Parametricity\">here</a> or <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Parametricity.20and.20Lean.204.3F\">here</a>.</p>",
        "id": 476174622,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1728577675
    },
    {
        "content": "<p>From <a href=\"https://docs.lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html\">https://docs.lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html</a>:</p>\n<blockquote>\n<p>Suppose you wish to write a function <code>cons</code> which inserts a new element at the head of a list. What type should <code>cons</code> have? Such a function is <em>polymorphic</em>: you expect the <code>cons</code> function for <code>Nat</code>, <code>Bool</code>, or an arbitrary type <code>Î±</code> to behave the same way.</p>\n</blockquote>\n<p>What does it mean that a function or datatype is parametrically polymorphic? What does the word \"polymorphic\" mean in the above context? I don't think it means universe polymorphism.</p>",
        "id": 476259640,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1728610992
    },
    {
        "content": "<p>I read a <a href=\"https://en.m.wikipedia.org/wiki/Parametric_polymorphism\">Wikipedia article</a> about parametric polymorphism and thought dependent functions and products in Lean are parametrically polymorphic. It seems I misunderstood the notion of parametric polymorphism. What is it, then?</p>",
        "id": 476260359,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1728611402
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/236446-Type-theory/topic/dependent.20types.20and.20parametric.20polymorphism.20in.20lean/near/476174622\">said</a>:</p>\n<blockquote>\n<p>Parametricity is not provable in Lean, and it's not true in all models of Lean + mathlib axioms; in particular, it's inconsistent with the axiom of choice. Check out also previous discussions <a href=\"#narrow/stream/270676-lean4/topic/Parametricity\">here</a> or <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Parametricity.20and.20Lean.204.3F\">here</a>.</p>\n</blockquote>\n<p>I'm not trying to prove the parametricity theorem; I haven't heard of it until now. I just want to check my understanding of parametric polymorphism.</p>",
        "id": 476261545,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1728611905
    },
    {
        "content": "<p>Ah, sorry! I misread this as a question about <em>parametricity</em>, but you are just asking about polymorphism. Yes, dependent functions are polymorphic.</p>\n<blockquote>\n<p>What does it mean that a function or datatype is parametrically polymorphic?</p>\n</blockquote>\n<p>It just means that we have one implementation of <code>cons</code> which works for lists containing elements of any type. That is, <code>cons</code>ing a Boolean onto a <code>List Bool</code> uses the same function as <code>cons</code>ing a number onto a <code>List Nat</code>, etc. The way this is formalized in dependent type theory is that the first argument of <code>List.cons</code> is a type, and then <code>List.cons Bool</code> (or <code>List.cons Nat</code> or whatever) is a \"monomorphic\" function of type <code>Bool -&gt; List Bool -&gt; List Bool</code> (or analogous).</p>",
        "id": 476270723,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1728614096
    },
    {
        "content": "<p>Thanks. One more question: are dependent products (pairs) in Lean polymorphic? It doesn't seem so.</p>",
        "id": 476275779,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1728615284
    },
    {
        "content": "<p>Note that \"polymorphic\" isn't a precise term in this context. Quoting from <a href=\"https://www.cis.upenn.edu/~bcpierce/tapl/\">Types and Programming Languages</a>:</p>\n<blockquote>\n<p>The term polymorphism refers to a range of language mechanisms that allow a single part of a program to be used with different types in different contexts (Â§23.2 discusses several varieties of polymorphism in more detail).</p>\n</blockquote>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Â§23.2</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<blockquote>\n<p>Type systems that allow a single piece of code to be used with multiple types are collectively known as polymorphic systems (poly = many, morph = form). Several varieties of polymorphism can be found in modern languages (this classification comes from Strachey, 1967, and Cardelli and Wegner, 1985).  </p>\n<p><em>Parametric polymorphism</em>, [...] allows a single piece of code to be typed â€œgenerically,â€ using variables in place of actual types, and then instantiated with particular types as needed. Parametric definitions are uniform: all of their instances <br>\nbehave the same. </p>\n<p>The most powerful form of parametric polymorphism is the impredicative or first-class polymorphism [...]. More common in practice is the form known as ML-style or let-polymorphism, which restricts polymorphism to top-level let-bindings, disallowing functions that take polymorphic values as arguments, and obtains in return a convenient and natural form of automatic type reconstruction. First-class parametric polymorphism is also becoming popular in programming languages, and forms the technical foundation for the powerful module systems of languages like ML.  </p>\n<p>Ad-hoc polymorphism, by contrast, allows a polymorphic value to exhibit different behaviors when â€œviewedâ€ at different types. The most common example of ad-hoc polymorphism is overloading, which associates a single function symbol with many implementations; the compiler (or the runtime system, depending on whether overloading resolution is static or dynamic) chooses an appropriate implementation for each application of the function, based on the types of the arguments.  </p>\n<p>A generalization of function overloading forms the basis for multi-method dispatch in languages such as CLOS (Bobrow et al., 1988; Kiczales et al., 1991) and Cecil (Chambers, 1992; Chambers and Leavens, 1994). This mechanism has been formalized in the Î»-&amp; calculus of Castagna, Ghelli, and Longo (1995; cf. Castagna, 1997).  </p>\n<p>A more powerful form of ad-hoc polymorphism known as intensional polymorphism (Harper and Morrisett, 1995; Crary, Weirich, and Morrisett, 1998) permits restricted computation over types at run time. Intensional polymorphism is an enabling technology for a variety of advanced implementation techniques for polymorphic languages, including tag-free garbage collection, â€œunboxedâ€ function arguments, polymorphic marshaling, and space-efficient â€œflattenedâ€ data structures.  </p>\n<p>Yet more powerful forms of ad-hoc polymorphism can be built from a typecase primitive, which permits arbitrary pattern-matching on type information at run time (Abadi, Cardelli, Pierce, and RÃ©my, 1995; Abadi, Cardelli, Pierce, and Plotkin, 1991b; Henglein, 1994; Leroy and Mauny, 1991; Thatte, 1990). Language features such as Javaâ€™s instanceof test can be viewed as restricted forms of typecase.  </p>\n<p>The subtype polymorphism of Chapter 15 gives a single term many types using the rule of subsumption, allowing us to selectively â€œforgetâ€ information about the termâ€™s behavior.</p>\n</blockquote>\n</div></div>\n<p>By that description, I'd argue that dependent products are polymorphic.</p>",
        "id": 476315566,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1728629446
    }
]