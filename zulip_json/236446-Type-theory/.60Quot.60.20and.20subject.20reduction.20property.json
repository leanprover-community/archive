[
    {
        "content": "<p><code>Quot</code> breaks subject reduction property only when it is used for <code>Prop</code> type?<br>\nI know that <code>Acc</code> can also breaks SR and Lean's type checking algorithm doesn't terminates.<br>\nI'm finding an new type theory which have SR property and strong termination property.<br>\nThis type theory is going to be modified in many terms from Carneiro's type theory; the most significant term is that proof terms are no longer reduced.</p>",
        "id": 486828040,
        "sender_full_name": "Miyahara Kō",
        "timestamp": 1733712728
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Would you know?</p>",
        "id": 487355839,
        "sender_full_name": "Miyahara Kō",
        "timestamp": 1733872044
    },
    {
        "content": "<p>Is there a question here?</p>",
        "id": 487357429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733873024
    },
    {
        "content": "<p>I'm not aware of an essential issue with subject reduction related to <code>Quot</code> on Type</p>",
        "id": 487357497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733873053
    },
    {
        "content": "<p>OK, I will search.<br>\nThank you!</p>",
        "id": 487677550,
        "sender_full_name": "Miyahara Kō",
        "timestamp": 1733877179
    },
    {
        "content": "<p>Note that <code>Quot</code> does break canonicity, since <code>Eq.rec</code> will not reduce over equalities between quotiented terms that are not defeq:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Squash</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Squash</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Quot</span><span class=\"bp\">.</span><span class=\"n\">sound</span><span class=\"w\"> </span><span class=\"bp\">⟨⟩</span>\n<span class=\"w\">  </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">this</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"c1\">--foo.proof_1 ▸ 0, not 0</span>\n</code></pre></div>",
        "id": 488072710,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733915873
    },
    {
        "content": "<p>more specifically, <code>Quot.sound</code> breaks canonicity, as does every axiom</p>",
        "id": 488157877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733940624
    },
    {
        "content": "<p>Are there any Lean axiom other than <code>Quot.lift</code> that have a computational behaviour ? <br>\nIn any case, <code>Quot.sound</code> <em>could</em> supposedly be given a computational behaviour which wouldn't break canonicity, as demonstrated in Loïc Pujet's <a href=\"https://github.com/loic-p/PhD-thesis/releases/download/17-03-2023/main.pdf\">PhD thesis</a> on Observational Equality:<br>\nGiven <code>Eq.rec</code> being defined using CC_Obs primitives as described p.38, and assuming that <code>cast</code> reduces as expected between neutral (definitioninally equal) types  (see p76), Quotients would not break canonicity.</p>",
        "id": 488518955,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733958649
    },
    {
        "content": "<p>true, but I would say that OTT is pretty radically different from CIC in other ways</p>",
        "id": 488519027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733958699
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"432410\">Arthur Adjedj</span> <a href=\"#narrow/channel/236446-Type-theory/topic/.60Quot.60.20and.20subject.20reduction.20property/near/488518955\">said</a>:</p>\n<blockquote>\n<p>Are there any Lean axiom other than <code>Quot.lift</code> that have a computational behaviour ?</p>\n</blockquote>\n<p>Well yes, every inductive recursor has computational behavior</p>",
        "id": 488519110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733958733
    },
    {
        "content": "<p>Right, but these are not axioms per se.</p>",
        "id": 488519152,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733958763
    },
    {
        "content": "<p><code>Quot.lift</code> is not really all that different from an inductive recursor</p>",
        "id": 488519172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733958775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/236446-Type-theory/topic/.60Quot.60.20and.20subject.20reduction.20property/near/488519027\">said</a>:</p>\n<blockquote>\n<p>true, but I would say that OTT is pretty radically different from CIC in other ways</p>\n</blockquote>\n<p>It's true that OTT's handling of indexed inductive types would be quite different than i.e Lean's implementation.</p>",
        "id": 488519207,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733958790
    },
    {
        "content": "<p>Lean basically has exactly one built in HIT</p>",
        "id": 488519248,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733958814
    },
    {
        "content": "<p>right</p>",
        "id": 488519336,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733958845
    },
    {
        "content": "<p>I'm not sure whether <code>Quot.sound</code> would be provable if it were a real HIT, or whether it is fundamentally necessary to axiomatize it</p>",
        "id": 488519381,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733958877
    },
    {
        "content": "<p>I guess it's the path constructor?</p>",
        "id": 488519398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733958888
    },
    {
        "content": "<p>meaning that the solution is presumably to give it computational behavior when applied via <code>congrArg</code>, but I think this doesn't lead to an overall confluent system and that road leads to cubical type theory</p>",
        "id": 488519500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733958950
    },
    {
        "content": "<p>Yeah, the Cubical/Observational way of doing things is to have primitive i.e <code>cast</code>/<code>transp</code> operators which behaves correctly when meeting i.e HITs, instead of working with an equality defined as an inductive type.</p>",
        "id": 488519628,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733959018
    },
    {
        "content": "<p>Another possible solution would be to say that if <code>motive x refl</code> is defeq to <code>motive y e</code> in <code>Eq.rec x motive minor y e</code> (where <code>x</code> is a term of a quotient), then one could have <code>Eq.rec</code> reduce \"on refl\" when working with quotient types. This is morally what happens with <code>cast</code> in OTT, casts get reduced on refl when the two types to cast from/to are defeq.</p>",
        "id": 488520058,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733959259
    },
    {
        "content": "<p>this surely isn't enough, <code>x</code> could be <code>A -&gt; Quot R</code> or something</p>",
        "id": 488520171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733959334
    },
    {
        "content": "<p>Though that would probably be too strict of a condition to englobe the full \"observational\" content of <code>cast</code> in OTT, yeah</p>",
        "id": 488520184,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733959347
    },
    {
        "content": "<p>by the way, there was an issue long ago about implementing OTT in lean</p>",
        "id": 488520220,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733959376
    },
    {
        "content": "<p>Right, I remember seeing that</p>",
        "id": 488520237,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733959386
    },
    {
        "content": "<p>I think we aren't likely to see any theory changes unless there is a clearly better alternative which avoids regressions relative to the existing type system</p>",
        "id": 488520362,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733959447
    },
    {
        "content": "<p>which is probably impossible</p>",
        "id": 488520371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733959453
    },
    {
        "content": "<p>There honestly wouldn't be many \"theoretical\" obstacles to having OTT in Lean. The two main that comes to mind, the classical axioms, and the large elimination of <code>Acc</code>, could both be resolved:</p>\n<ul>\n<li>the setoidal model of TTObs should be compatible with classical axioms</li>\n<li>Even though CCObs wouldn't be compatible with the singleton elimination criteria of Lean, it would be compatible with the \"restricted\" principle described in Tabareau's \"Definitional Equality without K\", which Coq's <code>SProp</code> currently uses. Axiomatizing <code>Acc</code> and its propositional equalities would then be compatible with the system</li>\n</ul>\n<p>The biggest issue with CCObs really is that it cannot easily manage indexed inductive types, and would have to rely on fording to define indexed types, which would be a limitation for users IMO.</p>",
        "id": 488522509,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733959587
    },
    {
        "content": "<p>Wouldn't <code>Eq</code> not be an inductive type anymore?</p>",
        "id": 488522566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733959628
    },
    {
        "content": "<p>Seems like that would break everything</p>",
        "id": 488522574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733959635
    },
    {
        "content": "<p>I wouldn't be, no. You could still define <code>Eq</code> as is already done in lean, the inductive Eq and the \"axiomatised\" one would be equivalent (and even equal through propext), but would not share the exact reduction behaviour between their eliminators. This is also exhibited in Loïc's Thesis.</p>",
        "id": 488522690,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733959701
    },
    {
        "content": "<p>does observational equality have J and the definitional rule for it?</p>",
        "id": 488522747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733959748
    },
    {
        "content": "<p>because if not that would definitely break everything</p>",
        "id": 488522771,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733959768
    },
    {
        "content": "<p>no, it has <code>cast</code> (which transports between types) and <code>transp</code> (which is J limited to elimination in Prop). These two are enough to not only define <code>J</code> at large, but also prove the equivalence between that formulation, and an inductive formulation which would have J as its recursor</p>",
        "id": 488522877,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733959820
    },
    {
        "content": "<p>I mean I guess you can say it's not a \"theoretical\" obstacle, but I cannot imagine transitioning lean to an equality where <code>Eq.rec</code> does not reduce</p>",
        "id": 488522974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733959886
    },
    {
        "content": "<p>so <code>Eq</code> would have to be the inductive one, and then what would we have gained?</p>",
        "id": 488523011,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733959905
    },
    {
        "content": "<p>also having two equality types sounds like a logistic nightmare</p>",
        "id": 488523128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733959959
    },
    {
        "content": "<p>one of the two would have to be buried deep where no one will notice</p>",
        "id": 488523216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733960026
    },
    {
        "content": "<p>I think replacing the inductive Eq with the \"axiomatised\" one would be the \"right\" solution in practice. All it would give the system is additional reduction rules/definitional equality compared to the current one. These added defeq would resolve the current issues wrt to the failures of canonicity relating to i.e <code>propext </code>and <code>Quot.sound</code></p>",
        "id": 488523302,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733960069
    },
    {
        "content": "<p>well that's why I'm asking, would <code>Eq.rec</code> reduce?</p>",
        "id": 488523340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733960093
    },
    {
        "content": "<p>yes</p>",
        "id": 488523346,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733960097
    },
    {
        "content": "<p>so what would not?</p>",
        "id": 488523368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733960117
    },
    {
        "content": "<p>it would reduce with the same behaviour as the one Lean currently has</p>",
        "id": 488523372,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733960121
    },
    {
        "content": "<p>axiom K too?</p>",
        "id": 488523385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733960137
    },
    {
        "content": "<p>everything would work as expected, excepted for the fact that indexed inductives would have to be managed differently in the kernel.</p>",
        "id": 488523400,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733960152
    },
    {
        "content": "<p>namely, the kernel would need to know about non-uniform parameters, as well as work with forded versions of the indexed inductive types.</p>",
        "id": 488523498,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733960191
    },
    {
        "content": "<p>is that a complete simulation method?</p>",
        "id": 488523519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733960208
    },
    {
        "content": "<p>or does it entail limitations on the indexed inductive schema</p>",
        "id": 488523550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733960229
    },
    {
        "content": "<p>That's still a conjecture AFAIK. Some categorical semanticists might already know the answer to that TBH.</p>",
        "id": 488523564,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733960244
    },
    {
        "content": "<p>heh</p>",
        "id": 488523602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733960268
    },
    {
        "content": "<p>Not a great answer, i know, but that's the best one I have</p>",
        "id": 488523669,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733960289
    },
    {
        "content": "<p>why can't you just have indexed inductives the same way lean does now?</p>",
        "id": 488523778,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733960363
    },
    {
        "content": "<p>and have OTT equality just get stuck on them</p>",
        "id": 488523790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733960372
    },
    {
        "content": "<p>The issue of casting an equality between different instances of an indexed inductive type is described in section 5.3 of Loïc's thesis, I'm afraid I don't have time to continue this conversation. Another possible issue with OTT is that type constructors would probably be injective.</p>",
        "id": 488524132,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733960556
    },
    {
        "content": "<p>hopefully not the ones where that's inconsistent...</p>",
        "id": 488524199,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733960602
    },
    {
        "content": "<p>I mean, all type constructors in OTT are already injective, in the sense that i.e <code>Nat = Nat</code> will redude to True, <code>Nat = Prop</code> will reduce to <code>False</code> <code>(x : A) -&gt; B = (y : C) -&gt; D </code>  will also reduce to \"both domains are equal and codomains are equal up to casting\" etc.., so it wouldn't be too surprising to see inductive types equalities <code>I p1 .. pn = I p'1 ... p'n</code> also reduce to <code>p1 = p'1 ^ ... ^pn = p'n</code></p>",
        "id": 488525554,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733961442
    },
    {
        "content": "<p>to keep this consistent, parameters would probably need to be \"small enough\", similarly to indices, but that would also be quite a heavy restriction. Another solution would be for equality on inductives family to not reduce like other type constructors.</p>",
        "id": 488526129,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1733961710
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"432410\">Arthur Adjedj</span> <a href=\"#narrow/stream/236446-Type-theory/topic/.60Quot.60.20and.20subject.20reduction.20property/near/488518955\">said</a>:</p>\n<blockquote>\n<p>Are there any Lean axiom other than <code>Quot.lift</code> that have a computational behaviour ? <br>\nIn any case, <code>Quot.sound</code> <em>could</em> supposedly be given a computational behaviour which wouldn't break canonicity, as demonstrated in Loïc Pujet's <a href=\"https://github.com/loic-p/PhD-thesis/releases/download/17-03-2023/main.pdf\">PhD thesis</a> on Observational Equality:<br>\nGiven <code>Eq.rec</code> being defined using CC_Obs primitives as described p.38, and assuming that <code>cast</code> reduces as expected between neutral (definitioninally equal) types  (see p76), Quotients would not break canonicity.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"432410\">@Arthur Adjedj</span> <br>\nThanks for the good paper!<br>\nThis is close to the type theory I was looking for.<br>\nI was struggling to find a complete (all correct theorems can be proved) type theory under a set-theoretic model. So I would like to investigate this theory.</p>",
        "id": 488541391,
        "sender_full_name": "Miyahara Kō",
        "timestamp": 1733972156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/236446-Type-theory/topic/.60Quot.60.20and.20subject.20reduction.20property/near/488157877\">said</a>:</p>\n<blockquote>\n<p>more specifically, <code>Quot.sound</code> breaks canonicity, as does every axiom</p>\n</blockquote>\n<p><a href=\"https://martinescardo.github.io/papers/negative-axioms.pdf\">Not every</a>!</p>",
        "id": 488582329,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1733994249
    }
]