[
    {
        "content": "<p>a) Is it even true in, or at least consistent with, Lean's type theory that <code>((a : Î±) â†’ Î² a) = ((a' : Î±') â†’ Î²' a')</code> implies <code>Î± = Î±'</code>and <code>Î² = Î²'</code>?<br>\nb) If it is true, is it provable in Lean?</p>\n<p>Normally, I'd try prove this by injectivity of constructors, but near as I can tell the dependent arrow is a low level construct that doesn't really <em>have</em> construtors... which is suspicious to me since even <code>Eq</code> has a constructor and a <code>recOn</code>, but if <code>Pi</code> or <code>forall</code> do I can't find it.</p>",
        "id": 498657928,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1739154023
    },
    {
        "content": "<p>It is consistent but not provable.<br>\nIn the cardinality model of Lean, <code>Unit â†’ Nat</code> and <code>Bool â†’ Nat</code> are the same cardinality, and so the same type.<br>\nOn the other have, there is nothing stopping these from being distinct.</p>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Eq#doc\">docs#Eq</a> is an inductive type, but the dependent arrow is built into Lean, which is why <code>Eq</code> has a <code>rec</code> principle but the <code>forall</code> types do not.</p>",
        "id": 498658874,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1739154684
    },
    {
        "content": "<p>I see. Unfortunate, but good to know for sure. Thanks.</p>",
        "id": 498658961,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1739154727
    },
    {
        "content": "<p>And I suppose the same argument applied to, say, <code>Bool â†’ Nat</code> and <code>Bool â†’ (Nat Ã— Nat)</code> demonstrates that even if we unify the index types,  <code>((a : Î±) â†’ Î² a) = ((a : Î±) â†’ Î²' a) â†’ Î² = Î²'</code> isn't provable either?</p>",
        "id": 498662051,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1739156883
    },
    {
        "content": "<p>That example is fine, because it could be the case that <code>Nat = Nat Ã— Nat</code> (they have the same cardinality).</p>\n<p><code>Nat -&gt; Bool</code> and <code>Nat -&gt; Nat</code> gives a cardinality counterexample though.</p>",
        "id": 498662447,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739157177
    },
    {
        "content": "<p>Ah, okay. Thanks!</p>",
        "id": 498662481,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1739157202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Injectivity.20of.20Pi.20type.20.22constructors.22/near/498658874\">said</a>:</p>\n<blockquote>\n<p>It is consistent</p>\n</blockquote>\n<p>This seems plausible, but I'm not sure since type constructor injectivity isn't consistent. Do you have a source for it? (Maybe it's in <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a>)</p>",
        "id": 498666218,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739159928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Injectivity.20of.20Pi.20type.20.22constructors.22/near/498658874\">said</a>:</p>\n<blockquote>\n<p>In the cardinality model of Lean, <code>Unit â†’ Nat</code> and <code>Bool â†’ Nat</code> are the same cardinality, and so the same type.</p>\n</blockquote>\n<p>Do you have a reference for the cardinality model of Lean? I checked <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a>, but I cannot find it there.</p>",
        "id": 498669670,
        "sender_full_name": "Walter Moreira",
        "timestamp": 1739162343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Injectivity.20of.20Pi.20type.20.22constructors.22/near/498666218\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Injectivity.20of.20Pi.20type.20.22constructors.22/near/498658874\">said</a>:</p>\n<blockquote>\n<p>It is consistent</p>\n</blockquote>\n<p>This seems plausible, but I'm not sure since type constructor injectivity isn't consistent. Do you have a source for it? (Maybe it's in <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a>)</p>\n</blockquote>\n<p>To me this is just \"obviously\" true. If it is inconsistent you should be able to find a concrete counterexample, which seems impossible if the target is not a <code>Prop</code>. I looked for a source, but didn't find one. Maybe I'll try writing a proof later.</p>\n<p>What is type constructor injectivity?</p>",
        "id": 498746415,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1739190028
    },
    {
        "content": "<p>I'm not sure we can appeal to \"obviously\" here. This looks very delicate to me.</p>",
        "id": 498791442,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739201271
    },
    {
        "content": "<p>Maybe I haven't built up enough intuition, and I am wrong on this. I'll try writing a proof later.</p>",
        "id": 498792752,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1739201508
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Injectivity.20of.20Pi.20type.20.22constructors.22/near/498746415\">said</a>:</p>\n<blockquote>\n<p>What is type constructor injectivity?</p>\n</blockquote>\n<p>This is certainly not my area of expertise but there's a discussion here <a href=\"#narrow/channel/236446-Type-theory/topic/.60Quot.60.20and.20subject.20reduction.20property/near/488524132\">#Type theory &gt; &#96;Quot&#96; and subject reduction property @ ðŸ’¬</a></p>",
        "id": 498808720,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739205268
    },
    {
        "content": "<p><a class=\"message-link\" href=\"/#narrow/channel/113489-new-members/topic/.E2.9C.94.20Are.20parametric.20type.20constructors.20injective.3F/near/477729049\">#new members &gt; âœ” Are parametric type constructors injective? @ ðŸ’¬</a>  has an example of an inductive type whose type constructor isn't injective. The way this one works doesn't apply to pi types however, since pi types have a universe bump.</p>",
        "id": 498812138,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739206168
    },
    {
        "content": "<p>pi types are not injective. <code>(Nat -&gt; True) = (Unit -&gt; True)</code></p>",
        "id": 498907387,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739239093
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I'm not sure what you mean about pi types having a universe bump - pi types don't bump the universe on their own</p>",
        "id": 498907773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739239268
    },
    {
        "content": "<p>For a codomain which is not a Prop, you can construct a model satisfying pi injectivity; there are some details on this construction in <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> . Unfortunately the cardinality model is not described there, even though I recall writing some notes on it which must have died in a git stash somewhere</p>",
        "id": 498908067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739239392
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Injectivity.20of.20Pi.20type.20.22constructors.22/near/498907387\">said</a>:</p>\n<blockquote>\n<p>pi types are not injective. <code>(Nat -&gt; True) = (Unit -&gt; True)</code></p>\n</blockquote>\n<p>I was going to mention this example, but Aaron said \"which seems impossible if the target is not aÂ <code>Prop</code>\" so it didn't seem necessary.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Injectivity.20of.20Pi.20type.20.22constructors.22/near/498907773\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> I'm not sure what you mean about pi types having a universe bump - pi types don't bump the universe on their own</p>\n</blockquote>\n<p>In the type constructor parameter example, you don't need the universe level of the resulting type to accommodate the parameter. Maybe 'universe bump' isn't descriptive enough, but in any case, the pi types lie in a large enough universe where the cantor trick doesn't seem to work.</p>",
        "id": 498908503,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739239585
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Injectivity.20of.20Pi.20type.20.22constructors.22/near/498908067\">said</a>:</p>\n<blockquote>\n<p>you can construct a model satisfying pi injectivity</p>\n</blockquote>\n<p>Is a way it works that each pi type can be represented by a corresponding ZFC function set? (I'm assuming we model dependent functions by using the union of the codomains as the codomain.)</p>",
        "id": 498909007,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739239826
    },
    {
        "content": "<p>See section 6.4 of <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a>. It works by interpreting types not as sets directly, but rather tagged sets that contain a semi-syntactic description of the way the type was constructed. So the representation of a pi type is <code>[[(a : A) -&gt; B a]] = (\"Pi\", [[A]], [[B]])</code> and we can use this to prove injectivity of pi wrt propositional equality in this model</p>",
        "id": 498954378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739262920
    }
]