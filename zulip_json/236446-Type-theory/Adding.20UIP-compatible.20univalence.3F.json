[
    {
        "content": "<p>The problem of adding traditional univalence to Lean would be that it is incompatible with UIP because there can be two distinct equivalence on pairs of types, which means two distinct equalities (e.g. id and flip in Bool).</p>\n<p>But it seems this difficulty can be avoided by adopting a restricted form of univalence that only allows to get an equality from an equivalence for a single equivalence per type pair, and such that the set of those equivalences is closed under composition and type formation congruence, so that there is still only one equality per type pair.</p>\n<p>Obviously the simplest way to realize this is to require a proof that the equivalence is unique.</p>\n<p>It seems it might also be possible to make this work by having types come with globally selected ordering, requiring that the equivalence is minimal in the lexicographic ordering induced by it (probably needs both directions to be minimal) and perhaps some other requirements to ensure composition and type formation works.</p>\n<p>Thoughts?</p>",
        "id": 467218915,
        "sender_full_name": "lyphyser",
        "timestamp": 1725362792
    },
    {
        "content": "<p>Another way could be to allow to specify an equivalence at type creation (with a new global directive similar to \"instance\") and check that the graph of those and those induced by applying type formers to them is acyclic and has no self loops (so that composition and type formation don't introduce two potentially different equalities for any pair of types or introduce an equality different than refl between a type and itself).</p>",
        "id": 467225565,
        "sender_full_name": "lyphyser",
        "timestamp": 1725364291
    },
    {
        "content": "<p>This seems plausible, but is it useful? To me, the big benefit of univalence is \"isomorphism induces equivalence\". If that principle holds, then the two distinct isomorphisms of booleans need to induce two distinct equalities.</p>",
        "id": 467226095,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1725364450
    },
    {
        "content": "<p>It would be restricted to \"the unique 'canonical' isomorphism (if there is one) induces equality\" with 'canonical' being defined using one of the criteria listed above (or something better if found).</p>",
        "id": 467241043,
        "sender_full_name": "lyphyser",
        "timestamp": 1725367389
    },
    {
        "content": "<p>Seems like allowing to choose an equivalence explictly is better than the requiring it to be minimal over an ordering, because you still need to effectively decide the ordering at type creation type, and specifying the equivalence directly seems much simpler than specifying an order.</p>\n<p>It seems this mechanism would be powerful enough for instance to define binary naturals, provide the equivalence to make  them be equal to the unary naturals, and define an instance of CommSemiring on them and prove that it is equal to the CommSemiring instance on N, and thus that any statement on commutative semirings that holds for unary naturals holds for binary naturals, and similarly any computation would give the same result (or more precisely the results would be HEq given HEq inputs)</p>",
        "id": 467296340,
        "sender_full_name": "lyphyser",
        "timestamp": 1725378363
    },
    {
        "content": "<p>Having a random equality doesn't really help. We need to be able to characterize what transporting along the equality does. So it would be next to useless to have that equality between binary and unary naturals unless we can prove that the additions and multiplications agree when you transport across the equality. That requires the full statement of univalence to prove in HoTT.</p>",
        "id": 467411494,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1725425267
    },
    {
        "content": "<p>the equality would come from an equivalence, which consists of a function, an inverse function and two proofs that fun . invFun = id and invFun . fun = id; hence, transport can be performed by applying the function</p>",
        "id": 467523014,
        "sender_full_name": "lyphyser",
        "timestamp": 1725453900
    },
    {
        "content": "<p>it would like univalence, except the univalence axiom would have additional prerequisites that make sure that only one equality can be created between any two types</p>",
        "id": 467523406,
        "sender_full_name": "lyphyser",
        "timestamp": 1725453982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"751429\">LL</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Adding.20UIP-compatible.20univalence.3F/near/467296340\">said</a>:</p>\n<blockquote>\n<p>It seems this mechanism would be powerful enough for instance to define binary naturals, provide the equivalence to make  them be equal to the unary naturals, and define an instance of CommSemiring on them and prove that it is equal to the CommSemiring instance on N, and thus that any statement on commutative semirings that holds for unary naturals holds for binary naturals, and similarly any computation would give the same result (or more precisely the results would be HEq given HEq inputs)</p>\n</blockquote>\n<p>This works (I think) because we only operate on concrete types. But as soon as we abstract, we get into trouble. For instance, we'd like to prove that any two isomorphic <code>CommSemiring</code>s are equal. However, this is not provable in your system because it only holds if the underlying isomorphism of types is the canonical one. In order to prove a general result, you'd have to introduce the special predicate \"f is the canonical isomorphism between Î± and Î²\". But even this result is much weaker than what you'd get in full HoTT.</p>",
        "id": 467530104,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1725455383
    },
    {
        "content": "<p>One thing to note is that in Lean, UIP follows from definitional proof irrelevance and the fact that <code>Eq</code> is a <code>Prop</code>. You can simply define a <code>Type</code>-valued identity type with no definitional UIP. This is what <a href=\"https://github.com/forked-from-1kasper/ground_zero/blob/197f0c01eb19361cb3b847b39d2a135f0f69a744/GroundZero/Types/Id.lean#L16\">GroundZero does</a>.</p>",
        "id": 467951005,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1725561989
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128280\">@Wojciech Nawrocki</span> You also need to avoid subsingleton elimination though, right? The <code>hott example</code> a few lines down successfully fails (I think I heard that <code>hott</code> is checking for subsingleton elimination), but in plain Lean UIP would go through just fine.</p>\n<p>Here's <code>Type</code>-valued UIP in plain Lean to save a click:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">TEq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TEq</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">TEq</span><span class=\"bp\">.</span><span class=\"n\">uip</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TEq</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TEq</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">refl</span>\n</code></pre></div>",
        "id": 467954449,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725562709
    },
    {
        "content": "<p>(I don't really know what I'm talking about here, so I might be using the wrong terminology, sorry!)</p>",
        "id": 467955165,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725562850
    },
    {
        "content": "<p>Absolutely, I forgot about that feature!</p>",
        "id": 467957736,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1725563402
    },
    {
        "content": "<p>I'm a bit confused, since subsingleton elimination doesn't apply to <code>TEq</code> as it's not a <code>Prop</code>.</p>\n<p>However, looking at the term for <code>TEq.uip</code>, it turns out <code>cases</code> silently uses UIP, pulling in <code>Eq.ndrec</code> to rewrite indices. That should be enough to trigger the <code>hott</code> check at least, and that's where subsingleton elimination is being used.</p>",
        "id": 467964960,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725565389
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Adding.20UIP-compatible.20univalence.3F/near/467530104\">said</a>:</p>\n<blockquote>\n<p>@_<strong>LL|751429</strong> <a href=\"#narrow/stream/236446-Type-theory/topic/Adding.20UIP-compatible.20univalence.3F/near/467296340\">said</a>:</p>\n<blockquote>\n<p>It seems this mechanism would be powerful enough for instance to define binary naturals, provide the equivalence to make  them be equal to the unary naturals, and define an instance of CommSemiring on them and prove that it is equal to the CommSemiring instance on N, and thus that any statement on commutative semirings that holds for unary naturals holds for binary naturals, and similarly any computation would give the same result (or more precisely the results would be HEq given HEq inputs)</p>\n</blockquote>\n<p>This works (I think) because we only operate on concrete types. But as soon as we abstract, we get into trouble. For instance, we'd like to prove that any two isomorphic <code>CommSemiring</code>s are equal. However, this is not provable in your system because it only holds if the underlying isomorphism of types is the canonical one. In order to prove a general result, you'd have to introduce the special predicate \"f is the canonical isomorphism between Î± and Î²\". But even this result is much weaker than what you'd get in full HoTT.</p>\n</blockquote>\n<p>Wouldn't this essentially be the same as providing some syntactic sugar for inductive types that are immediately quotiented by a given relation? So handling the \"canonical isomorphism\" would be handled by the existing <code>Quot</code>/<code>Quotient</code> API.</p>",
        "id": 498658739,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1739154602
    }
]