[
    {
        "content": "<p>I was wondering if anyone had resources or examples on how to define &amp; make theorems around simple type systems, the like you'd find in the TAPL (Types and Programming Languages) book, in Lean4.</p>\n<p>I'm a beginner self teaching in the topic and am trying to mess around with my own type theories and would love a more concrete way of defining &amp; proving theorems in them, I'm just not sure what an idiomatic way to define a \"type system\" in Lean4 would be as the starting point.</p>",
        "id": 560749308,
        "sender_full_name": "Philogy",
        "timestamp": 1764324880
    },
    {
        "content": "<p>I guess <a href=\"https://softwarefoundations.cis.upenn.edu/\">Software Foundations</a>, in particular Volume 2, also by Benjamin C. Pierce (and others), is a canonical resource on that. It uses Rocq, but at least most techniques should work very similarly in Lean. See also <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/Self-studying.20Lean4.20with.20Software.20Foundations.3F/with/508349850\">#new members &gt; Self-studying Lean4 with Software Foundations?</a> and <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Working.20on.20a.20Translation.20of.20Software.20Foundations.20to.20LEAN/with/525024674\">#general &gt; Working on a Translation of Software Foundations to LEAN</a>.</p>",
        "id": 560753663,
        "sender_full_name": "Sebastian Miele",
        "timestamp": 1764326313
    },
    {
        "content": "<p>In CSLib we have examples of both simples types and system F with subtyping: <a href=\"https://github.com/leanprover/cslib/tree/main/Cslib/Languages/LambdaCalculus/LocallyNameless\">https://github.com/leanprover/cslib/tree/main/Cslib/Languages/LambdaCalculus/LocallyNameless</a>. There are proofs of at least progress/preservation for each.</p>\n<p>These all currently use a locally nameless representation of syntax where bound and free variables are syntactically differentiated. There are other styles you should look into, like well-scoped indices where terms are indexed by the number of free variables. (We will have this soon, but maybe others have an example in the meantime)</p>",
        "id": 560754000,
        "sender_full_name": "Chris Henson",
        "timestamp": 1764326413
    },
    {
        "content": "<p>A while ago I wrote a blog post <a href=\"https://chrishenson.net/posts/2025-05-10-formalized_lambda_calculus.html\">Beginner Resources for Formalizing Lambda Calculi</a> you might find helpful. It collects links to various examples in different proof assistants.</p>",
        "id": 560754666,
        "sender_full_name": "Chris Henson",
        "timestamp": 1764326604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Simple.20Type.20Theory.20definitions.20.26.20Theorems/near/560754666\">said</a>:</p>\n<blockquote>\n<p>A while ago I wrote a blog post <a href=\"https://chrishenson.net/posts/2025-05-10-formalized_lambda_calculus.html\">Beginner Resources for Formalizing Lambda Calculi</a> you might find helpful. It collects links to various examples in different proof assistants.</p>\n</blockquote>\n<p>thanks!</p>",
        "id": 560755388,
        "sender_full_name": "Philogy",
        "timestamp": 1764326811
    },
    {
        "content": "<p>There is also <a href=\"https://github.com/lean-forward/logical_verification_2025/blob/main/hitchhikers_guide_2025_desktop.pdf\">the hitchhiker's guide</a> which considers operational and denotational semantics.</p>",
        "id": 560845378,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1764357885
    }
]