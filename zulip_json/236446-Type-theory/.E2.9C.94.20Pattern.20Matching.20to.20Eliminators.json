[
    {
        "content": "<p>Hey, I hope this is the correct stream for this. I'm curious if anybody has some intuition for how to rewrite a function definition that is using pattern matching as one using the eliminator?<br>\nAs a simple example, if we define the natural numbers as usually, the type of the corresponding eliminator would look something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elim_Nat</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span> <span class=\"n\">Zero</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">((</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span> <span class=\"n\">k</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">suc</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>I think I understand how this encodes the induction principle on Nat, but how can I use this to construct a function? As an example, I am trying to translate <strong>addition</strong> (which is usually defined using pattern matching), but I don't really understand how to construct it using the eliminator.<br>\nDoes anybody have any intuition they can offer me, or maybe a reference? <a href=\"https://jesper.sikanda.be/files/thesis-final-digital.pdf\">Jesper Cockx's thesis</a> has a section on this (section 4), but I haven't been able to get any intuition from that :)</p>",
        "id": 340794638,
        "sender_full_name": "Andre Graubner (安德)",
        "timestamp": 1678438237
    },
    {
        "content": "<p>The eliminator you have written is not powerful enough to define functions by recursion</p>",
        "id": 340795463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1678438478
    },
    {
        "content": "<p>(at least, not without using the axiom of choice)</p>",
        "id": 340795500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1678438490
    },
    {
        "content": "<p>Interesting, how would I have to construct it to be powerful enough?</p>",
        "id": 340795671,
        "sender_full_name": "Andre Graubner (安德)",
        "timestamp": 1678438525
    },
    {
        "content": "<p>Lean's eliminator differs in the resulting universe of <code>P</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elim_Nat</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span> <span class=\"n\">Zero</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">((</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span> <span class=\"n\">k</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">suc</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">P</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 340795682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1678438530
    },
    {
        "content": "<p>To construct addition (specifically, the function <code>a + .</code>), you would set <code>P := fun _ =&gt; Nat</code> (where <code>Nat : Sort 1</code>) with the clauses being <code>a</code> and <code>fun _ ih =&gt; suc ih</code></p>",
        "id": 340796034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1678438601
    },
    {
        "content": "<p>Thanks, is there any intuition guiding you in how you were able to come up with this so fast? Any way to think about eliminators that makes this easy? It's still a bit opaque to me <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 340796735,
        "sender_full_name": "Andre Graubner (安德)",
        "timestamp": 1678438800
    },
    {
        "content": "<p>There's the paper Eliminating dependent pattern matching by Goguen et al. It not only gives the formal construction, but also many examples and intuition.</p>",
        "id": 340799926,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1678439623
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 340803185,
        "sender_full_name": "Andre Graubner (安德)",
        "timestamp": 1678440539
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"419316\">Andre Graubner (安德)</span> has marked this topic as resolved.</p>",
        "id": 340803214,
        "sender_full_name": "Notification Bot",
        "timestamp": 1678440544
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"419316\">Andre Graubner (安德)</span> <a href=\"#narrow/stream/236446-Type-theory/topic/.E2.9C.94.20Pattern.20Matching.20to.20Eliminators/near/340796735\">said</a>:</p>\n<blockquote>\n<p>Thanks, is there any intuition guiding you in how you were able to come up with this so fast? Any way to think about eliminators that makes this easy? It's still a bit opaque to me <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>\n</blockquote>\n<p>It helps that I wrote a thesis on it -&gt; <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a></p>",
        "id": 340807317,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1678441421
    },
    {
        "content": "<p>Thanks, I'll check it out!</p>",
        "id": 340834354,
        "sender_full_name": "Andre Graubner (安德)",
        "timestamp": 1678447851
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"419316\">Andre Graubner (安德)</span> has marked this topic as unresolved.</p>",
        "id": 340839751,
        "sender_full_name": "Notification Bot",
        "timestamp": 1678449385
    },
    {
        "content": "<p>Sorry to bother you again, but is there a standard way to actually implement addition this way?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">myadd</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span> <span class=\"bp\">→</span> <span class=\"n\">mynat</span> <span class=\"bp\">→</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rec</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mysucc</span> <span class=\"n\">ih</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>seems to typecheck, but lean complains about</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">code</span> <span class=\"n\">generator</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"n\">support</span> <span class=\"n\">recursor</span> <span class=\"bp\">'</span><span class=\"n\">mynat.rec'</span> <span class=\"n\">yet</span><span class=\"o\">,</span> <span class=\"n\">consider</span> <span class=\"n\">using</span> <span class=\"bp\">'</span><span class=\"k\">match</span> <span class=\"bp\">...</span> <span class=\"k\">with</span><span class=\"bp\">'</span> <span class=\"n\">and</span><span class=\"bp\">/</span><span class=\"n\">or</span> <span class=\"n\">structural</span> <span class=\"n\">recursion</span>\n</code></pre></div>\n<p>This error is clear enough, but is there some way to play with this anyways, e.g. by defining the recursor myself?</p>",
        "id": 340839897,
        "sender_full_name": "Andre Graubner (安德)",
        "timestamp": 1678449426
    },
    {
        "content": "<p>the compiler does not support direct use of the <code>foo.rec</code> function, you have to use <code>match</code> statements. You can define a copy of the recursor implemented in terms of <code>match</code> and the compiler will be able to use it</p>",
        "id": 340843019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1678450232
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> if you want code for that</p>",
        "id": 340843136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1678450267
    },
    {
        "content": "<p>Amazing, thank you for your help! (sorry for the non-working example, but your hint to implement a copy of the recursor using match is all I needed) :)</p>",
        "id": 340843955,
        "sender_full_name": "Andre Graubner (安德)",
        "timestamp": 1678450484
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"419316\">Andre Graubner (安德)</span> has marked this topic as resolved.</p>",
        "id": 340843968,
        "sender_full_name": "Notification Bot",
        "timestamp": 1678450491
    }
]