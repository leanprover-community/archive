[
    {
        "content": "<p>I'm starting a formalisation of logics and lambda calculi in Lean 4, and my hope is that it can be upstreamed to mathlib. The target is to formalise the beta-normal form theorem, the Church-Rosser theorem, and the unique typing theorem for all of the systems in Barendregt's lambda cube. I also want the underlying logical foundations to be general enough to model general noncommutative linear logics. I've written some base code here, I would greatly appreciate feedback! (Yaël recommended that I tag <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Judgment</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- The antecedents of the judgment. This is also called the context. -/</span>\n  <span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n  <span class=\"sd\">/-- The consequent of the judgment. -/</span>\n  <span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">β</span>\n\n<span class=\"c1\">-- I don't know what priority this should be.</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">10</span> <span class=\"n\">l</span> <span class=\"s2\">\" ⊢ \"</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Judgment.mk</span> <span class=\"n\">l</span> <span class=\"n\">r</span>\n\n<span class=\"sd\">/-- A deduction system, with given antecedent and consequent types,</span>\n<span class=\"sd\">assigns a type to each judgment, which is the type of proofs of that judgment.</span>\n<span class=\"sd\">If the universe parameter is `0`, the proofs of each judgment are propositions. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">DeductionSystem.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">proof</span> <span class=\"o\">:</span> <span class=\"n\">Judgment</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">DeductionSystem</span> <span class=\"o\">(</span><span class=\"n\">proof</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">DeductionSystem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- A deduction system has *permutation* if proofs are stable under permutation of the context. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">Permutation</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DeductionSystem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">permute</span> <span class=\"o\">(</span><span class=\"bp\">Γ₁</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">Γ₂</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">Γ₁</span> <span class=\"bp\">~</span> <span class=\"bp\">Γ₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ₁</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ₂</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">Permutation</span> <span class=\"o\">(</span><span class=\"n\">permute</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">Permutation</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">Permutation</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"bp\">Γ₁</span> <span class=\"bp\">Γ₂</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"n\">γ₁</span> <span class=\"n\">γ₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- A way to cast between proofs where the contexts are equal only propositionally.</span>\n<span class=\"sd\">This has better computational properties than just using `Equiv.cast`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">castProof</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">Γ₁</span> <span class=\"bp\">=</span> <span class=\"bp\">Γ₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ₁</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ₂</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">permute</span> <span class=\"bp\">Γ₁</span> <span class=\"bp\">Γ₂</span> <span class=\"o\">(</span><span class=\"n\">List.Perm.of_eq</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">permuteSwap</span> <span class=\"o\">:</span>\n    <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"n\">γ₁</span> <span class=\"o\">::</span> <span class=\"n\">γ₂</span> <span class=\"o\">::</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"n\">γ₂</span> <span class=\"o\">::</span> <span class=\"n\">γ₁</span> <span class=\"o\">::</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">permute</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">List.Perm.swap</span> <span class=\"n\">γ₂</span> <span class=\"n\">γ₁</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">permuteMiddle</span> <span class=\"o\">:</span>\n    <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ₁</span> <span class=\"bp\">++</span> <span class=\"n\">γ</span> <span class=\"o\">::</span> <span class=\"bp\">Γ₂</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"bp\">Γ₁</span> <span class=\"bp\">++</span> <span class=\"bp\">Γ₂</span><span class=\"o\">)</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">permute</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">List.perm_middle</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">permuteAppend</span> <span class=\"o\">:</span>\n    <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ₁</span> <span class=\"bp\">++</span> <span class=\"bp\">Γ₂</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ₂</span> <span class=\"bp\">++</span> <span class=\"bp\">Γ₁</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">permute</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">List.perm_append_comm</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Permutation</span>\n\n<span class=\"sd\">/-- A deduction system has *weakening* if proofs are stable under increasing the context. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">Weakening</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DeductionSystem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">weaken'</span> <span class=\"o\">(</span><span class=\"bp\">Γ₁</span> <span class=\"bp\">Γ₂</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ₁</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ₂</span> <span class=\"bp\">++</span> <span class=\"bp\">Γ₁</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- A deduction system has *contraction* if a duplicate hypothesis can be removed. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">Contraction</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DeductionSystem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">contract'</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">∈</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">::</span> <span class=\"bp\">Γ₁</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ₁</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">Contraction</span> <span class=\"o\">(</span><span class=\"n\">contract'</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The *contraction* rule for multiple hypotheses. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">contract</span> <span class=\"o\">[</span><span class=\"n\">Contraction</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">Γ₁</span> <span class=\"bp\">Γ₂</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">Γ₁</span> <span class=\"bp\">⊆</span> <span class=\"bp\">Γ₂</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n    <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ₁</span> <span class=\"bp\">++</span> <span class=\"bp\">Γ₂</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ₂</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">pf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pf</span>\n  <span class=\"bp\">|</span> <span class=\"n\">γ</span> <span class=\"o\">::</span> <span class=\"bp\">Γ₁</span><span class=\"o\">,</span> <span class=\"bp\">Γ₂</span><span class=\"o\">,</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">pf</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">contract</span> <span class=\"bp\">Γ₁</span> <span class=\"bp\">Γ₂</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">aesop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">contract'</span> <span class=\"o\">(</span><span class=\"bp\">Γ₁</span> <span class=\"bp\">++</span> <span class=\"bp\">Γ₂</span><span class=\"o\">)</span> <span class=\"n\">γ</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">aesop</span><span class=\"o\">)</span> <span class=\"n\">pf</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The *weakening* rule, expressed using contraction and permutation:</span>\n<span class=\"sd\">we can weaken the hypotheses of a proof to any superset of hypotheses.</span>\n<span class=\"sd\">Note that the list subset operation does not count multiplicity, so we need contraction. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">weaken</span> <span class=\"o\">[</span><span class=\"n\">Weakening</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Permutation</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Contraction</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"bp\">Γ₁</span> <span class=\"bp\">Γ₂</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">Γ₁</span> <span class=\"bp\">⊆</span> <span class=\"bp\">Γ₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ₁</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">proof</span> <span class=\"o\">(</span><span class=\"bp\">Γ₂</span> <span class=\"bp\">⊢</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">contract</span> <span class=\"bp\">Γ₁</span> <span class=\"bp\">Γ₂</span> <span class=\"n\">C</span> <span class=\"n\">h</span> <span class=\"bp\">∘</span> <span class=\"n\">permuteAppend</span> <span class=\"bp\">∘</span> <span class=\"n\">Weakening.weaken'</span> <span class=\"bp\">Γ₁</span> <span class=\"bp\">Γ₂</span> <span class=\"n\">C</span>\n\n<span class=\"sd\">/-- Note: The `outParam` markers on this class ensure that typeclass synthesis depends on</span>\n<span class=\"sd\">the type of terms. This has the downside that we can't extend a `DeductionSystem α β`. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">TypeSystemData</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">Λ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- A proposition representing the assertion that a variable has a given type. -/</span>\n  <span class=\"n\">varTy</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"sd\">/-- A proposition representing the assertion that a term has a given type. -/</span>\n  <span class=\"n\">termTy</span> <span class=\"o\">:</span> <span class=\"bp\">Λ</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n\n  <span class=\"sd\">/-- Each variable is naturally a term. -/</span>\n  <span class=\"n\">var</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"bp\">Λ</span>\n  <span class=\"sd\">/-- The set of free variables of a term. -/</span>\n  <span class=\"n\">free</span> <span class=\"o\">:</span> <span class=\"bp\">Λ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">V</span>\n  <span class=\"sd\">/-- Substitute a variable for a term inside another term. -/</span>\n  <span class=\"n\">subst</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"bp\">Λ</span> <span class=\"bp\">→</span> <span class=\"bp\">Λ</span> <span class=\"bp\">→</span> <span class=\"bp\">Λ</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">TypeSystemData</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">free</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- I don't know what priority these should be.</span>\n<span class=\"c1\">-- I also don't really like the elaboration of variable typing assertions.</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">60</span> <span class=\"n\">v</span> <span class=\"s2\">\" ∶[\"</span> <span class=\"bp\">Λ</span> <span class=\"s2\">\"] \"</span> <span class=\"n\">τ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TypeSystemData.varTy</span> <span class=\"bp\">Λ</span> <span class=\"n\">v</span> <span class=\"n\">τ</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">60</span> <span class=\"n\">t</span> <span class=\"s2\">\" ∶ \"</span> <span class=\"n\">τ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TypeSystemData.termTy</span> <span class=\"n\">t</span> <span class=\"n\">τ</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"n\">t</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">v</span> <span class=\"s2\">\" := \"</span> <span class=\"n\">s</span> <span class=\"s2\">\"]\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TypeSystemData.subst</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"n\">t</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">TypeSystem</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">Λ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"o\">[</span><span class=\"n\">DeductionSystem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">TypeSystemData</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">Λ</span> <span class=\"n\">V</span> <span class=\"n\">T</span> <span class=\"n\">where</span>\n  <span class=\"n\">ax</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">proof</span> <span class=\"o\">([</span><span class=\"n\">v</span> <span class=\"bp\">∶</span><span class=\"o\">[</span><span class=\"bp\">Λ</span><span class=\"o\">]</span> <span class=\"n\">τ</span><span class=\"o\">]</span> <span class=\"bp\">⊢</span> <span class=\"n\">var</span> <span class=\"n\">v</span> <span class=\"bp\">∶</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n  <span class=\"n\">free_var</span> <span class=\"o\">:</span> <span class=\"n\">free</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span>\n  <span class=\"n\">subst_var</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">v</span><span class=\"o\">)[</span><span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">t</span>\n  <span class=\"n\">subst_var_ne</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">w</span><span class=\"o\">)[</span><span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">var</span> <span class=\"n\">w</span>\n  <span class=\"n\">subst_eq_of_not_free</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∉</span> <span class=\"n\">free</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">t</span><span class=\"o\">[</span><span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">t</span>\n  <span class=\"n\">free_subst_of_free</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">free</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">free</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">[</span><span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">s</span><span class=\"o\">])</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">free</span> <span class=\"n\">t</span> <span class=\"bp\">\\</span> <span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">})</span> <span class=\"bp\">∪</span> <span class=\"n\">free</span> <span class=\"n\">s</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">TypeSystem</span> <span class=\"o\">(</span><span class=\"n\">free_var</span> <span class=\"n\">subst_var</span> <span class=\"n\">subst_var_ne</span> <span class=\"n\">subst_eq_of_not_free</span> <span class=\"n\">free_subst_of_free</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">free_var</span> <span class=\"n\">subst_var</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">DeductionSystem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TypeSystem</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">Λ</span> <span class=\"n\">V</span> <span class=\"n\">T</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">free_subst_of_not_free</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"bp\">Λ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∉</span> <span class=\"n\">free</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">free</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">[</span><span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">s</span><span class=\"o\">])</span> <span class=\"bp\">=</span> <span class=\"n\">free</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">subst_eq_of_not_free</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">free_subst_eq</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"bp\">Λ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">free</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">[</span><span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">s</span><span class=\"o\">])</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">free</span> <span class=\"n\">t</span> <span class=\"bp\">\\</span> <span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">})</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">free</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">free</span> <span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">free</span> <span class=\"n\">t</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">free_subst_of_free</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">subst_eq_of_not_free</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">not_mem_free_of_subst</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"bp\">Λ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∉</span> <span class=\"n\">free</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∉</span> <span class=\"n\">free</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">[</span><span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">s</span><span class=\"o\">])</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">free_subst_eq</span><span class=\"o\">]</span>\n  <span class=\"n\">simp_all</span>\n</code></pre></div>",
        "id": 403441181,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1700591741
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4/topic/Logics.20and.20lambda.20calculi\">#lean4 &gt; Logics and lambda calculi</a> by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>.</p>",
        "id": 403441338,
        "sender_full_name": "Notification Bot",
        "timestamp": 1700591804
    },
    {
        "content": "<p>I think designing meta-frameworks for logics and type systems is <em>incredibly</em> difficult, because so little of the work can actually be reused from one theory to another. It is way too easy to design a framework and then realize that it doesn't apply to type systems in the wild. For an example which is fresh on my mind, consider the lean 4 logic formalized <a href=\"https://github.com/digama0/lean4lean/commit/c40c886bd83e71ac577d116e714bf4fdaadb2006#diff-f0eda1394268a79339a43fe414e3713031dd520dec9948e27a42f7d598b5d2ef\">here</a>. Would this framework be able to accomodate it? I think not, because <code>varTy</code> and <code>termTy</code> are contextless (not to mention the more fundamental difference that it uses de bruijn variables and not named variables)</p>",
        "id": 403442572,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700592311
    },
    {
        "content": "<p><code>varTy</code> is the type of some things that appear in a context, and <code>termTy</code> is a consequent of a judgment, so I think that isn't too big of an issue. We can use <code>varTy</code> assumptions to deduce <code>termTy</code>s.</p>",
        "id": 403442921,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1700592455
    },
    {
        "content": "<p>I also assumed that we wouldn't be able to properly define de Bruijn indexing in a meta-framework, because we don't know what the function types look like.</p>",
        "id": 403443051,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1700592506
    },
    {
        "content": "<p>Also note that <code>α</code> and <code>β</code> don't just need to be comprised of <code>varTy</code>/<code>termTy</code> things - you can also put definitional equality assertions in those types.</p>",
        "id": 403443386,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1700592670
    },
    {
        "content": "<p>I am a bit concerned about how portable results will actually be, though - I don't know what can really be proven in this generality.</p>",
        "id": 403443633,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1700592798
    },
    {
        "content": "<p>I've had a look and I <em>think</em> that all of the typing rules in the paper version of <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> can be represented in this framework.</p>",
        "id": 403444759,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1700593320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"492774\">Sky Wilshaw</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Logics.20and.20lambda.20calculi/near/403443051\">said</a>:</p>\n<blockquote>\n<p>I also assumed that we wouldn't be able to properly define de Bruijn indexing in a meta-framework, because we don't know what the function types look like.</p>\n</blockquote>\n<p>You don't need to know what function types look like to have a concept of <code>lift</code> and <code>subst</code> and how they interact</p>",
        "id": 403444976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700593399
    },
    {
        "content": "<p>I would be inclined to stay away from judgments, those are rather free form in practice</p>",
        "id": 403445264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700593515
    },
    {
        "content": "<p>except maybe for having something like a context with a weakening rule</p>",
        "id": 403445330,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700593557
    },
    {
        "content": "<p>I would not do anything with \"assumptions\", this is part of the judgment</p>",
        "id": 403445418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700593582
    },
    {
        "content": "<p>I suspect what is really needed here is some metaprogramming facilities to autogenerate definitions and proofs for things like lift and subst</p>",
        "id": 403445521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700593624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Logics.20and.20lambda.20calculi/near/403445418\">said</a>:</p>\n<blockquote>\n<p>I would not do anything with \"assumptions\", this is part of the judgment</p>\n</blockquote>\n<p>I agree, I'm being a bit sloppy with my wording.</p>",
        "id": 403445767,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1700593726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Logics.20and.20lambda.20calculi/near/403445521\">said</a>:</p>\n<blockquote>\n<p>I suspect what is really needed here is some metaprogramming facilities to autogenerate definitions and proofs for things like lift and subst</p>\n</blockquote>\n<p>This sounds like it could be very useful.</p>",
        "id": 403445801,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1700593741
    },
    {
        "content": "<p>it might also be worth looking into Nominal Isabelle, which is a framework for doing formal metatheory, although it is built around \"nominal types\" which are based on the named variable approach, so it instead automates things like fresh variables and alpha equivalence</p>",
        "id": 403445896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700593782
    },
    {
        "content": "<p>Sounds interesting, thanks for the pointer!</p>",
        "id": 403446127,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1700593885
    },
    {
        "content": "<p>Nominal Lean when? :-)</p>",
        "id": 403446302,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1700593946
    },
    {
        "content": "<p>In light of the discussion above, I've designed a different system that I think is more amenable to actually proving things, but is a lot less general. Instead of building a lambda calculus up using typeclasses, I declare a collection of parameters at the start, and build a lambda calculus based on those parameters. We can then use the recursion principle for these lambda terms to actually prove concrete things.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"sd\">/-- A collection of Boolean parameters that determine which features of the λ-calculus we construct</span>\n<span class=\"sd\">should be enabled. See `BoxIntegral.IntegrationParams` for an application of this idea that is</span>\n<span class=\"sd\">already in mathlib. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">LambdaParams</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- This λ-calculus has λ-abstractions and applications. -/</span>\n  <span class=\"n\">lambda</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n  <span class=\"sd\">/-- This λ-calculus has binary products and projections. -/</span>\n  <span class=\"n\">prod</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n  <span class=\"sd\">/-- This λ-calculus has binary coproducts and a case split construction. -/</span>\n  <span class=\"n\">coprod</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n  <span class=\"sd\">/-- This λ-calculus has a unit type and a constructor for that element. -/</span>\n  <span class=\"n\">unit</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n  <span class=\"sd\">/-- This λ-calculus has an empty type and a recursor for it. -/</span>\n  <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n\n<span class=\"sd\">/-- Types of terms in a λ-calculus with parameters `p` and primitive types `U`. -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">LambdaType</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">LambdaParams</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">prim</span>    <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaType</span> <span class=\"n\">p</span> <span class=\"n\">U</span>\n<span class=\"bp\">|</span> <span class=\"n\">lambda</span>  <span class=\"o\">:</span> <span class=\"n\">p.lambda</span>  <span class=\"bp\">→</span> <span class=\"n\">LambdaType</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaType</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaType</span> <span class=\"n\">p</span> <span class=\"n\">U</span>\n<span class=\"bp\">|</span> <span class=\"n\">prod</span>    <span class=\"o\">:</span> <span class=\"n\">p.prod</span>    <span class=\"bp\">→</span> <span class=\"n\">LambdaType</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaType</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaType</span> <span class=\"n\">p</span> <span class=\"n\">U</span>\n<span class=\"bp\">|</span> <span class=\"n\">coprod</span>  <span class=\"o\">:</span> <span class=\"n\">p.coprod</span>  <span class=\"bp\">→</span> <span class=\"n\">LambdaType</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaType</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaType</span> <span class=\"n\">p</span> <span class=\"n\">U</span>\n<span class=\"bp\">|</span> <span class=\"n\">unit</span>    <span class=\"o\">:</span> <span class=\"n\">p.unit</span>    <span class=\"bp\">→</span> <span class=\"n\">LambdaType</span> <span class=\"n\">p</span> <span class=\"n\">U</span>\n<span class=\"bp\">|</span> <span class=\"n\">empty</span>   <span class=\"o\">:</span> <span class=\"n\">p.empty</span>   <span class=\"bp\">→</span> <span class=\"n\">LambdaType</span> <span class=\"n\">p</span> <span class=\"n\">U</span>\n\n<span class=\"sd\">/-- Terms in a λ-calculus with parameters `p`, primitive types `U` and opaque constants `C`. -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">LambdaTerm</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">LambdaParams</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n<span class=\"sd\">/-- An opaque constant. -/</span>\n<span class=\"bp\">|</span> <span class=\"n\">const</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span>\n<span class=\"sd\">/-- A local variable of a given de Bruijn index. -/</span>\n<span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span>\n<span class=\"sd\">/-- A λ-abstraction. -/</span>\n<span class=\"bp\">|</span> <span class=\"n\">lambda</span> <span class=\"o\">:</span> <span class=\"n\">p.lambda</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaType</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span>\n<span class=\"sd\">/-- A λ-application. -/</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"n\">p.lambda</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span>\n<span class=\"sd\">/-- The pairing operation. -/</span>\n<span class=\"bp\">|</span> <span class=\"n\">pair</span> <span class=\"o\">:</span> <span class=\"n\">p.prod</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span>\n<span class=\"sd\">/-- The left projection of a product. -/</span>\n<span class=\"bp\">|</span> <span class=\"n\">fst</span> <span class=\"o\">:</span> <span class=\"n\">p.prod</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span>\n<span class=\"sd\">/-- The right projection of a product. -/</span>\n<span class=\"bp\">|</span> <span class=\"n\">snd</span> <span class=\"o\">:</span> <span class=\"n\">p.prod</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span>\n<span class=\"sd\">/-- The left injection of a coproduct. The type of the right factor is also given. -/</span>\n<span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"o\">:</span> <span class=\"n\">p.coprod</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaType</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span>\n<span class=\"sd\">/-- The right injection of a coproduct. The type of the left factor is also given. -/</span>\n<span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"o\">:</span> <span class=\"n\">p.coprod</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaType</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span>\n<span class=\"sd\">/-- Case splitting. If the parameters are `l`, `r`, `x`, then this term β-reduces to `l t` if</span>\n<span class=\"sd\">`x = inl t`, and β-reduces to `r t` if `x = inr t`. This matches `Sum.rec`. -/</span>\n<span class=\"bp\">|</span> <span class=\"n\">case</span> <span class=\"o\">:</span> <span class=\"n\">p.coprod</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span>\n<span class=\"sd\">/-- The inhabitant of the unit type. -/</span>\n<span class=\"bp\">|</span> <span class=\"n\">star</span> <span class=\"o\">:</span> <span class=\"n\">p.unit</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span>\n<span class=\"sd\">/-- The recursor for the empty type. This eliminates an element of `empty` into any given type. -/</span>\n<span class=\"bp\">|</span> <span class=\"n\">elim</span> <span class=\"o\">:</span> <span class=\"n\">p.empty</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaType</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">LambdaTerm</span> <span class=\"n\">p</span> <span class=\"n\">U</span> <span class=\"n\">C</span>\n</code></pre></div>",
        "id": 403998101,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1700845077
    },
    {
        "content": "<p>The typing relation is then defined with an additional parameter <code>C -&gt; LambdaType p U</code> which declares the type of each opaque constant.</p>",
        "id": 403998196,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1700845127
    }
]