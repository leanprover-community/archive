[
    {
        "content": "<p>Is there a way to talk about cardinality of functions without referring to mathlib's ZFC sets? I was surprised how non-obvious proving <code>(Fin2 1 -&gt; Fin2 1) \\neq (Fin2 2 -&gt; Fin2 2)</code> was without calling <code>simp [Nat.card]</code> (it seems to me a cardinality argument is the obvious method), and then further realized that is is probably not provable without <code>funext</code>. Do we have any notion of size that would make sense for these functions, in a purely type theoretical setting?  And as a bonus, can we prove this can't be proven without <code>funext</code> internally in Lean?</p>",
        "id": 489142249,
        "sender_full_name": "nrs",
        "timestamp": 1734321010
    },
    {
        "content": "<p>I assume you're missing some parentheses there?</p>",
        "id": 489147567,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734325414
    },
    {
        "content": "<p>whoops! fixed thanks</p>",
        "id": 489147892,
        "sender_full_name": "nrs",
        "timestamp": 1734325623
    },
    {
        "content": "<p>I assume this proof doesn't satisfy you?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 489149314,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734326619
    },
    {
        "content": "<p>Certainly there's no mention of ZFC sets</p>",
        "id": 489150131,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734327096
    },
    {
        "content": "<p>But even the definition of <code>Fintype</code> uses <code>funext</code>, as Mathlib makes absolutely no effort to avoid this axiom, and only a very small amount of effort to avoid <code>Classical.choice</code></p>",
        "id": 489150312,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734327214
    },
    {
        "content": "<p>hm the issue is there's a call to <code>Classical.choice</code> here, and I might be mistaken, but the definition of <code>Set A</code> as <code>A -&gt; Prop</code> combined with <code>Classical.choice</code> might be enough to imply this holds only in a set-theoretical model</p>",
        "id": 489152200,
        "sender_full_name": "nrs",
        "timestamp": 1734328371
    },
    {
        "content": "<p>Set shouldn't be involved in the above at all</p>",
        "id": 489152380,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734328462
    },
    {
        "content": "<p>but you're right that there's no explicit mention of mathlib's ZFC sets. I wonder if we can avoid <code>Classical.choice</code> completely?</p>",
        "id": 489152381,
        "sender_full_name": "nrs",
        "timestamp": 1734328463
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Setless.20proof.20of.20.60Fin2.201.20-.3E.20Fin2.201.20.5Cneq.20Fin2.202.20-.3E.20Fin2.202.60/near/489152380\">said</a>:</p>\n<blockquote>\n<p>Set shouldn't be involved in the above at all</p>\n</blockquote>\n<p>right but it is enough for there to be any type <code>A -&gt; Prop</code> which would behave as <code>Set</code> (in the case <code>Set</code> with <code>Classical.choice</code>  can only be realized in a set-theoretical model)</p>",
        "id": 489152669,
        "sender_full_name": "nrs",
        "timestamp": 1734328632
    },
    {
        "content": "<p>So it looks like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.nodup_range#doc\">docs#List.nodup_range</a> is one source of the use of <code>choice</code>, which might be easy enough to remove</p>",
        "id": 489155686,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734330240
    },
    {
        "content": "<p>But I would be surprised if Lean accepts a PR that removes the use of choice there</p>",
        "id": 489155987,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734330386
    },
    {
        "content": "<p><code>Multiset.pi</code> too it seems</p>",
        "id": 489156076,
        "sender_full_name": "nrs",
        "timestamp": 1734330446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Setless.20proof.20of.20.60Fin2.201.20-.3E.20Fin2.201.20.5Cneq.20Fin2.202.20-.3E.20Fin2.202.60/near/489155987\">said</a>:</p>\n<blockquote>\n<p>But I would be surprised if Lean accepts a PR that removes the use of choice there</p>\n</blockquote>\n<p>oh this is mostly out of interest in mapping out the metatheory of Lean</p>",
        "id": 489156106,
        "sender_full_name": "nrs",
        "timestamp": 1734330472
    },
    {
        "content": "<p>I'm curious if the use of choice in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.pi#doc\">docs#Multiset.pi</a> is unavoidable or trivial</p>",
        "id": 489161883,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734333263
    },
    {
        "content": "<p>That one is in mathlib not Lean, so I'd be happy to merge a de-choicification if the proof readability doesn't majorly suffer</p>",
        "id": 489162125,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734333365
    },
    {
        "content": "<p>it comes from the generated <code>Multiset.pi.proof_1</code> which I don't know much about, am currently investigating what it means</p>",
        "id": 489162332,
        "sender_full_name": "nrs",
        "timestamp": 1734333471
    },
    {
        "content": "<p>It's probably easier just to look at the source of Multiset.pi, which contains a <code>by</code> block corresponding to that</p>",
        "id": 489164538,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734334377
    },
    {
        "content": "<p>Looks like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.Pi.cons_swap#doc\">docs#Multiset.Pi.cons_swap</a> is to blame</p>",
        "id": 489164896,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734334542
    },
    {
        "content": "<p>Fixed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/19990\">#19990</a></p>",
        "id": 489165405,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734334740
    },
    {
        "content": "<p>Very cool! Thanks a lot for taking the time, it's a very nice change for metatheoretical purposes!</p>",
        "id": 489167753,
        "sender_full_name": "nrs",
        "timestamp": 1734335613
    },
    {
        "content": "<p>I will one day have time to write that command I've been meaning to write that singles out relevant lemmas for investigating their axiom usage, instead of  a wall of <code>#print axioms</code></p>",
        "id": 489167935,
        "sender_full_name": "nrs",
        "timestamp": 1734335679
    }
]