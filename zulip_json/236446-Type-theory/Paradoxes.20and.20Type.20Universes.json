[
    {
        "content": "<p>I am learning about type theory and I keep reading that it's necessary to add a universe hierarchy to type systems to avoid paradoxes that come from allowing (Type: Type). However, I've never seen a clear and simple example of such a paradox.</p>\n<p>I don't know how one would make a proposition of Russell's paradox in type theory. I'm assuming that's because Set theory and Type theory are fundamentally different.</p>\n<p>I also hear a lot about the Burali-Forti's paradox, but I don't know what an Ordinal is and how to even define that type or what would be the proposition for the paradox.</p>\n<p>Is there a clear and simple example of proving False/Null from a type theory that does not have a universe hiearchy, where the type of Type is Type?</p>\n<p>And would such an example require recursion / induction? That is, do all of these paradoxes have to do with recursively defined things? The nlab article on Burali-Forti's paradox says that (Type: Type) is inconsistent because it contains non-normalizing proofs of False. In that case, does that mean a proof of False is always through infinite recursion?</p>\n<p>Really, I expect that there exist some type in lean that's something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Example</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">....</span>\n</code></pre></div>\n<p>that doesn't lead to any inconsistencies, but if it was</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Example</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>or without universes</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>then it would clearly lead to proving False in an inconsistent type theory, and fail type checking in lean.</p>",
        "id": 537763462,
        "sender_full_name": "Jonathan Lacombe",
        "timestamp": 1757024070
    },
    {
        "content": "<p>One type-theoretic analogue of Russell's paradox is Girard's paradox. It is <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Counterexamples/Girard.lean\">here</a> in mathlib.</p>",
        "id": 537763867,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1757024311
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Paradoxes.20and.20Type.20Universes/near/537763867\">said</a>:</p>\n<blockquote>\n<p>One type-theoretic analogue of Russell's paradox is Girard's paradox. It is <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Counterexamples/Girard.lean\">here</a> in mathlib.</p>\n</blockquote>\n<p>Well, this just looks like gibberish to me. But I'll try to go through it anyway.</p>",
        "id": 537765634,
        "sender_full_name": "Jonathan Lacombe",
        "timestamp": 1757025367
    },
    {
        "content": "<p>The following Russell-like argument should also work assuming LEM and Sigma types (one kind of inductive types):</p>\n<ul>\n<li>Define <code>Ïƒ : Type := (Î± : Type) Ã— Î±</code>.</li>\n<li>There's an injective function <del><code>k : (Ïƒ â†’ Prop) â†’ Ïƒ := fun P =&gt; âŸ¨Ïƒ, PâŸ©</code></del> <code>k : (Ïƒ â†’ Prop) â†’ Ïƒ := fun P =&gt; âŸ¨Ïƒ â†’ Prop, PâŸ©</code>. (Looks already bad!)</li>\n<li>Define <code>Q : Ïƒ â†’ Prop := fun b =&gt; âˆƒ P, k P = b âˆ§ Â¬ P b</code>(Think of this as the set of sets that don't contain themselves.)</li>\n<li>If <code>Q (k Q)</code>, then there's <code>P</code> with <code>k P = k Q</code> and <code>Â¬ P (k Q)</code>. But <code>k</code> is injective, so <code>Â¬ Q (k Q)</code>. Contradiction.</li>\n<li>If <code>Â¬ Q (k Q)</code>, then choose <code>P := Q</code> and then <code>k P = k Q</code> and <code>Â¬ P (k Q)</code>, so that <code>Q (k Q)</code> holds by definition. Contradiction.</li>\n</ul>",
        "id": 537807510,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1757056721
    },
    {
        "content": "<p>see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.not_surjective_Type#doc\">docs#Function.not_surjective_Type</a> for a proof that there is no surjection from <code>Î± : Type</code> into <code>Type</code>, which also shows why <code>Type : Type</code> would be inconsistent (because the identity function is surjective).</p>",
        "id": 537866821,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1757077655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"743962\">Jonathan Lacombe</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Paradoxes.20and.20Type.20Universes/near/537765634\">said</a>:</p>\n<blockquote>\n<p>Well, this just looks like gibberish to me. But I'll try to go through it anyway.</p>\n</blockquote>\n<p>Here are some papers to read:</p>\n<ul>\n<li><a href=\"https://www.cs.cmu.edu/~kw/scans/hurkens95tlca.pdf\">https://www.cs.cmu.edu/~kw/scans/hurkens95tlca.pdf</a></li>\n<li><a href=\"https://www.cse.chalmers.se/~coquand/geuvers.pdf\">https://www.cse.chalmers.se/~coquand/geuvers.pdf</a></li>\n</ul>\n<p>See also <a href=\"https://ionathan.ch/2021/11/24/inconsistencies.html\">https://ionathan.ch/2021/11/24/inconsistencies.html</a></p>",
        "id": 537878022,
        "sender_full_name": "suhr",
        "timestamp": 1757080884
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"221653\">Paul Reichert</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Paradoxes.20and.20Type.20Universes/near/537807510\">said</a>:</p>\n<blockquote>\n<p>The following Russell-like argument should also work assuming LEM and Sigma types (one kind of inductive types):</p>\n<ul>\n<li>Define <code>Ïƒ : Type := (Î± : Type) Ã— Î±</code>.</li>\n<li>There's an injective function <code>k : (Ïƒ â†’ Prop) â†’ Ïƒ := fun P =&gt; âŸ¨Ïƒ, PâŸ©</code>. (Looks already bad!)</li>\n</ul>\n</blockquote>\n<p>I am actually getting stuck on this definition of <code>k</code>. If <code>Ïƒ</code> is defined as <code>Sigma Type (Î» (Î± : Type) =&gt; Î±)</code> and <code>k : (Ïƒ â†’ Prop) â†’ Ïƒ := fun (P: Ïƒ â†’ Prop) =&gt; âŸ¨Ïƒ, PâŸ©</code> then wouldn't <code>âŸ¨Ïƒ, PâŸ©</code> need to have type <code>Ïƒ</code> so that <code>(fst: Type) = Ïƒ</code> and (snd: B Ïƒ) where <code>B := Î» (Î± : Type) =&gt; Î±</code> and so wouldn't <code>(snd: Ïƒ) = P</code>fail the type check, since P has type <code>Ïƒ â†’ Prop</code> and not <code>Ïƒ</code>?<br>\nFor <code>k</code> to type check, wouldn't it need to be something like <code>k : Ïƒ â†’ Ïƒ := fun (P: Ïƒ) =&gt; âŸ¨Ïƒ, PâŸ©</code>?</p>",
        "id": 537920234,
        "sender_full_name": "Jonathan Lacombe",
        "timestamp": 1757094566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Paradoxes.20and.20Type.20Universes/near/537878022\">said</a>:</p>\n<blockquote>\n<p>Here are some papers to read:</p>\n</blockquote>\n<p>Thanks</p>",
        "id": 537921594,
        "sender_full_name": "Jonathan Lacombe",
        "timestamp": 1757095100
    },
    {
        "content": "<p>I think they meant <code>k : (Ïƒ â†’ Prop) â†’ Ïƒ := fun P =&gt; âŸ¨Ïƒ â†’ Prop, PâŸ©</code></p>",
        "id": 537924823,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757096298
    },
    {
        "content": "<p>Oops, sorry for the confusion. Yes, that is what I meant. Fixed it. Hopefully, it's possible to see how the argument more or less follows Russel's paradoxon. <code>Q</code> is meant to correspond to the set that contains all sets that do not contain themselves.</p>",
        "id": 537945429,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1757105456
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"221653\">Paul Reichert</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Paradoxes.20and.20Type.20Universes/near/537945429\">said</a>:</p>\n<blockquote>\n<p>Hopefully, it's possible to see how the argument more or less follows Russel's paradoxon. <code>Q</code> is meant to correspond to the set that contains all sets that do not contain themselves.</p>\n</blockquote>\n<p>Yeah, this mostly makes sense to me now. I think this is exactly what I was looking for. I am getting stuck on the last two bullet points because I don't know how k being injective results in the contradiction and I also don't know what you mean by choose <code>P := Q</code>.</p>\n<p>But, I did go on further and write some type theory pseudocode to see if I can get what I'm looking for.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">define</span><span class=\"w\"> </span><span class=\"n\">forward</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Null</span><span class=\"o\">):</span>\n<span class=\"w\">    </span><span class=\"bp\">Î»</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">.</span>\n<span class=\"w\">        </span><span class=\"bp\">?</span>\n\n<span class=\"n\">define</span><span class=\"w\"> </span><span class=\"n\">backward</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Null</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">):</span>\n<span class=\"w\">    </span><span class=\"bp\">Î»</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Null</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">.</span>\n<span class=\"w\">        </span><span class=\"bp\">?</span>\n\n<span class=\"n\">define</span><span class=\"w\"> </span><span class=\"n\">contradiction</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Î»</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Null</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Null</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">Null</span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"n\">define</span><span class=\"w\"> </span><span class=\"n\">proof_of_null</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">Null</span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">contradiction</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">forward</span><span class=\"w\"> </span><span class=\"n\">backward</span>\n</code></pre></div>\n<p>I just don't know how to formulate the definitions from your last two bullet points. But also, I don't see any need to assume LEM here. Does it have to do with something in the last two bullet points that I am missing?</p>",
        "id": 537957328,
        "sender_full_name": "Jonathan Lacombe",
        "timestamp": 1757113063
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Bad</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">Ã—</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†ª</span><span class=\"w\"> </span><span class=\"n\">Bad</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bad</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bad</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">Bad</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"bp\">âŸ©</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bad</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">âˆƒ</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">âˆ§</span><span class=\"w\"> </span><span class=\"bp\">Â¬</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">k_injective</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">eq_of_heq</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Sigma</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">inj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bad</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">down</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Â¬</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hP</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">Not</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congrFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k_injective</span><span class=\"w\"> </span><span class=\"n\">hP</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hP</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Â¬</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">âŸ¨</span><span class=\"n\">Q</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">âŸ©</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">down</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">down</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">down</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- 'false' depends on axioms: [Bad, bad]</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">false</span>\n</code></pre></div>",
        "id": 537958450,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757113979
    },
    {
        "content": "<p>you indeed don't need any LEM</p>",
        "id": 537958492,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757114015
    },
    {
        "content": "<p>this is just the diagonal argument</p>",
        "id": 537958697,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757114229
    },
    {
        "content": "<p>interestingly, this is also one of those infinitely reducing proofs</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- times out</span>\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">proofs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">false</span>\n</code></pre></div>",
        "id": 537959092,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757114651
    },
    {
        "content": "<p>by the way, this exact same proof can be used to show there can be no injective function <code>(Î± â†’ Prop) â†’ Î±</code>, which is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.cantor_injective#doc\">docs#Function.cantor_injective</a></p>",
        "id": 537959551,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757115084
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> Yeah this is exactly what I was looking for. Thanks</p>",
        "id": 538016579,
        "sender_full_name": "Jonathan Lacombe",
        "timestamp": 1757177427
    }
]