[
    {
        "content": "<p>From spending a bit of time in Lean, and thinking about the pros and cons. One thing I notice was that Prop:Type doesn't make much sense to me any more than having Type:Prop<br>\nFrom my point of view Prop and Type are two universes, one not a type of the other. Is this just a design decision or is there any practical reason for it.<br>\nMy preferred scheme would have been:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kt\">Prop</span><span class=\"o\">:</span><span class=\"n\">Universe0</span>\n<span class=\"kt\">Type</span><span class=\"o\">:</span><span class=\"n\">Universe0</span>\n<span class=\"n\">Universe0</span><span class=\"o\">:</span><span class=\"n\">Universe1</span><span class=\"o\">:</span><span class=\"bp\">..</span><span class=\"n\">etc</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>(This pretty much amounts to making Prop:Type1 instead of Prop:Type0.) Also probably a better name for \"Type\" would be \"Data\" since it is just the type of mathematical data like numbers etc. Having one of the types in type theory being called Type is a bit silly if you think about it.<br>\n<strong><em>Pros</em></strong><br>\nThe pro's of this scheme is a lot of terms are simplified. e.g. Instead of:<br>\n<code>rfl.{u} {α : Sort u} {a : α}</code> you could write <code>rfl {α : Universe0} {a : α}</code> as most of the time you only care about Prop and Type types anyway and not the higher universes. It makes the Curry-Howard correspondence a bit simpler for Prop and Type since these are just two types of the same Universe.<br>\n<strong><em>Cons</em></strong><br>\nIt would take a bit more typing to reason about higher universes. But probably wouldn't be needed for most mathematical tasks besides category theory.</p>\n<p>My second point is that having all the math types having the same type \"Type\" seems a bit like a wasted opportunity. For example, why not have the number fields like Nat and Complex have the type Field, the topology types as Spaces and so on.  Wouldn't this make it easier to do categorical comparisons? There is a paper here about what to do about things that have more than <a href=\"https://arxiv.org/pdf/2306.00617\">one category</a>. Instead we do this this with the [Field] in the square brackets. You could have dependent categories like Commutative(±1) for (anti-) commutative fields.</p>\n<p>So basically I'm wondering how much of this hierarchy is a design decision and how much is fundamental to how type theory works?</p>\n<p>BTW. This is just for curiosity, I'm not expected anyone to go back and rewrite Lean!</p>",
        "id": 448173984,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719781066
    },
    {
        "content": "<p>This might be more suited to the <a class=\"stream\" data-stream-id=\"236446\" href=\"/#narrow/stream/236446-Type-theory\">#Type theory</a> stream; want me to move it there? (I'll leave the notification message here so people still find it)</p>",
        "id": 448179404,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1719784363
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths/topic/Is.20the.20hierachy.20fixed.3F\">#maths &gt; Is the hierachy fixed?</a> by <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>.</p>",
        "id": 448179431,
        "sender_full_name": "Notification Bot",
        "timestamp": 1719784398
    },
    {
        "content": "<p>There is a lot of flexibility in how you can set up a universe hierarchy. Basically any directed acyclic graph with no maximal element will do</p>",
        "id": 448180262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719785156
    },
    {
        "content": "<p>It just so happens that the simplest such hierarchy is the natural numbers</p>",
        "id": 448180324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719785183
    },
    {
        "content": "<blockquote>\n<p>The pro's of this scheme is a lot of terms are simplified. e.g. Instead of:<br>\n<code>rfl.{u} {α : Sort u} {a : α}</code> you could write <code>rfl {α : Universe0} {a : α}</code> as most of the time you only care about Prop and Type types anyway and not the higher universes.</p>\n</blockquote>\n<p>This is basically saying not to use universe parametricity, which is problematic if you ever want to make use of those other types and find out after the fact that half of the library needs to be rewritten</p>",
        "id": 448180623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719785311
    },
    {
        "content": "<p>I don't see any reason why <code>Prop : Type</code> can't be true by your reading though. Why not think of <code>Prop</code> as a data type as well, if it's basically <code>Bool</code> with extra steps?</p>",
        "id": 448180805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719785384
    },
    {
        "content": "<p>on a reading that things are in <code>Type</code> if they are \"small\", <code>Prop</code> should also be in there</p>",
        "id": 448180958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719785430
    },
    {
        "content": "<p>In particular, having <code>Prop</code> in a higher universe means that <code>Nat : Type</code> but <code>Set Nat : Type 1</code> because <code>Set Nat := Nat -&gt; Prop</code> and <code>Prop</code> is \"large\" now</p>",
        "id": 448181089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719785469
    },
    {
        "content": "<p>so if we put those things together we observe that <code>rfl</code> doesn't prove equality of sets anymore!</p>",
        "id": 448181215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719785526
    },
    {
        "content": "<blockquote>\n<p>For example, why not have the number fields like Nat and Complex have the type Field, the topology types as Spaces and so on.</p>\n</blockquote>\n<p>We actually have this in mathlib as well, these types are usually used as categories, such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingCat#doc\">docs#RingCat</a> . It turns out to be more convenient not to use this unless we are explicitly working with the category though, because <code>Int</code> (the type) has to have one type, so it can't be <code>RingCat</code> and <code>AddGroupCat</code> at the same time. That means we really have <code>intRing : RingCat</code> such that <code>intRing.carrier = Int</code>, but now we have to be able to infer <code>intRing</code> given <code>Int</code>. This leads to a completely different library design known as \"canonical structures\", which is possible to do but very different from the typeclass approach</p>",
        "id": 448181564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719785861
    },
    {
        "content": "<p>It works just as well if you have Type:Prop it seems</p>",
        "id": 448181627,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719785889
    },
    {
        "content": "<p>No, that one is inconsistent actually</p>",
        "id": 448181639,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719785910
    },
    {
        "content": "<p>because then <code>Type</code> would be a proposition and all elements of it would be equal by proof irrelevance, so <code>Unit = Empty</code> and so you can prove false</p>",
        "id": 448181680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719785949
    },
    {
        "content": "<p>Classically <code>Prop</code> is really quite a small type, with only space for two distinct elements, not nearly enough to host a whole universe of data types</p>",
        "id": 448181963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719786038
    },
    {
        "content": "<p>What would happen if you had two distinct families:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kt\">Prop</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"bp\">...</span>\n<span class=\"kt\">Type</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>Is that ruled out I wonder?</p>",
        "id": 448182408,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719786197
    },
    {
        "content": "<p>No, in fact this is the setup used in Agda (as I mentioned there is a lot of flexibility and different provers do different things)</p>",
        "id": 448182556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719786246
    },
    {
        "content": "<p>Actually I take it back, there are two hierarchies in Agda but you have <code>Prop i : Type (i+1)</code></p>",
        "id": 448182788,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719786335
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"725689\">Mr Proof</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Is.20the.20hierarchy.20fixed.3F/near/448182408\">said</a>:</p>\n<blockquote>\n<p>What would happen if you had two distinct families:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kt\">Prop</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"bp\">...</span>\n<span class=\"kt\">Type</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>Is that ruled out I wonder?</p>\n</blockquote>\n<p>This is what Agda does: <a href=\"https://agda.readthedocs.io/en/v2.6.0/language/prop.html\">https://agda.readthedocs.io/en/v2.6.0/language/prop.html</a></p>",
        "id": 448182799,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1719786339
    },
    {
        "content": "<p>Well, my argument would be. If you are taking the time to define Set, is it much more work to add a SetRfl? Or does it all have to be added at the beginning for the whole hierachy?</p>",
        "id": 448182973,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719786367
    },
    {
        "content": "<p>I'm not sure what you mean by Set and SetRfl there</p>",
        "id": 448183031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719786388
    },
    {
        "content": "<p>Well, you said rfl wouldn't cover the case of Set as that would be Type 1. But can't you just add another rfl when defining sets to cover that case?</p>",
        "id": 448183133,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719786421
    },
    {
        "content": "<p>Are you saying that we should redefine <code>rfl</code> every time we need another universe?</p>",
        "id": 448183187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719786432
    },
    {
        "content": "<p>Not redefine. Just add an extra case</p>",
        "id": 448183248,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719786450
    },
    {
        "content": "<p>that means that the first person who finds they need to use Type 2 for some reason would have to copy paste the whole standard library, otherwise nothing would be usable for it</p>",
        "id": 448183397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719786484
    },
    {
        "content": "<p>and if you copy paste equality then you will also have to copy paste all the tactics that use equality</p>",
        "id": 448183659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719786559
    },
    {
        "content": "<p>How is <code>Prop 1 : Prop 2</code> consistent? Surely True is not equal to False?</p>",
        "id": 448532792,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1719907701
    },
    {
        "content": "<p>Agda has <code>Prop i : Type (i+1)</code> to be more accurate</p>",
        "id": 448533568,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1719907961
    },
    {
        "content": "<p>whoops my zulip missed some messages randomly initially, it's already answered by Mario</p>",
        "id": 448533708,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1719908021
    }
]