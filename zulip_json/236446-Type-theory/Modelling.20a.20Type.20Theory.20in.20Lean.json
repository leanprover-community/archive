[
    {
        "content": "<p>My current inductive definition of a term can produce ill-formed terms, for example if <code>A : type</code> is a type that is not <code>Ω</code> , then <code>all A (var 0 Ω)</code> is trying to bind an <code>Ω</code> variable to a <code>A</code> type binder.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">inductive</span> <span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">One</span> <span class=\"bp\">|</span> <span class=\"n\">Omega</span> <span class=\"bp\">|</span> <span class=\"n\">Prod</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">)</span><span class=\"bp\">|</span> <span class=\"n\">Pow</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">)</span>\n\n<span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"err\">Ω</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">Omega</span>\n<span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"mi\">𝟙</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">One</span>\n<span class=\"kn\">infix</span> <span class=\"bp\">`××`</span> <span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"o\">:=</span> <span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">Prod</span>\n<span class=\"kn\">prefix</span> <span class=\"err\">𝒫</span> <span class=\"o\">:</span><span class=\"mi\">101</span> <span class=\"o\">:=</span> <span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">Pow</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">var</span>  <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">Π</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"n\">star</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"mi\">𝟙</span>\n<span class=\"bp\">|</span> <span class=\"n\">top</span>  <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span>\n<span class=\"bp\">|</span> <span class=\"n\">bot</span>  <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span>\n<span class=\"bp\">|</span> <span class=\"n\">prod</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">},</span> <span class=\"n\">term</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">××</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">elem</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">},</span> <span class=\"n\">term</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"err\">𝒫</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span>\n<span class=\"bp\">|</span> <span class=\"n\">comp</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"err\">𝒫</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">and</span>  <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span>\n<span class=\"bp\">|</span> <span class=\"n\">or</span>   <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span>\n<span class=\"bp\">|</span> <span class=\"n\">imp</span>  <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span>\n<span class=\"bp\">|</span> <span class=\"n\">all</span>  <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span>\n<span class=\"bp\">|</span> <span class=\"n\">ex</span>   <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span>\n</code></pre></div>\n\n\n<p>I'm guessing in Lean you cannot enforce conditions on the creation of inductive terms (like trying to say you can only make an <code>all A φ</code> expression  if <code>φ</code> has only <code>var 0 A</code> and no <code>var 0 B</code>).</p>\n<p>My next best idea is introducing the context on terms which is a mapping of free variables to types. Here's my start on that, though I am not that familiar with using <code>fin</code>. Should I use array, vector, list? Or is there a more direct approach to only creating well-defined terms?</p>",
        "id": 195563859,
        "sender_full_name": "Billy Price",
        "timestamp": 1588080605
    },
    {
        "content": "<p>I guess what I would like to be able to say is that a variable can be any term, and it's really only defined by its number, and when we bind it to a binder, it then has an associated type.</p>",
        "id": 195564055,
        "sender_full_name": "Billy Price",
        "timestamp": 1588080688
    },
    {
        "content": "<blockquote>\n<p>I'm guessing in Lean you cannot enforce conditions on the creation of inductive terms (like trying to say you can only make an all A φ expression if φ has only var 0 A and no var 0 B).</p>\n</blockquote>\n<p>You can, but it's a pain because you are still in the middle of the definition so you can't easily use recursive functions at the same time</p>",
        "id": 195564501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588080845
    },
    {
        "content": "<p>I would recommend keeping the term syntax as context free as possible, and have a well typing condition afterward that can have whatever dependencies it wants</p>",
        "id": 195564583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588080894
    },
    {
        "content": "<p>Hmm okay I'll take your advice. I was looking at flypitch documentation and they seem to do without a well-formedness predicate. Is that just because their terms are all the same type?</p>",
        "id": 195565429,
        "sender_full_name": "Billy Price",
        "timestamp": 1588081296
    },
    {
        "content": "<p>It's easier for them because it's only one type, yes. You end up having to carry around a lot of \"type state\" in real type theories, and it becomes hard to get all the definitional equalities you want</p>",
        "id": 195565908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588081548
    },
    {
        "content": "<p>But they have a clearly distinct step for proofs, which I think should be the analogue of type checking for you</p>",
        "id": 195566085,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588081613
    },
    {
        "content": "<p>Sorry what step are you referring to?</p>",
        "id": 195566880,
        "sender_full_name": "Billy Price",
        "timestamp": 1588081961
    },
    {
        "content": "<p>step in the construction</p>",
        "id": 195567152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588082069
    },
    {
        "content": "<p>I would separate the grammar from the syntax rules</p>",
        "id": 195567199,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588082098
    },
    {
        "content": "<p>If you want terms that embed typing information, so that only well-typed terms can be constructed, the usual approach is to index it not only by a type, but also by a context containing the types of free variables. Thus, you would have something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">inductive</span> <span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">One</span> <span class=\"bp\">|</span> <span class=\"n\">Omega</span> <span class=\"bp\">|</span> <span class=\"n\">Prod</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">)</span><span class=\"bp\">|</span> <span class=\"n\">Pow</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">Fun</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">type</span>\n\n<span class=\"n\">def</span> <span class=\"kn\">context</span> <span class=\"o\">:=</span> <span class=\"n\">list</span> <span class=\"n\">type</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">var</span> <span class=\"o\">:</span> <span class=\"kn\">context</span> <span class=\"bp\">→</span> <span class=\"n\">type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">var0</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">var</span> <span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">varsucc</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">var</span> <span class=\"err\">Γ</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">var</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">::</span> <span class=\"err\">Γ</span><span class=\"o\">)</span> <span class=\"n\">β</span>\n\n<span class=\"c1\">-- This is the simply-typed lambda calculus with a unit type and products.</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"kn\">context</span> <span class=\"bp\">→</span> <span class=\"n\">type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">var</span> <span class=\"err\">Γ</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Γ</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">lam</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">::</span> <span class=\"err\">Γ</span><span class=\"o\">)</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Γ</span> <span class=\"o\">(</span><span class=\"n\">Fun</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">prod</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"err\">Γ</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Γ</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Γ</span> <span class=\"o\">(</span><span class=\"n\">Prod</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">unit</span> <span class=\"o\">{</span><span class=\"err\">Γ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"err\">Γ</span> <span class=\"n\">One</span>\n</code></pre></div>\n\n\n<p>This approach works fine and makes the development a little easier if (a) you don't have dependencies in your types (but I guess your <code>all</code> and <code>ex</code> are supposed to be quantifiers?) and (b) Lean properly supports indexed families (which I don't know). Mario's suggested approach -- keeping the syntax simple and putting a type predicate on top -- requires some additional boilerplate, but has the distinct advantage that it'll work regardless of what object theory you want to encode.</p>",
        "id": 195567247,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1588082125
    },
    {
        "content": "<p>Lean's support for indexed families is fine</p>",
        "id": 195567396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588082187
    },
    {
        "content": "<p>mutual is not fine</p>",
        "id": 195567406,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588082194
    },
    {
        "content": "<p>While I agree with you up to a point, I find that once you get down to proving theorems about these terms, you might want to e.g. prove something by induction on the context from the other end, and then it enters DTT hell</p>",
        "id": 195567538,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588082256
    },
    {
        "content": "<p>Yeah I'm a little turned off by the fact that my sequents will also have a context, and I'd have to marry them properly.</p>",
        "id": 195568076,
        "sender_full_name": "Billy Price",
        "timestamp": 1588082488
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I can see how that proof might be tricky. I've also become more skeptical of intrinsically typed syntax lately -- it's nice when it works, but when it breaks, it sure breaks.</p>",
        "id": 195568381,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1588082614
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"255481\">@Billy Price</span> I don't know exactly what your sequents look like, but you will probably have two contexts, one for the types and one for the hypotheses (as is customary in HOL)</p>",
        "id": 195568805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588082780
    },
    {
        "content": "<p>the hypotheses are nondependent so it's not such a big deal</p>",
        "id": 195568843,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588082795
    },
    {
        "content": "<p>The hypotheses in my sequents are just a single <code>term Ω</code>.</p>",
        "id": 195569469,
        "sender_full_name": "Billy Price",
        "timestamp": 1588083066
    },
    {
        "content": "<p>I'm having a little trouble stating the well-foundedness condition - am I on the right track?</p>\n<p>It also seems like there's two level's of well-foundedness - that every bound variable has the correct type, and that any free variables can be bound to a single type.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">FV_have_type</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">},</span> <span class=\"n\">term</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">n</span> <span class=\"n\">A</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"n\">v</span><span class=\"bp\">=</span><span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">Z</span><span class=\"bp\">=</span><span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">A</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">FV_have_type</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">φ</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"err\">&#39;</span> <span class=\"n\">A</span> <span class=\"n\">φ</span><span class=\"o\">)</span>   <span class=\"o\">:=</span> <span class=\"n\">FV_have_type</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">φ</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"err\">&#39;</span> <span class=\"n\">A</span> <span class=\"n\">φ</span><span class=\"o\">)</span>   <span class=\"o\">:=</span> <span class=\"n\">FV_have_type</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">φ</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">_</span> <span class=\"err\">⁎</span>          <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">_</span> <span class=\"n\">top</span>        <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">_</span> <span class=\"n\">bot</span>        <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">prod</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">FV_have_type</span> <span class=\"n\">v</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">FV_have_type</span> <span class=\"n\">v</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">α</span><span class=\"o\">)</span>    <span class=\"o\">:=</span> <span class=\"n\">FV_have_type</span> <span class=\"n\">v</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">FV_have_type</span> <span class=\"n\">v</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span><span class=\"err\">&#39;</span> <span class=\"n\">q</span><span class=\"o\">)</span>   <span class=\"o\">:=</span> <span class=\"n\">FV_have_type</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">FV_have_type</span> <span class=\"n\">v</span> <span class=\"n\">q</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span><span class=\"err\">&#39;</span> <span class=\"n\">q</span><span class=\"o\">)</span>   <span class=\"o\">:=</span> <span class=\"n\">FV_have_type</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">FV_have_type</span> <span class=\"n\">v</span> <span class=\"n\">q</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"err\">⟹</span> <span class=\"n\">q</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"n\">FV_have_type</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">FV_have_type</span> <span class=\"n\">v</span> <span class=\"n\">q</span>\n\n<span class=\"n\">def</span> <span class=\"n\">well_formed</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 195574629,
        "sender_full_name": "Billy Price",
        "timestamp": 1588085208
    },
    {
        "content": "<p>Do you mean <code>v = n -&gt; Z = A</code>? in other words saying that all occurrences of variable <code>n</code> are used at type <code>Z</code>?</p>",
        "id": 195574849,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588085313
    },
    {
        "content": "<p>Ah yes</p>",
        "id": 195575132,
        "sender_full_name": "Billy Price",
        "timestamp": 1588085454
    },
    {
        "content": "<p>I think it isn't the traditional presentation, but I'm pretty sure it is better to only have the notion \"<code>φ : term A</code> is well-formed in <code>Γ : context</code>\"</p>",
        "id": 195576900,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588086142
    },
    {
        "content": "<p>rather than having only <code>term</code>s with no context and trying to guess the free variables and their types by inspecting the term</p>",
        "id": 195577003,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588086189
    },
    {
        "content": "<p>I started working on a calculus of constructions in Lean à few weeks ago, maybe you find it helpful: <a href=\"https://github.com/anfelor/coc-lean\" title=\"https://github.com/anfelor/coc-lean\">https://github.com/anfelor/coc-lean</a> Feel free to contact me if you have any questions.</p>",
        "id": 195665323,
        "sender_full_name": "Anton Lorenzen",
        "timestamp": 1588141494
    },
    {
        "content": "<p>Awesome! thanks I'll take a look</p>",
        "id": 195698879,
        "sender_full_name": "Billy Price",
        "timestamp": 1588162497
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> WF means the types of the free variables of <code>term A</code> match the context.</p>",
        "id": 195709049,
        "sender_full_name": "Billy Price",
        "timestamp": 1588167249
    },
    {
        "content": "<p>More specifically?</p>",
        "id": 195709072,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588167258
    },
    {
        "content": "<p>What is the English translation of what you wrote?</p>",
        "id": 195709096,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588167268
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">WF</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kn\">context</span> <span class=\"bp\">→</span>  <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">n</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"err\">Γ</span>  <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"err\">Γ</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"err\">Γ</span><span class=\"bp\">.</span><span class=\"n\">nth_le</span> <span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">A</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"err\">Γ</span> <span class=\"o\">:=</span> <span class=\"n\">WF</span> <span class=\"err\">Ω</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">::</span> <span class=\"err\">Γ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"err\">&#39;</span> <span class=\"n\">A</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"err\">Γ</span>  <span class=\"o\">:=</span> <span class=\"n\">WF</span> <span class=\"err\">Ω</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">::</span> <span class=\"err\">Γ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"err\">&#39;</span> <span class=\"n\">A</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"err\">Γ</span>  <span class=\"o\">:=</span> <span class=\"n\">WF</span> <span class=\"err\">Ω</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">::</span> <span class=\"err\">Γ</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 195709139,
        "sender_full_name": "Billy Price",
        "timestamp": 1588167292
    },
    {
        "content": "<p>Hang on let me paste my term definition</p>",
        "id": 195709173,
        "sender_full_name": "Billy Price",
        "timestamp": 1588167304
    },
    {
        "content": "<p>Also that WF definition is incomplete, there are more terms but they are less interesting to WF</p>",
        "id": 195709219,
        "sender_full_name": "Billy Price",
        "timestamp": 1588167323
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"255481\">Billy Price</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195563859\" title=\"#narrow/stream/236446-Type-theory/topic/Modelling.20a.20Type.20Theory.20in.20Lean/near/195563859\">said</a>:</p>\n<blockquote>\n<p>My current inductive definition of a term can produce ill-formed terms, for example if <code>A : type</code> is a type that is not <code>Ω</code> , then <code>all A (var 0 Ω)</code> is trying to bind an <code>Ω</code> variable to a <code>A</code> type binder.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">inductive</span> <span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">One</span> <span class=\"bp\">|</span> <span class=\"n\">Omega</span> <span class=\"bp\">|</span> <span class=\"n\">Prod</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">)</span><span class=\"bp\">|</span> <span class=\"n\">Pow</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">)</span>\n\n<span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"err\">Ω</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">Omega</span>\n<span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"mi\">𝟙</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">One</span>\n<span class=\"kn\">infix</span> <span class=\"bp\">`××`</span> <span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"o\">:=</span> <span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">Prod</span>\n<span class=\"kn\">prefix</span> <span class=\"err\">𝒫</span> <span class=\"o\">:</span><span class=\"mi\">101</span> <span class=\"o\">:=</span> <span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">Pow</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">var</span>  <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">Π</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"n\">star</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"mi\">𝟙</span>\n<span class=\"bp\">|</span> <span class=\"n\">top</span>  <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span>\n<span class=\"bp\">|</span> <span class=\"n\">bot</span>  <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span>\n<span class=\"bp\">|</span> <span class=\"n\">prod</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">},</span> <span class=\"n\">term</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">××</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">elem</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">},</span> <span class=\"n\">term</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"err\">𝒫</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span>\n<span class=\"bp\">|</span> <span class=\"n\">comp</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"err\">𝒫</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">and</span>  <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span>\n<span class=\"bp\">|</span> <span class=\"n\">or</span>   <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span>\n<span class=\"bp\">|</span> <span class=\"n\">imp</span>  <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span>\n<span class=\"bp\">|</span> <span class=\"n\">all</span>  <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span>\n<span class=\"bp\">|</span> <span class=\"n\">ex</span>   <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"err\">Ω</span>\n</code></pre></div>\n\n\n<p>I'm guessing in Lean you cannot enforce conditions on the creation of inductive terms (like trying to say you can only make an <code>all A φ</code> expression  if <code>φ</code> has only <code>var 0 A</code> and no <code>var 0 B</code>).</p>\n<p>My next best idea is introducing the context on terms which is a mapping of free variables to types. Here's my start on that, though I am not that familiar with using <code>fin</code>. Should I use array, vector, list? Or is there a more direct approach to only creating well-defined terms?</p>\n</blockquote>",
        "id": 195709304,
        "sender_full_name": "Billy Price",
        "timestamp": 1588167362
    },
    {
        "content": "<p>Say the context is empty but you have a variable. Is that well-formed?</p>",
        "id": 195709460,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588167440
    },
    {
        "content": "<p>Ah sorry I just realised it was you I was discussing this with earlier. I'm not sure specifically what I should clarify more about <code>WF</code>, given the definition there</p>",
        "id": 195709467,
        "sender_full_name": "Billy Price",
        "timestamp": 1588167447
    },
    {
        "content": "<p>Inductively defined propositions:</p>\n<ol>\n<li><a href=\"https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions\" title=\"https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions\">TPIL</a></li>\n<li><a href=\"https://www.codewars.com/kata/5cc47f8c4b8fea001de6d226\" title=\"https://www.codewars.com/kata/5cc47f8c4b8fea001de6d226\">Codewars: Multiples of 3, you say?</a></li>\n<li><a href=\"https://www.codewars.com/kata/5e59626530e9d00028bbe569\" title=\"https://www.codewars.com/kata/5e59626530e9d00028bbe569\">Codewars: Times Three, Plus Five</a></li>\n</ol>",
        "id": 195709613,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1588167495
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> Yeah I thought about that and I'm not sure how to fix that. For my use I think I can just allow those terms to exist?</p>",
        "id": 195709755,
        "sender_full_name": "Billy Price",
        "timestamp": 1588167562
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Even though I use the keyword <code>def</code>, I'm still defining it inductively on the inductive type <code>term A</code> right?</p>",
        "id": 195710127,
        "sender_full_name": "Billy Price",
        "timestamp": 1588167718
    },
    {
        "content": "<p>yes, but <code>inductive</code> might be better for this case</p>",
        "id": 195710205,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1588167741
    },
    {
        "content": "<p>Hmm, is that because it allows me to name the axioms for well-formedness on each of the term A's? I'm not sure I see the difference/benefit.</p>",
        "id": 195710496,
        "sender_full_name": "Billy Price",
        "timestamp": 1588167882
    },
    {
        "content": "<p>it allows you to \"inject\" things</p>",
        "id": 195710600,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1588167938
    },
    {
        "content": "<p>and you don't need to go through every case</p>",
        "id": 195710631,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1588167956
    },
    {
        "content": "<p>(cases you haven't gone through are automatically \"false\")</p>",
        "id": 195710684,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1588167966
    },
    {
        "content": "<p>I'm pretty sure Reid is hinting at this, but more directly: you don't want <code>∀ a : n &lt; Γ.length, (Γ.nth_le n a = A)</code>, you want <code>∃ a : n &lt; Γ.length, (Γ.nth_le n a = A)</code>. The former says that either the type is correct or it's out of range, while the latter says that it is in range and the type is correct. Better yet, skip the hypothesis and use <code>Γ.nth n = some A</code></p>",
        "id": 195711420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588168249
    },
    {
        "content": "<p>Beautiful, thank you.</p>",
        "id": 195711855,
        "sender_full_name": "Billy Price",
        "timestamp": 1588168398
    },
    {
        "content": "<p>Here's what I've got now (it compiles). I'm still not understanding the suggestion to use <code>inductive</code>. </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">WF</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kn\">context</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"n\">n</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"err\">Γ</span>  <span class=\"o\">:=</span> <span class=\"err\">Γ</span><span class=\"bp\">.</span><span class=\"n\">nth</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">A</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"err\">Γ</span> <span class=\"o\">:=</span> <span class=\"n\">WF</span> <span class=\"err\">Ω</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">::</span> <span class=\"err\">Γ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"err\">&#39;</span> <span class=\"n\">A</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"err\">Γ</span>   <span class=\"o\">:=</span> <span class=\"n\">WF</span> <span class=\"err\">Ω</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">::</span> <span class=\"err\">Γ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"err\">&#39;</span> <span class=\"n\">A</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"err\">Γ</span>   <span class=\"o\">:=</span> <span class=\"n\">WF</span> <span class=\"err\">Ω</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">::</span> <span class=\"err\">Γ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"err\">⁎</span> <span class=\"err\">Γ</span>          <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">top</span> <span class=\"err\">Γ</span>        <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">bot</span> <span class=\"err\">Γ</span>        <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">prod</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"err\">Γ</span> <span class=\"o\">:=</span> <span class=\"n\">WF</span> <span class=\"bp\">_</span> <span class=\"n\">a</span> <span class=\"err\">Γ</span> <span class=\"bp\">∧</span> <span class=\"n\">WF</span> <span class=\"bp\">_</span> <span class=\"n\">b</span> <span class=\"err\">Γ</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"err\">Γ</span>    <span class=\"o\">:=</span> <span class=\"n\">WF</span> <span class=\"bp\">_</span> <span class=\"n\">a</span> <span class=\"err\">Γ</span> <span class=\"bp\">∧</span> <span class=\"n\">WF</span> <span class=\"bp\">_</span> <span class=\"n\">α</span> <span class=\"err\">Γ</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span><span class=\"err\">&#39;</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"err\">Γ</span>   <span class=\"o\">:=</span> <span class=\"n\">WF</span> <span class=\"bp\">_</span> <span class=\"n\">p</span> <span class=\"err\">Γ</span> <span class=\"bp\">∧</span> <span class=\"n\">WF</span> <span class=\"bp\">_</span> <span class=\"n\">q</span> <span class=\"err\">Γ</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span><span class=\"err\">&#39;</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"err\">Γ</span>   <span class=\"o\">:=</span> <span class=\"n\">WF</span> <span class=\"bp\">_</span> <span class=\"n\">p</span> <span class=\"err\">Γ</span> <span class=\"bp\">∧</span> <span class=\"n\">WF</span> <span class=\"bp\">_</span> <span class=\"n\">q</span> <span class=\"err\">Γ</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"err\">⟹</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"err\">Γ</span>  <span class=\"o\">:=</span> <span class=\"n\">WF</span> <span class=\"bp\">_</span> <span class=\"n\">p</span> <span class=\"err\">Γ</span> <span class=\"bp\">∧</span> <span class=\"n\">WF</span> <span class=\"bp\">_</span> <span class=\"n\">q</span> <span class=\"err\">Γ</span>\n</code></pre></div>",
        "id": 195713258,
        "sender_full_name": "Billy Price",
        "timestamp": 1588168901
    }
]