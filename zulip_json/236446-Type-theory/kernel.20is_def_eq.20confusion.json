[
    {
        "content": "<p>1) i was looking through lean's kernel code and was surprised to find that, apparently, <code>is_def_eq</code> (which is mostly just a wrapper for <a href=\"https://github.com/leanprover/lean4/blob/master/src/kernel/type_checker.cpp#L1002\"><code>is_def_eq_core</code></a>) doesn't seem to unfold definitions.<br>\nnear the bottom of the function, a comment claims \"At this point, t_n and s_n are in weak head normal form  (modulo metavariables and proof irrelevance)\", even though there are only calls to <code>whnf_core</code>, which doesn't unfold definitions.<br>\n(i don't quite understand that comment about proof irrelevance either, as <code>is_def_eq_proof_irrel(t_n, s_n)</code> was checked above.)<br>\ndoes the front-end unfold definitions before passing terms to the kernel, or am i missing something? (that would be odd, given that not all definitions need to be unfolded.)<br>\nit seems, without unfolding, <code>is_def_eq(\"a.succ\", \"a + 1\")</code> would return false.</p>\n<p>2) the code, that handles <a href=\"https://github.com/leanprover/lean4/blob/master/src/kernel/type_checker.cpp#L1037\">def-eq of constants</a>, only returns true, if the terms are the same constant <em>and</em> the levels are def-eq. why can't this return <code>false</code>, if the terms are the same constants, but the levels are <em>not</em> def-eq (ie <code>if same_constants(a, b) { return levels_eq(a.levels, b.levels) }</code>)?</p>\n<p>(3: is this actually the right channel for this question? :D)</p>\n<p>for context: i stumbled upon this, cause i was trying to figure out what <code>@[reducible]</code> meant. i remembered something like \"that's used by the elaborator, the kernel can unfold all definitions\".</p>",
        "id": 385486005,
        "sender_full_name": "Leonard Wigman",
        "timestamp": 1692199096
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"456923\">@Leonard Wigman</span> <br>\n(1) although I'm not entirely sure by looking at the code, I am certain that <code>is_def_eq_core</code> does in fact unfold definitions, and actually <code>unfold_definition</code> it is reachable in several places from that function. I would have to test it with a basic example like <code>a.succ =?= a + 1</code> to be sure.<br>\n(2) No that would not be correct, because you could have <code>def Foo.{u} : Type := Unit</code> and then <code>Foo.{1}</code> and <code>Foo.{2}</code> are defeq.<br>\n(3) I don't think it is, <a class=\"stream\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4\">#lean4</a> or <a class=\"stream\" data-stream-id=\"341532\" href=\"/#narrow/stream/341532-lean4-dev\">#lean4 dev</a> seems like a better place to get authoritative answers about this from devs.</p>",
        "id": 385499153,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1692203213
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, thanks!<br>\n1) oh, i completely missed <code>r = lazy_delta_reduction(t_n, s_n);</code>, that would explain it :^)</p>\n<p>2) i'm not sure i understand. for <code>Foo.{1}</code> and <code>Foo.{2}</code>, the const <code>Foo</code> would be the same. then returning <code>is_def_eq(const_levels(t_n), const_levels(s_n))</code> would return <code>false</code>, because level <code>1</code> is not equivalent to <code>2</code> <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span><br>\nto be clear, i'm proposing:</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"c1\">// old</span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">is_constant</span><span class=\"p\">(</span><span class=\"n\">t_n</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">is_constant</span><span class=\"p\">(</span><span class=\"n\">s_n</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">const_name</span><span class=\"p\">(</span><span class=\"n\">t_n</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">const_name</span><span class=\"p\">(</span><span class=\"n\">s_n</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span>\n<span class=\"w\">        </span><span class=\"n\">is_def_eq</span><span class=\"p\">(</span><span class=\"n\">const_levels</span><span class=\"p\">(</span><span class=\"n\">t_n</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">const_levels</span><span class=\"p\">(</span><span class=\"n\">s_n</span><span class=\"p\">)))</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">true</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// new</span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">is_constant</span><span class=\"p\">(</span><span class=\"n\">t_n</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">is_constant</span><span class=\"p\">(</span><span class=\"n\">s_n</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">const_name</span><span class=\"p\">(</span><span class=\"n\">t_n</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">const_name</span><span class=\"p\">(</span><span class=\"n\">s_n</span><span class=\"p\">))</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">is_def_eq</span><span class=\"p\">(</span><span class=\"n\">const_levels</span><span class=\"p\">(</span><span class=\"n\">t_n</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">const_levels</span><span class=\"p\">(</span><span class=\"n\">s_n</span><span class=\"p\">));</span>\n</code></pre></div>\n<p>3) okay, i'll use #lean4 next time <span aria-label=\"ok\" class=\"emoji emoji-1f44c\" role=\"img\" title=\"ok\">:ok:</span></p>",
        "id": 385504154,
        "sender_full_name": "Leonard Wigman",
        "timestamp": 1692205136
    },
    {
        "content": "<blockquote>\n<p>2) i'm not sure i understand. for Foo.{1} and Foo.{2}, the const Foo would be the same. then returning is_def_eq(const_levels(t_n), const_levels(s_n)) would return false, because level 1 is not equivalent to 2 </p>\n</blockquote>\n<p>Right, I'm saying that <code>false</code> is the wrong answer, because <code>Foo.{1}</code> and <code>Foo.{2}</code> are defeq</p>",
        "id": 385511385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1692208229
    },
    {
        "content": "<p>we need to proceed to the rest of the function to do the unfolding work, because the answer could be <code>true</code>, and is in this case</p>",
        "id": 385511502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1692208289
    },
    {
        "content": "<blockquote>\n<p>because <code>Foo.{1}</code> and <code>Foo.{2}</code> are defeq</p>\n</blockquote>\n<p>oh interesting!<br>\ni just assumed definitions were injective, which they of course aren't.<br>\nwhich means, i also have a bug in my <code>c1 args1 =?= c2 args2</code> code, whoops :D</p>\n<p>i should probably go over the typing rules again. i think i assumed, if i fail to show the premises of a rule, the terms are not def-eq. but it's more like the rules \"induce\" the def-eq terms, so all rules have to fail.</p>",
        "id": 385534312,
        "sender_full_name": "Leonard Wigman",
        "timestamp": 1692217317
    }
]