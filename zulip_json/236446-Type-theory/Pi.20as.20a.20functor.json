[
    {
        "content": "<p>For every type A, the function <code>fun (B : Type) =&gt; A -&gt; B</code> is a functor, with the map operation being function composition. So I have a couple of questions about it:</p>\n<p>1- Why doesn't Lean consider this as a functor (in stdlib)? Haskell does, which is very useful IMO</p>\n<p>2- I tried manually defining a Functor instance for it, but it doesn't seem to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Function.comp</span>\n\n<span class=\"c1\">-- works:</span>\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">Function.comp</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"c1\">-- fails:</span>\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">Functor.map</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n</code></pre></div>\n<p>(btw I'm asking here both because there's no channel for neither category theory nor functional programming, and also because universe issues seem to be related to this)</p>",
        "id": 526306534,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1751245977
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> Functor</p>",
        "id": 526306751,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751246232
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Functor\">Functor</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Applicative.toFunctor\">Applicative.toFunctor</a>, and <a href=\"https://loogle.lean-lang.org/?q=Functor\">108 more</a></p>",
        "id": 526306752,
        "sender_full_name": "loogle",
        "timestamp": 1751246234
    },
    {
        "content": "<p>there are only 110 results with Functor so I don't think it's used a lot</p>",
        "id": 526306760,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751246243
    },
    {
        "content": "<p>do you really want it for functional programming, or are you asking about category theory in Mathlib?</p>",
        "id": 526306775,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751246261
    },
    {
        "content": "<p>Lean uses <code>Reader</code> to opt-in to using it as a functor/monad</p>",
        "id": 526306836,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751246337
    },
    {
        "content": "<p>The equivalent of the functor/monad in Haskell is <code>Reader</code></p>",
        "id": 526307163,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751246713
    },
    {
        "content": "<p>Cool, how is it used?<br>\nI tried</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">Functor.map</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ReaderM</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n</code></pre></div>\n<p>but it doesn't work</p>",
        "id": 526307308,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1751246874
    },
    {
        "content": "<p>Instead of <code>(id : ReaderM Nat Nat)</code> you want <code>(read : ReaderM Nat Nat)</code></p>",
        "id": 526307360,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751246944
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- 3</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">read</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ReaderM</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n</code></pre></div>",
        "id": 526307384,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751246978
    },
    {
        "content": "<p>Thanks, weird that it fails without the type assertion.<br>\nIs there an easy way to convert <code>A -&gt; B</code> to <code>ReaderM A B</code>? Or even better, a coercion?</p>",
        "id": 526307547,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1751247159
    },
    {
        "content": "<p>The reason the <code>id</code> example fails is that type ascriptions aren't coercions (they only make sure that the type is definitionally equal to what it's supposed to be, not that the type will be structurally equal).</p>\n<p>Amusingly, <code>id</code> can be used to \"save\" the type.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ReaderM</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n</code></pre></div>\n<p>More idiomatically there's <code>show</code>, whose semantics are to make sure the type is structurally equal to what you say it is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">ReaderM</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n</code></pre></div>",
        "id": 526307779,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751247386
    },
    {
        "content": "<p>Coercion would definitely be bad, but you can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">funToReaderM</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ReaderM</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">read</span>\n</code></pre></div>",
        "id": 526307818,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751247424
    },
    {
        "content": "<p>Or there's using <code>do</code> and <code>read</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">read</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ReaderM</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n</code></pre></div>",
        "id": 526307865,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751247471
    },
    {
        "content": "<p>Anyway, this is a contrived example; in practice you can pass a function to anything that expects specifically a <code>ReaderM</code> argument.</p>\n<p>And also in practice you don't use the functor interface when <code>∘</code> will do</p>",
        "id": 526307948,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751247578
    },
    {
        "content": "<p><em>but I heard that defeq abuse is bad</em></p>",
        "id": 526307999,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751247647
    },
    {
        "content": "<p>Very weird, but seems to mostly work, although I definitely don't understand the rules which allow passing a function as a reader. Also, why does having an actual coercion for it in the standard library so bad?</p>",
        "id": 526308733,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1751248335
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Pi.20as.20a.20functor/near/526307948\">said</a>:</p>\n<blockquote>\n<p>Anyway, this is a contrived example; in practice you can pass a function to anything that expects specifically a <code>ReaderM</code> argument.</p>\n<p>And also in practice you don't use the functor interface when <code>∘</code> will do</p>\n</blockquote>\n<p>Are there equivalent operations defined on functions for fancier types of composition, like <code>&lt;*&gt;</code>? i.e. <code>fun x =&gt; f x (g x)</code></p>",
        "id": 526308870,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1751248471
    },
    {
        "content": "<p>You can use <code>&lt;*&gt;</code> for <code>ReaderM</code> and <code>ReaderT</code></p>",
        "id": 526308933,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751248523
    },
    {
        "content": "<p>not for regular functions though</p>",
        "id": 526308945,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751248537
    },
    {
        "content": "<p>There might be an operator for the S combinator somewhere, but it's not really Lean style to use fancy compositions. Dependent types are hard enough, no need to tax the neurons with complicated combinators :-)</p>",
        "id": 526309050,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751248641
    },
    {
        "content": "<p>Yeah but that kinda defeats the short point-free writing style for functional programming.<br>\nReplacing <code>fun x =&gt; f x (g x)</code> with <code>f &lt;*&gt; g</code> is great, but if I have to instead use<br>\n<code>((funToReaderM f) &lt;*&gt; (funToReaderM g))</code><br>\nthen it defeats the purpose</p>",
        "id": 526309073,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1751248665
    },
    {
        "content": "<p>The idea is that you'd work entirely with ReaderM, because that captures the idea of what you're doing (threading in an argument across multiple functions)</p>",
        "id": 526309111,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751248700
    },
    {
        "content": "<p>pointfree is great, but sometimes I lose track of where everything is going</p>",
        "id": 526309196,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751248801
    },
    {
        "content": "<p>I prefer not to swap functions in theorems for ReaderM (specifically I have a graph G on V, and I'd need a <code>ReaderM V</code>), but it's okay if proofs use fancy functional programming shenanigans</p>",
        "id": 526309431,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1751249009
    },
    {
        "content": "<p>So it sounds like you both suggest ignoring the urge to swap an S combinator that appears in the wild with an actual <code>&lt;*&gt;</code><br>\nI'll go with that, thank you!</p>",
        "id": 526309774,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1751249327
    },
    {
        "content": "<p>I'd suggest also maybe not using any combinators, since that's just one more thing to unfold when proving things. Plain lambdas with actual variables tend to be easiest.</p>\n<p>But it's too hard to speak about this in generalities. If you have some concrete code, it's probably worth taking a look.</p>",
        "id": 526310081,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751249739
    }
]