[
    {
        "content": "<p>To what extent do Lean structuresallow us  emulate ML modules? In principle modules are implementable as dependent sum types. I know lean structures don't :</p>\n<ol>\n<li>Act as a compilation unit</li>\n<li>allow recursive fields (ofc you can use an inductive declaration instead)</li>\n<li>Provide data hiding (like say a private keyword)</li>\n</ol>\n<p>Is there more?</p>",
        "id": 469482820,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726080185
    },
    {
        "content": "<p>This is a question that comes out of a discussion with Bhavik</p>",
        "id": 469482850,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726080198
    },
    {
        "content": "<p>Can you give a short example of an ML module using 2 or 3 that is hard to translate to Lean?</p>",
        "id": 470385203,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1726432150
    },
    {
        "content": "<p>I am not on a computer, but the example on the ocaml manual seems nice: <a href=\"https://ocaml.org/manual/5.2/recursivemodules.html\">https://ocaml.org/manual/5.2/recursivemodules.html</a></p>",
        "id": 470385676,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726432555
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 470385742,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726432576
    },
    {
        "content": "<p>It allows you to encapsulate an algebraic data type with a function that acts on it.</p>",
        "id": 470385866,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726432666
    },
    {
        "content": "<p>You can add data hiding by implementing extra functions in the struct that are not present in the signature. Those declarations are hidden</p>",
        "id": 470386006,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726432710
    },
    {
        "content": "<p>I found a useful explanation of hiding: <a href=\"https://cs3110.github.io/textbook/chapters/modules/encapsulation.html\">https://cs3110.github.io/textbook/chapters/modules/encapsulation.html</a></p>",
        "id": 470386594,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726433238
    },
    {
        "content": "<p>It provides a lot of nice examples of how a module's hidden functions can be used by other module functions but not outside the module</p>",
        "id": 470386603,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726433256
    },
    {
        "content": "<p>FWIW, it looks like this is on the FRO's <a href=\"https://lean-fro.org/about/roadmap-y2/\">roadmap</a> for this year, in language frontend. I think I remember reading/hearing something about private symbols being part of this, but I can't find it rigth now</p>",
        "id": 470461588,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1726465792
    },
    {
        "content": "<p>(by private I understand that to be these hdden functions, or more generally, identifiers)</p>",
        "id": 470461754,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1726465851
    },
    {
        "content": "<p>the word \"module\" covers a wide spectrum of implementations and features from simple namespacing to the stuff I mentioned above. I don't think the FRO wants to implement ML style modules based on Sebastian's response to my question in one of the FRO community meetings in late 2023 or early 2024. My curiosity is purely about how much of it would fit into lean's type theory.</p>",
        "id": 470560802,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726486002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Emulating.20ML.20modules/near/469482820\">said</a>:</p>\n<blockquote>\n<p>Is there more?</p>\n</blockquote>\n<p>What about signatures? Where  a <strong>signature</strong> is a type definition that specifies the interface of a module. It defines the types and values that a module must provide, without exposing implementation details. It acts as a contract separating interface from implementation 'in the large'.</p>",
        "id": 470982579,
        "sender_full_name": "Yuri",
        "timestamp": 1726580150
    },
    {
        "content": "<p>That's true. But if we ignore encapsulation and abstraction, a structure's instantiations are implementations, while the structure itself is a signature. Ofc this still does not give us file level modules and is not strictly a contract that hides implementation details</p>",
        "id": 470983943,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726580461
    },
    {
        "content": "<p>I guess I don't quite understand why this is about Lean's type theory, it doesn't really say anything about e.g. the visibility of identifiers accross files and stuff like that, does it? that's kind of orthogonal infrastructure isn't it?</p>",
        "id": 471002455,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1726583994
    },
    {
        "content": "<p>More than one source has told me that ML module types and their associated polymorphism and data hiding is incompatible with dependent types. I am trying to understand why and to what extent one can recover some nice features of ML modules</p>",
        "id": 471002808,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726584080
    },
    {
        "content": "<p>What I understand (and have worked with formally) is a semantics of modules in system F as existential types.</p>",
        "id": 471003462,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726584209
    },
    {
        "content": "<p>Isn't Coq's module system similar? <a href=\"https://coq.inria.fr/doc/V8.18.0/refman/language/core/modules.html\">https://coq.inria.fr/doc/V8.18.0/refman/language/core/modules.html</a> <br>\nAnd Coq does have dependent types.</p>",
        "id": 471206947,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1726650162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Emulating.20ML.20modules/near/470983943\">said</a>:</p>\n<blockquote>\n<p>while the structure itself is a signature</p>\n</blockquote>\n<p>I think this is not quite accurate - ML signatures match ML structures _structurally_, which is to say that a given module can be compatible with signatures that didn't even exist when it was implemented. Using iterated sigma types to emulate a module system misses out on this, though it can be faked with fancy enough elaboration a la coercive subtyping.</p>",
        "id": 473656006,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1727687658
    },
    {
        "content": "<p>Okay so there is some structural subtyping rules that have to be emulated somehow</p>",
        "id": 474136879,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727820929
    },
    {
        "content": "<p>So far my impression is that different features of ML modules are supported wholly or partially by different Lean constructs, but there is no unifying construct that adds all the above.</p>",
        "id": 474137035,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727820998
    },
    {
        "content": "<p>Some of the features are supported to various degrees in various ways, yeah</p>",
        "id": 474292628,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1727874375
    },
    {
        "content": "<p>One thing you'd have a hard time getting is generative functors, which won't matter so much in a pure language</p>",
        "id": 474292812,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1727874399
    }
]