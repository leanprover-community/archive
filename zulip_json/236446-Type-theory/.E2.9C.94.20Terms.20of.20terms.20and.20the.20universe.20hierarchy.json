[
    {
        "content": "<p>Hello, I hope the question is not too tangled, but I was trying to better understand type universes, and I’m confused on one point and TPIL didn’t really clear my doubt. </p>\n<p>Since I can write <code>3 : ℕ : Type 1 : Type 2 : … </code>,  I’m naturally tempted to also write: <code> ? : t : T : Type 2 : Type 3: … </code> except <code>? : t </code> doesn’t work since<code>t</code> is not a type. However if I think of <code>Type 1</code> as “the class of all sets”, I thought it would be natural to think of <code>Type 2</code> as  “the class of all things like the class of all sets”, but then I would expect the line above to make sense. So it seems more that <code>T:Type 2</code> is like <code>T:Type 1</code> (and the latter I think of as “T is like a set, except you have more information as to how to construct its elements”) , and the fact that it is in <code>Type 2</code> is not really important, as if we “started from scratch” at each level. Except of course that <code>Type 1  :  Type 2</code> is <em>not</em> like a set. </p>\n<p>So in summary I think my questions are: <br>\na) is there any other term of <code>Type 2</code> that “looks like” <code>Type 1</code>,  in the sense that its terms are also Types, or is a term T also a type iff.  <code>T : Type u</code>?<br>\nb) What “are” the terms of <code>Type u + 1 </code> other than <code>Type u </code>?</p>",
        "id": 407816345,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1702504261
    },
    {
        "content": "<p>A term is a type iff it has the type <code>Sort u</code> for some u. So that should answer question (a)</p>",
        "id": 407817460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702504737
    },
    {
        "content": "<p>For (b), other types in <code>Type (u+1)</code> which are not universes include <code>Type u -&gt; Type u</code> (this is a collection of functions, not types) or <code>List (Type u)</code> (the type of all lists of types)</p>",
        "id": 407817731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702504828
    },
    {
        "content": "<p>That helps quite a bit. Thank you!</p>",
        "id": 407818330,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1702505007
    },
    {
        "content": "<p>I think that the fact that <code>Type n : Type (n+1)</code> is confusing and misleading. It's only true because everything has to have a type. I think that a much better way to understand the world of all lean things is to focus on the three layer stratification: there are terms, types and universes, so you have <code>t : T</code> and <code>T : U</code> and just forget that universes have types because this is really just some glitch in the theory and not relevant in most use cases. Examples include <code>2 : Nat</code> and <code>Nat : Type</code>, and <code>proof : statement</code> and <code>statement : Prop</code>.</p>",
        "id": 407827563,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702509406
    },
    {
        "content": "<p>In short I'm saying that you should forget <code>Type 1 : Type 2</code> and just consider this an irrelevant implementation detail which is false in some parallel universe where instead they just had <code>Type n : U</code> for some uberuniverse U and for all n.</p>",
        "id": 407827728,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702509516
    },
    {
        "content": "<p>Another way of saying it: Type 1 is a completely unrepresentative term of type Type 2 because it's a universe not a type.</p>",
        "id": 407828554,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702510007
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466290\">@Luigi Massacci</span> : Here's an artificial way to introduce new types of <code>Type 2</code> for example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Example</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">2</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">construct</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Example</span>\n\n\n<span class=\"k\">#check</span> <span class=\"n\">Example.construct</span> <span class=\"o\">(</span><span class=\"n\">Monad</span> <span class=\"n\">IO</span><span class=\"o\">)</span> <span class=\"n\">ℕ</span> <span class=\"mi\">1</span>\n<span class=\"k\">#check</span> <span class=\"n\">Example</span>\n</code></pre></div>",
        "id": 407828914,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1702510187
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Terms.20of.20terms.20and.20the.20universe.20hierarchy/near/407828554\">said</a>:</p>\n<blockquote>\n<p>Another way of saying it: Type 1 is a completely unrepresentative term of type Type 2 because it's a universe not a type.</p>\n</blockquote>\n<p><code>Type 1</code> is a trivial example of a term of <code>Type 2</code> in the same sense that an isolated vertex is an example of a graph, even if it doesn't tell you much about what graphs really are.</p>",
        "id": 407829451,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1702510453
    },
    {
        "content": "<p>Thank you for the example, I think I'll stick with <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s philosophy and not really investigate further for the time being</p>",
        "id": 407838348,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1702515076
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466290\">Luigi Massacci</span> has marked this topic as resolved.</p>",
        "id": 407838366,
        "sender_full_name": "Notification Bot",
        "timestamp": 1702515086
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466290\">@Luigi Massacci</span> In <a href=\"https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects\">https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects</a> partway down there's a table that shows the three levels (terms, types, and sorts). Going up in the table is the \"has type\" relation. The fact that there is a \"has type\" relation along the first row (sorts) is what Kevin is calling a glitch.</p>\n<p>I've heard that even \"term has type\" and \"type has sort\" are sometimes separated into two different relations in other type theories.</p>",
        "id": 407839545,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702515639
    }
]