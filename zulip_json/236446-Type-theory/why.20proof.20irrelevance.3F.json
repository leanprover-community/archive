[
    {
        "content": "<p>what purpose does proof irrelevance serve?</p>\n<p>i.e. what if we treat theorems as normal types and each distinct proof of it as distinct objects?<br>\nwhat ill will such an implementation introduce?</p>\n<p>is proof irrelevance for logical or efficiency purpose?</p>\n<p>thanks~</p>",
        "id": 528853198,
        "sender_full_name": "Ping J",
        "timestamp": 1752583866
    },
    {
        "content": "<p>I'm not really familiar with this but I suspect it might have to do with allowing propositions to quantify over any type</p>",
        "id": 528854657,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752584279
    },
    {
        "content": "<p>I think it's so we can not have to worry about how something is proved</p>",
        "id": 528854773,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752584310
    },
    {
        "content": "<p>It makes things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Fin/Lemmas.html#Fin.ext_iff\">Fin.ext_iff</a> true. Otherwise one can have <code>i.val = j.val</code> but with different proofs. This is completely crazy from a mathematician's point of view.</p>",
        "id": 528855415,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1752584468
    },
    {
        "content": "<p>Proof irrelevance, in particular uniqueness of identity proofs (i.e. <code>(p q : a = b) -&gt; p = q</code>), makes types behave more like sets, otherwise they behave more like infinity groupoids.</p>",
        "id": 528855546,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752584500
    },
    {
        "content": "<p>Here is an example: if you have <code>p q : a = b</code> and <code>t : P a</code> then <code>p ‚ñ∏ t</code> will no longer be (automatically) the same as <code>q ‚ñ∏ t</code>. You would have to prove that <code>p = q</code> and then the lemma <code>p = q -&gt; p ‚ñ∏ t = q ‚ñ∏ t</code>.</p>",
        "id": 528856043,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752584618
    },
    {
        "content": "<p>So in particular, whenever you have a variable <code>X : Type</code> you will also need to assume <code>(a b : X) (p q : a = b) -&gt; p = q</code>.</p>",
        "id": 528856236,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752584670
    },
    {
        "content": "<p>i see.</p>",
        "id": 528856518,
        "sender_full_name": "Ping J",
        "timestamp": 1752584751
    },
    {
        "content": "<p>cheers to all :_)</p>",
        "id": 528856574,
        "sender_full_name": "Ping J",
        "timestamp": 1752584766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"937033\">Ping J</span> has marked this topic as resolved.</p>",
        "id": 528856665,
        "sender_full_name": "Notification Bot",
        "timestamp": 1752584790
    },
    {
        "content": "<p>It also means that things like the powerset are in the same universe. If <code>Set X := X -&gt; Type</code> then <code>Set X : Type 1</code>.</p>",
        "id": 528890764,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1752594280
    },
    {
        "content": "<p>A more technical answer: <a href=\"https://rocq-prover.org/doc/V9.0.0/stdlib/Stdlib.Logic.Berardi.html\">https://rocq-prover.org/doc/V9.0.0/stdlib/Stdlib.Logic.Berardi.html</a></p>\n<p>Impredicativity ‚àß excluded middle ‚Üí proof irrelevance. And you want impredicativity for power and convenience.</p>",
        "id": 528912425,
        "sender_full_name": "suhr",
        "timestamp": 1752601620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"937033\">Ping J</span> has marked this topic as unresolved.</p>",
        "id": 528968362,
        "sender_full_name": "Notification Bot",
        "timestamp": 1752631281
    },
    {
        "content": "<p>hmmm, deep, dark, and interesting.</p>\n<p>i'm not sure i fully understood the last contradiction</p>",
        "id": 528968400,
        "sender_full_name": "Ping J",
        "timestamp": 1752631314
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/236446-Type-theory/topic/why.20proof.20irrelevance.3F/near/528855415\">said</a>:</p>\n<blockquote>\n<p>It makes things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Fin/Lemmas.html#Fin.ext_iff\">Fin.ext_iff</a> true. Otherwise one can have <code>i.val = j.val</code> but with different proofs. This is completely crazy from a mathematician's point of view.</p>\n</blockquote>\n<p>So crazy that it does not happen :-) The equality in <code>Nat</code> is provably decidable, so by <a href=\"https://ncatlab.org/nlab/show/Hedberg%27s+theorem\">Hedberg's theorem</a> <code>Nat</code> satisfies UIP. In particular, any two proofs of <code>i.val = j.val</code> can be identified, which means that <code>Fin.ext_iff</code> is provable without assuming proof irrelevance.</p>",
        "id": 528988161,
        "sender_full_name": "Florent Schaffhauser",
        "timestamp": 1752646995
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/channel/236446-Type-theory/topic/why.20proof.20irrelevance.3F/near/528890764\">said</a>:</p>\n<blockquote>\n<p>It also means that things like the powerset are in the same universe. If <code>Set X := X -&gt; Type</code> then <code>Set X : Type 1</code>.</p>\n</blockquote>\n<p>You could also define <code>Set X := X -&gt; hProp</code>, where <code>hProp</code> is now the subtype of propositions in <code>Type</code>, and then <code>Set X : Type</code> as desired? </p>\n<p>I guess you need <a href=\"https://ncatlab.org/nlab/show/propositional+resizing\">propositional resizing</a> to justify that <code>hProp</code> is <code>Type</code>-small, though.</p>",
        "id": 528988426,
        "sender_full_name": "Florent Schaffhauser",
        "timestamp": 1752647128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"513540\">Florent Schaffhauser</span> <a href=\"#narrow/channel/236446-Type-theory/topic/why.20proof.20irrelevance.3F/near/528988161\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/236446-Type-theory/topic/why.20proof.20irrelevance.3F/near/528855415\">said</a>:</p>\n<blockquote>\n<p>It makes things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Fin/Lemmas.html#Fin.ext_iff\">Fin.ext_iff</a> true. Otherwise one can have <code>i.val = j.val</code> but with different proofs. This is completely crazy from a mathematician's point of view.</p>\n</blockquote>\n<p>So crazy that it does not happen :-) The equality in <code>Nat</code> is provably decidable, so by <a href=\"https://ncatlab.org/nlab/show/Hedberg%27s+theorem\">Hedberg's theorem</a> <code>Nat</code> satisfies UIP. In particular, any two proofs of <code>i.val = j.val</code> can be identified, which means that <code>Fin.ext_iff</code> is provable without assuming proof irrelevance.</p>\n</blockquote>\n<p>OMG you really switched to the dark side :D OK let's consider <code>‚Ñù‚â•0</code> then.</p>",
        "id": 529034498,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1752664334
    },
    {
        "content": "<p>do we even need that, like I feel like <code>‚Ñù</code> might already be different from our <code>‚Ñù</code>?</p>",
        "id": 529034736,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752664431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/stream/236446-Type-theory/topic/why.20proof.20irrelevance.3F/near/528912425\">said</a>:</p>\n<blockquote>\n<p>A more technical answer: <a href=\"https://rocq-prover.org/doc/V9.0.0/stdlib/Stdlib.Logic.Berardi.html\">https://rocq-prover.org/doc/V9.0.0/stdlib/Stdlib.Logic.Berardi.html</a></p>\n<p>Impredicativity ‚àß excluded middle ‚Üí proof irrelevance. And you want impredicativity for power and convenience.</p>\n</blockquote>\n<p>One more thing to note here is that Berardi gives you propositional proof irrelevance, whereas Lean has definitional proof irrelevance which makes a difference to the metatheory.</p>",
        "id": 529602377,
        "sender_full_name": "ùö†ùöòùöìùöåùöíùöéùöåùöë ùöóùöäùö†ùöõùöòùöåùöîùöí",
        "timestamp": 1752946540
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/236446-Type-theory/topic/why.20proof.20irrelevance.3F/near/529034736\">said</a>:</p>\n<blockquote>\n<p>do we even need that, like I feel like <code>‚Ñù</code> might already be different from our <code>‚Ñù</code>?</p>\n</blockquote>\n<p>For the Cauchy reals, we need more axioms for quotient types without proof irrelevance (unless it's definable as an inductive type <code>SetQuotient</code> like in cubical Agda, in which case zero axioms) to completely specify its behavior, but then the real numbers should be the same. In particular the equality type has at most one element.</p>\n<p>Of course, HoTT people adopt propositional proof irrelevance too, since it's the very definition of being a homotopy proposition. So a relevant (no pun intended) question is \"Why definitional proof irrelevance?\"</p>",
        "id": 531280683,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1753682058
    },
    {
        "content": "<p>Is this the same as definitional equality? Or not?<br>\ni.e. a function taking a term of type T will accept also a term of type T' as long as T is definitionally equivalent to T'. By which I believe is meant, that by reducing T and T' to their normal forms by means of expanding out all definitions. Please correct me if I am wrong.</p>",
        "id": 536884644,
        "sender_full_name": "Mr Proof",
        "timestamp": 1756524681
    },
    {
        "content": "<p>Yes, that is basically what definitional equality is (although I think there might be some nuance in that some pathological expressions in Lean don't have normal forms). The proof irrelevance being discussed here is a special case of definitional equality which applies to Lean, but not every other DTT based theorem prover.</p>",
        "id": 536886155,
        "sender_full_name": "Niels Voss",
        "timestamp": 1756526839
    },
    {
        "content": "<p>Yeah, Lean's reduction rules don't normalize. Proof irrelevance is in fact a cause for this: <a href=\"https://arxiv.org/abs/1911.08174\">https://arxiv.org/abs/1911.08174</a></p>\n<blockquote>\n<p>By which I believe is meant, that by reducing T and T' to their normal forms by means of expanding out all definitions.</p>\n</blockquote>\n<p>More precisely, there's definitional equality the relation and definitional equality the algorithm. The ideal definitional equality does not need normalization: terms are definitionally equal if there's any sequence of basic reductions (either applied forward or backward) that brings the first term to the second. The algorithm however does its best to see that terms are definitionally equal, but it might fail even if they really are definitionally equal. It uses heuristics to try to limit the number of reductions done.</p>\n<p>Proof irrelevance (\"Axiom K\") is one of the rules that you can choose definitional equality to have. Unlike beta/eta/zeta/delta reduction, it doesn't really have a sense of direction, it's not a \"reduction\", but a mere \"judgment\". It's just that you can substitute one proof for an arbitrary other proof of the same proposition. It's not compatible with thinking about definitional equality in terms of reducing to normal forms.</p>\n<p>An interesting use of proof irrelevance is in reducing recursors. Suppose you have a proof <code>h : a = a</code>. Then <code>Eq.refl a</code> is definitionally equal to <code>h</code> by proof irrelevance. So, the term <code>Eq.recOn h r</code> is definitionally equal to <code>Eq.recOn (Eq.refl a) r</code> is definitionally equal to <code>r</code>. The first is by proof irrelevance and the second is \"iota reduction\" (the \"computation rule\" for the recursor applied to a constructor). The fact that we know <code>Eq.refl a</code> is a proof of <code>a = a</code> from the type alone justifies reducing <code>Eq.recOn h r</code> to <code>r</code>. Lean puts this reasoning to use:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∏</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 536889478,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756530264
    }
]