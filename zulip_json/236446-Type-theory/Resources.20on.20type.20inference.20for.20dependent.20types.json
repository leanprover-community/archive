[
    {
        "content": "<p>I would like to understand how dependent type inference works, but am struggling to get a foothold. Is there a central resource or text book that covers this territory?</p>",
        "id": 289002275,
        "sender_full_name": "ohhaimark",
        "timestamp": 1657320630
    },
    {
        "content": "<p>As far as I know, the best theoretically-motivated approach is bidirectional typechecking, e.g. in this <a href=\"https://www.cl.cam.ac.uk/~nk480/bidir-survey.pdf\">survey</a>. However (again, afaik) there isn't really a theory of what Lean specifically does - it is a rather complicated algorithm based on higher-order unification and metavariables which encapsulate their local environment. Metavariables represent \"holes\" in the expression to be filled in at some later point. An early incarnation of these appeared in Conor McBride's <a href=\"http://www.lfcs.inf.ed.ac.uk/reports/00/ECS-LFCS-00-419/ECS-LFCS-00-419.pdf\">thesis</a>. Metavariables can be filled (\"elaborated\") in any order - this mechanism is known as <em>postponing</em>. This can generally infer much more than the bidirectional approach. The Lean 4 metaprogramming book describes various practical aspects, e.g. <a href=\"https://github.com/arthurpaulino/lean4-metaprogramming-book/blob/master/md/main/elaboration.md#term-elaboration-1\">here</a>.</p>",
        "id": 289008409,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1657326879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"244748\">ohhaimark</span> has marked this topic as resolved.</p>",
        "id": 289008889,
        "sender_full_name": "Notification Bot",
        "timestamp": 1657327552
    },
    {
        "content": "<p>This article <a href=\"https://leanprover.github.io/reference/expressions.html#expression-syntax\">https://leanprover.github.io/reference/expressions.html#expression-syntax</a> explains how Lean kernel determines the type of a fully elaborated expression. It may help better understand dependent types in general.</p>",
        "id": 289016085,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1657338042
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"244748\">@ohhaimark</span> I fond the survey posed by Wojceicg very useful. When it came to <em>implementing</em> the algorithm, I found the tutorial <a href=\"https://davidchristiansen.dk/tutorials/nbe/\">checking dependent types with normalization by evaluation: a tutorial by david thrane christiansen</a> to be the most hands-on. </p>\n<p>Here's a repo with the same implemented in haskell, along with papers I found enlightening when learning this stuff: <a href=\"https://github.com/bollu/minitt\">https://github.com/bollu/minitt</a></p>",
        "id": 289076572,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1657421540
    },
    {
        "content": "<p>In NbE, why is eta-expansion done rather than eta-reduction when doing a read-back?</p>",
        "id": 290226166,
        "sender_full_name": "ohhaimark",
        "timestamp": 1658318932
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"244748\">ohhaimark</span> has marked this topic as unresolved.</p>",
        "id": 290226227,
        "sender_full_name": "Notification Bot",
        "timestamp": 1658318977
    },
    {
        "content": "<blockquote>\n<p>In NbE, why is eta-expansion done rather than eta-reduction when doing a read-back?</p>\n</blockquote>\n<p>Eta-long normal forms are easy to implement - when readback sees a type with an eta rule, it can immediately spit out the corresponding introduction form and recur down to each sub-expression. For instance, if the type is <code>Unit</code>, just emit <code>Unit.unit</code>, and if the type is <code>A -&gt; B</code>, just emit a <code>fun (x : A) =&gt;</code> and read back the value applied to <code>x</code> at type <code>B</code>. This works for everything with a nice eta rule but <code>Empty</code>, for which some special hacks are needed (but if you're reading back normal forms for conversion checking, then you'll have a slow implementation anyway - the right answer is to convert the values incrementally based on their types, only computing what's needed, and then you can just directly equate all values of type <code>Empty</code> with no further computation).</p>\n<p>Univesral eta contraction is more difficult. For functions, it's reasonably easy to implement, but not efficiently (it requires a full traversal of the body to find variable occurrences). For non-<code>Unit</code> products, it would require conversion checks on all the fields, which is inelegant as a rule and also probably very slow. For <code>Unit</code>, it's hard to even know what it would mean.</p>",
        "id": 293434893,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1660505081
    }
]