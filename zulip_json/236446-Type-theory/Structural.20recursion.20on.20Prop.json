[
    {
        "content": "<p>I have been trying to understand the Bove-Capretta encoding of partial recursive functions in Rocq. The basic idea is that for a specific function, one builds an inductive predicate representing either the call graph or the domain of this function, but in either case does so in a way that follows the structure of recursive calls. Then to define the function, we simply proceed by structural recursion on the predicate. This is well and good, but the bizarre thing (to me) is that in Rocq, the predicate can live in <code>Prop</code>.</p>\n<p>For example, in section 15.4 of Bertot and CastÃ©ran, the <code>log</code> function is defined. The OCaml pseudocode is</p>\n<div class=\"codehilite\" data-code-language=\"OCaml\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"k\">rec</span> <span class=\"n\">log</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"nc\">S</span> <span class=\"mi\">0</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">0</span>\n<span class=\"o\">|</span> <span class=\"nc\">S</span> <span class=\"o\">(</span><span class=\"nc\">S</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">S</span> <span class=\"o\">(</span><span class=\"n\">log</span> <span class=\"o\">(</span><span class=\"nc\">S</span> <span class=\"o\">(</span><span class=\"n\">div2</span> <span class=\"n\">p</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>To define this, we first specify when an input lives in the domain of <code>log</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">log_domain</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">log_domain_1</span> <span class=\"o\">:</span> <span class=\"n\">log_domain</span> <span class=\"mi\">1</span>\n<span class=\"o\">|</span> <span class=\"n\">log_domain_2</span> <span class=\"o\">:</span> <span class=\"o\">âˆ€</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">div2</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"o\">-&gt;</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">p</span><span class=\"o\">)).</span>\n</code></pre></div>\n<p>Then, after proving some inversion theorems (which <em>must</em> be defined in such a way that the output is \"smaller\" than the input; essentially the output is an argument to the input constructor; a \"blatant violation of the principle of proof irrelevance\"), we define</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Fixpoint</span> <span class=\"n\">log</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">log_domain</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"k\">struct</span> <span class=\"n\">h</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">...</span>\n</code></pre></div>\n<p>The key thing here is <code>{struct h}</code>, telling <code>Fixpoint</code> to proceed by structural recursion on <code>h</code>. A more complicated example is <a href=\"https://mattam82.github.io/Coq-Equations/examples/Examples.bove_capretta.html\">here</a>.</p>\n<p>In Lean this pretty obviously cannot work: <code>log_domain</code> is not a syntactic subsingleton, so subsingleton elimination doesn't apply and the generated recursor can only eliminate into <code>Prop</code>. The question is: why does this make sense in Rocq? Why is it consistent with proof irrelevance? I would be grateful for any expert weighing in here.</p>\n<p>One clue is that Rocq has pattern matching (<code>case</code>?) and fixpoints built into the type theory, I think as distinct elimination forms. Is it then the case that while one cannot match on proofs when eliminating into data, recursion into data is foundationally a different concept and is allowed?</p>\n<p>Adding to my confusion is <a href=\"https://stackoverflow.com/questions/63210604/bove-capretta-predicate-in-prop/63261542#63261542\">this SO answer</a> which seems to suggest that the difference has something to do with whether proof irrelevance is definitional (like in Lean, or Rocq's <code>SProp</code>) or axiomatic (like in Rocq's <code>Prop</code>). While we know from <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> that this difference does impact normalization and metatheory, I am not seeing why it matters here.</p>",
        "id": 527590140,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1751938094
    },
    {
        "content": "<p>I think <code>log_domain</code> can be considered a syntactic subsingleton by a more permissive check. The important property is that all the non-prop data in the constructor (which constructor, and the argument <code>p</code> to the second one) can be constructed from inversion on the index.</p>",
        "id": 527591041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751938948
    },
    {
        "content": "<p>You can presumably prove that this type is a subsingleton in Rocq as a result</p>",
        "id": 527591238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751939116
    },
    {
        "content": "<p>Ok, it cannot be the \"fiberwise subsingleton\" property that makes this work; I verified that Rocq still accepts this definition if you use</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">log_domain</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">log_domain_1</span> <span class=\"o\">:</span> <span class=\"n\">log_domain</span> <span class=\"mi\">1</span>\n<span class=\"c\">(* Can even put a bunch of data there if we want. *)</span>\n<span class=\"o\">|</span> <span class=\"n\">log_domain_1a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"n\">log_domain</span> <span class=\"mi\">1</span>\n<span class=\"o\">|</span> <span class=\"n\">log_domain_2</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">Nat.div2</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"o\">-&gt;</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">p</span><span class=\"o\">)).</span>\n</code></pre></div>",
        "id": 527592404,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1751940065
    },
    {
        "content": "<p>what exactly is your <code>Fixpoint</code>?</p>",
        "id": 527592748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751940298
    },
    {
        "content": "<p>Here is the full example from Bertot/CastÃ©ran:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">log_domain</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">log_domain_1</span> <span class=\"o\">:</span> <span class=\"n\">log_domain</span> <span class=\"mi\">1</span>\n<span class=\"o\">|</span> <span class=\"n\">log_domain_2</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">Nat.div2</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"o\">-&gt;</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">p</span><span class=\"o\">)).</span>\n\n<span class=\"kn\">Theorem</span> <span class=\"n\">log_domain_non_0</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">log_domain</span> <span class=\"n\">x</span> <span class=\"o\">-&gt;</span> <span class=\"n\">x</span> <span class=\"o\">&lt;&gt;</span> <span class=\"mi\">0</span><span class=\"o\">.</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span>\n  <span class=\"k\">intros</span> <span class=\"n\">x</span> <span class=\"n\">H</span><span class=\"o\">;</span> <span class=\"k\">case</span> <span class=\"n\">H</span><span class=\"o\">;</span> <span class=\"k\">intros</span><span class=\"o\">;</span> <span class=\"kp\">discriminate</span><span class=\"o\">.</span>\n<span class=\"kn\">Qed</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Theorem</span> <span class=\"n\">log_domain_inv</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">log_domain</span> <span class=\"n\">x</span> <span class=\"o\">-&gt;</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">Nat.div2</span> <span class=\"n\">p</span><span class=\"o\">)).</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span>\n  <span class=\"k\">intros</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"n\">H</span><span class=\"o\">;</span> <span class=\"k\">case</span> <span class=\"n\">H</span><span class=\"o\">;</span> <span class=\"kr\">try</span> <span class=\"o\">(</span><span class=\"k\">intros</span> <span class=\"n\">H'</span><span class=\"o\">;</span> <span class=\"kp\">discriminate</span> <span class=\"n\">H'</span><span class=\"o\">).</span>\n  <span class=\"k\">intros</span> <span class=\"n\">p'</span> <span class=\"n\">H1</span> <span class=\"n\">H2</span><span class=\"o\">;</span> <span class=\"k\">injection</span> <span class=\"n\">H2</span><span class=\"o\">;</span> <span class=\"k\">intros</span> <span class=\"n\">H3</span><span class=\"o\">;</span> <span class=\"k\">rewrite</span> <span class=\"o\">&lt;-</span> <span class=\"n\">H3</span><span class=\"o\">;</span> <span class=\"kp\">assumption</span><span class=\"o\">.</span>\n<span class=\"kn\">Defined</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Fixpoint</span> <span class=\"n\">log</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">log_domain</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"k\">struct</span> <span class=\"n\">h</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">as</span> <span class=\"n\">y</span> <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">y</span> <span class=\"o\">-&gt;</span> <span class=\"n\">nat</span> <span class=\"k\">with</span>\n  <span class=\"o\">|</span> <span class=\"mi\">0</span> <span class=\"o\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">h'</span> <span class=\"o\">=&gt;</span> <span class=\"n\">False_rec</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"n\">log_domain_non_0</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">)</span>\n  <span class=\"o\">|</span> <span class=\"n\">S</span> <span class=\"mi\">0</span> <span class=\"o\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">h'</span> <span class=\"o\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"o\">|</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">h'</span> <span class=\"o\">=&gt;</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">log</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">Nat.div2</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">log_domain_inv</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">))</span>\n  <span class=\"k\">end</span> <span class=\"o\">(</span><span class=\"n\">refl_equal</span> <span class=\"n\">x</span><span class=\"o\">).</span>\n</code></pre></div>",
        "id": 527592893,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1751940400
    },
    {
        "content": "<p>and when you have two <code>log_domain_1</code>'s you just get more cases in the inversion lemma?</p>",
        "id": 527593087,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751940586
    },
    {
        "content": "<p>actually can you show that version?</p>",
        "id": 527593227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751940704
    },
    {
        "content": "<p>Are you actually using <code>log_domain_1a</code> in the inversion lemma?</p>",
        "id": 527593249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751940728
    },
    {
        "content": "<p>Sorry I removed it, but here's a version with some spurious data in the <code>S (S p)</code> case; I don't think the <code>fix</code> guardedness checker is looking at how many elements there are.</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">log_domain</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">log_domain_1</span> <span class=\"o\">:</span> <span class=\"n\">log_domain</span> <span class=\"mi\">1</span>\n<span class=\"o\">|</span> <span class=\"n\">log_domain_2</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">data</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">Nat.div2</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"o\">-&gt;</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">p</span><span class=\"o\">)).</span>\n\n<span class=\"kn\">Theorem</span> <span class=\"n\">log_domain_inv</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">log_domain</span> <span class=\"n\">x</span> <span class=\"o\">-&gt;</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">Nat.div2</span> <span class=\"n\">p</span><span class=\"o\">)).</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span>\n  <span class=\"k\">intros</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"n\">H</span><span class=\"o\">;</span> <span class=\"k\">case</span> <span class=\"n\">H</span><span class=\"o\">;</span> <span class=\"kr\">try</span> <span class=\"o\">(</span><span class=\"k\">intros</span> <span class=\"n\">H'</span><span class=\"o\">;</span> <span class=\"kp\">discriminate</span> <span class=\"n\">H'</span><span class=\"o\">).</span>\n  <span class=\"k\">intros</span> <span class=\"o\">_</span> <span class=\"n\">p'</span> <span class=\"n\">H1</span> <span class=\"n\">H2</span><span class=\"o\">;</span> <span class=\"k\">injection</span> <span class=\"n\">H2</span><span class=\"o\">;</span> <span class=\"k\">intros</span> <span class=\"n\">H3</span><span class=\"o\">;</span> <span class=\"k\">rewrite</span> <span class=\"o\">&lt;-</span> <span class=\"n\">H3</span><span class=\"o\">;</span> <span class=\"kp\">assumption</span><span class=\"o\">.</span>\n<span class=\"kn\">Defined</span><span class=\"o\">.</span>\n</code></pre></div>",
        "id": 527593345,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1751940831
    },
    {
        "content": "<p>This makes me wonder whether you can do recursion over acc in prop in rocq</p>",
        "id": 527593824,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751941268
    },
    {
        "content": "<p>well this is fascinating:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">acc</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">):</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">intro</span><span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"k\">forall</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"o\">-&gt;</span> <span class=\"n\">acc</span> <span class=\"n\">R</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">acc</span> <span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Theorem</span> <span class=\"n\">acc_inv</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">acc</span> <span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"o\">-&gt;</span> <span class=\"n\">acc</span> <span class=\"n\">R</span> <span class=\"n\">y</span><span class=\"o\">.</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span>\n  <span class=\"k\">intros</span> <span class=\"n\">y</span><span class=\"o\">.</span>\n  <span class=\"k\">case</span> <span class=\"n\">H</span><span class=\"o\">.</span>\n  <span class=\"k\">intros</span> <span class=\"n\">z</span> <span class=\"n\">H1</span> <span class=\"n\">H2</span><span class=\"o\">.</span>\n  <span class=\"kp\">exact</span> <span class=\"o\">(</span><span class=\"n\">H1</span> <span class=\"o\">_</span> <span class=\"n\">H2</span><span class=\"o\">).</span>\n<span class=\"kn\">Defined</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Fixpoint</span> <span class=\"n\">acc_rec</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span><span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">IH</span><span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"k\">forall</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"o\">-&gt;</span> <span class=\"n\">C</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">acc</span> <span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">):</span> <span class=\"n\">C</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"n\">IH</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"n\">r</span> <span class=\"o\">=&gt;</span> <span class=\"n\">acc_rec</span> <span class=\"n\">R</span> <span class=\"n\">IH</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">acc_inv</span> <span class=\"o\">_</span> <span class=\"n\">H</span> <span class=\"o\">_</span> <span class=\"n\">r</span><span class=\"o\">)).</span>\n</code></pre></div>",
        "id": 527602149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751948985
    },
    {
        "content": "<p>and here's a \"compilation to well founded recursion\" of the previous example:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">log_domain</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">log_domain_1</span> <span class=\"o\">:</span> <span class=\"n\">log_domain</span> <span class=\"mi\">1</span>\n<span class=\"o\">|</span> <span class=\"n\">log_domain_2</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">Nat.div2</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"o\">-&gt;</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">p</span><span class=\"o\">)).</span>\n\n<span class=\"kn\">Inductive</span> <span class=\"n\">log_rel</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">log_rel_2</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">log_rel</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">Nat.div2</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">p</span><span class=\"o\">)).</span>\n\n<span class=\"kn\">Theorem</span> <span class=\"n\">log_domain_acc</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">log_domain</span> <span class=\"n\">x</span> <span class=\"o\">-&gt;</span> <span class=\"n\">acc</span> <span class=\"n\">log_rel</span> <span class=\"n\">x</span><span class=\"o\">.</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span>\n  <span class=\"k\">intros</span> <span class=\"n\">x</span> <span class=\"n\">H</span><span class=\"o\">.</span> <span class=\"k\">induction</span> <span class=\"n\">H</span><span class=\"o\">;</span> <span class=\"k\">constructor</span><span class=\"o\">;</span> <span class=\"k\">intros</span><span class=\"o\">.</span>\n  <span class=\"o\">*</span> <span class=\"k\">inversion</span> <span class=\"n\">H</span><span class=\"o\">.</span>\n  <span class=\"o\">*</span> <span class=\"k\">inversion</span> <span class=\"n\">H0</span><span class=\"o\">;</span> <span class=\"k\">subst</span> <span class=\"n\">p0</span><span class=\"o\">;</span> <span class=\"kp\">assumption</span><span class=\"o\">.</span>\n<span class=\"kn\">Qed</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Theorem</span> <span class=\"n\">log_domain_non_0</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">log_domain</span> <span class=\"n\">x</span> <span class=\"o\">-&gt;</span> <span class=\"n\">x</span> <span class=\"o\">&lt;&gt;</span> <span class=\"mi\">0</span><span class=\"o\">.</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span>\n  <span class=\"k\">intros</span> <span class=\"n\">x</span> <span class=\"n\">H</span><span class=\"o\">;</span> <span class=\"k\">case</span> <span class=\"n\">H</span><span class=\"o\">;</span> <span class=\"k\">intros</span><span class=\"o\">;</span> <span class=\"kp\">discriminate</span><span class=\"o\">.</span>\n<span class=\"kn\">Qed</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Theorem</span> <span class=\"n\">log_domain_inv</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">log_domain</span> <span class=\"n\">x</span> <span class=\"o\">-&gt;</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">Nat.div2</span> <span class=\"n\">p</span><span class=\"o\">)).</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span>\n  <span class=\"k\">intros</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"n\">H</span><span class=\"o\">.</span> <span class=\"k\">case</span> <span class=\"n\">H</span><span class=\"o\">.</span> <span class=\"kr\">try</span> <span class=\"o\">(</span><span class=\"k\">intros</span> <span class=\"n\">H'</span><span class=\"o\">;</span> <span class=\"kp\">discriminate</span> <span class=\"n\">H'</span><span class=\"o\">).</span>\n  <span class=\"k\">intros</span> <span class=\"n\">p'</span> <span class=\"n\">H1</span> <span class=\"n\">H2</span><span class=\"o\">.</span> <span class=\"k\">injection</span> <span class=\"n\">H2</span><span class=\"o\">.</span> <span class=\"k\">intros</span> <span class=\"n\">H3</span><span class=\"o\">.</span> <span class=\"k\">rewrite</span> <span class=\"o\">&lt;-</span> <span class=\"n\">H3</span><span class=\"o\">.</span> <span class=\"kp\">assumption</span><span class=\"o\">.</span>\n<span class=\"kn\">Qed</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Definition</span> <span class=\"n\">log</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">log_domain</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">acc_rec</span> <span class=\"n\">log_rel</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">log</span> <span class=\"n\">h</span> <span class=\"o\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">as</span> <span class=\"n\">y</span> <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">y</span> <span class=\"o\">-&gt;</span> <span class=\"n\">nat</span> <span class=\"k\">with</span>\n    <span class=\"o\">|</span> <span class=\"mi\">0</span> <span class=\"o\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">h'</span> <span class=\"o\">=&gt;</span> <span class=\"n\">False_rec</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"n\">log_domain_non_0</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">)</span>\n    <span class=\"o\">|</span> <span class=\"n\">S</span> <span class=\"mi\">0</span> <span class=\"o\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">h'</span> <span class=\"o\">=&gt;</span> <span class=\"mi\">0</span>\n    <span class=\"o\">|</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">h'</span> <span class=\"o\">=&gt;</span>\n      <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">log</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">Nat.div2</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">ltac</span><span class=\"o\">:(</span><span class=\"k\">subst</span> <span class=\"n\">x</span><span class=\"o\">;</span> <span class=\"kp\">exact</span> <span class=\"o\">(</span><span class=\"n\">log_rel_2</span> <span class=\"o\">_))</span> <span class=\"o\">(</span><span class=\"n\">log_domain_inv</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">))</span>\n    <span class=\"k\">end</span> <span class=\"o\">(</span><span class=\"n\">refl_equal</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">log_domain_acc</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">.</span>\n</code></pre></div>",
        "id": 527604610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751950928
    },
    {
        "content": "<p>(note that <code>log_domain_inv</code> doesn't need to be unfoldable this time)</p>",
        "id": 527604708,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751951012
    },
    {
        "content": "<p>the example is only as complicated as this because <code>log_domain</code> is also mixing in partiality (it's not defined at 0), while <code>acc</code> as written only handles well founded recursion without a domain restriction</p>",
        "id": 527604832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751951090
    },
    {
        "content": "<p>Are you claiming that recursion on <code>Prop</code> can always be reduced to one on <code>Acc</code>, so if I believe in the latter I must believe in the former?</p>",
        "id": 527607256,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1751953027
    },
    {
        "content": "<p>I think the puzzling thing with the two types </p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">log_domain</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">log_domain_1</span> <span class=\"o\">:</span> <span class=\"n\">log_domain</span> <span class=\"mi\">1</span>\n<span class=\"o\">|</span> <span class=\"n\">log_domain_2</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">Nat.div2</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"o\">-&gt;</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">p</span><span class=\"o\">)).</span>\n\n<span class=\"kn\">Inductive</span> <span class=\"n\">log_domain'</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">log_domain_1'</span> <span class=\"o\">:</span> <span class=\"n\">log_domain'</span> <span class=\"mi\">1</span>\n<span class=\"o\">|</span> <span class=\"n\">log_domain_2'</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">data</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">log_domain'</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">Nat.div2</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"o\">-&gt;</span> <span class=\"n\">log_domain'</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">p</span><span class=\"o\">)).</span>\n</code></pre></div>\n<p>is that they could be considered equivalent even though <code>log_domain'</code> looks like it contains more data. The point is that even though <code>log_domain_2'</code> has an additional argument <code>data : nat</code>, there is no way <br>\n1) to extract this argument in the <code>Type</code> world, and<br>\n 2) no way to distinguish two <code>nat</code> within <code>prop</code>.</p>\n<p>The first point  would be a violation of the subsingleton elimination rule, and it is maybe easier to see that attempting to extract from a simpler inductive fails:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">Sq</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">squash</span> <span class=\"o\">(</span><span class=\"n\">data</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sq</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Goal</span> <span class=\"n\">Sq</span> <span class=\"o\">-&gt;</span> <span class=\"n\">nat</span><span class=\"o\">.</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span>\n  <span class=\"k\">intros</span> <span class=\"n\">x</span><span class=\"o\">.</span>\n <span class=\"c\">(* Annotating the pattern-matching for clarity *)</span>\n  <span class=\"k\">refine</span> <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">Sq</span> <span class=\"k\">return</span> <span class=\"n\">nat</span> <span class=\"k\">with</span> <span class=\"o\">|</span> <span class=\"n\">squash</span> <span class=\"n\">n</span> <span class=\"o\">=&gt;</span> <span class=\"n\">n</span> <span class=\"k\">end</span><span class=\"o\">).</span>\n  <span class=\"c\">(* Error: *)</span>\n  <span class=\"c\">(* Incorrect elimination of \"x\" in the inductive type \"Sq\": *)</span>\n  <span class=\"c\">(* the return type has sort \"Set\" while it should be SProp or Prop. *)</span>\n  <span class=\"c\">(* Elimination of an inductive object of sort Prop *)</span>\n  <span class=\"c\">(* is not allowed on a predicate in sort \"Set\" *)</span>\n  <span class=\"c\">(* because proofs can be eliminated only to build proofs. *)</span>\n<span class=\"kn\">Abort</span><span class=\"o\">.</span>\n</code></pre></div>\n<p>The second point correspond to the fact that you could extract the <code>data</code> component <em>inside</em> <code>prop</code> to a <code>natProp</code> proposition, but then you cannot tell zero and successor appart.</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">Sq</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">squash</span> <span class=\"o\">(</span><span class=\"n\">data</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sq</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Inductive</span> <span class=\"n\">natProp</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">ZP</span> <span class=\"o\">:</span> <span class=\"n\">natProp</span> <span class=\"o\">|</span> <span class=\"n\">SP</span> <span class=\"o\">:</span> <span class=\"n\">natProp</span> <span class=\"o\">-&gt;</span> <span class=\"n\">natProp</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Definition</span> <span class=\"n\">unsquash</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Sq</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">natProp</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"o\">|</span> <span class=\"n\">squash</span> <span class=\"n\">n</span> <span class=\"o\">=&gt;</span> <span class=\"n\">nat_ind</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">_</span> <span class=\"o\">=&gt;</span> <span class=\"n\">natProp</span><span class=\"o\">)</span> <span class=\"n\">ZP</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">_</span> <span class=\"n\">np</span> <span class=\"o\">=&gt;</span> <span class=\"n\">SP</span> <span class=\"n\">np</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"k\">end</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Goal</span> <span class=\"n\">ZP</span> <span class=\"o\">=</span> <span class=\"n\">SP</span> <span class=\"n\">ZP</span> <span class=\"o\">-&gt;</span> <span class=\"n\">False</span><span class=\"o\">.</span>\n  <span class=\"k\">intros</span> <span class=\"n\">eq</span><span class=\"o\">.</span>\n  <span class=\"kp\">discriminate</span> <span class=\"n\">eq</span><span class=\"o\">.</span>\n  <span class=\"c\">(* Error: Not a discriminable equality. *)</span>\n</code></pre></div>\n<p>The two scripts I gave are only for illustration purpose, they do not prove that extraction from <code>Sq</code> to <code>nat</code> is impossible, nor that one cannot discriminate on <code>natProp</code> in Rocq, and it is not possible to show these properties within the system because they are only admissible consequences of the restriction of patter-matching on propositions to subsingletons.</p>\n<p>Finally, I said that <code>log_domain</code> and <code>log_domain'</code> could be considered equivalent because  you can build functions in both directions that will become equivalences under the assumption of (propositional) proof-irrelevance (cf <a href=\"https://rocq-prover.org/doc/V9.0.0/stdlib/Stdlib.Logic.ProofIrrelevance.html\">def in stdlib</a>; <code>Prop</code> and the subsingleton elimination constraints are designed to be compatible with this axiom)</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">log_domain</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">log_domain_1</span> <span class=\"o\">:</span> <span class=\"n\">log_domain</span> <span class=\"mi\">1</span>\n<span class=\"o\">|</span> <span class=\"n\">log_domain_2</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">Nat.div2</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"o\">-&gt;</span> <span class=\"n\">log_domain</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">p</span><span class=\"o\">)).</span>\n\n<span class=\"kn\">Inductive</span> <span class=\"n\">log_domain'</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">log_domain_1'</span> <span class=\"o\">:</span> <span class=\"n\">log_domain'</span> <span class=\"mi\">1</span>\n<span class=\"o\">|</span> <span class=\"n\">log_domain_2'</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">data</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">,</span> <span class=\"n\">log_domain'</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">Nat.div2</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"o\">-&gt;</span> <span class=\"n\">log_domain'</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">p</span><span class=\"o\">)).</span>\n\n<span class=\"kn\">Fixpoint</span> <span class=\"n\">ll'</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">log_domain</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">log_domain'</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"o\">|</span> <span class=\"n\">log_domain_1</span> <span class=\"o\">=&gt;</span> <span class=\"n\">log_domain_1'</span>\n  <span class=\"o\">|</span> <span class=\"n\">log_domain_2</span> <span class=\"n\">p</span> <span class=\"n\">y</span> <span class=\"o\">=&gt;</span> <span class=\"n\">log_domain_2'</span> <span class=\"mi\">0</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">ll'</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"k\">end</span><span class=\"o\">.</span>\n\n<span class=\"kn\">Fixpoint</span> <span class=\"n\">l'l</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">log_domain'</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">log_domain</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"o\">|</span> <span class=\"n\">log_domain_1'</span> <span class=\"o\">=&gt;</span> <span class=\"n\">log_domain_1</span>\n  <span class=\"o\">|</span> <span class=\"n\">log_domain_2'</span> <span class=\"o\">_</span> <span class=\"n\">p</span> <span class=\"n\">y</span> <span class=\"o\">=&gt;</span> <span class=\"n\">log_domain_2</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">l'l</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"k\">end</span><span class=\"o\">.</span>\n</code></pre></div>",
        "id": 527621794,
        "sender_full_name": "Kyod",
        "timestamp": 1751960421
    },
    {
        "content": "<p>While it's true that you can't directly eliminate Prop into Type, that's not sufficient to explain what's going on here. The point is that the <em>guard checker</em> has a rather different view of <code>Prop</code> which looks a whole lot more like <code>Type</code> even though the model of <code>Prop</code> is supposed to be consistent with a two element universe. In particular you can have a long sequence of \"strictly smaller\" terms inside a proof in <code>Prop</code>. There is no way to justify this from a two element <code>Prop</code> interpretation</p>",
        "id": 527641059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751966807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’</span> <a href=\"#narrow/channel/236446-Type-theory/topic/Structural.20recursion.20on.20Prop/near/527607256\">said</a>:</p>\n<blockquote>\n<p>Are you claiming that recursion on <code>Prop</code> can always be reduced to one on <code>Acc</code>, so if I believe in the latter I must believe in the former?</p>\n</blockquote>\n<p>Yes, I believe <code>Acc</code> to be \"universal\" among large eliminating <code>Prop</code> inductives</p>",
        "id": 527641672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751966983
    }
]