[
    {
        "content": "<p>I think I understand the idea of universes in type theory, but lately when reading the Theorem Proving in Lean textbook I saw the term 'Sort'. This seems similar to the idea of a universe, but I don't really understand what's the idea and how is it different from a universe and why is it necessary. So, I would appreciate if someone could give a basic explanation of the idea of a Sort, how is it related to the idea of a universe , why is it necessary (what's the problem with just having a hierarchy of universes?), and is this idea specific only to lean or is it something you can expect to see in a general (theoretical) text on type theory?</p>",
        "id": 543665096,
        "sender_full_name": "Michael Novak",
        "timestamp": 1759903175
    },
    {
        "content": "<p>Sort 0 = Prop<br>\nSort 1 = Type 0<br>\nSort 2 = Type 1<br>\n...</p>",
        "id": 543667065,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759904302
    },
    {
        "content": "<p><code>Sort</code> <em>is</em> the universe hierarchy. <code>Sort 0</code> is <code>Prop</code>, <code>Sort 1</code> is <code>Type 0</code>, <code>Sort 2</code> is <code>Type 1</code>, etc. as shown in the chart in <a href=\"https://leanprover.github.io/theorem_proving_in_lean4//Dependent-Type-Theory/#types-as-objects\">this section</a> of TPIL. </p>\n<p>This is not unique to Lean, other proof assistants like Rocq with an impredicative <code>Prop</code> are set up similarly.</p>",
        "id": 543667109,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759904324
    },
    {
        "content": "<p>Sort basically means \"anything you can put on the right of a colon\", which identifies both Prop and Type</p>",
        "id": 543667129,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759904333
    },
    {
        "content": "<p>O.k, I think I understand it now, thank you!</p>",
        "id": 543669678,
        "sender_full_name": "Michael Novak",
        "timestamp": 1759905645
    },
    {
        "content": "<p>Why does Prop need to be a lower level than Type?</p>",
        "id": 543906739,
        "sender_full_name": "aron",
        "timestamp": 1760000631
    },
    {
        "content": "<p>For that matter, I thought if a type (using that word loosely) referenced other types it needed to be at the same or a higher level than the types it references. But Prop seems to be able to reference any level of type while still staying at Sort 0. How come?</p>",
        "id": 543907061,
        "sender_full_name": "aron",
        "timestamp": 1760000723
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"814082\">aron</span> <a href=\"#narrow/channel/236446-Type-theory/topic/What.20is.20a.20Sort.20and.20how.20is.20it.20realted.20to.20Universes.3F/near/543907061\">said</a>:</p>\n<blockquote>\n<p>Prop seems to be able to reference any level of type while still staying at Sort 0. How come?</p>\n</blockquote>\n<p>It's a choice that Lean made, and it's not universal in the proving languages.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"814082\">aron</span> <a href=\"#narrow/channel/236446-Type-theory/topic/What.20is.20a.20Sort.20and.20how.20is.20it.20realted.20to.20Universes.3F/near/543906739\">said</a>:</p>\n<blockquote>\n<p>Why does Prop need to be a lower level than Type?</p>\n</blockquote>\n<p>I guess there is nothing wrong with <code>Prop : Type 1</code> and <code>Type : Type 1</code> but then that doesn't really change anything does it</p>",
        "id": 543907817,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760000936
    },
    {
        "content": "<p>Ah ok so there's no type theoretic notion of Prop as a distinct concept from Type?</p>",
        "id": 543908110,
        "sender_full_name": "aron",
        "timestamp": 1760001013
    },
    {
        "content": "<p>This is just a Lean design choice?</p>",
        "id": 543908176,
        "sender_full_name": "aron",
        "timestamp": 1760001030
    },
    {
        "content": "<p>well \"whether you can reference other levels from Prop and stay in Prop\" is a notion in type theory</p>",
        "id": 543908419,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760001103
    },
    {
        "content": "<p>and \"whether any two proofs of the same prop are the same\" is also a notion in type theory</p>",
        "id": 543908686,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760001179
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"814082\">aron</span> <a href=\"#narrow/channel/236446-Type-theory/topic/What.20is.20a.20Sort.20and.20how.20is.20it.20realted.20to.20Universes.3F/near/543906739\">said</a>:</p>\n<blockquote>\n<p>Why does Prop need to be a lower level than Type?</p>\n</blockquote>\n<p>I had a similar question in the past and rationalized to myself as follows. Let me know if I am misrepresenting something here ... </p>\n<p>Prop isn’t exactly <em>below</em> or <em>above</em> Type u; it’s a separate universe for propositions. It behaves peculiarly compared to the tower of type universes because nothing \"escapes\" it -- even if a proposition refers to types from Type 2 or Type 50, the resulting proposition still lives in Prop.</p>\n<p>In Lean, representing Prop as <code>Sort 0</code> is mostly a practical design choice: it allows Prop and the hierarchy of <code>Type u</code> universes to share a single unified representation (Sort u) internally. This way, universes can be encoded simply as natural-number levels, with Prop corresponding to level 0.</p>",
        "id": 544007875,
        "sender_full_name": "Yuri",
        "timestamp": 1760028425
    },
    {
        "content": "<p>Universe levels aren't actually encoded as natural numbers, and in fact there's nothing to prevent Lean's universe hierarchy from being quite complicated. It need not be isomorphic to <code>Nat</code>. Note that the piece of the hierarchy which <em>is</em> like <code>Nat</code> actually encodes universe levels in unary, which is why you're prevented from working with even moderately small universe sizes by default.</p>",
        "id": 544080784,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1760067086
    },
    {
        "content": "<p>My eyes were opened when reading a comment in the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UnivLE#doc\">docs#UnivLE</a> implementation that mentioned, offhandedly, that <code>max u v</code> may indeed be strictly larger than <em>both</em> <code>u</code> and <code>v</code>!</p>",
        "id": 561313713,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1764642931
    },
    {
        "content": "<p>I don't believe this is true of the real universe hierarchy, <code>max u v &lt;= w</code> is implied by <code>u &lt;= w</code> and <code>v &lt;= w</code></p>",
        "id": 561340710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1764660609
    },
    {
        "content": "<p>but <code>max u v</code> can be a semi-lattice join operation</p>",
        "id": 561340751,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1764660624
    },
    {
        "content": "<p>actually I suppose that's agreeing with you, if it's a nontrivial join (i.e. u and v are incomparable) then it will be bigger than both u and v</p>",
        "id": 561340857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1764660683
    },
    {
        "content": "<p>It's provable that UnivLE is total</p>",
        "id": 561381359,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764673320
    },
    {
        "content": "<p>Huh? I didn't know that. Do you have a proof in Lean?</p>",
        "id": 561382322,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1764673559
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=univLE_total#doc\">docs#univLE_total</a></p>",
        "id": 561383839,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764674030
    },
    {
        "content": "<p>you prove <code>UnivLE.{u, v}</code> iff the cardinal of u is smaller than the cardinal of v, and then you use that the cardinals are a total order</p>",
        "id": 561384067,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764674105
    },
    {
        "content": "<p>I think this still doesn't rule out the possibility that max u v is strictly greater than both u and v</p>",
        "id": 561384438,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764674196
    },
    {
        "content": "<p>this does not show that universes are a linear order, it shows that the image of the <code>u |-&gt; Type u</code> function is a linear order under cardinality order</p>",
        "id": 561394248,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1764677149
    },
    {
        "content": "<p>one \"obvious\" theorem <code>UnivLE</code> doesn't give you is <code>UnivLE.{u,v} -&gt; UnivLE.{u+1,v+1}</code></p>",
        "id": 561394653,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1764677276
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> which order on universes is the one you refer to in your message?</p>",
        "id": 561394984,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1764677384
    },
    {
        "content": "<p>the one in the type theory</p>",
        "id": 561395078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1764677408
    },
    {
        "content": "<p>equivalent to <code>max u v = v</code> being a defeq</p>",
        "id": 561395147,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1764677427
    },
    {
        "content": "<p>I see. I find it hard to prove things that are defined in terms of defeqs.</p>",
        "id": 561396495,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1764677799
    },
    {
        "content": "<p>you can't, internally</p>",
        "id": 561396588,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1764677825
    },
    {
        "content": "<p>that's why <code>UnivLE</code> exists</p>",
        "id": 561396615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1764677832
    },
    {
        "content": "<p>it's the \"nearest provable equivalent\" to universe le</p>",
        "id": 561396650,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1764677847
    },
    {
        "content": "<p>just like <code>=</code> compared to defeq</p>",
        "id": 561396677,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1764677857
    },
    {
        "content": "<p>but just like <code>x |- a x == b x</code> implies <code>|- a == b</code> as a defeq while <code>(∀ x, a x = b x) -&gt; a = b</code> is independent until you add axioms (funext), <code>u &lt;= v</code> implies <code>u+1 &lt;= v+1</code> but <code>UnivLE.{u,v} -&gt; UnivLE.{u+1,v+1}</code> is independent until you add axioms (and we didn't)</p>",
        "id": 561397152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1764678029
    }
]