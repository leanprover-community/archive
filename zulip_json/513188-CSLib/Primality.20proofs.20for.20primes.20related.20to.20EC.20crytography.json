[
    {
        "content": "<p>Right now I would like a proof that 2^255 - 19 is prime and soon I suspect I need the same information for others similar primes. Two questions:</p>\n<ul>\n<li>\n<p>Is CSLib going to be the correct place for this? I had in mind something like <a href=\"https://safecurves.cr.yp.to/primeproofs.html\">this collection</a> of many ECC relevant primes together with the primality proofs. </p>\n</li>\n<li>\n<p>Did anyone already prove that  2^255 - 19 is prime in Lean? Or how far are we from this? I suspect <a href=\"https://github.com/b-mehta/HighlyAbundant/tree/enlarge/HighlyAbundant/Prime\">this folder</a> of <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> gives most of the relevant arguments. Are there plans to upstream this to mathlib sometime?</p>\n</li>\n</ul>",
        "id": 555538833,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1763111927
    },
    {
        "content": "<p>I had indeed proved this number is prime. The most up to date version however will be in <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>'s repo, and although this example may not be already there, I expect it won't take long to appear!</p>",
        "id": 555539878,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1763112258
    },
    {
        "content": "<p>That's great! We'll keep a sorry in our code for the moment and then connect to your proof soon.</p>",
        "id": 555555567,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1763116985
    },
    {
        "content": "<p><a href=\"https://github.com/kckennylau/PrimeCert/blob/master/PrimeCert/PrimeList.lean#L84\">https://github.com/kckennylau/PrimeCert/blob/master/PrimeCert/PrimeList.lean#L84</a> <span class=\"user-mention\" data-user-id=\"613177\">@Oliver Butterley</span></p>",
        "id": 555576123,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1763123485
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>, that makes it very easy.</p>",
        "id": 555581968,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1763125411
    },
    {
        "content": "<p>How does Lean currently compare to Rocq. <a href=\"https://github.com/thery/coqprime\">https://github.com/thery/coqprime</a><br>\nI guess these benchmarks are some 8 years old, so it would be interesting to update them.<br>\nAlso, what is the TCB for this proof in Lean? Does it use unverified integer computation in C++ ?</p>",
        "id": 556631567,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1763237551
    },
    {
        "content": "<p>It uses only Lean's kernel, no native compute. This does use GMP for natural number computation, for values larger than 2^64, in particular for the operations listed here <a href=\"https://github.com/leanprover/lean4/blob/ae86c18ac19cee9bdf4e63cde2c11694e3217b70/src/kernel/type_checker.cpp#L613\">https://github.com/leanprover/lean4/blob/ae86c18ac19cee9bdf4e63cde2c11694e3217b70/src/kernel/type_checker.cpp#L613</a> (though in my version, not all these operations were used, and I expect similar for Kenny's upgraded version of mine). The benchmarks listed in the coqprime readme are specifically for Mersenne numbers; for which the Lucas-Lehmer test is more efficient, so a direct comparison wouldn't be entirely fair. This is, however, in mathlib, with some examples in <a href=\"https://github.com/leanprover-community/mathlib4/blob/96d819b3dca803e787de2b9746361952a26773d4/Archive/Examples/MersennePrimes.lean\">mathlib's archive</a>, although I think Kenny and I have optimised certain parts of this computation that the PrimeCert version might be faster than the mathlib version.</p>",
        "id": 556631847,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1763237880
    },
    {
        "content": "<blockquote>\n<p>Does it use unverified integer computation in C++ ?</p>\n</blockquote>\n<p>All kernel proofs that do reduction on closed Nat/Int terms use unverified integer computation in C++ in Lean. Do you mean to ask whether it makes use of <code>native_decide</code>?</p>\n<p>I find these TCB comparisons between Rocq and Lean proofs a bit difficult btw. For example in Lean people will say, we have this <code>native_decide</code> thing that is outside of the kernel so you can opt into it. On the other hand we have the Rocq kernel which has iirc 2 evaluation engines that do an equivalent of <code>native_decide</code> built-in (albeit with less optimizations and, unlike Lean's <code>native_decide</code>, for open terms). So saying that something is done \"with just the kernel\" has completely different meaning for Rocq and for Lean.</p>",
        "id": 556632030,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1763238068
    },
    {
        "content": "<p>Thanks. Yes, that's what I understood, that Lean depends on C++ integer computation. </p>\n<p>Rocq has compute, vm_compute (<a href=\"https://dl.acm.org/doi/abs/10.1145/583852.581501\">https://dl.acm.org/doi/abs/10.1145/583852.581501</a>, a verified VM) and native_compute (<a href=\"https://inria.hal.science/hal-00650940/file/full_throttle.pdf\">https://inria.hal.science/hal-00650940/file/full_throttle.pdf</a>) a somewhat verified way of using extraction to ocaml. Work is under way, on using Rocq's new <em>verified</em> extraction to ocaml/malfunction (<a href=\"https://github.com/MetaRocq/rocq-verified-extraction\">https://github.com/MetaRocq/rocq-verified-extraction</a>).</p>\n<p>Is there a paper describing native_decide?</p>",
        "id": 556632633,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1763238577
    },
    {
        "content": "<p>native_decide is just Lean's normal compiler</p>",
        "id": 556632731,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1763238655
    },
    {
        "content": "<p>Which is unverified, and is described in <a href=\"https://arxiv.org/abs/1908.05647\">https://arxiv.org/abs/1908.05647</a> ?</p>",
        "id": 556633074,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1763238955
    },
    {
        "content": "<p>I think section 3 of <a href=\"https://lean-lang.org/papers/lean4.pdf\">https://lean-lang.org/papers/lean4.pdf</a> gives a small amount of description too</p>",
        "id": 556633154,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1763239015
    },
    {
        "content": "<p>It is unverified yes, it will also likely never be verified. The algorithms from immutable beans counting have a formal proof in Marc Huisinga's Bachelor thesis but they amount only to the very last bits of the transformation pipeline. The main chunk of the transformation pipeline is just a normal functional compiler. That would make it quite difficult to publish a paper about given that there is not really anything new happening (in combination with the fact that time was tight when the largest chunk of the code was written in 2022/23). The description from the Lean 4 tool paper is, somewhat amusingly, so undetailed that it still holds true despite a full rewrite of about 2/3rds of the compiler.</p>",
        "id": 556633436,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1763239228
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>. Yes, they point to the cool work on Perseus, which talks about a formalization, with which I believe they mean \"mathematically precise\" not in a proof assistant, but I may have overlooked something.<br>\n<a href=\"https://dl.acm.org/doi/pdf/10.1145/3453483.3454032\">https://dl.acm.org/doi/pdf/10.1145/3453483.3454032</a><br>\nIIUC this approach does not work for coinductive types.</p>",
        "id": 556633735,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1763239442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/513188-CSLib/topic/Primality.20proofs.20for.20primes.20related.20to.20EC.20crytography/near/556633735\">said</a>:</p>\n<blockquote>\n<p>Thanks <span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span>. Yes, they point to the cool work on Perseus, which talks about a formalization, with which I believe they mean \"mathematically precise\" not in a proof assistant, but I may have overlooked something.<br>\n<a href=\"https://dl.acm.org/doi/pdf/10.1145/3453483.3454032\">https://dl.acm.org/doi/pdf/10.1145/3453483.3454032</a><br>\nIIUC this approach does not work for coinductive types.</p>\n</blockquote>\n<p>Perceus is an algorithm based on the immutable beans counting paper by de Moura and Ullrich that has a formalization in Marc's Bachelor thesis as I just said.</p>",
        "id": 556633812,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1763239494
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> ! our messages crossed.</p>",
        "id": 556633891,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1763239537
    },
    {
        "content": "<p><a href=\"https://pp.ipd.kit.edu/uploads/publikationen/huisinga19bachelorarbeit.pdf\">https://pp.ipd.kit.edu/uploads/publikationen/huisinga19bachelorarbeit.pdf</a> here's the thesis for reference</p>",
        "id": 556633911,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1763239557
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> Rocq-prime also has Pocklington. It should be easy to run some more extensive benchmarks, but at least here is  a statement:</p>\n<blockquote>\n<p>Proving the primality of a number of about 1200 decimal digits takes about 9 hours</p>\n</blockquote>\n<p>However, that should be corrected for Moore's law, and it still uses Rocq's regular compute, as opposed to a more optimized one.</p>\n<p>How long does it take to check a 1200 decimal digit number in Lean?<br>\nUnfortunately, the README does not say what the 1200 digit number was ...</p>",
        "id": 556634934,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1763240324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/513188-CSLib/topic/Primality.20proofs.20for.20primes.20related.20to.20EC.20crytography/near/555576123\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/kckennylau/PrimeCert/blob/master/PrimeCert/PrimeList.lean#L84\">https://github.com/kckennylau/PrimeCert/blob/master/PrimeCert/PrimeList.lean#L84</a> <span class=\"user-mention silent\" data-user-id=\"613177\">Oliver Butterley</span></p>\n</blockquote>\n<p>Hi Kenny! I'm new here, but I'm working with Oliver on an issue related to this. I was wondering is the repo maintained? Would it make sense a PR to update it to mathlib 4.25.2? I'd be down to do that</p>",
        "id": 562657256,
        "sender_full_name": "Alessandro D'Angelo",
        "timestamp": 1765278935
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>  Some extra context: we are working a project verifying some ecc code in lean. For that we need the primality proof. It would be convenient to add your repo as a dependency for this. However we recently updated to the newer version of lean.</p>",
        "id": 562671462,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1765283380
    },
    {
        "content": "<p>Assuming that your intention is to keep the PrimeCert as a reference repo for these primality proofs, would it make sense to setup a system for auto tagging releases as lean updates?</p>",
        "id": 562671950,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1765283536
    },
    {
        "content": "<p>I've added and (auto) tagged versions of the repo for 4.25.0, 4.25.1, 4.25.2. Hope this helps :)</p>",
        "id": 563146255,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1765447603
    },
    {
        "content": "<p>Thanks! That's perfect.</p>",
        "id": 563149186,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1765448489
    }
]