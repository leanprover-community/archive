[
    {
        "content": "<p>Hello!</p>\n<p>I am working on a contribution (one of my first) in Computability defining Weighted DFAs here:</p>\n<p><a href=\"https://github.com/LiamSchilling/mathlib4/blob/rational-and-subsequential-transductions/Mathlib/Computability/WDFA.lean\">https://github.com/LiamSchilling/mathlib4/blob/rational-and-subsequential-transductions/Mathlib/Computability/WDFA.lean</a></p>\n<p>I want to build up to defining subsequential and rational string transductions, then proving the Choffrut characterization.</p>\n<p>I know it's advisable for PRs to be minimal, and in general I'm wondering what's the best way to go about it. It's not long yet, but it may be after adding the <code>simp</code> lemmas and lemmas relating WDFAs to acceptor DFAs.</p>\n<p>Thank you  :)</p>",
        "id": 569652009,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769154182
    },
    {
        "content": "<p>Hello <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span><br>\nYou might want to consider <a class=\"stream\" data-stream-id=\"513188\" href=\"/#narrow/channel/513188-CSLib\">#CSLib</a> instead</p>",
        "id": 569789243,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1769196395
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"786070\">@Rudy Peterson</span> who I believe had mentioned some related work and <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> who has been working on automata in CSLib</p>",
        "id": 569792970,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769197980
    },
    {
        "content": "<p>Thank you for the direction! This is my first time hearing of CSLib.</p>",
        "id": 569793709,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769198291
    },
    {
        "content": "<p>You can start by browsing the code here:<br>\n<a href=\"https://github.com/leanprover/cslib/tree/main/Cslib/Computability/Automata\">https://github.com/leanprover/cslib/tree/main/Cslib/Computability/Automata</a><br>\nI'm porting the results from an earlier project into CSLib:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory\">https://github.com/ctchou/AutomataTheory</a><br>\nwhose README indicates which results are already in CSLib.</p>",
        "id": 569812454,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769207460
    },
    {
        "content": "<p>There was a talk about CSLib in the just-concluded \"Lean Together\":<br>\n<a class=\"stream-topic\" data-stream-id=\"557175\" href=\"/#narrow/channel/557175-Lean-Together-2026/topic/Fabrizio.20Montesi.20-.20CSLib.3A.20The.20Lean.20Computer.20Science.20Library/with/569148509\">#Lean Together 2026 &gt; Fabrizio Montesi - CSLib: The Lean Computer Science Library</a><br>\nI'm told the video recording will appear on YouTube next week.</p>",
        "id": 569812751,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769207653
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"878804\">@Liam Schilling</span>  It would be nice if you can outline what definitions and theorems from the theory of weighted automata you plan to formalize.  That will help people like myself who are not already familiar with the  theory to get a sense of (so to speak) the lay of the land.</p>",
        "id": 569908423,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769294678
    },
    {
        "content": "<p>Hello! My first formalization target is the class of subsequential transductions, which are realized by deterministic FSTs. Then, I will prove the Choffrut Theorem, which is the transducer version of Myhill-Nerode.</p>\n<p>My motivation for capturing weighted automata with <code>Transducer</code> is that they immediately specialize to the desired FST definition without being any more complicated. Similarly, every transducer model within the rational class (deterministic FST; nondeterministic FST; bimachine) has an immediate generalization from string outputs (the free monoid) to outputs from any monoid. In this sense, defining <code>Transducer</code> in terms of semigroups and monoids instead of assuming we are working with the free monoid is a two birds/one stone situaion: we get both weighted automata and string-to-string transducers.</p>\n<p>I also wonder if this discussion should be moved to <a class=\"stream\" data-stream-id=\"513188\" href=\"/#narrow/channel/513188-CSLib\">#CSLib</a>.</p>",
        "id": 569911178,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769298287
    },
    {
        "content": "<p>As for the PR, I agree with your comment that it might be better to wait until some transducer models are defined, so that we will see if the current definition is the most convenient.</p>",
        "id": 569911545,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769298844
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Weighted.20DFAs.20and.20Deterministic.20FSTs\">#mathlib4 &gt; Weighted DFAs and Deterministic FSTs</a> by <span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span>.</p>",
        "id": 569920556,
        "sender_full_name": "Notification Bot",
        "timestamp": 1769309830
    },
    {
        "content": "<p>I have drafted the <a href=\"https://github.com/leanprover/cslib/pull/286\">PR</a> until I define the weighted automaton and bimachine models, and implement <code>Transducer</code> for them. This should help ensure that we have the best definition of <code>Transducer</code>. There were other design choices I could have made that I will outline here for if anybody has thoughts:</p>\n<ul>\n<li>No accumulators: have weights from a <code>Monoid</code> and give <code>Transducer</code> only one field <code>transduce : T -&gt; List Symbol -&gt; Weight</code>. This is simpler, and the <code>Monoid</code> restriction should be fine because there are no practical situations I can think of where weights are not from a <code>Monoid</code>. However, this limits performance optimizations in cases like <code>transduce t xs * y</code> where <code>transduce t xs</code> is a very long list. Ideally, <code>y</code> would be passed as an accumulator so that <code>transduce t xs</code> is only constructed once (recall <code>List.append</code> unfolds the left-hand list).</li>\n<li>Current definition: have weights from a <code>Semigroup</code> and give <code>Transducer</code> the function <code>transduceFrom</code> that takes a left and right accumulator.  This is still fairly simple and it allows some of the optimizations. However, once implemented, the direction of associativity of multiplication cannot be changed, even for types where the other direction is preferred. Also, for <code>Semigroup</code>s that are not <code>Monoid</code>s, <code>transduceFrom</code> is limited in expressivity because it must have both a left and right accumulator where an empty weight (<code>1</code>) cannot be provided.</li>\n<li>Separate functions for left and right accumulators:  have weights from a <code>Semigroup</code> and give <code>Transducer</code> two functions <code>transduceFromLeft</code> and <code>transduceFromRight</code> which take a left and right accumulator respectively. This is the least simple definition. However, it allows both directions of associativity of multiplication to be implemented at once. Also, it avoids the expressivity limitation of the previous <code>transduceFrom</code>.</li>\n</ul>\n<p>I am leaning toward the third definition because it is the most general and the most flexible to implementation.</p>",
        "id": 569924894,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769314920
    },
    {
        "content": "<p>I don't know enough about the subject matter to make any concrete suggestions.  But it seems to me that the best way to exercise your definitions is to try to prove some not-entirely-trivial theorems.  Then you'll find out quickly how well your definitions work.</p>",
        "id": 570002688,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769396435
    },
    {
        "content": "<p>Yes, for adding new definitions like this there is a bit of a bootstrapping problem of actually using your definitions to gain confidence that they are both correct and ergonomic. What I think would be most helpful, for both yourself and the reviewers, is to follow the above advice and see how these definitions play out in practice. Most of the developments in CSLib started this way, spending a lot of time in a fork or other personal repo until reaching a non-trivial theorem.</p>",
        "id": 570004301,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769397884
    },
    {
        "content": "<p>Also if you're aware of any related formalizations in other proof assistants, this is extremely helpful for reviewing purposes. When thinking about the first lambda calculi definitions we added, I spent a lot of time contrasting formalizations in Rocq and Agda.</p>",
        "id": 570004456,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769398037
    }
]