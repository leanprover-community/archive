[
    {
        "content": "<p>I've been working for a few weeks on adding URMs (unlimited register machines), and would like to announce my work. I've just opened a <a href=\"https://github.com/leanprover/cslib/pull/299\">PR</a>.</p>\n<p>URMs are a machine model of computation that's a bit closer to what we'd recognize as a \"computer\" than a Turing machine, in that it has a notion of instructions (and programs) and registers. One imagines a machine with an infinite sequence of registers, each containing a natural number (unbounded). One computes by evaluating programs, which are sequences of four instructions:</p>\n<ul>\n<li>Z n ‚Äî set the content of register n to zero</li>\n<li>S n ‚Äî increment the content of register n</li>\n<li>T m n ‚Äî copy the content of register m to register n</li>\n<li>J m n q ‚Äî if registers m and n are equal, jump to instruction q; otherwise, continue to the next instruction</li>\n</ul>\n<p>The PR includes the basic instruction type, program representation, execution semantics, and foundational lemmas about straight-line programs and halting behavior.</p>\n<p>While Mathlib has some Turing machine content, URMs feel like a natural fit for CSLib given its focus on algorithmic computation models. My longer-term goal is to prove the equivalence of URM-computability with CSLib's existing SKI calculus, establishing another bridge between computation models in the library. I actually have a proof of this result ready to go but am more interested in getting your feedback on the basics before asking for review on a large PR. I also see URMs as a nice base layer on which to build other languages and machine models, leveraging Lean's macro system. URM could also be a nice source of examples for exercising <code>grind</code>, especially when it comes to verification of concrete (URM) programs.</p>\n<p>I'd welcome feedback on the API design, naming conventions, and overall structure. Are there aspects of URM theory that would be especially valuable to prioritize?</p>",
        "id": 570571407,
        "sender_full_name": "Jesse Alama",
        "timestamp": 1769610269
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"754512\">@Jesse Alama</span>  : I am trying to write a more universal model in <a href=\"https://github.com/leanprover/cslib/pull/275\">cslib#275</a></p>",
        "id": 570574734,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769610961
    },
    {
        "content": "<p>It could subsume this model as a query</p>",
        "id": 570574781,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769610970
    },
    {
        "content": "<p>You still need to write the model as a query, which is homologous to the work Jesse did...</p>",
        "id": 570575241,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769611080
    },
    {
        "content": "<p>Yeah, but it could be fitted into this framework</p>",
        "id": 570575377,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769611116
    },
    {
        "content": "<p>Then you get to easily write reductions from this model to other models and vice versa</p>",
        "id": 570575396,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769611120
    },
    {
        "content": "<p>It looks like the query model is tailored to time complexity analysis, whereas the URM approach -- at least how I've sketched it -- is more about computability. It seems there's room for both approaches! I'd be happy to help work out how to embed URMs to the query model.</p>",
        "id": 570579282,
        "sender_full_name": "Jesse Alama",
        "timestamp": 1769611965
    },
    {
        "content": "<p>Hm, to prove that something is computable is it not enough to write Lean code that computes it? (and you can prove, that it is correct in Lean)</p>",
        "id": 570580024,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769612106
    },
    {
        "content": "<p>At least it proves that it is computable in the computational model that is Lean I think? But we don't have formal proof that Lean computation model is equivalent to TM.</p>",
        "id": 570580752,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769612266
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"870257\">@Jakub Nowak</span> I share your concerns! The gap between \"computable in Lean\" and \"computable in a formal sense\" is exactly what motivates this kind of work.</p>\n<p>Two relevant pending results that help bridge this:</p>\n<ol>\n<li>\n<p>I have a proof of the equivalence of CSLib's SKI calculus with Turing machines (TM0), which would establish that connection within CSLib.</p>\n</li>\n<li>\n<p>For Mathlib, I also have a proof of TM ‚Üí Partrec (every function computed by a Turing machine is partial recursive). Mathlib currently only has the reverse direction (Partrec ‚Üí TM, in <code>TMToPartrec.lean</code>), so this would complete that equivalence.</p>\n</li>\n</ol>\n<p>Together these would give a chain: SKI ‚Üî TM ‚Üî Partrec, formally connecting different models of computation.</p>",
        "id": 570587023,
        "sender_full_name": "Jesse Alama",
        "timestamp": 1769613560
    },
    {
        "content": "<p>I'm working on similar thing, but for call-by-value lamdba calculus, i.e. proving call-by-value lamdba calculus is equivalent to turing machine as computational models. With your work, I can choose to prove the equivalence with SKI or Partrec (or URM, if you plan to do that too), instead of TM, which might be easier. I'm looking forward to also seeing your approach for these proofs.</p>",
        "id": 570590395,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769614273
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"754512\">Jesse Alama</span> <a href=\"#narrow/channel/513188-CSLib/topic/Unlimited.20register.20machines/near/570587023\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> I share your concerns! The gap between \"computable in Lean\" and \"computable in a formal sense\" is exactly what motivates this kind of work.</p>\n<p>Two relevant pending results that help bridge this:</p>\n<ol>\n<li>\n<p>I have a proof of the equivalence of CSLib's SKI calculus with Turing machines (TM0), which would establish that connection within CSLib.</p>\n</li>\n<li>\n<p>For Mathlib, I also have a proof of TM ‚Üí Partrec (every function computed by a Turing machine is partial recursive). Mathlib currently only has the reverse direction (Partrec ‚Üí TM, in <code>TMToPartrec.lean</code>), so this would complete that equivalence.</p>\n</li>\n</ol>\n<p>Together these would give a chain: SKI ‚Üî TM ‚Üî Partrec, formally connecting different models of computation.</p>\n</blockquote>\n<p>Sounds good. Glad to be of help. I am a bit busy for the rest of this week. But hopefully the examples already uploaded in the PR are helpful</p>",
        "id": 570592630,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769614685
    },
    {
        "content": "<p>I actually just posted a challenge to put TMs inside this model here : <a class=\"message-link\" href=\"/#narrow/channel/513188-CSLib/topic/Query.20model.20for.20Algorithms.20complexity.20.3A.20updates/near/570590324\">#CSLib &gt; Query model for Algorithms complexity : updates @ üí¨</a></p>",
        "id": 570592776,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769614714
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Unlimited.20register.20machines/near/570574734\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"754512\">Jesse Alama</span>  : I am trying to write a more universal model in <a href=\"https://github.com/leanprover/cslib/pull/275\">cslib#275</a></p>\n<p>It could subsume this model as a query</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> I don't think we want to have your proposed query model attempt to encompass every single development related to complexity theory. After that PR is cleaned up and merged, you could certainly try some proofs of equivalence to other parts of the library, but my viewpoint is that we do not want every single development in CSLib to be through this monadic framework, as there are tradeoffs with more standard deep embeddings.</p>",
        "id": 570600423,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769616488
    },
    {
        "content": "<p>That‚Äôs fair but one of my goals with the query model is to make it trivial to lift algorithms between models more systematically</p>",
        "id": 570600726,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769616567
    },
    {
        "content": "<p>This is needed for example when doing circuit complexity upper bounds. Typically you need a bounded time complexity computation (say on a model of TMs)  that produces a circuit and then you need the circuit to compute things.</p>",
        "id": 570600977,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769616622
    },
    {
        "content": "<p>More concretely I agree that deep embeddings have benefits. But I think a shallow embedding can co exist and be useful as well.</p>",
        "id": 570602966,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769617123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"754512\">Jesse Alama</span> <a href=\"#narrow/channel/513188-CSLib/topic/Unlimited.20register.20machines/near/570587023\">said</a>:</p>\n<blockquote>\n<p>Together these would give a chain: SKI ‚Üî TM ‚Üî Partrec, formally connecting different models of computation.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"754512\">@Jesse Alama</span> I look forward to these future PRs as well! I am excited to see some connections to other parts of CSLib via SKI. </p>\n<p>For this PR, I will try to start reviewing sometime in the next week or so.</p>",
        "id": 570608826,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769618482
    },
    {
        "content": "<p>Question about this URM model: is there no notion of \"dereference a register\"? Otherwise this seems like a program can only manipulate a finite number of registers ever.</p>",
        "id": 570641590,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769627781
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/513188-CSLib/topic/Unlimited.20register.20machines/near/570641590\">said</a>:</p>\n<blockquote>\n<p>Question about this URM model: is there no notion of \"dereference a register\"? Otherwise this seems like a program can only manipulate a finite number of registers ever.</p>\n</blockquote>\n<p>You only need 2 registers to be Turing Complete. At least for the Minsky Machine, not sure about URM, but I'm guessing you also only need 2 or 3. <a href=\"https://en.wikipedia.org/wiki/Counter_machine\">https://en.wikipedia.org/wiki/Counter_machine</a></p>",
        "id": 570665057,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769636410
    },
    {
        "content": "<p>btw there's a great Computerphile video that proves 2 registers are sufficient to be Turing complete:<br>\n<a href=\"https://www.youtube.com/watch?v=PXN7jTNGQIw\">https://www.youtube.com/watch?v=PXN7jTNGQIw</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"PXN7jTNGQIw\" href=\"https://www.youtube.com/watch?v=PXN7jTNGQIw\"><img src=\"https://uploads.zulipusercontent.net/376eaaf389382ee30529ec9bfbf1564bd64698a5/68747470733a2f2f692e7974696d672e636f6d2f76692f50584e376a544e475149772f6d7164656661756c742e6a7067\"></a></div>",
        "id": 570671152,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1769638901
    },
    {
        "content": "<p>Just curious: Would URM be easier to use if the program is a graph modeling a flowchart, rather than a list of instructions?</p>",
        "id": 570707566,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769663243
    },
    {
        "content": "<p>Ah, okay. I was familiar with the fact that 2 suffices for Turing completeness, I thought this was a \"model\" in the sense of, say, \"the Real RAM model\", for writing down programs and so on.</p>",
        "id": 570708034,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769663591
    },
    {
        "content": "<p>I get it now. :) Cool!</p>",
        "id": 570708050,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769663601
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"754512\">Jesse Alama</span> <a href=\"#narrow/channel/513188-CSLib/topic/Unlimited.20register.20machines/near/570571407\">said</a>:</p>\n<blockquote>\n<p>My longer-term goal is to prove the equivalence of URM-computability with CSLib's existing SKI calculus, establishing another bridge between computation models in the library.</p>\n</blockquote>\n<p>Very glad to see that the SKI developments are proving useful! I had grand plans of proving Partrec -&gt; SKI (most of the pieces ought to be in <code>SKI/Recursion</code>) but never got around to fixing what it means for a term to compute a partial function in a way I was 100% happy with. If there are any developments on the SKI side that would be helpful please let me know :-))</p>",
        "id": 570989329,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1769768349
    },
    {
        "content": "<p>More generally it has seemed to me for a while that we need a formal notion of \"computability class\" or something of the sort, or at least a way to say that two notions of computation are equivalent in strength in a non-ad-hoc way ‚Äî though tbf we would then need to fix what a \"model of computation\" is, &amp;c&amp;c</p>",
        "id": 570990095,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1769768581
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> I think your comments on <a href=\"https://github.com/leanprover/cslib/pull/299\">cslib#299</a> have been addressed, I've set it to merge once you approve. (Just pinging here since the PR has gotten a bit noisy)</p>",
        "id": 571953972,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770221794
    },
    {
        "content": "<p>Thanks, I'll have another look asap. :‚Å†-‚Å†)</p>",
        "id": 571955004,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1770222056
    }
]