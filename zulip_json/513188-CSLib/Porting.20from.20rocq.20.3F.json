[
    {
        "content": "<p>Rocq has a huge CS library. <br>\nThere are already some porting efforts under way (e.g. iris/stdpp) and <a href=\"http://softwarefoundations.cis.upenn.edu\">softwarefoundations.cis.upenn.edu</a> .<br>\n[ I also have some of my own that I'll announce separately. }</p>\n<p>Did you consider porting, or at least taking inspiration from the Rocq eco-system?<br>\nThe CS lib roadmap is not very detailed, so for now, I've just asked an LLM to do a quick comparison.<br>\nIt's below (slightly edited). I'd be happy to help with a more detailed comparison.<br>\nThe HOL eco-systems can also be a rich source for inspiration.</p>\n<p>I believe this may also be a chance for deeper connections and collaboration between the eco-systems.<br>\nOne such project we are working on is the <a href=\"http://peregrine-project.github.io\">peregrine-project.github.io</a>. (for verified compilers, pilar II)</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>AI (mostly) generated</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Here's a mapping of CSLib's three pillars to existing Rocq ecosystem projects that could serve as porting sources or inspiration:</p>\n<hr>\n<h2>Pillar 1: Formalizing CS Foundations</h2>\n<p>This is where the Rocq ecosystem is richest and most directly relevant.</p>\n<p><strong>Models of Computation (lambda calculus, Turing machines, computability)</strong><br>\n- <strong>Formalised Undecidable Problems</strong> (coq-community) — This is the single most relevant library. It formalizes lambda calculus as a model of computation (Forster &amp; Smolka's \"L\" calculus), Turing machines, Post correspondence problem, and a large web of reductions between undecidable problems. Built collaboratively by students at Saarland. Directly maps to CSLib's 6-month milestone.<br>\n- <strong>CoLoR</strong> — Library on rewriting theory, lambda-calculus and termination. Has sub-libraries on data structures extending the stdlib.<br>\n- <strong>Regular Language Representations</strong> — Translations between regular expressions, automata, etc. Covers formal language theory fundamentals.</p>\n<p><strong>Algorithms &amp; Data Structures</strong><br>\n- <strong>Functional Algorithms Verified in SSReflect</strong> (coq-community) — Verified implementations of searching, sorting, and other fundamental algorithms. Directly targets CSLib's \"algorithms textbook\" goal.<br>\n- <strong>Tarjan/Kosaraju SCC algorithms</strong> (coq-community) — Formalized graph algorithms with correctness proofs.<br>\n- <strong>Ceramist</strong> — Verified hash-based approximate membership structures (Bloom filters).<br>\n- <strong>CertiGraph</strong> — Library for reasoning about directed graphs and their embedding in separation logic.<br>\n- <strong>Graph Theory</strong> — Formalized graph theory results.</p>\n<p><strong>Randomized / Approximation Arguments</strong><br>\n- <strong>FCF</strong> — Framework for proofs of cryptography (includes probabilistic reasoning). <br>\n- <strong>SSProve</strong> — Modular cryptographic proofs framework.</p>\n<p><strong>Logic &amp; PL Foundations</strong><br>\n- <strong>Coq Library for First-Order Logic</strong> — Syntax, semantics, and proof systems of FOL, built on the undecidability library. There was an active push to add this to the Rocq Platform.<br>\n- <strong>Completeness and Decidability of Modal Logic Calculi</strong> — Formalized K, K*, CTL, PDL. Relevant to CSLib's modal logic goals.<br>\n- <strong>Metalib</strong> — PL metatheory using locally nameless representations.<br>\n- <strong>Autosubst</strong> — Automated de Bruijn term handling, crucial infrastructure for PL formalization.</p>\n<p><strong>Math for CS (not in Mathlib)</strong><br>\n- <strong>Rocq Stdlib</strong> itself has basic arithmetic, logic, data structures (lists, sets, maps), and decidability infrastructure.<br>\n- <strong>Coq-std++</strong> (stdpp) — The extended alternative standard library used heavily by Iris. Has finite maps, finite sets, countable types, orders, etc. This is extremely well-engineered and would be a prime porting candidate for foundational data structures and reasoning infrastructure.<br>\n- <strong>Mathematical Components</strong> — While much overlaps with Lean's Mathlib, certain combinatorial and finite-type reasoning (fintypes, bigops) could fill CS-specific gaps.</p>\n<hr>\n<h2>Pillar 2: Reasoning about Code (Boole / imperative verification)</h2>\n<p>This is where Rocq's flagship projects live, but porting is harder because they're tightly integrated with Rocq-specific features.<br>\n<strong>Program Verification Tools</strong><br>\n- <strong>Interaction Trees</strong> — Library for representing recursive and impure programs. Very relevant to Boole's need to handle effectful imperative code.<br>\n- <strong>FreeSpec</strong> — Modularly verifying programs with effects and effect handlers.<br>\n- <strong>Fiat</strong> — Automated synthesis of correct-by-construction programs.</p>\n<p><strong>Real-World Verification Projects (as case studies/inspiration)</strong><br>\n- <strong>Verdi</strong> — Formally verified distributed systems.<br>\n- <strong>ConCert</strong> — Smart contract verification with extraction to contract languages. (included in <a href=\"https://peregrine-project.github.io/\">https://peregrine-project.github.io/</a>)<br>\n- <strong>Fiat-Crypto</strong> — Cryptographic primitive code generation (used in Chrome/BoringSSL).</p>\n<hr>\n<h2>Pillar 3: Repository of Verified Code</h2>\n<p>This is largely downstream of Pillars 1 and 2, but the Rocq ecosystem has relevant verified implementations:</p>\n<ul>\n<li><strong>Functional Algorithms Verified in SSReflect</strong> — Directly maps to the \"algorithms textbook in Boole\" goal.</li>\n<li><strong>Verified Functional Algorithms</strong> (Software Foundations Vol. 3) — Andrew Appel's textbook formalizations of data structures in Coq. A natural porting target.</li>\n<li><strong>Incremental Cycles</strong> — Verified OCaml implementation of incremental cycle detection.</li>\n<li><strong>CompCert</strong> programs verified via VST — There's a corpus of verified C programs. (also included in the <a href=\"https://peregrine-project.github.io/\">https://peregrine-project.github.io/</a> pipeline)</li>\n</ul>\n<hr>\n<p>The key insight is that Rocq has ~40 years of CS formalization that Lean largely lacks, and CSLib is explicitly trying to fill this gap. The Rocq community libraries are the most natural and license-compatible sources for porting foundational CS content.</p>\n</div></div>",
        "id": 572607552,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1770544312
    },
    {
        "content": "<p>Small nitpick: I think it would be nice to move the wall of LLM text into a spoiler drop-down so the human text is easier to see in the flow of conversation.</p>\n<p>I'll speak mostly on the lambda calculus formalizations I wrote. These modules, as noted in their docstrings, very directly take inspiration from Rocq and I wouldn't object to calling them a port. (The interesting deviations as I talked about in my Lean Together talk are how Lean's metaprogramming and <code>grind</code> change things). This isn't in CSLib yet, but I also spent a lot of time looking at Agda formalizations of lambda calculi because of how I believe their intrinsic typing judgements are needed for getting some version of categorical semantics in to Lean. </p>\n<p>As I have mentioned previously, my next big project for CSLib is going to be very directly taking inspiration from Rocq and Nominal Isabelle in setting up metaprogramming utilities for declaring type systems and binding. Again the interesting part here is in synthesis of prior tooling of other proof assistants into something that looks a little bit different in Lean. In areas that I'm less familiar with, I know there have been discussions about making use of the recently added coinductive predicates, which would definitely closely reference prior work in Rocq. </p>\n<p>There are several other examples I'll omit for brevity. So yes, it has not only been considered to take inspiration from Rocq and other proof assistants, but is already actively shaping the library. Several of the examples in the LLM generated text are things that I have already used as inspiration or will for future work. I would personally be welcoming of idiomatic (i.e. not fully AI translated) ports of developments from other proof assistants. The idiomatic piece here is crucial, especially when translating tactics and automation between proof assistants and using existing Mathlib abstractions.</p>",
        "id": 572609494,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770546052
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> I'll try to look up your talk later. Unfortunately, there are no slides here: <a href=\"https://leanprover-community.github.io/lt2026/schedule.html\">https://leanprover-community.github.io/lt2026/schedule.html</a></p>\n<p>From what you wrote, what you've done (looking at rocq and agda) is precisely what I tried to suggest. <br>\nI see you are a PhD-student. Have you considered how to get academic credit for your work, while also giving due credit to earlier formalizations? <br>\nI agree there are more idiomatic ways of translating then say Babel does (<a href=\"https://hal.science/hal-05342510/document\">https://hal.science/hal-05342510/document</a>)<br>\nBut I'm also wondering how to justify porting of several hundreds of thousands of lines  of code from Rocq to Lean, if we dont use assistance. </p>\n<p>About nominal sets, our colleagues work on nominal SSProve is now in the main line: <a href=\"https://eprint.iacr.org/2025/598\">https://eprint.iacr.org/2025/598</a><br>\nMaybe it is of some use to you. I'd be interested in an idiomatic development in Lean.</p>",
        "id": 572620304,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1770556671
    },
    {
        "content": "<p>Link to the talk-<br>\n<a href=\"https://youtu.be/BVmhPmrAMGU\">https://youtu.be/BVmhPmrAMGU</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"BVmhPmrAMGU\" href=\"https://youtu.be/BVmhPmrAMGU\"><img src=\"https://uploads.zulipusercontent.net/6e48c7e56d5cba2a4c92e81c367d338cb00f7968/68747470733a2f2f692e7974696d672e636f6d2f76692f42566d68506d72414d47552f6d7164656661756c742e6a7067\"></a></div>",
        "id": 572621393,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770557889
    },
    {
        "content": "<p>And another CSLib talk-<br>\n<a href=\"https://youtu.be/KfIZn2zH8CA\">https://youtu.be/KfIZn2zH8CA</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"KfIZn2zH8CA\" href=\"https://youtu.be/KfIZn2zH8CA\"><img src=\"https://uploads.zulipusercontent.net/0f2d601113a9451116d57f00e0e52b6b08936746/68747470733a2f2f692e7974696d672e636f6d2f76692f4b66495a6e327a483843412f6d7164656661756c742e6a7067\"></a></div>",
        "id": 572621409,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770557904
    },
    {
        "content": "<p>And slides<br>\n<a href=\"#narrow/channel/557175-Lean-Together-2026/topic/Chris.20Henson.20-.20Proof.20Automation.20and.20Metaprogramming.20in.20CSLib/near/569373059\">https://leanprover.zulipchat.com/#narrow/channel/557175-Lean-Together-2026/topic/Chris.20Henson.20-.20Proof.20Automation.20and.20Metaprogramming.20in.20CSLib/near/569373059</a></p>",
        "id": 572621559,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770558057
    },
    {
        "content": "<p>This is classical POPLmark (reloaded) material.  Someone (<span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> ?) should do Lean4!<br>\n( or maybe it's already done, and then the websites would need to be updated...)</p>\n<p><a href=\"https://poplmark-reloaded.github.io/\">https://poplmark-reloaded.github.io/</a><br>\n<a href=\"https://www.seas.upenn.edu/~plclub/poplmark/\">https://www.seas.upenn.edu/~plclub/poplmark/</a></p>",
        "id": 572625120,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1770561254
    },
    {
        "content": "<p>Thanks for finding the links <span class=\"user-mention\" data-user-id=\"933054\">@Snir Broshi</span>. To address your other questions <span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> :</p>\n<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/513188-CSLib/topic/Porting.20from.20rocq.20.3F/near/572620304\">said</a>:</p>\n<blockquote>\n<p>Have you considered how to get academic credit for your work, while also giving due credit to earlier formalizations? </p>\n</blockquote>\n<p>Yes, as I think is true of any PhD student publications are being considered! How to frame things is a question, but for instance the (<em>very</em> early) work I describe above regarding a Lean synthesis of Autosubst and related work is sufficiently novel in my view. Even the work in my talk linked above, while well trod in some sense, is interesting in seeing how it compares the first Rocq formalizations of locally nameless binding.</p>\n<blockquote>\n<p>I agree there are more idiomatic ways of translating then say Babel does (<a href=\"https://hal.science/hal-05342510/document\">https://hal.science/hal-05342510/document</a>)<br>\nBut I'm also wondering how to justify porting of several hundreds of thousands of lines  of code from Rocq to Lean, if we dont use assistance. </p>\n</blockquote>\n<p>Disclaimer: I am a single maintainer that does not speak unilaterally for CSLib and I'll be as brief as possible at the cost of nuance. My view is the many discussions you can find in other threads about \"why do we formalize mathematics?\" equally apply here. I'd ask a similar \"why do we port to Lean?\". For myself, I think it is because there is something inherently interesting to be found in discovering the \"Lean way\" of implementing the previous decades of PL research done in other proof assistants. For me, using AI to perform large ports does not align with my goals of careful exploring this space. The details are deceptively \"simple\"! </p>\n<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/513188-CSLib/topic/Porting.20from.20rocq.20.3F/near/572625120\">said</a>:</p>\n<blockquote>\n<p>This is classical POPLmark (reloaded) material.  Someone (<span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> ?) should do Lean4!<br>\n( or maybe it's already done, and then the websites would need to be updated...)</p>\n</blockquote>\n<p>Yes, it is! I didn't include records, but the pure Fsub pieces (1A/2A) are complete, closely following Charguéraud. A new contributor is currently working on strong normalization for STLC.</p>",
        "id": 572626074,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770562059
    },
    {
        "content": "<p>We take inspiration from projects (and papers) in other theorem provers, yes. Porting efforts or pointers to relevant projects are always welcome (just like any other formalisation effort in the scope of CSLib). Sometimes porting is not simple, as it requires a redesign to integrate well with CSLib and Mathlib (which we depend on).</p>",
        "id": 573729140,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1770985377
    }
]