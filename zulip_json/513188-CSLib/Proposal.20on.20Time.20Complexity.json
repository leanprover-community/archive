[
    {
        "content": "<p>I am thinking about the simplest way to analyze the time complexity of an algorithm in Lean. Later, we can port these algorithms into more elegant machinery such as Boole. </p>\n<p>I have written an example of merge sort using the Cost Monad to track the running time. What do you feel about this type of analysis?  What I like about this simple approach is that the correctness and runtime proofs remain separate.  </p>\n<p>Comments/suggestions are welcome. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">cost</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CostM</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">cost</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">cost</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pure</span>\n<span class=\"w\">  </span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bind</span>\n<span class=\"c1\">-- Increment cost</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">tick</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">⟩</span>\n<span class=\"c1\">-- We define `@[simp]` lemmas for the `.cost` field, similar to how we did for `.val`.</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">cost_of_pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cost</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">cost_of_bind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CostM</span><span class=\"bp\">.</span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cost</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">cost</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cost</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">cost_of_tick</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tick</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cost</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">val_bind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CostM</span><span class=\"bp\">.</span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">tick</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">tick</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">::</span><span class=\"n\">ys'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">::</span><span class=\"n\">ys'</span><span class=\"o\">)</span>\n<span class=\"w\">         </span><span class=\"n\">tick</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ys'</span>\n<span class=\"w\">         </span><span class=\"n\">tick</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mergeSort</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">half</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">take</span><span class=\"w\"> </span><span class=\"n\">half</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">drop</span><span class=\"w\"> </span><span class=\"n\">half</span>\n<span class=\"w\">  </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">sortedLeft</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mergeSort</span><span class=\"w\"> </span><span class=\"n\">left</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">sortedRight</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mergeSort</span><span class=\"w\"> </span><span class=\"n\">right</span>\n<span class=\"w\">    </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"n\">sortedLeft</span><span class=\"w\"> </span><span class=\"n\">sortedRight</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">decreasing_by</span><span class=\"w\"> </span><span class=\"o\">(</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">length_take</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inf_lt_right</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_le</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">gt_iff_lt</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"n\">simp_all</span>\n<span class=\"w\">    </span><span class=\"n\">rename_i</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">log2_terminates</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n<span class=\"o\">)</span>\n</code></pre></div>",
        "id": 541407869,
        "sender_full_name": "Sorrachai Yingchareonthawornchai",
        "timestamp": 1758791498
    },
    {
        "content": "<p>This is effectively what <span class=\"user-mention\" data-user-id=\"514145\">@Geoffrey Irving</span> already did in the debate formalisation. They also prove the comparison sort lower bound</p>",
        "id": 541428599,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1758797963
    },
    {
        "content": "<p>This method can be generalised to a combinator language parameterised by a query language that I have mentioned many times on Zulip and discord. That allows us to choose custom cost models.</p>",
        "id": 541429020,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1758798090
    },
    {
        "content": "<p>The upside to the monad approach is that you get to reuse lean machinery for the combinator side. The downside is you might be able to sneak in some pure computations. For example you might be able to call merge sort inside a let statement and then just pass the result to the cost function</p>",
        "id": 541429576,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1758798270
    },
    {
        "content": "<p>The ideal method will allow writing Dafny style <code>require</code> and <code>ensure</code> conditions that allow you to write a functional sorting algorithm and then say “our computation is identical to this” and then move to the functional realm for the rest. Then the computational complexity bit will be handled in the Dafny style code listing.</p>",
        "id": 541429786,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1758798334
    },
    {
        "content": "<p>There's also this line of work:<br>\n<a href=\"https://www.cs.cmu.edu/~rwh/papers/calf/popl22.pdf\">https://www.cs.cmu.edu/~rwh/papers/calf/popl22.pdf</a></p>",
        "id": 541443281,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1758802806
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/541443281\">said</a>:</p>\n<blockquote>\n<p>There's also this line of work:<br>\n<a href=\"https://www.cs.cmu.edu/~rwh/papers/calf/popl22.pdf\">https://www.cs.cmu.edu/~rwh/papers/calf/popl22.pdf</a></p>\n</blockquote>\n<p>how much of this translates to imperative code? Wouldn't this require writing a cost aware DSL?</p>",
        "id": 541459400,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1758807155
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/cslib/blob/Boole-sandbox/Cslib/Languages/Boole/examples/MergeSort/mergeSort.lean\">here</a> is correctness and running time analysis</p>",
        "id": 542670573,
        "sender_full_name": "Sorrachai Yingchareonthawornchai",
        "timestamp": 1759389814
    },
    {
        "content": "<p>What stops me from sneaking in the tick function with argument 0 somewhere?</p>",
        "id": 542694215,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759396757
    },
    {
        "content": "<p>To improve this approach a bit, maybe the array should be put behind the monad and made accessible through some query operations. I think this was the approach in the debate formalisation.  Otherwise, nothing stops me from calling a normal function for some operations on some sub arrays which are not counted by this Cost monad.</p>",
        "id": 542696205,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759397321
    },
    {
        "content": "<p>Yeah, to me this is not a very satisfactory notion of time complexity. If you proved various bounds on the \"time complexity\" a function this way, you could never even in principle translate that to (say) something about how quickly a Turing machine can compute it.</p>",
        "id": 542761942,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1759416577
    },
    {
        "content": "<p>I think this kind of <code>tick</code> operation could maybe be used for talking about query or communication complexity, where a <code>get</code> or <code>send</code> function is the only place you need a <code>tick</code>, and so you somehow bundle those together.</p>",
        "id": 542762213,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1759416640
    },
    {
        "content": "<p>I am formalising communication complexity (right now) iand it's much simpler to leave the complexity stuff to the operational semantics</p>",
        "id": 542762840,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759416791
    },
    {
        "content": "<p>Or, in your example, it's already surprising to me: typically sorting algorithms are timed based on the <em>number of comparisons needed</em>, so while you wrote</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">tick</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">tick</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">::</span><span class=\"n\">ys'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">::</span><span class=\"n\">ys'</span><span class=\"o\">)</span>\n<span class=\"w\">         </span><span class=\"n\">tick</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ys'</span>\n<span class=\"w\">         </span><span class=\"n\">tick</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n</code></pre></div>\n<p>I think it would be more standard to express</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">::</span><span class=\"n\">ys'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">tick</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">::</span><span class=\"n\">ys'</span><span class=\"o\">)</span>\n<span class=\"w\">         </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ys'</span>\n<span class=\"w\">         </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n</code></pre></div>",
        "id": 542762868,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1759416797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/542762840\">said</a>:</p>\n<blockquote>\n<p>I am formalising communication complexity (right now) iand it's much simpler to leave the complexity stuff to the operational semantics</p>\n</blockquote>\n<p>Yeah, I agree that's better. Just trying to explain how I feel about a tick-based approach</p>",
        "id": 542763034,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1759416835
    },
    {
        "content": "<p>In general I think if the user can/has to specify the <code>tick</code> calls, then it leaves room for bad specifications</p>",
        "id": 542763190,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759416874
    },
    {
        "content": "<p>And with CSLib we need to be extra careful since there has been some mention of AI generated code being a part of the project.</p>",
        "id": 542763343,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759416905
    },
    {
        "content": "<p>One way to make this tick approach work better (but not ideal) is to define a query monad for the  compare and swap operations on the array, and a small step op semantics for this monad, which tracks calls to the queries and interprets their operations on an array as well as counts the number of query calls. That way local modifications of the array have no effect on the semantics side.</p>",
        "id": 542764217,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759417108
    },
    {
        "content": "<p>Thank you for the good discussion so far.  The only downside is that tick instrumentation requires manual verification to ensure the ticks are counted correctly.  Other than that, it is pretty flexible to count in a way you think can be implemented. Ideally, it would be preferable not to have any manual checks at all, and we aim to achieve this in the long run.</p>",
        "id": 542776485,
        "sender_full_name": "Sorrachai Yingchareonthawornchai",
        "timestamp": 1759420121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/542764217\">said</a>:</p>\n<blockquote>\n<p>One way to make this tick approach work better (but not ideal) is to define a query monad for the  compare and swap operations on the array, and a small step op semantics for this monad, which tracks calls to the queries and interprets their operations on an array as well as counts the number of query calls. That way local modifications of the array have no effect on the semantics side.</p>\n</blockquote>\n<p>I think you are referring to formalizing a query model where you are not allowed to \"cheat\" the system by performing list manipulation outside the query. This is a good idea if you want to formalize a comparison-based model.</p>",
        "id": 542776927,
        "sender_full_name": "Sorrachai Yingchareonthawornchai",
        "timestamp": 1759420233
    },
    {
        "content": "<p>I think the bigger issue with this approach is that for TCS we need a proper specification system that cannot be easily gamed</p>",
        "id": 542784644,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759422387
    },
    {
        "content": "<p>Because our specifications are usually much larger than math and correspondingly it is an engineering nightmare to make sure they are correct.</p>",
        "id": 542784748,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759422423
    },
    {
        "content": "<p>My query idea is more general than comparison based models.</p>",
        "id": 542784832,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759422446
    },
    {
        "content": "<p>Almost all computational models in TCS can be expressed as query models. These queries of the model are the unit operations we perform. This not only applies to standard models like word RAM and Real RAM but also for those situations where you want to additionally perform blackbox queries</p>",
        "id": 542785092,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759422519
    },
    {
        "content": "<p>So for example, if you want to make blackbox queries to the FOCS'22 max flow algorithm or SSSP algorithm, you can extend it to include these calls as queries.</p>",
        "id": 542785349,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759422589
    },
    {
        "content": "<p>Additionally you can include non-traditional models such as the online model or the LCA model as query models.  </p>\n<p>This generalisation is useful because one can reason about the combinators (loops, conditionals, sequential operations, non-deterministic calls) independently of the underlying query model</p>",
        "id": 542785598,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759422656
    },
    {
        "content": "<p>Another thing I want to emphasise is that in the current approach you are allowing the manipulation of semantic information about the algorithm (namely how many steps the algorithm counts) with the syntax (the program spec). These are two separate concerns. It will be hard-to-impossible to prove that your semantics are sound (if at all they are). Conceptually, your costing mechanism should be inaccessible inside the syntax. In some program logic settings they call such parameters ghost variables.</p>",
        "id": 542785945,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759422749
    },
    {
        "content": "<p>Happy to discuss more. Do you have the implementation of your query models or sample code to start the discussion?</p>",
        "id": 542787685,
        "sender_full_name": "Sorrachai Yingchareonthawornchai",
        "timestamp": 1759423303
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"759386\">@Sorrachai Yingchareonthawornchai</span> : in addition to the example I mailed in DM see the deepmind groups formalisation of debate as well as sampcert (published at PLDI)</p>",
        "id": 542812894,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759431952
    },
    {
        "content": "<p><a href=\"https://github.com/girving/debate/blob/f5a4cf1692c9d501c7a922081dc3cf3965e57802/Comp/Sort.lean\">https://github.com/girving/debate/blob/f5a4cf1692c9d501c7a922081dc3cf3965e57802/Comp/Sort.lean</a></p>",
        "id": 542818170,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759433921
    },
    {
        "content": "<p>Also you can see that this discussion about designing the monad to minimise the amount of code that needs to be manually checked has happened here </p>\n<p><a href=\"#narrow/channel/144837-PR-reviews/topic/.2318629.20runtime.20complexity.20of.20sorting.20a.20list/near/483290907\">https://leanprover.zulipchat.com/#narrow/channel/144837-PR-reviews/topic/.2318629.20runtime.20complexity.20of.20sorting.20a.20list/near/483290907</a></p>",
        "id": 542818852,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759434244
    },
    {
        "content": "<p>I've been reading about the CALF framework mentioned above and related work; it is very interesting and solves some of the issues discussed here. I had a couple of questions</p>\n<ul>\n<li>\n<p>Do you think it would be better to build a very general framework in Lean (which may be quite difficult) and after that start estimating algorithms, or perhaps it is better to start contributing estimations with a simpler approach and adapt them progressively as a more general framework takes shape?</p>\n</li>\n<li>\n<p>I read somewhere that the goal is not only to verify algorithms from a theoretical point of view, but to make them available as verified algorithms that can be used elsewhere. Perhaps adapting these algorithms to a very general framework may incur in loss of performance in runtime that make them unusable?</p>\n</li>\n</ul>",
        "id": 543223970,
        "sender_full_name": "Juanjo Madrigal",
        "timestamp": 1759730759
    },
    {
        "content": "<p>I mentored an undergrad (Ian Martin) this summer and he worked on translating Calf to Lean. The translation is incomplete, but may be worth taking a look in any case: <a href=\"https://github.com/ianm1129/Polytime-Formalizations/tree/master\">https://github.com/ianm1129/Polytime-Formalizations/tree/master</a></p>",
        "id": 543250264,
        "sender_full_name": "Quang Dao",
        "timestamp": 1759740025
    },
    {
        "content": "<p>Hi! I don't check this Zulip regularly, but someone pointed me to this thread regarding Calf. The idea of building something like this in Lean is really cool! Let me comment on one potential pitfall to be careful of.</p>\n<p>One of the main ideas of Calf is to use an axiomatic phase distinction to prevent intensional/quantitative information (e.g. instrumentation of programs with time steps) from interfering with the extensional behaviour of functions. The simplest semantic model of this would be in the category <code>Arr(Set)</code>, i.e. the category whose objects are functions between sets and whose morphisms are commuting squares. Then the \"extensional\" stuff lives in the codomains and the \"quantitative\" stuff lives upstairs. The codomain functor <code>Arr(Set) -&gt; Set</code> lets you purge out the intensional/quantitative stuff and reason extensionally about programs. This is incorporated internally to calf by means of a phase modality. In addition to enforcing noninterference, it also gives you a simple way to state theorems like \"mergesort == insertionsort modulo cost\".</p>\n<p>Anyway, this aspect cannot be incorporated into a Lean implementation because Lean has classical logic built-in. In the presence of LEM, the only \"phases\" are the total phase and the empty phase, which means that the calf system becomes degenerate when written in Lean.</p>\n<p>You can still do cool stuff without the phase distinction. But I just wanted to warn you in advance, that to use a phase distinction like calf, you need to work in a type theory that doesn't assume LEM globally. One thing that is interesting about the <code>Arr(Set)</code> model I mentioned is that although <code>Arr(Set)</code> refutes LEM, we can recover <code>Set</code> inside <code>Arr(Set)</code> in two different ways using two modalities; one of them is the \"phase modality\" that purges all the quantitative stuff, and the other is the corresponding \"sealing modality\" that \"moves\" all the extensional/non-quantitative stuff into the quantitative world. (For topos theorists, this is an open/closed partition of the topos; others can feel free to ignore that remark). Anyway, what this means is that you could have a system where LEM is present but restricted in certain ways so as to apply only in these modal subuniverses.</p>",
        "id": 543304316,
        "sender_full_name": "Jonathan Sterling",
        "timestamp": 1759754781
    },
    {
        "content": "<p>Not even in a deeply embedded DSL?</p>",
        "id": 543327024,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759759984
    },
    {
        "content": "<p>I thought that was the proposal, given the juxtaposition with Boole.</p>",
        "id": 543327174,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759760019
    },
    {
        "content": "<p>Hi! A deep embedding could potentially work, depending on the details.</p>",
        "id": 543752853,
        "sender_full_name": "Jonathan Sterling",
        "timestamp": 1759931342
    },
    {
        "content": "<p>I also wonder whether we couldn’t use a typeclass to capture prop types with the desired phase separation. We do use this idea in a different situation (keeping linear and non linear contexts)  for BI logic in iris</p>",
        "id": 543772628,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759935930
    },
    {
        "content": "<p>This is partially relevant:  </p>\n<p><a href=\"#narrow/channel/113486-announce/topic/Loom.3A.20framework.20for.20Multi.20Modal.20program.20verifiers.20in.20Lean/near/544200084\">https://leanprover.zulipchat.com/#narrow/channel/113486-announce/topic/Loom.3A.20framework.20for.20Multi.20Modal.20program.20verifiers.20in.20Lean/near/544200084</a></p>",
        "id": 544211956,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760114717
    },
    {
        "content": "<p>Can somebody exemplify how (some of) the code in <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a> would look in the 'non-gameable' design? Is it gonna work by means of annotations?</p>",
        "id": 560562028,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764239242
    },
    {
        "content": "<p>I have commented a link to an example in the PR.</p>",
        "id": 560565596,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764240251
    },
    {
        "content": "<p>Sorry mentioned it.</p>",
        "id": 560565757,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764240294
    },
    {
        "content": "<p>But this topic has come up several times and I actually linked the comparison sort Lower bound</p>",
        "id": 560565929,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764240337
    },
    {
        "content": "<p>this? <a href=\"https://github.com/girving/debate/blob/f5a4cf1692c9d501c7a922081dc3cf3965e57802/Comp/Sort.lean\">https://github.com/girving/debate/blob/f5a4cf1692c9d501c7a922081dc3cf3965e57802/Comp/Sort.lean</a></p>",
        "id": 560566208,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764240416
    },
    {
        "content": "<p>Yes</p>",
        "id": 560567076,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764240664
    },
    {
        "content": "<p>It works because iirc they work entirely with queries and implement them separately (at least that’s my memory from 1.5 years ago)</p>",
        "id": 560567440,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764240760
    },
    {
        "content": "<p>At least the merge sort function is not annotated <br>\n<a href=\"https://github.com/girving/debate/blob/f5a4cf1692c9d501c7a922081dc3cf3965e57802/Comp/Sort.lean#L229\">https://github.com/girving/debate/blob/f5a4cf1692c9d501c7a922081dc3cf3965e57802/Comp/Sort.lean#L229</a></p>",
        "id": 560567717,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764240838
    },
    {
        "content": "<p>Is the key this line then? <a href=\"https://github.com/girving/debate/blob/f5a4cf1692c9d501c7a922081dc3cf3965e57802/Comp/Sort.lean#L226\">https://github.com/girving/debate/blob/f5a4cf1692c9d501c7a922081dc3cf3965e57802/Comp/Sort.lean#L226</a></p>",
        "id": 560573789,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764242705
    },
    {
        "content": "<p>I agree that fighting manual annotation errors is worthy, but that code looks much more complex. I wonder if it could be made simpler/more ergonomic.<br>\nAn alternative would be to take the <code>TimeM</code> approach in <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a> and create a 'private' library of carefully-vetted and growing-over-time lifted definitions of existing Lean defs, like List.cons (with appropriate costs). Then the 'userspace' algorithms we wanna prove things about could just invoke the API in that library.</p>\n<p>But I'd like to get started from somewhere first, so that we can compare code alternatives. Furthermore, even 'time' is just one of the interesting metrics one can have on programs, and in the future we'll have to figure out a multi-metric approach. So I'd be happy with a polished version of <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a> that can then later be used as reference for future discussions.</p>",
        "id": 560576053,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764243468
    },
    {
        "content": "<p>You’ll find that the review burden scales poorly</p>",
        "id": 560576335,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764243562
    },
    {
        "content": "<p>In the case of algorithms community, there is very little awareness of these issues. CSLib will be seen as an authority on correct formalisation practices</p>",
        "id": 560576528,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764243621
    },
    {
        "content": "<p>I’d rather we don’t have false starts.</p>",
        "id": 560576622,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764243656
    },
    {
        "content": "<p>If you want to get algorithmic content in CSLib I have a different suggestion</p>",
        "id": 560576691,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764243680
    },
    {
        "content": "<p>When proving <em>correctness</em> of algorithms I anticipate that we will find it easier to prove that a given Boole program has the same input-output relationship as a functional programming implementation</p>",
        "id": 560577037,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764243799
    },
    {
        "content": "<p>And then we prove the correctness properties for this implementation.</p>",
        "id": 560577075,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764243812
    },
    {
        "content": "<p>Essentially it’s a proof of Boole code refining a functional spec</p>",
        "id": 560577115,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764243827
    },
    {
        "content": "<p>We can start by writing purely functional versions of the algorithms and proving <em>only</em> their correctness</p>",
        "id": 560577222,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764243860
    },
    {
        "content": "<p>When Boole arrives we will only need to prove the time complexity and refinement stuff</p>",
        "id": 560577349,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764243899
    },
    {
        "content": "<p>Proving correctness of algorithms in the functional style is already feasible in lean. We have some basic results in lean core and mathlib.</p>",
        "id": 560577671,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764243995
    },
    {
        "content": "<p>But there is a whole lot we could still do.</p>",
        "id": 560577750,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764244015
    },
    {
        "content": "<p>There is the entire “Functional Algorithms verified” book in Isabelle which can be ported to lean</p>",
        "id": 560577899,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764244060
    },
    {
        "content": "<p>And in graph algorithms we can write purely functional and set-theoretic versions of these algorithms and show that they satisfy their invariants</p>",
        "id": 560578058,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764244115
    },
    {
        "content": "<p>Proving the functional correctness of Lean code is something we can start doing now for sure, and PRs about that are welcome.<br>\nBut what about their complexity properties (of Lean code; I see what you mean with Boole code)?</p>",
        "id": 560578131,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764244140
    },
    {
        "content": "<p>I’d say that given that we don’t yet have functional correctness we could start working there until Boole arrives</p>",
        "id": 560578253,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764244181
    },
    {
        "content": "<p>Incidentally I think we can also retrofit loom with a different monad and use that for time complexity. But Ilya’s group is already working on it.</p>",
        "id": 560578339,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764244214
    },
    {
        "content": "<p>From both a technical and social viewpoint I think it is important that we get it right as far as time complexity goes. A false start will be a huge setback  given how little the community understands the difficulties involved and will therefore rely  on the example set by authority figures.</p>",
        "id": 560578605,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764244319
    },
    {
        "content": "<p>Let’s not rush the time complexity side in haste when we might very well have a good solution in a couple of months, especially when we still have a lot of work to do on the functional correctness side (especially since this can be put to use in verifying the imperative side later)</p>",
        "id": 560578860,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764244395
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560578605\">said</a>:</p>\n<blockquote>\n<p>From both a technical and social viewpoint I think it is important that we get it right as far as time complexity goes. A false start will be a huge setback  given how little the community understands the difficulties involved and will therefore rely  on the example set by authority figures.</p>\n</blockquote>\n<p>I understand, but that can be dealt with by being informative and very direct about limitations in the docstrings. I'm afraid 'not doing anything until we have the perfect solution' will lead to less progress, not more. We should be working on the perfect solution, and we should have some code to use as benchmark.</p>",
        "id": 560579044,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764244465
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560578860\">said</a>:</p>\n<blockquote>\n<p>Let’s not rush the time complexity side in haste when we might very well have a good solution in a couple of months, especially when we still have a lot of work to do on the functional correctness side (especially since this can be put to use in verifying the imperative side later)</p>\n</blockquote>\n<p>What solution will appear in a couple of months?</p>",
        "id": 560579064,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764244473
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560579044\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560578605\">said</a>:</p>\n<blockquote>\n<p>From both a technical and social viewpoint I think it is important that we get it right as far as time complexity goes. A false start will be a huge setback  given how little the community understands the difficulties involved and will therefore rely  on the example set by authority figures.</p>\n</blockquote>\n<p>I understand, but that can be dealt with by being informative and very direct about limitations in the docstrings. I'm afraid of 'not doing anything until we have the perfect solution'. We should be working on the perfect solution, and we should have some code to use as benchmark.</p>\n</blockquote>\n<p>This makes sense if we can’t make any progress at all. But here we can. There is an enormous amount of work to be done on the correctness and discrete math side.</p>",
        "id": 560579267,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764244534
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560579064\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560578860\">said</a>:</p>\n<blockquote>\n<p>Let’s not rush the time complexity side in haste when we might very well have a good solution in a couple of months, especially when we still have a lot of work to do on the functional correctness side (especially since this can be put to use in verifying the imperative side later)</p>\n</blockquote>\n<p>What solution will appear in a couple of months?</p>\n</blockquote>\n<p>I’m told that the creators of Loom have already managed to create a DSL on top of it, similar to Velvet m, which can count complexity.</p>",
        "id": 560579370,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764244575
    },
    {
        "content": "<p>I'd be very (but pleasantly) surprised if Loom machinery were CSLib-ready and in an accepted PR in a couple of months. :-)</p>",
        "id": 560579602,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764244660
    },
    {
        "content": "<p>It’s more refined than manually counting ticks inside a monad explicitly in its current state because of its verification condition generator. But my original point remains. We have work to do that will be necessary when Boole arrives and which will simplify our task when it does.</p>",
        "id": 560580542,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764244998
    },
    {
        "content": "<p>For what it’s worth, counting ticks has been proposed several times on this Zulip since early 2023 and rejected for the same reasons. It’s something every TCS person who is new to lean comes up with.</p>",
        "id": 560580706,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764245045
    },
    {
        "content": "<p>What's the argument against having the separate library of 'tick annotations' for Lean functions?</p>",
        "id": 560581122,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764245184
    },
    {
        "content": "<p>Same as above. He who controls the ticks determines the complexity.  The larger the spec, the harder it is to check.</p>",
        "id": 560581277,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764245231
    },
    {
        "content": "<p>In algorithms our specs (defs, algorithms, theorem statements) are much larger than in pure math.</p>",
        "id": 560581407,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764245270
    },
    {
        "content": "<p>Sounds like the specs themselves will pose interesting ergonomics issues.</p>",
        "id": 560581517,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764245312
    },
    {
        "content": "<p>Anyway, I'll of course be very happy to see PRs about functional correctness only, without time complexity.</p>",
        "id": 560581619,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764245346
    },
    {
        "content": "<p>I suggest not going ahead with <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a></p>",
        "id": 560581708,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764245377
    },
    {
        "content": "<p>I just don't see how getting started with <em>something</em> about time complexity, as imperfect as it may be, won't be useful to make progress (w/ appropriate strong warnings about reliability). It's the only proposal I have right now.</p>",
        "id": 560581830,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764245415
    },
    {
        "content": "<p>It will set the wrong precedent and you will have to redo the work again later.</p>",
        "id": 560581906,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764245444
    },
    {
        "content": "<p>And you will have to explain to people who have no clue about the difficulties of theorem proving why you are going through all this and then need Boole.</p>",
        "id": 560582026,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764245478
    },
    {
        "content": "<p>There is a stupendous communication gap here because of how little understanding there is of ITP among algorithms theory folks in general have. The few people on this Zulip and some courses students are the exception. Not the norm. A few docstrings will not address this communication gap.</p>",
        "id": 560582408,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764245598
    },
    {
        "content": "<p>Sometimes, nothing is better than something, if that something is going to prove misleading.</p>",
        "id": 560582447,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764245611
    },
    {
        "content": "<p>And it’s not like we don’t have enough to do outside Boole.</p>",
        "id": 560582978,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764245776
    },
    {
        "content": "<p>We hardly have any spectral graph theory. We hardly have basic probability lemmas like concentration bounds. We don’t even have definitions for so many graph decompositions or reduction gadgets.</p>",
        "id": 560583109,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764245825
    },
    {
        "content": "<p>All of which is to say, if we want to make progress that will also prove useful when Boole arrives, there are many more basic things we can (and should) do, instead of false starts in time complexity that will have to be repeated later and will cause review burden in the meantime.</p>",
        "id": 560583813,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764246063
    },
    {
        "content": "<p>Actually I just checked and we don’t even have a definition of strongly connected components of a Digraph because that API is so new. Only a few hours ago I posted a recent definition of Walks in #graph theory,  which does not use dependent indices  (which lead to massive headaches in definitions on Walks). There is currently no definition of Walks for Digraph in mathlib.</p>",
        "id": 560586737,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764246998
    },
    {
        "content": "<p>Given all these tasks at hand, I don’t see a reason to pursue a naive and flawed approach to time complexity which is supposed to be a stopgap for a more systematic solution, and also adds substantial review burden, and later, repetition of all this work for Boole.</p>",
        "id": 560587389,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764247209
    },
    {
        "content": "<p>Btw, if you want concrete reachable goals, I can give some right away. I am half way through developing a lot of Digraph API for flow problems. There are many possibilities here.</p>",
        "id": 560588558,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764247563
    },
    {
        "content": "<p>Many of those are interesting things, which I'd be happy to see PRs for.</p>\n<p>Getting back to this specific topic: why is the <code>TimeM</code> approach doomed? As far as I can see, the approach is simple and modular. So instead of invoking 'naked' operations directly and weaving the ticks in the algorithm, in the very near future we could already invoke lifted 'annotated' operations (like merge sort itself, but also more basic ones like List.cons). <span class=\"user-mention\" data-user-id=\"759386\">@Sorrachai Yingchareonthawornchai</span> is that correct?<br>\nIn the future we might even be able to build some semi-automated support for this.</p>",
        "id": 560608269,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764253006
    },
    {
        "content": "<p>From all the code linked and approaches discussed so far, I haven't seen one that'd give a substantially better situation -- unless we switch to a deeply-embedded language, but then we'd still have to trust the translation from such language to Lean, the verification of which would require... a time-complexity analysis for Lean code, as proposed in here. This all looks a bit circular to me, so starting from the simplest and immediately available thing (Lean) currently seems pretty reasonable. Am I missing something?</p>",
        "id": 560610701,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764253685
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> when you need to review a thousand lines of specification before you get to a proof, you don’t want there to be too much leeway to tinker with standard things in the spec.</p>",
        "id": 560610952,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764253752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560610701\">said</a>:</p>\n<blockquote>\n<p>From all the code linked and approaches discussed so far, I haven't seen one that'd give a substantially better situation -- unless we switch to a deeply-embedded language, but then we'd still have to trust the translation from such language to Lean, the verification of which would require... a time-complexity analysis for Lean code, as proposed in here. This all looks a bit circular to me, so starting from the simplest and immediately available thing (Lean) currently seems pretty reasonable. Am I missing something?</p>\n</blockquote>\n<p>That’s a much more systematic approach (and most likely what Boole is doing and loom does)?</p>",
        "id": 560611196,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764253809
    },
    {
        "content": "<p>There is a very good reason PL researchers invest so much effort into proof engineering</p>",
        "id": 560611366,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764253855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560610952\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> when you need to review a thousand lines of specification before you get to a proof, you don’t want there to be too much leeway to tinker with standard things in the spec.</p>\n</blockquote>\n<p>Are you talking about time complexity specs? Can you give an example?</p>",
        "id": 560611377,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764253859
    },
    {
        "content": "<p>Try writing any modern STOC/FOcS paper in this framework. The specs (def/theorem statements alone) will alone exceed a thousand lines easily</p>",
        "id": 560611569,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764253913
    },
    {
        "content": "<p>Actually just check how big some of these theorem statements are in pen and paper, when fleshed out in detail, including all the custom definitions.</p>",
        "id": 560611778,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764253965
    },
    {
        "content": "<p>Math paper theorem statements are tiny in comparison</p>",
        "id": 560611819,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764253975
    },
    {
        "content": "<p>Please keep in mind that the algorithm code is part of the spec. As are the tick annotations</p>",
        "id": 560611994,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764254012
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560610701\">said</a>:</p>\n<blockquote>\n<p>From all the code linked and approaches discussed so far, I haven't seen one that'd give a substantially better situation ?</p>\n</blockquote>\n<p>That substantially better situation comes from a DSL like Boole and Loom. They have all these proofs for translation. It takes time and effort to engineer them. Haphazardly putting something together looks nice but this means you are going to repeatedly prove concrete theorems again and again instead of abstracting the essentials, and allowing too much flexibility in tinkering with complexity computations which should be purely determined by the composition of operations that are being counted.</p>",
        "id": 560613481,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764254387
    },
    {
        "content": "<p>And this is not waiting for something perfect. This is waiting for something that’s good enough to make formalisation of algorithms reasonably systematic.  If ticks were a solution, we would have long since had algorithms theory in lean. As I mentioned earlier, I have seen this idea on this very Zulip a few times now.</p>",
        "id": 560615519,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764254941
    },
    {
        "content": "<p>Are you saying we won't be able to modularly use theorems like that about the time complexity of merge sort in proofs about the time complexity of algorithms that invoke it?</p>",
        "id": 560619949,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764256133
    },
    {
        "content": "<p>No I am saying it would depend on me annotating all calls correctly. This is far too dangerous in a spec which has to be manually checked, especially when the algorithms get bigger. Another way to put it, the  composition theorems for complexity  would be only valid for correctly annotated functions, and there is no automated check for that or a good formal definition of “correctly annotated”.</p>\n<p>In an acceptable approach, it should not be so easy to sneak in mistakes. The complexity of a function should follow from the selection of basic operations and composition theorems without any human annotation on what to count.</p>",
        "id": 560621661,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764256642
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560621661\">said</a>:</p>\n<blockquote>\n<p>The complexity of a function should follow from the selection of basic operations and composition theorems without any human annotation on what to count.</p>\n</blockquote>\n<p>To me that sounds like a metaprogram that transforms regular Lean functions into <code>TimeM</code> programs. The metaprogram rules would be basically identical to the timing rules a DSL would have to declare and so should result in similar assurances about correct counting, but your specification remains a natural Lean program that can be executed (and proofread) without tick annotation overhead, best of both worlds.</p>",
        "id": 560634858,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1764260566
    },
    {
        "content": "<p>Actually if you get the time complexity before the translation then you wont need to translate the program into TimeM</p>",
        "id": 560635128,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764260669
    },
    {
        "content": "<p>Just a normal lean function would be fine</p>",
        "id": 560635143,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764260674
    },
    {
        "content": "<p>My issue with the current PR is, it just lets the algorithm writer choose when and how much to <code>tick</code> an operation.</p>",
        "id": 560635237,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764260704
    },
    {
        "content": "<p>Not sure what you mean by \"get\" here. Are you saying the metaprogram could be a verifier instead of annotater?</p>",
        "id": 560635297,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1764260724
    },
    {
        "content": "<p>Oh you mean you go from \"lean function\" to \"TimeM\"</p>",
        "id": 560635382,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764260761
    },
    {
        "content": "<p>That could work if we could tell the metaprogram which function calls to count systematically I guess</p>",
        "id": 560635460,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764260791
    },
    {
        "content": "<p>Yes. Same a DSL would have to decide on</p>",
        "id": 560635591,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1764260834
    },
    {
        "content": "<p>Yeah that would work. That would remove the manual tick annotation. Would we need to prove that the metaprogram worked correctly?</p>",
        "id": 560635983,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764260964
    },
    {
        "content": "<p>Is it simpler to write this metaprogram than do what Geoffrey did in the sorting lower bound?</p>",
        "id": 560636445,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764261112
    },
    {
        "content": "<p>The metaprogram could construct a proof that throwing away the ticks results in the input program. I don't think there's much to prove about the ticks part, it would be as axiomatic as in any DSL approach.</p>",
        "id": 560636642,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1764261175
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560636445\">said</a>:</p>\n<blockquote>\n<p>Is it simpler to write this metaprogram than do what Geoffrey did in the sorting lower bound?</p>\n</blockquote>\n<p>Their approach seems to be very specific to counting comparisons via an oracle, I don't see this scaling to arbitrary Lean functions in a natural way</p>",
        "id": 560637342,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1764261429
    },
    {
        "content": "<p>Yeah this sounds much nicer. I once asked Claude to generate an AST for a combinator language parameterised by a <code>Query</code> type. I thought that would generalise his approach.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Claude Generated this. It might have errors. I have a slightly different version without non-determinism</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Algorithmic combinator type parametrized by query type</span>\n<span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"c1\">-- Primitive query operation</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">query</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"c1\">-- Pure value (no computation)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"c1\">-- Sequential composition / monadic bind</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"c1\">-- Conditional branching</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cond</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"c1\">-- Iteration/loops - while loop with state</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">while</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">σ</span>\n\n<span class=\"c1\">-- Bounded iteration - for loop</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">σ</span>\n\n<span class=\"c1\">-- Procedure call/recursion - fixed point combinator</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fix</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">β</span>\n\n<span class=\"c1\">-- Parallel composition (when supported by model)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">par</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Choice/nondeterminism (when supported)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"c1\">-- Syntactic sugar for common patterns</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Combinator.map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"n\">Combinator.bind</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Combinator.pure</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Combinator.seq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"n\">Combinator.bind</span><span class=\"w\"> </span><span class=\"n\">c1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">c2</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- If-then-else sugar</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Combinator.ite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"n\">Combinator.cond</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">e</span>\n\n<span class=\"c1\">-- Repeat n times</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Combinator.repeat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"n\">Combinator.for</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Combinator.seq</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Combinator.pure</span><span class=\"w\"> </span><span class=\"o\">()))</span>\n\n<span class=\"c1\">-- Sequential composition of list of computations</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Combinator.sequence</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Combinator</span><span class=\"w\"> </span><span class=\"n\">Query</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Combinator.pure</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">cs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Combinator.bind</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"n\">Combinator.bind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Combinator.sequence</span><span class=\"w\"> </span><span class=\"n\">cs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"n\">Combinator.pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)))</span>\n</code></pre></div>\n</div></div>\n<p>I didn't pursue this beyond the basics after CSlib was announced due to time constraints and the fact that they were actually paying someone to do this.</p>",
        "id": 560637664,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764261558
    },
    {
        "content": "<p>The complexity composition theorems can be defined on this type and the AST could be compiled to a lean function (partial maybe?)</p>",
        "id": 560637931,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764261638
    },
    {
        "content": "<p>Right, though at that point you're basically writing programs in a DSL again, and indeed you would likely want syntax sugar on top of that</p>",
        "id": 560638234,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1764261735
    },
    {
        "content": "<p>True. The nice thing is, I can define all the models in sequential computation as well as custom models as an inductive type (any number of RAM variants, pointer machines, Real number models). So these are the only operations which are counted and for which I have to provide an interpretation.</p>",
        "id": 560639055,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764262014
    },
    {
        "content": "<p>Note though that with any such semi-shallow representation, you have zero control over the complexity of pure subterms. With a metaprogram, you have all the control.</p>",
        "id": 560639473,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1764262146
    },
    {
        "content": "<p>So in my version, i didn't actually have a constructor for <code>pure</code>, <code>par</code> and <code>choice</code>. I was afraid that I could stuff everything inconvenient into <code>pure</code></p>",
        "id": 560639592,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764262182
    },
    {
        "content": "<p>But surely your <code>bind</code> still takes a Lean function that you have no control over</p>",
        "id": 560639763,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1764262232
    },
    {
        "content": "<p>Yes. I never found a satisfactory fix for that.</p>",
        "id": 560639843,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764262255
    },
    {
        "content": "<p>In effect, the only way to make this completely robust would be for a metaprogram to create this representation, but at that point I think we are at the overkill stage compared to more targeted metaprogram approaches we were discussing.</p>",
        "id": 560640019,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1764262300
    },
    {
        "content": "<p>One work around might be to put the data structures behind the wall of interpretation.</p>",
        "id": 560640530,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764262467
    },
    {
        "content": "<p>I didn't implement it yet so I don't have a concrete idea of how well it will work. But basically you also parametrise the <code>interpret</code> function by a global type of all data structures you use, which can only be accessed by queries. It is complicated to return the value of type<code>\\alpha</code> though. Concretely, I am not sure what the <code>\\alpha</code> ought to represent.</p>",
        "id": 560640757,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764262560
    },
    {
        "content": "<p>In the context of mergesort, this data type would an array and queries would be <code>get (i : Nat)</code>, <code>compare (i j : Nat)..</code> and <code>swap (i j : Nat)</code></p>",
        "id": 560640909,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764262612
    },
    {
        "content": "<p>since <code>Combinator</code> isn't carrying this array around, a pure function or bind function can't actually touch the array directly. You only have the explicit data structure parameter in the \"interpret\" function that interprets the combinator AST into a real lean function</p>",
        "id": 560641122,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764262689
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560634858\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560621661\">said</a>:</p>\n<blockquote>\n<p>The complexity of a function should follow from the selection of basic operations and composition theorems without any human annotation on what to count.</p>\n</blockquote>\n<p>To me that sounds like a metaprogram that transforms regular Lean functions into <code>TimeM</code> programs. The metaprogram rules would be basically identical to the timing rules a DSL would have to declare and so should result in similar assurances about correct counting, but your specification remains a natural Lean program that can be executed (and proofread) without tick annotation overhead, best of both worlds.</p>\n</blockquote>\n<p>This is very near to the 'semi-automated' help I was writing about. Plus, possibly, restricting access to <code>pure</code> and <code>tick</code> to the trusted library of operations (like the annotated version of List.cons).<br>\nMetaprogramming could perhaps also help with some automatic annotations.</p>",
        "id": 560643420,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764263474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560643420\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560634858\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560621661\">said</a>:</p>\n<blockquote>\n<p>The complexity of a function should follow from the selection of basic operations and composition theorems without any human annotation on what to count.</p>\n</blockquote>\n<p>To me that sounds like a metaprogram that transforms regular Lean functions into <code>TimeM</code> programs. The metaprogram rules would be basically identical to the timing rules a DSL would have to declare and so should result in similar assurances about correct counting, but your specification remains a natural Lean program that can be executed (and proofread) without tick annotation overhead, best of both worlds.</p>\n</blockquote>\n<p>This is very near to the 'semi-automated' help I was writing about. Plus, possibly, restricting access to <code>pure</code> and <code>tick</code> to the trusted library of operations (like the annotated version of List.cons).<br>\nMetaprogramming could perhaps also help with some automatic annotations.</p>\n</blockquote>\n<p>It wouldn’t be semi automated. Imagine you have an attribute on top of a lean function that lists function calls you care about. The metaprogram would fully automatically generate a <code>TimeM</code> version with <code>tick</code> at each call of the function. So it would be fully automated.</p>",
        "id": 560643706,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764263591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560640019\">said</a>:</p>\n<blockquote>\n<p>In effect, the only way to make this completely robust would be for a metaprogram to create this representation, but at that point I think we are at the overkill stage compared to more targeted metaprogram approaches we were discussing.</p>\n</blockquote>\n<p>Btw as Fabrizio’s message reminds me, you can also cheat in the TimeM monad as it exists in the PR</p>",
        "id": 560643904,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764263669
    },
    {
        "content": "<p>That part, yes (I don't think you need the list btw, if we have a database of such functions). What I mean is that we'd still have to manually curate the database of lifted basic operations (like operations on Lean lists, arrays, ..., from the standard library).</p>",
        "id": 560644099,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764263759
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560643904\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560640019\">said</a>:</p>\n<blockquote>\n<p>In effect, the only way to make this completely robust would be for a metaprogram to create this representation, but at that point I think we are at the overkill stage compared to more targeted metaprogram approaches we were discussing.</p>\n</blockquote>\n<p>Btw as Fabrizio’s message reminds me, you can also cheat in the TimeM monad as it exists in the PR</p>\n</blockquote>\n<p>Yes, that's why I'm talking about restricting access to pure and tick.</p>",
        "id": 560644150,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764263790
    },
    {
        "content": "<p>I am still keen on making the combinator approach work with the fix I suggested above because it represents a good opportunity to define several sequential models that are masquerading as “the”  RAM model in the literature currently. </p>\n<p>I don’t think you should rely on the lean module system as a way to stop accessing functions. The goal is to formally be able to prove things about them while still not being able to use them in code to cheat.</p>",
        "id": 560644430,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764263905
    },
    {
        "content": "<p>Wouldn't that give us very non-idiomatic lean code? (I admit I might be a bit lost in all the messages now.)</p>\n<p>Btw, with the TimeM approach, I also get to use the current manually-indtrumented implementation as a test for the future metaprogramming facility.</p>",
        "id": 560644675,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764264005
    },
    {
        "content": "<p>It would give us idiomatic algorithms pseudocode which is then compiled into lean code.</p>",
        "id": 560644773,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764264056
    },
    {
        "content": "<p>Which is arguably a nice thing to have.</p>",
        "id": 560644792,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764264066
    },
    {
        "content": "<p>And it would allow us to reason about algorithms whose implementation details have not been fleshed out fully.</p>",
        "id": 560644891,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764264116
    },
    {
        "content": "<p>From the perspective of reviewing/maintenance, I worry about introducing this before we have had a chance to see Boole land in the main branch, which to my understanding will cover some of the same ground? After seeing the subtleties discussed in this thread, I don't believe I personally have the expertise or bandwidth to review.</p>",
        "id": 560644930,
        "sender_full_name": "Chris Henson",
        "timestamp": 1764264136
    },
    {
        "content": "<p>(Which I think is important in modern algorithms theory)</p>",
        "id": 560644931,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764264136
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560644930\">said</a>:</p>\n<blockquote>\n<p>From the perspective of reviewing/maintenance, I worry about introducing this before we have had a chance to see Boole land in the main branch, which to my understanding will cover some of the same ground? After seeing the subtleties discussed in this thread, I don't believe I personally have the expertise or bandwidth to review.</p>\n</blockquote>\n<p>that would also be my suggestion for the near term. This combinator query is something  I want to mess with independently, but any PR to do complexity without waiting for Boole will create a lot of overlapping work. And as I argued before, we have a lot we can do that will link up to Boole code in the future anyway.</p>",
        "id": 560645255,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764264268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560644773\">said</a>:</p>\n<blockquote>\n<p>It would give us idiomatic algorithms pseudocode which is then compiled into lean code.</p>\n</blockquote>\n<p>Ah, I see what you mean. But this would indeed overlap with Boole and other WIP, so I'd wait at least a little bit to hear progress on that.</p>\n<p>The <code>TimeM</code> approach is appealing precisely because it's 'lightweight', albeit this makes it more complicated to build a trust layer around it.</p>",
        "id": 560646927,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764264882
    },
    {
        "content": "<p>My take is, we had several variants of <code>TimeM</code> floating around since the end of mathlib3-&gt;mathlib4 port. We waited for a proper language because of the difficulties of managing this lightweight approach. I think the Boole people and initial CSLib steering committee members who backed it knew this as well.</p>",
        "id": 560647181,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764265002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560641122\">said</a>:</p>\n<blockquote>\n<p>since <code>Combinator</code> isn't carrying this array around, a pure function or bind function can't actually touch the array directly. You only have the explicit data structure parameter in the \"interpret\" function that interprets the combinator AST into a real lean function</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> : Would love to hear your take on this</p>",
        "id": 560648501,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764265472
    },
    {
        "content": "<p>Also I just noticed that the Claude definition of <code>fix</code> is wrong (it's coinductive)</p>",
        "id": 560649832,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764266061
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> Again, I get what you mean, but it's a different problem. How will I analyse the time complexity of arbitrarily-structured Lean code with that approach?</p>",
        "id": 560651049,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764266563
    },
    {
        "content": "<p>You can’t. But lean code is also not exactly great to verify time complexity with. Sebastian’s solution gets rid of the manual annotation of each function call. But this is still verifying our interpretation of lean function’s time complexity.</p>",
        "id": 560651330,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764266675
    },
    {
        "content": "<p>To be clear we are now talking about two related things. </p>\n<ol>\n<li>The TimeM monad approach as it exists in the PR</li>\n<li>Sebastian’s suggestion to metaprogram lean functions into TimeM and automatically tag calls to pre-specified functions.</li>\n</ol>",
        "id": 560651790,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764266764
    },
    {
        "content": "<p>1 is not ideal for all the reasons discussed above. 2 is nice because it is lightweight and requires no manual annotation of ticks inside the def of an algorithm.</p>",
        "id": 560651953,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764266816
    },
    {
        "content": "<p>1 is also good prototyping towards 2 though, I don't find it objectionable if it comes with a clear plan</p>",
        "id": 560652149,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1764266904
    },
    {
        "content": "<p>For 2, you need a metaprogram that converts lean functions and a theorem that shows that the lean function and its TimeM counterpart are extensionally equal.</p>",
        "id": 560652322,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764266976
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560651790\">said</a>:</p>\n<blockquote>\n<p>To be clear we are now talking about two related things. </p>\n<ol>\n<li>The TimeM monad approach as it exists in the PR</li>\n<li>Sebastian’s suggestion to metaprogram lean functions into TimeM and automatically tag calls to pre-specified functions.</li>\n</ol>\n</blockquote>\n<p>Exactly, these are not disjoint, planning wise. As I mentioned earlier on, the idea is to use 1 to work on the interface (TimeM) and then work on 2 as we gain experience through 1. The intermediate step is to build a good library of functions so that we can start asking to use little to no ticks in PRs, or something like that.</p>\n<p>So, in a nutshell, 1 still looks very useful to me, with the warnings that I talked about.</p>",
        "id": 560652600,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764267098
    },
    {
        "content": "<p>Well yeah the warnings are important. We should also have some sort of a policy on merging PRs which come with tick annotated functions until 2 is ready.</p>",
        "id": 560652803,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764267199
    },
    {
        "content": "<p>My idea was to push people towards making and expanding this 'trusted' library of lifted operations and time-verified algos.</p>\n<p>We could even make some static checkers and safe/unsafe blocks to help with checking the code.</p>",
        "id": 560653578,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764267592
    },
    {
        "content": "<p>I think you are headed towards the complexity sebastian was talking about. Currently even if there is a safe function with <code>tick</code>, you still need to call <code>tick</code> on it when you call the function.</p>",
        "id": 560653669,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764267643
    },
    {
        "content": "<p>The goal should be to get the metaprogram ready asap. the mergesort code can prove useful as a test for the metaprogram (and so migrate to a file in the test folder). EDIT: Actually any manually annotated <code>TimeM</code> program which you think would help device the metaprogram probably ought to be used in testing anyway.</p>",
        "id": 560653744,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764267678
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560653578\">said</a>:</p>\n<blockquote>\n<p>We could even make some static checkers and safe/unsafe blocks to help with checking the code.</p>\n</blockquote>\n<p><del>People have discussed the difficulties of adding linear type theory and quantitative type theoretic frameworks on top of lean. I think the conclusion was that this was practically impossible.</del> EDIT : Oh you mean for the test cases? Yeah that makes sense</p>",
        "id": 560653938,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764267802
    },
    {
        "content": "<p>Ideally the main repository folder should not contain this <code>unsafe</code> code.</p>",
        "id": 560654625,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764268188
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560653669\">said</a>:</p>\n<blockquote>\n<p>I think you are headed towards the complexity sebastian was talking about. Currently even if there is a safe function with <code>tick</code>, you still need to call <code>tick</code> on it when you call the function.</p>\n</blockquote>\n<p>(This is now more a bit of stream of consciousness..)<br>\nCouldn't we give the user the possibility to declare the function as safe (or unsafe, conversely) somehow and then activate a linter/checker that complains every time you don't tick a call to a TimeM term?</p>",
        "id": 560654641,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764268196
    },
    {
        "content": "<p>I don't think it is a good idea to have the unsafe stuff in the main library</p>",
        "id": 560654738,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764268237
    },
    {
        "content": "<p>Since they are test cases for the metaprogram, it makes sense to have them as objects for building future tests in the corresponding folder</p>",
        "id": 560654790,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764268263
    },
    {
        "content": "<p>I think we can have a somewhat controllable directory or small unsafe blocks, and then safe algorithms like merge sort that build on them. We'll need a trusted Lean layer for a long time, even with Boole or similar approaches, so I want to start exploring this soon.</p>",
        "id": 560660585,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764271300
    },
    {
        "content": "<p>I've also mostly been in the \"wait for Boole to work on time complexity\" camp but I do have a suggestion for this query complexity stuff which uses a free monad to avoid the issue of gaming the tick function.  It resembles <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> combinator language. Something like the following:</p>\n<p>Define an AST/functor describing the primitive ops of our computation model:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">QueryF</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">read</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">QueryF</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">write</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">QueryF</span><span class=\"w\"> </span><span class=\"n\">PUnit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cmp</span><span class=\"w\">   </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">QueryF</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"c1\">-- etc: whatever the RAM / comparison model needs</span>\n</code></pre></div>\n<p>Define a free monad of programs over the model:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Prog</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"w\"> </span><span class=\"n\">QueryF</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>With some basic control flow like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Prog</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">cond</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Prog</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Prog</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Prog</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">forLoop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Prog</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Prog</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Prog</span><span class=\"w\"> </span><span class=\"n\">PUnit</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\">       </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">()</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\">   </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">I</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Prog</span>\n</code></pre></div>\n<p>Then all programs are written in <code>Prog</code> and their complexity is measured by interpreting/folding into <code>CostM</code> instead of manually annotating with ticks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">costOfQuery</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">QueryF</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">read</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\">       </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">write</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\">    </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cmp</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\">      </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">costInterp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">QueryF</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"w\"> </span><span class=\"n\">ι</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">read</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\">      </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"bp\">.</span><span class=\"n\">tick</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">costOfQuery</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">read</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">write</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\">   </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"bp\">.</span><span class=\"n\">tick</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">costOfQuery</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">write</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cmp</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\">     </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">CostM</span><span class=\"bp\">.</span><span class=\"n\">tick</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">costOfQuery</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cmp</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">))</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">costProg</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Prog</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">liftM</span><span class=\"w\"> </span><span class=\"n\">costInterp</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cost</span>\n</code></pre></div>\n<p>This doesn't give full time complexity but seems to address some of the issues wrt query complexity</p>",
        "id": 561826867,
        "sender_full_name": "Tanner Duve",
        "timestamp": 1764839459
    },
    {
        "content": "<p>We can write another interpreter that actually executes the program:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">evalQuery</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">QueryF</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ι</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">read</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\">      </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">write</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\">   </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cmp</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\">     </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">evalProg</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Prog</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">FreeM</span><span class=\"bp\">.</span><span class=\"n\">foldFreeM</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">QueryF</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">evalQuery</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>And then write a mergeSort as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">cmpVal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Prog</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">FreeM</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">QueryF</span><span class=\"bp\">.</span><span class=\"n\">cmp</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Prog</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">XS</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ys'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">cmpVal</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ys'</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ys'</span>\n<span class=\"w\">        </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">accL</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">accR</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">accL</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">accR</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">accL</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">accR</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">accL</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">accR</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"w\"> </span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">accL</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">accR</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">accL</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">accR</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n\n<span class=\"c1\">-- partial for now didn't feel like writing termination proof</span>\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mergeSort</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Prog</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\">      </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"w\">     </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">XS</span><span class=\"w\">      </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"n\">XS</span>\n<span class=\"w\">    </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">sortedLeft</span><span class=\"w\">  </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mergeSort</span><span class=\"w\"> </span><span class=\"n\">left</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">sortedRight</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mergeSort</span><span class=\"w\"> </span><span class=\"n\">right</span>\n<span class=\"w\">      </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"n\">sortedLeft</span><span class=\"w\"> </span><span class=\"n\">sortedRight</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">evalProg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mergeSort</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">8</span><span class=\"o\">,</span><span class=\"mi\">6</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">7</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">])</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">costProg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mergeSort</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">8</span><span class=\"o\">,</span><span class=\"mi\">6</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">7</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>And our #eval outputs are <code>[1, 2, 3, 4, 5, 6, 7, 8]</code> and <code>12</code> respectively</p>",
        "id": 561829614,
        "sender_full_name": "Tanner Duve",
        "timestamp": 1764840248
    },
    {
        "content": "<p>I love this idea.</p>",
        "id": 561864250,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764851107
    },
    {
        "content": "<p>Just one extra step : abstract the query type as a parameter and declare a type class that requires the query type to have an interpretation function and counting function</p>",
        "id": 561864388,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764851145
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 561864772,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764851248
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> thoughts?</p>",
        "id": 561957448,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764875762
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"677310\">@Tanner Duve</span> what’s your definition of free monads btw?</p>",
        "id": 561957933,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764875940
    },
    {
        "content": "<p>Is this using  freer monads</p>",
        "id": 561958027,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764875972
    },
    {
        "content": "<p>Yeah its a freer monad, the traditional free monad definition (eg Haskell) fails termination checking due to strict positivity</p>",
        "id": 561961761,
        "sender_full_name": "Tanner Duve",
        "timestamp": 1764877414
    },
    {
        "content": "<p>All free monad stuff is in here: <a href=\"https://github.com/leanprover/cslib/tree/main/Cslib/Foundations/Control/Monad\">https://github.com/leanprover/cslib/tree/main/Cslib/Foundations/Control/Monad</a></p>",
        "id": 561961791,
        "sender_full_name": "Tanner Duve",
        "timestamp": 1764877426
    },
    {
        "content": "<p>The definition is <a href=\"https://github.com/leanprover/cslib/blob/c362a7cde26e85a5a679a814852bd817506ee9c6/Cslib/Foundations/Control/Monad/Free.lean#L78\">here</a></p>",
        "id": 561961833,
        "sender_full_name": "Tanner Duve",
        "timestamp": 1764877447
    },
    {
        "content": "<p>I’m no expert in this topic. But I wonder if there is any plan to ground these rather abstract complexity models on something more “concrete “ like RAM model?</p>",
        "id": 562167261,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1764961632
    },
    {
        "content": "<p>The proposal for Boole is such a concrete model in some sense. But realistically that would be too restrictive for algorithms research and theory.</p>",
        "id": 562167394,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764961685
    },
    {
        "content": "<p>But surely there need to be some sort of grounding so that one knows that the abstract model is within (say) a constant factor of a more concrete model like the RAM model? Otherwise one would not know reliably whether a complexity result in terms of the more abstract model actually says anything about real-world performance, right?</p>",
        "id": 562169076,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1764962446
    },
    {
        "content": "<p>Not really. No theoretical complexity model has any meaningful connection with what you run and measure  on a recent computer.</p>",
        "id": 562176722,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764965960
    },
    {
        "content": "<p>Not even the RAM model. It’s a good line of inquiry to build more realistic models and relate them to query models (outside lean),  but that’s also orthogonal to formulating the theory in terms of queries in lean in the first place.</p>",
        "id": 562176982,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764966100
    },
    {
        "content": "<p>Secondly a lot of theoretical models are designed purely for theoretical insight. You want to measure the theoretically best achievable result in a very hypothetical model that is weaker than real models or prove lower bounds in a stronger model that then translate to a weaker model.</p>",
        "id": 562177251,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764966247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/562176722\">said</a>:</p>\n<blockquote>\n<p>Not really. No theoretical complexity model has any meaningful connection with what you run and measure  on a recent computer.</p>\n</blockquote>\n<p>Then I have to say I don’t understand why you would care about whether the “tick” can be gamed in the first place.</p>",
        "id": 562180674,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1764967697
    },
    {
        "content": "<p>Scale:   If you pre-select queries (like Tanner illustrated above) and the complexity is compositionally determined, then you only need to check the query type to know what operations are counted and the statement of correctness and complexity  of the algorithm. In the manual tick approach you also have to check that each occurrence of a specific operation is marked with a tick inside the algorithm definition. Additionally, you don’t actually get to make a more fine grained count of each query separately. </p>\n<p>Sorrachai is perfectly correct that algorithms theory is more directly concerned with the lightweight measurement of queries rather than exact complexity. If you search this Zulip and the lean discord, I am sure you will find that I have made this point several times in the last two years . My objection to the time monad is how much manual checking this will entail of the spec as opposed to the combinator/freer monad approach. The time monad approach is not nearly as compositional as the latter. Scale problems will generally get worse as we have more algorithms of increasing complexity.</p>",
        "id": 562181603,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764968158
    },
    {
        "content": "<p>Another benefit of a parametrised query approach is how many different standard models and custom oracles it could subsume in one set of composition theorems for complexity. This benefit is lost in the manual tick approach because of loss of compositionality.</p>",
        "id": 562182012,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764968363
    },
    {
        "content": "<p>Note that my comments were not about the particulars of time monad or any other models. I was merely asking whether there is any plan to ground the more abstract models on the more concrete models, perhaps in the form of some simulation theorem where (for example) the run time on the former can be bounded by the run time on the latter with a constant factor. I have no skin in which model should be chosen, but I do care about whether the results proved using a model has some connection to real-world performance. The connection doesn’t have to be direct or even very close, but it should be there and we should have theorems about it.</p>",
        "id": 562195706,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1764975961
    },
    {
        "content": "<p>You are asking for something that is far too complicated for modern commodity hardware + compilers + tool stack. The best we can mathematically do is what theorists already do. Asymptotic measurement of the number of calls to specific primitives (queries).</p>",
        "id": 562195994,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764976165
    },
    {
        "content": "<p>Remember that I brought up the RAM model?</p>",
        "id": 562200330,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1764979645
    },
    {
        "content": "<p>Yes. But the RAM model itself is not one model.</p>",
        "id": 562200383,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764979672
    },
    {
        "content": "<p>Pick the one you like. Is there a relationship between that RAM model and the query based model you can prove?</p>",
        "id": 562200534,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1764979814
    },
    {
        "content": "<p>Probably. But it is uninteresting and tedious</p>",
        "id": 562200626,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764979886
    },
    {
        "content": "<p>Why?</p>",
        "id": 562200649,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1764979913
    },
    {
        "content": "<p>Because it is full of implementation details that are trivially understood but tedious to pin down precisely. You are welcome to experiment with it.</p>",
        "id": 562200717,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764979955
    },
    {
        "content": "<p>the RAM \"model\" would just be another query type with a rather long list of queries</p>",
        "id": 562200746,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764979976
    },
    {
        "content": "<p>Further as I mentioned before, algorithms theory only cares about this connection \"morally\". Our primary work is combinatorial procedures that explain how we construct something from access to some other procedure (query)</p>",
        "id": 562200798,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1764980025
    },
    {
        "content": "<p>Is there a paper/survey I can read up on to understand how this \"Query model\" measures time ?</p>\n<p>I understand what a \"step\" of a TM is.<br>\nFor the \"RAM\" model, I approximate it as: imagine MIPs, except instead of 32bit registers/words, we have registers/words that are k*logn size for some k, where n = size of input.</p>\n<p>Then we can compile a language like a mini-OCaml/mini-Haskell to RAM model.</p>\n<p>Then we can write NP reductions succintly in mini-OCaml/Haskell, if a few log n factors here &amp; there don't matter; or write it in \"mips assembly w/ k*log n size registers) if getting the right running time really matters [like Dijkstras].</p>\n<p>How does the \"query model\" compare to this ?</p>",
        "id": 562214746,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764994217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"677310\">Tanner Duve</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/561826867\">said</a>:</p>\n<blockquote>\n<p>With some basic control flow like this:</p>\n</blockquote>\n<p>I thought the point of the monad is that you can just use <code>do</code> notation with native for loops and <code>if</code>s?</p>",
        "id": 562217599,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1764997696
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1001511\">TongKe Xue</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/562214746\">said</a>:</p>\n<blockquote>\n<p>Is there a paper/survey I can read up on to understand how this \"Query model\" measures time ?</p>\n<p>I understand what a \"step\" of a TM is.<br>\nFor the \"RAM\" model, I approximate it as: imagine MIPs, except instead of 32bit registers/words, we have registers/words that are k*logn size for some k, where n = size of input.</p>\n<p>Then we can compile a language like a mini-OCaml/mini-Haskell to RAM model.</p>\n<p>Then we can write NP reductions succintly in mini-OCaml/Haskell, if a few log n factors here &amp; there don't matter; or write it in \"mips assembly w/ k*log n size registers) if getting the right running time really matters [like Dijkstras].</p>\n<p>How does the \"query model\" compare to this ?</p>\n</blockquote>\n<p>The query model is a general idea that subsumes multiple models. There query here is an inductive type of basic operations (possibly parametrised by more inputs).  </p>\n<ol>\n<li>The RAM model is one such query model. You write a query type whose constructors are the unit operations of the RAM model and assign unit cost to all of them. </li>\n<li>The operations of a Turing machine can be encoded as another query type. Mathlib already has such a type of operations for one of its Turing machine types. </li>\n</ol>\n<p>As for literature, this idea seems to be evolving folklore. I can give you my perspective of the history, but that’s a long and off-topic answer.</p>",
        "id": 562232801,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765015651
    },
    {
        "content": "<p>But part of it is my own story of convincing both the lean community and my corner of the algorithms to understand this intermediate lightweight abstraction of complexity which is closer to what algorithms theorists write in their papers than focus on implementations. I got a concrete version of this idea from Wouter Swierstra’s PiWare in roughly Spring 2023 . But it’s also basically one of  the oldest ideas in the PL world : write a DSL that captures all the compositions you care about and compile it down to other code. Once you abstract away the basic operations type, you can obtain multiple models and complexities of algorithms in them from the same composition theorems for complexity.</p>",
        "id": 562232859,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765015767
    },
    {
        "content": "<p>It is not clear to me the advantage of this over</p>\n<ol>\n<li>define a RAM model once; each instr = 1 tick</li>\n<li>let people build whatever High Level Language they want in the form of a compiler to the RAM model</li>\n<li>there's no way to \"cheat\" time/space in the HLL, as we measure both from the RAM model</li>\n</ol>",
        "id": 562236060,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1765020273
    },
    {
        "content": "<p>There is no cheating happening. It is a perfectly valid question to ask how may DFS or cut queries or matrix multiplication queries it took to get an algorithm working.</p>",
        "id": 562236113,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765020358
    },
    {
        "content": "<p>I am sorry but if you think algorithms theory at the research is about producing implementable code you write in undergrad classes and LeetCode, you are simply mistaken.</p>",
        "id": 562236160,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765020408
    },
    {
        "content": "<p>Also there is no “the RAM model”. I encourage you to try writing a Real RAM to word RAM compiler including handling all the floating point issues. You will see how many many trivial issues lead to formalisation headaches. It’s also far removed from algorithmic content</p>",
        "id": 562236250,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765020506
    },
    {
        "content": "<p>Secondly even in complexity theory, oracles are a thing independent of the standard models. These are by definition implementation agnostic</p>",
        "id": 562236319,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765020622
    },
    {
        "content": "<p>I think you and I have different motives. I want to formalize (1) CLRS style proofs and (2) <a href=\"https://theory.cs.princeton.edu/complexity/\">https://theory.cs.princeton.edu/complexity/</a> style complexity theory.</p>",
        "id": 562236394,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1765020721
    },
    {
        "content": "<p>On the contrary we both have the same motives. I just recognise that CLRS style formalisation won’t scale for research level CS theory.</p>",
        "id": 562236435,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765020775
    },
    {
        "content": "<p>And the query + combinator model will give you a better way of working with Turing machines as well than raw transition function applications.</p>",
        "id": 562236469,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765020819
    },
    {
        "content": "<p>But we are beginning to veer off-topic here</p>",
        "id": 562236477,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765020832
    },
    {
        "content": "<p>Boole is supposed to be  designed to implement CLRS style algorithms per the announcement of CSLib. Maybe that’s something you want to wait for.</p>",
        "id": 562236527,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765020877
    },
    {
        "content": "<p>Do note that even CLRS plays a bit fast and loose with their RAM model as long as the word size is irrelevant (they become relevant when you have pseudo polynomial time algorithms)</p>",
        "id": 562236671,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765021098
    },
    {
        "content": "<p>If you want to go as far as implementing word ram, you might end up implementing your own int and float types and that would be overkill.</p>",
        "id": 562236771,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765021189
    },
    {
        "content": "<p>I'm curious why you insist in assigning costs at constructors of your \"Query Model\"  vs just writing a compiler from your \"Query Model\" to the CLRS-RAM Model, and just counting instrs at the CLRS-RAM model level.</p>",
        "id": 562236798,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1765021239
    },
    {
        "content": "<p>Because I understand the abstraction at which algorithms theory works and the pointless tedium of trying to implement and/or compile something to some real world model and its complete irrelevance to algorithmic complexity</p>",
        "id": 562236898,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765021385
    },
    {
        "content": "<p>We discussed all this way back in 2023 in a thread about computational complexity. I think I was talking about the query model more vaguely back then.</p>",
        "id": 562236926,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765021433
    },
    {
        "content": "<p>I also see the unifying power of a query model to abstract dozens of computational models as well as hundreds of bespoke query models. Just yesterday I was chatting with someone about property testing substring matches and naturally that also fits into a query model.</p>",
        "id": 562236994,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765021515
    },
    {
        "content": "<p>Also I object to “the CLRS RAM model” being a single well defined term. There is almost certainly more than one model. They have a chapter on geometric algorithms iirc</p>",
        "id": 562237028,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765021563
    },
    {
        "content": "<p>This discussion has dragged on and I have answered all your questions. To get back on track</p>\n<p>I have a PR to <span class=\"user-mention\" data-user-id=\"677310\">@Tanner Duve</span>’s PR where I abstract the query type as a parameter</p>",
        "id": 562237201,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765021801
    },
    {
        "content": "<p>Does your query model allow people to do * and + ?</p>\n<p>Consider a problem of size n, where we will be using (log n) sized registers.</p>\n<p>Multiplying two numbers of log-n bits is O(1) on RAM model.<br>\nMultiplying two numbers of size (n log n) bits is atleast big-Omega(n) &lt;-- just to read the input and output.</p>\n<p>In your query model, does both count as \"1 multiplication\" ?</p>\n<p>The way this is resolved in the RAM model is that registers are of size k log n for some fixed constant k; thus, we can't stuff a (n log n)-bit number in a single register. So we need to spread it out in big-Theta(n/k) different registers. Even in your \"Query Model\", I don't see how you get around the issue of tracking that all your registers/numbers are O(log n) bits.</p>",
        "id": 562255042,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1765042861
    },
    {
        "content": "<p>I think you are missing the point. You pick the unit operations. To be up front if we did care about bit complexity of multiplication we can use the corresponding cost function. You should know that even in these models, you assume something like bigint and count the bit size of numbers to deduce cost.</p>",
        "id": 562255145,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765043019
    },
    {
        "content": "<p>The cost is simply abstracted away by taking log2 of those numbers and assigning to operations their  bit complexity.  How they are distributed among registers is an irrelevant implementation detail.</p>",
        "id": 562255255,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765043158
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 562255505,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765043512
    },
    {
        "content": "<p>I am answering your questions, but we are veering substantially off-topic here. Both the time monad and query-combinator approach are being  pushed by people who actually work in this area of research (Sorrachai and me, respectively). If you wish to continue this discussion, I believe a new topic should be started. Our discussion above is specifically about how to implement this lightweight query approach.</p>",
        "id": 562255644,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765043697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/562217599\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"677310\">Tanner Duve</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/561826867\">said</a>:</p>\n<blockquote>\n<p>With some basic control flow like this:</p>\n</blockquote>\n<p>I thought the point of the monad is that you can just use <code>do</code> notation with native for loops and <code>if</code>s?</p>\n</blockquote>\n<p>Yeah you could just use do notation, the control flow stuff I wrote wasn't necessary</p>",
        "id": 562257909,
        "sender_full_name": "Tanner Duve",
        "timestamp": 1765046151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/562237201\">said</a>:</p>\n<blockquote>\n<p>This discussion has dragged on and I have answered all your questions. To get back on track</p>\n<p>I have a PR to <span class=\"user-mention silent\" data-user-id=\"677310\">Tanner Duve</span>’s PR where I abstract the query type as a parameter</p>\n</blockquote>\n<p>just merged it into my branch</p>",
        "id": 562257933,
        "sender_full_name": "Tanner Duve",
        "timestamp": 1765046180
    },
    {
        "content": "<p>Catching up. Question: this is merge sort in <a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a>, </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SortProg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ys'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">cmpVal</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ys'</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ys'</span>\n<span class=\"w\">        </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>What prevents me from 'cheating' with a pure normal comparison rather than invoking cmpVal? (I haven't read all the code yet, but would appreciate a pointer.)</p>",
        "id": 562261453,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1765049957
    },
    {
        "content": "<p>Writing the algorithm over an abstract type without any comparison operators helps a bit</p>",
        "id": 562295313,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1765097744
    },
    {
        "content": "<p>When you come to proving correctness of the algorithm, you'll get stuck because I could pass in a comparator that reverses the order, and you'd be ignoring it and using the regular one</p>",
        "id": 562295448,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1765097882
    },
    {
        "content": "<p>What do you mean? Changing the signature of that merge sort example so not to use Nat?</p>",
        "id": 562296740,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1765099237
    },
    {
        "content": "<p>Won't we want to specify that algo and query model over any type with a comparison op?</p>",
        "id": 562296780,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1765099300
    },
    {
        "content": "<p>My PR to Tanners PR was incomplete at the point of merging. I might try to change it so that the query monad returns a program ast (a sequence or tree of queries), such that one has to evaluate them to produce a program. Tanner goes further and lifts from this monad to the time monad.</p>",
        "id": 562298482,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765101383
    },
    {
        "content": "<p>The monad should eventually just return an ast that is interpreted.</p>",
        "id": 562298516,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765101417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/stream/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/562296780\">said</a>:</p>\n<blockquote>\n<p>Won't we want to specify that algo and query model over any type with a comparison op?</p>\n</blockquote>\n<p>You indeed want to generalize to any type, but you don't want to include the comparison operation in the signature of the algorithm; the whole point is to force the algorithm to make a query to obtain it</p>",
        "id": 562345818,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1765141862
    },
    {
        "content": "<p>You can then prove something like <code>((mySortAlg l).run rel).Sorted rel</code> to show the algorithm is correct, and look at the \"ast\" of <code>(mySortAlg l)</code> to evaluate complexity. This is what <span class=\"user-mention\" data-user-id=\"514145\">@Geoffrey Irving</span>'s proofs of sorting complexity do, roughly.</p>",
        "id": 562346428,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1765141993
    },
    {
        "content": "<p>The idea is that the underlying data structure (in this case the array) is never directly accessible to the program in the Prog monad.</p>",
        "id": 562371337,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765152909
    },
    {
        "content": "<p>It can only create query tokens in an AST.</p>",
        "id": 562371353,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765152931
    },
    {
        "content": "<p>It is the interpretation/evaluation function that interprets those queries over the array.</p>",
        "id": 562371380,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765152961
    },
    {
        "content": "<p>i dont know if someone mentioned this already, but there should probably be a shallow embedding of simply typed lambda caclulus into lean</p>",
        "id": 562384554,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1765167231
    },
    {
        "content": "<p>so some sort of a notation <code>cdef</code> that allows you to simultaneously define a quoted functino in simply typed lambda calulcus along with it's corresponding monadic function and a proof of equivalence between the two. That way you can just prove properties about the unquoted functions for correctness and analyze the time complexity of the quoted function (the quoted function wont be part of a function type so you can just induct over the type of simply typed functions)</p>",
        "id": 562384652,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1765167322
    },
    {
        "content": "<p>and then if you want to embed lean structures (preferrably in teh <code>Type</code> univserse) then you can have a <code>QuotedEncodable</code> typeclass that you get an instance of using `driving QuotedEncodable</p>",
        "id": 562384733,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1765167417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/562345818\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/stream/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/562296780\">said</a>:</p>\n<blockquote>\n<p>Won't we want to specify that algo and query model over any type with a comparison op?</p>\n</blockquote>\n<p>You indeed want to generalize to any type, but you don't want to include the comparison operation in the signature of the algorithm; the whole point is to force the algorithm to make a query to obtain it</p>\n</blockquote>\n<p>So this targets something different than 'let's verify the time complexity in something that looks like annotated Lean code', instead aiming at 'offering a hard-to-get-wrong-by-AST-trickery approach to algorithm specification' through the 'usual' Free Monad interpretation trick. Correct?</p>",
        "id": 562545692,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1765222940
    },
    {
        "content": "<p>It’s a more systematic approach to <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> monad</p>",
        "id": 562545852,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765223005
    },
    {
        "content": "<p>It makes the basic operations and their meaning conceptually separated from the complexity counting.</p>",
        "id": 562545916,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765223032
    },
    {
        "content": "<p>that's pretty clear (and gives also the parametric complexity model advantage). I'm trying to pinpoint the cons.</p>",
        "id": 562546016,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1765223071
    },
    {
        "content": "<p>It allows us to explicitly relate different models in different ways. By mapping basic operations in one query to another, we can get a free translation of algorithms into different models</p>",
        "id": 562546068,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765223094
    },
    {
        "content": "<p>The main difference between my approach and tanners is that he uses the free monad (essentially the first two constructors in the code sample I pasted above)</p>",
        "id": 562546269,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765223172
    },
    {
        "content": "<p>But he goes further and compiles to the time monad</p>",
        "id": 562546301,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765223187
    },
    {
        "content": "<p>And provides the interpretation function for evaluation</p>",
        "id": 562546322,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765223196
    },
    {
        "content": "<p>The rest of the combinators come from Lean’s monadic constructions</p>",
        "id": 562546383,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765223225
    },
    {
        "content": "<p>Now I am trying to parametrise the query type.</p>",
        "id": 562546672,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765223343
    },
    {
        "content": "<p>The advantage of a simple TimeMonad is the flexibility.  In TCS papers, it is rare for mistracking time to be the correctness concern, since most algorithms in theory papers are easy to track. The main advantage is the flexibility in expressing algorithms and running time across many models. </p>\n<p>Let's say we want to analyze graph algorithms. In TCS papers, they usually write graph algorithms in set-theoretic notation rather than raw code (e.g., as in a programming contest), where the underlying implementation is typically straightforward.    More concretely, let's consider the <a href=\"https://github.com/sorrachai/FAA2025/blob/main/Lectures/Week09/Sheet2'.lean\">BFS algorithm</a>. I can express it easily using Mathlib's graph library. But hold on, Mathlib objects do not support time complexity.  TimeMonad allows us to tick it and analyze based on the time.  </p>\n<p>Simplicity and flexibility are assets here. On the other hand, if it requires too much effort just to state the algorithms, I would not want to use it. Of course, making time-complexity models rigorous and easy to use is a massive project by itself.  This is my personal view. Of course, some people may view it differently depending on their preferences. Still, I believe that time-ticking misalignment can be easily corrected, whereas inconvenience may be too burdensome for users.</p>\n<p>Let's not worry about one another's approach; I would say let's do it any way you like. At some point, time will tell which approach people want to use.</p>",
        "id": 562558880,
        "sender_full_name": "Sorrachai Yingchareonthawornchai",
        "timestamp": 1765228282
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"759386\">@Sorrachai Yingchareonthawornchai</span>  I agree with you that we want simplicity</p>",
        "id": 562559208,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765228439
    },
    {
        "content": "<p>I have also lobbied hard for two years to do complexity formalisation at a high level of abstraction</p>",
        "id": 562559298,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765228472
    },
    {
        "content": "<p>But flexibility comes at a huge cost</p>",
        "id": 562559311,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765228477
    },
    {
        "content": "<p>If I annotate every algorithm individually as I please, then not only is there room for mistakes, there is also complete loss of information about whether we are even talking about the same (custom/standard) model or not</p>",
        "id": 562559396,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765228513
    },
    {
        "content": "<p>For example, if you want to have two subtly distinct cut queries or matrix multiplication queries, you can't even distinguish them</p>",
        "id": 562559447,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765228538
    },
    {
        "content": "<p>Let alone formalise their relationship</p>",
        "id": 562559461,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765228546
    },
    {
        "content": "<p>The reason you go for modularity and composability (topics of decades of PL research) is precisely to avoid mistakes of scale, separate reduction orthogonal concerns, avoid mixing up abstractions, and avoiding mistakes</p>",
        "id": 562559553,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765228577
    },
    {
        "content": "<p>I should know. I wrote the  bits about scalability issues for the  equational theories paper where I was maintainer (the preprint should ideally be up tomorrow night)</p>",
        "id": 562559638,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765228601
    },
    {
        "content": "<p>Let's not worry about one another's approach; I would say let's do it any way you like. Less talking, more doing.</p>",
        "id": 562560031,
        "sender_full_name": "Sorrachai Yingchareonthawornchai",
        "timestamp": 1765228705
    },
    {
        "content": "<p>I respectfully disagree. Pushing a flawed approach has costs. Coding just for the sake of just getting \"something\" done is something we teach undergrads not to do.</p>",
        "id": 562560093,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765228734
    },
    {
        "content": "<p>The free monad approach of Tanner actually builds on top of your time monad approach. <br>\nThe query monad compiles to the time monad, but essentially annotates ticks compositionally. It would be nice to combine them and merge the combined PR after it is ready. </p>\n<p>Also this still means as <span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>  agreed (see : <a class=\"message-link\" href=\"/#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560579044\">#CSLib &gt; Proposal on Time Complexity @ 💬</a> about docstrings and a further reference here in the second paragraph that's a single line : <a class=\"message-link\" href=\"/#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/560652600\">#CSLib &gt; Proposal on Time Complexity @ 💬</a>  ), the module docstring of the mergesort example should note the risks of manual annotation. I have also pointed this out in review comments (for e.g. <a href=\"https://github.com/leanprover/cslib/pull/165#discussion_r2572608503\">here</a>, <a href=\"https://github.com/leanprover/cslib/pull/165/files/041e48cbc9ec2d51476593073019a53afa9e6de3#r2572678916\">here</a>, <a href=\"https://github.com/leanprover/cslib/pull/165/files/041e48cbc9ec2d51476593073019a53afa9e6de3#r2577742108\">here</a> ,and <a href=\"https://github.com/leanprover/cslib/pull/165#issuecomment-3628877894\">here</a>) which have gone unaddressed completely so far.</p>",
        "id": 562560259,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765228801
    },
    {
        "content": "<p>I am currently neatly parametrizing his approach with a generic query type and filling in the monad instances. This will take a few days (given availability of time outside work hours). But wit this, we will have a clean definition of models and relationships between them, as well as no need to manually annotate ticks. I think the wait is worth it.</p>",
        "id": 562561103,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765229180
    },
    {
        "content": "<p>There is no real harm in accepting multiple proposals. It is healthy to have many options to choose from, depending on the context. While there may be many proposals at the start, it is too premature to rule out good ones before they have a chance to grow. If someone believes in their design, we should let them shine and do their thing. In the end, good design will stand the test of time.</p>",
        "id": 562564187,
        "sender_full_name": "Sorrachai Yingchareonthawornchai",
        "timestamp": 1765230494
    },
    {
        "content": "<p>I don't think mathlib followed that approach. That's actually more akin to Isabelle's approach and the result is a heavily fragmented library, where you have to carefully choose which definitions you pick and avoid for the same concept.</p>",
        "id": 562564315,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765230552
    },
    {
        "content": "<p>It is critical to get good definitions into a large library from the beginning in formalisation and keep it coherent.</p>",
        "id": 562564397,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765230586
    },
    {
        "content": "<p>and stick to one (iteratively improved) definition where possible to avoid fragmentation.</p>",
        "id": 562564423,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765230599
    },
    {
        "content": "<p>Also if we are pursuing an each-to-their-own approach, then what even is the point of a cslib</p>",
        "id": 562564724,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765230748
    },
    {
        "content": "<p>I urge some patience in merging this PR (<a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a>) , especially since there is a possibility (<a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a> still WIP) of systematising its approach.</p>",
        "id": 562564883,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765230836
    },
    {
        "content": "<p>Another issue is, the approach that will “win”  will likely be the one that is easy in the short term and very suboptimal in the long run, but then it will be a much bigger headache to fix. So there is very real harm.</p>",
        "id": 562565355,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765231038
    },
    {
        "content": "<p>Can you edit \"This PR\" to reference the PR in question?</p>",
        "id": 562574284,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1765235648
    },
    {
        "content": "<p>sure. Also linked all referenced messages and github comments.</p>",
        "id": 562574513,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765235822
    },
    {
        "content": "<p>Can you list the proposals in a bulleted list? I'm still confused, especially since <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a> doesn't mention \"tick monad\" anywhere but the code definitely uses ticks. Which PR is which proposal? Is one of them awaiting a refactor?</p>",
        "id": 562582373,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1765241596
    },
    {
        "content": "<p>It’s called TimeM.</p>",
        "id": 562582428,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765241645
    },
    {
        "content": "<p>To write code in it you explicity (and arbitrarily) pick operations you want to count in the middle of the algorithms definition.</p>",
        "id": 562582486,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765241703
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 562582544,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765241756
    },
    {
        "content": "<p>That’s <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a></p>",
        "id": 562582602,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765241817
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"677310\">@Tanner Duve</span> proposed a FreeM based abstraction for a specific query model. It has some flaws that Eric pointed out but in principle it can represent algorithms as calls to queries from a query type.</p>",
        "id": 562582706,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765241905
    },
    {
        "content": "<p>Then a translation function translates into the TimeM monad with automated annotation of ticks where queries are counted.</p>",
        "id": 562582756,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765241962
    },
    {
        "content": "<p>And an evaluation function computes the function that the algorithm represents. At least that’s the idea. It is still a big WIP in <a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a></p>",
        "id": 562582800,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765242006
    },
    {
        "content": "<p>I think you can find these PRs mentioned in the last big message I sent. <a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a> is decidedly not ready for review. There is still some work to be done. But once it is complete we can get a clean definition of a sorting model and a merge sort algorithm in it. In principle (and unlike <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a>) we can also get the comparison sort lower bound.</p>",
        "id": 562582973,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765242131
    },
    {
        "content": "<p>And much of this thread is me arguing that fixing a unified and good definition is important for a useful and coherent and correct  library that is relatively easy to add content to.</p>",
        "id": 562583020,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765242163
    },
    {
        "content": "<p>I still need answers on whether my observations are correct. To help the discussion as far as supporting different approaches in CSLib goes, here are questions I need clear answers for:</p>\n<ol>\n<li>In <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a>, when writing a TimeM def: say I call another TimeM def. Is it easy enough to remember that I should include its time complexity in that of the invoking def? It seems so. What requires care seems to be ticking calls to untimed stuff. Correct?</li>\n<li>Can I still mess up in <a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a> by calling something and wrapping it into a pure or something like that?</li>\n<li>Is it fair to say that <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a> supports writing pretty idiomatic and arbitrary Lean code, whereas <a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a> requires changing the way one works a bit? (This wouldn't make me be against <a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a>, I'm aware of its advantages; it's the cons that I wanna understand well before considering merging it once it's cooked enough.)</li>\n</ol>",
        "id": 562691785,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1765288865
    },
    {
        "content": "<p>Satisfactory answers that would motivate supporting both approaches could be in the space 'yes, easy enough', 'yes, I can still mess up'/'no, I can't', 'fair enough'. ;-)</p>",
        "id": 562692308,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1765288980
    },
    {
        "content": "<p>I think it's very important to understand this clearly because we need to equip the two approaches with appropriate docstrings/docs that document their pros and cons (things to be careful with).</p>",
        "id": 562692448,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1765289022
    },
    {
        "content": "<ol start=\"3\">\n<li><a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a> also supports writing idiomatic code. It is just a different monad.</li>\n</ol>",
        "id": 562692751,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765289100
    },
    {
        "content": "<ol start=\"2\">\n<li>In <a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a> I am still modifying the approach a bit, but the goal is to not be able to sneak in pure code. I can confirm this when I have nailed down the design completely. But even now, I would say it helps us clearly identify dangerous queries (as Eric did when discussing alternative ways to write the sorting example in DM)</li>\n</ol>",
        "id": 562693291,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765289226
    },
    {
        "content": "<ol>\n<li>“Easy enough” is subjective. Both authors and reviewers must be careful to vet everything for <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a>. <a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a> forces you to be more explicit about your basic operations and cost functions. I also dislike that I can’t clearly distinguish subtle model differences easily in <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a>.</li>\n</ol>",
        "id": 562693565,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765289286
    },
    {
        "content": "<ol start=\"3\">\n<li>We gotta define/use a query model and invoke operations therein instead of using whatever def/typeclass/etc. in Lean. So it looks different in that sense to me. Correct?</li>\n</ol>",
        "id": 562697610,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1765290211
    },
    {
        "content": "<ol start=\"2\">\n<li>Fair enough. And the approach would still be interesting anyway.</li>\n</ol>",
        "id": 562697886,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1765290272
    },
    {
        "content": "<ol>\n<li>If I invoke mergeSort from another timed def (with TimeM), can I just 'forget' to tick the invocation? Or is the 'default' that it counts as ticked? I think here we could actually devise quite a few mechanisms to identify this kind of occurrences.</li>\n</ol>",
        "id": 562698276,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1765290350
    },
    {
        "content": "<ol>\n<li>It’s one thing to identify mistakes in the <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a> using some heuristic metaprogram. It’s another thing to formally define the property of “correctly annotated” programs which is actually impossible. So how does one get compositionally correct complexity results?</li>\n</ol>",
        "id": 562702721,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765291370
    },
    {
        "content": "<p>For what it is worth, I don't see these approaches as entirely separate. <a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a> builds a way of using <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a>'s TimeM monad in a systematic manner.</p>",
        "id": 562714952,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765293845
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/562697610\">said</a>:</p>\n<blockquote>\n<ol start=\"3\">\n<li>We gotta define/use a query model and invoke operations therein instead of using whatever def/typeclass/etc. in Lean. So it looks different in that sense to me. Correct?</li>\n</ol>\n</blockquote>\n<p>The model is already conceptually out there. We assume it implicitly when we decide to use certain procedures without caring about their implementations and count the complexity of calls to them (with their inputs). With <a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a> I want formalisers to make it explicit and abstract the implementation away.</p>",
        "id": 562730905,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765297019
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/562698276\">said</a>:</p>\n<blockquote>\n<ol>\n<li>If I invoke mergeSort from another timed def (with TimeM), can I just 'forget' to tick the invocation?</li>\n</ol>\n</blockquote>\n<p>You could do something like <code>pure (TimeM.run mergeSort).result</code> to cheat and discard the tick count</p>",
        "id": 562838965,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1765330932
    },
    {
        "content": "<p>Thanks, that matches my understanding! I think I know enough to know what to ask for in the docstrings of <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a> (will work on that), and it looks like an approach worth keeping.<br>\nI look forward to further developments of <a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a> as well.</p>",
        "id": 562932872,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1765366365
    },
    {
        "content": "<p>I do think the that <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a> must explicitly  record in docstrings that it is an unsafe and risky  approach and that contributors are to be encouraged to build on more safe abstractions. That is why I recommend waiting a bit for <a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a> (I am only asking for a week roughly).</p>",
        "id": 563074880,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765406976
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 563145659,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1765447430
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a> got quite a few changes recently and looks ready to me now. I'll be interested in future developments of both that and <a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a> (as well as new approaches).<br>\nI might have a few ideas for improvements to both <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a> (safety) and <a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a> (ergonomics), but these can happen at a later stage.</p>",
        "id": 563449404,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1765538062
    },
    {
        "content": "<p>This topic was mentioned here: <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/Converting.20Lean.2EExpr.20to.20untyped.20lambda.20calculus/with/565414847\">#Is there code for X? &gt; Converting Lean.Expr to untyped lambda calculus</a> <br>\n<span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> You mention that's it's possible to relate query model to computational model like TM. Can you elaborator on how this can be done? What I would like to have, is to at the end build one Turing Machine for all possible inputs, and be able to prove stuff about it's time complexity (i.e. a function <code>input -&gt; Nat</code>). Tbh, the first thing I don't understand is how do we ensure with TimeM monad that it's not possible to e.g. arbitrarily access tape/stacks? And the second, how can I have a time that depends on the input, while still ensuring that the turing machine doesn't depend on the input?</p>",
        "id": 565423024,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766739234
    },
    {
        "content": "<p>Good question. But it’s WIP and I’ll respond when I am finished which is after the holidays.</p>\n<ol>\n<li>You can interpret queries over a suitable data  structure</li>\n<li>TimeM in itself won’t stop you from accessing the TM’s internals</li>\n</ol>",
        "id": 565436841,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766750421
    }
]