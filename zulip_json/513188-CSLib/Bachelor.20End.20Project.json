[
    {
        "content": "<p>Hello everyone,<br>\nWe are <span class=\"user-mention\" data-user-id=\"1020043\">@Marian Luca</span> , <span class=\"user-mention\" data-user-id=\"1021679\">@Jēkabs Gritāns</span> , <span class=\"user-mention\" data-user-id=\"1018238\">@Momchil  Damianov</span>  and <span class=\"user-mention\" data-user-id=\"1010895\">@Daan Deckers</span> , and we are bachelor students doing our bachelor end project on CSlib under guidance of <span class=\"user-mention\" data-user-id=\"563058\">@Pieter Cuijpers</span> . We hope to make meaningful contributions to CSlib and we look forward to working with you all! Are there some areas/disciplines of CS that you recommend we contribute to?</p>",
        "id": 571200292,
        "sender_full_name": "Daan Deckers",
        "timestamp": 1769869499
    },
    {
        "content": "<p>What are you interested in? What have you learnt recently? What experience do you have with Lean/Cslib? You have to help us out here. :-)</p>",
        "id": 571262733,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1769928435
    },
    {
        "content": "<p>The theoretical CS course which we've all taken followed chapters 1-4 of Sipser's book (regular languages, context-free languages, Turing machines, decidability).</p>\n<p>Personally, I'm most comfortable with regular languages / finite automata, as they've appeared in other courses, and in a research project I did on recurrent neural networks. So I feel like contributing to \"Cslib/Computability/\" would have the highest chances of success. But I am of course open to other topics :)</p>\n<p>Personally, I have zero experience with lean/mathlib/cslib, but we did have to do basic analysis problems in Waterproof (which is a natural language wrapper on top of COQ). I'm also currently reading \"Theorem Proving in Lean 4\" and \"Functional Programming in Lean\" and trying to learn the basics of type theory.</p>",
        "id": 571286501,
        "sender_full_name": "Jēkabs Gritāns",
        "timestamp": 1769952125
    },
    {
        "content": "<p>Based on your advisor’s interests and your desire to contribute to CSLib, maybe linear recurrence sequences are your thing? Linear recurrences are the discrete counterparts of linear differential equations (which are central to control theory and cyberphysical systems). But they also show up in combinatorics a lot. There are open CS problems about them such as Skolems problem. </p>\n<p>The theory gets fairly abstract and connects to abstract algebra as well as number theory,  so maybe mathlib people will also be interested.</p>",
        "id": 571290486,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769955760
    },
    {
        "content": "<p>This would be a substantial amount of work and could proceed independently of other parts of CSLib for a few months.</p>",
        "id": 571290711,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769955984
    },
    {
        "content": "<p>By Skolems problem, I mean the problem of asking if there can exist an algorithm to decide whether an LRS of order 5 or higher has a zero (and by extension a number of other properties) or not.</p>",
        "id": 571290884,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769956140
    },
    {
        "content": "<p>And if there is enough material in your library, you could maybe post this problem as a conjecture to deepmind’s formal conjectures repository</p>",
        "id": 571290954,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769956206
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1021679\">Jēkabs Gritāns</span> <a href=\"#narrow/channel/513188-CSLib/topic/Bachelor.20End.20Project/near/571286501\">said</a>:</p>\n<blockquote>\n<p>Personally, I'm most comfortable with regular languages / finite automata, as they've appeared in other courses, and in a research project I did on recurrent neural networks. So I feel like contributing to \"Cslib/Computability/\" would have the highest chances of success. But I am of course open to other topics :)</p>\n</blockquote>\n<p>Quite a bit of automata theory, over both finite words and infinite words, already exists in cslib.  In particular, the closure results of regular languages under boolean operations, concatenation, and Kleene star are in cslib:<br>\n<a href=\"https://github.com/leanprover/cslib/blob/main/Cslib/Computability/Languages/RegularLanguage.lean\">https://github.com/leanprover/cslib/blob/main/Cslib/Computability/Languages/RegularLanguage.lean</a><br>\nOne missing piece that no one (as far as I know) is working on is the connection between regular expressions (RE) and regular languages.  The definition of RE exists in mathlib but is not connected to regular languages.  (Mathlib did not have the closure results for boolean operations until recently and the closures under concatenation and Kleene star are still missing.). So the connection between RE and RL could be a project idea.</p>",
        "id": 571318280,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769982395
    },
    {
        "content": "<p>There are additional properties to be proven of the System F formalization that don't require too many additional definitions. (I can go into more detail if this is an area of interest)</p>",
        "id": 571319148,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769983368
    },
    {
        "content": "<p>Formalizing Brzozowski's algorithm for computing the minimal DFA of a regular language is yet another project idea:<br>\n<a href=\"https://en.wikipedia.org/wiki/DFA_minimization#Brzozowski's_algorithm\">https://en.wikipedia.org/wiki/DFA_minimization#Brzozowski's_algorithm</a></p>",
        "id": 571340614,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1770003478
    },
    {
        "content": "<p>Hi! Jumping in here as I'm also a bachelor student looking for a project.</p>\n<p>I'm interested in writing a type checker for <code>Stlc</code> and proving soundness and completeness. <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> Would you encourage this, or would you recommend looking into the System F properties instead? I'd be happy to hear the details.</p>",
        "id": 571344703,
        "sender_full_name": "Maximiliano Onofre Martínez",
        "timestamp": 1770006244
    },
    {
        "content": "<p>Do you have a particular kind of typechecker and reference(s) in mind?</p>\n<p>For System F, I was thinking of properties like confluence, strong normalization, and parametricity. For simplicity, you could strip the existing <code>Fsub</code> of extensions down to just ordinary System F or Fω.</p>",
        "id": 571351048,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770011086
    },
    {
        "content": "<p>Pierce's TAPL is my main reference for the idea, but find your suggestion about System F very interesting, thanks! I will definitely take a look.</p>",
        "id": 571397968,
        "sender_full_name": "Maximiliano Onofre Martínez",
        "timestamp": 1770028938
    },
    {
        "content": "<p>I think it's not unreasonable to look at the metatheory of a type checker, but you would need some references beyond TAPL and might find more subtlety then you expect.</p>\n<p>For System F, I'll point out a couple of Rocq formalizations you might find helpful as references:</p>\n<ul>\n<li><a href=\"https://github.com/yiyunliu/system-f-omega\">https://github.com/yiyunliu/system-f-omega</a></li>\n<li><a href=\"https://github.com/Lysxia/system-F\">https://github.com/Lysxia/system-F</a></li>\n</ul>",
        "id": 571401262,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770029749
    },
    {
        "content": "<p>Thanks for the links. Your <a href=\"https://chrishenson.net/posts/2025-05-10-formalized_lambda_calculus.html\">blog post</a> was also a great read. I hope to have some updates soon!</p>",
        "id": 571408934,
        "sender_full_name": "Maximiliano Onofre Martínez",
        "timestamp": 1770032062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Bachelor.20End.20Project/near/571290711\">said</a>:</p>\n<blockquote>\n<p>This would be a substantial amount of work and could proceed independently of other parts of CSLib for a few months.</p>\n</blockquote>\n<p>Are there any resources you would recommend to get started with? I tried looking through CSLib &amp; Mathlib on GitHub to hopefully find some issues (regardless of their state) that would give me some idea of what is currently implemented/being developed with respect to LRSs, but I couldn't find anything at all mentioning them.</p>",
        "id": 572624093,
        "sender_full_name": "Momchil  Damianov",
        "timestamp": 1770560230
    },
    {
        "content": "<p>There’s nothing at all right now. This is one of the topics where a few different formalisation projects will be necessary before we know what works and what doesn’t.</p>",
        "id": 572628332,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770563910
    },
    {
        "content": "<p>And that’s another thing. I suggest building a formalisation independently first without the extra pressure of mathlib or CSLib readiness. Formalisation  is hard enough when building new definitions are involved.</p>",
        "id": 572628473,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770564029
    },
    {
        "content": "<p>Okay, thank you for clearing things up!</p>",
        "id": 572630378,
        "sender_full_name": "Momchil  Damianov",
        "timestamp": 1770565868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Bachelor.20End.20Project/near/572628473\">said</a>:</p>\n<blockquote>\n<p>And that’s another thing. I suggest building a formalisation independently first without the extra pressure of mathlib or CSLib readiness. Formalisation  is hard enough when building new definitions are involved.</p>\n</blockquote>\n<p>That's a fair point. But how do we go about that in such a way that different people can voice their opinions? First make an entire proof and then put that up for review or comments here? (It would be nice to know from the start there are people interested in reviewing.)</p>",
        "id": 572978267,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1770713643
    },
    {
        "content": "<p>That’s hard to say. Usually people here voluntarily help when they can. But they might also not have time. The reason I am suggesting not to aim for CSLib on day 1 is precisely because the project will very quickly get stalled or steered by reviewers and eliminate the independent input of the students</p>",
        "id": 572995007,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770718280
    },
    {
        "content": "<p>And ideally more experimentation in the design can be accomplished without CSLib review and more of the students’ ideas can be attempted without being overruled by us in the community</p>",
        "id": 572995329,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770718361
    },
    {
        "content": "<p>Since you are in Netherlands, it might be simpler to get a second supervisor or even a third one rather than relying on the community to review an ongoing project.</p>",
        "id": 572995571,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770718426
    },
    {
        "content": "<p>We might not even understand the goals and constraints  of the thesis here</p>",
        "id": 572995656,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770718452
    },
    {
        "content": "<p>Finally once the students are done they  can always submit to CPP later this year and get peer reviewed.</p>",
        "id": 572995892,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770718516
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"563058\">@Pieter Cuijpers</span> I think that some of the above is a bit extreme, but I agree with some broad points.</p>\n<p>Anyone is welcome to make an draft PR to solicit early feedback. How practical it is to move from this point to merged PR is going to depend a lot on the level of experience of the student and if the material they chose easily finds a reviewer.</p>\n<p>The areas above I suggested for lambda calculus for instance I would be very happy to review. In an area like this where I'm very comfortable with the material and formalization, I am happy to spend some extra time helping clean things up for a PR. Other areas like linear recurrences mentioned above would require some extra effort on my part but are still possible. I would say this all should be considered on a case by case basis.</p>\n<p>The official maintainer team is very small at this point. Fabrizio and myself (a PhD student) are reviewing each PR at this point, with additional input from trusted contributors and a couple of Mathlib maintainers. This will expand in the future, but just to give some immediate context.</p>",
        "id": 573005282,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770721116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"563058\">Pieter Cuijpers</span> <a href=\"#narrow/channel/513188-CSLib/topic/Bachelor.20End.20Project/near/572978267\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Bachelor.20End.20Project/near/572628473\">said</a>:</p>\n<blockquote>\n<p>And that’s another thing. I suggest building a formalisation independently first without the extra pressure of mathlib or CSLib readiness. Formalisation  is hard enough when building new definitions are involved.</p>\n</blockquote>\n<p>That's a fair point. But how do we go about that in such a way that different people can voice their opinions? First make an entire proof and then put that up for review or comments here? (It would be nice to know from the start there are people interested in reviewing.)</p>\n</blockquote>\n<p>One thing you could do is invite people to your GitHub repository to review from time to time or just post here. Depending on availability we might very well be happy to give it a pass.</p>",
        "id": 573014778,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770723761
    },
    {
        "content": "<p>Yeah, I think we are converging on the same policy as Mathlib that anyone is welcome to leave reviews. Some frequent contributors who aren't officially maintainers have started to do so naturally.</p>",
        "id": 573015143,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770723876
    },
    {
        "content": "<p>Fwiw, I should probably tell you that this is a topic (LRS)  I have been suggesting for a while. So I can’t guarantee that nobody else has taken it up. There is a reasonable chance that I might attempt an independent formalisation of LRSes around April or May. I can see value in multiple formalisation attempts since they can inform what we put in CSlib and we might find that different styles of formalisation prove useful for different goals.</p>",
        "id": 573015677,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770724043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Bachelor.20End.20Project/near/572628332\">said</a>:</p>\n<blockquote>\n<p>There’s nothing at all right now. This is one of the topics where a few different formalisation projects will be necessary before we know what works and what doesn’t.</p>\n</blockquote>\n<p>I just came across a definition for a \"Linear Recurrence\" that already exists within Mathlib's Algebra module (Mathlib/Algebra/LinearRecurrence.lean). Is that a different structure from what you are referring to?</p>",
        "id": 573468439,
        "sender_full_name": "Momchil  Damianov",
        "timestamp": 1770887478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/513188-CSLib/topic/Bachelor.20End.20Project/near/571351048\">said</a>:</p>\n<blockquote>\n<p>Do you have a particular kind of typechecker and reference(s) in mind?</p>\n<p>For System F, I was thinking of properties like confluence, strong normalization, and parametricity. For simplicity, you could strip the existing <code>Fsub</code> of extensions down to just ordinary System F or Fω.</p>\n</blockquote>\n<p>I would be interested in the suggestions regarding formalizing confluence, strong normalization, and parametricity for System F, if they are still available, <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> , since it seems that <span class=\"user-mention\" data-user-id=\"816479\">@Maximiliano Onofre Martínez</span> is also interested in it. Do you think it would be better to find something else, so that there wouldn't be multiple people working on the same thing?</p>\n<p>The suggestion of <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> about Brzozowski's algorithm seems very interesting as well. Correct me if I am wrong, but it seems Hopcroft's algorithm also isn't formalized.</p>",
        "id": 573487758,
        "sender_full_name": "Marian Luca",
        "timestamp": 1770893208
    },
    {
        "content": "<p>I don't know the scope required for your project, but you can certainly split the work among you for the System F suggestions. What I mentioned are pretty separate things to formalize.</p>",
        "id": 573489749,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770893778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1018238\">Momchil  Damianov</span> <a href=\"#narrow/channel/513188-CSLib/topic/Bachelor.20End.20Project/near/573468439\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Bachelor.20End.20Project/near/572628332\">said</a>:</p>\n<blockquote>\n<p>There’s nothing at all right now. This is one of the topics where a few different formalisation projects will be necessary before we know what works and what doesn’t.</p>\n</blockquote>\n<p>I just came across a definition for a \"Linear Recurrence\" that already exists within Mathlib's Algebra module (Mathlib/Algebra/LinearRecurrence.lean). Is that a different structure from what you are referring to?</p>\n</blockquote>\n<p>It’s a good starting point, but as you can see the file is quite basic. So there’s a lot of work to do to build it up into something usable.</p>",
        "id": 573492513,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770894554
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1020043\">Marian Luca</span> <a href=\"#narrow/channel/513188-CSLib/topic/Bachelor.20End.20Project/near/573487758\">said</a>:</p>\n<blockquote>\n<p>The suggestion of <span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> about Brzozowski's algorithm seems very interesting as well. Correct me if I am wrong, but it seems Hopcroft's algorithm also isn't formalized.</p>\n</blockquote>\n<p>Not sure what you mean by \"Hopcroft's algorithm\".  If you mean this:<br>\n<a href=\"https://en.wikipedia.org/wiki/Thompson%27s_construction\">https://en.wikipedia.org/wiki/Thompson%27s_construction</a><br>\nthen you are correct: it has not been formalized.  Currently in cslib, the closures of regular languages under boolean operations are proved using DA and the closures under concatenation and Kleene star are proved using NA (in fact, as special cases of the corresponding constructions for ω-regular languages).  There has been almost no development in EpsilonNA, where the only nontrivial theorem proved is that an εNA can be converted to an NA.</p>",
        "id": 573580261,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1770917184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/Bachelor.20End.20Project/near/573580261\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"1020043\">Marian Luca</span> <a href=\"#narrow/channel/513188-CSLib/topic/Bachelor.20End.20Project/near/573487758\">said</a>:</p>\n<blockquote>\n<p>The suggestion of <span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> about Brzozowski's algorithm seems very interesting as well. Correct me if I am wrong, but it seems Hopcroft's algorithm also isn't formalized.</p>\n</blockquote>\n<p>Not sure what you mean by \"Hopcroft's algorithm\".  If you mean this:<br>\n</p>\n</blockquote>\n<p>I was referring to this:<br>\n<a href=\"https://en.wikipedia.org/wiki/DFA_minimization#Hopcroft's_algorithm\">https://en.wikipedia.org/wiki/DFA_minimization#Hopcroft's_algorithm</a><br>\nThis is actually the algorithm for DFA minimization I learned during my Automata &amp; Formal Languages course, as well as what I came across in some compiler construction books.</p>",
        "id": 573589503,
        "sender_full_name": "Marian Luca",
        "timestamp": 1770919974
    },
    {
        "content": "<p>It's not formalized.  There is no result about DFA minimization in cslib or (as far as I know) in mathlib.  There is a \"Myhill-Nerode theorem\" in mathlib:<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/MyhillNerode.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/MyhillNerode.html</a><br>\nBut its connection to the minimal DFA:<br>\n<a href=\"https://en.wikipedia.org/wiki/Myhill%E2%80%93Nerode_theorem\">https://en.wikipedia.org/wiki/Myhill%E2%80%93Nerode_theorem</a><br>\nis not shown.  The notion of \"right congruence\" is defined in PR <a href=\"https://github.com/leanprover/cslib/pull/278\">cslib#278</a> which should be merged soon (hopefully).</p>",
        "id": 573593989,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1770921562
    },
    {
        "content": "<p>I see, thanks a lot for your help!</p>",
        "id": 573595745,
        "sender_full_name": "Marian Luca",
        "timestamp": 1770922129
    }
]