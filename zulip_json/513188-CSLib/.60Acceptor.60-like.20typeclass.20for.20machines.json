[
    {
        "content": "<p>There are a number of  \"Machine\" types that I am seeing either in PRs like <a href=\"https://github.com/leanprover/cslib/pull/269\">cslib#269</a> or <a href=\"https://github.com/leanprover/cslib/pull/299\">cslib#299</a>, or in proposed PRs like <a href=\"https://github.com/crei/cslib/pull/1\">this</a> one / just in my own ideas for other concepts I'd like to eventually formalize.</p>\n<p>I am thinking that all of these have the following structure</p>\n<ul>\n<li>A class of objects that broadly represent classes of computable (or perhaps partial) functions, with individual functions implemented by individual machines within the class.<ul>\n<li>So the typeclass would probably be structured as <code>[Machine X inputType outputType]</code></li>\n</ul>\n</li>\n<li>A machine can have \"configurations\" which correspond to states of input feed, external tapes and stacks, and internal state.<ul>\n<li>So there is a type <code>Machine.Cfg</code>, </li>\n</ul>\n</li>\n<li>To compute the function, there is a map from terms of the input type to configurations<ul>\n<li>a function <code>initCfg : inputType -&gt; Cfg</code>, maybe also a function <code>finalCfg : Cfg -&gt; Option (outputType)</code></li>\n</ul>\n</li>\n<li>There is then a transition function which maps configurations to other configurations, until eventually there is a final configuration which maps to a return type (I have thought it might be better to have the state transitions return a sum type rather than an option to represent this).<ul>\n<li>So there is a function <code>step : Cfg -&gt; Option Cfg</code> or <code>step : Cfg -&gt; Cfg oplus outputType</code></li>\n<li>We can then define a computed function <code>inputType -&gt; Part outputType</code></li>\n</ul>\n</li>\n<li>Perhaps there is a time function that tracks time in terms of number of steps, or in some other way.</li>\n</ul>\n<p>I am thinking we could make a typeclass for this (perhaps after the above mentioned PRs are merged). Does this seem like a good idea? Are there any existing plans for something like this? We currently have <code>Acceptor</code> as a typeclass for automata, but this only permits binary return values and complete functions. Perhaps this could be subclassed or superclassed in some way?</p>",
        "id": 573928750,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1771105798
    },
    {
        "content": "<p>Check out <code>Automata/Acceptors/Transducer.lean</code> in <a href=\"https://github.com/leanprover/cslib/pull/289\">cslib#289</a>. It's a typeclass for functions that take strings as input and accumulate output via multiplication onto some <code>Weight</code>. It's meant to model weighted automata and finite-state transducers. It's a bit more specific than what you've proposed, and doesn't have some of the bells and whistles, but it seems related.</p>\n<p>I am planning to request a merge once I finish formalizing the algebraic characterization of subsequential transductions, though progrss has been slow admittedly because I am busy with classes right now <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span>.</p>",
        "id": 573931104,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1771109047
    },
    {
        "content": "<p>Nice, thanks!</p>",
        "id": 573931229,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1771109205
    },
    {
        "content": "<p>Generally speaking, I think your proposal of a class that is more general than both <code>Acceptor</code> and <code>Transducer</code> is a good idea :)</p>",
        "id": 573931244,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1771109215
    },
    {
        "content": "<p>Good discussion! I'd like to reach a hierarchy eventually. I've been thinking about this when I wrote Acceptor (and before, some automata), but 'machine' is a very broadly-used term. For example, there are machines whose purpose is not to model computation but behaviour, like communicating finite-state machines.</p>\n<p>There is certainly a notion of 'machine for computing a function' -- function(Al) machine? -- which should be usable as (convertible to) a (partial) function.</p>",
        "id": 573961757,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1771145745
    },
    {
        "content": "<p>I like this idea! My one suggestion is that we could go more general still, to something like \"model of computation\" ‚Äî the main difference being allowing non-deterministic computations (I'm of course thinking about SKI &amp; lambda calculus). Then you can compile to a partial function given a reduction strategy, which is something like your <code>step : Cfg -&gt; Cfg oplus outputType</code>, but you could still reason about computations without proving any standardisation lemma (\"this reduction strategy computes a normal form, if one exists\").</p>",
        "id": 574121189,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1771251895
    },
    {
        "content": "<p>None of that means you can't have a <code>Machine</code> typeclass of course, but we probably ought to think about how inheritance would work between the two</p>",
        "id": 574121433,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1771251971
    },
    {
        "content": "<p>It seems like if you bundle everything into <code>Cfg</code> your class gets closer to bundling a relation, similar to <code>ReductionSystem</code> which we recently removed. How do you think this interacts with us currently using unbundled relations, for instance <a href=\"https://api.cslib.io/docs/Cslib/Computability/URM/Execution.html#Cslib.URM.isHalted_iff_normal\">Cslib.URM.isHalted_iff_normal</a> and <a href=\"https://api.cslib.io/docs/Cslib/Computability/URM/Execution.html#Cslib.URM.step_confluent\">Cslib.URM.step_confluent</a> which then are able to reuse definitions from <code>Relation</code>. (Similarly you can also reuse <a href=\"https://api.cslib.io/docs/Cslib/Foundations/Data/RelatesInSteps.html#Relation.RelatesInSteps\">Relation.RelatesInSteps</a>)</p>\n<p>Still forming an opinion, just trying to understand if/how things I mentioned at <a href=\"#narrow/channel/513188-CSLib/topic/unbundling.20.60ReductionSystem.60/near/571888430\">#CSLib &gt; unbundling &#96;ReductionSystem&#96; @ üí¨</a> are relevant.</p>",
        "id": 574127213,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771253637
    },
    {
        "content": "<p>Perhaps this does take us closer to bundling a relation again (one thing I liked about that setup was that I was able to write things like <code>tm.ComputesInSteps</code> rather than <code>RelatesWithinSteps tm.TransitionRelation</code> ). I think the main benefits I have in mind are generalizing lemmas that involve both the configuration-evolution relation and the I/O system, such as the lemma in the single-tape-TM PR that says that the output length of a machine is bounded by the sum of the input length and the step count. So if we want to avoid duplication of API between machines and reductions, perhaps we can just try to ensure that lemmas about machines never reference just the relation, and if they do, make them a lemma about relations instead.</p>",
        "id": 574188202,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1771279012
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> can I <span aria-label=\"ping pong\" class=\"emoji emoji-1f3d3\" role=\"img\" title=\"ping pong\">:ping_pong:</span> you about responding to <a href=\"https://github.com/leanprover/cslib/pull/269#pullrequestreview-3731233360\">this</a> comment? chris477 and I would like to start thinking about other kinds of machines and it would be nice to have confirmation on this PR first.</p>",
        "id": 574643899,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1771471879
    },
    {
        "content": "<p>Yes! I'll get there soon, just gotta finish another couple of PR reviews first. :)</p>",
        "id": 574721950,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1771506345
    },
    {
        "content": "<p>I bumped the toolchain just to be sure that isn't a surprise on merging, but everything still looks fine.</p>",
        "id": 574734882,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771509664
    },
    {
        "content": "<p>Very nice work. Left some questions/comments.</p>\n<p>This reinforced my feeling that machines are begging for finding common abstractions, just like we did for automata. :-)</p>",
        "id": 575071319,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1771662980
    },
    {
        "content": "<p>I'd like to also have a good way to talk about the classes FP, TFNP, etc! In many ways function problems are \"more basic\" than languages and have better composability properties generally. Language can then be viewed as function problems to a Boolean. I hope we can find a formulation that reflects this!</p>",
        "id": 575119067,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1771714869
    },
    {
        "content": "<p>Agree about tfnp</p>",
        "id": 575119768,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771715816
    },
    {
        "content": "<p>One of the nice things about tfnp is that there is a problem called ‚Äúwrong proof‚Äù that unifies much of it into a single complete problem,  but not all.</p>",
        "id": 575119811,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771715874
    },
    {
        "content": "<p>But I have thought about the design of a computable typeclass before and I think you just want to use structures instead.</p>",
        "id": 575119823,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771715897
    },
    {
        "content": "<p>Basically there is no ‚Äúcanonical‚Äù computability/machine/automata instance.</p>",
        "id": 575119886,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771715997
    },
    {
        "content": "<p>The specific machine types could just extend this structure</p>",
        "id": 575119927,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771716055
    }
]