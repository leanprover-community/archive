[
    {
        "content": "<p>Although not directly part of CS Lib, I have a result I think people here might be interested in: over at <a href=\"http://github.com/Timeroot/CircuitComp\">CircuitComp</a> I now have a Lean proof that Parity is not in AC0. :) <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> </p>\n<p>I think this is the first nontrivial <em>tractability</em> result proved in Lean; with the noncomputability of the Halting problem as (imo) the otherwise most nontrivial complexity-theory result. (There may be other big ones I don't know about -- but we all know how fully end-to-end complexity theory is really hard to formalize...!)</p>",
        "id": 565949343,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1767238448
    },
    {
        "content": "<p>In particular I went for this because Turing machines (and their complexity classes) are such a pain, but circuit complexity could be a bit more accessible in this regard.</p>",
        "id": 565949373,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1767238472
    },
    {
        "content": "<p>There's still a lot of missing \"helpful\" facts to make working with circuits more reasonable. A few things I'd like to do:</p>\n<ul>\n<li>NCi (and similar classes) are unchanged by adding any finite set of gates</li>\n<li>So it's obvious that NCi is in ACi, but showing that ACi is in NC_{i+1}, and so NC=AC. I already have that NC1 can compute AND, so it's a matter of setting up appropriate \"substitution\" of gates (like the above)</li>\n<li>More stuff about composing/substituting circuits</li>\n</ul>\n<p>Right now the only definition of circuit is a \"layered\" circuit where each layer only talks to the previous one. There's other natural logically equivalent structures, like a list of gates where each can refer to any previous gates (and then depth is the maximum length path, etc.), or a layered circuit with skip connections. It would be good to define these and show the natural equivalences.</p>",
        "id": 565949595,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1767238864
    },
    {
        "content": "<p>This looks really interesting! I think it would be great to get a definition of circuit in CSLib, as this has previously come up with someone who was working on Barrington's theorem, and I see you have some work on NC. I would be happy to review any PRs more closely.</p>",
        "id": 565950766,
        "sender_full_name": "Chris Henson",
        "timestamp": 1767240588
    },
    {
        "content": "<p>This is amazing!<br>\nRegarding the definition, I think it should use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Digraph#doc\">docs#Digraph</a> with a <code>[Finite V]</code> and <code>G.IsAcyclic</code> assumptions, plus <code>V → operation</code> and a proof that degrees match operation arity. If we need non-commutative operations (e.g. arithmetic circuits use exponentiation), maybe add <code>(v : V) → { l // G.neighborFinset.toList.Perm l }</code> or something.<br>\n(this requires a few Mathlib PRs to <a href=\"#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/565949855\">beef up</a> <code>Digraph</code>, adding <code>Digraph.IsAcyclic</code>/<code>Digraph.degree</code>/<code>Digraph.neighborFinset</code> to match the existing <code>SimpleGraph</code> definitions)</p>",
        "id": 565976041,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1767271839
    },
    {
        "content": "<p>Ah this is an interesting way of dealing with circuits.  I have been trying to make them work as an inductive type.</p>",
        "id": 565989382,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767287061
    },
    {
        "content": "<p>This creates a more general definition but comes at the cost of needing binders to allow out nodes with out degree &gt; 1</p>",
        "id": 565989472,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767287231
    },
    {
        "content": "<p>Btw I think it’s just a typo in your message but you probably want to show AC (i) is in NC (i + 1)</p>",
        "id": 565989520,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767287293
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Parity.20is.20not.20in.20AC0/near/565989520\">said</a>:</p>\n<blockquote>\n<p>Btw I think it’s just a typo in your message but you probably want to show AC (i) is in NC (i + 1)</p>\n</blockquote>\n<p>Aha yes, fixed</p>",
        "id": 565989664,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1767287430
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Parity.20is.20not.20in.20AC0/near/565989472\">said</a>:</p>\n<blockquote>\n<p>This creates a more general definition but comes at the cost of needing binders to allow out nodes with out degree &gt; 1</p>\n</blockquote>\n<p>By out degree you mean a node that computes multiple outputs, like <code>divMod</code> returning two numbers?</p>",
        "id": 565989883,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1767287699
    },
    {
        "content": "<p>No. In circuit complexity (both boolean and arithmetic), there is a distinction between circuits and formulas. Formulas are trees. Circuits can be DAGs,  where a node can provide its output to multiple inputs</p>",
        "id": 565990262,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767288152
    },
    {
        "content": "<p>This can make a difference when you are computing size</p>",
        "id": 565990269,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767288160
    },
    {
        "content": "<p>An AC0 circuit, which is polynomial size can unfold into an exponential sized formula</p>",
        "id": 565990280,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767288181
    },
    {
        "content": "<p>Yes I'm aware of that, and mine is for circuits, so arbitrary out degree</p>",
        "id": 565994408,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1767293447
    },
    {
        "content": "<p>.. Oh! You were saying you have an inductive definition, but it really captures formulas, not circuits. I see, I had misunderstood your message. Makes sense now</p>",
        "id": 565994432,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1767293482
    },
    {
        "content": "<p>It can capture circuits if we allow metavariables that have to be mapped to circuits</p>",
        "id": 565994679,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767293890
    },
    {
        "content": "<p>That just means we have to write substitution. But then you have recursive circuit constructions, so you also have to add recursion</p>",
        "id": 565994715,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767293946
    },
    {
        "content": "<p>Btw, how do you construct explicit circuits?</p>",
        "id": 565994741,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767293961
    },
    {
        "content": "<p>At the moment, I give an explicit listing of layers + gates + what their inputs are. It's pretty unwieldly for anything nontrivial, really. I think the better way will be once we have more <code>def</code>s that give ways about modifying or composing circuits. At the moment I have <code>comp</code>, which lets you stack one circuit on top of another, and <code>sum</code>, which lets you run two circuits \"in parallel\". The main other thing would be substitution, letting you plug in a circuit implementing a gate <code>G1</code> in terms of gates <code>G0</code> into another circuit with <code>G0</code> and <code>G1</code>, in order to get a new circuit with gates only in <code>G1</code>. And then reason about how this affects the depth/width/size of the circuit. With those three primitives I think we could then start proving increasingly more interesting circuits can be built at some size. Sort of like how there's a whole bunch of functions in Mathlib proven to be <code>Nat.Primrec</code>, and it's pretty easy to build them up now to show new ones. (Like, a proof that primality testing is in Primrec would be pretty easy; correspondingly, I would like a world where a proof that primality testing is in coNP/poly should be just a few lines to build up.)</p>",
        "id": 565999346,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1767301060
    },
    {
        "content": "<p>Mm, one issue with this definition of circuit is that all wires are of the same type. So you could have an arithmetic circuit with Nat or Int wires just fine, and then you could imagine a substitution-type method that \"compiles\" that arithmetic circuit down to a Bool circuit with some effective bounds on the sizes of the numbers involved. You could also use this kind of definition to talk about, for instance, a neural network structure, in a reasonable way.</p>\n<p>But this definition I have right now doesn't support talking about a circuit with mixed data types, like some Nat wires and some Real wires and some Bool wires.</p>",
        "id": 565999481,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1767301202
    },
    {
        "content": "<p>I think in your definition you will also find it difficult to do inductive proofs that would be trivial in an inductive type</p>",
        "id": 566000863,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767303546
    },
    {
        "content": "<p>Can you give an example of what this inductive type would look like?</p>",
        "id": 566003910,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1767308169
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">CTerm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ID</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">CVar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ID</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- Circuit input nodes. important to keep separate.</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">BVar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CTerm</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ID</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">CTerm</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ID</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Mult</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CTerm</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ID</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">CTerm</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ID</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Neg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CTerm</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ID</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">CTerm</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ID</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Const</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">CTerm</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ID</span>\n</code></pre></div>",
        "id": 566004320,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767308634
    },
    {
        "content": "<p>these were defined for arithmetic circuits of course</p>",
        "id": 566004343,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767308666
    },
    {
        "content": "<p>Okay, so that's reflecting formulas then, yes?</p>\n<p>Unless you end up defining \"size\" as some kind of minimization over identifying equal subterms together, but that sounds terrible</p>",
        "id": 566004928,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1767309534
    },
    {
        "content": "<p>What is <code>BVar</code>?</p>",
        "id": 566004958,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1767309589
    },
    {
        "content": "<p>Bvar is an identifier for circuits</p>",
        "id": 566005454,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767310423
    },
    {
        "content": "<p>And circuits are to be evaluated over a context.</p>",
        "id": 566005457,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767310440
    },
    {
        "content": "<p>So when common sub circuits become an element of this context. They are supposed to be counted exactly once when size is computed.</p>",
        "id": 566005505,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767310497
    },
    {
        "content": "<p>How is a context expressed in Lean?</p>",
        "id": 566005579,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1767310621
    },
    {
        "content": "<p>I think this would be very awkward.<br>\nThe standard solutions in the literature are visualizing the circuit as a labeled DAG, and thinking of it as a straight-line program (in our case, we can make the line numbers an arbitrary finite linear order).</p>",
        "id": 567706269,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1768292769
    },
    {
        "content": "<p>Just a heads up, I realised that we can use the <a href=\"https://github.com/leanprover/cslib/pull/275\">cslib#275</a> approach to build boolean and arithmetic circuit complexity. I'll experiment a bit and post more here.</p>",
        "id": 569922450,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769312301
    },
    {
        "content": "<p>The promised update is here:</p>\n<p>In <a href=\"https://github.com/leanprover/cslib/pull/275\">cslib#275</a> , specifically in <a href=\"https://github.com/leanprover/cslib/pull/275/changes#diff-64a0f73b982700104830baace7482885ed8f9b4352ad414927281a7398ceff05\">CircuitProgs.lean</a> I have written an example circuit type</p>",
        "id": 569997217,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769391292
    },
    {
        "content": "<p>and I have instantiated it with a circuit on rationals and a circuit on Booleans. This can be used for circuit complexity on arbitrary circuit types</p>",
        "id": 569997258,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769391336
    },
    {
        "content": "<p>But most interestingly for arithmetic and boolean circuit complexity</p>",
        "id": 569997272,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769391347
    },
    {
        "content": "<p>This is all part of the query model framework.</p>",
        "id": 569997281,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769391358
    },
    {
        "content": "<p>The trick to not double counting shared sub-circuits is to assign IDs to each circuit node as we create them, collect all the unique node IDs as a list, and compute its length. Currently this is happening manually, but I do wish there is a more elegant solution to automatically fitting node IDs into the circuit description, but I think this is an excellent start to both describing circuits and circuit complexity inside a monadic DSL</p>",
        "id": 569997421,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769391478
    },
    {
        "content": "<p>Thanks to the custom cost structure, we get </p>\n<ol>\n<li>A list of nodes in the circuit,</li>\n<li>Its depth</li>\n<li>Its size (which can be derived trivially from 1)</li>\n</ol>",
        "id": 569997830,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769391824
    },
    {
        "content": "<p>I need to sleep now. But if there are questions and suggestions, I am glad to answer them in around 12  to 24 hours</p>",
        "id": 569998299,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769392305
    },
    {
        "content": "<p>We definitely need a bunch of API lemmas for size fwiw.</p>",
        "id": 569999222,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769393153
    },
    {
        "content": "<p>This remains a bit outside my expertise, but I am interested to see what <span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span> thinks of this approach. I think it might make sense to split this into its own PR until we understand if there are tradeoffs compared to the work Alex has done already. I don't want what seems like work heading in a productive direction to get slowed down by having too many directions from the onset. I think what will make this easiest to merge is if the initial scope of the first PR cleanly subsumes the existing modules using <code>TimeM</code>.</p>",
        "id": 570005052,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769398672
    },
    {
        "content": "<p>So Alex represents a circuits as DAGs with explicit edges. In principle one can take this DSL and compile it to such a DAG by using a different model. One drawback in those DAGs is they are incredibly hard to use for constructing circuits explicitly. Another related drawback is that it is hard to perform induction on the formula structure in his method. Conversely, in my work, it is important to assign distinct IDs to nodes for counting size (although we do have a notion of IDs when we draw circuits on paper. We use complex labels).</p>",
        "id": 570030097,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769415238
    },
    {
        "content": "<p>In addition to the implied advantages above, in my method, it is relatively trivial to do two things:</p>\n<ol>\n<li>Construct explicit circuits. </li>\n<li>Define uniform circuits upto a point. If we define a query type for TMs per a transition function, then this gets even more precise. We can then speak of DLOGTIME-uniform AC0</li>\n</ol>",
        "id": 570030488,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769415408
    },
    {
        "content": "<p>Also since <span class=\"user-mention\" data-user-id=\"815159\">@Yuval Filmus</span> has been doing complexity theory for more than a decade I am also hoping to hear this thoughts on this</p>",
        "id": 570030980,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769415577
    },
    {
        "content": "<p>I think this is quite awkward.<br>\nSuppose that we want to show that the cost of computing f(x)^2 is at most one plus the cost of computing f(x).<br>\nIt’s possible but not so convenient.</p>\n<p>My preferred solution is straight line programs.<br>\nThis also has the minor advantage of being able to accommodate multi-output gates.<br>\nOne disadvantage is that defining depth (and in the arithmetic case, degree) becomes more awkward.</p>\n<p>There are other computation models out there (many, in fact), for example branching programs.<br>\nThey also seem more natural to encode using IDs for computation nodes.</p>\n<p>As for formulas, it is more natural to use trees.<br>\nHowever, one can also define them by restricting the fan-out of nodes in a circuit.</p>",
        "id": 570032550,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1769416168
    },
    {
        "content": "<p>In addition, the set of gates could be a parameter in the general definition.</p>",
        "id": 570033090,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1769416357
    },
    {
        "content": "<p>So the circuit type I have defined is an example</p>",
        "id": 570035067,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769416986
    },
    {
        "content": "<p>One can fit in almost any inductive type into this framework</p>",
        "id": 570035109,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769417002
    },
    {
        "content": "<p>Not only circuits - also proofs (in proof complexity), where you have the analogs of both formulas and circuits (and less commonly, other objects).</p>",
        "id": 570035332,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1769417084
    },
    {
        "content": "<p>The key features that this example demonstrates are the following :</p>\n<ol>\n<li>Using lean code (and therefore lean identifiers and lean functions including recursion) to define circuits </li>\n</ol>\n<p>2.reduce one model to another by mapping their query types. </p>\n<ol start=\"3\">\n<li>Compute size of a DAG even when it is a tree</li>\n</ol>",
        "id": 570035377,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769417098
    },
    {
        "content": "<p>For proof complexity you can define a different query type</p>",
        "id": 570035495,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769417140
    },
    {
        "content": "<p>This is a lightweight version of the  meta model I once described to you. It can express them all an relations between them</p>",
        "id": 570035609,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769417180
    },
    {
        "content": "<p>When reducing one model to another, we often use gadget reductions.<br>\nAlso not uncommon is operations such as depth balancing.</p>",
        "id": 570035637,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1769417192
    },
    {
        "content": "<p>Also possible here. I’d even say a bit easier with inductive types</p>",
        "id": 570035724,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769417223
    },
    {
        "content": "<p>Strictly speaking, an inductive circuit type (or even branching program) with node IDs is sufficient. What my examples show is how we can write them (including recursively defined circuits) right in lean.</p>",
        "id": 570035954,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769417312
    },
    {
        "content": "<p>For your definition you need to verify another property - circuits with identical IDs coincide.</p>",
        "id": 570036159,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1769417381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Parity.20is.20not.20in.20AC0/near/569997217\">said</a>:</p>\n<blockquote>\n<p>The promised update is here:</p>\n<p>In <a href=\"https://github.com/leanprover/cslib/pull/275\">cslib#275</a> , specifically in <a href=\"https://github.com/leanprover/cslib/pull/275/changes#diff-64a0f73b982700104830baace7482885ed8f9b4352ad414927281a7398ceff05\">CircuitProgs.lean</a> I have written an example circuit type</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"815159\">@Yuval Filmus</span> : when you say you would prefer to just use lean program are you describing Alex’s method or the example I quoted above?</p>",
        "id": 570036182,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769417389
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"815159\">Yuval Filmus</span> <a href=\"#narrow/channel/513188-CSLib/topic/Parity.20is.20not.20in.20AC0/near/570036159\">said</a>:</p>\n<blockquote>\n<p>For your definition you need to verify another property - circuits with identical IDs coincide.</p>\n</blockquote>\n<p>That’s true</p>",
        "id": 570036221,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769417401
    },
    {
        "content": "<p>But I also think we could just carry it as an assumption in our theorem statements</p>",
        "id": 570036351,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769417438
    },
    {
        "content": "<p>Not Lean programs, but straightline programs, which is one way in which circuits are understood in complexity theory.<br>\nWe can describe a circuit as a sequence of instructions where each line can only use inputs and outputs from previous lines.</p>",
        "id": 570036505,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1769417487
    },
    {
        "content": "<p>Doesn’t my approach already fit that?</p>",
        "id": 570036604,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769417514
    },
    {
        "content": "<p>I think it’s very awkward, since you have this condition that nodes with the same ID are identical.<br>\nYou don’t need this in a straightline program.<br>\nOne can ask whether we want to think of a straightline program as a list (perhaps with an additional ID field), which you evaluate inductively; or as a mapping from a partial order to instructions, which are constrained to only refer to preceding inputs (though some models allow circular circuits, at least in proof complexity).</p>",
        "id": 570037240,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1769417703
    },
    {
        "content": "<p>On the other hand, in some cases (branching programs, switching networks, comparator networks) we want to care about “layers”, which will be awkward in both models unless you add more structure to the ID.</p>",
        "id": 570037666,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1769417841
    },
    {
        "content": "<p>Adding structure to the ID is certainly possible. I picked natural numbers since they are the easiest to generate new IDs for</p>",
        "id": 570037828,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769417885
    },
    {
        "content": "<p>The problem that a monadic DSL like this is solving is </p>\n<ol>\n<li>Defining variable substitution, especially recursive ones</li>\n<li>Defining a notion of functions or procedures.</li>\n</ol>",
        "id": 570038051,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769417951
    },
    {
        "content": "<p>These are incredibly annoying parts of defining a deeply embedded DSL</p>",
        "id": 570038177,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769417984
    },
    {
        "content": "<p>The specific representation of Circuits and IDs inside this monadic framework are very fungible</p>",
        "id": 570038353,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769418024
    },
    {
        "content": "<p>Suppose you want to join two circuits together.<br>\nYou can do it directly with natural numbers, but it’s a bit artificial.</p>",
        "id": 570038500,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1769418072
    },
    {
        "content": "<p>You would join them with one of the circuit’s gates right?</p>",
        "id": 570039923,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769418549
    },
    {
        "content": "<p>See the second and third examples</p>",
        "id": 570039953,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769418559
    },
    {
        "content": "<p>Or do you mean join them and share internal nodes?</p>",
        "id": 570040008,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769418577
    },
    {
        "content": "<p>No, just join</p>",
        "id": 570040189,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1769418640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Parity.20is.20not.20in.20AC0/near/570038051\">said</a>:</p>\n<blockquote>\n<p>The problem that a monadic DSL like this is solving is </p>\n<ol>\n<li>Defining variable substitution, especially recursive ones</li>\n<li>Defining a notion of functions or procedures.</li>\n</ol>\n<p>These are incredibly annoying parts of defining a deeply embedded DSL</p>\n</blockquote>\n<p>Maybe I am more comfortable because I have formalized enough lambda calculi, but I hope to encourage design decisions that do not <em>unnecessarily</em> shy away from binding. I do agree it requires a certain amount of careful setup. I am working on metaprogramming utilities to help in this area, but this is a longer term project.</p>",
        "id": 570040580,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769418766
    },
    {
        "content": "<p>There is also the benefit of fitting circuit classes within the free monad framework by reductions</p>",
        "id": 570041692,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769419090
    },
    {
        "content": "<p>The ID trick is orthogonal to this. It is simply a mechanism for keeping track of circuit nodes we have already counted in a recursive traversal of the inductive circuit type. </p>\n<p>I would still like circuits to be inductive so that inductive proofs don’t become complicated for the kind of manipulations Yuval mentioned above. The only other way I see to make size not double count is to check each sub circuit for equality with every other sub circuit encountered so far.</p>",
        "id": 570042862,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769419462
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"815159\">@Yuval Filmus</span> : strictly speaking the condition is not “all nodes with the same ID are identical”. The circuit author assigns IDs manually. The correct claim is “all circuits with the same id are counted once collectively when computing the size of the circuit”</p>",
        "id": 570064656,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769425997
    },
    {
        "content": "<p>You can always assign the same ID to different subcircuits. It doesn’t affect the correctness of what the circuit computes and the depth of the circuit.</p>",
        "id": 570064845,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769426054
    },
    {
        "content": "<p>What prevents me from cheating, then?<br>\nI can use the same ID for all subcircuits.</p>",
        "id": 570064896,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1769426074
    },
    {
        "content": "<p>Nothing yet. Someone still has to read your spec to see what you label your nodes. I have pointed this out as something to be worked on. Maybe another monad.</p>",
        "id": 570067890,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769427101
    },
    {
        "content": "<p>For example a state monad that keeps track of a counter and increments it each time to generate IDs it is used can ensure nobody cheats on Boolean or arithmetic circuits</p>",
        "id": 570068243,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769427223
    },
    {
        "content": "<p>But for use cases where you want to use the same ID for different nodes, the option exists</p>",
        "id": 570068357,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769427260
    },
    {
        "content": "<p>A stranger idea I had is to maintain a type theory like context and instead of the inductive type of circuits referring to other circuits recursively, they refer to valid IDs</p>",
        "id": 570069053,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769427500
    },
    {
        "content": "<p>The problem there is getting recursive definitions.</p>",
        "id": 570069088,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769427517
    },
    {
        "content": "<p>It’s basically like ngspice</p>",
        "id": 570069118,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769427527
    },
    {
        "content": "<p>After some thinking, I believe this is what you mean by a line description.</p>",
        "id": 570072691,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769428717
    },
    {
        "content": "<p>I dunno, I think this is not the most natural or ergonomic definition of circuits. (And, while there may be multiple good definitions of the same informal concept in Lean, they should either be natural <em>or</em> ergonomic.) I believe you that they might be natural for arithmetic circuit complexity, which I'm passingly familiar with but have never worked on myself. You say that it's easier to construct explicit examples of circuits, and this monadic DSL is nice, but I guess I'm not convinced that it's easy for the cases of interest to me (complexity theory -- as opposed to, say, constructing explicit circuits for a particular function).</p>",
        "id": 570128123,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769442655
    },
    {
        "content": "<p>I've actually been working on branching programs a good bit locally, I have a proof of Barrington's Theorem, that width-5 oblivious BP's are equivalent to NC1.</p>",
        "id": 570128310,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769442707
    },
    {
        "content": "<p>I'd also like to note that the inductive definition doesn't (obviously, to me) generalize to multiple-output circuits. So things like the class FNC or theorems like Uhlig's \"mass production of Boolean functions\" would seem very hard to get in that form.</p>",
        "id": 570129130,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769442908
    },
    {
        "content": "<p>I think I'm increasingly of the opinion that it may be worth keeping a few different types around, which offer different options for constructions, and then we have the functions to move between them.</p>\n<p>For circuits, we have one informal notion: a circuit.<br>\nThen there's a few different ways a mathematician might right down a definition (in English):</p>\n<ul>\n<li>A series of layers, which connect one to the next. (the one I linked at the top of this thread)</li>\n<li>A series of of layers, which each connect to any previous layer.</li>\n<li>A DAG</li>\n<li>An inductive construction, with some method of common subexpression elimination -- what you've been describing</li>\n<li>Straight-line-programs</li>\n</ul>\n<p>And additionally all of these have two different conventions I'm aware of: do you start with the inputs to the circuit explicitly as the first n nodes? Or, can I add \"fresh copies\" of the input at later nodes? (A special type of \"constant\" gate that is always the ith input.)</p>",
        "id": 570129866,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769443069
    },
    {
        "content": "<p>Personally, I believe the best outcome would be having all five of those bullet points as definitions. (I'm not sure about the second point). And then some functions to convert one to the other, and lemmas about how this conversion changes the depth/width/size/weft/etc.</p>",
        "id": 570130247,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769443148
    },
    {
        "content": "<p>I was already running into this with branching programs, that some people really insist on branching programs being layered, and some insist on it being a DAG. And this matters, a lot actually! Because there's interest in what functions you can compute at particular constant widths (width-4 vs width-5) and then these subtle differences give you meaningfully different complexity classes.</p>",
        "id": 570130806,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769443267
    },
    {
        "content": "<p>It's possible that you can take the first bullet point above as just a predicate about the second, but then the types can get messier when you talk about how to refer to earlier layers when you put it in Lean.</p>\n<p>Similarly, a straight-line-program can be viewed as the special case of a layered circuit (with skips) where each layer is width 1. This is a correct definition, mathematically. But now the \"depth\" of your SLP is not what you would expect (the minimum depth over equivalent circuits), but rather the size of the circuit, so you get some extra headache.</p>\n<p>For the reason, I think it's better to just keep them separate.</p>",
        "id": 570131372,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769443396
    },
    {
        "content": "<p>I hope the finish cleaning up my branching program stuff soon, then hopefully it will convince you a bit more that this kind of circuit stuff isn't too bad too work with. :)</p>",
        "id": 570131539,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769443437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/513188-CSLib/topic/Parity.20is.20not.20in.20AC0/near/570128123\">said</a>:</p>\n<blockquote>\n<p>I dunno, I think this is not the most natural or ergonomic definition of circuits. (And, while there may be multiple good definitions of the same informal concept in Lean, they should either be natural <em>or</em> ergonomic.) I believe you that they might be natural for arithmetic circuit complexity, which I'm passingly familiar with but have never worked on myself. You say that it's easier to construct explicit examples of circuits, and this monadic DSL is nice, but I guess I'm not convinced that it's easy for the cases of interest to me (complexity theory -- as opposed to, say, constructing explicit circuits for a particular function).</p>\n</blockquote>\n<p>I actually wrote this with the intent of using it in complexity theory</p>",
        "id": 570135250,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769444384
    },
    {
        "content": "<p>This monadic approach is a method to write the inductive type inside a monad. In principle you can write a different <code>Model</code> in which <code>evalQuery</code> returns just the inductive circuit type as it is, or a DAG like your structure.</p>",
        "id": 570135837,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769444541
    },
    {
        "content": "<p>I am still considering how to work with IDs in a more transparent way to get a good size function fwiw.</p>",
        "id": 570136047,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769444594
    },
    {
        "content": "<p>Another point to consider is that essentially <code>Prog</code> is a Free monad DSL. You can write your own notion of Branching Programs with its constructors, and retrofit it into this DSL easily</p>",
        "id": 570136500,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769444697
    },
    {
        "content": "<p>You can see the examples in <code>ProgExamples.lean</code> to get an idea of how to fit an arbitrary inductive type into Prog</p>",
        "id": 570136794,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769444784
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/513188-CSLib/topic/Parity.20is.20not.20in.20AC0/near/570129866\">schrieb</a>:</p>\n<blockquote>\n<p>I think I'm increasingly of the opinion that it may be worth keeping a few different types around, which offer different options for constructions, and then we have the functions to move between them.</p>\n<p>For circuits, we have one informal notion: a circuit.<br>\nThen there's a few different ways a mathematician might right down a definition (in English):</p>\n<ul>\n<li>A series of layers, which connect one to the next. (the one I linked at the top of this thread)</li>\n<li>A series of of layers, which each connect to any previous layer.</li>\n<li>A DAG</li>\n<li>An inductive construction, with some method of common subexpression elimination -- what you've been describing</li>\n<li>Straight-line-programs</li>\n</ul>\n<p>And additionally all of these have two different conventions I'm aware of: do you start with the inputs to the circuit explicitly as the first n nodes? Or, can I add \"fresh copies\" of the input at later nodes? (A special type of \"constant\" gate that is always the ith input.)</p>\n</blockquote>\n<p>Do we need an explicit model for dags? I don't see what is simpler than straight-line programs for that. You can still transform a straight line program to a dag, if you want to without having to maintain another definition.</p>",
        "id": 570137962,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1769445096
    },
    {
        "content": "<p>In one of my own tries I have defined circuits like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Circuit</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">gates</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">well_formed</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">gates</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n1</span><span class=\"w\"> </span><span class=\"n\">n2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">gates</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">n2</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">input_length</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">gates</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">input_well_formed</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">gates</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">gates</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">input_length</span>\n<span class=\"w\">  </span><span class=\"n\">output</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">gates</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>to try and validate a reduction. For me everything though is a NAND-gate which makes the straightline program simpler than having to support multiple gate operations with different arities.</p>",
        "id": 570138323,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1769445194
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span> in this DSL the input nodes are simply circuit parameters supplied to a function</p>",
        "id": 570148281,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769447773
    },
    {
        "content": "<p>It doesn't matter whether they are constant or not and where they are used first</p>",
        "id": 570148331,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769447790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/513188-CSLib/topic/Parity.20is.20not.20in.20AC0/near/570129130\">said</a>:</p>\n<blockquote>\n<p>I'd also like to note that the inductive definition doesn't (obviously, to me) generalize to multiple-output circuits. So things like the class FNC or theorems like Uhlig's \"mass production of Boolean functions\" would seem very hard to get in that form.</p>\n</blockquote>\n<p>This is also not true. You can change the output type of a prog and generate a tuple of circuits</p>",
        "id": 570148515,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769447850
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/513188-CSLib/topic/Parity.20is.20not.20in.20AC0/near/570128310\">said</a>:</p>\n<blockquote>\n<p>I've actually been working on branching programs a good bit locally, I have a proof of Barrington's Theorem, that width-5 oblivious BP's are equivalent to NC1.</p>\n</blockquote>\n<p>This is very nice, I was specifically hoping to get to Barrington since it has been mentioned before. I'd love to start getting  some of this into CSLib.</p>\n<p>Here are my thoughts on the different representations. From Alex's comments it sounds like there are some nontrivial decisions, and possibly appetite to support multiple representations like we do for lambda calculi, but at the moment he has reached some nontrivial theorems that indicate some level of usability. My preference is that we:</p>\n<ul>\n<li>continue refining <a href=\"https://github.com/leanprover/cslib/pull/275\">cslib#275</a> into cleanly subsuming <code>TimeM</code> and can be merged, so that this contribution does not stall with this widening scope</li>\n<li>separately begin (in small chunks at Alex's discretion) PRing material using this layered circuit representation building towards theorems on AC and NC</li>\n<li>revisit what additional representations, such as the monadic one or others Alex mentions, may make sense to additionally support</li>\n</ul>\n<p>I'd like to clarify that I am <em>not</em> at all shooting down <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span>'s idea of having this monadic representation of circuits, just trying to make some suggestions about cleanly delineating the scope of PRs. I think what would be convincing is concretely seeing what proofs about complexity look like in the monadic framework, say the proof that Parity is not AC0, so that everyone can directly compare the ergonomics.</p>",
        "id": 570150810,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769448544
    },
    {
        "content": "<p>For the latter I would need to work on Alex’s repo. I think the monadic framework can be translated to his representation. I suggest leaving the circuit examples as examples of how flexible the framework can be for now, but not pushing it any further. We definitely need a convenient way to program circuits for circuit complexity. There are far too many important upper bounds that rely on clever constructions.</p>",
        "id": 570151316,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769448696
    },
    {
        "content": "<p>We could even choose to have a dual setup where Alex’s definitions are used for lower bound style while the monadic framework is used for upper bounds and we just link them by some equivalence relation</p>",
        "id": 570151492,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769448756
    },
    {
        "content": "<p>I think leaving the examples is fine, though I might consider moving them to the testing directory.</p>",
        "id": 570152284,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769449008
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span> : May I try porting the Prog stuff to your repo and compile circuits down to your description?</p>",
        "id": 570153521,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769449357
    },
    {
        "content": "<p>Oh yes, I won't object to anyone trying to PR anything to or from my repo. :) If someone wants to grab it and get it into some other framework, I'll be all the happier!</p>",
        "id": 570163975,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769452681
    },
    {
        "content": "<p>and I do want to understand this Prog stuff better. It just doesn't look very convenient to me but I strongly suspect that it's my lacking some vision of how it can/does scale up.</p>",
        "id": 570164095,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769452718
    },
    {
        "content": "<p>(I think any representation will come with its own pain points, and its own places where it needs extra support/API to make it more usable...)</p>",
        "id": 570164184,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769452752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"619540\">Johannes Tantow</span> <a href=\"#narrow/channel/513188-CSLib/topic/Parity.20is.20not.20in.20AC0/near/570137962\">said</a>:</p>\n<blockquote>\n<p>Do we need an explicit model for dags? I don't see what is simpler than straight-line programs for that. You can still transform a straight line program to a dag, if you want to without having to maintain another definition.</p>\n</blockquote>\n<p>So, I agree that straight-line programs naturally include DAGs, essentially just throwing away the unneeded information of vertex labels (in some type) and instead just giving canonical Nat labels.</p>\n<p>The reason I think DAGs might still be good would be composability. This is a bit far away from what any of us are trying to do now, but I can imagine some scenario where I say:</p>\n<ul>\n<li>I've constructed this circuit for <code>f</code>, that uses as a subroutine this circuit for <code>g</code>.</li>\n<li>I've separately constructed this circuit for <code>h</code>, that also uses as a subroutine this circuit for <code>g</code>.</li>\n<li>Now I'm constructing a new circuit that uses both <code>f</code> and <code>h</code>, and I want to reuse the <code>g</code> part of it.<br>\nThat would, I think, be pretty tricky to express in terms of SLPs. But very natural in DAGs, where I could put meaningful labels on my vertices that let me express this kind of thing.</li>\n</ul>\n<p>I also think things like \"compute these O(n^2) functions, each of depth O(n), in parallel, and then do a final O(n) computation on their outputs --&gt; gives a circuit of depth O(n)\" would be annoying to reason about in the SLP model. You will, again, be proving something about these different nodes with meaningful labels (something like <code>(Fin a × Fin b) ⊕ Fin c</code>), but instead you're just doing it all with natural numbers. So you need to relabel through an <code>Equiv</code> to get the labels out, and show that the equivalence respects the ordering correctly; or you need to write down some explicit arithmetic for encoding/decoding the natural number labels to the IDs, which will also be a headache and very easy to mess up.</p>",
        "id": 570165419,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769453146
    },
    {
        "content": "<p>Hi. I too have been working on formalising Barrington's Theorem (<a href=\"https://github.com/AnvitAggarwal/barrington-theorem-lean\">repo link</a>). I defined Formula in the following way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">BoolBasis</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"o\">(</span><span class=\"n\">arity</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">arity</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">demorgan_basis</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">demorgan_basis</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">demorgan_basis</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BoolBasis</span><span class=\"w\"> </span><span class=\"n\">demorgan_basis</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">arity</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">demorgan_basis</span><span class=\"bp\">.</span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">demorgan_basis</span><span class=\"bp\">.</span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"w\">  </span><span class=\"n\">eval</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">demorgan_basis</span><span class=\"bp\">.</span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">demorgan_basis</span><span class=\"bp\">.</span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BoolBasis</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BoolBasis</span><span class=\"bp\">.</span><span class=\"n\">arity</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BoolBasis</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BoolBasis</span><span class=\"bp\">.</span><span class=\"n\">arity</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">env</span>\n<span class=\"w\">  </span><span class=\"n\">BoolBasis</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n</code></pre></div>\n<p>And proved a version of Barrington's theorem using {AND, NOT} basis and group programs instead of branching programs.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Input</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hfcomputed</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">computed_by_formula</span><span class=\"w\"> </span><span class=\"n\">demorgan_basis</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"bp\">.</span><span class=\"n\">IsCycle</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GroupProgram</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">),</span>\n<span class=\"w\">      </span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">      </span><span class=\"n\">computes_with</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>It seems as though <span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span> has already formalised the proof of Barrington's theorem. I wanted to ask if my current work could be useful in any way. </p>\n<p>Also, I'd like to continue working on formalising circuit complexity theory. I'm not sure if it helps, but I'm currently a sophomore in Computer Science, and only starting out with Circuit Complexity Theory. I'd appreciate any suggestions on directions I could work on now.</p>",
        "id": 570419344,
        "sender_full_name": "Anvit Aggarwal",
        "timestamp": 1769546902
    },
    {
        "content": "<p>Another Update : I wrote another query model for circuits that compiles down to the previous model, but labels their IDs automatically</p>",
        "id": 570588502,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769613871
    },
    {
        "content": "<p>You can see the examples in CircuitProgs.lean in the section <code>section CircuitQuery</code></p>",
        "id": 570589041,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769613987
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"815159\">@Yuval Filmus</span>  This should remove the concern of cheating</p>",
        "id": 570589108,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769613998
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"908200\">@Anvit Aggarwal</span> I think it's definitely still useful. Oftentimes having two different proofs is good, it'll show two different ways of doing the same thing. This is thread is active with us discussing the \"right way\" to do things.</p>",
        "id": 570640785,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769627460
    },
    {
        "content": "<p>Your definition gives different IDs to the same subcircuit and the same ID to different subcircuits.</p>\n<p>Perhaps the best solution is to prove some nontrivial theorems using one of these models — both upper and lower bounds — and see how easy it is.</p>",
        "id": 570661136,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1769634920
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"815159\">Yuval Filmus</span> <a href=\"#narrow/channel/513188-CSLib/topic/Parity.20is.20not.20in.20AC0/near/570661136\">said</a>:</p>\n<blockquote>\n<p>Your definition gives different IDs to the same subcircuit and the same ID to different subcircuits.</p>\n<p>Perhaps the best solution is to prove some nontrivial theorems using one of these models — both upper and lower bounds — and see how easy it is.</p>\n</blockquote>\n<p>It doesn’t. Whether it assigns a different id to equal sub circuits or not depends on how you declare it</p>",
        "id": 570661265,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769634975
    },
    {
        "content": "<p>Perhaps I'm looking at the wrong functions — <code>circQueryEvalAux</code> labels the root with the input <code>id</code>, the left child with <code>id+1</code>, and the right child with <code>id+2</code>. Doesn't that mean that if you use <code>mul z z</code> then the children will get different id's? Similarly, won't the two children of the left child get the id's <code>id+2</code> (again) and <code>id+3</code>?</p>",
        "id": 570662306,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1769635356
    },
    {
        "content": "<p>Ah I see what you mean. Yes</p>",
        "id": 570663032,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769635625
    },
    {
        "content": "<p>Personally I like the explicit circuit model more because it is trivial to impose the condition that only equal nodes get equal IDs and that is sufficient for boolean circuit complexity.</p>",
        "id": 570663729,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769635869
    },
    {
        "content": "<p>I vote for straight-line programs, but there are probably other issues with them.<br>\nThat's why it might be best to give things a test run.</p>",
        "id": 570664050,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1769635995
    },
    {
        "content": "<p>I think straight line programs can also be encoded in this framework.</p>",
        "id": 570664313,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769636118
    },
    {
        "content": "<p>I think I know how to recover recursive programs. We have to make the circuit definition recursive on only one argument.</p>",
        "id": 570668749,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1769637930
    },
    {
        "content": "<p>I think I can show some of my idea of how these models could fit together, here: <a href=\"https://github.com/Timeroot/CircuitComp/blob/main/CircuitComp/BranchingProgram/Basic.lean\">https://github.com/Timeroot/CircuitComp/blob/main/CircuitComp/BranchingProgram/Basic.lean</a></p>\n<p>This is for branching programs, not circuits. But I think several of the same ideas apply and it's an easier test ground.</p>\n<p>So I've got <code>LayeredBranchingProgram</code> (nodes are in Fin-indexed layers and point only to the next one), <code>BranchingProgram</code> (which is an unstructured DAG), and <code>SkipBranchingProgram</code> (which has layers, but nodes can point to any subsequent one).</p>\n<p>The suggested definition that I got from Aristotle for <code>BranchingProgram</code> was actually not what I was initially intending, but it was quite interesting:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">BranchingProgram</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">nodes</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">nodes</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Every node either returns a value in `γ`, or reads a variable `α` and branches to the next node. -/</span>\n<span class=\"w\">  </span><span class=\"n\">info</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">nodes</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">nodes</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The relation `child` is well-founded, ensuring no infinite paths. -/</span>\n<span class=\"w\">  </span><span class=\"n\">wellFounded</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WellFounded</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">info</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">var</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>so that evaluation comes straight from well-founded recursion. This lets you include interesting cases like a branching program that reads <code>Nat</code> valued variables, and has different depths depending on the values it reads - with no bound on the depth at all! While still having meaningful termination.</p>",
        "id": 570707772,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769663399
    },
    {
        "content": "<p>Then there's <code>LayeredBranchingProgram.toBranchingProgram</code> which turns it into a DAG, and <code>BranchingProgram.toSkip</code> which computes depths and lays them out, and <code>SkipBranchinProgram.toLayered</code> which adds in the missing intermediate nodes to avoid skip connections.</p>\n<p>All of these are then backed up with an appropriate proof that their <code>eval</code> functions agree.</p>",
        "id": 570707852,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769663462
    },
    {
        "content": "<p>In <code>Barrington.lean</code> I separately define <code>GroupProgram</code>, and have the conversion from an AND-NOT circuit (a <code>FeedForward</code>) to a GroupProgram over S^5; and then the conversion from GroupProgram to BranchingProgram. I'm working on getting the compilation from <code>BranchingProgram</code> back down to a <code>FeedForward</code> circuit in log-depth, to get the other direction of Barrington's theorem.</p>",
        "id": 570708182,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769663712
    },
    {
        "content": "<p>I really believe that keeping these different definitions around will be helpful.</p>\n<p>One of my goals to make sure this is workable is to show that you can convert a <em>non-oblivious</em> (layered) branching program to an oblivious one, with only a modest increase in width. This is very tedious to do with a plain LayeredBranchingProgram, but much more straightforward to do with a SkipBranchingProgram: spread the nodes out so as to group separate nodes reading different variables into different levels. So it's easy to see that you can do this with a SkipBranchingProgram.</p>\n<p>To show that you can make a layered program oblivious, you convert to a skip branching program (which doesn't change width), make that oblivious, then convert back (which increases width in a controlled amount, and keeps it oblivious.)</p>",
        "id": 570708591,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769663999
    },
    {
        "content": "<p>I'm still mucking with them enough as I go that I don't think it's PR-ready yet. Also my proofs need to be cleaned up. :) But I think once I hit those ^^ two theorems, I'll try to PR it in some form.</p>",
        "id": 570708680,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1769664071
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"815159\">@Yuval Filmus</span> : I worked on the circuits language a bit and now managed to make it work without IDs</p>",
        "id": 571686104,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770131145
    },
    {
        "content": "<p>I have renamed the old <code>Circuit</code> to <code>Formula</code>. The size computation of formulas works as expected.</p>",
        "id": 571686187,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770131168
    },
    {
        "content": "<p>Then I provided a model from <code>Circuit</code> to <code>Formula</code> that ensures that a formula is only counted in size when it is evaluated in the monad.</p>",
        "id": 571686321,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770131203
    },
    {
        "content": "<p>So I can avoid double counting of repeated circuits.</p>",
        "id": 571686392,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770131222
    },
    {
        "content": "<p>See example 6</p>",
        "id": 571686408,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770131225
    },
    {
        "content": "<p>Link : <a href=\"https://github.com/Shreyas4991/cslib/blob/d472ff51419c7647457912d60f941264eee9f4b8/Cslib/Algorithms/CircuitProgs.lean#L198\">https://github.com/Shreyas4991/cslib/blob/d472ff51419c7647457912d60f941264eee9f4b8/Cslib/Algorithms/CircuitProgs.lean#L198</a></p>",
        "id": 571687042,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770131385
    },
    {
        "content": "<p>Also CC : <span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span></p>",
        "id": 571687079,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770131394
    },
    {
        "content": "<p>I am fixing a mistake right now. I'll ping once it is done. Basically the idea is to turn circuit into a monad in itself.</p>",
        "id": 571687466,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770131484
    },
    {
        "content": "<p>I will be moving this model to a separate PR</p>",
        "id": 571695380,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770133230
    },
    {
        "content": "<p>FYI <span class=\"user-mention silent\" data-user-id=\"1020114\">Dennj Osele</span> is PRing circuits to Mathlib <a href=\"https://github.com/leanprover-community/mathlib4/pull/34578\">#34578</a></p>",
        "id": 572308418,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770362656
    },
    {
        "content": "<p>Or rather, PRing formulas but calling them circuits to skirt the issue…</p>",
        "id": 572309840,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1770363321
    },
    {
        "content": "<p>Mathlib is really not the best place for this. When there is no agreement on which definition of a circuit to even use, people shouldn’t be PRing a definition to either lib. Concretely the solution is to first prove upper and lower bounds using any given definition/model of circuits, and then, if there is convergence to that model, then PR it  to CSLib.</p>",
        "id": 572315101,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770365508
    },
    {
        "content": "<p>I agree but I'm not sure what we can do about this other than comment our thoughts in that PR<br>\nThey don't seem to be active on Zulip, and are not subscribed to the CSLib channel</p>",
        "id": 572318036,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770366574
    },
    {
        "content": "<p>Letting a mathlib maintainer know should suffice.</p>",
        "id": 572318308,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1770366643
    },
    {
        "content": "<p>I think we should take care to not dictate what is in scope for Mathlib, and there is no mandate that all contributions to Mathlib's <code>Computability</code> modules should immediately be rerouted. On the other hand if there is a promising Mathlib PR that for whatever reason appears will not be merged, it seems perfectly fine for either a Mathlib or CSLib maintainer to inquire if the author is interested in contributing to CSLib. Conversely, CSLib retains the prerogative to extend, ignore, or otherwise deviate from Mathlib.</p>",
        "id": 572322313,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770367946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"815159\">Yuval Filmus</span> <a href=\"#narrow/channel/513188-CSLib/topic/Parity.20is.20not.20in.20AC0/near/572309840\">said</a>:</p>\n<blockquote>\n<p>Or rather, PRing formulas but calling them circuits to skirt the issue…</p>\n</blockquote>\n<p>To be clear however, I do agree on this point. To me it's analogous to when people formalize a \"categorical semantics\" but really they've worked around the encoding issues by conflating the syntax with its interpretation.</p>",
        "id": 572351602,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770376902
    },
    {
        "content": "<p>The author of the PR actually has a clear vision regarding the formula / circuit issue, articulated in the PR.<br>\nI wonder whether there is any reason to duplicate their effort here.</p>",
        "id": 572569258,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1770500839
    },
    {
        "content": "<p>It is a bit unfortunate there was not more coordination here. I've not compared them closely, but my suggestion is that if anyone has comments about the differences between <span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span>'s <a href=\"https://github.com/Timeroot/CircuitComp\">CircuitComp</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/34578\">#34578</a> (or any general concerns) that you point them out on the Mathlib PR. It would be ideal that whatever ends up in Mathlib is something we are happy using too.</p>",
        "id": 572578109,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770511529
    }
]