[
    {
        "content": "<p>I’ve implemented a fully polymorphic bisection method <a href=\"https://github.com/Oscario0/LeanBisection/blob/main/src/bisection.lean\">here</a>. It finds a root in the interval [a, b], and when executing on floats, it agrees with Python numerical libraries works quite nicely when executing on floats. We made make it fully polymorphic to work with both <code>Floats</code> and <code>ℝ</code>, and prove termination and sub-interval generation thus far. Beyond these, what other properties, theorems or invariants about the code are there that are typically proved in this context? <br>\nI redefined mathlib definitions for now to get the code to agree with reals. Any questions, suggestions and critiques on style, refactoring  and so on... are welcomed as well.</p>",
        "id": 569408395,
        "sender_full_name": "Oscar Matemb ⚛️",
        "timestamp": 1769057170
    },
    {
        "content": "<p>You can save yourself a fair amount of boilerplate by writing</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">BisectionConfig</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Sub</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Div</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">two</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">isPositive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"n\">isNegative</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n</code></pre></div>",
        "id": 569422294,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769066696
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 570699281,
        "sender_full_name": "Oscar Matemb ⚛️",
        "timestamp": 1769657593
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"1010219\">@Alejandro Radisic</span> this project is a subscript of what you implemented in LeanCert, I wanted to get your opinion on it.</p>",
        "id": 570861632,
        "sender_full_name": "Oscar Matemb ⚛️",
        "timestamp": 1769709346
    },
    {
        "content": "<p>Hey Oscar, nice work getting this running!</p>\n<p>So the big difference with what we did in LeanCert is basically point sampling vs interval enclosures. In your version you’re just evaluating <code>f(mid)</code> directly, which is great for Floats and works fast, but it’s hard to prove anything about it, and over ℝ it’s noncomputable anyway</p>\n<p>In LeanCert we avoid that by evaluating <code>f</code> on an interval instead, and then checking whether the whole interval is positive, negative, or neither. That way you keep things computable (endpoints are rational) and you also get soundness from the bounds.</p>\n<p>The polymorphism issue you ran into with ℝ is pretty much exactly why we went that route, you can’t turn a Prop like <code>f x &lt; 0</code> into a Bool in a computable way.</p>\n<p>If you want to move more in the verification direction, the key idea is switching to a kind of three-state logic. Instead of asking “is <code>f(x) &lt; 0</code>?”, you ask something like “is <code>f([x−ε, x+ε]).hi &lt; 0</code>?”. That’s decidable and actually gives you something you can prove correct</p>",
        "id": 570918405,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1769731659
    },
    {
        "content": "<p>Thank you very much for your response. I actually didn't think about evaluating <code>f</code> over an interval instead of a fixed point. I don't understand why an interval provides a higher level logic that allows computations to be provable? I understand the simplicity of this approach but not at a high level. If you have some resources to do some reading that's greatly appreciated as well!</p>",
        "id": 571784456,
        "sender_full_name": "Oscar Matemb ⚛️",
        "timestamp": 1770160224
    }
]