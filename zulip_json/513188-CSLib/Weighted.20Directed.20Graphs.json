[
    {
        "content": "<p>Hi all, I'm interested in verifying properties of graph algorithms (e.g., shortest path) where both edge weights and directions are essential. While exploring Mathlib's graph definitions, I noticed that none of the existing structures fully capture what I need:</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/Graph/Basic.html#Graph\"><code>Graph</code></a>: weighted and but undirected</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/Digraph/Basic.html#Digraph\"><code>DiGraph</code></a>: directed but unweighted  </li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/SimpleGraph/Basic.html#SimpleGraph\"><code>SimpleGraph</code></a>: undirected, loopless, and unweighted  </li>\n</ul>\n<p>I'm interested in CS applications, so I started this topic in the CSLib channel to ask:  <br>\nWould there be interest in modifying one of these definitions or introducing a new one that supports both directionality and edge weights?</p>\n<p>To make this more concrete, I'm envisioning something along the lines of:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">WeightedDirectedGraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The adjacency relation of a digraph. -/</span>\n<span class=\"w\">  </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>This is similar to <code>DiGraph</code>, but allows edge identifiers (or weights) via <code>β</code>. Alternatively, a more elaborate structure inspired by <code>Graph</code> might look like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">WeightedDirectedGraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The binary incidence predicate, stating that `x` and `y` are the ends of an edge `e`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"w\">  </span><span class=\"sd\">/-- The vertex set. -/</span>\n<span class=\"w\">  </span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span>\n\n<span class=\"w\">  </span><span class=\"sd\">/-- The edge set. -/</span>\n<span class=\"w\">  </span><span class=\"n\">edgeSet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{(</span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">}</span>\n\n<span class=\"w\">  </span><span class=\"sd\">/-- An edge `e` is incident to `x` and `y` if and only if `(e, x, y)` is in the edge set. -/</span>\n<span class=\"w\">  </span><span class=\"n\">edge_mem_iff_exists_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">edgeSet</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Iff.rfl</span>\n\n<span class=\"w\">  </span><span class=\"sd\">/-- If some edge `e` is incident to `x`, then `x ∈ V`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">left_mem_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Or.inl</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"w\">  </span><span class=\"sd\">/-- If some edge `e` is incident to `y`, then `y ∈ V`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">right_mem_of_isLink</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">IsLink</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">vertexSet</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Or.inr</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">⟩⟩</span>\n</code></pre></div>\n<p>This version is closer in spirit to <code>Graph</code>, but adapted for directed edges and edge data. I'd like to hear thoughts on whether this fits within CSLib's (or Mathlib's) scope or if there's an existing effort I could contribute to.</p>",
        "id": 543712431,
        "sender_full_name": "Abdalrhman M Mohamed",
        "timestamp": 1759919753
    },
    {
        "content": "<p>This seems like it could be represented by an auxiliary definition instead of being a part of the graph structure—could weights be an edge labeling a la <a href=\"https://github.com/leanprover-community/mathlib4/pull/30047\">#30047</a>?</p>",
        "id": 543716480,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1759921025
    },
    {
        "content": "<p>Thanks for pointing me to <a href=\"https://github.com/leanprover-community/mathlib4/pull/30047\">#30047</a>. I hadn't seen it before! That approach definitely seems promising, especially since it avoids major refactoring of existing graph definitions.</p>\n<p>That said, I do wonder about potential fragmentation: if we keep layering auxiliary structures or wrappers, we might end up with several parallel graph definitions that don't interoperate easily. Ideally, we'd be able to reuse algorithms written for more general graph types (e.g., weighted, directed) when working with specialized ones. I'd love to explore whether there's a clean way to unify these representations or at least ensure good composability across them.</p>",
        "id": 543728037,
        "sender_full_name": "Abdalrhman M Mohamed",
        "timestamp": 1759924571
    },
    {
        "content": "<p>Doesn't using a definition on top of an existing graph _avoid_ parallel definitions?</p>",
        "id": 543742479,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1759928520
    },
    {
        "content": "<p>That said, I definitely find the current situation in Mathlib sub-optimal, preferably SimpleGraph would be a specialization and all of it's basic infrastructure would be shared with e.g. Digraph. I'm sure there has been previous discussion about this but I have not invested the time to find and go through it</p>",
        "id": 543742639,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1759928569
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"761203\">Vlad Tsyrklevich</span> <a href=\"#narrow/channel/513188-CSLib/topic/Weighted.20Directed.20Graphs/near/543742479\">said</a>:</p>\n<blockquote>\n<p>Doesn't using a definition on top of an existing graph _avoid_ parallel definitions?</p>\n</blockquote>\n<p>Yes, this does help avoid completely separate implementations and redundant code. We wouldn't need to reimplement all the operations already available in <code>DiGraph</code> for a graph with edge labels.</p>\n<p>That said, I'm thinking about this from a generality perspective. Conceptually, <code>DiGraph</code> could be seen as a special case of a weighted graph where the edge type is <code>Unit</code> and <code>SimpleGraph</code> is a structure that extends <code>DiGraph</code> with symmetry and loopless properties. Many algorithms designed for weighted graphs (like shortest path) work just as well for unweighted graphs. Ideally, we'd have a unified implementation of these algorithms (say, for a general weighted directed graph) that can be reused seamlessly by <code>DiGraph</code>, <code>Graph</code>, and <code>SimpleGraph</code>, along with their associated properties.</p>\n<p>I agree with your second point: the current fragmentation in Mathlib is somewhat suboptimal. I haven't dug into past discussions either (will do so when I have when I have more free time), but I'd be interested in exploring ways to move toward that kind of unification.</p>",
        "id": 543787877,
        "sender_full_name": "Abdalrhman M Mohamed",
        "timestamp": 1759940271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"761203\">Vlad Tsyrklevich</span> <a href=\"#narrow/channel/513188-CSLib/topic/Weighted.20Directed.20Graphs/near/543742639\">said</a>:</p>\n<blockquote>\n<p>That said, I definitely find the current situation in Mathlib sub-optimal, preferably SimpleGraph would be a specialization and all of it's basic infrastructure would be shared with e.g. Digraph. I'm sure there has been previous discussion about this but I have not invested the time to find and go through it</p>\n</blockquote>\n<p><a class=\"stream\" data-stream-id=\"252551\" href=\"/#narrow/channel/252551-graph-theory\">#graph theory</a>  is the place, e.g. <a class=\"stream-topic\" data-stream-id=\"252551\" href=\"/#narrow/channel/252551-graph-theory/topic/.28Undirected.29.20hypergraphs/with/539077486\">#graph theory &gt; (Undirected) hypergraphs</a> </p>\n<p>The current state of graphs is quite a mess, but if cslib diverges instead of contributing to Mathlib it'll be an even bigger mess :(</p>",
        "id": 544167282,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1760102117
    },
    {
        "content": "<p>I don't recall where I had the discussion on graphs before, exactly. But there seem to be two flavours of definitions - one suitable if you want to prove theorems about a graph that is fixed, and one that is more suitable if you want to prove theorems about graph transformations. We will probably run into that in CSLib in exactly the same way, so it makes sense to at least understand what happened in Mathlib.</p>",
        "id": 544329159,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1760196457
    },
    {
        "content": "<p>There was also some discussion of the mess at <a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/channel/116395-maths/topic/Graph.20Minors/with/544174095\">#maths &gt; Graph Minors</a></p>",
        "id": 544400601,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1760275627
    }
]