[
    {
        "content": "<p>See <a href=\"https://github.com/leanprover/cslib/pull/111\">cslib#111</a>.  Your comments will be appreciated.</p>",
        "id": 545119140,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1760558905
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span>:  Thanks a lot for the comments!  I'll incorporate them.  As a practical matter, how did you spot all those opportunities for using <code>grind</code> to shorten the proofs?  That's a skill I'd like to acquire.</p>",
        "id": 545425995,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1760640953
    },
    {
        "content": "<p>No problem. Here's a bit of a checklist of what I do:</p>\n<ul>\n<li>First write everything without grind annotations</li>\n<li>Begin by working backwards from each branch of the proof</li>\n<li>add <code>=</code> annotations to definitions and notation lemmas, which are probably safe</li>\n<li>Try backing up from anything that uses <code>exact</code>, <code>cases</code>, <code>congr</code>, etc.</li>\n<li>Try replacing <code>simp</code> and <code>rw</code> with <code>grind</code>.</li>\n<li>In cases where it's not possible to generate have a grind rule, you can use <code>have</code> beforehand to fill in arguments <code>grind</code> can't infer, but can use if you place in the local context</li>\n<li>Think about what <a href=\"https://lean-lang.org/doc/reference/latest/The--grind--tactic/E___matching/#e-matching\">E-matching</a> you might need if an inferred pattern doesn't work. <code>→</code> and <code>=&gt;</code> are commonly helpful for inferring \"forward\" steps</li>\n<li>If the <code>grind</code> rules for each branch are reasonably overlapping, you can have have something like <code>induction ... &lt;;&gt; grind [...]</code></li>\n<li>Similarly for existentials after you <code>refine</code> for data <code>grind</code> won't infer</li>\n<li>Finally, consider what lemmas are reasonably general enough and useful to add annotations to. Be careful of anything with a danger of recursion</li>\n</ul>",
        "id": 545446888,
        "sender_full_name": "Chris Henson",
        "timestamp": 1760649995
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> I've recently switched from that approach to trying grind first. If it fails, I start writing the most obvious proof structure and try grind for every goal. Once I finally hit a place where grind works, I start going backwards and inspect why grind wasn't able to prove that goal. This often leads me to general lemmas that should really be proven separately and annotated with grind. Sometimes I manage to make everything a single call to grind, or a call to induction and then grind.</p>",
        "id": 546028205,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760977771
    },
    {
        "content": "<p>(Recently as in a few weeks ago.. I really like grind doing the work for me. :⁠-⁠P)</p>",
        "id": 546028417,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760977817
    },
    {
        "content": "<p>That seems reasonable too. One tangentially related point of pain is if a proof with <code>grind</code> later breaks and you've forgotten the regular proof structure. I've been saved a couple of times by being able to view the full proof in the commit history.</p>",
        "id": 546030352,
        "sender_full_name": "Chris Henson",
        "timestamp": 1760978327
    },
    {
        "content": "<p>And I agree, I am having a good experience so far. I am interested to try out the interactive mode being developed and see if that reshapes my strategies.</p>",
        "id": 546030411,
        "sender_full_name": "Chris Henson",
        "timestamp": 1760978340
    },
    {
        "content": "<p>I just noticed that the Greek letter <code>φ</code> is used to denote the Euler totient function in the <code>Nat</code> namespace. Since the theory developed in Cslib/Foundations/Data/Nat/Segment.lean is also in the <code>Nat</code> namespace, its use of <code>φ</code> as a function name is potentially dangerous. So I have made a PR (<a href=\"https://github.com/leanprover/cslib/pull/116\">cslib#116</a>) to replaces all occurrences of <code>φ</code> by <code>f</code> and all previous occurrences of <code>f</code> by <code>g</code>.  Could you review it?  Thanks in advance!</p>",
        "id": 546352426,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761097601
    }
]