[
    {
        "content": "<p>Let's continue CSlib-specific discussion from <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/Deriving.20dot.20notation.20from.20class.20instances/with/554505554\">#Is there code for X? &gt; Deriving dot notation from class instances</a> here.</p>",
        "id": 554506142,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762630973
    },
    {
        "content": "<p>If desired, I can look at the discussed extension of creating an <code>abbrev</code> for each compatible field (this seems not hard). An attribute is straightforward because it was already written in <code>MetaM</code>. There should hopefully be no concern of problems with <code>grind</code> because these are <code>abbrev</code>s.</p>\n<p>I do think <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> has a point about complexity. I think it got obscured by being too entwined with the specifics of <code>Acceptor</code> and I wouldn't phrase it as \"extending Lean\", but in general we should weigh the maintenance of meta code with its benefit. I am hesitant when the upside is additional dot notation. I also think when writing meta code that creates declarations it is good to think about the user experience.</p>",
        "id": 554507542,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762632450
    },
    {
        "content": "<p>There are two discussions at play here.</p>\n<ol>\n<li>Whether having an Acceptor typeclass to establish a common interface (guarantee the same def names), reuse code (for now not much but might expand in the future, e.g., when finiteness assumptions are given as parameters), and force that things (like language) are defined in the same way.</li>\n<li>Whether we sometimes wanna have dot notation when using typeclasses. More specifically, as in this case, when we're basically using a class instance to implement a trait/interface with default methods a-la OOP, where people are used to get dot notation.</li>\n</ol>\n<p>This triggered my curiosity to explore whether a programmatic solution for (2) can be provided, to support the pattern.</p>\n<p><span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> had some doubts about whether having Acceptor is worth it, so the discussions got mixed. Also, (1) is specific whereas (2) is a much more general point.</p>\n<p>I see value in doing (1) even without doing (2). See the points I list in (1), and there are already 7 instances of Acceptor (I'm gonna merge it with OmegaAcceptor). So I think it's worth a shot. We can always revert it to having duplicated code if it doesn't pay off.</p>",
        "id": 554508850,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762634006
    },
    {
        "content": "<p>Yes, my hope was to untangle these two things a bit. My inclination is also to try (1) and leave (2) on the table for later.</p>",
        "id": 554509279,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762634427
    },
    {
        "content": "<p>The current alternatives are all conveniently available in different PRs:</p>\n<ul>\n<li><a href=\"https://github.com/leanprover/cslib/pull/142\">cslib#142</a> is a design without the \"acceptor\" classes, where the definition <code>language</code> and the theorem <code>mem_language</code> are directly on each of the 6 possible combinations of {DA,NA}.{FinAcc,Buchi,Muller}.</li>\n<li><a href=\"https://github.com/leanprover/cslib/pull/144\">cslib#144</a> is a design with the \"acceptor\" classes, where <code>language</code> and <code>mem_language</code> are only in the \"acceptor\" file, but we end up having to write an expression like <code>Cslib.Automata.Acceptor.language nfa = l</code> rather than the much shorter <code>nfa.language = l</code>, or <code>Acceptor.language na.toDAFinAcc = Acceptor.language na</code> rathe than <code>na.toDAFinAcc.language  = na.language</code>.</li>\n<li><a href=\"https://github.com/leanprover/cslib/pull/145\">cslib#145</a> is a modification of <a href=\"https://github.com/leanprover/cslib/pull/144\">cslib#144</a>, where I added back  the definition <code>language</code> and the theorem <code>mem_language</code> for each of the 6 possible combinations of {DA,NA}.{FinAcc,Buchi,Muller}.  (To be sure, I did only {DA,NA}.{FinAcc} in the PR so far, but the idea is to do it for all six combinations.). So we get the shorter, more readable expressions back at the expense of the same additional code as in <a href=\"https://github.com/leanprover/cslib/pull/142\">cslib#142</a> (on top of the code for the \"acceptor\" classes).</li>\n</ul>",
        "id": 554519124,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762644943
    },
    {
        "content": "<p>Here's my suggestion: we go for <a href=\"https://github.com/leanprover/cslib/pull/145\">cslib#145</a>, so that we can actually start developing some automata theory, in which we can use natural notations like <code>nfa.language</code>.  In the meantime, if <span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> is so inclined, he can pursue using Lean metaprogramming to eliminate the duplicated code.  The duplicated code is localized and can be easily removed with a new PR.  On the other hand, if that approach proves unsuccessful, the acceptor code can also be easily removed because of the presence of the duplicated code.</p>",
        "id": 554520108,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762646075
    },
    {
        "content": "<p>The approach above has the advantage that the development of automata theory is not held up by the finer points in automata representation.  It has the additional advantage that as the code base of automata theory grows, the metaprogramming code will get more test cases and reality checks as it is being developed.</p>",
        "id": 554520554,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762646480
    },
    {
        "content": "<p>I think the situation is much better than you think:</p>\n<p>Some of the problems you mention are just scoping issues. Here's how you can make the code look nice: <a href=\"https://github.com/leanprover/cslib/pull/144/commits/45a57cd5855915eafbbecad6be899e211846f563\">https://github.com/leanprover/cslib/pull/144/commits/45a57cd5855915eafbbecad6be899e211846f563</a></p>\n<p>The actual problem is really if we want so hard to be able to write <code>nfa.language</code> instead of <code>language nfa</code>. The same problem arises in many parts of Lean. If it is so important, I think that the right way of doing it is to just add this single line (with the right parameter type) for each of the 7 instances:</p>\n<p><code>abbrev language (a : FinAcc State Symbol) := Acceptor.language a</code></p>\n<p>This gives dot notation for language. There's no need to do the same for the theorems, since grind will find them (by expanding the abbrev automatically; I've tested this: the proofs work with no modifications) and even when we reference them manually in general we should refer to theorems under the class namespace (to elicit in the proof that we're using a shared concept; this is a general observation, independent from Acceptor).</p>\n<p>In summary:</p>\n<ul>\n<li>We can write simple things like <code>language nfa</code>.</li>\n<li>If we want <code>nfa.language</code>, it's just one line away.</li>\n</ul>\n<p>I'll add the abbrevs to <a href=\"https://github.com/leanprover/cslib/pull/144\">cslib#144</a>, so that we get dot notation for <code>language</code> and we can go ahead with more stuff on automata. Is that reasonable, aestethics-wise?</p>",
        "id": 554538742,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762669625
    },
    {
        "content": "<p>I personally would prefer just writing <code>language nfa</code>. For me the simplicity of fewer declarations outweighs the very slight benefit of dot notation. As you say, once you open the scope they are nearly identical already.</p>",
        "id": 554539059,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762669978
    },
    {
        "content": "<p>Yes and in this case <code>language a</code> reads quite nicely as 'the language of a'.</p>",
        "id": 554539328,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762670243
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>  Please test your <code>abbrev</code> based dot-notation on the following example.  I have verified that the <code>language ...</code> + <code>open ... in</code> version works.  The files that Regular.lean imports plus Cslib.Computability.Automata.OmegaAcceptor should provide all the definitions needed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State1</span><span class=\"w\"> </span><span class=\"n\">State2</span><span class=\"w\"> </span><span class=\"n\">State3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">a1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">FinAcc</span><span class=\"w\"> </span><span class=\"n\">State1</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">Buchi</span><span class=\"w\"> </span><span class=\"n\">State2</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">Buchi</span><span class=\"w\"> </span><span class=\"n\">State3</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">a1</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a2</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a3</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 554544289,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762675263
    },
    {
        "content": "<p>If the example works, I think the solution is good enough and we can move on.</p>",
        "id": 554544443,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762675410
    },
    {
        "content": "<p>Yes, it works as expected.</p>\n<p>This also works btw, with no need for weird parentheses:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"n\">ωAcceptor</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State1</span><span class=\"w\"> </span><span class=\"n\">State2</span><span class=\"w\"> </span><span class=\"n\">State3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">a1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">FinAcc</span><span class=\"w\"> </span><span class=\"n\">State1</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">Buchi</span><span class=\"w\"> </span><span class=\"n\">State2</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">Buchi</span><span class=\"w\"> </span><span class=\"n\">State3</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">a1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">a2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">a3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>And, just for curiosity, statements and proofs seem to work unaffected even when the two styles are mixed (but  we should never do this!):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"sd\">/-- The `DA` constructed from an `NA` has the same language. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">scoped</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toDAFinAcc_language_eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">na</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"bp\">.</span><span class=\"n\">FinAcc</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">na</span><span class=\"bp\">.</span><span class=\"n\">toDAFinAcc</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">na</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>",
        "id": 554556457,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762688592
    },
    {
        "content": "<p>I've been trying to find examples of similar approaches to the <code>abbrev</code> here, and this seems to be one: <a href=\"https://github.com/leanprover-community/mathlib4/blob/29692a968705f26dc0f7432961647c38f620ae1f/Mathlib/Order/Category/DistLat.lean#L60\">https://github.com/leanprover-community/mathlib4/blob/29692a968705f26dc0f7432961647c38f620ae1f/Mathlib/Order/Category/DistLat.lean#L60</a></p>\n<p>(The ones pointed out in the github thread so far are slightly different from what we're doing here.)</p>",
        "id": 554557609,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762689914
    },
    {
        "content": "<p>There's a little more going on there than just dot notation, not sure I would take that as an example.</p>",
        "id": 554558713,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762691088
    },
    {
        "content": "<p>Testing the abbrev solution. It all works but there's a subtle effect worth pointing out.</p>\n<p>With all abbrevs in place, we cannot use the normal 'class syntax with open' discussed previously in some situations any longer. For example this gives an error</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">εNA</span><span class=\"bp\">.</span><span class=\"n\">FinAcc</span>\n<span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toNAFinAcc_language_eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ena</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">εNA</span><span class=\"bp\">.</span><span class=\"n\">FinAcc</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">ena</span><span class=\"bp\">.</span><span class=\"n\">toNAFinAcc</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ena</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>This gives an error for <code>language ena.toNAFinAcc</code>, because <code>language</code> now exists under <code>Automata.εNA.FinAcc</code> and therefore takes priority over instance resolution. One has then to write <code>Acceptor.language ena.toNAFinAcc</code> explicitly (then it works).</p>\n<p>So if one wants to use the non-dot syntax, this looks like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">εNA</span><span class=\"bp\">.</span><span class=\"n\">FinAcc</span>\n<span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toNAFinAcc_language_eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ena</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">εNA</span><span class=\"bp\">.</span><span class=\"n\">FinAcc</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Acceptor</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">ena</span><span class=\"bp\">.</span><span class=\"n\">toNAFinAcc</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">ena</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>So the price to pay for dot notation here is that if one wants to use normal function application notation, it gets a bit worse.</p>",
        "id": 554558780,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762691147
    },
    {
        "content": "<p>I think that pretty much settles the case against those <code>abbrev</code>, just not worth it IMO.</p>",
        "id": 554558953,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762691327
    },
    {
        "content": "<p>Yes, <code>language a</code> without the abbrev seems to be a better path towards choosing the 'right' language def. Let's go ahead with that for now. PR updated (and I've dealt with the other comments).</p>\n<p>I suggest we merge and get back to working on results about LTS and automata theory for now. I see more stuff in LTS that should really become a class, it'll provide further food for thought later.</p>",
        "id": 554560824,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762693379
    },
    {
        "content": "<p>I am at the current \"main\" and I want to prove the following theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Computability</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">DA</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">DA</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"n\">ωAcceptor</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">scoped</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">_=_</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">buchi_eq_finAcc_omegaLim</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Buchi</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FinAcc</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">))</span><span class=\"bp\">↗</span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">DA</span>\n</code></pre></div>\n<p><code>rintro</code> does not work at the first <code>sorry</code>.  What can I do to unpack the LHS?</p>",
        "id": 554598357,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762729286
    },
    {
        "content": "<p>The following works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Filter</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Computability</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">FLTS</span>\n<span class=\"w\">  </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">ωAcceptor</span>\n<span class=\"w\">  </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">FinAcc</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">Buchi</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">DA</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"n\">ωAcceptor</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">scoped</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">_=_</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">buchi_eq_finAcc_omegaLim</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Buchi</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FinAcc</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">))</span><span class=\"bp\">↗</span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃ᶠ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">atTop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But if I have to explicitly state the intermediate result (<code>∃ᶠ k in atTop, da.run xs k ∈ acc</code>) every time I need it, then the supposed saving from eliminating the \"duplicated code\" is just illusory, isn't it?</p>\n<p>Furthermore, I have to <code>open scoped</code> a bunch of namespaces to make <code>grind</code> work.  To be sure, the above list of <code>open scoped</code> is not the minimal list.  But how should I figure out what the minimal list is?</p>",
        "id": 554599462,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762730266
    },
    {
        "content": "<p>I've very much skimmed this thread, but one advantage of having <code>language dfa</code> and <code>language nfa</code> is you have then have a typeclass that says <code>language (n1 + n2) = language n1 + language n2</code> or similar, with instances for all sorts of automata</p>",
        "id": 554603221,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762733993
    },
    {
        "content": "<p>Let me try to separate out your questions <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> </p>\n<blockquote>\n<p><code>rintro</code> does not work at the first <code>sorry</code>. What can I do to unpack the LHS?</p>\n</blockquote>\n<p>It is not clear to me what kind of  pattern you want here, could you explain?</p>\n<blockquote>\n<p>But if I have to explicitly state the intermediate result (<code>∃ᶠ k in atTop, da.run xs k ∈ acc</code>) every time I need it, then the supposed saving from eliminating the \"duplicated code\" is just illusory, isn't it?</p>\n</blockquote>\n<p>I believe this is just missing API, as what you've written here is equal to the hypothesis. To be explicit, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Cslib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"w\"> </span><span class=\"n\">Automata</span><span class=\"w\"> </span><span class=\"n\">ωAcceptor</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">Buchi</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">toDA</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">toDA</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Buchi</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">∃ᶠ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">atTop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toDA</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>If you would like this to be inferred by <code>grind</code>, add this and annotate it as a forward rule as I have done above.</p>\n<blockquote>\n<p>Furthermore, I have to <code>open scoped</code> a bunch of namespaces to make <code>grind</code> work. To be sure, the above list of <code>open scoped</code> is not the minimal list. But how should I figure out what the minimal list is?</p>\n</blockquote>\n<p>I don't have a great answer to this. I don't believe there is a way to minimize <code>open scoped</code> in this way. As I described earlier, I would probably just write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Computability</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"w\"> </span><span class=\"n\">FLTS</span><span class=\"w\"> </span><span class=\"n\">Automata</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"n\">ωAcceptor</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">FinAcc</span><span class=\"w\"> </span><span class=\"n\">Buchi</span>\n</code></pre></div>\n<p>for brevity at the onset.</p>",
        "id": 554605666,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762736412
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span>  Your theorem <code>foo</code> is basically one direction of the theorem <code>mem_language</code> specialized to DA.Buchi.  If I have to prove that theorem as an API lemma anyway, what \"code deduplication\" has this whole business of \"acceptor\" achieved anywy?  We could have taken the route in <a href=\"https://github.com/leanprover/cslib/pull/142\">cslib#142</a> and end up with the same amount of code (actually less code, because there wouldn't be separate <code>Acceptor</code> and <code>ωAcceptor</code> classes) and we wouldn't need to <code>open Acceptor ωAcceptor</code> before <code>language</code> can be used without qualifiers (because each of {DA,NA}.{FinAcc,Buchi,Muller} has its own <code>language</code> method and the dot-notation can be used).</p>",
        "id": 554609548,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762740253
    },
    {
        "content": "<p>Put another way, if I have to state and prove he following theorem (or some version of it) explicitly anyway:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">ωAcceptor</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mem_language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Buchi</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃ᶠ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">atTop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>what \"code deduplication\" have the \"acceptors\" bought us?  I could have defined <code>DA.Buchi.language</code> and proved the above theorem and dispensed with the annoying <code>open ωAcceptor in</code> by using the dot-notation.  The only \"duplicated\" code is the definition of <code>DA.Buchi.language</code>, which is just one or two lines anyway.  In the end,  because we don't need \"acceptors\" anymore, we end up with fewer files and about the same number of lines of code.  And a reader of the code has one fewer concept to comprehend.</p>",
        "id": 554611017,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762741774
    },
    {
        "content": "<p>I guess I am not seeing exactly why you need that <code>have</code> or the seperate theorem you've written. Is the rest of that proof branch short enough that you could finish it to demonstrate what <code>grind</code> isn't picking up?</p>\n<p>I'll leave the more general decisions about <code>Acceptor</code> to you and Fabrizio. I believe the intent in merging <a href=\"https://github.com/leanprover/cslib/pull/144\">cslib#144</a> was to move past this design discussion so you could continue actually working on automata. If after some further work you still feel it is not adding anything, we can certainly remove <code>Acceptor</code>. I think it is just a bit easier to see this with some concrete downstream proofs in place rather than rehashing the discussion beforehand.</p>",
        "id": 554612392,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762743100
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/513188-CSLib/topic/deriving.20dot.20notation/near/554612392\">said</a>:</p>\n<blockquote>\n<p>I guess I am not seeing exactly why you need that <code>have</code> or the seperate theorem you've written. Is the rest of that proof branch short enough that you could finish it to demonstrate what <code>grind</code> isn't picking up?</p>\n</blockquote>\n<p>Please tell me how I can make progress in proving <code>buchi_eq_finAcc_omegaLim</code> if I don't have the <code>have</code> or a separate theorem like <code>mem_language</code>.  How do I transform the LHS of <code>buchi_eq_finAcc_omegaLim</code> into something I can use?  We have a similar problem for the RHS as well.</p>",
        "id": 554612558,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762743288
    },
    {
        "content": "<p>I am not necessarily contradicting this, I am just saying it would be helpful for me to the rest of the proof (with the <code>have</code>) to better understand the problem.</p>",
        "id": 554612911,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762743613
    },
    {
        "content": "<p>Consider the following partial proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"n\">ωAcceptor</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">scoped</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">_=_</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">buchi_eq_finAcc_omegaLim</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Buchi</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FinAcc</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">))</span><span class=\"bp\">↗</span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Buchi</span><span class=\"bp\">.</span><span class=\"n\">mem_language</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Frequently</span><span class=\"bp\">.</span><span class=\"n\">mono</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">h_n</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FinAcc</span><span class=\"bp\">.</span><span class=\"n\">mem_language</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Just before the first <code>sorry</code>, the tactic state looks like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span>\n<span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span>\n<span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span>\n<span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">Symbol</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃ᶠ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">atTop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n<span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">h_n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">mtr</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">extract</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n</code></pre></div>\n<p>Now if we comment out the two <code>simp</code>s, the tactic state just before the first <code>sorry</code> looks like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span>\n<span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span>\n<span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span>\n<span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">Symbol</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ωAcceptor</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">toDA</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">h_n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"w\"> </span><span class=\"n\">toDA</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">toDA</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">accept</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">extract</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">toDA</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>The second tactic state is much less readable than the first one, isn't it?  Upon seeing the first tactic state, you immediately see that the proof boils down to showing that <code>da.mtr da.start (xs.extract 0 n) = (da.run xs) n</code>.  Would you be able to see that from the second tactic state?  I can't.  To be sure, the two <code>simp</code>s may end up being not strictly necessary in the end, but they surely help, don't they?  Which means that I need to prove  the <code>mem_language</code> lemmas for <code>DA.FinAcc</code> and <code>DA.Buchi</code>, just to keep myself sane when doing proofs.  Now if I need those lemmas explicitly, then the whole \"code deduplication\" argument is just illusory, isn't it?</p>",
        "id": 554615864,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762746179
    },
    {
        "content": "<p>Instead of <code>simp only [Buchi.mem_language]</code> you do <code>simp only [ωAcceptor.mem_language]</code>, and if you wanna reveal the definition of Accepts, you do <code>simp only [ωAcceptor.mem_language, ωAcceptor.Accepts]</code>.</p>\n<p>So for example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"n\">ωAcceptor</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">scoped</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">_=_</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">buchi_eq_finAcc_omegaLim</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Buchi</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FinAcc</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">))</span><span class=\"bp\">↗</span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ωAcceptor</span><span class=\"bp\">.</span><span class=\"n\">mem_language</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ωAcceptor</span><span class=\"bp\">.</span><span class=\"n\">Accepts</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Frequently</span><span class=\"bp\">.</span><span class=\"n\">mono</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">h_n</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Acceptor</span><span class=\"bp\">.</span><span class=\"n\">mem_language</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"bp\">.</span><span class=\"n\">Accepts</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>which takes you to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span>\n<span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span>\n<span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span>\n<span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">Symbol</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃ᶠ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">atTop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n<span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">h_n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">mtr</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">extract</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n</code></pre></div>\n<p>which is what you want.</p>",
        "id": 554622476,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762751918
    },
    {
        "content": "<p>I didn't mention that I actually have @[simp] annotation on the lemmas <code>DA.FinAcc.mem_language</code> and <code>DA.Buchi.mem_language</code>.  So <code>simp</code> alone already does the job for me.  Then <code>simp?</code> told me exactly which <code>simp</code> lemmas are used and I got the <code>simp only</code> with a single click.  I tried putting @[simp] annotations on both <code>language</code> and <code>mem_language</code> in both Acceptor.lean and OmegaAcceptor.lean (and removed the @[simp] annotation on <code>DA.FinAcc.mem_language</code> and <code>DA.Buchi.mem_language</code>).  This is how far <code>simp</code> can get me with that approach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span>\n<span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span>\n<span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span>\n<span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">Symbol</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ωAcceptor</span><span class=\"bp\">.</span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">toDA</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">}</span>\n<span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">h_n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"w\"> </span><span class=\"n\">toDA</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">toDA</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">accept</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">extract</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"bp\">.</span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">toDA</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Not very useful, is it?</p>\n<p>Furthermore, lemmas like <code>DA.FinAcc.mem_language</code> and <code>DA.Buchi.mem_language</code> can be used in more ways than just by <code>rw</code> or <code>simp</code>.  For example, I can get their <code>mp</code> or <code>mpr</code> direction and use that implication in forward or backward reasoning.  How am I supposed to do that if I don't have those lemmas already proved?</p>",
        "id": 554645233,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762764359
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 554673117,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762772961
    },
    {
        "content": "<p>If you want simp to help you you can just annotate these things. Here's how to do it post-definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ωAcceptor</span><span class=\"bp\">.</span><span class=\"n\">mem_language</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">Buchi</span><span class=\"bp\">.</span><span class=\"n\">instωAcceptor</span>\n</code></pre></div>\n<p>As for the second question, can't you do it in the usual way? I tested this in your proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ωAcceptor</span><span class=\"bp\">.</span><span class=\"n\">mem_language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Buchi</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span>\n<span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ωAcceptor</span><span class=\"bp\">.</span><span class=\"n\">mem_language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Buchi</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n</code></pre></div>",
        "id": 554683790,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762776299
    },
    {
        "content": "<p>Is that your idea of \"code deduplication\"?   If I need the <code>mp</code> direction 3 times and the <code>mpr</code> direction 2 times, I'll (basically) re-prove <code>DA.Buchi.mem_language</code> 5 times.  And every time I do it, I'll just reconstruct in my mind what the theorem I'm proving actually looks like.  As to your suggestion about <code>simp</code>, it doesn't really work.  I played with it and the best it can do is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span>\n<span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span>\n<span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span>\n<span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">Symbol</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃ᶠ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">atTop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">}</span>\n<span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">h_n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">extract</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"bp\">.</span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">toDA</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Also note that the name <code>instωAcceptor</code> is an instance name generated by Lean.</p>\n<p>Anyway, I'm putting the <code>mem_language</code> lemmas back.  It is me who's doing the proofs and I'll do them in a way that is most comfortable to me.</p>",
        "id": 554758369,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762796496
    },
    {
        "content": "<p>That's weird, it worked for me by writing simp at the beginning of the relevant case. What does your proof look like?</p>",
        "id": 554759233,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762796785
    },
    {
        "content": "<p>You need to add:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">Acceptor</span><span class=\"bp\">.</span><span class=\"n\">mem_language</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">FinAcc</span><span class=\"bp\">.</span><span class=\"n\">instAcceptor</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">ωAcceptor</span><span class=\"bp\">.</span><span class=\"n\">mem_language</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">Buchi</span><span class=\"bp\">.</span><span class=\"n\">instωAcceptor</span>\n</code></pre></div>\n<p>to make everything work.</p>\n<p>As I wrote above, I'm putting the <code>mem_language</code> lemmas back.  I'm not going to spend my days going through level upon level of indirection just to prove some painfully obvious facts implicitly.  I'll keep my proofs simple and stupid by explicitly spelling out those painfully obvious facts.  Life is too short and I want to get on with doing some actual development of automata theory.</p>",
        "id": 554771891,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762801381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/deriving.20dot.20notation/near/554771891\">said</a>:</p>\n<blockquote>\n<p>You need to add:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">Acceptor</span><span class=\"bp\">.</span><span class=\"n\">mem_language</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">FinAcc</span><span class=\"bp\">.</span><span class=\"n\">instAcceptor</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">ωAcceptor</span><span class=\"bp\">.</span><span class=\"n\">mem_language</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Automata</span><span class=\"bp\">.</span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">Buchi</span><span class=\"bp\">.</span><span class=\"n\">instωAcceptor</span>\n</code></pre></div>\n<p>to make everything work.</p>\n<p>As I wrote above, I'm putting the <code>mem_language</code> lemmas back.  I'm not going to spend my days going through level upon level of indirection just to prove some painfully obvious facts implicitly.  I'll keep my proofs simple and stupid by explicitly spelling out those painfully obvious facts.  Life is too short and I want to get on with doing some actual development of automata theory.</p>\n</blockquote>\n<p>I still don't get what the problem is with just putting a @[simp] over precisely those definitions (instances included, you can annotate them), since that's what you're doing elsewhere.</p>\n<p>My example with 'attribute' was to keep it self-contained.</p>",
        "id": 554772395,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762801591
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>  You claim that having \"acceptors\" would lead to \"code deduplication\".  But with all the @[simp] annotations, <code>open scoped Acceptor</code> lines to allow <code>language</code> to be used without qualifiers, and the overhead of the \"acceptor\" code itself (Acceptor.lean and OmegaAcceptor.lean), are you actually reducing the lines of code overall?  Sure, you'll have fewer explicit definitions and theorems (6 <code>language</code> definitions and 6 <code>mem_langauge</code> theorems, to be precise).  But when you end up writing things like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ωAcceptor</span><span class=\"bp\">.</span><span class=\"n\">mem_language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Buchi</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span>\n</code></pre></div>\n<p>you are essentially proving the theorem <code>DA.Buchi.mem_language</code> on the fly.  Why not prove it once and for all and refer to it later?  After all, there are only 6 such theorems.  Perhaps you are smart enough to see the line above and know immediately that it is the following theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∃ᶠ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">atTop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">accept</span>\n</code></pre></div>\n<p>I'm not that smart, and I suspect most future readers of the code are not that smart, either.</p>\n<p>And does the \"acceptor\" actually offer any abstraction at a conceptual level?  If you read the code and strip away all irrelevant details, you'll see that an \"acceptor\" consists of three things:</p>\n<ul>\n<li>A predicate <code>P</code></li>\n<li>A set defined by the predicate <code>P</code>:  <code>s := { x | P x }</code></li>\n<li>A theorem relating <code>P</code> and <code>s</code>: <code>x ∈ s ↔ P x</code></li>\n</ul>\n<p>That's it.  I am highly skeptical that any useful conceptual abstraction can be gotten out of that meager set of data.  I also don't think that explicitly spelling out each instance of \"acceptor\" (and there are only 6 of them) makes the code unnecessarily redundant or duplicative or harder to understand.</p>",
        "id": 554779461,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762804341
    },
    {
        "content": "<p>Maybe this will help the discussion. I've taken your <a href=\"https://github.com/leanprover/cslib/pull/152\">cslib#152</a> and made it work without the additional lemmas, <em>without</em> (importantly) changing your proofs: <a href=\"https://github.com/leanprover/cslib/commit/a62c4c838f87f77edd2752738d36c892673bac8b\">https://github.com/leanprover/cslib/commit/a62c4c838f87f77edd2752738d36c892673bac8b</a></p>\n<p>(Sidenote: <code>buchi_eq_finAcc_omegaLim</code> can be proven by <code>grind</code> if you open OmegaLanguage, but I think using <code>simp</code> is perfectly fine.)</p>\n<p>Back to the general topic:<br>\nWhat I'm trying to do is to understand if you can keep proving things simply and, at the same time, we can make code easier to review.</p>\n<p>Specifically here, the 'deduplication' given by (Omega)Acceptor that I'm interested in is not so much lines of code. It's more about enforcing that everybody calls the functions <code>language</code> and <code>mem_language</code> always the same, and that they are always defined in the same way. So I'm looking for what in OOP is an interface with default methods, or a trait.</p>\n<p>We can do something else if this leads us to doing stupid things, but for now it still seems fine.<br>\nBtw, if you have  code where I can see the problem with using mp/mpr directions of OmegaAcceptor, please feel free to point me to it. It might happen because of doing a simplification too early (but I'd need to see an example to really have an opinion).</p>\n<p>Q for everyone: Is adding <code>@[simp]</code> to an instance stupid?</p>",
        "id": 556800886,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1763377672
    },
    {
        "content": "<p>Note that I did approve <a href=\"https://github.com/leanprover/cslib/pull/152\">cslib#152</a> based on my review comments being addressed, but I did not intend to bypass this discussion about (Omega)Acceptor.</p>\n<p>I have seen some instances marked as <code>simp</code> in Mathlib, but I'm not sure of best practices around that.</p>",
        "id": 556802895,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763378303
    },
    {
        "content": "<p>No problem, I'm gonna merge <a href=\"https://github.com/leanprover/cslib/pull/152\">cslib#152</a>, I think it's very nice otherwise. I'll then make a PR of my own with the commit above.</p>",
        "id": 556815917,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1763382198
    },
    {
        "content": "<p>Your <a href=\"https://github.com/leanprover/cslib/pull/161\">cslib#161</a>, especially considering it doesn't change any proofs, seems reasonable to me.</p>",
        "id": 556831772,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763386643
    },
    {
        "content": "<p>I tested <a href=\"https://github.com/leanprover/cslib/pull/161\">cslib#161</a> manually at various places and it seems to work.  So I've approved it.</p>",
        "id": 556938389,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1763416986
    }
]