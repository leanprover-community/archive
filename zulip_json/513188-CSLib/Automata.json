[
    {
        "content": "<p>We should discuss a bit the pattern for defining different kinds of automata in CSlib. Preferably, this should be coherent with the way we do semantics (but that way can be updated as well, if we get any new insights here!).</p>\n<p>One way of using what's already there is to define an automaton as a labelled transition system plus all the assumptions we're making about it. For example, a DFA could be defined as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Foundations</span><span class=\"bp\">.</span><span class=\"n\">Semantics</span><span class=\"bp\">.</span><span class=\"n\">Lts</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Dfa</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Label</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"c1\">-- The transition system of the automaton</span>\n<span class=\"w\">  </span><span class=\"n\">lts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lts</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Label</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Start state</span>\n<span class=\"w\">  </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Accept states</span>\n<span class=\"w\">  </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"c1\">-- The automaton is finite-state</span>\n<span class=\"w\">  </span><span class=\"n\">finite_state</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">FiniteState</span>\n<span class=\"w\">  </span><span class=\"c1\">-- The automaton is deterministic</span>\n<span class=\"w\">  </span><span class=\"n\">deterministic</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">Deterministic</span>\n</code></pre></div>\n<p>Pros:<br>\nThis would automatically give the expected notions of traces, multi-step transitions, determinism, divergence, state equivalences, etc., coherent with the other languages in cslib. We have theorems about these things as well, which can be reused across the board. This might also facilitate translations between different structures like this (e.g., from DFA to NFA and vice versa).</p>\n<p>Cons:<br>\nGoing through the <code>Lts</code>type might be weird, so maybe we just wanna put the transition relation in there and provide some magical macro/typeclass. (Not sure what that could be though.)</p>\n<p>What other ways could we go for, in order to promote reuse?</p>",
        "id": 540420886,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758277372
    },
    {
        "content": "<p><code>lts.Deterministic</code> only guarantees uniqueness but not existence, so it's different than a function <code>State → Label → State</code> if that's what you meant</p>",
        "id": 540422604,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1758278014
    },
    {
        "content": "<p>I vote for having both, and providing a way to convert between them:<br>\nI think the structure <code>Dfa</code> should contain a function, and should have <code>def toLts</code> that converts it to an <code>Lts</code>, and theorems showing <code>dfa.toLts.FiniteState</code> and <code>dfa.toLts.Deterministic</code>.<br>\nUsually the variant with the function is easier to handle (e.g. we don't need the axiom of choice to get the next transition) but converting to an <code>Lts</code> is useful to access more theorems, and also to be able to define transitions as <code>Prop</code> which aren't easily definable as a function.<br>\nSimilarly we should be able to convert a <code>Dfa</code> to an <code>Nfa</code> by forgetting the deterministic hypothesis and converting the start state to a singleton set.</p>",
        "id": 540426632,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1758279341
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/540422604\">said</a>:</p>\n<blockquote>\n<p><code>lts.Deterministic</code> only guarantees uniqueness but not existence, so it's different than a function <code>State → Label → State</code> if that's what you meant</p>\n</blockquote>\n<p>Oh, yes, I agree. Mine is just a quick sketch to give an idea.</p>",
        "id": 540432315,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758281230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/540426632\">said</a>:</p>\n<blockquote>\n<p>I vote for having both, and providing a way to convert between them:<br>\nI think the structure <code>Dfa</code> should contain a function, and should have <code>def toLts</code> that converts it to an <code>Lts</code>, and theorems showing <code>dfa.toLts.FiniteState</code> and <code>dfa.toLts.Deterministic</code>.<br>\nUsually the variant with the function is easier to handle (e.g. we don't need the axiom of choice to get the next transition) but converting to an <code>Lts</code> is useful to access more theorems, and also to be able to define transitions as <code>Prop</code> which aren't easily definable as a function.<br>\nSimilarly we should be able to convert a <code>Dfa</code> to an <code>Nfa</code> by forgetting the deterministic hypothesis and converting the start state to a singleton set.</p>\n</blockquote>\n<p>I'd like that. It's much like what I proposed a while ago (having conversion functions), and it'd allow people to Keep Definitions Simple (TM).</p>",
        "id": 540432621,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758281352
    },
    {
        "content": "<p>Gave it a try, how's it looking?</p>\n<p><a href=\"https://github.com/leanprover/cslib/blob/automata/Cslib/Computability/Dfa/Basic.lean\">https://github.com/leanprover/cslib/blob/automata/Cslib/Computability/Dfa/Basic.lean</a></p>",
        "id": 540580112,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758369182
    },
    {
        "content": "<p>Looking good, making <code>toLts</code> a coercion sounds great.</p>\n<p>If I were to nitpick this as a reviewer (which I am not), I have some comments:</p>\n<ul>\n<li><code>toLts_deterministic</code> can be proven as follows:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toLts_deterministic</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dfa</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Dfa</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">dfa</span><span class=\"bp\">.</span><span class=\"n\">toLts</span><span class=\"bp\">.</span><span class=\"n\">Deterministic</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">htr2</span><span class=\"w\"> </span><span class=\"n\">htr3</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">htr2</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">htr3</span>\n</code></pre></div>\n<p>which can be even shorter, but I think it's too far for readability <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toLts_deterministic</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dfa</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Dfa</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">dfa</span><span class=\"bp\">.</span><span class=\"n\">toLts</span><span class=\"bp\">.</span><span class=\"n\">Deterministic</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n</code></pre></div>\n<ul>\n<li><code>language</code> uses a function to define a set, which is discouraged in Mathlib, as the fact that sets are functions is considered an implementation detail. Prefer using <code>{ μs | dfa.Accepts μs }</code> instead.</li>\n<li><code>accepts_mem_language</code> is solved by <code>rfl</code>:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">accepts_mem_language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dfa</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Dfa</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">dfa</span><span class=\"bp\">.</span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">dfa</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<ul>\n<li>Why <code>Type _</code> in <code>Dfa</code> and not <code>Type*</code>? I don't know the difference, but I think Mathlib prefers <code>Type*</code></li>\n<li><code>Dfa/Basic.lean</code> is missing a module docstring</li>\n<li>I'm not sure if it's possible to change the convention, but I much prefer the following: <code>q₁ q₂</code> for states (<code>q₀</code> for <code>start</code>), <code>a</code> for labels, <code>w</code> for <code>List Label</code> (\"word\"), <code>δ</code> for the transition function, δ̂ (delta hat) for <code>MTr</code>, <code>Q</code> for <code>State</code>, <code>Σ</code> for <code>Label</code>.<br>\nI think those are the standard names used in the literature, at least that's what <a href=\"https://en.wikipedia.org/wiki/Deterministic_finite_automaton\">Wikipedia uses</a></li>\n</ul>",
        "id": 540595514,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1758384594
    },
    {
        "content": "<p>Ah, yes, some refinements definitely needed. Also, I don't recall by memory if the alphabet is supposed to be finite... (Edit: yes it is.)</p>",
        "id": 540596514,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758385480
    },
    {
        "content": "<p>And yes, we should definitely use the notation for Set, thanks for reminding me. :-)</p>",
        "id": 540596734,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758385638
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 540596792,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758385693
    },
    {
        "content": "<p>Re Type*: I don't know. Using either yields the same result, apparently, and <code>Type _</code> is a bit clearer in what it does.</p>",
        "id": 540596973,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758385809
    },
    {
        "content": "<p><code>Type*</code>, <a href=\"https://github.com/leanprover-community/mathlib4/blob/be1e9da0073bd4082ac7e9d052a7a869877ed4e1/Mathlib/Tactic/TypeStar.lean#L22-L26\">defined here in Mathlib</a>, just elaborates into fresh implicit universes. So yes I think they do the same thing, but with us being downstream of Mathlib, maybe is more idiomatic/readable? Also maybe prevents issues of accidentally sharing a universe for different types. There are several files where we don't care much about universes but specify them explicitly, this could be nicer to write for brevity.</p>",
        "id": 540597815,
        "sender_full_name": "Chris Henson",
        "timestamp": 1758386450
    },
    {
        "content": "<p>But <code>Type _</code> reads like 'Type with whatever universe', whereas <code>Type*</code> reads like... '???' :-)<br>\nThat's why I've stopped using the latter in favour of the former. But if it solves a problem, then we should consider it ofc. Not sure why it'd work better than <code>Type _</code> though.</p>",
        "id": 540597926,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758386553
    },
    {
        "content": "<p>I think it's used enough in Mathlib that many read it exactly the same way. It seems slightly nicer if you want to specify multiple <code>(X Y ... Z : Type*)</code>, but otherwise I am ambivalent.</p>",
        "id": 540598221,
        "sender_full_name": "Chris Henson",
        "timestamp": 1758386911
    },
    {
        "content": "<p>Ahhh, that's <em>why</em> it's useful. (X Y ... Z : Type _) would use the same universe for all, wouldn't it? Type* would assign a different universe each.</p>",
        "id": 540598278,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758386981
    },
    {
        "content": "<p>Yes, that's what I meant above by \"accidentally sharing a universe\".</p>",
        "id": 540598681,
        "sender_full_name": "Chris Henson",
        "timestamp": 1758387444
    },
    {
        "content": "<p>Re conventions: I went for plain-text names because I couldn't use <code>Σ</code> :\\<br>\nMaybe some intermediate solution will come to mind... in the meantime I could call <code>Label</code> <code>Symbol</code> instead.</p>",
        "id": 540599057,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758387872
    },
    {
        "content": "<p>I've updated <code>Dfa</code> slightly so that we use <code>grind</code> a bit more and added a few things, same branch.<br>\nI'm wondering about some other design choices, exemplified by choosing between the next two for the formalisation of <code>δ̂</code>:</p>\n<ol>\n<li>Define it as function composition of <code>δ</code>/<code>tr</code>, and then prove it's consistent with <code>toLts.MTr</code>.</li>\n<li>Define it directly as <code>toLts.MTr</code>.</li>\n</ol>\n<p>I'm leaning towards 1 in general. That way, people accustomed to automata theory will find their usual definitions, and whenever they <em>want</em> to use results about lts, they can. But we're setting the convention here. Is that how we want things to be done?</p>",
        "id": 540942435,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758611403
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/540598278\">said</a>:</p>\n<blockquote>\n<p>Ahhh, that's <em>why</em> it's useful. (X Y ... Z : Type _) would use the same universe for all, wouldn't it? Type* would assign a different universe each.</p>\n</blockquote>\n<p>No: <code>(X Y Z : Type _)</code> assigns different universes for each variable.</p>",
        "id": 540977456,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1758622928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/540977456\">said</a>:</p>\n<blockquote>\n<p>No: <code>(X Y Z : Type _)</code> assigns different universes for each variable.</p>\n</blockquote>\n<p>Good to know, thanks!</p>",
        "id": 540977784,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758623064
    },
    {
        "content": "<p>Tested a bit the first route and it looks pretty ok to me. :)</p>\n<p><a href=\"https://github.com/leanprover/cslib/blob/automata/Cslib/Computability/Dfa/Basic.lean\">https://github.com/leanprover/cslib/blob/automata/Cslib/Computability/Dfa/Basic.lean</a></p>\n<p>If we go down this route I could (should?) probably move the lts results to a dedicated Dfa/Lts.lean file.</p>",
        "id": 540984303,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758625524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/540420886\">said</a>:</p>\n<blockquote>\n<p>We should discuss a bit the pattern for defining different kinds of automata in CSlib. Preferably, this should be coherent with the way we do semantics (but that way can be updated as well, if we get any new insights here!).</p>\n</blockquote>\n<p>(this is just an idea I had, not sure if it has been discussed before/elsewhere)<br>\nCould an automaton be defined as a homomorphism from a list to a category? For example, a DFA is a homomorphism from a list to the category of functions and an NFA is a homomorphism from a list to the category of relations. By homomorphism, I mean that list concatenation becomes arrow composition, so</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"k\">forall</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 541253800,
        "sender_full_name": "Atticus Kuhn",
        "timestamp": 1758726502
    },
    {
        "content": "<p>I'm not 100% sure about the construction, but one could maybe prove some correspondence results with the 'standard' definition of Dfa? Our current definition abstracts from the types of states and symbols.</p>",
        "id": 541258279,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758727665
    },
    {
        "content": "<p>I don't have anything to contribute myself, but do I understand correctly that the Automata in CSLib will be separate from those in mathlib already? And also separate from the project by <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span>, as both discussed in this thread <a class=\"stream-topic\" data-stream-id=\"516743\" href=\"/#narrow/channel/516743-computer-science/topic/Automata.20theory.20in.20Lean4/with/532251644\">#computer science &gt; Automata theory in Lean4</a>  <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 541385576,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1758784958
    },
    {
        "content": "<p>Yes, they're all a bit different. What I'm trying to do here is to see if we can reach a definition that is general and usable enough so that people could be happy to port their work to.</p>",
        "id": 541387933,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758785760
    },
    {
        "content": "<p>Sorry, I just saw this thread.  I've not figured out how to keep track of what's going on on Zulip and I saw this thread only because <span class=\"user-mention\" data-user-id=\"422703\">@Malvin Gattinger</span> mentioned me above.<br>\nAnyway, the following are the differences between the definition of automata in my project and the definition <span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> gave above:<br>\n(1) My automata definition has the state type bundled in.  This is natural for defining automata constructions (direct sum, product, concatenation, loop, etc), where the corresponding constructions on the state spaces will appear on the RHS (rather than the LHS) of the <code>:=</code>of the definition of the construction.  But I have to admit that this gave me a lot of trouble in universe level inference and I ended up defining everything on <code>Type</code> rather than <code>Type*</code>.  (For automata theory I don't think that's a big deal.)<br>\n(2) On the other hand, my automata definition does not include the accepting states or the finiteness assumption:<br>\n(2.a) The accepting states are not included because automata on infinite words have multiple types of accepting conditions (Büchi, Muller, Rabin, etc), but automata on finite and infinite words can share many automata constructions if the accepting condition is not included..<br>\n(2.b) The finite-state assumption is not included because many result just don't depend on the state spaces being finite.  Note that this is also the approach taken by the automata theory in mathlib.  When I need to assume the state space is finite, I just include an additional assumption <code>[Finite M.State]</code> in the theorem statement.  Since the finite-state assumption is not included by default, I use <code>Set</code> instead of <code>Finset</code> throughout.   (The same is true in mathlib.)<br>\n(3) I treat deterministic automata and nondeterministic automata separately and do not regard the former as a special case of the latter.  Instead, I have a map <code>Automata.DA.toNA</code> to convert a DA into the corresponding NA.  (With the dot-notation, one can just write <code>M.toNA</code>.). In fact, I started my project with DA being a special case of NA and found that it was quite painful to work with.  Note that mathlib's automata theory also has separate NFA and DFA classes.<br>\n(4) Sometimes I wonder even whether the initial state(s) should be part of an \"automaton\".  On more than one occasions the proof I was formalizing calls for reasoning about the set of inputs that can lead an automaton M to go from state s1 to state s2.  So perhaps we should stick to a minimalist approach and have only the notions of a nondeterministic LTS and a deterministic LTS, rather than trying to come up with a universally applicable definition of an \"automaton\".</p>",
        "id": 541521428,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758824976
    },
    {
        "content": "<p>One more thing: we also need a better-named definition of an infinite sequence/word: <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream.27.20called.20Stream.27.3F/with/541500490\">#mathlib4 &gt; Why is Stream' called Stream'?</a></p>",
        "id": 541521758,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758825079
    },
    {
        "content": "<p>A question: Why does the transition in cslib's LTS have type <code>State → Lable → State → Prop</code>, rather than <code>State → Label → Set State</code>?  The latter is what is used by NFA in mathlib.  Although it is easy to move between <code>State → Prop</code> and <code>Set Prop</code>, this difference does introduce some friction.</p>",
        "id": 541526217,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758826596
    },
    {
        "content": "<p>The former is what people typically use when defining operational semantics, both on pen&amp;paper and formalisations (inductive with that signature), and what is standard in Lean for relations. But if there are good reasons to switch we can discuss the definition, no problem. I'm trying to stick to 'define things as expected and then prove they're equivalent to other formulations' as a general rule. People could also want the coalgebraic and dialgebraic views, etc.</p>",
        "id": 541527766,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758827222
    },
    {
        "content": "<p>I still need to go through it all, and you make lots of good comments, but these seem to be more appropriate for more powerful automata than Dfas. Having finiteness assumptions and a start state is part of the accepted definition of Dfa.</p>\n<p>To generalise, I'd prefer having separate definitions and then either show conversion defs or instances for Dfas and the like. This is what I've explored with LTS as an example: <a href=\"https://github.com/leanprover/cslib/blob/3fe4da76a31b58c9f4372616020dc0f9e7e27665/Cslib/Computability/Dfa/Basic.lean#L67\">https://github.com/leanprover/cslib/blob/3fe4da76a31b58c9f4372616020dc0f9e7e27665/Cslib/Computability/Dfa/Basic.lean#L67</a></p>",
        "id": 541528624,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758827509
    },
    {
        "content": "<p>Re 3: I don't understand what you mean. We don't even have Nfa yet, and I fully agree with what you wrote. :⁠-⁠)</p>\n<p>Re 4: as for 3? We have a definition of Lts, and then various predicates formalising their standard classes (image finite, deterministic, etc.).</p>\n<p>Perhaps what's confusing here is what I meant by general definition. I don't wanna have a single definition for all kinds of automata (the most general ones are arguably Lts for discrete stuff and then even more general versions when going beyond); first, I'm trying to see if we could agree on a definition for Dfa that suits the different developments that people have done/are interested in.</p>",
        "id": 541529462,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758827906
    },
    {
        "content": "<p>Re bundled vs unbundled: I'm trying to stick to unbundled State and Symbol/Label types because it's the standard approach and it does seem to work nicely. But I think I've encountered the problems you mention regarding union and other operations when working with LTS. I haven't played enough with those yet. In fact, Dfas might be a better/simpler place to understand the ergonomics of all of this.</p>",
        "id": 541529851,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758828081
    },
    {
        "content": "<p>If you just want to define DFA, what's wrong with the current DFA definition in mathlib?<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/DFA.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/DFA.html</a><br>\nRegarding finiteness assumptions: I never once needed to assume that the alphabet/symbols is finite in my automata theory project, while many (though by no means all) theorems depend on the state space being finite.   This is not surprising if you think about it.  Once the state space is finite, the automaton can only distinguish the symbols to a finite degree of \"resolution\" anyway.</p>",
        "id": 541533469,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758829450
    },
    {
        "content": "<p>Regarding bundled vs unbundled state space: an unbundled design is probably a good idea if you want to develop automata theory for all universe levels.  My bundled design gave me endless troubles when I tried to use <code>Type*</code> instead of <code>Type</code>.</p>",
        "id": 541533861,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758829629
    },
    {
        "content": "<p>For the usual closure properties of regular languages under the boolean operations (union, intersection, and complementation), concatenation, and Kleene star, I don't think any of the corresponding automata constructions in the proofs actually needs to assume that the automata are finite-state.  In fact, for union and intersection, one doesn't even need to assume that only finitely many automata are involved.  It is actually in the case of ω-regular languages that one often needs to make finite-state assumptions.</p>",
        "id": 541536165,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758830547
    },
    {
        "content": "<p>I agree on that, to show many common properties about Dfas, we don't need all the assumptions typically bundled (on pen&amp;paper) in textbook presentations of Dfa.</p>\n<p>The issue I'm concerned with is that this means we have to choose between (as far as I see now):</p>\n<ol>\n<li>Formalise Dfa with fewer assumptions and call it a day.</li>\n<li>Formalise Dfa as expected, and write all definitions and theorems that do not need the 'extra' assumptions for a more general structure or class. Code things such that those easily/directly apply to Dfa.</li>\n<li>Formalise Dfa with fewer assumptions (this is like 2, but we're calling the more general structure Dfa), and then formalise a Dfafs (or something like that) which is the actual formalisation of Dfa (with all the standard assumptions). Explain why we have this in the documentation.</li>\n</ol>\n<p>My current view is that 2 is a good compromise. 3 might also work (the acronym Dfa says nothing about finite alphabet, so we could consider challenging tradition).<br>\n1 seems a bit dangerous when I think about (a) somebody eventually trying to prove any reasonable theorem that requires a standard assumption that we decided to exclude (then we'll have to introduce the assumption) and (b) people learning CS through CSlib (though this can be ameliorated with good documentation).</p>\n<p>I think we should be very explicit about what we're doing, since my experience is that even the tiniest question mark/deviation in the formalisation of an established concept can make people roll out yet another version. There should be space for the hierarchy of assumptions.</p>\n<p>What do you think?</p>\n<p>Btw, do you think that (a) is never gonna be an issue?</p>",
        "id": 541590963,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758867380
    },
    {
        "content": "<p>Side comment: it is really great that something as simple as Dfa raises these questions, thanks for the good discussion so far.</p>",
        "id": 541591070,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758867464
    },
    {
        "content": "<p>In my automata theory project I took approach 1.  I have a namespace <code>Automata</code> and define <code>Automta.NA</code> and <code>Automata.DA</code> classes for nondeterministic and deterministic automata, respectively.  <code>Automata.NA</code> and <code>Automata.DA</code> include only the initial state(s) and the next state(s) function and nothing else.  Finite-state assumptions are made in theorems only when needed.  I think exposing the actual logic in the proofs is more important than agreeing with what the textbooks say.</p>",
        "id": 541602775,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758872341
    },
    {
        "content": "<p>As far as I can see, finite-alphabet assumptions will only be needed in the equivalence of finite automata and regular expressions.  Like the finite-state assumption, it can be made only when needed.</p>",
        "id": 541604750,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758872994
    },
    {
        "content": "<p>I'm not concerned about (a).  For a theorem to have a long list of assumptions is not uncommon in Lean.  If someone can't prove a theorem because of a missing assumption, I expect he/she will soon realize that and add the necessary assumption (and only the necessary assumption).</p>",
        "id": 541606158,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758873502
    },
    {
        "content": "<p>Need to go to bed now.  Talk to you tomorrow.</p>",
        "id": 541606293,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758873552
    },
    {
        "content": "<p>Isn't what you're describing more akin to approach 2? Your code gives me the same impression: you have defined a more general structure than Dfa, given it another name (DA), and proven things about this more general structure.<br>\nMy only addition in (2) is that the definition of Dfa should <em>also</em> be allowed to exist, and inherit somewhat all the stuff proven about the more general structure (in your case DA).</p>\n<p>Approach (2) is in line also with this:</p>\n<blockquote>\n<p>I think exposing the actual logic in the proofs is more important than agreeing with what the textbooks say.</p>\n</blockquote>\n<p>Are we then discussing whether the 'standard' definition of <code>Dfa</code> (with the finite alphabet assumption) should even be formalised? That for me would depend on whether there is at least one interesting definition/theorem that can be given with the additional assumption. I was working under this hypothesis.<br>\nAre you saying that <code>Dfa</code> and <code>DA</code> cannot be distinguished in any meaningful way? (I don't think you are, judging from your last message.)</p>",
        "id": 541722131,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758910430
    },
    {
        "content": "<p>OK, I now understand you better.  Yes, I think it would be a good idea to have a class <code>Automata.DA</code> for deterministic automata which has only fields for the initial state and the next state function and then extend <code>Automata.DA</code> to <code>Automata.DFA</code> with finite-state and perhaps also finite-alphabet assumptions.    Similarly for <code>Automata.NA</code>, <code>Automata.NFA</code>, and <code>Automata.EpsilonNFA</code>.   Regular languages will be defined as languages accepted by <code>Automata.NFA</code>, but accepted languages will be defined more generally for <code>Automata.NA</code>.  There is no need to define accepted languages for the deterministic automata, because they can be easily converted to nondeterministic ones via <code>Automata.DA.toNA</code>.</p>\n<p>I have put everything above in an <code>Automata</code> namespace, because that would give us more freedom in choosing names in that namespace.</p>",
        "id": 541753180,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758925122
    },
    {
        "content": "<p>So let's see, we have..</p>\n<p>Transition systems:</p>\n<ul>\n<li><code>Lts State Label</code>: just a transition relation. Bisimulation, Trace Equivalence, etc. are defined on this.</li>\n<li><code>RootedLts State Label</code>: extends <code>Lts</code> with a root (which in automata is the initial state).</li>\n</ul>\n<p>Automata:</p>\n<ul>\n<li><code>Automaton State Symbol</code>: <code>start</code> state and <code>accept</code> (Finset of accept states). If we required the user to give us a <code>toLts</code> function, we could define <code>Accepts</code> here, but it's probably excessive.</li>\n<li><code>DA</code>: extends <code>Automaton</code> with a transition function <code>State -&gt; Symbol -&gt; State</code>. Offers <code>.toNA</code>, <code>.toRootedLts</code>, and proofs of correctness of these encodings.</li>\n<li><code>NA</code>: extends <code>Automaton</code> with a transition function <code>State -&gt; Symbol -&gt; Set State</code>. Offers <code>.toRootedLts</code>.</li>\n<li><code>Dfa</code>: extends <code>DA</code> with finite-state and finite-label assumptions. As this extends <code>DA</code>, it offers <code>.toDA</code> and inherits all the nice things from <code>DA</code>.</li>\n<li><code>Nfa</code>: similar to above.</li>\n</ul>",
        "id": 541799170,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758973272
    },
    {
        "content": "<p>Since the point of automata is accepting/rejecting strings, should we make <code>accepts : List Symbol -&gt; Bool</code>(or <code>Accepts : List Symbol -&gt; Prop</code>) a field of <code>Automaton</code> maybe? That way we can define the language of an automaton already at that level.</p>\n<p>(Edit: mmmh, that'd make the rest kinda redundant, conflating this with what a Language is..)</p>",
        "id": 541821469,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758992730
    },
    {
        "content": "<p>What about the question from <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> about the motivation to define DFA in CsLib considering the definition in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/DFA.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/DFA.html</a>? We also have turing machines and NFA in Mathlib.</p>",
        "id": 541919435,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1759094447
    },
    {
        "content": "<p>My preferred design is described below.  You can think of it as a refactoring of the relevant code in mathlib.<br>\n(1) Put everything in a new namespace <code>Automata</code>.<br>\n(2) Use an unbundled design, so that the state type (<code>S</code> below)  and the alphabet type (<code>A</code> below) are parameters.<br>\n(3)<code>Automata.NA</code> (for nondeterministic automata) and <code>Automata.DA</code> (for deterministic automata) are the two root classes<br>\n(3.a) <code>Automata.DA</code> has the following fields:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"n\">step</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">S</span>\n</code></pre></div>\n<p>(3.b) <code>Automata.NA</code> has the following two fields:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">S</span>\n</code></pre></div>\n<p>(3.c) <code>Automata.εNA</code> has the following fields:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">S</span>\n</code></pre></div>\n<p>(4) The <code>DFA</code>,<code>NFA </code> and <code>εNFA</code> in mathlib can be defined as extensions of <code>Automata.NA</code> and <code>Automata.DA</code>, respectively.  I would like to put mathlib's <code>DFA</code>, <code>NFA</code>, and <code>εNFA </code> in the <code>Automata</code> namespace as well.<br>\n(5) Now that we have a separate (DA,NA,εNA) and  (DFA,NFA,εNFA), the finite-state and perhaps also the finite-alphabet assumptions can be added to the latter.<br>\n(6) Separate extensions of (DA,NA) will be defined for Buchi automata, Muller automata, etc.</p>\n<p>Comment: It is not a good idea to define <code>NA</code> to have a single initial state.  First, technically, think about how you prove that the union of the languages of two <code>NA</code>s is again accepted by an <code>NA</code>.  With the design given above, there is a straightforward sum construction on nondeterministic automata that even works over an arbitrary index set.  If an <code>NA</code> can have only a single initial state, a more complicated construction is needed.  Second, philosophically, why is nondeterminism allowed only on transitions but not on the choice of the initial state?</p>",
        "id": 541923795,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759100276
    },
    {
        "content": "<p>I like this design, though I still think <code>S → Prop</code> is preferable to <code>Set S</code> since that's how relations are usually defined in mathlib (see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph#doc\">docs#SimpleGraph</a> for example)<br>\nAs for having a single initial state, we can add <code>NA₀</code>, <code>εNA₀</code>, <code>NFA₀</code>, <code>εNFA₀</code> variants for those and define translations. I'm also in favor of having multiple start states as the canonical <code>NFA</code>.</p>\n<p>Regarding acceptance conditions: How about having a very general repeated transition function which takes an LTS, a set of states, and a sequence <code>Stream'.Seq Label</code>, and returns <code>Set (Stream'.Seq State)</code>? Then DFA/NFA acceptance conditions will operate on <code>.toList.getLast?</code> (just the state reached), and we can define Buchi/Rabin/Miller/Strett on the infinite sequence</p>",
        "id": 541925609,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1759102728
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> So your design is like what I wrote, but without <code>Automaton</code> because of the difference in start states between <code>DA</code> and <code>NA</code>. I'm happy with that, because I agree with you that <code>NA</code> should have a set of initial states. There is also precedent for that choice in research papers (e.g., <a href=\"https://dl.acm.org/doi/abs/10.1145/2490818\">https://dl.acm.org/doi/abs/10.1145/2490818</a>). We should mention this in the docs.</p>\n<p>I have a few comments on style, I'll write a separate message about that.</p>",
        "id": 541956051,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759128881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/541925609\">said</a>:</p>\n<blockquote>\n<p>I like this design, though I still think <code>S → Prop</code> is preferable to <code>Set S</code> since that's how relations are usually defined in mathlib (see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph#doc\">docs#SimpleGraph</a> for example)</p>\n</blockquote>\n<p>The set option seems more common in textbooks (Hopcroft &amp; Ullman, Kozen) and also supports a very natural expression of the powerset construction:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/c75ca6877960a98adf88d2a1a9ff26be668f4fdc/AutomataTheory/Automata/PSet.lean#L32\">https://github.com/ctchou/AutomataTheory/blob/c75ca6877960a98adf88d2a1a9ff26be668f4fdc/AutomataTheory/Automata/PSet.lean#L32</a></p>\n<blockquote>\n<p>As for having a single initial state, we can add <code>NA₀</code>, <code>εNA₀</code>, <code>NFA₀</code>, <code>εNFA₀</code> variants for those and define translations. I'm also in favor of having multiple start states as the canonical <code>NFA</code>.</p>\n</blockquote>\n<p>I don't think we need them, because they can be easily realized by instantiating <code>start</code> with a singleton set.</p>\n<blockquote>\n<p>Regarding acceptance conditions: How about having a very general repeated transition function which takes an LTS, a set of states, and a sequence <code>Stream'.Seq Label</code>, and returns <code>Set (Stream'.Seq State)</code>? Then DFA/NFA acceptance conditions will operate on <code>.toList.getLast?</code> (just the state reached), and we can define Buchi/Rabin/Miller/Strett on the infinite sequence</p>\n</blockquote>\n<p>In the automata literature I've seen, an automaton operates either on finite words or on infinite words, but never both.</p>",
        "id": 541959504,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759130291
    },
    {
        "content": "<p>Style comments:</p>\n<ul>\n<li>I think we should write <code>Symbol</code>, not <code>A</code> (or <code>Alphabet</code>), for the type of symbols. <code>x : Alphabet</code> to say that <code>x</code> is a symbol is weird.</li>\n<li>Afaik, <code>step</code> is normally called 'transition function', so it should be called <code>tr</code>.</li>\n<li>I don't remember where/when, but I was told that <code>LTS</code> should be named <code>Lts</code>, which would mean that <code>DFA</code> should be <code>Dfa</code>. But I'm not convinced of this anymore, so I suggest I just revert <code>Lts</code> to being <code>LTS</code> and we keep all uppercase for the automaton names. ;-)</li>\n</ul>",
        "id": 541959530,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759130303
    },
    {
        "content": "<p>Re <code>εNA</code>: I'd like to understand better the use of <code>Option</code>, as opposed to <code>Sum</code> with an epsilon type or something like that. Could you elaborate a bit? Is it just convenience?</p>",
        "id": 541960372,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759130581
    },
    {
        "content": "<p>I chose the names \"start\" and \"step\" simply because they are what automata in mathlib use.  It seems to me a good idea to match mathlib so that what we do can become a drop-in replacement for the relevant parts of mathlib without too much trouble.  The <code>εNA</code> also follows mathlib, where <code>none</code> gives you the ability of changing state without consuming a symbol.</p>\n<p>Either <code>Symbol</code> or <code>Alphabet</code> is fine with me.  I just don't want to use Greek letters for type names like in mathlib, because <code>α</code> and <code>σ</code> look awfully like each other in all the fonts I've played with.</p>\n<p>Personally I prefer <code>DFA</code> over <code>Dfa</code> because this is an acronym every letter of which begins a word, but not itself a word.  This is also what mathlib uses.</p>",
        "id": 541961738,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759131080
    },
    {
        "content": "<p>The current rule of thumb in cslib is that Greek letters work fine only when they match what people are used to or one doesn't wanna be descriptive on purpose. Here being descriptive is good, so no Greek.</p>",
        "id": 541962222,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759131274
    },
    {
        "content": "<p>As for <code>step</code>, that looks like it should really be <code>tr</code>, to match both pen&amp;paper and the <code>Tr</code> in <code>LTS</code>. Some things from mathlib will need some adaptation if/when ported anyway.</p>",
        "id": 541962496,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759131367
    },
    {
        "content": "<p>I'd like to give some thought to the signature of the transition function in <code>NA</code> (ending in <code>Prop</code> vs ending in <code>Set State</code>, as <span class=\"user-mention\" data-user-id=\"933054\">@Snir Broshi</span> mentioned). There's some tension there as to what gets easier or harder. One advantage of Set is that we get membership notation and some constructions.</p>\n<p>But choosing <code>Tr : State -&gt; Symbol -&gt; State -&gt; Prop</code> has some advantages as well. For example, <code>NA</code> could be just an extension of <code>LTS</code>. As we're discussing things, an NA is actually just an LTS with some initial states. If that holds, we should consider making this formal. That way we'd inherit all definitions and theorems for LTSs directly, with no need for conversion functions.</p>\n<p>(Note I'm not saying we should do this just yet, I'm just brainstorming.)</p>",
        "id": 541965480,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759132526
    },
    {
        "content": "<p>(Keeping track of how some of these decisions would look like in code here: <a href=\"https://github.com/leanprover/cslib/tree/automata/Cslib/Computability/Automata\">https://github.com/leanprover/cslib/tree/automata/Cslib/Computability/Automata</a>.)</p>",
        "id": 541972369,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759134930
    },
    {
        "content": "<p>I would prefer sticking to the current names and conventions used in mathlib for automata theory.  It takes efforts changing them and I don't see any point in spending that effort.  In any case, Lean has good support for moving between sets and predicates: given <code>s : Set X</code>, <code>(· ∈ s)</code> is the corresponding predicate, and given <code>p : X → Prop</code>, <code>{x | p x}</code> is the corresponding set.  So LTS theorems should be readily usable by automata theory even if the latter uses sets instead of predicates.</p>",
        "id": 542099663,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759167023
    },
    {
        "content": "<p>For example, suppose NA is defined using sets:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n</code></pre></div>\n<p>We can define:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"bp\">.</span><span class=\"n\">toLTS</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>With the dot-notation, we can write <code>M.toLTS</code> which can then use the theorems about LTS.</p>",
        "id": 542110443,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759170158
    },
    {
        "content": "<p>Well, one point is that we'd be able to (more directly) apply automata theory to studying the operational semantics of terms given in a language formulated  languages given as LTS.</p>\n<p>Another point is that we'll avoid a lot of boilerplate, since many definitions and theorems I see about NAs do not need the initial states, they can be formulated (and make good sense to have) for LTS. For example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The `μ`-image of a state `s` is the set of all `μ`-derivatives of `s`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The `μ`-image of a set of states `S` is the union of all `μ`-images of the states in `S`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"bp\">.</span><span class=\"n\">setImage</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">μ</span>\n</code></pre></div>\n<p>Edit: also this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The set of outgoing labels of a state. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"bp\">.</span><span class=\"n\">outgoingLabels</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">HasOutLabel</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 542242011,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759229430
    },
    {
        "content": "<p>I really don't want to deviate from how mathlib does things if possible.  It is not easy or pleasant to make changes in mathlib (for example, see <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream.27.20called.20Stream.27.3F/with/542325653\">#mathlib4 &gt; Why is Stream' called Stream'?</a>).  I'd rather write boilerplate code and prove adapter lemmas if I need to use results from LTS.  The latter is under my control; mathlib isn't.</p>",
        "id": 542327577,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759252116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/542327577\">said</a>:</p>\n<blockquote>\n<p>It is not easy or pleasant to make changes in mathlib (for example, see <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream.27.20called.20Stream.27.3F/with/542325653\">#mathlib4 &gt; Why is Stream' called Stream'?</a>)...  mathlib isn't [under my control]</p>\n</blockquote>\n<p>I disagree. That thread seems receptive, just wanting to make sure to evaluate pros/cons. We have already made small upstreams to Mathlib, and will continue to do so.</p>",
        "id": 542335244,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759254526
    },
    {
        "content": "<p>Frankly, I now regret starting that thread about <code>Stream'</code>.  In retrospect, I don't think that's a good way to spend my time.  I don't want to repeat the experience.</p>",
        "id": 542338899,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759255587
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> I understand the lack of enthusiasm for investing a lot of time discussing API design when you wanna get things done.<br>\nBut I'd still like to understand what we're balancing here. Are you saying that (a) you think extending LTS from NA would be the better technical choice but your concern for mathlib compatibility makes you not want it anyway, or (b) you think even thinking about these design issues is a waste of time, because mathlib compatibility takes precedence anyway?</p>\n<p>This is a cs concept, so we're the ones who should think about this carefully. We've already gained quite a bit from this discussion, I think.<br>\n(I'm also asking colleagues about how this will affect probabilistic models later on, since I remember similar boilerplate gets problematic there..)</p>\n<p>Another reason for which I'd like to understand this well is that this would be the first place where we introduce using <code>Set</code> to model nondeterministic semantics. Both LTS and ReductionSystem use the standard relation to <code>Prop</code> instead.</p>",
        "id": 542342682,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759256865
    },
    {
        "content": "<p>Sorry for the late reply.</p>\n<p>Yes, I think compatibility with mathlib should take precedence.  Whether the transition part of an automaton is called <code>step</code> or <code>Tr</code> or <code>next</code> is of no real mathematical consequence.  Personally I do not want to spend my time fighting it.</p>\n<p>As to whether the transition part of an automaton should have the type <code>State → Symbol → Set State</code> or <code>State → Symbol → State → Prop</code>, I think both options are valid and both have long traditions, though I think the former has a longer tradition.  Attached below is Rabin and Scott's seminal 1959 paper in which the notion of a nondeterministic automaton first appeared:<br>\n<a href=\"/user_uploads/3121/zTIgyC4Ik9oTdQID_9iaodgO/Rabin-and-Scott-Finite_Automata_and_Their_Decision_Problems.pdf\">Rabin and Scott - Finite_Automata_and_Their_Decision_Problems.pdf</a><br>\nTake a look at Definition 9 on page 120, which uses the first option.  As far as I can tell, most of the subsequent textbooks on automata theory also continued that tradition.</p>\n<p>All the above is just a long way for me to say that there is nothing wrong with both options to exist in mathlib and I think it is even valuable to have definitions and theorems for going back and forth between them.</p>\n<p>A personal rant: If Lean didn't have \"sets\" in the first place, we wouldn't need to discuss this topic at all.  I once raised the topic of why does Lean have \"sets\" at all and was promptly shot down:</p>\n<p><a class=\"message-link\" href=\"/#narrow/channel/113489-new-members/topic/How.20do.20I.20prove.20this.20about.20Nat.2Enth.3F/near/522848837\">#new members &gt; How do I prove this about Nat.nth? @ 💬</a></p>",
        "id": 542630752,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759362406
    },
    {
        "content": "<p>How entrenched are the automata definitions in Mathlib? Loogle seems to indicate that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFA#doc\">docs#DFA</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NFA#doc\">docs#NFA</a> are used just in leaf files in Computability. How much more than that is there? What I'm getting at is that I am more open to deviating from the current definition if we feel it is a high benefit and not too onerous to upstream (or even downstream, but that's a different discussion).</p>",
        "id": 542634392,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759364720
    },
    {
        "content": "<p>I recall that mathlib maintainers might be happy to see some of the computability stuff offloaded to CSlib since it is more on-topic here</p>",
        "id": 542724886,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759406866
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/542724886\">said</a>:</p>\n<blockquote>\n<p>I recall that mathlib maintainers might be happy to see some of the computability stuff offloaded to CSlib since it is more on-topic here</p>\n</blockquote>\n<p>With this in mind, I think we are free pick the spellings we find most useful, then plan to migrate the Mathlib automata code to CSLib.</p>",
        "id": 542727891,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759407764
    },
    {
        "content": "<p>I posted a query in the mathlib4 channel to verify <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> 's claim:<br>\n<a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Is.20there.20a.20plan.20to.20offload.20Mathlib.2EComputability.20to.20Cslib.3F/near/542792339\">#mathlib4 &gt; Is there a plan to offload Mathlib.Computability to Cslib? @ 💬</a></p>",
        "id": 542792552,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759424999
    },
    {
        "content": "<p>It has been a while but I believe you might be able to search some zulip conversations where this was mentioned</p>",
        "id": 542792688,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759425033
    },
    {
        "content": "<p>I want to see a clear policy statement from the community, not just (possibly personal) opinions expressed in a discussion thread.</p>",
        "id": 542793337,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759425235
    },
    {
        "content": "<p>Sure. But I think “theoretical computer science is surely part of mathematics” is a highly non-obvious and disputed claim. Nevertheless, the separation is not always well-defined and the boundaries are fuzzy. So getting a clear statement on this will be difficult from a technical standpoint.</p>",
        "id": 542793554,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759425298
    },
    {
        "content": "<p>Strangely, one of the most eminent theoretical computer scientists/mathematicians wrote an entire book (which you can download for free):<br>\n<a href=\"https://www.math.ias.edu/avi/book\">https://www.math.ias.edu/avi/book</a><br>\nto express the opposite view.  You may recall that Wigderson was awarded both the Abel Prize and the Turing Award (among many other awards).</p>",
        "id": 542795952,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759426083
    },
    {
        "content": "<p>That's a book on computability and complexity. I don't see how it supports your claim</p>",
        "id": 542796853,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759426389
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/542724886\">said</a>:</p>\n<blockquote>\n<p>I recall that mathlib maintainers might be happy to see some of the computability stuff offloaded to CSlib since it is more on-topic here</p>\n</blockquote>\n<p>ditto</p>",
        "id": 542802760,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759428504
    },
    {
        "content": "<p>Anyway, in general, we're willing to maintain automata theory at cslib. I'm making some progress on how it could look like taking the discussion so far into consideration, will show some more soon.</p>",
        "id": 542802924,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759428571
    },
    {
        "content": "<p>A new question:   Why is the field <code>Tr</code> of <code>Lts</code> capitablized?  The field names of structures in mathlib seems consistently lowercase.  Also, isn't <code>Tr</code> a bit too short and hence ambiguous?  (There is \"trace\" in linear algebra, for example.). Wouldn't <code>trans</code> be a more informative name that's just slightly longer?</p>",
        "id": 542848400,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759449355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/542848400\">said</a>:</p>\n<blockquote>\n<p>A new question:   Why is the field <code>Tr</code> of <code>Lts</code> capitablized?  The field names of structures in mathlib seems consistently lowercase.  Also, isn't <code>Tr</code> a bit too short and hence ambiguous?  (There is \"trace\" in linear algebra, for example.). Wouldn't <code>trans</code> be a more informative name that's just slightly longer?</p>\n</blockquote>\n<p>I believe the captialization correctly follows the <a href=\"https://leanprover-community.github.io/contribute/naming.html\">Mathlib naming conventions</a> for a non-Prop field? Please correct me if that's wrong. I'll otherwise defer to <span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> on the matter of a more descriptive name.</p>",
        "id": 542851017,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759451426
    },
    {
        "content": "<p>Well, propositions like associativity seems to get lowercase names in algebraic structures; for example:<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Group/Defs.html#Monoid\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Group/Defs.html#Monoid</a></p>",
        "id": 542851245,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759451619
    },
    {
        "content": "<p>It is possible I am wrong, or that is an example of \"some fields of structures are currently wrongly lower-cased\" the conventions page mentions.</p>",
        "id": 542851433,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759451774
    },
    {
        "content": "<p>[ I was writing the following when <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> 's message above appeared.  It adds one more aesthetic argument. ]</p>\n<p>It occurred to me that there is an aesthetic argument for why the next-state transition of a nondeterministic automaton should have the type (where <code>S</code> and <code>A</code> are the types of states and alphabet/symbols, respectively):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">S</span>\n</code></pre></div>\n<p>The argument is that the above type has a nice formal correspondence with the next-state transition of a deterministic automaton:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">S</span>\n</code></pre></div>\n<p>The naming convention discussion above gives one more argument: we can use the same field name in both NA and DA cases, rather than capitalizing the former but lowercasing the latter.</p>",
        "id": 542851986,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759452338
    },
    {
        "content": "<p>In any case, the above makes me think that perhaps we can extend the API of Lts:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Lts</span><span class=\"bp\">.</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lts</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Then <code>Lts.next</code> provides an alternative, set-valued view of <code>Lts.Tr</code> and, with the dot-notation and suitable theorems, the two can be used interchangeably, depending on the user's preference.  For example, there can be a set-valued counterpart of <code>Lts.MTr</code>.</p>",
        "id": 542854605,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759454779
    },
    {
        "content": "<p>Re style of <code>Tr</code> etc.: I'm trying to follow mathlib's conventions, yes. I think they have some tech debt wrt notation, if I understand correctly. If you think I've interpreted something wrongly, please let me know.</p>",
        "id": 542892865,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759479602
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/542854605\">said</a>:</p>\n<blockquote>\n<p>In any case, the above makes me think that perhaps we can extend the API of Lts:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Lts</span><span class=\"bp\">.</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lts</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Then <code>Lts.next</code> provides an alternative, set-valued view of <code>Lts.Tr</code> and, with the dot-notation and suitable theorems, the two can be used interchangeably, depending on the user's preference.  For example, there can be a set-valued counterpart of <code>Lts.MTr</code>.</p>\n</blockquote>\n<p>That's exactly the road I've been following the past couple of days. Note LTS already has <code>image</code> (which is a standard concept and name there), which does almost that but starts from a single state. I extended it to <code>setImage</code> and multistep definitions as well, which have the signatures you want I think.</p>",
        "id": 542893049,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759479680
    },
    {
        "content": "<p>Alright people, I think I'm ready to show a proposal in code, which I hope makes sense to you. Feedback is welcome. Explanation below. Current code at: <a href=\"https://github.com/leanprover/cslib/tree/automata/Cslib/Computability/Automata\">https://github.com/leanprover/cslib/tree/automata/Cslib/Computability/Automata</a></p>\n<h1>Structure</h1>\n<p>We have the following components.</p>\n<ul>\n<li>LTS, modelling transition systems as a transition relation <code>Tr : State → Label → State → Prop</code>. Nothing else, no assumptions are made on <code>Tr</code>.</li>\n<li>NA (nondet automaton), which extends LTS with start and accept fields; both have type <code>Set State</code>. In all automata, I call the type of labels <code>Symbol</code> to be more familiar.</li>\n<li>DA (det automaton), which is independent. It has a start state, a set of accept states, and a transition function <code>tr : State → Symbol → State</code>.</li>\n<li>DFA, which extends DA with finiteness assumptions on state and symbol types.</li>\n</ul>\n<p>This design worked out pretty nicely (see next section). It's the result of trying many things, so it's good to mention what didn't work well (hopefully not just because of me being clumsy). I'll report on that at the end.</p>\n<h1>Development</h1>\n<ul>\n<li>I have extended <code>LTS</code> with plenty of definitions and results about 'image transitions'. In particular, I've built on the existing <code>LTS.image</code> definition (which returns the set of all states reachable by a state with a given label) to define <code>LTS.imageMultistep</code> (the set of all states reachable by a state through multistep transitions on a given list of labels) and their natural extensions to input sets of states instead of states, <code>LTS.setImage</code> (the union of all <code>LTS.image</code>s of the states in an input set) and <code>LTS.setImageMultistep</code> (same, for <code>LTS.imageMultistep</code>). These definitions come with characterisation results that link set membership and equality to the existence of (multistep) transitions.</li>\n<li>Since an <code>NA</code> <em>is</em> an <code>LTS</code>, I can define the transition function in the subset construction <code>NA.toDA</code> as just <code>tr : na.setImage</code>.</li>\n<li>Thanks to the characterisation results for image transitions in <code>LTS</code>, I could easily prove that the standard multistep transition function (defined in <code>DA</code>) of <code>NA.toDA</code> is equal to <code>LTS.setImageMultistep</code>.</li>\n<li>From the above, correctness of the subset construction (<code>na.language = na.toDA.language</code>) is straightforward (<a href=\"https://github.com/leanprover/cslib/blob/898d941058f2cf49088122d612c60707c6ab622e/Cslib/Computability/Automata/DA.lean#L157\">https://github.com/leanprover/cslib/blob/898d941058f2cf49088122d612c60707c6ab622e/Cslib/Computability/Automata/DA.lean#L157</a>).</li>\n</ul>\n<p>Many of these proofs are just a single call <code>grind</code>, sometimes preceded by a simple line or two.</p>\n<h1>Alternatives that did not work well</h1>\n<ul>\n<li>Making <code>DA</code> extend <code>LTS</code>. It's possible: I just had to add a default about the definition of the transition relation (from a transition function put in another field) and a propositions that enforces that default (that's standard in Lean). But I didn't like that something as simple as a DA ended up having so many fields and surprising internals. So I opted for providing a <code>DA.toNA</code> and an automatic coercion.</li>\n<li>Making a structure <code>Automaton</code> (tried both one that extends <code>LTS</code> and one that doesn't) that <code>NA</code> and <code>DA</code> extend. The only meaningful thing I could do in <code>Automaton</code> was requiring an <code>Accepts : List Symbol → Prop</code> field and then define <code>language</code> based on that. While this makes sense as a contract, it's not really what Lean structure extension/inheritance is useful for, as people could then override it. I found all of this clunky and discarded it.</li>\n<li>Making <code>NA</code> <em>not</em> an extension of <code>LTS</code> but rather an isolated structure. Outside of the notion of acceptance, which is the conceptual extension from LTS to automata, I repeatedly encountered the issue that, when defining something, I could either duplicate code from <code>LTS</code> (and prove it equivalent to the one in <code>LTS</code>) or make the definition use <code>toLTS</code> and invoke whatever I needed from <code>LTS</code>. The former means lots of boilerplate, the latter means giving indirect definitions. Both implied that I needed results about <code>LTS</code> anyway. When I tried extending <code>LTS</code>, this pushed me to extending <code>LTS</code> with lots of useful things that do not depend on the notion of acceptance, which I took as a positive sign.</li>\n</ul>",
        "id": 542897997,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759481522
    },
    {
        "content": "<p>A message was moved from this topic to <a class=\"stream-topic\" data-stream-id=\"513188\" href=\"/#narrow/channel/513188-CSLib/topic/Project.20board/with/542920049\">#CSLib &gt; Project board</a> by <span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span>.</p>",
        "id": 542920050,
        "sender_full_name": "Notification Bot",
        "timestamp": 1759489098
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> I think what you have now is pretty good.  I'll take a closer look and provide more concrete feedbacks later.</p>\n<p>I think some of the constructions on NA actually make perfect sense on LTS.  Examples include sum and product constructions:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Sum.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Sum.lean</a><br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Prod.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Prod.lean</a><br>\nDo they already exist in the LTS literature?</p>\n<p>Your experience with failed attempts accords with my own.  I think there is actually a deeper mathematical reason behind this.  In the usual automata theory textbooks, the closure properties of regular languages are all proved using construction on NA, except for the closure under complementation, which uses a construction on DA and a NA → DA conversion.  Only recently did I learn from reading Choueka's paper that it is actually possible to prove all the closure properties using DA alone, including the constructions for concatenation and Kleene-star.  So DA is very much its own thing and not really a special case of NA, as it superficially seems to be.</p>",
        "id": 543013348,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759518502
    },
    {
        "content": "<p>That's good to hear!</p>\n<p>As far as I know we typically deal with union for LTS (which might be Sum? I'll have a look), but the literature is vast and there might something similar.<br>\nI'm certainly finding it very nice to apply things I know are normally formulated for NFAs to LTS, so looking at what constructions we can generalise seems very good to me.</p>\n<p>I've added to the branch an example of how epsilonNA could be formulated, keeping the Option design choice. I'm basically instantiating \\tau-transitions as none-transitions, and then the transition relation is 'just' what we call saturated transitions in LTS. Hopefully this will yield a very easy proof of its correctness (<code>theorem toNAWithoutEpsilon_language_eq</code>, still have to try).</p>",
        "id": 543014016,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759518814
    },
    {
        "content": "<p>Once we're done looking at these automata on finite words, I'd really like to look together into how your work on omega automata applies here. (There you're more of an expert, I think, so I'd suggest you create those files, if you're willing.)</p>",
        "id": 543014245,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759518916
    },
    {
        "content": "<p>Yes, I can work on creating those files.</p>",
        "id": 543017949,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759520030
    },
    {
        "content": "<p>I created a PR for a new datatype <code>ωList</code> to represent infinite words:<br>\n<a href=\"https://github.com/leanprover/cslib/pull/80\">https://github.com/leanprover/cslib/pull/80</a><br>\nI assume that finite words will be represented by <code>List</code>.</p>",
        "id": 543036550,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759530575
    },
    {
        "content": "<ol>\n<li><code>ωList</code> is a great name</li>\n<li>Why not rename Mathlib's <code>Stream'</code> to <code>ωList</code> instead of diverging?</li>\n</ol>",
        "id": 543036905,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1759530876
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/543036905\">said</a>:</p>\n<blockquote>\n<ol>\n<li><code>ωList</code> is a great name</li>\n<li>Why not rename Mathlib's <code>Stream'</code> to <code>ωList</code> instead of diverging?</li>\n</ol>\n</blockquote>\n<p>Please read this thread: <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Why.20is.20Stream.27.20called.20Stream.27.3F/with/543032393\">#mathlib4 &gt; Why is Stream' called Stream'?</a> .  Renaming <code>Stream'</code> to something else was my original proposal.  In particular, I think Mario wants to keep <code>Stream'</code> for coinductively defined streams that may become a reality in the future, at which point the implementation of <code>Stream'</code> will change completely.  Also, he does make a good point about the disruptiveness of name change of existing API.</p>",
        "id": 543039863,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759533656
    },
    {
        "content": "<p>I thought that thread was actually going to rename <code>Stream'</code>, did they decide against it?<br>\nI don't think that many things rely on <code>Stream'</code> for it to be disruptive.<br>\nAlso you didn't suggest <code>ωList</code> there, which I think is the best name suggested so far.</p>",
        "id": 543040122,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1759533882
    },
    {
        "content": "<p>Read the end part of the thread.  The name <code>ωList</code> occurred to me only afterwards.  Anyway, my PR is for cslib, not mathlib.</p>",
        "id": 543040223,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759533977
    },
    {
        "content": "<p>Oh well. How about defining aliases for it in CSLib then?<br>\nFor example <code>def drop (n : ℕ) (s : ωList α) := Stream'.drop n s</code><br>\nThen <code>Stream'</code> will be the source of truth, and CSLib will only contain the rename.<br>\nI'm against copying code, that usually creates problems.</p>",
        "id": 543040454,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1759534203
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"933054\">@Snir Broshi</span> , do you mind making your comments on <code>ωList</code> in the PR instead?  Thanks!</p>",
        "id": 543040536,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759534273
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> I have some  comments about your automata code:</p>\n<ol>\n<li>I would recommend moving the accepting condition from DA and NA to DFA and NFA.  This is because NA and DA will also be used for automata on infinite words and those automata can have more complicated accepting conditions.  For example, the accepting condition of a Muller automaton is a set of subsets of states and that of a Rabin automaton is a set of pairs of subsets of states. By removing the accepting condition from DA and NA, you will allow Muller and Rabin automata to be defined as extensions of DA and NA.</li>\n<li>As part of the above, the definitions and theorems related to accepted languages should also be moved from DA/NA to DFA/NFA.  But the NA section of DA (namely, the stuff related DA.toNA) can stay in DA.</li>\n<li>I think the subset construction should be split into a separate file.  Each automata construction should get its own file.</li>\n<li>I wonder if the <code>finite_symbol</code> assumption is warranted in DFA, NFA, etc.  As I mentioned before, this assumption is not needed in all the automata theory results I've seen and the only place I think it is needed is to ensure that a regular expression is a finite object.  Maybe it should be left out and brought in only when needed.</li>\n<li>I recommend introducing a namespace <code>Automata</code> above <code>DA</code> and <code>NA</code>, because the latter are very short names and we may want to re-use them in a different context.</li>\n<li>Nitpick: You probably want to add explicit <code>variable</code> declarations of <code>State</code>, <code>Symbol</code>, etc, rather than leaving them implicit.</li>\n</ol>",
        "id": 543042359,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759535997
    },
    {
        "content": "<p>One more comment: I think I still prefer <code>Alphabet</code> over <code>Symbol</code>.  I know an expression like <code>x : Alphabet</code> looks weird, but so do <code>Finite Symbol</code>, <code>finite_symbol</code>, and <code>Language Symbol</code> (see <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/Language.html\">Language</a>).  <code>Alphabet</code> is the standard terminology.  Let's use it.</p>",
        "id": 543047402,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759540487
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> Thanks for the good comments.</p>\n<ol>\n<li>Right.. Also, I've just added EpsilonNA, and it shows that problem, too (it extends NA, but its acceptance condition is different than NA, which is just gonna cause headaches!). I've moved things around.</li>\n<li>I've moved this to DFA and NFA for now, too, for consistency. The problem is that the proof of correctness of that translation requires knowing the notion of acceptance. I would come back to this once we merge the first omega automata, so that we can look at what we can unify.</li>\n<li>Done -- and every translation now has its own file. We can come back to this too.</li>\n<li>I think it might be important once we get to regexps (like you say) and how to compute things with automata. So for now I'd keep it around (also because we need to keep them around in the translations between automata). We might wanna reconsider this and extend the hierarchy once we get further down the road of regexes, etc. But it's nontrivial to figure out the names, so for now I'm happy to postpone this problem. It might also very well be, like you say, that it might suffice to take these things as parameters where needed. I'd just like to see some code that uses these things before committing to a choice.</li>\n<li>With the new structure where lots of things have been moved to DFA, NFA, etc., I hardly use DA or NA outside of structures that extend them, so I didn't perceive it as a big problem any longer. But I'm happy to reconsider this if some code starts getting too clunky; it's easy to change.</li>\n<li>Lean seems to do the right and intuitive thing, but I agree it wouldn't hurt.. I'll keep that in mind for future edits of these files. (Or if anybody wants to make a PR for this, it'd be welcome.)</li>\n</ol>",
        "id": 543279075,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759748060
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/543047402\">said</a>:</p>\n<blockquote>\n<p>One more comment: I think I still prefer <code>Alphabet</code> over <code>Symbol</code>.  I know an expression like <code>x : Alphabet</code> looks weird, but so do <code>Finite Symbol</code>, <code>finite_symbol</code>, and <code>Language Symbol</code> (see <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/Language.html\">Language</a>).  <code>Alphabet</code> is the standard terminology.  Let's use it.</p>\n</blockquote>\n<p>I'll mull over it. I see your point but for some reason my brain switches to set theory when I hear alphabet and I get some cognitive dissonance when then looking at the Lean code..</p>",
        "id": 543280766,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759748555
    },
    {
        "content": "<p>I think we have a good design now, so I've made a PR that summarises everything so far: <a href=\"https://github.com/leanprover/cslib/pull/83\">https://github.com/leanprover/cslib/pull/83</a></p>",
        "id": 543280931,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759748607
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>  Your automata PR looks good.  I've added some comments.</p>",
        "id": 543386812,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759776369
    },
    {
        "content": "<p>I can't seem to find them?</p>",
        "id": 543389396,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759777323
    },
    {
        "content": "<p>Hmm, I can see them: <a href=\"https://github.com/leanprover/cslib/pull/83\">https://github.com/leanprover/cslib/pull/83</a>.  There are 4 comments.</p>",
        "id": 543389654,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759777421
    },
    {
        "content": "<p>can you link to one of them? I see only <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span>'s comments for some reason.</p>",
        "id": 543389851,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759777490
    },
    {
        "content": "<p>You might need to submit the review, if you've started a review.</p>",
        "id": 543390081,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759777566
    },
    {
        "content": "<p>better :)</p>",
        "id": 543390289,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759777652
    },
    {
        "content": "<p>Can you see them now?</p>",
        "id": 543390361,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759777684
    },
    {
        "content": "<p>yep!</p>",
        "id": 543390376,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759777689
    },
    {
        "content": "<p>Great!</p>",
        "id": 543390395,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759777698
    },
    {
        "content": "<p>all done, modulo the last two comments (see my replies), which I agree with but since they're backwards compatible extensions I'd like to address them in a future PR.</p>",
        "id": 543392110,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759778369
    },
    {
        "content": "<p>Thanks both, very good comments</p>",
        "id": 543392142,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759778383
    },
    {
        "content": "<p>I created a PR to show what the definitions of Büchi and Muller automata will look like:<br>\n<a href=\"https://github.com/leanprover/cslib/pull/85\">https://github.com/leanprover/cslib/pull/85</a><br>\nUnfotunately, since it depends two other PRs, the PR shows too many changed files.  The only  really relevant files are:<br>\nCslib/Computability/Automata/{DA,NA,BuchiNA,MullerDA}.lean</p>",
        "id": 543410150,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759785693
    },
    {
        "content": "<p>As a reminder, you can link to PRs like this: <a href=\"https://github.com/leanprover/cslib/pull/85\">cslib#85</a></p>",
        "id": 543412057,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759786443
    },
    {
        "content": "<p>Just caught up with the discussion on OmegaList. There seem to be valid points on both sides.<br>\nBefore I think more about this, could somebody explain why nobody has gone for the negative coinductive formulation (see, e.g., <a href=\"https://rocq-prover.org/doc/V8.14.1/refman/language/core/coinductive.html#caveat\">https://rocq-prover.org/doc/V8.14.1/refman/language/core/coinductive.html#caveat</a> and <a href=\"https://proofassistants.stackexchange.com/questions/4142/what-is-a-positive-coinductive-type-and-why-are-they-so-bad\">https://proofassistants.stackexchange.com/questions/4142/what-is-a-positive-coinductive-type-and-why-are-they-so-bad</a>)? That is something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ωList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωList</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>One can then even define a view like this if we need it (this is just an example, we should use other functions in this, like skip I guess):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ωList</span><span class=\"bp\">.</span><span class=\"n\">toFunction</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">head</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"bp\">.</span><span class=\"n\">toFunction</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>Is this just unworkable when making interesting definitions, because of termination checking? I haven't tried it much, just wanted to hear opinions.</p>",
        "id": 543524072,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759841536
    },
    {
        "content": "<p>My assumption was that the type of <code>Stream'</code> was selected because it was determined to be the easiest way to emulate coinductive definitions given such issues.</p>",
        "id": 543552507,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759848628
    },
    {
        "content": "<p>Attached below is a page from the following survey article:<br>\n<a href=\"/user_uploads/3121/sy9tl8tYukzewgKTkOxiaIeS/automata-on-infinite-words.pdf\">automata on infinite words.pdf</a></p>\n<blockquote>\n<p>Thomas, Wolfgang (1990). \"Automata on infinite objects\". In Van Leeuwen (ed.). Handbook of Theoretical Computer Science. Elsevier. pp. 133–164.</p>\n</blockquote>\n<p>That's the sort of thing I want to formalize.  Does anyone see co-induction there?  (If you do, please specify where precisely you see it used.)  Is a type that is basically <code>ℕ → α</code> but also supports the dot-notation not good enough?  For example, the following notations:<br>\n<a href=\"/user_uploads/3121/cqq__JWKOAhyOwtyvWUmL_xC/image.png\">image.png</a><br>\nare called <code>s.extract m n</code> and <code>s.drop m</code>, where <code>s : ωList</code> represents an infinite sequence.  (Note that the naming convention agrees with that of <code>List</code> quite nice.)  The following function:<br>\n<a href=\"/user_uploads/3121/NWROPBel31cqBqcCfsCAPIE-/image.png\">image.png</a><br>\nis translated quite literally as:</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/cqq__JWKOAhyOwtyvWUmL_xC/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"861x44\" src=\"/user_uploads/thumbnail/3121/cqq__JWKOAhyOwtyvWUmL_xC/image.png/840x560.webp\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/NWROPBel31cqBqcCfsCAPIE-/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"332x52\" src=\"/user_uploads/thumbnail/3121/NWROPBel31cqBqcCfsCAPIE-/image.png/840x560.webp\"></a></div><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ωList</span><span class=\"bp\">.</span><span class=\"n\">infOcc</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωList</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃ᶠ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">atTop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Yet someone was telling me that (1) I should be using <code>Stream'</code> and (2) with an expression like <code>xs k</code>, I have committed the sin of \"defeq abuse\".</p>",
        "id": 543639702,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759881953
    },
    {
        "content": "<p>As I said in the review (<a href=\"https://github.com/leanprover/cslib/pull/80\">cslib#80</a>), my mention of <em>potential</em> defeq abuse is not my primary issue. My main concern is the tradeoffs of duplicating code from <code>Steam'</code> in CSLib. I think I have written down all my relevant thoughts on the review.</p>",
        "id": 543641224,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759883069
    },
    {
        "content": "<p>I've been reading up some papers and the discussions on Zulip. Much of the discussion on <code>Stream'</code> stems from the fact that <code>Stream'</code>'s goal is to be a data structure that cannot be written yet, so for now it's defined as a function hidden by a good API. We shouldn't confuse the two concepts.</p>\n<p>I've drafted a new design in the branch <code>omega-sequence</code> to facilitate our discussion: <a href=\"https://github.com/leanprover/cslib/tree/omega-sequence\">https://github.com/leanprover/cslib/tree/omega-sequence</a></p>\n<p>In particular, you'll find two files:</p>\n<ul>\n<li><code>Cslib.Foundations.Data.OmegaList</code>, defining the data structure <code>ωList</code>. This is probably useless until we get good support for coinduction. It is what <code>Stream'</code> is intended to be, i.e., a data type to be used in programs. But although it cannot be inhabited, I could write some definitions about it, so we can at least keep track of some basic things and the fact that we want it to be translatable into an <code>ωSequence</code>.</li>\n<li><code>Cslib.Foundations.Data.OmegaSequence</code>, defining <code>ωSequence</code> as a function <code>ℕ → α</code>. This is what <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> is using. <code>ωSequence</code> embraces that it is supposed to be used as a function (whether it is defined as such doesn't matter too much).</li>\n</ul>\n<p>Of course, since the implementations of <code>ωSequence</code> and <code>Stream'</code> are coincidentially the same for now, this will lead to some duplication of code. So I'd like that we port features from <code>Stream'</code> to <code>ωSequence</code> only when they're actually used.</p>\n<p><span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span>, questions:</p>\n<ul>\n<li>Do you need to write <code>s i</code> or would you be equally happy with writing <code>s[i]</code>? We can easily define a <code>GetElem</code> instance that never requires a side-condition.</li>\n<li>Are you happy with replacing <code>ωList</code> with <code>ωSequence</code> in your code? (I've taken the liberty of putting your name on top of the <code>ωSequence</code> file for now, since it's basically your <code>ωList</code>.)</li>\n</ul>",
        "id": 543709917,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759918874
    },
    {
        "content": "<p>I'm proposing this also because even in mathlib there are different uses, like here: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Polynomial/Sequence.html#Polynomial.Sequence\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Polynomial/Sequence.html#Polynomial.Sequence</a></p>",
        "id": 543710188,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759918966
    },
    {
        "content": "<p>I'm happy with the name <code>ωSequence</code>.  Although it is longer than <code>ωList</code>, it is also a more accurate description of what the type actually is.  But I do not like to write <code>s[n]</code>.  Since we have made it clear that <code>ωSequence α</code> is but a (thin) abstraction of <code>ℕ → α</code>, we should take that POV seriously and be able to use the function application notation <code>s i</code> and not clutter the code with pointless <code>[...]</code>.  (In contrast, there is a good reason for <code>List</code> and <code>Array</code> to use the <code>[...]</code> notation, because out-of-bound access is not well-defined.  So several variations <code>[...]'h</code>, <code>[...]?</code>, and <code>[...]!</code> need to be differentiated and supported.  This is obviously not an issue for <code>ωSequence</code>: <code>s n</code> is always well-defined for any <code>s : ωSequence α</code> and <code>n : ℕ</code>.)</p>\n<p>I do have a concern about using the name <code>ωList</code> for the co-inductive version of infinite sequence.  The concern is not about the name itself, but about the fact that we are probably going to use the existing <code>List</code> type for finite sequences/words.  So the question may be raised about why we choose to use <code>List</code> to represent finite words/executions but use <code>ωSequence</code> instead of <code>ωList</code> to represent infinite words/sequences.  The answer is of course that the theory of ω-automata (or temporal logic, for that matter) just doesn't use co-induction in its development, while the theory of automata on finite words will frequently take advantage of the inductive structure of <code>List</code>.  But that's an answer that is probably too long to avoid all confusions.  Perhaps a better name for the co-inductive view of infinite sequences could be <code>ωStream</code>?  The current <code>Stream</code> (without the prime) type in mathlib is a type of both finite and infinite sequences, so the <code>ω</code> in <code>ωStream</code> would be quite appropriate.  (Admittedly, one thing I learned from all these discussions is that there seems to be a lot of disagreements about what exactly a \"stream\" is in the literature.)</p>",
        "id": 543814146,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759949534
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/540984303\">said</a>:</p>\n<blockquote>\n<p>Tested a bit the first route and it looks pretty ok to me. :)</p>\n<p><a href=\"https://github.com/leanprover/cslib/blob/automata/Cslib/Computability/Dfa/Basic.lean\">https://github.com/leanprover/cslib/blob/automata/Cslib/Computability/Dfa/Basic.lean</a></p>\n<p>If we go down this route I could (should?) probably move the lts results to a dedicated Dfa/Lts.lean file.</p>\n</blockquote>\n<p>Hopping on the CSLib train as well. (I missed the launch as I was teaching a lot lately...)</p>\n<p>Question: I foresee that I can mobilize some students to work on process algebra, which relies on Lts as a semantics as well. Do we consider this \"the same\" as automata theory, or should Lts be placed more general than automata theory? (Same remark for Petri Nets)</p>\n<p>My instinct would be to consider \"syntactic\" and \"semantic\" definitions as different things and let them live in different directories.</p>",
        "id": 543821110,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1759952142
    },
    {
        "content": "<p>I still strongly disagree with this direction, but I appreciate that we have thoroughly discussed it at least. Thank you for your patience.</p>\n<p>Regarding the points above:</p>\n<p>I think the naming of the \"co-inductive\" version is not so crucial since as Fabrizio points out we won't be able to do much with it. I personally would wait until it's inevitably defined upstream, but it probably won't matter much either way.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/543814146\">said</a>:</p>\n<blockquote>\n<p>But I do not like to write <code>s[n]</code>.  Since we have made it clear that <code>ωSequence α</code> is but a (thin) abstraction of <code>ℕ → α</code>, we should take that POV seriously and be able to use the function application notation <code>s i</code> and not clutter the code with pointless <code>[...]</code>.</p>\n</blockquote>\n<p>Please correct me if I am wrong, but my understanding is that a type being a \"thin wrapper\" is antithetical to the design philosophy of Mathlib, whose conventions we have decided to adhere to as much as possible. This would sidestep the API defined by for instance <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27.get#doc\">docs#Stream'.get</a>, making it useless to have in the first place. If you could show me where in Mathlib <code>Stream'</code> is used like this, I would be more inclined to accept this usage. I agree that <code>GetElem</code> is awkward for the reasons you state, I only offered the idea as a compromise that gave you close to the notation you want.</p>",
        "id": 543823245,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759952964
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/542630752\">said</a>:</p>\n<blockquote>\n<p>Sorry for the late reply.</p>\n<p>Yes, I think compatibility with mathlib should take precedence.  Whether the transition part of an automaton is called <code>step</code> or <code>Tr</code> or <code>next</code> is of no real mathematical consequence.  Personally I do not want to spend my time fighting it.</p>\n<p>As to whether the transition part of an automaton should have the type <code>State → Symbol → Set State</code> or <code>State → Symbol → State → Prop</code>, I think both options are valid and both have long traditions, though I think the former has a longer tradition.  Attached below is Rabin and Scott's seminal 1959 paper in which the notion of a nondeterministic automaton first appeared:<br>\n<a href=\"/user_uploads/3121/zTIgyC4Ik9oTdQID_9iaodgO/Rabin-and-Scott-Finite_Automata_and_Their_Decision_Problems.pdf\">Rabin and Scott - Finite_Automata_and_Their_Decision_Problems.pdf</a><br>\nTake a look at Definition 9 on page 120, which uses the first option.  As far as I can tell, most of the subsequent textbooks on automata theory also continued that tradition.</p>\n<p>All the above is just a long way for me to say that there is nothing wrong with both options to exist in mathlib and I think it is even valuable to have definitions and theorems for going back and forth between them.</p>\n<p>A personal rant: If Lean didn't have \"sets\" in the first place, we wouldn't need to discuss this topic at all.  I once raised the topic of why does Lean have \"sets\" at all and was promptly shot down:</p>\n<p><a class=\"message-link\" href=\"/#narrow/channel/113489-new-members/topic/How.20do.20I.20prove.20this.20about.20Nat.2Enth.3F/near/522848837\">#new members &gt; How do I prove this about Nat.nth? @ 💬</a></p>\n</blockquote>\n<p>Just a comment from my experience, I've found <code>State -&gt; Symbol -&gt; State -&gt; Prop</code> to be more convienient while generating structured operational semantics. One can simply mimick SOS-rules using something like:</p>\n<p><code>inductive MySOS State -&gt; Symbol -&gt; State -&gt; Prop where\n  | concatenate_rule (x a y) (y b z) (_ : c = a + b) : MySOS x c z</code></p>\n<p>With the <code>State -&gt; Symbol -&gt; Set State</code> based approach, this is more of a hassle, I think.</p>",
        "id": 543823388,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1759953024
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"563058\">@Pieter Cuijpers</span> I think <span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> has made LTS sufficiently flexible for the same LTS to support both styles now.</p>",
        "id": 543823674,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759953152
    },
    {
        "content": "<p>PR for the initial version of ωSequence: <a href=\"https://github.com/leanprover/cslib/pull/90\">cslib#90</a></p>",
        "id": 543844609,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759963081
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> Will something like the following make you feel better?  Is it possible to define another coercion to get rid of the invocations of <code>ωSequence.mk</code> below?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">coe</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"bp\">.</span><span class=\"n\">seq</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">coeFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">seq</span><span class=\"o\">)}</span>\n\n<span class=\"sd\">/-- Head of an ω-sequence: `ωSequence.head s = ωSequence s 0`. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"sd\">/-- Tail of an ω-sequence: `ωSequence.tail (h :: t) = t`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- Drop first `n` elements of an ω-sequence. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">drop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- `take n s` returns a list of the `n` first elements of ω-sequence `s` -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">take</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">take</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- Get the list containing the elements of `xs` from position `m` to `n - 1`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">extract</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">take</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">drop</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 543849797,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759967642
    },
    {
        "content": "<p>Originally (in <a href=\"https://github.com/leanprover/cslib/pull/80\">cslib#80</a>) you also ported an equivalent of <code>Stream'.get</code>, which is meant to be the API used instead of directly accessing with function application. In the new PR it seems you have removed <code>get</code> completely, and instead definitions like <code>Any</code>, <code>All</code>, etc. that were originally defined using <code>get</code> are now directly using application.</p>\n<p>In the context of the original PR, I would maybe have suggested:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">coe</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"bp\">.</span><span class=\"n\">seq</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">coeFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>with the point being that the one field structure prevents directly applying, then the coercion is defined in terms of the API. (And if you really need to convert to a function, the generated equational lemmas are still there)</p>\n<p>Without defining things in terms of <code>get</code> as you have done in this latest PR, I don't see a reason for the misdirection. As you have said, it is a \"thin abstraction\" that does not follow the Mathlib pattern of defining and using API.</p>",
        "id": 543855286,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759972355
    },
    {
        "content": "<p>I think my latest design is in the same spirit as (though much simpler than) <code>Equiv</code>:<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Logic/Equiv/Defs.html#Equiv\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Logic/Equiv/Defs.html#Equiv</a><br>\nwhere if you have <code>f : α ≃ β</code> and <code>a : α</code>, you can (and indeed are advised to) write <code>f a</code>, instead of <code>f.toFun a</code>.  Note that <code>ωSequence.get = fun s ↦ s.seq</code> is a theorem.</p>\n<p>I think a good name for <code>ωSequence.mk</code>is <code>ωSequence.ofFn</code>, just like <code>List.ofFn</code> and <code>Array.ofFn</code>.  The following definitions are already more than what I needed in automata theory.  I think I'll get rid of most of the other API functions.  For example, if we take seriously the POV that <code>ωSequence α</code> is just an abstraction of <code>ℕ → α</code> which also supports the dot-notation, then we don't need <code>All s</code> because we can just write <code>∀ n, s n</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">coe</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"bp\">.</span><span class=\"n\">seq</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">coeFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">seq</span><span class=\"o\">)}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ofFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"sd\">/-- Head of an ω-sequence: `ωSequence.head s = ωSequence s 0`. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"sd\">/-- Tail of an ω-sequence: `ωSequence.tail (h :: t) = t`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ofFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- Drop first `n` elements of an ω-sequence. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">drop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ofFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- `take n s` returns a list of the `n` first elements of ω-sequence `s` -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">take</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">take</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- Get the list containing the elements of `xs` from position `m` to `n - 1`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">extract</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">take</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">drop</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Prepend an element to an ω-sequence. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ofFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"kn\">infixr</span><span class=\"o\">:</span><span class=\"mi\">67</span><span class=\"w\"> </span><span class=\"s2\">\" :: \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cons</span>\n\n<span class=\"sd\">/-- Append an ω-sequence to a list. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">appendωSequence</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">::</span><span class=\"n\">appendωSequence</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">infixl</span><span class=\"o\">:</span><span class=\"mi\">65</span><span class=\"w\"> </span><span class=\"s2\">\" ++ω \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">appendωSequence</span>\n</code></pre></div>",
        "id": 543862424,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759978678
    },
    {
        "content": "<p>Maybe I was unclear. I don't really see the point of the structure or <code>CoeFun</code> at all if you're dropping the <code>get</code> API.</p>\n<p>And if you did have a structure, I would not define <code>.ofFun</code> when it is the same as the default <code>.mk</code> constructor.</p>",
        "id": 543866078,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759981841
    },
    {
        "content": "<p>I see.  Then I won't use <code>structure</code>, but I will get rid of some of the APIs.</p>",
        "id": 543869824,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1759985045
    },
    {
        "content": "<p>I'll try to reply to your points in a single go, <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> and <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span>, hopefully in a coherent way:</p>\n<ul>\n<li>We should of course try to make cslib work well with mathlib, not duplicate code, etc. But this situation seems a bit special to me. What <code>Stream'</code> is supposed to be can't be defined, and this led to understandable compromises. Unfortunately, misusing it is way too easy. For example, I'd accessed it as a function in all my development of divergence in LTS (see <a href=\"https://github.com/leanprover/cslib/blob/e9cfac98021aefab859d7310482266f72e772180/Cslib/Foundations/Semantics/LTS/Basic.lean#L585\">https://github.com/leanprover/cslib/blob/e9cfac98021aefab859d7310482266f72e772180/Cslib/Foundations/Semantics/LTS/Basic.lean#L585</a>), because I wasn't aware that the future of <code>Stream'</code> is to be become an actual data structure. I tried to define it so that the underlying function definition becomes unaccessible, without success.</li>\n<li>It seems that the literature on omega automata works with infinite sequences, not streams. These are not the same. The former is usually formalised as a function, either with Nat (our case here) or Int (for sequences that can be infinite in two directions) as domain. It is a coincidence that <code>Stream'</code> can be misused as an infinite sequence now. I really dislike the code duplication, too. So if there are ideas to avoid it by means of typeclasses or other clever usages of Lean features, I'm all ears.</li>\n<li>In mathlib itself, I see at least an example of people using a sequence instead of <code>Stream'</code>: <a href=\"https://github.com/leanprover-community/mathlib4/blob/3540854faab731972101b97b709a67bf0fe8636f/Mathlib/Algebra/Polynomial/Sequence.lean#L39-L44\">https://github.com/leanprover-community/mathlib4/blob/3540854faab731972101b97b709a67bf0fe8636f/Mathlib/Algebra/Polynomial/Sequence.lean#L39-L44</a>.</li>\n<li>My formulation of <code>ωSequence</code> is a def, not a structure, exactly because it embraces <em>being</em> a function (not a wrapper). I was asking about potential uses exactly to ensure that it's ok not defining any getter methods. It should be a function, also by contract (that's why I documented it as such).</li>\n<li><code>Stream'.Seq</code> is not what we want, either.</li>\n</ul>\n<p>We're the ones with the immediate need to use workable infinite sequences (not streams/colists) to define a sizable part of automata theory, which is core to CS. Hence my proposal to just introduce a new type (<code>ωSequence</code>) that is intended to be used exactly as we need and can be implemented with current Lean features.</p>",
        "id": 543889223,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759995338
    },
    {
        "content": "<p>I understand your intent for <code>ωSequence</code> to \"embrace being a function\". I think that in Mathlib the response would be to question having a def designed for defeq abuse rather than using a function type directly and having dot notation from the <code>Function</code> namespace as Mario pointed out.  Of course, we are free to make our own decision and be a bit less rigid about this (and Mathlib does sometimes too!). </p>\n<p>My position remains that despite the undesirability of using <code>Stream'</code> because of its future as coinductive data that it is preferable to the ~1000 lines of code duplication being proposed. My reasoning is if we are able to express everything we want through the long-standing API of <code>Stream'</code>, I think that the usual deprecation cycle of Mathlib will ensure that all existing code has a path to migration. I would rather follow this lifecycle than redefine things ourselves. </p>\n<p>I will reiterate again that I am fine to defer to your decision, and am satisfied that you have considered all our arguments. I will be happy either way to move on to PRs for the much more interesting work <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> has done!</p>",
        "id": 543898320,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759998242
    },
    {
        "content": "<p>I tried what Mario suggested in that thread and I couldn't put the dot-notation stuff for Function under a specialised namespace. The only way it worked was to put it directly under <code>Function</code>, instead of, say <code>ωSequence.Function</code> or something like that (opening <code>ωSequence</code> then didn't give me access to the defs through dot-notation). So I'm at a bit of a loss regarding how to keep this thing not leak to dependencies, unless we adopt a definition like this.</p>",
        "id": 543899041,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759998431
    },
    {
        "content": "<p>(I forgot to mention I tried this, thanks for bringing it up.)</p>",
        "id": 543899119,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759998451
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 543899910,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759998668
    },
    {
        "content": "<p>I see what you mean, but I don't have a problem with adding to existing namespaces like that. We do so already in other places. It doesn't really solve code duplication though, it just means it gets duplicated in the <code>Function</code> namespace instead.</p>",
        "id": 543900482,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759998820
    },
    {
        "content": "<p>Normally I don't have a problem either, I guess here I'm just a bit extra wary because the future of this is likely that we'll add <em>so much stuff</em> to Function that is really domain-specific.</p>",
        "id": 543901084,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759998976
    },
    {
        "content": "<p>The code duplication I don't know how to avoid, unfortunately, as soon as one <em>wants</em> to use a function as interface for sequences.. :-\\</p>",
        "id": 543901210,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759999017
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/543899041\">said</a>:</p>\n<blockquote>\n<p>I tried what Mario suggested in that thread and I couldn't put the dot-notation stuff for Function under a specialised namespace. The only way it worked was to put it directly under <code>Function</code>, instead of, say <code>ωSequence.Function</code> or something like that (opening <code>ωSequence</code> then didn't give me access to the defs through dot-notation). So I'm at a bit of a loss regarding how to keep this thing not leak to dependencies, unless we adopt a definition like this.</p>\n</blockquote>\n<p>cc: <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span></p>",
        "id": 543934263,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760009348
    },
    {
        "content": "<p>for my part the backup plan if dot notation doesn't work is to just not use dot notation, put everything in a namespace and open it so the functions don't get too long to write. I don't think it should be a deal breaker, lots of functions are written without dot notation</p>",
        "id": 543934688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760009492
    },
    {
        "content": "<p>An alternative I've toyed around with in my head looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">drop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- etc. etc.</span>\n\n<span class=\"c1\">-- Could also include:</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GetElem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">getElem</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">i</span>\n</code></pre></div>\n<p>This would hide it's a function, and future coinductive data structures could just instantiate it. I'm just not sure if the level of indirection would really be worth it, and whether I'm abusing the class mechanism here.</p>",
        "id": 543942326,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760011809
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/543934688\">said</a>:</p>\n<blockquote>\n<p>for my part the backup plan if dot notation doesn't work is to just not use dot notation, put everything in a namespace and open it so the functions don't get too long to write. I don't think it should be a deal breaker, lots of functions are written without dot notation</p>\n</blockquote>\n<p>I guess in this solution we could, optionally, still have <code>ωSequence</code> as an <code>abbrev</code>?</p>",
        "id": 543942534,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760011861
    },
    {
        "content": "<p>you could call the <code>at</code> field <code>get</code> since that's what it is</p>",
        "id": 543947338,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760013192
    },
    {
        "content": "<p>Yes ofc</p>",
        "id": 543952483,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760014501
    },
    {
        "content": "<p>(That's actually what it was but somebody was confused that it doesn't require a side-condition. Anyway, doesn't matter.)</p>",
        "id": 543952661,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760014545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/543898320\">said</a>:</p>\n<blockquote>\n<p>My position remains that despite the undesirability of using <code>Stream'</code> because of its future as coinductive data that it is preferable to the ~1000 lines of code duplication being proposed. </p>\n</blockquote>\n<p>In the 2nd commit of <a href=\"https://github.com/leanprover/cslib/pull/90\">cslib#90</a> I have whittled down the API functions and associated theorems down to ~600 lines (including comments).  Note  that:</p>\n<ol>\n<li>Even the remaining API functions are way more than what I actually used in the omega automata theory, where I needed only  <code>const</code>,<code>drop</code>, <code>take</code>, <code>extract</code>, and <code>appendωSequence</code>.  I kept some iterators as they seem to be potentially useful even with an <code>ℕ → α</code> view of infinite sequences.</li>\n<li>The API function <code>extract</code> is NOT in <code>Stream'</code> and about 80 lines of theorems are about <code>extract</code>.  So the actual LOC we are carrying over from <code>Stream'</code> is about 500.</li>\n</ol>",
        "id": 544035271,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1760038814
    },
    {
        "content": "<p>I've made this point before and I'll make it again: if we want to support reasoning about infinite sequences (which are used not only in automata theory but also in temporal logic and related topics), we should be willing to pay the cost of maintaining a data type which is truly an abstraction of <code>ℕ → α</code>and not designed for some other purpose.</p>",
        "id": 544036158,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1760039162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/543942326\">said</a>:</p>\n<blockquote>\n<p>An alternative I've toyed around with in my head looks like this:<br>\n[ ... ]</p>\n</blockquote>\n<p>I think this approach is similar to the experiment I gave in an earlier message of this thread:<br>\n<a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/543862424\">https://leanprover.zulipchat.com/#narrow/channel/513188-CSLib/topic/Automata/near/543862424</a><br>\nAs you can see, I really don't want to have to use <code>get</code> or <code>getElem</code>, which always seems unnecessarily bureaucratic to me when I think of infinite sequences as objects of type <code>ℕ → α</code> in my mind.  So I coerce it away.  I think the main drawback of this approach is that you probably need an explicit constructor function to convert a function of type <code>ℕ → α</code> to an infinite sequence of type <code>ωSequence α</code>.  This is also too bureaucratic in my view, but more tolerable than to have to use <code>get</code> or <code>getElem</code> all over the place.</p>",
        "id": 544040407,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1760040912
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/543942534\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/543934688\">said</a>:</p>\n<blockquote>\n<p>for my part the backup plan if dot notation doesn't work is to just not use dot notation, put everything in a namespace and open it so the functions don't get too long to write. I don't think it should be a deal breaker, lots of functions are written without dot notation</p>\n</blockquote>\n<p>I guess in this solution we could, optionally, still have <code>ωSequence</code> as an <code>abbrev</code>?</p>\n</blockquote>\n<p>I was using <code>ℕ → α</code> to represent infinite sequences in my automata theory project before I got fed up.  As you can see here:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/2c3ba16124d8bef9d5df5e7ba151ef6290705d67/AutomataTheory/Sequences/Basic.lean\">https://github.com/ctchou/AutomataTheory/blob/2c3ba16124d8bef9d5df5e7ba151ef6290705d67/AutomataTheory/Sequences/Basic.lean</a><br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/2c3ba16124d8bef9d5df5e7ba151ef6290705d67/AutomataTheory/Sequences/Basic.lean\">https://github.com/ctchou/AutomataTheory/blob/2c3ba16124d8bef9d5df5e7ba151ef6290705d67/AutomataTheory/Sequences/Basic.lean</a><br>\nit's not pretty.  I introduce a bunch of notations to emulate the dot-notation.  But they don't look good and don't let me use the same naming convention as in <code>List</code>.  (Note that the naming convention is not just about the API functions themselves, but also about the theorems they are involved in.)  Using <code>abbrev</code> is not going to work, because <code>abbrev</code> does not change the names and namespaces of the relevant theorems.  So the thin veneer provided by <code>abbrev</code> disappears immediately once you want to prove anything.</p>",
        "id": 544042548,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1760041940
    },
    {
        "content": "<p>Mmmh, I see. What about this then? <a href=\"https://github.com/leanprover/cslib/blob/omega-sequence/Cslib/Foundations/Data/OmegaSequence.lean\">https://github.com/leanprover/cslib/blob/omega-sequence/Cslib/Foundations/Data/OmegaSequence.lean</a></p>\n<p>I've coded things as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>This enables both accessing the sequence with function notation <em>and</em> to create one just by giving a function. For example, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">drop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This codifies the contract that <code>ωSequence</code> should be definable as a function, and be accessible as a function, while hiding away how it is implemented. We get easy coercions from both stream' and omegalist, if we want them:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ωList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">get</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Stream'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">get</span>\n</code></pre></div>",
        "id": 544103436,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760081463
    },
    {
        "content": "<p>This looks like the right way we wanna access a sequence tbh. Could somebody tell me if there's an advantage to doing this over just defining <code>ωSequence</code> to <em>be</em> a function?</p>",
        "id": 544104159,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760081731
    },
    {
        "content": "<p>The <code>FunLike</code> instance being defined as <code>get</code> means that you can write application freely that unfolds to the API, right? So it is technically abstracted from its implementation as a function without having to think about it. This is the proposal I've been most comfortable with so far.</p>",
        "id": 544107649,
        "sender_full_name": "Chris Henson",
        "timestamp": 1760082930
    },
    {
        "content": "<p>Yes, that's the idea. When you use function application, it unfolds to an invocation of <code>.get</code>. Unless you're proving theorems about <code>ωSequence</code>, you're never gonna use or see that <code>get</code>. If you do, however, it'll show, and then it's the same as defining it directly as a function.<br>\nWe could make the field private or protected (I'm not 100% sure about what they do) to restrict knowledge of this implementation detail to the file on omega sequence.</p>",
        "id": 544108478,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760083214
    },
    {
        "content": "<p>You can also provide an instance of <code>GetElem</code> to get array-like syntax (<code>lst[n]</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GetElem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ωList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">getElem</span><span class=\"w\"> </span><span class=\"n\">lst</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">lst</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>",
        "id": 544153862,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1760098210
    },
    {
        "content": "<p>Hey that reminds me of something :-) <a class=\"message-link\" href=\"/#narrow/channel/513188-CSLib/topic/Automata/near/543942326\">#CSLib &gt; Automata @ 💬</a></p>",
        "id": 544153953,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760098239
    },
    {
        "content": "<p>Ah, but you're proposing it for omega list! Yes, definitely!</p>",
        "id": 544154040,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760098268
    },
    {
        "content": "<p>FYI, your definition of <code>ωList</code> is an empty type</p>",
        "id": 544167894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760102270
    },
    {
        "content": "<p>We know, it's in the docstring. (But comment appreciated all the same.)</p>",
        "id": 544168008,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760102303
    },
    {
        "content": "<p>the docstring does not say this</p>",
        "id": 544168369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760102409
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">This</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">just</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">stub</span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">It</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">currently</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">possible</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">construct</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">manipulate</span><span class=\"w\"> </span><span class=\"n\">nicely</span><span class=\"w\"> </span><span class=\"n\">an</span>\n<span class=\"ss\">`ωList</span><span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">due</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">current</span><span class=\"w\"> </span><span class=\"n\">lack</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">coinduction</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>this is not saying that <code>ωList</code> is empty, it implies that better support will make it easier to write elements of the type but they provably don't exist</p>",
        "id": 544168540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760102450
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ωList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωList</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">nolist</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">False</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">nolist</span><span class=\"w\"> </span><span class=\"n\">tail</span>\n</code></pre></div>",
        "id": 544168668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760102486
    },
    {
        "content": "<p>If you are trying to write coinductive streams then please use <code>Stream'</code></p>",
        "id": 544168779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760102518
    },
    {
        "content": "<p>That's what I meant by 'it's not possible to construct'. I'll add a more explicit statement, thx.</p>",
        "id": 544168876,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760102548
    },
    {
        "content": "<p>I was expecting the difference between <code>ωList</code> and <code>ωSequence</code> to be that one is infinite lists and the other is possibly infinite lists</p>",
        "id": 544168932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760102565
    },
    {
        "content": "<p>OmegaList is what I expect Stream' to become one day: the data structure. We have the file just to collect desiderata/thoughts.</p>",
        "id": 544169091,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760102622
    },
    {
        "content": "<p>So nothing important right now.</p>",
        "id": 544169181,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760102648
    },
    {
        "content": "<p>OmegaSequence is an infinite sequence in one direction, as the name (I hope) implies.</p>",
        "id": 544169275,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760102683
    },
    {
        "content": "<p>If you want the data structure I would instead suggest</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ωList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span>\n</code></pre></div>",
        "id": 544169279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760102685
    },
    {
        "content": "<p>note that this has universe issues</p>",
        "id": 544169364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760102708
    },
    {
        "content": "<p>I tried variations of this and always had some problems so far.</p>",
        "id": 544169453,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760102738
    },
    {
        "content": "<p>Won't Stream' switch to be a data structure, when it becomes possible to have a nice one?</p>",
        "id": 544169585,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760102770
    },
    {
        "content": "<p>indeed</p>",
        "id": 544169610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760102777
    },
    {
        "content": "<p>I'd rather not try to do the same job. OmegaList shouldn't be really used.</p>",
        "id": 544169648,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760102789
    },
    {
        "content": "<p>which is why I don't understand why you are reinventing it</p>",
        "id": 544169649,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760102789
    },
    {
        "content": "<p>It's in that branch to explore the interplay between the data structure (that we can't really write yet) and OmegaSequence (which we're gonna use).</p>",
        "id": 544169820,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760102845
    },
    {
        "content": "<p>in that case you should relate <code>OmegaSequence</code> and <code>Stream'</code></p>",
        "id": 544169974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760102894
    },
    {
        "content": "<p>because these types are actually isomorphic without cheats</p>",
        "id": 544170003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760102905
    },
    {
        "content": "<p>Of course. That I would gladly even see go in the main branch, it wouldn't be a design thought experiment like this one. (Assuming that it only uses the API of stream', which can be done.)</p>",
        "id": 544170923,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760103143
    },
    {
        "content": "<p>To be clear, OmegaList is the thought experiment, not omega sequence.</p>",
        "id": 544171341,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760103282
    },
    {
        "content": "<p>Regarding the FunLike implementation that <span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> posted above, the top commit of the following branch:<br>\n<a href=\"https://github.com/ctchou/cslib/tree/omega-sequence-funlike\">https://github.com/ctchou/cslib/tree/omega-sequence-funlike</a><br>\nshows what changes it incurs in OmegaSequence, using the whittled down API I posted yesterday.  The main drawback of the FunLike implementation is that it breaks the naive inductive definition of <code>iterate</code>.  I had to relegate the inductive definition to a helper function <code>iterate'</code> and fix the proof of <code>map_iterate</code>.  But nearly everything else works.  If you know a better way to define <code>iterare</code>, please let me know.</p>\n<p>Is everyone happy with this implementation?  If so, we should settle on it and start using it to define and prove other stuffs.  There is much to be done.</p>",
        "id": 544287432,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1760157572
    },
    {
        "content": "<p>This seems fine to me.</p>",
        "id": 544292621,
        "sender_full_name": "Chris Henson",
        "timestamp": 1760163162
    },
    {
        "content": "<p>Great!  Then please review <a href=\"https://github.com/leanprover/cslib/pull/90\">cslib#90</a>.  In particular, I would appreciate feedbacks on which theorems should be labeled with @[simp] and @[grind] and the theorems about <code>extract</code>, which are new (relative to <code>Stream'</code>).</p>",
        "id": 544293653,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1760164304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/544293653\">said</a>:</p>\n<blockquote>\n<p>Great!  Then please review <a href=\"https://github.com/leanprover/cslib/pull/90\">cslib#90</a>.  In particular, I would appreciate feedbacks on which theorems should be labeled with @[simp] and @[grind] and the theorems about <code>extract</code>, which are new (relative to <code>Stream'</code>).</p>\n</blockquote>\n<p>Review left, with a focus on these aspects.</p>",
        "id": 544303062,
        "sender_full_name": "Chris Henson",
        "timestamp": 1760173824
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span>'s comments have been incorporated.</p>",
        "id": 544360308,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1760230121
    },
    {
        "content": "<p>LGTM now</p>",
        "id": 544819633,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1760469001
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/540977784\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/channel/513188-CSLib/topic/Automata/near/540977456\">said</a>:</p>\n<blockquote>\n<p>No: <code>(X Y Z : Type _)</code> assigns different universes for each variable.</p>\n</blockquote>\n<p>Good to know, thanks!</p>\n</blockquote>\n<p>I found a clue you might be interested in: <a href=\"https://github.com/leanprover-community/mathlib4/pull/6499\">#6499</a></p>\n<p>\"This has nice performance benefits.\"</p>",
        "id": 558903621,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1763912773
    },
    {
        "content": "<p>Exactly what is the difference between <code>Type _</code> and <code>Type*</code>?  Why do they have different performance characteristics?</p>",
        "id": 558924273,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1763933626
    },
    {
        "content": "<p><code>Type _</code> is core Lean, while <code>Type*</code> is syntax provided by Mathlib. My guess at the performance difference is that the former triggers universe unification (I believe that's the correct terminology) it is less performant the Mathlib syntax which explicitly calls <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.mkFreshLevelMVar#doc\">docs#Lean.Meta.mkFreshLevelMVar</a>. Once we have benchmarking set up, I would welcome a PR that follows suit with Mathlib and eliminates <code>Type _</code>.</p>",
        "id": 558924786,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763934196
    },
    {
        "content": "<p>Ignoring performance for the moment, are the following semantically equivalent?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 558925004,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1763934429
    },
    {
        "content": "<p>The following suggests that they are not:<br>\n<a href=\"/user_uploads/3121/8PtVO5QEl_upHbz9VwFOZ_Eq/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/8PtVO5QEl_upHbz9VwFOZ_Eq/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"218x167\" src=\"/user_uploads/thumbnail/3121/8PtVO5QEl_upHbz9VwFOZ_Eq/image.png/840x560.webp\"></a></div>",
        "id": 558925122,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1763934591
    },
    {
        "content": "<p>In your image they just have different level names, but that is the same. The difference is that in the former they are being unified, while in the latter they were explicitly created.</p>",
        "id": 558925380,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763934841
    },
    {
        "content": "<p>Much earlier in the thread I made the mistake of thinking that <code>Type _</code> could accidentally force the same universe levels, which was subsequently corrected. They both assign fresh universes, but the way in which they do so has performance implications. (Anyone please correct me if that is wrong)</p>",
        "id": 558925540,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763935047
    },
    {
        "content": "<p>My impression is that <code>?u.20</code> is a meta-variable while <code>u_1</code> is an object-level variable for type level.  Is that correct?</p>",
        "id": 558925637,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1763935132
    },
    {
        "content": "<p>If you want to be precise, look at <a href=\"https://github.com/leanprover-community/mathlib4/blob/d33ff7cbf94ad8bb5ebc6668f4763603c53f6a53/Mathlib/Tactic/TypeStar.lean#L28-L30\">the definition of Type*</a>. It creates a fresh level mvar and converts it into a paramater, while for <code>Type _</code> it is unassigned and left to unification. I just meant \"same\" in that they are both fresh because I wasn't clear by what you meant by \"semantically\".</p>",
        "id": 558926108,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763935594
    },
    {
        "content": "<p>I'm not sure what I mean \"semantically\", either.  As far as I can understand it, the formal semantics of Lean in Mario Carneiro's thesis doesn't seem to deal with meta-variables and unification.</p>",
        "id": 558926482,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1763936041
    },
    {
        "content": "<p>The main difference is that with <code>Type _</code>, Lean can try to solve and unify level parameters, if it is necessary.  With <code>Type*</code>, you are guaranteed new \"independent\" universe levels.</p>",
        "id": 558968371,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1763970331
    },
    {
        "content": "<p>Here is a simple example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- Type mismatch</span>\n</code></pre></div>",
        "id": 558974305,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1763972129
    },
    {
        "content": "<p>Thanks for the discussion. This is starting to be convincing evidence for me that we should use <code>Type*</code> instead of <code>Type _</code>.</p>",
        "id": 559006265,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1763980894
    },
    {
        "content": "<p>I'm puzzled by <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> 's second example.  Consider the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>How come Lean doesn't complain about the last proof goal?</p>",
        "id": 559122886,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1764009192
    },
    {
        "content": "<p>Your <code>foo</code> and <code>bar</code> are universe polymorphic, so the printing is misleading. It's bringing in a single universe used with equality. I think it is clearer if you give it a name and print everything:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo_bar_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- info: foo_bar_eq.{u_3} : @Eq.{u_3 + 2} ((X : Type u_3) → (x : X) → X) foo.{u_3} bar.{u_3} -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">foo_bar_eq</span>\n</code></pre></div>",
        "id": 559124601,
        "sender_full_name": "Chris Henson",
        "timestamp": 1764009686
    },
    {
        "content": "<p>That's the thing I don't understand: the type-level variable given to <code>X</code> and <code>Y</code> can denote the same level, as exemplified in the theorem <code>far_bar_eq</code>.  So why does Lean reject the expression <code>X = Y</code>?</p>",
        "id": 559125740,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1764010020
    },
    {
        "content": "<p>Let me try explaining another way. In your example, you have a variable <code>X</code> and <code>Y</code> and <em>individually</em> refer to these in your universe polymorphic definitions of <code>foo</code> and <code>bar</code>, so they can be unified. In Damiano's example <code>variable (X Y : Type*)</code> together parameterizes the signature, so they must be separate levels and are not free to unify. </p>\n<p>Maybe more clear if you see the equivalent without using variable:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- fails, X and Y are explicitly assigned different levels</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- each of `foo` and `bar` use a single level param to create a universe polymorphic definition</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"c1\">-- so this is fine, because we're able to set a fixed level `u` and compare `foo.{u}` and `bar.{u}`</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"c1\">-- also works</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- fails</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 559127425,
        "sender_full_name": "Chris Henson",
        "timestamp": 1764010556
    },
    {
        "content": "<p>I'm not sure I'm entirely convinced.  Lean does accept the following example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>So it seems that unification will happen except when <code>X</code> and <code>Y</code> are given (so to speak) \"nakedly\".</p>",
        "id": 559134556,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1764012591
    },
    {
        "content": "<p>This is not unification, this works because for types  <code>X : Type u</code> and <code>Y : Type v</code>, <code>X → Y</code> and <code>Y → X</code> both are in <code>Type (max u v)</code>. Your example here is still universe polymorphic over two levels.</p>",
        "id": 559136793,
        "sender_full_name": "Chris Henson",
        "timestamp": 1764013228
    },
    {
        "content": "<p>Note also <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Every.20Type.20is.20finite.20.3B-.29/with/403999799\">#general &gt; Every Type is finite ;-)</a>: the example there has since been \"fixed\", but the issue was that <code>α</code> was implicitly introduced as <code>α : Sort _</code> and this then unified the universe to make it <code>α : Prop</code> and therefore it was retrieving the <code>Finite.of_subsingleton</code> instance on <code>α</code>.</p>",
        "id": 560023143,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1764021100
    },
    {
        "content": "<p>The code there no longer works (gladly!), but it has worked at some point!  <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 560023182,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1764021119
    },
    {
        "content": "<p>I think I can fully endorse the sentiment expressed by Kevin Buzzard in that thread.  <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 560024877,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1764021716
    },
    {
        "content": "<p>I think that, with some exceptions, you should always use <code>Type*</code>.  If some part of the code does not work and the issue is having used <code>Type*</code>, then try switching to <code>Type _</code>.</p>",
        "id": 560025045,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1764021774
    },
    {
        "content": "<p>Note also that the <code>autoImplicit</code> feature introduces <code>Sort _</code>, and that may create some subtle universe dependencies, even when it does not look like this is the case.</p>",
        "id": 560025552,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1764021962
    },
    {
        "content": "<p>Ok, so roughly <code>Type*</code> means 'a type in its own fresh universe variable' and <code>Type _</code> means 'a type in whatever suitable universe'?</p>",
        "id": 560175319,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764082266
    },
    {
        "content": "<p>FYI, <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Move.20automata.20theory.20in.20mathlib.20to.20CSLib.3F/with/563159088\">#mathlib4 &gt; Move automata theory in mathlib to CSLib?</a></p>",
        "id": 563159406,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1765451615
    }
]