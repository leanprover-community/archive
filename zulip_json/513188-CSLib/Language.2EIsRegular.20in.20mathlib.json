[
    {
        "content": "<p>I just noticed that the notion of regular languages in mathlib, Language.IsRegular, requires that the state type of the automaton to be <code>Type 0</code>, not <code>Type _</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A regular language is a language that is defined by a DFA with finite states. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"bp\">.</span><span class=\"n\">IsRegular</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">accepts</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">L</span>\n</code></pre></div>\n<p>This means that if we are not going to redefine the notion of regular languages in cslib, we will probably have to impose the same requirement on ω-regular languages as well, because the theory of regular languages a necessary part of the theory of ω-regular languages.  Personally I think this is fine, because requiring a finite type to be in <code>Type 0</code> does not seem an excessive requirement.  But I just want to point it out.</p>",
        "id": 547567046,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761677430
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Language.isRegular_iff#doc\">docs#Language.isRegular_iff</a> gives the equivalence to the universe-polymorphic version.</p>",
        "id": 547632373,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1761716424
    },
    {
        "content": "<p>Thanks!  I didn't notice that.  Two questions:</p>\n<ol>\n<li>Why was <code>isRegular_iff</code> not taken as the definition in the first place?</li>\n<li>What is the key idea behind the proof of this theorem?  Is it the existence of an equivalence (<code>≃</code>) between a finite type in any universe and a finite type in <code>Type 0</code>?</li>\n</ol>",
        "id": 547637325,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761719557
    },
    {
        "content": "<p>Alas, I'm getting an inkling of why (1) was not done.  I have a proof of:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">regular_compl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">IsRegular</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">IsRegular</span>\n</code></pre></div>\n<p>If I use the universe-polymorphic version of <code>IsRegular</code>, the proof breaks and I get the error message below which I don't understand at all:</p>\n<blockquote>\n<p>declaration <code>Language.regular_compl</code> contains universe level metavariables at the expression<br>\n  ∃ (State : Type ?u.151), ∃ (dfa : Cslib.DFA.{?u.151, u_1} State Symbol), DFA.language.{?u.151, u_1} dfa = lᶜ<br>\nin the declaration body<br>\n  fun {Symbol} [Finite Symbol] {l} h =&gt;<br>\n    Eq.mpr (id (congrArg (fun _a =&gt; _a) (propext regular_iff_cslib_dfa.{u_1, ?u.151})))<br>\n      (Exists.casesOn (<a href=\"http://Eq.mp\">Eq.mp</a> (congrArg (fun _a =&gt; _a) (propext regular_iff_cslib_dfa.{u_1, ?u.151})) h)<br>\n        fun (State : Type ?u.151)<br>\n          (h : ∃ (dfa : Cslib.DFA.{?u.151, u_1} State Symbol), DFA.language.{?u.151, u_1} dfa = l) =&gt;<br>\n        Exists.casesOn h fun (dfa : Cslib.DFA.{?u.151, u_1} State Symbol) (h : DFA.language.{?u.151, u_1} dfa = l) =&gt;<br>\n          h ▸ Exists.intro State (Exists.intro (DFA.compl.{?u.151, u_1} dfa) (DFA.compl_lang.{?u.151, u_1} dfa)))</p>\n</blockquote>\n<p>I remember that in my personal automata theory project:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory\">https://github.com/ctchou/AutomataTheory</a><br>\nI also got into a lot of trouble with making the type of automata state universe-polymorphic and ended up using <code>Type 0</code>.  I had thought that the trouble was caused by the bundled design of the automata type (where the state type is one of the fields of the automata structure).  But now the automata type in cslib is unbundled and we still get into trouble with universe polymorphism.</p>",
        "id": 547639415,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761720774
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/Language.2EIsRegular.20in.20mathlib/near/547637325\">said</a>:</p>\n<blockquote>\n<p>Thanks!  I didn't notice that.  Two questions:</p>\n<ol>\n<li>Why was <code>isRegular_iff</code> not taken as the definition in the first place?</li>\n<li>What is the key idea behind the proof of this theorem?  Is it the existence of an equivalence (<code>≃</code>) between a finite type in any universe and a finite type in <code>Type 0</code>?</li>\n</ol>\n</blockquote>\n<ol>\n<li>This is so that for every <code>L</code> there is exactly one proposition <code>Language.IsRegular L</code>, not one for each universe level.</li>\n<li>Yes.</li>\n</ol>",
        "id": 547639476,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1761720797
    },
    {
        "content": "<p>Yes, the error message basically means that if you just write <code>l.IsRegular</code>, then Lean has no way of knowing which universe <code>σ</code> is supposed to come from. What you would want from a universe-polymorphic version is <code>∃ u : Level, ∃ σ : Type u, ∃ _ : Fintype σ, ∃ M : DFA T σ, M.accepts = L</code>, but this is not something you can write down in Lean. Instead, for every <code>u</code> you get a <code>IsRegular.{u} L</code>, which is not what you want.</p>",
        "id": 547639781,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1761720953
    },
    {
        "content": "<p>I'm not sure I really understand this.  But my sense is that it is not worthwhile to struggle with universe variables.  I'll stick to using <code>Type</code> for state types.</p>",
        "id": 547641165,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761721578
    },
    {
        "content": "<p>Maybe it's time I raise the issue of whether/when/how we should port all of automata and language theory from mathlib to cslib, since <code>Language.IsRegular</code> uses mathlib's DFA, not cslib's DFA. So it could be a hassle to use.</p>",
        "id": 547795661,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761765600
    },
    {
        "content": "<p>Though <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> has just pointed out to me that he's bridging this quite nicely for now, so I should note this here as well. :-)</p>\n<p><a href=\"https://github.com/ctchou/cslib/blob/regular-language-work/Cslib/Computability/Languages/RegularLanguage.lean\">https://github.com/ctchou/cslib/blob/regular-language-work/Cslib/Computability/Languages/RegularLanguage.lean</a></p>",
        "id": 547795861,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761765680
    },
    {
        "content": "<p>I'll make the above file and associated changes into a PR pretty soon, after I prove the closure of regular languages under boolean operations (which I had thought were in mathlib but don't actually seem to be).  Closure under concatenation and Kleene star will take (quite) more work.</p>",
        "id": 547796462,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761765922
    },
    {
        "content": "<p>This is good to consider, we certainly would like to maintain as much compatibility as possible. Relatedly I've been meaning to ask if the recent activity at <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Regular.20languages.3A.20the.20review.20queue/with/547609781\">#mathlib4 &gt; Regular languages: the review queue</a> is relevant to what's being worked on in CSlib. (I have not read all the PRs there, so I don't know myself)</p>",
        "id": 547796802,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761766048
    },
    {
        "content": "<p>I didn't know about that at all!</p>",
        "id": 547797373,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761766248
    },
    {
        "content": "<p>My general sense is that I'll prove what I need along the way.  If new additions are made to mathlib, I'll use them.</p>",
        "id": 547800424,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761767440
    },
    {
        "content": "<p>Ah, well glad I mentioned it. I would appreciate your keeping an eye on what is happening there since you are probably most familiar with how it will affect us. Proving what you need and periodically checking for relevant Mathlib additions sounds fine to me.</p>",
        "id": 547800734,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761767581
    },
    {
        "content": "<p>Someone should make a website tracking the correspondence between mathlib PR activities and existing mathlib theories.  It would be very nice if a webpage like the following:<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/DFA.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/DFA.html</a><br>\nalso contains pointers to the PRs discussed in the thread that Chris forwarded.  Personally I don't have the bandwidth to browse Zulip sufficiently to keep a tap of what's going on.</p>",
        "id": 548042084,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761863124
    },
    {
        "content": "<p>What's the benefit of Cslib.DFA over <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFA#doc\">docs#DFA</a> ? The latter looks strictly more general to me, and I think the former was explicitly transformed into the latter when PRd to Mathlib</p>",
        "id": 548090189,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1761895035
    },
    {
        "content": "<p>I think there are still some uncertainties about many of the definitions; see the discussion in this thread: <a class=\"stream-topic\" data-stream-id=\"513188\" href=\"/#narrow/channel/513188-CSLib/topic/Question.20Lean.20structure.20and.20extends/with/548041292\">#CSLib &gt; Question Lean structure and extends</a></p>",
        "id": 548095825,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761897557
    },
    {
        "content": "<p>If there is not a good reason for it to be bundled as I advocate in that thread, I don't see why we couldn't use the Mathlib definition. (I understand Cslib.NFA is currently different because it extends LTS)</p>",
        "id": 548097851,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761898376
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/513188-CSLib/topic/Language.2EIsRegular.20in.20mathlib/near/548090189\">said</a>:</p>\n<blockquote>\n<p>What's the benefit of Cslib.DFA over <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFA#doc\">docs#DFA</a> ? The latter looks strictly more general to me, and I think the former was explicitly transformed into the latter when PRd to Mathlib</p>\n</blockquote>\n<p>Mathlib's DFA = Cslib's DA + the theorems in Cslib's DFA.</p>\n<p>(As I agree with Chris that there's no good reason to bundle things, as things currently stand.)</p>",
        "id": 548128770,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761908540
    },
    {
        "content": "<p>Tangentially - on the topic of the actual mathematical meaning of universes here: In the \"standard\" presentation of deterministic automata, we require a finite state space (<code>Fintype σ</code>); relaxing this to allow for infinite state spaces (as a larger class of automata) isn't interesting, because then we can add a state for every possible string over <code>T</code>, and so there is an automaton for every language.</p>\n<p>But, that really only works when <code>T</code> and <code>σ</code> are the same universe. The proposition</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"bp\">.</span><span class=\"n\">IsRegular'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">accepts</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">L</span>\n</code></pre></div>\n<p>is equivalent to <code>True</code> when <code>u</code> is universe 0, but it becomes something nontrivial when <code>u</code> is a higher universe. Of course this is a version of the more general idea that you get something nontrivial as long as the alphabet is an infinite set with <em>larger cardinality</em> than your state space; e.g. you can talk about an automaton that accepts languages written over the alphabet of real numbers, but with only a countable state space.</p>",
        "id": 548157232,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1761917358
    },
    {
        "content": "<p>There is an earlier thread arguing for an LTS definition and making NFA and DFA depend on it because LTSes are far more general structures</p>",
        "id": 548165505,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1761919630
    }
]