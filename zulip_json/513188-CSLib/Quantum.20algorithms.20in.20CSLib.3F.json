[
    {
        "content": "<p>Hi, everyone! I'm a professor at the University of Amsterdam working on quantum computing and quantum information. I am interested in formalizing some key quantum algorithms that are important in my research in Lean. Perhaps this can be done as part of CSLib by creating a quantum extension of Boole? I wonder if there are other people with background in quantum computing who might be interested in this endeavor?</p>\n<p>My research interests are on using representation-theoretic techniques in quantum computing (more specifically, I'm interested in various generalizations of the Fourier transform). As a long-term goal, I would like to implement the quantum circuits and formalize their correctness for <strong>Fourier transform for symmetric group</strong> and <strong>Schur transform</strong>. Here is a brief summary of the current state of the art on these two.</p>\n<p><strong>Fourier transform for symmetric group</strong></p>\n<p>The original 1997 paper by <a href=\"https://doi.org/10.1145/258533.258548\">Beals</a> describes the ideas on a high level and doesn't contain any quantum circuits or pseudo code. A much more precise description of the algorithm was spelled out by <a href=\"https://doi.org/10.1016/j.jsc.2015.11.016\">Kawano and Sekigawa</a> in 2016. However, my master's student recently found that their description of the algorithm and its analysis is incomplete. He is defending his thesis on Friday and we hope to turn it into a paper afterwards. I hope that it can be used as a basis for a blueprint for formalization.</p>\n<p><strong>Schur transform</strong></p>\n<p>Schur transform is a key subroutine in many quantum information tasks which implements the basis change appearing in the so-called <a href=\"https://en.wikipedia.org/wiki/Schur%E2%80%93Weyl_duality\">Schur–Weyl duality</a> which relates the representation theory of symmetric and unitary groups. A quantum algorithm for it was first described in <a href=\"http://arXiv.org/abs/quant-ph/0407082\">these</a> <a href=\"http://arXiv.org/abs/quant-ph/0601001\">two</a> papers by Bacon, Chuang and Harrow (I recommend the 2nd half of <a href=\"https://arxiv.org/abs/quant-ph/0512255\">Harrow's</a> PhD thesis from 2005 as a particularly good source). Unfortunately they don't give explicit quantum circuits. First explicit circuits (albeit with sub-optimal complexity) were provided by <a href=\"https://arxiv.org/abs/1709.07119\">Kirby and Strauch</a> in the special case of qubits.</p>\n<p>An alternative approach to Schur transform was devised by <a href=\"https://arxiv.org/abs/1804.00055\">Krovi</a> in 2018 which makes use of the symmetric group Fourier transform. However, recently a mistake in the last step of his algorithm was discovered, so we posted a <a href=\"https://arxiv.org/abs/2509.22640\">paper</a> last month that corrects this error and provides a much more detailed analysis and description of the algorithm.</p>\n<p>Together with a new PhD student who will start with me in January, we will be looking at implementing these two quantum algorithms and formally proving their correctness. If anyone else is interested in this subject, especially someone with more expertise in Lean, please let me know.</p>",
        "id": 544749468,
        "sender_full_name": "Maris Ozols",
        "timestamp": 1760448535
    },
    {
        "content": "<p>There is a QuantumInfo repository which might be better suited for this</p>",
        "id": 544749750,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760448600
    },
    {
        "content": "<p>They also have a channel <a href=\"#narrow/channel/508986-Quantum-information\">https://leanprover.zulipchat.com/#narrow/channel/508986-Quantum-information</a></p>",
        "id": 544750036,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760448667
    },
    {
        "content": "<p>Thanks, I'm aware of it! I just wanted to stop by here and say \"hi\" because I wasn't aware of CSLib until I run into <span class=\"user-mention\" data-user-id=\"644040\">@George Tsoukalas</span> last week. He got me in touch with <span class=\"user-mention\" data-user-id=\"934205\">@Swarat Chaudhuri</span> who suggested I drop by here.</p>",
        "id": 544788456,
        "sender_full_name": "Maris Ozols",
        "timestamp": 1760457731
    },
    {
        "content": "<p>Here are some additional thoughts. While I have not seen the specification of the Boole language yet, my hope is that it can be extended with the following extra \"quantum\" functionality:</p>\n<ul>\n<li>A special variable <code>nq</code> that tells the current number of qubits.</li>\n<li>An operation <code>ancilla k</code> that adds <code>k</code> ancilla qubits initialized in state <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mn>0</mn><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">|0\\rangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣0</span><span class=\"mclose\">⟩</span></span></span></span>. It would increase <code>nq</code> by <code>k</code> and replaces the current <code>nq</code>-qubit state <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">Ψ</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">|\\Psi\\rangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣Ψ</span><span class=\"mclose\">⟩</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">Ψ</mi><mo stretchy=\"false\">⟩</mo><mo>⊗</mo><mi mathvariant=\"normal\">∣</mi><mn>0</mn><msup><mo stretchy=\"false\">⟩</mo><mrow><mo>⊗</mo><mi>k</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">|\\Psi\\rangle \\otimes |0\\rangle^{\\otimes k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣Ψ</span><span class=\"mclose\">⟩</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0991em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣0</span><span class=\"mclose\"><span class=\"mclose\">⟩</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span></span>.</li>\n<li>An operation <code>gate i U</code> that applies unitary <code>U</code> on qubit <code>i</code>, where <code>U</code> comes from some predefined gate set. If <code>U</code> is a 2-qubit gate, it would be applied on qubits <code>i</code> and <code>i+1</code>.</li>\n</ul>\n<p>I think this would be enough for the two algorithms I want to implement since they are fully coherent (they describe isometries with quantum input and quantum output, so they do not involve measurements).</p>\n<p>For more general quantum algorithms you would also want something like this.</p>\n<ul>\n<li>An operation <code>measure i</code> that measures the <code>i</code>-th qubit in the standard basis and returns the boolean measurement outcome.</li>\n<li>An operation <code>discard i</code> that discards the <code>i</code>-th qubit. It effectively measures the qubit and forgets the measurement outcome. Since the post-measurement state is in product with the rest, the measured qubit can be removed.</li>\n</ul>\n<p>An extra complication that these operations create is that one needs to deal with mixed states, which can be described either by density matrices or by explicit probabilistic mixtures of pure states. For the purposes of what I want to do, I think this won't be needed.</p>",
        "id": 544899093,
        "sender_full_name": "Maris Ozols",
        "timestamp": 1760514865
    },
    {
        "content": "<p>I am not sure it will be that simple. There will have to be a way to enforce no cloning and loss of a qubit state after it is measured</p>",
        "id": 544936674,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760525775
    },
    {
        "content": "<p>Measurements in the quantum sense are irreversible whereas in the classical setting. one can always read a memory location as many time as one wants to. Encoding this will require some linear resource usage system which might be a non trivial addition</p>",
        "id": 544937080,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760525903
    },
    {
        "content": "<p>No cloning follows from linearity, so enforcing linearity of gates should be enough.</p>",
        "id": 544937372,
        "sender_full_name": "Maris Ozols",
        "timestamp": 1760525998
    },
    {
        "content": "<p>I only have a rough idea how formal program verification works classically, so I'm likely naive about this. However, at least for the project I have in mind, measurements are not needed, so I hope that this will keep things much simpler than in the general case.</p>",
        "id": 544938280,
        "sender_full_name": "Maris Ozols",
        "timestamp": 1760526194
    },
    {
        "content": "<p>I think Maris's idea makes sense, as long as your building it up from unitary gates and ancillae these properties (linearity, no cloning) will come along for free, philosophically these shouldn't have to be \"extra\" constraints to impose at any point</p>",
        "id": 544945135,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1760528448
    },
    {
        "content": "<p>I think a monad for unitary (or more generally, CPTP) operations might be the best way to do this then, esp. since it lets us build on lots of the convenient monadic work already in Lean.</p>",
        "id": 544945402,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1760528539
    },
    {
        "content": "<p>You can imagine a <code>UnitaryM</code> which you work with by building up these gate sets. It would track the total unitary you apply, and probably also the number of gates applied. (Other nice things you could track in the monad: gate depth (by tracking depth on each qubit; fidelity (when you're building a unitary A that you want to closely approximate another unitary B and to keep track of the running error.)</p>\n<p>Then you can divide your circuit construction into separate operations on the monad, and talk about pre- and post-conditions for each and so on.</p>",
        "id": 544946274,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1760528798
    },
    {
        "content": "<p>Gates are unitary and  reversible. Qubits are linear w.r.t. measurement</p>",
        "id": 544971517,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760535565
    },
    {
        "content": "<p>Adding linearity is not a trivial thing afaik.</p>",
        "id": 544971739,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760535628
    },
    {
        "content": "<p>the program logic you need to express this might be some linear separation logic on top of MoSel or something similar.</p>",
        "id": 544972057,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760535712
    },
    {
        "content": "<p>For example : <a href=\"https://arxiv.org/abs/2102.00329\">https://arxiv.org/abs/2102.00329</a> </p>\n<p>This is of course just the program logic. To make it work with good automation, we might want to build it on top of a framework like Loom.</p>",
        "id": 544972216,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760535748
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"735840\">@Maris Ozols</span>, sorry this took me a bit to get to! To echo what others have said I am not exactly sure of the right place for your formalization, but I am sure it will be welcome somewhere. I am not one of the maintainers who is an expert in Boole, but my understanding is that it works by defining a <a href=\"https://github.com/strata-org/Strata\">Strata</a> dialect that is used to generate the language. If such a thing is amenable to the formalization work you want to do, I would be happy to review, as I have <em>some</em> experience with quantum in Rocq (mostly via trying out Robert Rand's work). Even if you prefer to do a more bespoke embedding, I think this could be considered or there is the QuantumInfo repo as well.</p>\n<p>As a side note, a few years ago I read your essay on the Solovay-Kitaev theorem and found it very useful! I did not know you were involved in formalization. I would love to help formalize it at some point if that hasn't been done already.</p>",
        "id": 545137180,
        "sender_full_name": "Chris Henson",
        "timestamp": 1760567331
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"735840\">@Maris Ozols</span> Have you looked at formalizations in Rocq and Isabelle?<br>\nE.g. (non-exhaustive!)<br>\n<a href=\"https://arxiv.org/abs/1912.02250\">https://arxiv.org/abs/1912.02250</a><br>\n<a href=\"https://dl.acm.org/doi/10.1145/3571222\">https://dl.acm.org/doi/10.1145/3571222</a><br>\nand the work on the Qwhile language for post-quantum cryptography:<br>\n<a href=\"https://dominique-unruh.github.io/qrhl-tool/install.html\">https://dominique-unruh.github.io/qrhl-tool/install.html</a><br>\n<a href=\"https://www.isa-afp.org/search/?s=unruh\">https://www.isa-afp.org/search/?s=unruh</a><br>\n<a href=\"https://inria.hal.science/hal-03529301v1/document\">https://inria.hal.science/hal-03529301v1/document</a> (EasyPQC)</p>",
        "id": 545358651,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1760626597
    }
]