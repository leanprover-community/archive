[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> thanks for all the work into those PRs. I have plenty of comments, but to optimise everybody's time I'd like to understand better how TimeM, <a href=\"https://github.com/leanprover/cslib/pull/372\">cslib#372</a>, and <a href=\"https://github.com/leanprover/cslib/pull/376\">cslib#376</a> compare. Let's focus on key points.</p>\n<p>In a nutshell, <a href=\"https://github.com/leanprover/cslib/pull/372\">cslib#372</a> gives us signatures like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">insertionSort</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Prog</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SortOpsInsertHead</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which fights cheating through interpretation (<code>FreeM</code>/<code>Prog</code>).</p>\n<p>By contrast, <a href=\"https://github.com/leanprover/cslib/pull/376\">cslib#376</a> gives us:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">insertionSort</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cmp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which fights cheating through parametric polymorphism.</p>\n<p>I have two questions:</p>\n<ol>\n<li>After squinting my eyes for a while, I could imagine ways to do almost anything interesting in both approach (reusing the same algorithm with different cost models, doing parametric complexity, proving lower bounds, etc.). Is that actually true?</li>\n<li>Real bliss in this case would be using a typeclass instead of an explicit parameter for the operations, for example:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">insertionSort</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Can that be done?</p>",
        "id": 576417703,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1772279726
    },
    {
        "content": "<p>Please note <a href=\"https://github.com/leanprover/cslib/pull/275\">cslib#275</a> is closed in favor of <a href=\"https://github.com/leanprover/cslib/pull/372\">cslib#372</a>. They are the same with squashed commit history that made it easier to review.</p>",
        "id": 576417915,
        "sender_full_name": "Chris Henson",
        "timestamp": 1772279875
    },
    {
        "content": "<p>That's the one I meant, thanks for spotting it. Edited.</p>",
        "id": 576418006,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1772279931
    },
    {
        "content": "<p>the point with <a href=\"https://github.com/leanprover/cslib/pull/372\">cslib#372</a> is beyond just getting rid of cheating. In terms of “cheat”ability both PRs are close (and substantially better than TimeM) but as <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> pointed out, passing explicit comparison functions can cause problems.  I will let him address that issue</p>",
        "id": 576418488,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772280243
    },
    {
        "content": "<p>The point of my Prog approach is to go far beyond what TimeM and TickM can</p>",
        "id": 576418543,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772280278
    },
    {
        "content": "<p>To allow explicit reasoning about model and reductions between them</p>",
        "id": 576418851,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772280483
    },
    {
        "content": "<p>And about lower bounds in some cases</p>",
        "id": 576418877,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772280502
    },
    {
        "content": "<p>As I showed in an earlier thread we can also handle circuits (which means we can handle parallel algorithms)</p>",
        "id": 576418911,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772280528
    },
    {
        "content": "<p>To be clear, what you're claiming is that all of that cannot be done in <a href=\"https://github.com/leanprover/cslib/pull/376\">cslib#376</a>?</p>",
        "id": 576418965,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1772280578
    },
    {
        "content": "<p>Yes</p>",
        "id": 576418972,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772280585
    },
    {
        "content": "<p>And there’s more</p>",
        "id": 576418990,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772280607
    },
    {
        "content": "<p>With an explicit query model  approach we can </p>\n<ol>\n<li>Have multiple cost models for the same query (you see examples in one of my test files)</li>\n<li>You can pursue a top down and modular approach to algorithms formalization.</li>\n</ol>",
        "id": 576419051,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772280666
    },
    {
        "content": "<p>To elaborate on 2. What I mean is that we follow algorithms papers and encode their opaque subroutines from Literature as queries. Then we reduce those custom queries to more basic queries, all the way down to standard models</p>",
        "id": 576419098,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772280717
    },
    {
        "content": "<p>So we have clear reduction theorems</p>",
        "id": 576419115,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772280728
    },
    {
        "content": "<p>I can also use this framework to make working with explicit TMs quite a bit simpler</p>",
        "id": 576419145,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772280764
    },
    {
        "content": "<p>And since both circuits and TMs can fit into the same web of reductions, we have a chance to finally tackle uniform circuits</p>",
        "id": 576419197,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772280812
    },
    {
        "content": "<h3>slightly different issue</h3>\n<p>The generalisations of <a href=\"https://github.com/leanprover-community/CSLib/pull/376\">CSLib#376</a> could (and ideally should) be built on top of <a href=\"https://github.com/leanprover/cslib/pull/372\">cslib#372</a> by converting Prog from a free monad to a free monad transformer.</p>",
        "id": 576419282,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772280899
    },
    {
        "content": "<p>For algorithms theory I’d not use this hypothetical ProgT with any monad other than Id because adding extra monads has unexplored questions of soundness w.r.t complexity models.</p>",
        "id": 576419337,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772280957
    },
    {
        "content": "<p>And to also be clear. None of the models above completely disallow “cheating”. They just reduce it to a point where a reviewer can easily spot it. As soon as you have a query (on in the case of <a href=\"https://github.com/leanprover/cslib/pull/376\">cslib#376</a> ‘s case a function)  that performs what I  call a “write-operation”  it can be substituted by a pure operation. </p>\n<p>This is an inherent limitation of any monadic lightweight approach which will require human review to avoid. Both these approaches simplify this review process over TimeM. But with <a href=\"https://github.com/leanprover-community/CSLib/pull/372\">CSLib#372</a> as Eric can explain, this is simpler because of the upfront statement of queries and costs.</p>",
        "id": 576419589,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772281225
    },
    {
        "content": "<p>And I claim that we actually want this explicit commitment for all the reasons above. In general if one cannot commit to a cost model and operations to count in advance, it is much more dangerous to do this inside an algorithm.</p>",
        "id": 576419686,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772281325
    },
    {
        "content": "<p>An interesting aspect of 376 is its usage of <code>mvcgen</code>. It would be nice to make use of this, so I'd like to understand if its possible and/or what this would look like with the free monad approach.</p>",
        "id": 576419697,
        "sender_full_name": "Chris Henson",
        "timestamp": 1772281333
    },
    {
        "content": "<p>Yes</p>",
        "id": 576419711,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772281350
    },
    {
        "content": "<p>I haven’t done this because my pr is big enough as it is</p>",
        "id": 576419720,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772281368
    },
    {
        "content": "<p>But I think the basic approach of <a href=\"https://github.com/leanprover/cslib/pull/376\">cslib#376</a> can be ported to <a href=\"https://github.com/leanprover/cslib/pull/372\">cslib#372</a> (in a future PR)</p>",
        "id": 576419754,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772281413
    },
    {
        "content": "<p>After all we are just evaluating in the Id monad</p>",
        "id": 576419776,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772281431
    },
    {
        "content": "<p>And Fabrizio : I think the extra annotation’s flexibility is important.</p>",
        "id": 576419920,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772281558
    },
    {
        "content": "<p>Today you might have an opaque query for computation  Z with one cost model. Tomorrow there might be a better algorithm for Z with better time complexity. You might just want to give your existing query a new cost model for Z.</p>",
        "id": 576420032,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772281663
    },
    {
        "content": "<p>(note that I have some thoughts here but am away on vacation for the next week and a bit so may not find time to collect them)</p>",
        "id": 576420131,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772281754
    },
    {
        "content": "<p>There might be two ways of building <a href=\"https://github.com/leanprover/cslib/pull/376\">cslib#376</a> on top of <a href=\"https://github.com/leanprover/cslib/pull/372\">cslib#372</a>. </p>\n<ol>\n<li>Eric suggested compiling these parametric monad programs to Prog for complexity. </li>\n<li>I thought we could generalise Prog.eval to Prog.liftM which would lift programs to arbitrary monads while we handle complexity through Prog.time. That way we can also probably reuse the mvcgen stuff </li>\n</ol>\n<p>Maybe this message goes to a different thread.</p>",
        "id": 576420944,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772282522
    }
]