[
    {
        "content": "<p>Hello! I am trying to create some syntax for definitions related to transduction operations, but I don't often work with <code>notation</code> and I'm not sure how best to capture these.</p>\n<p>The prefix function <code>pref</code> of <code>f</code> is usually written</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>f</mi><mi>p</mi></msup></mrow><annotation encoding=\"application/x-tex\">f^p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9088em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>I have the following, which works when applying <code>fᵖ</code> to an argument as in <code>fᵖ xs</code>, but doesn't allow me to write just <code>fᵖ</code>. For a reason I do not know, Lean does not parse things correctly when I define this notation without <code>xs</code>: then it makes an error whenever I write <code>fᵖ xs</code>. Is there a way to get <code>fᵖ</code> to just work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"s2\">\"ᵖ \"</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pref</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n</code></pre></div>\n<p>The tail function <code>tail</code> of <code>f</code> with respect to a string <code>xs</code> is usually written</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mi>f</mi><mrow><mi>x</mi><mi>s</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">f_{xs}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"mord mathnormal mtight\">s</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>I have the following. I would prefer to be able to write something as simple as <code>fᵗ xs ys</code> (<code>fᵗ</code> being the only custom notation), but this breaks for the same reason as before. Instead, I have to use some clunky structure with all three aguments.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"s2\">\"-\"</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"s2\">\"ᵗ \"</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n</code></pre></div>\n<p>Also, is there a standard for when to turn custom notation into a notation typeclass? Should I scaffold these around typeclasses?</p>",
        "id": 570943890,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769749619
    },
    {
        "content": "<p>Note that not every character has superscript and/or subscript versions in unicode.  What is wrong with writing (say) <code>f.pref xs</code> and <code>f.tail xs</code>?</p>",
        "id": 570946109,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769751227
    },
    {
        "content": "<p>Aha, somehow I forgot the suffix version was an option :)</p>",
        "id": 570946876,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769751827
    },
    {
        "content": "<p>There are two other things that I think should have a custom notation. One is tail congruence because it is a relation:</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>u</mi><msub><mo>∼</mo><mi>f</mi></msub><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">u \\sim_f v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7167em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">∼</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span></span></p>\n<p>Which I currently have written as <code>u ~fᵗ v</code> because there must be something between the <code>f</code> and the <code>v</code>.</p>\n<p>The other is right-concatenation to the quotient of strings by tail congruence (which well-defined because tail congruence is a right congruence as usual). It should probably have a notation because it is just <code>append</code>, which has a notation, lifted. I currently have that as <code>u ++' v</code>, which I do not really like.</p>",
        "id": 570947415,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769752172
    },
    {
        "content": "<p>I feel like there are nicer notations that will work in Lean.</p>",
        "id": 570947516,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769752240
    },
    {
        "content": "<p>The lifted append should probably be defined more generally anyways after the outstanding PR defining right congruences is merged.</p>",
        "id": 570947871,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769752485
    },
    {
        "content": "<p>Perhaps you want to take a look at the notion of right congruence in <a href=\"https://github.com/leanprover/cslib/pull/278\">cslib#278</a>.  I did not define any special notation, though the usual notation for equivalence, <code>≃</code>, should be in effect.</p>",
        "id": 570960351,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769759307
    },
    {
        "content": "<p>Yes! This is the one I have seen this one before. Your <code>RightCongr.toDA</code> is exactly the first part of a <code>Transduction.toTransducer</code> I wrote, and I'd prefer to reuse it :).</p>\n<p>I noticed that you do the <code>append</code> lifting in the <code>toDA</code> definition. Maybe this should be defined separately too, since it will be a very common operation?</p>\n<p>I also worry that the default equivalence notation won't be sufficient, because it does not allow me to specify the function whose tail I'm even refering to. Did you ever have a similar issue? Surely you worked with a syntactic congruence that depended on some <code>Language</code> you had to refer to.</p>",
        "id": 571095023,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769796712
    },
    {
        "content": "<p>Maybe there should be a notation typeclass that introduces a ternary relation for cases like this</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>u</mi><msub><mo>∼</mo><mi>f</mi></msub><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">u \\sim_f v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7167em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">∼</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span></span></p>\n<p>Something like this is used for tail congruences of a transduction, syntactic congruences of a language,  transition congruences of automata...</p>",
        "id": 571095986,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769797083
    },
    {
        "content": "<p>I'm not sure I understand completely what you want.  Could you write down in informal but precise math what definitions you wish to make?  In particular, I don't understand the role of the function <code>f</code> in what you wrote above.</p>",
        "id": 571098782,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769798038
    },
    {
        "content": "<p>Sure! I'll start with languages. One usually denotes that two strings <code>u</code> and <code>v</code> are syntactically congruent with respect to <code>L</code> by</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>u</mi><msub><mo>≈</mo><mi>L</mi></msub><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">u \\approx_L v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6331em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">≈</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">L</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span></span></p>\n<p>The definition is via</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>u</mi><msub><mo>≈</mo><mi>L</mi></msub><mi>v</mi><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>w</mi><mo separator=\"true\">,</mo><mi>u</mi><mi>w</mi><mo>∈</mo><mi>L</mi><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi>v</mi><mi>w</mi><mo>∈</mo><mi>L</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u \\approx_L v \\iff (\\forall w, uw \\in L \\iff vw \\in L)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6331em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">≈</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">L</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.549em;vertical-align:-0.024em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟺</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7073em;vertical-align:-0.024em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟺</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>Of course, Myhill-Nerode tells us that a language is regular iff this congruence has finite index. You have probably already worked with this formalization.</p>\n<p>For transductions, we have a similar syntactic congruence called <em>tail congruence</em>. One usually denotes that two strings <code>u</code> and <code>v</code> are tail congruent with respect to a transduction <code>f</code> by</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>u</mi><msub><mo>∼</mo><mi>f</mi></msub><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">u \\sim_f v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7167em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">∼</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span></span></p>\n<p>Strings are tail congruent if and only if the tail functions of <code>f</code> with respect to both of them are equal. A result called by various names (sometimes Choffrut's Theorem) tells us that a transduction is subsequential if and only if its tail congruence has finite index.</p>",
        "id": 571100393,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769798618
    },
    {
        "content": "<p>Because both use similar notation, we may want some kind of <code>u ~L v</code> notation typeclass where <code>u</code> and <code>v</code> and <code>L</code> are terms.</p>",
        "id": 571100629,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769798697
    },
    {
        "content": "<p>As for the lifted <code>append</code>: if <code>~</code> is a right congruence and we have a string <code>w</code> and an equivalence class:</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>u</mi><msub><mo stretchy=\"false\">]</mo><mo>∼</mo></msub></mrow><annotation encoding=\"application/x-tex\">[u]_\\sim</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">u</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1068em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mrel mtight\">∼</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>Then there is a unique equivalence class reached by right-concatenating <code>w</code> (by the defining property of a right congruence), and we can refer to it as</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>u</mi><mi>w</mi><msub><mo stretchy=\"false\">]</mo><mo>∼</mo></msub></mrow><annotation encoding=\"application/x-tex\">[uw]_\\sim</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1068em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mrel mtight\">∼</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>In Lean, we get this by lifting <code>List.append</code>. This is what you did in <code>RightCongr.toDA</code>. Since it works for right congruences in general and is a common operation, it should probably be defined in general.</p>",
        "id": 571102001,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769799173
    },
    {
        "content": "<p>So does generalizing to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">RightCongruence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span>\n<span class=\"w\">  </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">right_cov</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CovariantClass</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">eq</span>\n</code></pre></div>\n<p>match what you want then?</p>",
        "id": 571104044,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769799856
    },
    {
        "content": "<p>The notion of <code>RightCongruence</code> in <a href=\"https://github.com/leanprover/cslib/pull/278\">cslib#278</a> is simply an equivalence relation (modeled as a <code>Setoid</code>) plus the requirement that if <code>u</code> and <code>v</code> are equivalent, then <code>u ++ w</code> and <code>v ++ w</code> are also equivalent for any <code>w</code>.  The equivalence relation can come from a language or from a transduction or from something else.  I agree with <span class=\"user-mention\" data-user-id=\"878804\">@Liam Schilling</span>  that the one-step right-concatenation of the \"equivalence classes\" used in <code>DA/Congr.lean</code> can indeed be generalized to strings in general.  You are welcomed to make such definitions and <code>DA/Congr.lean</code> can be refactored to use those definitions.</p>",
        "id": 571104652,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769800015
    },
    {
        "content": "<p>Yes, this is the <code>RightCongruence</code> in the PR <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> linked to. I believe that <code>Quotient.lift (fun xs =&gt; [xs ++ ys]) (...) fx</code> should have its own definition. Here, <code>fx</code> is a right congruence class and <code>ys</code> is a string (<code>List</code>).</p>",
        "id": 571104949,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769800085
    },
    {
        "content": "<p>What I wrote above is different from the definition that appears in the PR. It generalizes from <code>List.append</code> to an arbitrary relation.</p>",
        "id": 571105230,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769800174
    },
    {
        "content": "<p>Aha, sorry I should have checked my comparison. The generalization is probably okay <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span>, but it's not important for what I'm working on in particular. Either way, the lifted operation can still be defined.</p>",
        "id": 571105698,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769800335
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span>'s definition is perhaps too general.  It seems unlikely that you can prove anything about list concatenation with such a definition.</p>",
        "id": 571105837,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769800384
    },
    {
        "content": "<p>In other words, the function <code>f</code> in Chris's definition should have something to do with lists.  Also note that left and right congruences have different list properties.</p>",
        "id": 571106158,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769800492
    },
    {
        "content": "<p>(I think) It is true that this definition is not specific to right congruences. (I think) It could equally well be used to define a left congruence by flipping the argument order in <code>f</code></p>",
        "id": 571106476,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769800597
    },
    {
        "content": "<p>It should be able to define a right congruence just fine though, by passing <code>List.append</code> as <code>f</code>. The only downside I can see is that the proof of right covariance will be a little worse. Ideally, we would only have to prove that the one-character right concatenation preserves the relation. In this case, we would have to prove it for any right concatenation.</p>",
        "id": 571106841,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769800721
    },
    {
        "content": "<p>I believe that either:</p>\n<p><code>f</code> should be generalized to <code>a -&gt; b -&gt; a</code> so that we can pass <code>List.cons</code> and then only have to prove the one-character right concatenation.</p>\n<p>We should just define it for strings as <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> said.</p>",
        "id": 571107150,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769800830
    },
    {
        "content": "<p>Actually if <code>f</code> is <code>List.append</code>, you get left, not right, congruence.  Read carefully how <code>CovariantClass</code> is defined.</p>",
        "id": 571107210,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769800851
    },
    {
        "content": "<p>Yes, this is why you get either depending on argument order</p>",
        "id": 571107265,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769800872
    },
    {
        "content": "<p>In my opinion, the definition doesn't add much to the table compared to just <code>CovarianceClass</code>.</p>",
        "id": 571107496,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769800947
    },
    {
        "content": "<p>The reason having a <code>RightCongr</code> class is useful is that it allows us to prove that one-character right concatenation preserves the relation in the cases we implement, and automatically get that any right concatenation preserves the relation. In this sense, I agree with <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> that this string-specific purpose is better captured by a string-soecific definition.</p>",
        "id": 571108054,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769801132
    },
    {
        "content": "<p>There is something else I worry about: Giving this <code>class</code> status instead of just <code>structure</code>. At least for my application, there is no <em>canonical</em> right congruence over strings. I will always have to specify which transduction <code>f</code>'s tail congruence im referring to.</p>",
        "id": 571108769,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769801396
    },
    {
        "content": "<p>The same should hold for syntactic congruences <em>with respect to</em> a language <code>L</code></p>",
        "id": 571108894,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769801441
    },
    {
        "content": "<p>Using <code>List.cons</code> for <code>f</code> does not type-check.  Again, read carefully how <code>Covariant</code> is defined.</p>\n<p>As to your remark about <code>class</code> vs <code>structure</code>, there is no canonical congruence in my application, either.</p>",
        "id": 571109844,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769801758
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> what about this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">RightCongruence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span>\n<span class=\"w\">  </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">right_cov</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CovariantClass</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">eq</span>\n</code></pre></div>",
        "id": 571110541,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769801990
    },
    {
        "content": "<p>This is what I meant by generalize<code>f</code> to <code>a -&gt; b -&gt; a</code>, then use <code>List.cons</code>.</p>",
        "id": 571110701,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769802040
    },
    {
        "content": "<p>I got the <code>a</code> and <code>b</code> swapped :)</p>",
        "id": 571110744,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769802055
    },
    {
        "content": "<p>This makes sense to me. Again, I don't know this area, but if this captures part of what you're looking for we can easily use it in both places.</p>",
        "id": 571112275,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769802596
    },
    {
        "content": "<p>And to be clear <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> if we decide to do this later, you can still write an abbrev for <code>RightCongruence (List α) (List α) (fun x y =&gt; y ++ x)</code> if you'd like so that it's not any worse ergonomics where you've used it already</p>",
        "id": 571113302,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769802969
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> maybe for our application, it's better to have <code>RightCongruence</code> treated more like Lean's <code>Equivalence</code>.</p>",
        "id": 571113325,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769802981
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RightCongruence</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Equivalence</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">right_cov</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Covariant</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">r</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">RightCongruence</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toSetoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RightCongruence</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"bp\">.</span><span class=\"n\">toEquivalence</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RightCongruence</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"bp\">.</span><span class=\"n\">toSetoid</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"bp\">.</span><span class=\"n\">toSetoid</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">liftOn</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟦</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"bp\">⟧</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"s2\">\"+++\"</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">RightCongruence</span>\n</code></pre></div>",
        "id": 571113346,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769802989
    },
    {
        "content": "<p>That is, instead of making it a <code>class</code> and embedding the <code>Setoid</code> class into it, make it a <code>structure</code> and embed the <code>Equivalence</code> structure into it. Then, we can easily get the setoid we want out as in <code>toSetoid</code>.</p>",
        "id": 571113561,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769803073
    },
    {
        "content": "<p>Uh oh, I just realized I defined a left-congruence by accicent.</p>",
        "id": 571114346,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769803392
    },
    {
        "content": "<p>FIX: replace <code>List.cons</code> with <code>(fun x xs =&gt; xs ++ [x])</code>.</p>",
        "id": 571114481,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769803449
    },
    {
        "content": "<p>My inclination is to prefer the class, but we can revisit this. I would ask that you try this first so that it's easier to integrate into what's already done in <a href=\"https://github.com/leanprover/cslib/pull/278\">cslib#278</a>.</p>",
        "id": 571114534,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769803468
    },
    {
        "content": "<p>Where is the \"right\" in the <code>RightCongruence</code> definition you gave above?  How do you define a left congruence?  How about an equivalence relation that is both a left and a right congruences?</p>",
        "id": 571114621,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769803500
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RightCongruence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Equivalence</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">right_cov</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Covariant</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"n\">r</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">LeftCongruence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Equivalence</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">left_cov</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Covariant</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">r</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">LeftRightCongruence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span>\n<span class=\"w\">    </span><span class=\"n\">RightCongruence</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">LeftCongruence</span><span class=\"w\"> </span><span class=\"n\">r</span>\n</code></pre></div>",
        "id": 571114991,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769803654
    },
    {
        "content": "<p>No, this is moving in the wrong direction I think. Once you abstract over the function, it depends on what you pass as <code>f</code> that determines if it is left/right. You can still have the case of having both as an extension.</p>",
        "id": 571115372,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769803809
    },
    {
        "content": "<p>Okay, I am trying to write a version that captures both the general version and this specific case <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 571115493,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769803854
    },
    {
        "content": "<p>There are a couple of ways I suppose. You could actually define the both left and right the same, or involve <code>flip</code>/<code>Function.swap</code>. It depends on how exactly you want to enforce the functions being related to each other.</p>",
        "id": 571116148,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769804086
    },
    {
        "content": "<p>I think if you are going to do the quotient construction, you may as well include <code>Setoid</code> in the definition.  I would hate to have to write <code>toSetoid</code> all the time.  Also, I don't see the advantage of using <code>List.cons</code> and <code>fun x xs =&gt; xs ++ [x]</code>rather than list append.  In principle, one could define left and right congruence for any binary operation.  In fact, I think that is a probably better direction for generalization.</p>",
        "id": 571117168,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769804510
    },
    {
        "content": "<p>The lifted <code>append</code> of left and right congruences are just a special case of a lifted <code>foldl</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Congruence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Equivalence</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">cov</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Covariant</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">r</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RightCongruence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span>\n<span class=\"w\">    </span><span class=\"n\">Congruence</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">])</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">LeftCongruence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span>\n<span class=\"w\">    </span><span class=\"n\">Congruence</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Congruence</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toSetoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Congruence</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"bp\">.</span><span class=\"n\">toEquivalence</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Congruence</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"bp\">.</span><span class=\"n\">toSetoid</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"bp\">.</span><span class=\"n\">toSetoid</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">liftOn</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟦</span><span class=\"n\">ys</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">⟧</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Congruence</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">RightCongruence</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RightCongruence</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"bp\">.</span><span class=\"n\">toSetoid</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"bp\">.</span><span class=\"n\">toSetoid</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">congr</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n\n<span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"s2\">\"+++\"</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">RightCongruence</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">LeftCongruence</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LeftCongruence</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"bp\">.</span><span class=\"n\">toSetoid</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"bp\">.</span><span class=\"n\">toSetoid</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">congr</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">LeftCongruence</span>\n</code></pre></div>",
        "id": 571118079,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769804861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> I think  you would not have to refer to <code>toSetoid</code> all the time:</p>\n<p>Suppose you have defined a syntactic congruence in the usual way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">synCongr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>Then, you would show:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">synCongr_rightCongr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RightCongruence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">synCongr</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>Then, you could just access the equivalence classes via an abbreviation with <code>toSetoid</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">CongrClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">synCongr_rightCongr</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSetoid</span>\n</code></pre></div>\n<p>From here, you would never have to refer to <code>toSetoid</code> again.</p>",
        "id": 571118657,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769805091
    },
    {
        "content": "<p>I think this is getting a bit sidetracked. I agree with Ching-Tsun that the cleaner generalization is a class over arbitrary relations, and if we <em>really have to</em> we can consider the <code>structure</code> part afterwards. I liked the direction when you proposed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">RightCongruence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span>\n<span class=\"w\">  </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">right_cov</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CovariantClass</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">eq</span>\n</code></pre></div>\n<p>it just needs to be shown that it works with left/right variants.</p>",
        "id": 571118877,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769805180
    },
    {
        "content": "<p>I believe this is essentially the same as what I defined as <code>Congruence</code> above.</p>",
        "id": 571119211,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769805325
    },
    {
        "content": "<p>The only difference is that instead of the relation <code>r</code> being a field of <code>Congruence</code>, it is an argument. For <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> and I, I believe it will not be good for the relation to be a field of <code>Congruence</code> because there is no <em>canonical</em> congruence relation over strings.</p>",
        "id": 571119406,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769805413
    },
    {
        "content": "<p>The <code>Congruence</code> as I defined it is a generalization of both <code>RightCongruence</code> and <code>LeftCongruence</code> as you suggested. Additionally, I showed that the lifted <code>append</code> that <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> and I need can actually be defined on the general <code>Congruence</code> level as a lifted <code>foldl</code>.</p>",
        "id": 571119824,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769805591
    },
    {
        "content": "<p>The generalization I would like to see is something like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">RightCongr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">right_cov</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CovariantClass</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">eq</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">LeftCongr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">left_cov</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CovariantClass</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">eq</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">LeftRightCongr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span>\n<span class=\"w\">  </span><span class=\"n\">LeftCongr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">RightCongr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">op</span>\n</code></pre></div>\n<p>The above definitions are applicable to any type <code>α</code> equipped with a binary operation <code>op : α → α → α</code>.     I had hoped that such definitions already exist in mathlib, but I did not find any.  Note that <code>α</code> can be something that does not have an inductive structure like lists.</p>",
        "id": 571139186,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769814361
    },
    {
        "content": "<p>In my opinion, <code>LeftCongr</code> and <code>RightCongr</code> should descend from a more general <code>Congr</code>. I think <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> has argued this.</p>",
        "id": 571139643,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769814691
    },
    {
        "content": "<p>Sorry, what is <code>Congr</code>?</p>",
        "id": 571139677,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769814717
    },
    {
        "content": "<p>sorry, I am using <code>Congr</code> as shorthand for <code>Congruence</code></p>",
        "id": 571139718,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769814743
    },
    {
        "content": "<p>oh, I misunderstood your question</p>",
        "id": 571139741,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769814758
    },
    {
        "content": "<p>No, I really had in mind something like what is written above.</p>",
        "id": 571139749,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769814764
    },
    {
        "content": "<p>But they are nearly the same definition. You get one or the other just by passing in <code>op.swap</code></p>",
        "id": 571139778,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769814789
    },
    {
        "content": "<p>They are really both just a <code>Congruence</code></p>",
        "id": 571139797,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769814801
    },
    {
        "content": "<p>I think it makes more sense to only have one general <code>Congruence</code>. Differentiating between left and right only makes sense once we are working with strings.</p>",
        "id": 571139901,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769814876
    },
    {
        "content": "<p>Differentiating between left and right congruences makes sense whenever the binary operation is not commutative.</p>",
        "id": 571140065,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769814984
    },
    {
        "content": "<p>Yes, but the point of separating them like this is so that through the typeclass inference when you pass a function to <code>LeftRightCongr</code>, it searches for the <code>CovariantClass</code> instances for both the function and its flipped version. Neither <code>RightCongr</code> or <code>LeftCongr</code> has a more specific claim (\"left\" and \"right\" are arbitrary) but together they say something about <code>op</code> and <code>flip op</code>.</p>",
        "id": 571140139,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769815022
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> in the most general mathematical sense, a congruence is just an equivalence relation that is closed under some operation <code>op</code>. In this sense, <code>op</code> should really have type <code>b -&gt; a -&gt; a</code>. In which case, there is no notion of left or right or commutativity.</p>",
        "id": 571140416,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769815153
    },
    {
        "content": "<p>This may be why you cannot find the version you wrote in Mathlib, it's not a common notion. What's in Mathlib is <code>CovarianceClass</code> because that is more common. And observe that what I described it just an <code>Equivalence</code> equipped with a <code>CovarianceClass</code></p>",
        "id": 571140529,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769815248
    },
    {
        "content": "<p>Here's a version that allows the operands of <code>op</code> to have different types:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">RightCongr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">right_cov</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CovariantClass</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">eq</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">LeftCongr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">left_cov</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CovariantClass</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">eq</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">LeftRightCongr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span>\n<span class=\"w\">  </span><span class=\"n\">LeftCongr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">RightCongr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">op</span>\n</code></pre></div>",
        "id": 571140676,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769815342
    },
    {
        "content": "<p>As such, I think it is more natural that the general version be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Congruence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Equivalence</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">cov</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Covariant</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">r</span>\n</code></pre></div>",
        "id": 571140729,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769815380
    },
    {
        "content": "<p>Okay, now your <code>RightCongruence</code> is the same as my <code>Congruence</code> :)</p>",
        "id": 571140824,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769815434
    },
    {
        "content": "<p>The only question that remains is <code>class</code> and <code>Setoid</code> vs <code>structure</code> and <code>Equivalence</code> <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 571141009,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769815563
    },
    {
        "content": "<p>Oh, I think <code>LeftRightCongr</code> needs two <code>op</code>s to maintain the type generality</p>",
        "id": 571141307,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769815765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"878804\">Liam Schilling</span> <a href=\"#narrow/channel/513188-CSLib/topic/.60RightCongruence.60.20and.20notation.20for.20transduction.20operations/near/571141307\">said</a>:</p>\n<blockquote>\n<p>Oh, I think <code>LeftRightCongr</code> needs two <code>op</code>s to maintain the type generality</p>\n</blockquote>\n<p>I think this is the point we are talking past each other on. This is distinct from <code>LeftRightCongr</code>, which is saying that a <em>single relation</em> and its inverse are covariant.</p>",
        "id": 571141477,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769815895
    },
    {
        "content": "<p>I mean it will work, but it will be clunky to specialize to strings. Ideally imo, we would just need to prove covariance under one-character left-concatenation and one-character right-concatenation (the two different <code>op</code>s). To implement <code>LeftRightCongr</code> as above, we would need to prove it for concatenation in general.</p>",
        "id": 571141760,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769816107
    },
    {
        "content": "<p>I understand the <em>single relation</em> interpretation you mean. I just don't believe this is usually how left-right congruences are interpreted in the literature.</p>",
        "id": 571141817,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769816147
    },
    {
        "content": "<p>Rather, I would say a left-right congruence over strings is usually interpreted (and defined) as a relation that is a right congruence under one-char right concatenation, and a left congruence under one-char left concatenation. Hence, two <code>op</code>s</p>",
        "id": 571141999,
        "sender_full_name": "Liam Schilling",
        "timestamp": 1769816291
    },
    {
        "content": "<p>I think it is a good idea to allow heterogeneous operand types in the definitions <code>LeftCongr</code> and <code>RightCongr</code>, because it is more general.  However, it does not follow that for left and right congruences on lists, we should therefore use one-step left and right concatenations in the definitions.  For my particular application, <code>++</code>-based congruence definition is actually more convenient (see the definition of <code>BuchCongruence</code> in <a href=\"https://github.com/leanprover/cslib/pull/278\">cslib#278</a>).  Furthermore, one-step congruence is an immediate consequence of <code>++</code>-based congruence, while the other direction would require an induction.  So I prefer the <code>++</code>-based definition.</p>",
        "id": 571144725,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1769818065
    }
]