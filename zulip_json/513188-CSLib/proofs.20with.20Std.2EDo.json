[
    {
        "content": "<p>My understanding is that Boole will be the language of choice for CSLib. Is there room for other approaches, too? In particular, is there any interaction between proofs about Boole programs and the forthcoming Std.Do framework?</p>",
        "id": 529479024,
        "sender_full_name": "Jesse Alama",
        "timestamp": 1752850853
    },
    {
        "content": "<p>Can you provide a pointer to info about Std.Do?</p>",
        "id": 529704468,
        "sender_full_name": "Clark Barrett",
        "timestamp": 1753035307
    },
    {
        "content": "<p>It's the FRO built do notation verification framework. It was originally developed here: <a href=\"https://github.com/sgraf812/mpl?tab=readme-ov-file#mpl\">https://github.com/sgraf812/mpl?tab=readme-ov-file#mpl</a> and then merged into core not too long ago, there is some info in that readme about how it works and more ongoing work by Sebastian Graf at the FRO right now.</p>",
        "id": 529707959,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1753039181
    },
    {
        "content": "<p>I think the short answer to</p>\n<blockquote>\n<p>In particular, is there any interaction between proofs about Boole programs and the forthcoming Std.Do framework?</p>\n</blockquote>\n<p>Is: We (as in: the authors of Boole and me, as the author of <code>Std.Do</code>) do not yet know enough about each other's approaches.<br>\nI would hope that we can assess the question better once Boole is released and I have at least written a proper reference manual entry for <code>Std.Do</code> (it is currently in the \"pre-release, use at your own risk\" phase). I would be very excited to support CSLib with <code>Std.Do</code>!</p>",
        "id": 529818736,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1753089415
    },
    {
        "content": "<p>Where can we find the <code>Std.Do</code> reference manual? I would also be curious about reference to understand its implementation.</p>",
        "id": 530163104,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1753195651
    },
    {
        "content": "<p>There's no manual entry yet, that's why I need to write one. I think I'll make that a higher priority (higher than \"avoiding exponential formula blowup\", that is) given that it will be essential to sync up with the CSLib effort ASAP. In the meantime, this blog post gives a rough overview on how to use it: <a href=\"https://markushimmel.de/blog/my-first-verified-imperative-program/\">https://markushimmel.de/blog/my-first-verified-imperative-program/</a>. There's also my kitchen sink test file that you can check out: <a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/doLogicTests.lean\">https://github.com/leanprover/lean4/blob/master/tests/lean/run/doLogicTests.lean</a>.</p>",
        "id": 530181695,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1753201214
    },
    {
        "content": "<p>There's now a <a href=\"https://hackmd.io/@sg-fro/BJRlurP_xg\">tutorial for <code>mvcgen</code></a> with a compact section on how to extend and use it with custom monads.</p>",
        "id": 534621642,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1755248608
    },
    {
        "content": "<p>Any chance of a verso copy?</p>",
        "id": 534625071,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755250442
    },
    {
        "content": "<p>Unfortunately it looks like lean has once again fallen victim to the highlight.js new language door being  sealed shut, and so we have to contact every service using highlight.js and ask them to consider adding our language separately.</p>",
        "id": 534625255,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755250560
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/513188-CSLib/topic/proofs.20with.20Std.2EDo/near/534625071\">said</a>:</p>\n<blockquote>\n<p>Any chance of a verso copy?</p>\n</blockquote>\n<p>Yes, but I wanted to get the content out before making it pretty and polished.</p>",
        "id": 534663386,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1755268410
    },
    {
        "content": "<p>I'm also interested in knowing how Boole and <code>mvcgen</code> will interact with each other. Aeneas and Loom also do something similar, but I hear that Son Ho (Aeneas) is planning to have support for <code>mvcgen</code> soon. </p>\n<p>Should we think of all of them as different ways (instances of Monad?) that can generate verification conditions in pure Lean, so we can ignore which tool was used to get the pure VCs? Even so, I think the style of the VCs will vary from tool to tool, so the proofs that we write for the VCs may look quite different. </p>\n<p>At BAIF and at Galois, we are trying to do Rust verification in Lean, and trying to build AI tools for the VCs which are generated. We are currently going with the Aeneas-to-mvcgen transpiler, but it would great to know which framework (Boole/mvcgen/Loom) to focus on, or at least what the long-term roadmap would be.</p>",
        "id": 558762481,
        "sender_full_name": "Shaowei Lin",
        "timestamp": 1763765096
    },
    {
        "content": "<p>Here's my summary as the maintainer of <code>mvcgen</code>:</p>\n<ul>\n<li><code>Hax</code> builds on <code>Std.Do</code> and uses <code>mvcgen</code> to generate VCs.</li>\n<li>Son Ho of <code>Aeneas</code> is currently looking into using <code>Std.Do</code> in order to use <code>mvcgen</code> to generate VCs. Na√Øvely I would expect that not to be much more difficult than for <code>Hax</code>, however Aeneas has a sophisticated tactic support for its current VC generation mechanism that would need to be ported.</li>\n<li>Vlad Gladstein of Loom will work on generalizing <code>Std.Do</code> in Q1/26 so that Loom can build on it. We have sketched out how a viable generalization might work.</li>\n<li>Boole did not have a shallow embedding into Lean's <code>do</code> notation last I checked (which was a few months ago). I think it could make use of <code>mvcgen</code>/<code>Std.Do</code> iff they manage to define some kind of semantic translation from Boole into something that can have a <code>WP</code> instance (i.e., a Monad). I don't know enough of Boole and its future plans to judge whether such a translation exists.</li>\n<li>Same for Strata. It depends on the generality of the framework, I suppose.</li>\n</ul>\n<p>Concrete answers for your questions:</p>\n<blockquote>\n<p>I'm also interested in knowing how Boole and <code>mvcgen</code> will interact with each other.</p>\n</blockquote>\n<p>Can't say. If anything, Boole is not Rust, so you are probably rather asking about Strata. And I have no idea there, either.</p>\n<blockquote>\n<p>Should we think of all of them as different ways (instances of Monad?) that can generate verification conditions in pure Lean, so we can ignore which tool was used to get the pure VCs?</p>\n</blockquote>\n<p>That would be great, yes. I'm optimistic for shallowly embedded languages (Loom, Aeneas, Hax). I'm not sure if this works out for deeply embedded languages. I hope it will, but I haven't seen examples yet. See \"iff\" above.</p>\n<blockquote>\n<p>Even so, I think the style of the VCs will vary from tool to tool, so the proofs that we write for the VCs may look quite different.</p>\n</blockquote>\n<p>That sounds likely. The generated VCs depend on the particular shallow embedding (i.e., denotational semantics).</p>\n<blockquote>\n<p>We are currently going with the Aeneas-to-mvcgen transpiler, but it would great to know which framework (Boole/mvcgen/Loom) to focus on, or at least what the long-term roadmap would be.</p>\n</blockquote>\n<p>I'm not sure if either competitor falls in the Rust-to-Lean fragment. The decision should be between Hax and Aeneas and I do not have advice here. It has been discussed before, though; see <a class=\"stream-topic\" data-stream-id=\"236449\" href=\"/#narrow/channel/236449-Program-verification/topic/What.20is.20the.20connection.20between.20Aeneas.20and.20Hax.3F/with/536203835\">#Program verification &gt; What is the connection between Aeneas and Hax?</a></p>",
        "id": 558812033,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1763814970
    },
    {
        "content": "<p>Loom is similar to SSProve (in Rocq), in that both use the Dijkstra monad framework. We've been using SSProve as a backend for Hax successfully in:</p>\n<ol>\n<li>Verification of PQ TLS  (<a href=\"https://eprint.iacr.org/2025/980\">https://eprint.iacr.org/2025/980</a>) </li>\n<li>to connect Rust with Jasmin code for cryptographic primitives (Last Yard paper)</li>\n<li>to verify a cryptographic voting smart contract written in Rust. <br>\n<a href=\"https://hax.cryspen.com/publications/\">https://hax.cryspen.com/publications/</a></li>\n</ol>\n<p><span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> you looked at the Dijkstra monad framework, and decided to take another route. You documented your rationale somewhere. Could you remind us of it, and contrast it to Loom ?</p>",
        "id": 559027540,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1763986601
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> ! This helps a lot! I'm looking forward to hearing more about how deeply embedded languages like Boole and Strata could build on <code>mvcgen/Std.Do</code>, when their developers are ready to discuss this.</p>",
        "id": 560076986,
        "sender_full_name": "Shaowei Lin",
        "timestamp": 1764052339
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> for highlighting the similarities between Loom, SSProve and Hax!</p>",
        "id": 560307550,
        "sender_full_name": "Shaowei Lin",
        "timestamp": 1764135014
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657707\">@Shaowei Lin</span> to be sure, Loom is an implementation of the Dijkstra monad framework, the same one we've been using the last five years in SSProve. SSProve supports a relational logic, which is common for security proofs.<br>\nI don't think these are currently supported by Loom (I only looked quickly), but I think it could be added.<br>\nHax is partially orthogonal in that it transforms industry rust code into a language friendly for proof assistants (similar to aeneas, in this respect as they share parts of the front-end).</p>",
        "id": 560417249,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1764170601
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> do you know of any implementations of SSProve in Lean? While Loom is also based on the Dijkstra monad framework, it doesn't seem to have the same concept of \"packages\" with import and export interfaces as SSProve.</p>",
        "id": 566021928,
        "sender_full_name": "Shaowei Lin",
        "timestamp": 1767333540
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/513188-CSLib/topic/proofs.20with.20Std.2EDo/near/559027540\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> you looked at the Dijkstra monad framework, and decided to take another route. You documented your rationale somewhere. Could you remind us of it, and contrast it to Loom ?</p>\n</blockquote>\n<p>This was the initial realization that led me to a slightly different approach than the Dijkstra monad encoding: <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499787873\">https://leanprover.zulipchat.com/#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499787873</a></p>\n<p>There's also a practical difference in expressivity: When exceptions are involved, Dijkstra monads force you into a fixed postcondition interpretation of the exceptional case, whereas in Std.Do you can choose your postcondition freely. The <a href=\"https://lean-lang.org/doc/reference/latest/The--mvcgen--tactic/Tutorial___-Verifying-Imperative-Programs-Using--mvcgen/#The-Lean-Language-Reference--The--mvcgen--tactic--Tutorial___-Verifying-Imperative-Programs-Using--mvcgen--Exceptions\">reference manual entry about exceptions</a> goes through an example that isn't easily expressed in a Dijkstra monad framework:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Supply</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">counter</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">limit</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">property</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">counter</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">limit</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkFresh</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EStateM</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">Supply</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">supply</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">get</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">supply</span><span class=\"bp\">.</span><span class=\"n\">counter</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">supply</span><span class=\"bp\">.</span><span class=\"n\">limit</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">throw</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"Supply exhausted: {supply.counter} = {supply.limit}\"</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">supply</span><span class=\"bp\">.</span><span class=\"n\">counter</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">supply</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n<span class=\"w\">    </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">supply</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">counter</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">property</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mkFresh_spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">‚¶É</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">‚åú</span><span class=\"n\">state</span><span class=\"bp\">.</span><span class=\"n\">counter</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">‚åù</span><span class=\"o\">‚¶Ñ</span>\n<span class=\"w\">    </span><span class=\"n\">mkFresh</span>\n<span class=\"w\">    </span><span class=\"o\">‚¶É</span><span class=\"n\">post</span><span class=\"bp\">‚ü®</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">‚åú</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"bp\">.</span><span class=\"n\">counter</span><span class=\"bp\">‚åù</span><span class=\"o\">,</span>\n<span class=\"w\">          </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">‚åú</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"bp\">.</span><span class=\"n\">counter</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"bp\">.</span><span class=\"n\">limit</span><span class=\"bp\">‚åù‚ü©</span><span class=\"o\">‚¶Ñ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">mvcgen</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mkFresh</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>Note that <code>fun _ state =&gt; ‚åúc = state.counter ‚àß c = state.limit‚åù‚ü©</code> specifies the exact postcondition that holds when an exception is thrown; it's neither simply <code>False</code> nor <code>True</code>.</p>",
        "id": 566033707,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1767343558
    },
    {
        "content": "<p>\"Dijkstra monad\" is a very general concept, and one that keeps getting generalized over the years. Loom is based on Dijkstra monads in so far as it reinterprets every computational monad by an effect observation (generalized as \"ordered monad algebra\") into some lattice, and this lattice <em>might</em> be viewed as a special Dijkstra monad. (Although the notion of \"ordered\" has not been standard in any of the Dijkstra monad works I recall, and there might be useful lattices/algebras that are not monads.)<br>\nIf you want to equate every ordered monad algebra into an ordere monad with \"Dijkstra monad\" (i.e. \"Dijkstra monads for All\"), then so be it. I would argue that \"ordered monad algebra\" is a concept that can be grasped much easier.</p>\n<p>One advantage of \"ordered monad algebra\" is that you can choose the lattice freely. To make progress on Std.Do, I initially started out thinking that it's enough to fix the lattice to predicate transformers over exceptions and states. This was great to get things starting and is expressive enough to handle most monadic computable Lean programs. It is not enough to handle noncomputable monads such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Probability/ProbabilityMassFunction/Basic.html#PMF\"><code>PMF</code></a> (where the base proposition is a distribution <code>Œ± ‚Üí ‚Ñù‚â•0‚àû</code> rather than a set <code>Œ± ‚Üí Prop</code>) or separation logic, where you really need the relaxed requirement on <code>bind</code> that is embodied in Loom's <code>ùúá_ord_bind</code>.</p>\n<p>Hence we'll work on opening up the notion of predicate transformers and <code>wp_bind</code> to accommodate both use cases.</p>",
        "id": 566033739,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1767343579
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657707\">@Shaowei Lin</span> No, there is no treatment of SSP packages in Lean. This could potentially be formalized on top of an existing framework for reasoning about probability and state. One would then prove the fundamental theorem 2.4 <a href=\"https://eprint.iacr.org/2021/397.pdf#page=7.20\">here</a> connecting the SSP semantics with the one of the program logic. This could potentially also be done on top of the ongoing implementation of bluebell in Iris Lean (<a href=\"https://github.com/Verified-zkEVM/iris-lean\">https://github.com/Verified-zkEVM/iris-lean</a>). Although I have not seen the details of that yet.</p>",
        "id": 566041535,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1767348855
    }
]