[
    {
        "content": "<p>I started a PR <a href=\"https://github.com/leanprover/cslib/pull/92\">cslib#92</a> on <code>ωLanguage</code>, which is the infinite-word analogue of <code>Mathlib.Computability.Language</code>.  If anyone has a better idea for the definition of <code>omegaPower</code>, please let me know.  One of my goals is to port the theorems in:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Languages/Basic.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Languages/Basic.lean</a><br>\nsome of which are pretty nasty to prove.  I can definitely use some better ideas.</p>",
        "id": 544267036,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1760141395
    },
    {
        "content": "<p>Is it true that <code>L^ω = (L∗)↗ω</code>? — that might not be easier to work with as a definition but it is at least cleaner (or seems so to me)</p>",
        "id": 544849694,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1760482764
    },
    {
        "content": "<p><code>L^ω ⊆ (L∗)↗ω</code> is certainly true, but I'm not too sure about the other direction.  I'm working on an alternative definition of <code>L^ω</code> that uses an <code>ωSequence</code> version of <code>flatten</code>, in a manner analogous to how <code>L∗</code> is defined in Mathlib.Computability.Language.  We will see whether this makes the proofs easier</p>",
        "id": 544850575,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1760483392
    },
    {
        "content": "<p>The PR <a href=\"https://github.com/leanprover/cslib/pull/92\">cslib#92</a> for OmegaLanguage is now ready for review.  The proofs of the harder results have been much improved relative to: <br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Languages/Basic.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Languages/Basic.lean</a><br>\nWe now have enough results about OmegaLanguage to start developing the theory of ω-automata.<br>\nCC: <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> , <span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span></p>",
        "id": 547007075,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761344924
    },
    {
        "content": "<p>That looks pretty good to me. I'd just like to point out this PR creates the <code>Computability/Languages/</code> directory with this (containing Language and OmegaLanguage), which seems ok to me, in case anybody wants to comment on that.</p>",
        "id": 547249990,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761563752
    },
    {
        "content": "<p>That did pass my notice, but I think it's fine? Maybe <code>Languages.Languages</code> is mildly confusing, but it's probably okay.</p>",
        "id": 547252497,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761564511
    },
    {
        "content": "<p>Actually the names of leaf files are in singular, not plural, forms.  I expect <code>Computability/Languages/</code> to get more files, such as <code>OmegaRegularLanguage.lean</code>.</p>",
        "id": 547321864,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761582242
    },
    {
        "content": "<p>On a related note, I noticed there is now a LTS.<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\"> \\omega </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span> Tr definition, but it looks more like a definition of an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\"> \\omega </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>-run to me than a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\"> \\omega </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>-transition. In comparison, the LTS.MTr definition looses the 'intermediate states' along a path, while the LTS.<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\"> \\omega </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span> Tr definition keeps them. I think this is confusing.</p>\n<p>Is there a place where we talk about runs/walks/whatever we should call it, instead of transitions?<br>\nAnd should this definition not go there?</p>\n<p>(In the context of Zeno behavior, or in the context of Buchi-like automata, it makes sense to have an infinite series of transitions \"end\" in some final state. In that context, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\"> \\omega </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span> Tr would make sense to me.)</p>",
        "id": 566504563,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1767690830
    },
    {
        "content": "<p>I don't have a strong view about the name.  But we will need such a definition, whatever we choose to call it. For, in automata theory on infinite words, we need to express such notions as \"some accepting states appear infinitely many times\" and \"the set of states that appear infinitely many times is such and such\".</p>",
        "id": 566596959,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1767723017
    },
    {
        "content": "<p>My current vision is that all of the following might be relevant, long-term:</p>\n<ul>\n<li>LTS.Execution, which is the finite version of our current LTS.ωTr (using Lists instead of ωSequences). It models a finite sequence of transitions.</li>\n<li>LTS.MTr, basically what we have now. It's a multi-step transition from a state to another.</li>\n<li>LTS.OmegaExecution, which is our current LTS.ωTr. It's an (omega-)infinite sequence of transitions.</li>\n<li>LTS.ωTr, which is the LTS.MTr equivalent for OmegaExecution.</li>\n</ul>\n<p>with theorems connecting all of these.</p>\n<p>There's some thinking to do and I really wanted to unlock the link-up between LTS and the automata work, so in the spirit of 'good is better than perfect' I added LTS.ωTr and postponed thinking about this.</p>",
        "id": 566607333,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1767727344
    },
    {
        "content": "<p>I'm not sure there is a useful infinite counterpart of LTS.MTr.  LTS.OmegaExecution is useful.  But once you get rid of the infinite sequence of states, I don't think what remains is very useful.</p>",
        "id": 566621578,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1767733336
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/OmegaLanguage/near/566621578\">said</a>:</p>\n<blockquote>\n<p>I'm not sure there is a useful infinite counterpart of LTS.MTr.  LTS.OmegaExecution is useful.  But once you get rid of the infinite sequence of states, I don't think what remains is very useful.</p>\n</blockquote>\n<p>My feeling as well. I think renaming the current LTS.ωTr to LTS.ωExecution and introducing LTS.Execution is a natural first step. (I'll put it on my todo list, so keep me posted if anyone wants to start on it as well.)</p>\n<p>There are conceivable infinite counterparts of LTS.MTr, but those require that one comes up with a \"cluster point\" or \"convergence point\" of an infinite sequence of states. On metric or topological labeled transition systems, this is done. But without additional structure, indeed, it does not make sense (to me at least).</p>",
        "id": 566896985,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1767863911
    },
    {
        "content": "<p>Actually it is not very clear what a definition for LTS.Execution should look like.  Fabrizio and I thought about this but have not reached a definite conclusion.  The closest thing we have now is the theorem <code>LTS.MTr.exists_states</code> in LTS/Basic.lean.  Also,  in PR <a href=\"https://github.com/leanprover/cslib/pull/249\">cslib#249</a>, we have a series of theorems relating <code>LTS.MTr</code> and <code>LTS.ωTR</code> in the section <code>ωMultiStep</code> in the same file.</p>",
        "id": 567015224,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1767899946
    },
    {
        "content": "<p>Here's the current status on that:</p>\n<p>I have a local branch with a ready-to-PR proposal for Execution and related theorems. I never made a PR simply because I haven't found a use for it yet.</p>\n<p>It looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- An execution is a (possibly-empty) sequence of transitions from a start state. -/</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">IsExecution</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsExecution</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">stepL</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">μs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsExecution</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">s3</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"n\">IsExecution</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s3</span>\n</code></pre></div>\n<p>This construction is similar to what people do in 'execution systems', where you have a start state and then a <code>List (Label x State)</code>. However, <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> and I discussed that working with such lists that pack together labels and states is a bit of a pain, so we've been sticking to having two lists (one for labels and one for states) instead.</p>\n<p>In infinite executions (currently OmegaTr), the formulation is easier/more elegant because you just need two omega-sequences, as you don't need to cover the case where the execution has no transitions.</p>\n<p>IsExecution comes with some basic properties and a correspondence to MTr:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Correspondence between multistep transitions and executions. -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mTr_isExecution_iff</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">MTr</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">IsExecution</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>I'm not sure how to refactor, if at all, <code>theorem MTr.exists_states</code> if we introduce this. We need something like that to enable reasoning with indexes.</p>",
        "id": 567103864,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1767952190
    },
    {
        "content": "<p>I like that definition quite a lot! It solves some of the problems I've had in the past as well, at first sight.</p>\n<p>I think, actually, that the correspondence theorem you now use is really the definition of LTS.MTr<br>\nI would just prove all the composition theorems on IsExecution first, and then derive them for LTS.MTr</p>\n<p>In a few weeks time, I get four students who want to do a Lean4 project. I'm planning to leave it a bit open to them what kind of problems to take on, but such a refactoring could be part of the work? (No promisses, they also have to want it, and it has to be interesting enough from an educational point of view.)</p>",
        "id": 567146099,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1767966630
    },
    {
        "content": "<p>MTr.exists_states sounds like a connection to me between walks in a graph and executions over an LTS.<br>\nA walk in a graph would be a \"list of edges\" that are appropriately connected.<br>\nEach edge, in case of an LTS, is a transition.</p>",
        "id": 567148303,
        "sender_full_name": "Pieter Cuijpers",
        "timestamp": 1767967283
    },
    {
        "content": "<p>Well, an lts is essentially a graph -- with minimal assumptions (can have infinite states, have infinite edges getting out of a state, etc.). So MTr/IsExecution is a walk. In introduction to choreographies, I have a background chapter on inference systems where I use exactly graph walks as an example, because then it translates directly to an inference system for multistep transitions in lts.</p>",
        "id": 567150444,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1767967904
    },
    {
        "content": "<p>the key difference with MTr.exists_states is just ergonomics, iiuc, i.e., whether you wanna reason by structural induction on the walk or you wanna reason on the indexes of the 'list(s) of transitions'.</p>\n<p>it <em>might</em> be that we can elegantly refactor the proofs that use MTr.exists_states to use IsExecution instead, but we should really check. :-)</p>",
        "id": 567150899,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1767968060
    },
    {
        "content": "<p>Why not just take the right-hand side of <code>LTS.MTr.exists_states</code> as the definition of <code>LTS.IsExecution</code>?  Namely:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"bp\">.</span><span class=\"n\">IsExecution</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">[</span><span class=\"n\">μs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The current proof of <code>LTS.MTr.exists_states</code> already proves the <code>→</code> direction of <code>mTr_isExecution_iff</code> and a simple induction on <code>ℕ</code> will prove the <code>←</code> direction.  In general, I find it much more pleasant to work with explicit indices over ℕ than with custom inductive types, because Lean has very strong support for such reasoning in <code>grind</code> and <code>omega</code> tactics and also has an enormous library about Lists.</p>",
        "id": 567249452,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1767987257
    },
    {
        "content": "<p>I mentioned this in a review I just left, but could you explain to me this pattern of having existentials like <code>∃ _ : ss.length = μs.length + 1</code> ? It feels very odd for things whose type is in <code>Prop</code>.</p>",
        "id": 567250644,
        "sender_full_name": "Chris Henson",
        "timestamp": 1767987698
    },
    {
        "content": "<p>The weird <code>∃ _</code> and <code>∀ _</code> patterns are there to enable Lean to automatically infer that all indexing operations in the expression are within bounds.  Once you get familiar with it, it is very easy to use.</p>",
        "id": 567251040,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1767987847
    },
    {
        "content": "<p>In informal math, you would write something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"bp\">.</span><span class=\"n\">IsExecution</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">ss</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">[</span><span class=\"n\">μs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>But Lean is not smart enough (yet) to supply the in-bound proofs in this case.</p>",
        "id": 567251839,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1767988171
    },
    {
        "content": "<p>As I noted in the review for <a href=\"https://github.com/leanprover/cslib/pull/241\">cslib#241</a> for the <code>∀ _</code> you can instead write <code>∀ k, (_ : k &lt; μs.length) → ...</code>, which I think is a bit more legible.</p>\n<p>Not sure about the existential though. Is this sort of thing common upstream for proofs using indexing? It all seems to work fine, I just want to make sure we're doing whatever is most standard.</p>",
        "id": 567252319,
        "sender_full_name": "Chris Henson",
        "timestamp": 1767988348
    },
    {
        "content": "<p>We can use whatever form that is considered standard.  By Curry-Howard isomorphism, I suspect they are literally identical to Lean.</p>",
        "id": 567252769,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1767988537
    },
    {
        "content": "<p>BTW, there is another advantage of using explicit list indexing over an inductive definition: the latter biases you toward doing induction from the left end of the list while the former doesn't.  For example, in many automata theory textbooks, a multi-step execution is defined by induction on the right end of the list, which is the opposite of how induction on lists is typically done in Lean.  So the translation from the textbook to the Lean code is not exactly straightforward.  By using explicit list indexing, when you do an induction on ℕ, you can choose to decompose the list either on the left end or on the right end and you can always find appropriate API functions and theorems in mathlib to support your reasoning.</p>",
        "id": 567254833,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1767989378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/OmegaLanguage/near/567249452\">said</a>:</p>\n<blockquote>\n<p>Why not just take the right-hand side of <code>LTS.MTr.exists_states</code> as the definition of <code>LTS.IsExecution</code>?  Namely:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"bp\">.</span><span class=\"n\">IsExecution</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">[</span><span class=\"n\">μs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The current proof of <code>LTS.MTr.exists_states</code> already proves the <code>→</code> direction of <code>mTr_isExecution_iff</code> and a simple induction on <code>ℕ</code> will prove the <code>←</code> direction.  In general, I find it much more pleasant to work with explicit indices over ℕ than with custom inductive types, because Lean has very strong support for such reasoning in <code>grind</code> and <code>omega</code> tactics and also has an enormous library about Lists.</p>\n</blockquote>\n<p>This was an idea I did consider, actually, also because it matches what we'd do for OmegaExecution (now called OmegaTr). I guess my main qualm for not doing it right now is that it looks a bit weird. I'll spend some more time trying to make it look what one would write on paper... I remember I had some problems making the proofs go through though -- probably connected to what you mention about grind and omega.</p>",
        "id": 567317625,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1768049386
    },
    {
        "content": "<p>I should point out that a theorem like <code>LTS.MTr.exists_states</code> will always be needed, no matter how we define <code>LTS.IsExecution</code>, for the simple reason that we need to relate finite executions and infinite executions somehow.  So my suggestion is that we may as well just use the RHS of <code>LTS.MTr.exists_states</code> as the definition.  In fact, we can probably live without a definition for <code>LTS.IsExecution</code> at all.  This is the situation now, and I don't feel we lack anything when proving theorems.</p>\n<p>Having said all that, here's yet another possible definition of <code>`LTS.MTr.exists_states</code>: we can make the state sequence always infinite as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"bp\">.</span><span class=\"n\">IsExecution</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"bp\">.</span><span class=\"n\">mTr_isExecution_iff</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">MTr</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">IsExecution</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This way we can dispense with all the pesky assertions about the lengths of state sequences and related list indexing in-bound proofs, though we still need to reason about those about label sequences.  Also note that  <code>lts.IsExecution μs ss</code> doesn't need to mention <code>s1</code> and <code>s2</code>, because they are simply <code>ss 0</code> and <code>ss μs.length</code>.  In the proof of the <code>→</code> direction of <code>LTS.mTr_isExecution_iff</code> we need to extend finite sequences to infinite sequence.  But that would not be a problem because we can always repeat <code>s1</code> forever.  We probably should also prove theorems saying that <code>lts.IsExecution μs ss</code> depends only on the first <code>μs.length + 1</code> states of <code>ss</code>, though my experience suggests that such theorems  are never actually used in the development of automata theory.</p>",
        "id": 567354385,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1768088940
    },
    {
        "content": "<p>I managed to clean up the list stuff quite a bit. See <a href=\"https://github.com/leanprover/cslib/pull/258\">cslib#258</a> for a possible definition of execution.</p>\n<p><span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> I agree that maybe we can do without, but it's nice to give it a name in theorems about it. We'll see how useful it can be though..</p>\n<p>Anyway, if we go ahead with this, I should probably add to the PR a renaming of OmegaTr to IsOmegaExecution.</p>\n<p>I'm using the Is-prefix because it might make sense to have a bundled version as well with 'methods' like 'start', 'final', 'labels', etc. But I don't wanna introduce that now, since I don't see any proof that needs it yet.</p>",
        "id": 567387387,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1768134436
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>  I have commented on <a href=\"https://github.com/leanprover/cslib/pull/258\">cslib#258</a>.  I think you want to include the beginning and ending states among the arguments of <code>LTS.IsExecution</code>.  That will make the statements of several theorem shorter and prettier.  (In particular, the condition <code>ss.length = μs.length + 1</code> won't need to be mentioned again and again.)</p>\n<p>I'm fine with renaming <code>OmegaTR</code> to <code>IsOmegaExecution</code>.  But perhaps we can shorten <code>Execution</code> to <code>Exec</code> everywhere?  I think we should not use the Greek letter <code>ω</code> for <code>Omega</code>, because it is hard to notice.</p>",
        "id": 567433897,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1768186506
    },
    {
        "content": "<p>Re naming and Omega: I agree, it's also a pain to search. Do I understand correctly you mean renaming <code>ωTr</code> into <code>OmegaExecution</code>?</p>",
        "id": 567594158,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1768237687
    },
    {
        "content": "<p>Re the length thing, I've replied in the PR.</p>",
        "id": 567594325,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1768237728
    },
    {
        "content": "<p>I would prefer <code>OmegaExec</code> for brevity.  But <code>OmegaExecution</code> is fine, too.</p>",
        "id": 567598519,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1768238768
    }
]