[
    {
        "content": "<p>I currently have a bit more time on hand and wanted to use that on contributing to nice projects. And I think CSLib could be such a nice project, but I'm a bit lost where I my contributions could be valuable.</p>\n<p>I recently finished my phd on theoretical computer science in program verification, in case my expertise level is relevant. I thought the Algorithms folder still looks a bit empty, but I'm open for any ideas.</p>\n<p>Any recommendations where/what I could contribute?</p>",
        "id": 566764048,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1767800920
    },
    {
        "content": "<p>I wanted to join this discussion to also ask where contributions would be appreciated; this is my first foray into open source Lean. <span class=\"user-mention\" data-user-id=\"571277\">@Ira Fesefeldt</span>, I was leaning towards adding more sorting algorithms to CSLib, like insertion sort, etc., as they are integral to the CS curriculum at most universities. Would that be appreciated, or are there other algorithms to focus on instead?</p>",
        "id": 566771459,
        "sender_full_name": "Arjun Bhamra",
        "timestamp": 1767802912
    },
    {
        "content": "<p>The algorithms section is empty partly because Boole hasn’t landed yet and partly because we are still not fixed on the correct modelling of algorithms. There is the very lightweight <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a> which has been merged and there is (imo) the more systematic version that’s still WIP (<a href=\"https://github.com/leanprover/cslib/pull/201\">cslib#201</a>)</p>",
        "id": 566785867,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767806881
    },
    {
        "content": "<p>The latter is mine and I will get to finishing jt soon modulo some other upcoming deadline constraints.</p>",
        "id": 566785966,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767806913
    },
    {
        "content": "<p>I understand that there is a lot to do on the automata and logic side as well and it is in better shape.</p>",
        "id": 566786278,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767807037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/ideas.20for.20first.20contribution/near/566786278\">said</a>:</p>\n<blockquote>\n<p>I understand that there is a lot to do on the automata and logic side as well and it is in better shape.</p>\n</blockquote>\n<p>Are there any specific areas you could point me to, PRs/issues or otherwise? I'd love to help (assuming the barrier to entry isn't too high for me). Thanks for the heads-up w.r.t the Algorithms section.</p>",
        "id": 566802907,
        "sender_full_name": "Arjun Bhamra",
        "timestamp": 1767812486
    },
    {
        "content": "<p>I can point to a couple of things I know of:</p>\n<ul>\n<li><a href=\"https://api.cslib.io/docs/Cslib/Foundations/Data/Relation.html\">Cslib.Foundations.Data.Relation</a> has recently expanded a bit, but still likely missing pretty basic theorems. Exercises in Chapter 2 of the listed reference could be good for instance.</li>\n<li><a href=\"https://api.cslib.io/docs/Cslib/Languages/LambdaCalculus/LocallyNameless/Untyped/FullBetaConfluence.html#Cslib.LambdaCalculus.LocallyNameless.Untyped.Term.para_diamond\">Cslib.LambdaCalculus.LocallyNameless.Untyped.Term.para_diamond</a> is a complete but overly long proof that I would love for someone to clean up. <a href=\"https://plfa.github.io/Confluence/#parallel-reduction-satisfies-the-diamond-property\">In PLFA</a> for instance they have a very nice proof (using what is sometimes called the Takahashi translation) that I had trouble getting to work with locally nameless syntax</li>\n<li>I would be happy to review any proofs of strong normalization for the existing locally nameless lambda calculi (there is currently untyped, STLC, and System F with subtyping). The locally nameless part can make things tricky and I'm going to in the hopefully near future encourage a different binding scheme for most of CSLib, but it would still be valuable to have these proofs.</li>\n</ul>",
        "id": 566806872,
        "sender_full_name": "Chris Henson",
        "timestamp": 1767813730
    },
    {
        "content": "<p>Sounds good, I'll try taking a look at the <code>Relation</code> file and \"Term Rewriting and All That\" (great name for a book); thanks!</p>",
        "id": 566811135,
        "sender_full_name": "Arjun Bhamra",
        "timestamp": 1767815248
    },
    {
        "content": "<p>I'd also be very interested in helping with <code>Relation</code>! Is there anything important to watch when contributing?</p>",
        "id": 566811349,
        "sender_full_name": "Oliver Soeser",
        "timestamp": 1767815342
    },
    {
        "content": "<p>One oddity is that to my knowledge there isn't an upstream definition of just the symmetric closure of a relation, so feel free to add this definition if you need it. You may find yourself wanting certain inductions that haven't been defined yet, these would be welcome contributions as well. If there's any questions about the right way to state a missing definition, please ask here and I'd be happy to discuss.</p>",
        "id": 566815333,
        "sender_full_name": "Chris Henson",
        "timestamp": 1767816823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/513188-CSLib/topic/ideas.20for.20first.20contribution/near/566815333\">said</a>:</p>\n<blockquote>\n<p>One oddity is that to my knowledge there isn't an upstream definition of just the symmetric closure of a relation</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompRel#doc\">docs#CompRel</a>, but it should probably be renamed <code>Relation.SymmGen</code> and moved to <code>Mathlib.Logic.Relation</code></p>",
        "id": 566819766,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1767818494
    },
    {
        "content": "<p>I'm working on porting the results in my earlier automata theory project:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory\">https://github.com/ctchou/AutomataTheory</a><br>\ninto cslib.  But there are still many interesting results in automata theory which are not in my plan.  Here are some examples off the top of my head:</p>\n<ul>\n<li>Regular expressions as another characterization of regular languages.</li>\n<li>Brzozowski's algorithm (<a href=\"https://en.wikipedia.org/wiki/DFA_minimization#Brzozowski's_algorithm\">https://en.wikipedia.org/wiki/DFA_minimization#Brzozowski's_algorithm</a>).</li>\n<li>The connection between Büchi automata and monadic second-order logic.</li>\n</ul>",
        "id": 566823116,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1767819917
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/513188-CSLib/topic/ideas.20for.20first.20contribution/near/566819766\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompRel#doc\">docs#CompRel</a>, but it should probably be renamed <code>Relation.SymmGen</code> and moved to <code>Mathlib.Logic.Relation</code></p>\n</blockquote>\n<p>Thanks for sharing this! I agree, and it appears this file is not imported anywhere at the moment, so probably an easy change.</p>",
        "id": 566828104,
        "sender_full_name": "Chris Henson",
        "timestamp": 1767821974
    },
    {
        "content": "<p>This is not a small project, but I really really hope the CSLib instigates a good Float library for Lean. This seems like one of the highest impact possible projects, and of course there is an excellent model to follow from Rocq.</p>",
        "id": 566829165,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1767822429
    },
    {
        "content": "<p>I was already in the process of telling myself that I shouldn't try to work on/port a Float library :|</p>",
        "id": 566829480,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1767822563
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/513188-CSLib/topic/ideas.20for.20first.20contribution/near/566829165\">said</a>:</p>\n<blockquote>\n<p>This is not a small project, but I really really hope the CSLib instigates a good Float library for Lean. </p>\n</blockquote>\n<p>Any specific Rocq works do you have in mind?</p>",
        "id": 566831046,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1767823250
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/ideas.20for.20first.20contribution/near/566831046\">said</a>:</p>\n<blockquote>\n<p>Any specific Rocq works do you have in mind?</p>\n</blockquote>\n<p>I guess it's <a href=\"https://flocq.gitlabpages.inria.fr/\">Flocq</a></p>",
        "id": 566835836,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1767825501
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/513188-CSLib/topic/ideas.20for.20first.20contribution/near/566828104\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/513188-CSLib/topic/ideas.20for.20first.20contribution/near/566819766\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompRel#doc\">docs#CompRel</a>, but it should probably be renamed <code>Relation.SymmGen</code> and moved to <code>Mathlib.Logic.Relation</code></p>\n</blockquote>\n<p>Thanks for sharing this! I agree, and it appears this file is not imported anywhere at the moment, so probably an easy change.</p>\n</blockquote>\n<p>Just to clarify, we'd want to hold off on any formalization of symmetric closure within CSLib's <code>Relation.lean</code>until <code>CompRel</code> is moved? There are probably other theorems/exercises that don't require symmetric closure, will try to find those</p>",
        "id": 566839878,
        "sender_full_name": "Arjun Bhamra",
        "timestamp": 1767827232
    },
    {
        "content": "<p>You can still use <code>CompRel</code> in the meantime.</p>",
        "id": 566840627,
        "sender_full_name": "Chris Henson",
        "timestamp": 1767827642
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/513188-CSLib/topic/ideas.20for.20first.20contribution/near/566806872\">said</a>:</p>\n<blockquote>\n<p>... proofs of strong normalization for the existing locally nameless lambda calculi</p>\n</blockquote>\n<p>Do you have any thoughts about how (or if, I suppose) we should go about formalising logical relations / reducibility candidates? It would be nice if some of those arguments could be generalised across different calculi &amp; different results, but I don't really see how one would go about that</p>",
        "id": 566865341,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1767846952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"931332\">Thomas Waring</span> <a href=\"#narrow/channel/513188-CSLib/topic/ideas.20for.20first.20contribution/near/566865341\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/513188-CSLib/topic/ideas.20for.20first.20contribution/near/566806872\">said</a>:</p>\n<blockquote>\n<p>... proofs of strong normalization for the existing locally nameless lambda calculi</p>\n</blockquote>\n<p>Do you have any thoughts about how (or if, I suppose) we should go about formalising logical relations / reducibility candidates? It would be nice if some of those arguments could be generalised across different calculi &amp; different results, but I don't really see how one would go about that</p>\n</blockquote>\n<p>I'm not sure either. As I've mentioned before, I have plans for adapting work from Isabelle and Rocq for unifying binding across CSLib, essentially metaprograms that give you an inductive definition and tactics. The work that is maybe the closest analogy to that for logical relations is <a href=\"https://complogic.cs.mcgill.ca/beluga/\">Beluga</a> (see <a href=\"https://www.cs.mcgill.ca/~bpientka/talks/beluga-logrel.pdf\">these slides too</a>) and <a href=\"https://arxiv.org/abs/1507.08053\">contextual types</a>, but I'm not as comfortable with what this would look like in Lean. I'm very open to experimentation that builds on this literature if that's something you're interested in, it's just a bit more unfamiliar to me personally and possibly somewhat uncharted territory.</p>",
        "id": 566871538,
        "sender_full_name": "Chris Henson",
        "timestamp": 1767851956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/ideas.20for.20first.20contribution/near/566823116\">said</a>:</p>\n<blockquote>\n<p>I'm working on porting the results in my earlier automata theory project:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory\">https://github.com/ctchou/AutomataTheory</a><br>\ninto cslib.  But there are still many interesting results in automata theory which are not in my plan.  Here are some examples off the top of my head:</p>\n<ul>\n<li>Regular expressions as another characterization of regular languages.</li>\n<li>Brzozowski's algorithm (<a href=\"https://en.wikipedia.org/wiki/DFA_minimization#Brzozowski's_algorithm\">https://en.wikipedia.org/wiki/DFA_minimization#Brzozowski's_algorithm</a>).</li>\n<li>The connection between Büchi automata and monadic second-order logic.</li>\n</ul>\n</blockquote>\n<p>As far as I can tell, there is already quite some work done on the characterization of regular languages as regular expressions in mathlib (regular expressions themselves are there defined already, the thompson construction exists twice as pr). Is the general plan to move such results to Cslib or...?</p>",
        "id": 566975295,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1767887412
    },
    {
        "content": "<p>The idea of moving things from Mathlib to CSLib, contingent on agreement from both groups of maintainers, has been discussed but there is no active effort to do so yet. Especially considering CSLib is a very new project in comparison to Mathlib, there is no rush to do so until everyone feels comfortable that this makes sense in the long term. As we are downstream of Mathlib, we can easily extend existing Mathlib modules in CSLib. We have done so in a few cases, including upstreaming back to Mathlib when appropriate. In other cases we have some definitions that diverge slightly, but have proofs of equivalence.</p>",
        "id": 566981246,
        "sender_full_name": "Chris Henson",
        "timestamp": 1767888976
    },
    {
        "content": "<p>Yes, the definition of regular expressions exists in mathlib.  But the closures of regular languages under boolean operations appeared in mathlib only a month ago and the PRs for the closures under concatenation and Kleene star are still open.  You can't prove the equivalence between regular expressions and regular languages without those results.  After my PRs <a href=\"https://github.com/leanprover/cslib/pull/239\">cslib#239</a> and <a href=\"https://github.com/leanprover/cslib/pull/241\">cslib#241</a> are closed, those result will exist in cslib.</p>\n<p>Also, the automata infrastructure in cslib strives to treat automata on finite words and automata on infinite words in as uniform a fashion as possible.  There is nothing about automata on infinite words in mathlib.</p>",
        "id": 567017614,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1767900743
    },
    {
        "content": "<p>Hi all <span aria-label=\"smiling face\" class=\"emoji emoji-263a\" role=\"img\" title=\"smiling face\">:smiling_face:</span> Since the discussion came up, I’m also curious about the future of regular expressions in CSLib.</p>\n<p>Mathlib’s definition of regexes currently does not have complement and intersection (I'm asking because I’ve formalized algorithms for these operations before). If I wanted to build on the existing Mathlib definitions, what would be the recommended way to integrate these new constructors into CSLib?</p>\n<p>I’m also interested in a more general symbolic setting, where single characters are replaced by predicates. Again, is it preferable to keep the standard definition and work on a parallel version, or is there room for a discussion about generalising the definition to symbolic alphabets (which subsumes the classical one). I’d love to hear what the maintainers consider the cleanest approach for such generalisations.</p>",
        "id": 567020104,
        "sender_full_name": "Kat Zhuchko",
        "timestamp": 1767901660
    },
    {
        "content": "<p>Hey Kat, nice to hear from you! :) I'm not so familiar with this material so sorry in advance if I misunderstand anything, but I can answer your questions from the maintainer perspective</p>\n<blockquote>\n<p>If I wanted to build on the existing Mathlib definitions, what would be the recommended way to integrate these new constructors into CSLib?</p>\n</blockquote>\n<p>For areas where definitions exists in Mathlib and we're happy to continue using those definitions in CSLib, we welcome PRs that extend currently existing Mathlib namespaces. As an example, there is <a href=\"https://api.cslib.io/docs/Cslib/Foundations/Data/Relation.html\">Cslib.Foundations.Data.Relation</a> with some additional definitions about relations that have more of a CS flavor.</p>\n<blockquote>\n<p>Again, is it preferable to keep the standard definition and work on a parallel version, or is there room for a discussion about generalising the definition ...</p>\n</blockquote>\n<p>This is a bit of a judgement call. As an example for automata, we use some different definitions from Mathlib because they extend some CSLib-specific definitions. Some places we have theorems relating to the Mathlib equivalent, like <a href=\"https://api.cslib.io/docs/Cslib/Computability/Languages/RegularLanguage.html\">Cslib.Computability.Languages.RegularLanguage</a>.</p>\n<p>So in short, we try our best to avoid <em>unnecessary</em> duplication of Mathlib, but we are in general welcoming of PRs that define something with more generality than Mathlib. It sounds like this your situation, so I think we'd welcome the more general extension to symbolic alphabets, ideally with a proof connecting it to any existing Mathlib work. Does that answer your questions?</p>",
        "id": 567025577,
        "sender_full_name": "Chris Henson",
        "timestamp": 1767903571
    },
    {
        "content": "<p>I second Chris’s idea fwiw. Mathlib is a great library to depend on, but CSlib should not chain itself to Mathlib’s design decisions. If Mathlib likes our definitions then they can discuss with us about upstreaming it. There are two other factors to consider :</p>\n<ol>\n<li>Making up steaming PRs is quite a bit of extra non-lean work. </li>\n<li>CSLib should ideally be self contained for CS concepts, not just a patch on what is missing in mathlib. That will make CSLib a mess with bits and pieces here, and bits and pieces in mathlib.</li>\n</ol>",
        "id": 567060679,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1767923468
    },
    {
        "content": "<p>Thanks a lot for the helpful reply. I will think about more about how to best structure it and come back when I have something reasonably settled for a potential PR!</p>",
        "id": 567121357,
        "sender_full_name": "Kat Zhuchko",
        "timestamp": 1767957875
    }
]