[
    {
        "content": "<p>Hi, I am new to CSLib. I have been formalizing the longest common subsequence problem. Currently, I provide 3 implementations:</p>\n<ol>\n<li>recursion without dynamic programming,</li>\n<li>functional dynamic programming, and</li>\n<li>imperative dynamic programming.</li>\n</ol>\n<p>The correctness of the first 2 implementations are proved whereas I am still experimenting with mvcgen for the imperative implementation. Could I contribute this in any form to CSLib?</p>\n<p><a href=\"https://gist.github.com/kuotsanhsu/e21ec4cfb78f3b43e898ed19d55d3625\">https://gist.github.com/kuotsanhsu/e21ec4cfb78f3b43e898ed19d55d3625</a></p>",
        "id": 575165533,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1771770077
    },
    {
        "content": "<p>Hi! I don't think this exists anywhere (someone correct me if I'm wrong), so this is probably suitable with some cleaning. For 3) we've actually not discussed mvcgen proofs in CSLib yet, but I think you could start with just the first two.</p>\n<p>Have you considered also verifying the time complexity of the quadratic approach? There's some ongoing discussion of generalizing it, but at the moment we have <a href=\"https://api.cslib.io/docs/Cslib/Algorithms/Lean/TimeM.html\">TimeM</a> for expressing this.</p>",
        "id": 575168245,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771772822
    },
    {
        "content": "<p>You could also make the PR to <a href=\"https://github.com/leanprover/cslib/pull/275\">cslib#275</a> ‘s prog approach.</p>",
        "id": 575168866,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771773501
    },
    {
        "content": "<p>Thanks for the pointers. I'll attempt TimeM for implementation 2 following <a href=\"https://github.com/leanprover/cslib/pull/275\">cslib#275</a>.</p>",
        "id": 575169083,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1771773770
    },
    {
        "content": "<p>Please do not feel that you have to wait if you'd like to try out the existing <code>TimeM</code> in the meantime. If it is superseded by <a href=\"https://github.com/leanprover/cslib/pull/275\">cslib#275</a>, we can handle porting over any proofs.</p>",
        "id": 575169318,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771774037
    },
    {
        "content": "<p>Ok, I'll try out TimeM directly, but I would need some time to get familiar with it.</p>",
        "id": 575170017,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1771774655
    },
    {
        "content": "<p>If you are targeting <a href=\"https://github.com/leanprover/cslib/pull/275\">cslib#275</a>, I think you want two constructors in your query type. One reads a list (the input list or dp table) at an index. The other writes a value at an index to a list (which will be the dp table).  <del>your choice of query type becomes easier if you declare a “DataStructure” type that contains the input array and the dp array.</del> actually let’s just use queries that take lists or arrays as input and outputs as required. Just having an  RwCollection query type for a given ‘Collection’ would be nicer</p>",
        "id": 575170104,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771774715
    },
    {
        "content": "<p>And you can reuse your existing proofs for correctness by proving that the Prog version evaluates to your version. On all inputs.</p>",
        "id": 575170161,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771774775
    },
    {
        "content": "<p>Glad to assist as much as I can (since I have a bit of travel coming up)</p>",
        "id": 575170196,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771774803
    },
    {
        "content": "<p>Thank you so much for the instructions. I'll try to make a PR even if I hit a wall so that I can call for help.</p>",
        "id": 575170359,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1771774980
    },
    {
        "content": "<p>Hi Gordon, if you want to use TimeM, the simplest approach is to write an algorithm in functional code, and then you can use TimeM almost immediately without change.</p>",
        "id": 575751852,
        "sender_full_name": "Sorrachai Yingchareonthawornchai",
        "timestamp": 1772018999
    },
    {
        "content": "<p>This also goes for Prog. There is a little bit more overhead, because you actually have to commit to a model and costs of each query  in advance, but essentially after that the Prog will look identical to the functional version. </p>\n<p>You just have to replace List.get and set with their query versions. Also the query you define will be usable for many array based algorithms. Future algorithms authors will just use the model you define instead of writing their own.</p>",
        "id": 575757327,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772020878
    },
    {
        "content": "<p>Fwiw you might get the TimeM version for free from the Prog version. For timing Prog compiles to TimeM.</p>",
        "id": 575758600,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772021288
    },
    {
        "content": "<p>At any rate, since the approaches are similar it is fine to use TimeM now, and then switch to Prog later</p>",
        "id": 575830742,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772040319
    },
    {
        "content": "<p>I have proven time complexity with <code>TimeM</code>, but <code>TimeM</code> messed up my other two lemmas which relied on the definitional equality of <code>List.foldr</code>. Reviewers can start giving feedback while I keep working on the lemmas.</p>\n<p><a href=\"https://github.com/leanprover/cslib/pull/370\">https://github.com/leanprover/cslib/pull/370</a></p>",
        "id": 575855460,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772048252
    },
    {
        "content": "<p>I think this PR could do with a lot simplification. You could directly create a 2D table DP table by <code>DP : a -&gt; a -&gt; b</code> instead of doing things in a roundabout fashion with DP and DPS.</p>",
        "id": 575937971,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772085316
    },
    {
        "content": "<p>Secondly that long proof in the middle could be drastically shorter with fun_induction, simp and/or grind.</p>",
        "id": 575939650,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772086141
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Longest.20Common.20Subsequence/near/575937971\">said</a>:</p>\n<blockquote>\n<p>I think this PR could do with a lot simplification. You could directly create a 2D table DP table by <code>DP : a -&gt; a -&gt; b</code> instead of doing things in a roundabout fashion with DP and DPS.</p>\n</blockquote>\n<p>Don't worry, your original wording is spot on. I share the same sentiment. I doubted my sanity when my first version looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">lcs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">dps</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DP</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">default</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">yy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DP</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">default</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">xy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DP</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">default</span>\n<span class=\"w\">    </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">xx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">dps</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n<span class=\"w\">      </span><span class=\"n\">yy</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">dp</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">xx</span><span class=\"w\"> </span><span class=\"n\">yy</span><span class=\"w\"> </span><span class=\"n\">xy</span>\n<span class=\"w\">      </span><span class=\"n\">dps</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">dps</span><span class=\"bp\">.</span><span class=\"n\">set!</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">yy</span>\n<span class=\"w\">      </span><span class=\"n\">xy</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">xx</span>\n<span class=\"w\">      </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">dps</span><span class=\"bp\">.</span><span class=\"n\">back!</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">dp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xx</span><span class=\"w\"> </span><span class=\"n\">yy</span><span class=\"w\"> </span><span class=\"n\">xy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DP</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DP</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xy</span><span class=\"bp\">.</span><span class=\"n\">lcs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">xy</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">xy</span><span class=\"bp\">.</span><span class=\"n\">length_eq</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">xx</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">yy</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">xx</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">yy</span>\n</code></pre></div>",
        "id": 575987979,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772102036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Longest.20Common.20Subsequence/near/575939650\">said</a>:</p>\n<blockquote>\n<p>Secondly that long proof in the middle could be drastically shorter with fun_induction, simp and/or grind.</p>\n</blockquote>\n<p>It could be shorter if I don't annotate the types of the local variables/proofs and hide the structure of the proof behind tactics. However, wouldn't you find it more readable this way: the context is directly visible in the code instead of needing to hook up the infoView panel in VSCode. Anyway, I think the point is mute, people like tactics. I can rewrite it.</p>",
        "id": 575989395,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772102407
    },
    {
        "content": "<p>Could you elaborate on the 2D table approach? Immutability leads to construction of lists. The visiting order is the key part of the proof but with <code>foldr</code> it's free. How do you index the table? How do you zip (as in visiting two list simultaneously) the DP table and one of the input lists without incurring the cloning of both for each iteration? How do you index both the DP table and one of the input lists without tricky proofs on the index (<code>foldr</code> is easier to reason)?</p>\n<p>2D table was my first thought, as it is much closer to my original imperative implementation. However, when I tried to attempt an mvcgen proof, I realized how tricky it is with all the indices needing to be in bound, and the prefix of the DP array needing to satisfy certain lengthy property. The proof would be  DPS plus index consistency.</p>\n<p>Nevertheless, I would like to see a 2D table approach. I just couldn't think of one that is less convoluted than with <code>foldr</code> and DPS.</p>",
        "id": 575992109,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772103179
    },
    {
        "content": "<p>So let’s start with the most important thing. Apologies for the wording.</p>",
        "id": 575993156,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772103449
    },
    {
        "content": "<p>I will fix the stylistic issues brought up by Eric Wieser, move the unit tests to CSLibTest as Shreyas Srinivas, and close the <code>sorry</code> in the two lemmas.</p>",
        "id": 575993194,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772103459
    },
    {
        "content": "<p>Secondly I actually find this version you posted above better</p>",
        "id": 575993249,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772103477
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Longest.20Common.20Subsequence/near/575993156\">said</a>:</p>\n<blockquote>\n<p>So let’s start with the most important thing. Apologies for the wording.</p>\n</blockquote>\n<p>No need to apologize, I feel the same way.</p>",
        "id": 575993252,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772103478
    },
    {
        "content": "<p>Thirdly I would probably start by getting rid of DPS</p>",
        "id": 575993305,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772103492
    },
    {
        "content": "<p>You don’t actually need the list length to be carried along inside a structure.</p>",
        "id": 575993435,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772103529
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Longest.20Common.20Subsequence/near/575993249\">said</a>:</p>\n<blockquote>\n<p>Secondly I actually find this version you posted above better</p>\n</blockquote>\n<p>I find it harder to prove than with <code>foldr</code> and <code>DPS</code>. Please see my original attempt without <code>TimeM</code>: <a href=\"https://gist.github.com/kuotsanhsu/e21ec4cfb78f3b43e898ed19d55d3625\">https://gist.github.com/kuotsanhsu/e21ec4cfb78f3b43e898ed19d55d3625</a></p>",
        "id": 575993535,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772103557
    },
    {
        "content": "<p>Thirdly. I understand you find your current proof readable. </p>\n<ol>\n<li>But this is a library. It needs to have compact proofs. </li>\n<li>Even from a readability perspective a long proof is unreadable</li>\n</ol>",
        "id": 575993675,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772103605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Longest.20Common.20Subsequence/near/575993305\">said</a>:</p>\n<blockquote>\n<p>Thirdly I would probably start by getting rid of DPS</p>\n</blockquote>\n<p>Isn't the caching of LCS length the key to DP? Lengths have to be cached in the supposedly 2D table, or 1D array with 2 more trackers in the mutable case.</p>",
        "id": 575993684,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772103607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Longest.20Common.20Subsequence/near/575993675\">said</a>:</p>\n<blockquote>\n<p>Thirdly. I understand you find your current proof readable. </p>\n<ol>\n<li>But this is a library. It needs to be produce compact proofs. </li>\n<li>Even from a readability perspective a long proof is unreadable</li>\n</ol>\n</blockquote>\n<p>Ok, I'll refactor with tactics.</p>",
        "id": 575993815,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772103630
    },
    {
        "content": "<p>About that. I had this funny idea that in functional languages, a top down memoizing dp is easier to write. But more importantly I think with a clever bit of metaprogramming we can get automatic memoization for any divide and conquer recursion.</p>",
        "id": 575994047,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772103707
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Longest.20Common.20Subsequence/near/575994047\">said</a>:</p>\n<blockquote>\n<p>About that. I had this funny idea that in functional languages, a top down memoizing dp is easier to write. But more importantly I think with a clever bit of metaprogramming we can get automatic memoization for any divide and conquer recursion.</p>\n</blockquote>\n<p>Indeed, but we currently don't have that. It would be a good case for future refactoring if such a feature comes about.</p>",
        "id": 575994231,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772103776
    },
    {
        "content": "<p>You could actually repurpose your DP structure to hold a 2D Finvec(Matrix in mathlib)/list/array</p>",
        "id": 575994311,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772103802
    },
    {
        "content": "<p>And hold the current indices upto which they are filled.</p>",
        "id": 575994348,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772103812
    },
    {
        "content": "<p>Instead of list length</p>",
        "id": 575994364,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772103818
    },
    {
        "content": "<p>And then every update takes this state and the next index from the inputs to produce a new state.</p>",
        "id": 575994461,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772103846
    },
    {
        "content": "<p>What about immutability?</p>",
        "id": 575994511,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772103857
    },
    {
        "content": "<p>I am not worrying myself about mvcgen for now</p>",
        "id": 575994584,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772103880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Longest.20Common.20Subsequence/near/575994047\">said</a>:</p>\n<blockquote>\n<p>About that. I had this funny idea that in functional languages, a top down memoizing dp is easier to write. But more importantly I think with a clever bit of metaprogramming we can get automatic memoization for any divide and conquer recursion.</p>\n</blockquote>\n<p>If we have good memoization facility, <code>lcsBrute</code> would work directly by adding an attribute.</p>",
        "id": 575994653,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772103908
    },
    {
        "content": "<p>I am trying to focus on the question: how can we get a clean functional programming version of lcs</p>",
        "id": 575994661,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772103909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"468690\">Gordon Hsu</span> <a href=\"#narrow/channel/513188-CSLib/topic/Longest.20Common.20Subsequence/near/575994653\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Longest.20Common.20Subsequence/near/575994047\">said</a>:</p>\n<blockquote>\n<p>About that. I had this funny idea that in functional languages, a top down memoizing dp is easier to write. But more importantly I think with a clever bit of metaprogramming we can get automatic memoization for any divide and conquer recursion.</p>\n</blockquote>\n<p>If we have good memoization facility, <code>lcsBrute</code> would work directly by adding an attribute.</p>\n</blockquote>\n<p>There is something called MonadCache</p>",
        "id": 575994715,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772103928
    },
    {
        "content": "<p>But let’s leave it to one side for now.</p>",
        "id": 575994754,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772103941
    },
    {
        "content": "<p>Let’s first make the lcs functional version simple and familiar</p>",
        "id": 575994832,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772103969
    },
    {
        "content": "<p>I would still like to keep DP. The only concern is DPS.</p>",
        "id": 575994957,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772104010
    },
    {
        "content": "<p>I am not a machine so I can’t give you good arguments against it. So I will skip to my second point.</p>",
        "id": 575995519,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772104185
    },
    {
        "content": "<p>But if you think about it, DPS serves the same role as the 1d vector with 2 extra trackers.</p>",
        "id": 575995523,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772104186
    },
    {
        "content": "<p>Take the internal auxiliary lemmas and bring them out. Give them proper names</p>",
        "id": 575995581,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772104205
    },
    {
        "content": "<p>Prove the lcs invariant and prove correct initialisation</p>",
        "id": 575995739,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772104260
    },
    {
        "content": "<p>Could you sketch with some pseudocode?</p>",
        "id": 575995894,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772104312
    },
    {
        "content": "<p>Say if we are not concerned with cloning, zipping <code>ys</code> and <code>List (DP α)</code> would be cleaner.</p>",
        "id": 575996794,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772104601
    },
    {
        "content": "<p>Just right now I can’t. I’m on a train in the middle of nowhere</p>",
        "id": 575996821,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772104613
    },
    {
        "content": "<p>No problem. I'll make a new attempt.</p>",
        "id": 575996980,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772104663
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"468690\">Gordon Hsu</span> <a href=\"#narrow/channel/513188-CSLib/topic/Longest.20Common.20Subsequence/near/575995523\">said</a>:</p>\n<blockquote>\n<p>But if you think about it, DPS serves the same role as the 1d vector with 2 extra trackers.</p>\n</blockquote>\n<p>Correction, DPS is just to avoid passing <code>ys</code> and cloning for each zip which reduces clarity.</p>",
        "id": 575997988,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772104997
    },
    {
        "content": "<p>As for “2D tables” check mathlib matrices</p>",
        "id": 576001500,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772106210
    },
    {
        "content": "<p>I've proved things using matrices before, but how do they perform with regard to indexing and updating? Would updating every element of a matrix lead to <code>m*n</code> deep <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Logic/Function/Basic.html#Function.update\">Function.update</a>? Why not just list of lists by <code>foldr</code>?</p>",
        "id": 576005247,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772107431
    },
    {
        "content": "<p>Let’s ignore actual performance for now please.</p>",
        "id": 576006201,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772107777
    },
    {
        "content": "<p>Let’s simplify first, prove stuff, and then optimise step by step.</p>",
        "id": 576006593,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772107908
    },
    {
        "content": "<p>Ok, I'll do the following:</p>\n<ol>\n<li>Use tactics to shorten proofs.</li>\n<li>Replace DPS with zipping, but keep list of list.</li>\n<li>Third implementation using matrix.</li>\n</ol>",
        "id": 576006724,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772107956
    },
    {
        "content": "<p>Matrix is just a function on two index variables. This is the structure you want to use</p>",
        "id": 576006895,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772108009
    },
    {
        "content": "<p>I've tried proving stuff with indexing. I doubt it will be cleaner, but I'll nevertheless see for myself.</p>",
        "id": 576007108,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772108083
    },
    {
        "content": "<p>I will be away for a few days. I hope someone can step in and help you if I can’t.</p>",
        "id": 576016198,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1772110797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Longest.20Common.20Subsequence/near/576016198\">said</a>:</p>\n<blockquote>\n<p>I will be away for a few days. I hope someone can step in and help you if I can’t.</p>\n</blockquote>\n<p>Thanks for your input. Have a good time. I think a suitable recursion could serve as building a matrix without the indexing nor <code>foldr</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- List with cached length. -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DP</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">lcs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">length_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">lcs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">length</span>\n\n<span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DP</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n\n<span class=\"sd\">/-- Core decision of LCS dynamic programming that is considered *one tick*. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">macro_inline</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">core</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xx</span><span class=\"w\"> </span><span class=\"n\">yy</span><span class=\"w\"> </span><span class=\"n\">xy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DP</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DP</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xy</span><span class=\"bp\">.</span><span class=\"n\">lcs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">xy</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">xy</span><span class=\"bp\">.</span><span class=\"n\">length_eq</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">xx</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">yy</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">xx</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">yy</span>\n\n<span class=\"sd\">/-- Dynamic programming taking quadratic time and quadratic space via table-like recursion. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">lcsDP</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TimeM</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">outerLoop</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">lcs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">lcs</span>\n<span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Iterate through all rows of the DP table, keeping just the last row. -/</span>\n<span class=\"w\">  </span><span class=\"n\">outerLoop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TimeM</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DP</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">default</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">dps</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">outerLoop</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dps</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">innerLoop</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">zip</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"n\">dps</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">dps</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Grow the row of the DP table for `x` by one `y` at a time. -/</span>\n<span class=\"w\">  </span><span class=\"n\">innerLoop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">DP</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">TimeM</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DP</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">DP</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">DP</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">([],</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">xx</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dps</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">yy</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">xy</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">innerLoop</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">rest</span>\n<span class=\"w\">      </span><span class=\"bp\">✓</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">dp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">core</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">xx</span><span class=\"w\"> </span><span class=\"n\">yy</span><span class=\"w\"> </span><span class=\"n\">xy</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dp</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">dps</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">xx</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 576079002,
        "sender_full_name": "Gordon Hsu",
        "timestamp": 1772125720
    }
]