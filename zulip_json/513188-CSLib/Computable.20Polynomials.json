[
    {
        "content": "<p>I have been working on implementation of Turing machines with composition in <a href=\"https://github.com/leanprover-community/CSLib/pull/269\">CSLib#269</a>. I noticed that I was asked to make some of my definitions <code>noncomputable</code> due to the underlying noncomputability of Mathlib's <code>Polynomial</code> type, which has been discussed on this zulip many times before. I'm also aware that some libraries of noncomputable polynomials have been implemented, for example <a href=\"https://github.com/NethermindEth/CompPoly/\">this</a> one. Perhaps computability will be more important to a computer science library than a math library. Should CSLib attempt to use a computable polynomial implementation in view of this?</p>",
        "id": 568700528,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1768778182
    },
    {
        "content": "<p>Where do polynomials enter the picture in TM composition? Also are you extending Mathlib defs of Turing Machines?</p>",
        "id": 568707149,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768785074
    },
    {
        "content": "<p>Why does it matter if some of your definitions are <code>noncomputable</code>?</p>",
        "id": 568713879,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1768792094
    },
    {
        "content": "<blockquote>\n<p>Where do polynomials enter the picture in TM composition? </p>\n</blockquote>\n<p>They don't enter into Turing machine composition itself (I guess I should have been more clear about this) but the PR also includes a proof that compositions of polynomial time Turing machines are polynomial time, and that is the point at which <code>Polynomial</code> enters.</p>\n<blockquote>\n<p>Also are you extending Mathlib defs of Turing Machines?</p>\n</blockquote>\n<p>In this case, I have not been extending the Mathlib defs of Turing machines because in various ways, I have found them hard to work with / I have a view to generalizing them in a finer-grained ways that seem incompatible with using a lot of the data structures as written.</p>\n<blockquote>\n<p>Why does it matter if some of your definitions are <code>noncomputable</code>?</p>\n</blockquote>\n<p>Well, I guess I am asking if it does. Mathlib has gotten a long way without being very concerned about code generation, but it strikes me that a computer science library might have more reason to be concerned about this for the reason that it is perhaps more integrated with uses of computers that produce runnable code. Given that CSLib is still relatively new, I am wondering if it is a good idea to try to keep code computable as much as possible in anticipation of this, or if the people interested in CSLib feel it would be best to not worry about it.</p>",
        "id": 568715491,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1768793834
    },
    {
        "content": "<p>Unless you are generating code from the polynomials themselves, I really don't see why you should care about whether the polynomials are \"computable\".  Even if you are generating code from the Turing machines, I don't see why any complexity results about the TMs proved using \"noncomputable\" polynomials would be any less valid simple because the polynomials are \"noncomputable\".</p>",
        "id": 568730288,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1768805167
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/channel/513188-CSLib/topic/Computable.20Polynomials/near/568715491\">said</a>:</p>\n<blockquote>\n<p>it strikes me that a computer science library might have more reason to be concerned about this for the reason that it is perhaps more integrated with uses of computers that produce runnable code.</p>\n</blockquote>\n<p>I'm generally in favor of computable polynomials (specifically <code>MvPolynomial</code>), but this reminds me of a famous quote:</p>\n<blockquote>\n<p><em>Computer science is no more about computers than astronomy is about telescopes.</em>  ~ Edsger Dijkstra</p>\n</blockquote>",
        "id": 568801100,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768829296
    },
    {
        "content": "<p>Also I think Mathlib would be more intersted in computable polynomials than CSLib; they're great for algorithms in symbolic maths, e.g. finding a minimal polynomial of an expression using a Gröbner basis.</p>",
        "id": 568801647,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768829458
    },
    {
        "content": "<p>I don’t think mathlib cares about computing with computable polynomials. Why reinvent CAS in lean for practical use, when existing CAS tools already do the job better</p>",
        "id": 568803141,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768829892
    },
    {
        "content": "<p>They might want computable polynomials if there are mathematical use cases for them</p>",
        "id": 568803246,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768829918
    },
    {
        "content": "<p>I disagree that CAS tools are fine as-is. I believe Mathlib should subsume CAS.<br>\nBut whether you agree doesn't change the claim that Mathlib is more suited to want them, precisely because of this. I'm not the only one that wants CAS; <a class=\"stream\" data-stream-id=\"482893\" href=\"/#narrow/channel/482893-Computer-algebra\">#Computer algebra</a></p>",
        "id": 568804220,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768830206
    },
    {
        "content": "<p>We are working on computable polynomials in Lean! <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> <a href=\"https://github.com/Verified-zkEVM/CompPoly\">https://github.com/Verified-zkEVM/CompPoly</a> our use case is for zkVMs but feel free to reach out, the idea is to have a computable version of the mathlib polynomials. this is a successor to the repo you pointed to <span class=\"user-mention\" data-user-id=\"282271\">@Bolton Bailey</span></p>",
        "id": 568805833,
        "sender_full_name": "Derek Sorensen",
        "timestamp": 1768830617
    },
    {
        "content": "<p>Verifying CAS is definitely interesting. But there is the gap between algorithms that are easy to verify and algorithms which are efficient</p>",
        "id": 568805843,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768830619
    },
    {
        "content": "<p>Our medium-term goal has been to propose an upstream to CSLib once this is in good shape</p>",
        "id": 568806126,
        "sender_full_name": "Derek Sorensen",
        "timestamp": 1768830695
    },
    {
        "content": "<p>we have basic definitions of uni- and multivariate polynomials rn but still have some way to go to get the typeclasses right, ring isomorphisms, and some efficient implementations of e.g. interpolation, FFT/NTT, etc etc</p>",
        "id": 568806280,
        "sender_full_name": "Derek Sorensen",
        "timestamp": 1768830734
    },
    {
        "content": "<p>contributions are welcome!!</p>",
        "id": 568806300,
        "sender_full_name": "Derek Sorensen",
        "timestamp": 1768830740
    },
    {
        "content": "<p>(by \"our\" I mean the Ethereum Foundation btw)</p>",
        "id": 568806326,
        "sender_full_name": "Derek Sorensen",
        "timestamp": 1768830749
    },
    {
        "content": "<p>Oh hi Derek nice to meet you here after all these years. What representation do you use?</p>",
        "id": 568807162,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768830955
    },
    {
        "content": "<p>Re: mathlib, I believe if one digs through the zulip archives there have been past discussions about computable polynomials and why we shouldn't expect them to show up in mathlib (unless something changes...), which I think is fine, but I definitely think CSLib should aim to be computable wherever possible, if only by introducing lemmas showing equivalence between a noncomputable object with a computable one (as was done in CompPoly to related computable polynomials to the those of mathlib and their associated theory).</p>",
        "id": 568807382,
        "sender_full_name": "Alexander Hicks",
        "timestamp": 1768831011
    },
    {
        "content": "<p>Large parts of CS don't care about computability either (See Leo's talk at last year's CAV keynote)</p>",
        "id": 568807508,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768831047
    },
    {
        "content": "<p>Likewise <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> ! <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> It's been a while! For univariate polynomials it's a dense coefficient array; for multivariate, a sparse map from monomials to coefficients</p>",
        "id": 568807619,
        "sender_full_name": "Derek Sorensen",
        "timestamp": 1768831080
    },
    {
        "content": "<p>certainly for our use case (formal verification of production cryptographic protocols) computability is a huge win</p>",
        "id": 568808045,
        "sender_full_name": "Derek Sorensen",
        "timestamp": 1768831186
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/Computable.20Polynomials/near/568807508\">said</a>:</p>\n<blockquote>\n<p>Large parts of CS don't care about computability either (See Leo's talk at last year's CAV keynote)</p>\n</blockquote>\n<p>Which is why I think it's fine for a theory to be developed around noncomputable definitions and to then have translation lemmas to a computable representation. The fact that computability is not striclty necessary for some people should not be a blocker to the library being useful to the subset of people for whom it is, or an agreement needs to be made about having another general purpose computable library so that we avoid having many people maintaining thigns with limited time; I believe there are already several other computable polynomial libraries, for example, but don't know what their exact status is.</p>",
        "id": 568808313,
        "sender_full_name": "Alexander Hicks",
        "timestamp": 1768831245
    },
    {
        "content": "<p>speaking of cryptographic protocols, has anyone worked on embedding Tamarin into lean? I had a chat with Cas a while ago and he mentioned that there's an intermediate tool whose translation would take a lot of effort but might not get done in academia for \"academia\" reasons</p>",
        "id": 568808455,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768831281
    },
    {
        "content": "<p>Not afaik, maybe this will come up at HACS later this year as I believe he'll attend, but I don't know who would be interested in working on this.</p>",
        "id": 568808664,
        "sender_full_name": "Alexander Hicks",
        "timestamp": 1768831335
    },
    {
        "content": "<p>Cas is clear that he is not willing to get someone working on this. It doesn't produce work that can be published in a meaningful timeframe (especially since it would be re-implementing some existing haskell code in lean)</p>",
        "id": 568811454,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768832039
    },
    {
        "content": "<p>It will have to come from the industry, if I understand his reasoning correctly.</p>",
        "id": 568811516,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1768832056
    },
    {
        "content": "<p>My interpretation of the philosophy of CSLib is that we try to reuse Mathlib infrastructure as much as possible, but are open to well motivated deviations. At least one of these cases is already made for computability reasons. The idea of computable polynomials has emerged several times and seems to already have a concrete use case here, so I would personally be open to upstreaming as <span class=\"user-mention\" data-user-id=\"562377\">@Derek Sorensen</span> suggests.</p>",
        "id": 568819460,
        "sender_full_name": "Chris Henson",
        "timestamp": 1768834113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690355\">Alexander Hicks</span> <a href=\"#narrow/channel/513188-CSLib/topic/Computable.20Polynomials/near/568807382\">said</a>:</p>\n<blockquote>\n<p>Re: mathlib, I believe if one digs through the zulip archives there have been past discussions about computable polynomials and why we shouldn't expect them to show up in mathlib (unless something changes...),</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> is making progress on an independently useful refactor that will unblock further work to make polynomial computable; but that likely doesn't mean 'computable with the performance characteristics you want\"</p>",
        "id": 568935000,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768879604
    },
    {
        "content": "<p>Yes I agree with Eric that it is worth distinguishing between \"computable polynomials\" and \"performant polynomials\".</p>",
        "id": 569077657,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768927333
    },
    {
        "content": "<p>Though the work that <span class=\"user-mention\" data-user-id=\"562377\">@Derek Sorensen</span> mentions is certainly great stuff.</p>",
        "id": 569077744,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768927353
    },
    {
        "content": "<p>That said - <span class=\"user-mention\" data-user-id=\"562377\">@Derek Sorensen</span>, may I ask, why did you decide to have CPolynomial be a wrapper around Array, rather than, say, using a sigma type or a dependent structure (or even a quotient if you want to get fancy) to ensure it was a minimal such polynomial?</p>",
        "id": 569078212,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768927465
    },
    {
        "content": "<p>Ah I see this is CPolynomialC, essentially.</p>",
        "id": 569079059,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768927681
    },
    {
        "content": "<p>yeah there is discussion internally on what should be the \"canonical\" polynomial representation - either raw arrays or these canonical arrays (a subtype). ultimately, the motivation for this library is to make performant specs. so, our priority has been to use data structures that map fairly straightforward onto how one might find them in the wild, in code to be verified</p>",
        "id": 569079422,
        "sender_full_name": "Derek Sorensen",
        "timestamp": 1768927771
    },
    {
        "content": "<p>That makes sense. I personally favour the latter - I have in a personal repository an implementation of finite permutations where there's a similar sort of problem.</p>",
        "id": 569079606,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768927821
    },
    {
        "content": "<p>right, that's good to know! it's a soft TODO to make that change. depending on the ergonomics of using CompPoly as specs for production code we will adapt, but you're adding to the argument of making the canonical polynomials the trimmed/subtype</p>",
        "id": 569079787,
        "sender_full_name": "Derek Sorensen",
        "timestamp": 1768927876
    },
    {
        "content": "<p>Actually what I do there is start with <code>PermOf n</code>, the permutation of size <code>n</code> (which might fix n, so really you can view is as permutations that permute <em>up to</em> n points - analogous to polynomials of up to n degrees). It is convenient to have this, and then you can define some function which calculates the minimum size of a permutation (what is the largest non-fixed point) and the permutation of type <code>PermOf (a.minSize)</code>. And then that is a natural thing to build into a little structure.</p>",
        "id": 569079999,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768927931
    },
    {
        "content": "<p>do you have a link you'd be willing to share? <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> would be interested in having a look</p>",
        "id": 569080143,
        "sender_full_name": "Derek Sorensen",
        "timestamp": 1768927970
    },
    {
        "content": "<p>I'm trying to find the right balance between \"computable\" (and beautiful, theoretically), and \"performant.\" I'm guessing that will result in multiple implementations with ring isomorphisms between them (that's the plan, at least)</p>",
        "id": 569080187,
        "sender_full_name": "Derek Sorensen",
        "timestamp": 1768927982
    },
    {
        "content": "<p><a href=\"https://github.com/linesthatinterlace/controlbits/tree/master/CBConcrete/CBConcrete/PermOf\">https://github.com/linesthatinterlace/controlbits/tree/master/CBConcrete/CBConcrete/PermOf</a></p>",
        "id": 569080206,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768927986
    },
    {
        "content": "<p>Here we go</p>",
        "id": 569080215,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768927990
    },
    {
        "content": "<p><code>MonoidHom.lean</code> is the file where I construct the finite thingy.</p>",
        "id": 569080328,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768928017
    },
    {
        "content": "<p>You have obviously a set of injections upwards (for polynomials of degree &lt;= n and permutations of n elements respectively) and essentially the goal is to take the direct limit.</p>",
        "id": 569080515,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768928061
    },
    {
        "content": "<p>I believe that is what it is called - Mathlib does have an implementation of the direct limit but it certainly isn't performant.</p>",
        "id": 569080597,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768928086
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"562377\">Derek Sorensen</span> <a href=\"#narrow/channel/513188-CSLib/topic/Computable.20Polynomials/near/569080187\">said</a>:</p>\n<blockquote>\n<p>I'm trying to find the right balance between \"computable\" (and beautiful, theoretically), and \"performant.\" I'm guessing that will result in multiple implementations with ring isomorphisms between them (that's the plan, at least)</p>\n</blockquote>\n<p>Yes, indeed it may be the case that you end up with multiple ones along this path.</p>",
        "id": 569080717,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768928114
    },
    {
        "content": "<p>Obviously Equiv.Perm (Fin n) exists but you know it's nice to think we could get better performance using arrays (also it is sort of hard to computably construct finite permutations that way...)</p>",
        "id": 569081060,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768928199
    },
    {
        "content": "<p>Anyway I am trying to pay attention to your work with interest.</p>",
        "id": 569081125,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768928213
    },
    {
        "content": "<p>Was good to chat to Alex and Bolton about it last year at HACS.</p>",
        "id": 569081204,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1768928233
    },
    {
        "content": "<p>yeah, this is great feedback <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> aiming to have CompPoly in a reasonably good state before HACS this year, will report as we get more mature on the project!</p>",
        "id": 569081411,
        "sender_full_name": "Derek Sorensen",
        "timestamp": 1768928295
    },
    {
        "content": "<p>I guess one thing to add regarding computable polynomials and computable v efficient is that, at least for our use cases, we'll happily rely on domain specific compilers that have many optimisations built-in (e.g. <a href=\"https://github.com/fractalyze/prime-ir\">https://github.com/fractalyze/prime-ir</a>) which let's us focus on implementing a simpler theory of computable polynomials (and associated algorithms) whilst leaving the performance engineering to the compiler and, if required, verifying the compiler via Lean-MLIR or rewriting it in Lean. Then  the question becomes what do we want to have in the high level source code, what are we leaving to the compiler, and how to co-develop both effectively.</p>",
        "id": 571039069,
        "sender_full_name": "Alexander Hicks",
        "timestamp": 1769782270
    }
]