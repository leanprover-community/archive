[
    {
        "content": "<p>I am trying to formalize strong normalization for lambda calculus right now, I found the <code>Acc</code> type, is there an inverse of this type, so that <code>Acc R t</code> holds if there are now infinite seqences <code>t R x R y ...</code> ?</p>\n<p>I know I can just write <code>(Acc (Function.swap FullBeta) t)</code>, but is there something nicer?</p>",
        "id": 570956964,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769757789
    },
    {
        "content": "<p>I don't recommend doing it directly with accessibility, but if you go that route, you will notice we define <a href=\"https://api.cslib.io/docs/Cslib/Foundations/Data/Relation.html#Relation.Terminating\">Relation.Terminating</a> similarly, just using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFounded#doc\">docs#WellFounded</a> instead of directly using <code>Acc</code>. I don't believe there is a more primitive inverse like you are looking for.</p>\n<p>Usually however when proving strong normalization, you will see it characterized inductively as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Languages</span><span class=\"bp\">.</span><span class=\"n\">LambdaCalculus</span><span class=\"bp\">.</span><span class=\"n\">LocallyNameless</span><span class=\"bp\">.</span><span class=\"n\">Untyped</span><span class=\"bp\">.</span><span class=\"n\">FullBeta</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">LambdaCalculus</span><span class=\"bp\">.</span><span class=\"n\">LocallyNameless</span><span class=\"bp\">.</span><span class=\"n\">Untyped</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Term</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">SN</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sn</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">t'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">⭢</span><span class=\"n\">β</span><span class=\"bp\">ᶠ</span><span class=\"w\"> </span><span class=\"n\">t'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SN</span><span class=\"w\"> </span><span class=\"n\">t'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SN</span><span class=\"w\"> </span><span class=\"n\">t</span>\n</code></pre></div>\n<p>and you can prove that this is equivalent to the various ways of saying there are no infinite reductions. Again the locally nameless piece is a little harder to find references for, but these ideas are the same regardless of binding.</p>",
        "id": 570960863,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769759523
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 570965983,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769761307
    },
    {
        "content": "<p>I am pretty much done with the saturated sets, now I need multisubstitutions for the soundness lemma. Is there something like this already in the library? I can only see a map that substitutes a single variable, but it seems to connect to some other part of the library.</p>",
        "id": 571120874,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769805987
    },
    {
        "content": "<p>I can hack something together, I am just asking because I want to of course reuse everything available as much as possible</p>",
        "id": 571122062,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769806460
    },
    {
        "content": "<p>No, there is no definition of multiple substitution. I am somewhat surprised you need it, but I guess that depends on exactly the proof structure. Is your work so far in a branch I could look at?</p>",
        "id": 571122830,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769806751
    },
    {
        "content": "<p>Not jet, I did not push anything yet, because it is still messy:</p>\n<p>I can quickly summarize the type of proof structure I am familiar with:</p>\n<p>You write a semantic map that maps each type to a subset of strongly normalizing terms, and these sets are closed under some types of terms and operations.</p>\n<p>Then you prove soundness like this:<br>\n<a href=\"/user_uploads/3121/WeT9KgNMc8HpbXM6nm3g_9bV/image.png\">image.png</a><br>\nin this definition of soundness, <code>\\sigma </code> is a substitition, that contains finitely many variables and terms to replace them with.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/WeT9KgNMc8HpbXM6nm3g_9bV/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"849x132\" src=\"/user_uploads/thumbnail/3121/WeT9KgNMc8HpbXM6nm3g_9bV/image.png/840x560.webp\"></a></div>",
        "id": 571124033,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769807116
    },
    {
        "content": "<p>the way I always implemented this is by having a list that recursively substitutes with the ordinary subst map, but if there is something nicer I'd use that of course.</p>",
        "id": 571124216,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769807172
    },
    {
        "content": "<p>If you know/prefer a specific proof structure that avoids this, please link me a document with the proof, then I will try to formalize that instead.</p>",
        "id": 571124581,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769807259
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">multisubst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">M</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">σ'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">multisubst</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">σ'</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">satisfies_term</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">τ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">Base</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">semanticMap</span><span class=\"w\"> </span><span class=\"n\">τ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">multisubst</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">semanticMap</span><span class=\"w\"> </span><span class=\"n\">τ</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">satisfies_context</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">Base</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">τ</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">τ</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">multisubst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">fvar</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">semanticMap</span><span class=\"w\"> </span><span class=\"n\">τ</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">consequence</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">Base</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">τ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">Base</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">satisfies_context</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">satisfies_term</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">τ</span>\n</code></pre></div>\n<p>This works, I just wonder if there is something nicer/wether you like it</p>",
        "id": 571126546,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769808096
    },
    {
        "content": "<p>Oh sorry, you are right that it is needed. I would probably not recurse on the context like that, it seems easier if it is structural on the term since you just need to replace free variables?</p>",
        "id": 571130108,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769809697
    },
    {
        "content": "<p>I am not recursing on the context, the strong norm proof will essentially recurse over the typing derivation and push variables onto some accumulated <code>\\sigma</code>.  other parts of the proof will use that substitution again.</p>\n<p>But I need to build up a list of variables and terms for that somewhere.</p>",
        "id": 571130369,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769809820
    },
    {
        "content": "<p>When you said multiple substitution, I imagined something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Languages</span><span class=\"bp\">.</span><span class=\"n\">LambdaCalculus</span><span class=\"bp\">.</span><span class=\"n\">LocallyNameless</span><span class=\"bp\">.</span><span class=\"n\">Untyped</span><span class=\"bp\">.</span><span class=\"n\">FullBeta</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Languages</span><span class=\"bp\">.</span><span class=\"n\">LambdaCalculus</span><span class=\"bp\">.</span><span class=\"n\">LocallyNameless</span><span class=\"bp\">.</span><span class=\"n\">Context</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">LambdaCalculus</span><span class=\"bp\">.</span><span class=\"n\">LocallyNameless</span><span class=\"bp\">.</span><span class=\"n\">Untyped</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">multisubst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bvar</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">bvar</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fvar</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"bp\">.</span><span class=\"n\">dlookup</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fvar</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">multisubst</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">multisubst</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">multisubst</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 571132946,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769810999
    },
    {
        "content": "<p>They are free variables, so we can do this all at once, right?</p>",
        "id": 571133067,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769811058
    },
    {
        "content": "<p>(Also a small tip: try to never write <code>.subst</code> directly, always use the notation)</p>",
        "id": 571133164,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769811109
    },
    {
        "content": "<p>I think so.</p>\n<p>The lecture notes I am familiar with actually defines substiution over a map that maps variables to terms, and then that map replaces all variables with whatever it maps to, the variables not to be replaced are just mapped to itself.</p>\n<p>This is quite elegant but requires careful management of tracking wether a variable is free or not.</p>\n<p>We could replace \"subst\" with that type of substitution and then still implement the HasSubstitution typeclass with a map that only has a support of a single variable. that way it wouldn't break anything and I think it would work well with the locally nameless stuff because then you essentially just have free variables connected to that operation.</p>",
        "id": 571133731,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769811397
    },
    {
        "content": "<p>I would need to see concretely what you're proposing and that it doesn't break anything in STLC or System F. My guess is it will be delicate interacting with the locally nameless binding, but I am happy to consider a PR proving me wrong!</p>\n<p>We are planning to additionally support something like this style of substitution, closely following Autosubst, but this is a longer term project because of the metaprogramming involved.</p>",
        "id": 571136216,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769812685
    },
    {
        "content": "<p>At the moment I'll only try to produce a single file strongnorm.lean :)</p>\n<p>Did you consider nominal techniques for variable management?</p>",
        "id": 571136542,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769812849
    },
    {
        "content": "<p>By \"nominal\" , do you mean in the sense of Nominal Isabelle?</p>",
        "id": 571136991,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769813141
    },
    {
        "content": "<p>well lean doesn't have nominal stuff built in the type theory, so no, I mean by formalizing nominal sets and then formalizing all stuff that uses variables using nominal sets. I do not know if this is a practical idea though.</p>",
        "id": 571137091,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769813199
    },
    {
        "content": "<p>The direction I am headed is to define a command elaborator that looks like a usual inductive type, but is tagged with information about where binding occurs and has multiple options for what \"backend\" is used for binding. I think it is evident from prior work that this works for locally nameless and scoped indices (with the substitution you described earlier). It might be possible to have a nominal sets backend in this framework, but I have no immediate plan to do so. (This is all very early in development, so details are subject to change!)</p>",
        "id": 571138024,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769813706
    },
    {
        "content": "<p>I think formalising nominal sets would be cool, but I agree that something closer to Autosubst would be more practical for handling bindings and variables in practice</p>",
        "id": 571209783,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1769875152
    },
    {
        "content": "<p>did autosubst manage to include dependent types yet? Last I heard you could do pretty much everything in like 70 lines for System F or stuff like that but once you add dependent types it just doesn't work.</p>",
        "id": 571209905,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769875241
    },
    {
        "content": "<p>but last time I did type theory was a few years ago.</p>",
        "id": 571209933,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769875264
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> progress report on STLC strong norm:</p>\n<p>The main structure soundness lemma stands and has no sorries, there are some trivial lemmas left, like wen app t s is SN then just t is SN, but the main issue that i still need to resolve is a single variable management issue. Not sure how long that will take, if I am lucky tonight, but I can't promise anything.</p>",
        "id": 571306933,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769970966
    },
    {
        "content": "<p>Is there some lemma that says something like</p>\n<p>if x is not free in t<br>\nthen t[x:=s] = t?</p>",
        "id": 571310928,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769975108
    },
    {
        "content": "<p>I think you want <a href=\"https://api.cslib.io/docs/Cslib/Languages/LambdaCalculus/LocallyNameless/Untyped/Properties.html#Cslib.LambdaCalculus.LocallyNameless.Untyped.Term.subst_fresh\">Untyped.Term.subst_fresh</a></p>",
        "id": 571311033,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769975198
    },
    {
        "content": "<p>thanks!</p>",
        "id": 571311075,
        "sender_full_name": "David Wegmann",
        "timestamp": 1769975260
    },
    {
        "content": "<p>No problem. And in general, good to hear you're making progress!</p>",
        "id": 571311083,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769975274
    },
    {
        "content": "<p>I think I mostly resolved all variable management issues arising from the locally nameless approach.</p>\n<p>There are 7 sorries left for the entire proof, most of them are stuff like</p>\n<p>when <code>t.app s</code> is strongly normalizing, then so is just <code>t</code>. I am working on that right now.</p>",
        "id": 572421300,
        "sender_full_name": "David Wegmann",
        "timestamp": 1770396080
    },
    {
        "content": "<p>I made a lot more progress, but I am still stuck with some of the locally nameless things</p>",
        "id": 572578276,
        "sender_full_name": "David Wegmann",
        "timestamp": 1770511736
    },
    {
        "content": "<p>Maybe you could open a draft PR if it is pretty close otherwise? That would make it easier for me to take a look at the last few <code>sorry</code>.</p>",
        "id": 572578878,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770512528
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/cslib/pull/327\">https://github.com/leanprover/cslib/pull/327</a><br>\n<span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span></p>",
        "id": 572640635,
        "sender_full_name": "David Wegmann",
        "timestamp": 1770574879
    },
    {
        "content": "<p>I did open the pull request. Just a disclaimer, I have not contributed on a larger project before, so I still have to get used to style guides and all that stuff for pull requests, this is just very messy code. I planned to eliminate all the sorries before I wanted to submit anything at all.</p>\n<p>I think I identified the main issue. Even the untyped terms require to be locally closed for reductions. I have to make some adjustments to incorperate this in a few of the substition/strong_norm lemmas.</p>",
        "id": 572640829,
        "sender_full_name": "David Wegmann",
        "timestamp": 1770575072
    },
    {
        "content": "<p>Yeah, in your lemmas about operations preserving <code>SN</code> and also in <code>semanticMap</code>, you need to carry around a hypothesis/conjunction that the term is locally closed. But at a quick glance it looks like it's headed in the tight direction.</p>\n<p>Totally fine that there is work to be done style wise at this point, we want to be friendly to new contributors. I've marked it as a draft to indicate this. I will hold off on style remarks until you get these last <code>sorry</code> ironed out. Please ping me if you need any help.</p>",
        "id": 572641522,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770575835
    },
    {
        "content": "<p>I think I'll manage, I just took a lot longer to figure out some caviats of the locally nameless approach. But the intuition how general the lemmas have to be seems to carry over from pure DeBrujin.</p>",
        "id": 572641590,
        "sender_full_name": "David Wegmann",
        "timestamp": 1770575933
    },
    {
        "content": "<p>Chipping in to say hi</p>",
        "id": 572644839,
        "sender_full_name": "IntGrah",
        "timestamp": 1770579474
    },
    {
        "content": "<p>have de bruijn levels been considered instead of locally nameless syntax?</p>",
        "id": 572645155,
        "sender_full_name": "IntGrah",
        "timestamp": 1770579845
    },
    {
        "content": "<p>also, intrinsic well scopedness too<br>\nso <code>bvar : Fin n -&gt; Term n</code></p>",
        "id": 572645382,
        "sender_full_name": "IntGrah",
        "timestamp": 1770580018
    },
    {
        "content": "<p>Yes, these will appear in a future PR that I am working on already.</p>",
        "id": 572654067,
        "sender_full_name": "Chris Henson",
        "timestamp": 1770588203
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"674484\">@IntGrah</span> Thanks for contributing app_sn btw!</p>",
        "id": 572764783,
        "sender_full_name": "David Wegmann",
        "timestamp": 1770640702
    },
    {
        "content": "<p>I think I figured out the crucial requirement for the proof to work, one needs to demand that saturated sets only contain Locally closed terms. A single sorry remains in the Stlc/StrongNorm.lean file.</p>\n<p>Suppose <code>M ^ N</code> is locally closed. Does this imply that <code>M.abs</code> is locally closed? It feels true but I haven't yet found a lemma for that.</p>",
        "id": 573948152,
        "sender_full_name": "David Wegmann",
        "timestamp": 1771130894
    },
    {
        "content": "<p>Could you update your repository?</p>",
        "id": 573951296,
        "sender_full_name": "Sehun Kim",
        "timestamp": 1771134107
    },
    {
        "content": "<p>one second</p>",
        "id": 573951323,
        "sender_full_name": "David Wegmann",
        "timestamp": 1771134130
    },
    {
        "content": "<p>I pushed it to my fork: <a href=\"https://github.com/leanprover/cslib/compare/main...WegmannDavid:cslib:main\">https://github.com/leanprover/cslib/compare/main...WegmannDavid:cslib:main</a></p>",
        "id": 573951585,
        "sender_full_name": "David Wegmann",
        "timestamp": 1771134470
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"1019144\">@David Wegmann</span> That lemma seems plausible to me as well. The non-abstraction cases at least are easy.</p>\n<p>I think you are still missing some locally closed hypothesis in your <code>semanticMap</code>. I would expect the definition to be something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">semanticMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">τ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">Base</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">τ</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">base</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">SN</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">LC</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">arrow</span><span class=\"w\"> </span><span class=\"n\">τ₁</span><span class=\"w\"> </span><span class=\"n\">τ₂</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LC</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">semanticMap</span><span class=\"w\"> </span><span class=\"n\">τ₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">semanticMap</span><span class=\"w\"> </span><span class=\"n\">τ₂</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>which I think will resolve the last <code>sorry</code> in that file.</p>",
        "id": 573953647,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771136284
    },
    {
        "content": "<p>that LC hypothesis for s won't be necessary. It is obtained by the induction hypothesis. we are proving that <code>semanticMap  τ</code> is saturated by induction on <code>τ</code>. in the case of the arrow type, we must show that</p>\n<p><code>semanticMap  (τ₁ -&gt; τ₂)</code> is saturated while already assuming that <code>semantic map  τ₁</code> and <code>semanticMap τ₂</code>. all elements inside saturated sets are locally closed, so <code>s</code> will be too.</p>",
        "id": 573980057,
        "sender_full_name": "David Wegmann",
        "timestamp": 1771165331
    },
    {
        "content": "<p>also the arrow case already doesn't contain any sorries. its the base case that containes the sorry</p>",
        "id": 573980150,
        "sender_full_name": "David Wegmann",
        "timestamp": 1771165445
    },
    {
        "content": "<p>Hmm. I'll wait to think about this more carefully until the last <code>sorry</code> are filled in.</p>",
        "id": 573980690,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771165911
    },
    {
        "content": "<p>If you still have a interest in the locally closed hypothesis, the following would be helpful.</p>\n<p>In [A. Chargueraud, The Locally Nameless Representation</p>\n<p>](<a href=\"https://chargueraud.org/research/2009/ln/main.pdf\">https://chargueraud.org/research/2009/ln/main.pdf</a>), which is the primary reference of implementation, several different definitions of “locally closed” are proposed. One of them defines lc_at as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">lc_at</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">):</span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"k\">with</span>\n\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">bvar</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">&lt;</span><span class=\"n\">k</span>\n\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">fvar</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span>\n\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">lc_at</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">lc_at</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">t₂</span>\n\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">lc_at</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">t</span>\n</code></pre></div>\n<p>One can prove that lc_at 0 M  if and only if M.LC is closed and the function lc\\_at yields more useful theorems. Proving it is little tricky, the induction on the number of lambdas in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> or “depth” of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> defined by</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">depth</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"k\">with</span>\n\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">bvar</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">fvar</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">depth</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">depth</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"o\">)</span>\n\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">depth</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>is the best approach I found.</p>\n<p>Using lc_at, we can prove the theorems like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">lc_at_iff_lc_at_openRec_fvar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n\n<span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lc_at</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">lc_at</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">openRec</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fvar</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This means that M ^ fvar x is locally closed if and only if lc_at 1 M.</p>\n<p>I think the main and only case we need to consider is the case when N=fvar x, and in this case, abs M is locally closed since lc_at 1 M holds.</p>",
        "id": 573980814,
        "sender_full_name": "Sehun Kim",
        "timestamp": 1771166003
    },
    {
        "content": "<p>If you think it would be useful elsewhere, I'd be happy to review a separate PR adding this definition. It is probably best if it includes a proof that at level zero this is equivalent to our existing <code>LC</code> definition.</p>",
        "id": 573981661,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771166750
    },
    {
        "content": "<p>Actually I already made a proof.</p>",
        "id": 573981866,
        "sender_full_name": "Sehun Kim",
        "timestamp": 1771166960
    },
    {
        "content": "<p>Maybe my intuition is wrong, but what <span class=\"user-mention\" data-user-id=\"878228\">@Sehun Kim</span> proposes is maybe necessary to fill in the last sorry in my proof.</p>",
        "id": 573983150,
        "sender_full_name": "David Wegmann",
        "timestamp": 1771168101
    },
    {
        "content": "<p>my intuition for this is the following: Consider the open operation. it is not enough to define if just for replacing the 0th debrujin index, because it is recursively defined through incrementing the index to be replaced whenever one walks by an abstraction. But then proofs about such operations also require an induction hypothesis that is relative. We need a way to express that a term is \"locally closed upto the last n levels\" otherwise we cannot state such general enough induction hypotheses. I have a feeling that something like this is necessary to resolve the sorry in my file.</p>",
        "id": 573983339,
        "sender_full_name": "David Wegmann",
        "timestamp": 1771168270
    },
    {
        "content": "<p>I think there are some ways you can get around this, but I'm fine with this approach. I'd just ask that you split off what you can into smaller PRs to start with. Especially <code>lc_at</code> seems easy to do this for. This also applies to some of the lemmas in your draft PR that aren't specific to normalization.</p>",
        "id": 573983604,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771168576
    },
    {
        "content": "<p>Alright, I'll do that, but I think most of the \"not specific\" to stlc strong norm lemmas are still very specific to strong norm lemmas in general. I'll try to get everything to compile first, then I'll break it up into multiple pull requests.</p>",
        "id": 573988810,
        "sender_full_name": "David Wegmann",
        "timestamp": 1771172996
    },
    {
        "content": "<p>I have merged <span class=\"user-mention\" data-user-id=\"878228\">@Sehun Kim</span>'s <a href=\"https://github.com/leanprover/cslib/pull/336\">cslib#336</a> adding this more general version of local closure, so feel free to use it as needed for normalization.</p>",
        "id": 574054200,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771229367
    },
    {
        "content": "<p>I used it and it worked perfectly. The strong norm proof file is now sorry free: <a href=\"https://github.com/WegmannDavid/cslib/blob/main/Cslib/Languages/LambdaCalculus/LocallyNameless/Stlc/StrongNorm.lean\">https://github.com/WegmannDavid/cslib/blob/main/Cslib/Languages/LambdaCalculus/LocallyNameless/Stlc/StrongNorm.lean</a><br>\nI still have to solve some sorries in the other file, then I will break it up and implement the style guide.</p>",
        "id": 574164432,
        "sender_full_name": "David Wegmann",
        "timestamp": 1771266069
    },
    {
        "content": "<p>Having worked with debruijn indices in the past, the definition of <code>LcAt</code> from <span class=\"user-mention\" data-user-id=\"878228\">@Sehun Kim</span> feels much more natural and general enough than the current <code>LC</code> definition. If I were asked to come up with a definition for locally closedness, In retrospect I think I would have come up with exactly the same definition as <span class=\"user-mention\" data-user-id=\"878228\">@Sehun Kim</span> .</p>",
        "id": 574164728,
        "sender_full_name": "David Wegmann",
        "timestamp": 1771266208
    },
    {
        "content": "<p>Appart from my intuition, I have a specific issue with the current <code>LC</code> definition. It requires one to pick a set of variables that are excluded in the abs case. This set is not uniquely determined, which makes <code>LC</code> a structure instead of a property.</p>",
        "id": 574164891,
        "sender_full_name": "David Wegmann",
        "timestamp": 1771266301
    },
    {
        "content": "<p>If I had to make the decision, I would replace <code>LC</code> with <code>LcAt</code> in the entire development.</p>",
        "id": 574165056,
        "sender_full_name": "David Wegmann",
        "timestamp": 1771266390
    },
    {
        "content": "<p>As the original paper that <span class=\"user-mention\" data-user-id=\"878228\">@Sehun Kim</span> linked above mentions, I think there are some nice things about the inductive <code>LC</code> definition such as the induction principle it uses and that it hides the depth level which is irrelevant for most proofs. Especially in light of the other cofinite constructors, I think it is also more consistent and this is the standard way to formalize locally nameless binding.</p>\n<p>I'm not quite sure the distinction you are drawing between \"structure\" and \"property\", but it is well-understood that these sets of variables are not unique. In fact the <code>free_union</code> term elaborator that is used throughout specifically takes advantage of this fact to allow specifying free variables at a high level. While I think it is useful to also have <code>LcAt</code>, I don't think I would agree with replacing <code>LC</code> entirely as I think in practice this would come with more bookkeeping. If you are very sure to the contrary I encourage you to try it out and I would carefully consider a PR that fully ports not just simple terms but System F as well. </p>\n<p>Please also note that we are planning to support well scoped de Bruijn indices in the future which will align much more closely with what you are used to. It is not at all my intent to force all the lambda calculi modules in CSLib to use this locally nameless binding, which I agree can be a bit unintuitive. It is on my personal TODO list to port this for STLC/System F so that people have a example of either style and are free to choose for further type systems.</p>",
        "id": 574174153,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771271022
    },
    {
        "content": "<p>That sounds reasonable. I don't have a strong opinion on it as I only have the viewpoint of somebody trying to contribute a single proof. I just wanted to offer that opinion in case everybody else is indifferent about LC vs LcAt. If the specific LC definition makes multiple other things simpler and just makes the strong norm proof a bit more tedious than I suppose it is reasonable to keep it that way.</p>",
        "id": 574180941,
        "sender_full_name": "David Wegmann",
        "timestamp": 1771274505
    },
    {
        "content": "<p>About SystemF: I have done full church style debruijn SystemF with strong norm and confluence and everything. The issue that comes up without something like autosubst is that you get a horrible combinatoric explosion of lemmas that let you move substitutions/steps/liftings between different levels of terms</p>",
        "id": 574195070,
        "sender_full_name": "David Wegmann",
        "timestamp": 1771283675
    },
    {
        "content": "<p>My coq debrujin stlc development was like 500 lines at the end, including confluence and strong norm.</p>\n<p>The System F development was like 1000 lines. System F omega was 3000 lines I think.</p>",
        "id": 574195147,
        "sender_full_name": "David Wegmann",
        "timestamp": 1771283742
    },
    {
        "content": "<p>essentially every time you add another level of terms with their own substituions, you have get a quadratic increase of all the bookkeeping lemmas.</p>\n<p>If you guys really want something like that I could port it, but I am not sure how much value it would add to the library. It would just be big and complicated.</p>",
        "id": 574195258,
        "sender_full_name": "David Wegmann",
        "timestamp": 1771283823
    },
    {
        "content": "<p>Yes, I agree. This is why I am working on something analogous to Autosubst for CSLib, but this is going to take me some time.</p>",
        "id": 574195284,
        "sender_full_name": "Chris Henson",
        "timestamp": 1771283840
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> I just finished the entire proof for strong normalization, there are no more sorries left.<br>\nYou can take a look at it if you want to, but I plan on simplifying the proof code before submitting a proper pull requests<br>\n<a href=\"https://github.com/WegmannDavid/cslib/tree/main\">https://github.com/WegmannDavid/cslib/tree/main</a></p>\n<p>I was thinking about splitting the entire thing into 4 pull requests:</p>\n<ol>\n<li>Add some required lemmas into existing files like FullBeta.lean and Properties.lean (some of these reside in my StrongNorm.lean as of now)</li>\n<li>Add multiApp.lean + lemmas, operation that applies a list of argument terms to a term and lots of lemmas</li>\n<li>general Strong Norm lemmas</li>\n<li>strong norm proof for stlc.</li>\n</ol>\n<p>Sounds good?</p>",
        "id": 575934978,
        "sender_full_name": "David Wegmann",
        "timestamp": 1772083617
    },
    {
        "content": "<p>Exciting! Yes, splitting things up is always appreciated. The first two sound good, though maybe if 3+4 are not too long, it is easier to review them together?</p>",
        "id": 575935824,
        "sender_full_name": "Chris Henson",
        "timestamp": 1772084055
    },
    {
        "content": "<p>alright. I'll still take a few days to shorten the proofs, then I'll know how long these will get.</p>",
        "id": 576069919,
        "sender_full_name": "David Wegmann",
        "timestamp": 1772123521
    },
    {
        "content": "<p>Feel free to open the first of the PRs even with minimal shortening, because I'll also work on this while reviewing.</p>",
        "id": 576071924,
        "sender_full_name": "Chris Henson",
        "timestamp": 1772123999
    },
    {
        "content": "<p>At the moment I am trying to spread the whole thing over multiple files</p>\n<p>But there is an issue. Somehow, if I put multiApp into a different file called multiApp.lean, like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">module</span>\n\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Languages</span><span class=\"bp\">.</span><span class=\"n\">LambdaCalculus</span><span class=\"bp\">.</span><span class=\"n\">LocallyNameless</span><span class=\"bp\">.</span><span class=\"n\">Untyped</span><span class=\"bp\">.</span><span class=\"n\">FullBeta</span>\n\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Cslib</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasFresh</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">LambdaCalculus</span><span class=\"bp\">.</span><span class=\"n\">LocallyNameless</span><span class=\"bp\">.</span><span class=\"n\">Untyped</span><span class=\"bp\">.</span><span class=\"n\">Term</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">multiApp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\">      </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">multiApp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>I cannot rw/simp/unfold/ it any more.</p>\n<p>even explicitly writing unfold Untyped.Term.multiApp in another file doesn't work for some reason<br>\nthe term also doesn't appear to be definitionally equal to the terms it unfolds to.</p>",
        "id": 576165412,
        "sender_full_name": "David Wegmann",
        "timestamp": 1772159742
    },
    {
        "content": "<p>It looks like you are missing <code>@[expose] public section</code>. This is a recent change with the module system.</p>",
        "id": 576166108,
        "sender_full_name": "Chris Henson",
        "timestamp": 1772160287
    },
    {
        "content": "<p>Thanks, that fixed it.</p>",
        "id": 576169632,
        "sender_full_name": "David Wegmann",
        "timestamp": 1772162763
    },
    {
        "content": "<p>Could you quickly glance over this? I split the whole thing into multiple files. It's not split into multiple pull requests yet. I just want to know if you are happy with the number/theme of the files.</p>\n<p><a href=\"https://github.com/WegmannDavid/cslib/tree/main/Cslib/Languages/LambdaCalculus/LocallyNameless\">https://github.com/WegmannDavid/cslib/tree/main/Cslib/Languages/LambdaCalculus/LocallyNameless</a></p>",
        "id": 576169679,
        "sender_full_name": "David Wegmann",
        "timestamp": 1772162801
    },
    {
        "content": "<p>Is that the commit you meant to share? It has an empty file for multiple substitution and the strong normalization files seem to still have several lemmas about reduction, <code>LcAt</code>, etc. that should be moved.</p>",
        "id": 576171810,
        "sender_full_name": "Chris Henson",
        "timestamp": 1772164028
    },
    {
        "content": "<p><a href=\"https://github.com/WegmannDavid/cslib/tree/main/Cslib/Languages/LambdaCalculus/LocallyNameless\">https://github.com/WegmannDavid/cslib/tree/main/Cslib/Languages/LambdaCalculus/LocallyNameless</a></p>",
        "id": 576367279,
        "sender_full_name": "David Wegmann",
        "timestamp": 1772236219
    },
    {
        "content": "<p>try it now, I think I forgot to save the file in vscode</p>",
        "id": 576367300,
        "sender_full_name": "David Wegmann",
        "timestamp": 1772236236
    },
    {
        "content": "<p>That looks better! There are still a few lemmas in <code>Untyped/StrongNorm</code> (<code>step_subst_cong2 </code>, <code>steps_subst_cong2 </code>, <code>steps_open_cong_abs </code>, <code>lcAt_openRec_lcAt </code>, <code>open_abs_lc</code>) that seem like they don't belong there. Unless I'm missing something, those are just general properties or about reduction.</p>",
        "id": 576367839,
        "sender_full_name": "Chris Henson",
        "timestamp": 1772236717
    }
]