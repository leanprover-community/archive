[
    {
        "content": "<p>In the following code, is it possible to define <a href=\"http://DFA.prod\">DFA.prod</a> as an extension of <a href=\"http://DA.prod\">DA.prod</a> but still make it to have the type <code>DFA (State1 × State2) Symbol</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The initial state of the automaton. -/</span>\n<span class=\"w\">  </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The transition function of the automaton. -/</span>\n<span class=\"w\">  </span><span class=\"n\">tr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">State</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">da1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State1</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">da2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State2</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State1</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">State2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">da1</span><span class=\"bp\">.</span><span class=\"n\">start</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">da2</span><span class=\"bp\">.</span><span class=\"n\">start</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">tr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">da1</span><span class=\"bp\">.</span><span class=\"n\">tr</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">da2</span><span class=\"bp\">.</span><span class=\"n\">tr</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The set of accepting states of the automaton. -/</span>\n<span class=\"w\">  </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The automaton is finite-state. -/</span>\n<span class=\"w\">  </span><span class=\"n\">finite_state</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The type of symbols (also called 'alphabet') is finite. -/</span>\n<span class=\"w\">  </span><span class=\"n\">finite_symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Symbol</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dfa1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"n\">State1</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dfa2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"n\">State2</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State1</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">State2</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State1</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">State2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">dfa1</span><span class=\"bp\">.</span><span class=\"n\">toDA</span><span class=\"w\"> </span><span class=\"n\">dfa2</span><span class=\"bp\">.</span><span class=\"n\">toDA</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">start</span>\n<span class=\"w\">  </span><span class=\"n\">tr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">dfa1</span><span class=\"bp\">.</span><span class=\"n\">toDA</span><span class=\"w\"> </span><span class=\"n\">dfa2</span><span class=\"bp\">.</span><span class=\"n\">toDA</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tr</span>\n<span class=\"w\">  </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n<span class=\"w\">  </span><span class=\"n\">finite_state</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">dfa1</span><span class=\"bp\">.</span><span class=\"n\">finite_state</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">dfa2</span><span class=\"bp\">.</span><span class=\"n\">finite_state</span>\n<span class=\"w\">    </span><span class=\"n\">infer_instance</span>\n<span class=\"w\">  </span><span class=\"n\">finite_symbol</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">dfa1</span><span class=\"bp\">.</span><span class=\"n\">finite_symbol</span>\n</code></pre></div>",
        "id": 547823075,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761776971
    },
    {
        "content": "<p>I don't think I understand what you mean by \"define <code>DFA.prod</code> as an extension of <code>DA.prod</code>\". You could write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dfa1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"n\">State1</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dfa2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"n\">State2</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State1</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">State2</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State1</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">State2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">DFA</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">dfa1</span><span class=\"bp\">.</span><span class=\"n\">toDA</span><span class=\"w\"> </span><span class=\"n\">dfa2</span><span class=\"bp\">.</span><span class=\"n\">toDA</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Finite</span><span class=\"bp\">.</span><span class=\"n\">instProd</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">dfa1</span><span class=\"bp\">.</span><span class=\"n\">finite_state</span><span class=\"w\"> </span><span class=\"n\">dfa2</span><span class=\"bp\">.</span><span class=\"n\">finite_state</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dfa1</span><span class=\"bp\">.</span><span class=\"n\">finite_symbol</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>As a sidenote, those finite instances not being inferred without <code>have</code> still annoys me, does anyone know if there is a way to add an instance for <code>DFA.finite_state</code> and  <code>DFA.finite_symbol</code>?</p>",
        "id": 547830588,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761781293
    },
    {
        "content": "<p>Can you remind me why we bundle the instances? I know a lot of thought went into the definitions, I just can't recall.</p>",
        "id": 547838800,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761787673
    },
    {
        "content": "<p>Because the \"F\" in <code>DFA</code> means \"finite\".  Actually I'm going to advocate getting rid of <code>finite_symbol</code>, because it is not used in any proof and causes cslib's notion of regular languages differ from mathlib's.  In the following theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">regular_iff_cslib_dfa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">IsRegular</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">dfa</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dfa</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>the <code>[Finite Symbol]</code> assumption is there only because mathlib's <code>Language.IsRegular</code> does not assume that the alphabet is finite.</p>",
        "id": 547843187,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761791319
    },
    {
        "content": "<p>I'm not sure I made myself clear. I meant why is <code>Finite</code> a field of the structure versus being an argument to it?</p>",
        "id": 547843355,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761791469
    },
    {
        "content": "<p>If the finite-ness is an argument, then the above theorem would look something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">IsRegular</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">dfa</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dfa</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span>\n</code></pre></div>\n<p>Right?  That's actually how mathlib's DFA works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"bp\">.</span><span class=\"n\">IsRegular</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">accepts</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">L</span>\n</code></pre></div>\n<p>I'm not sure that is better.  Personally, now that I know the \"type universe hell\" I encountered in my earlier automata theory project was not caused by the state type being bundled, I would prefer bundle the state type into DA and DFA, so that we can prove something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">IsRegular</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">dfa</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dfa</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span>\n</code></pre></div>\n<p>which seems more elegant.</p>",
        "id": 547843885,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761791904
    },
    {
        "content": "<p>It is generally recommended in Mathlib (since the move to Lean 4 at least) to unbundle. It would simplify the statement of definitions like <code>DFA.prod</code> and there are performance implications of bundling. See <a href=\"https://arxiv.org/abs/2508.21593v1\">section 5.1 of this paper</a> for some discussion.</p>",
        "id": 547844726,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761792603
    },
    {
        "content": "<p>I don't have a strong view about this.  I can go either way.  The unbundled design does have the advantage of making clear which finiteness assumption is used when.  (In particular, we don't need to drag <code>finite_symbol</code> around for no real purpose.).  On the other hand, the list of assumptions or quantified variables of some theorems will become longer.  <span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> , what do you think?</p>",
        "id": 547845089,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761792966
    },
    {
        "content": "<p>I strongly advocate for unbundling. As someone who has done some category theory (one of the situations where bundling <em>is</em> required) I can attest to the pain it causes. The performance and potential awkwardness of definitions is not worth it IMO.</p>",
        "id": 547845657,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761793510
    },
    {
        "content": "<p>BTW, if we go for unbundling, we don't need DFA and NFA anymore.  We will use DA and NA instead and the notion of the language of an automaton will be applied to DA and NA and take the accepting condition as an argument.  That's actually the design I adopted in my earlier automata theory project.  Similarly, instead of EpsilonNFA, we will have EpsilonNA.</p>",
        "id": 547849426,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761797020
    },
    {
        "content": "<p>I'm open to discussing alternative designs for sure. My original comment was that it is very weird to call something <em>without</em> a finiteness assumption DFA/NFA/etc. instead of the more general DA/NA/etc.</p>\n<p>From all the discussions we've had and my own knowledge of the literature, what is much more important is categorising the acceptance conditions. These cannot really live hardcoded in DA/NA/etc.</p>",
        "id": 547887041,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761816692
    },
    {
        "content": "<p>If as the message previous suggests unbundling would preclude having seperate <code>def</code>s for DFA/NFA at all, I think the odd naming would be avoided?</p>",
        "id": 547888343,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761817046
    },
    {
        "content": "<p>Getting rid of DFA/NFA/etc. is easy, yes. The problem we had is that then we gotta figure out where to put and what to call the places defining their acceptance conditions. That's what I need a proposal for.</p>",
        "id": 547889055,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761817249
    },
    {
        "content": "<p>Take, for example, NFA and EpsilonNFA. They're essentially the same, but for the acceptance condition (which is the one given in the literature).</p>",
        "id": 547889269,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761817316
    },
    {
        "content": "<p>Is this inherently linked to the other typeclass fields being (un)bundled?</p>",
        "id": 547889941,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761817525
    },
    {
        "content": "<p>You mean the structures?</p>",
        "id": 547891126,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761817811
    },
    {
        "content": "<p>I don't think so</p>",
        "id": 547891144,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761817816
    },
    {
        "content": "<p>It's just that we need to create new terminology and abandon some well-known one from the literature, so we gotta be careful.<br>\nI'll exemplify:</p>",
        "id": 547891368,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761817884
    },
    {
        "content": "<p>Currently, 'NFA' is 'NA with (1) finiteness assumptions and (2) the expected acceptance condition for NFA'.<br>\nDropping (1) is no problem, but then it doesn't make sense to call that thing NFA (the 'F' is not there). Agreed? What should we call it then?</p>",
        "id": 547891514,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761817932
    },
    {
        "content": "<p>What we care about is putting the (2) somewhere, not the (1). The latter is very easy to unbundle and put it wherever as theorem assumptions.</p>",
        "id": 547891617,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761817961
    },
    {
        "content": "<p>Bear with me a bit as I am not so familiar with this area. I understand there are more conditions on <code>accept</code> between each structure, but to be concrete compare the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Cslib</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"n\">tr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">State</span>\n\n<span class=\"c1\">-- what we currently have</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"n\">finite_state</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"n\">finite_symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Symbol</span>\n\n<span class=\"c1\">-- an unbundled version</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DFA'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Cslib</span>\n</code></pre></div>\n<p>I am asking if the last definition is reasonable as a starting point.</p>",
        "id": 547894499,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761818817
    },
    {
        "content": "<p>Yes, it'd be an improvement, imo.</p>",
        "id": 547894818,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761818914
    },
    {
        "content": "<p>Re (2), continuing the example:</p>\n<p>Currently, this sits under <code>NFA</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- An NFA accepts a string if there is a multi-step accepting derivative with that trace from</span>\n<span class=\"sd\">the start state. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">scoped</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nfa</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NFA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">nfa</span><span class=\"bp\">.</span><span class=\"n\">start</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">nfa</span><span class=\"bp\">.</span><span class=\"n\">accept</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nfa</span><span class=\"bp\">.</span><span class=\"n\">MTr</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">s'</span>\n</code></pre></div>\n<p>but it doesn't need any of the finiteness assumptions. However, I can't put it under <code>NA</code> either, because EpsilonNFA is an NA as well, and it has a different definition of Accepts.</p>\n<p>A direct approach could be to move <code>NFA.Accepts</code> under <code>NA</code> and call it the 'canonical'/'simple' acceptance condition for NAs. Then rename <code>EpsilonNFA</code> to <code>EpsilonNA</code>, get rid of <code>εNFA</code> entirely and just rename <code>εNFA.Accepts</code> into <code>NA.εAccepts</code>.</p>",
        "id": 547896388,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761819426
    },
    {
        "content": "<p>This would cause a bit of proliferation though, because then we get <code>εLanguage</code> in addition to <code>language</code>, etc.</p>",
        "id": 547896537,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761819473
    },
    {
        "content": "<p>and then more (<code>buchiAccepts</code>, <code>buchiLanguage</code>, ...)</p>",
        "id": 547896608,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761819495
    },
    {
        "content": "<p>I think it'd be much better to:</p>\n<ul>\n<li>get rid of all the finiteness assumptions in <code>DFA</code>, <code>NFA</code> and <code>εNFA</code>, etc.</li>\n<li>rename them to something that is not DA/NA.</li>\n</ul>",
        "id": 547896967,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761819605
    },
    {
        "content": "<p><code>εNFA</code> could just be <code>εNA</code>, that's easy.<br>\n<code>DFA</code> could become ... ?<br>\n<code>NFA</code> could become ... ?</p>",
        "id": 547897169,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761819650
    },
    {
        "content": "<p>Another alternative, which I still need to figure out (any ideas? :-)), would be to make manifest the concept of 'acceptance condition' and define all of them in separate files. Then, ideally, once given a notion of acceptance condition, its associate notion of 'language' is derived automatically.</p>",
        "id": 547897415,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761819722
    },
    {
        "content": "<p>End of stream of consciousness about the design of automata theory... ;-)</p>",
        "id": 547897526,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761819758
    },
    {
        "content": "<p>Is making <code>Accept</code> a typeclass helpful at all in this? Browsing the current code, it seems we have some repeated definitions like <code>.language</code> and <code>.accepts_mem_language</code> that would be expressible in terms of this,  but I'm not familiar enough to know if this is always possible.</p>",
        "id": 547899076,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761820217
    },
    {
        "content": "<p>We'd have multiple instantiations of that typeclass for <code>NA</code>, wouldn't that be a problem?</p>",
        "id": 547905772,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761822231
    },
    {
        "content": "<p>Would you need more than one instance at a time? They could be scoped if that makes sense.</p>",
        "id": 547906206,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761822377
    },
    {
        "content": "<p>Probably? Like for the encoding from <code>εNFA</code> to <code>NFA</code>.</p>",
        "id": 547907043,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761822655
    },
    {
        "content": "<p>How would that look like?</p>",
        "id": 547908756,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761823258
    },
    {
        "content": "<p>This is rough and I left out some LTS bits, but this is the shape I had in mind:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Cslib</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"bp\">.</span><span class=\"n\">MTr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">MTr</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">stepL</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">μs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">MTr</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"w\"> </span><span class=\"n\">s3</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">MTr</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">μs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s3</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n\n<span class=\"c1\">-- this namepsacing is bad, but you get the idea...</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">A</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">accepts_mem_language</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">NFA</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">NFA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"n\">nfa</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">nfa</span><span class=\"bp\">.</span><span class=\"n\">start</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">nfa</span><span class=\"bp\">.</span><span class=\"n\">accept</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nfa</span><span class=\"bp\">.</span><span class=\"n\">MTr</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">s'</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">εNFA</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n\n<span class=\"c1\">-- not writing this one out because it relies on more of LTS...</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">εNFA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"n\">enfa</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">εNFA</span><span class=\"bp\">.</span><span class=\"n\">toNFA</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">enfa</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">εNFA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NFA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- just stating and not proving:</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toNFA_language_eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">enfa</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">εNFA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">enfa</span><span class=\"bp\">.</span><span class=\"n\">toNFA</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">enfa</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 547918096,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761826196
    },
    {
        "content": "<p>i like it, it's very similar to what I was once thinking of defining as the notion of acceptor. I'd actually call <code>A</code> <code>Acceptor</code>.</p>",
        "id": 547918592,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761826351
    },
    {
        "content": "<p>We'd have an equivalent typeclass for Omega-stuff of course. (OmegaAcceptor, I guess.)</p>",
        "id": 547918733,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761826394
    },
    {
        "content": "<p>For Epsilon <code>Symbol</code> varies to <code>Option Symbol</code>. Are there variants where <code>State</code> similarly changes?</p>",
        "id": 547919172,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761826519
    },
    {
        "content": "<p>Don't think so, outside of the definitions for the subset construction, e.g.,</p>\n<p><code>def NFA.toDFA (nfa : NFA State Symbol) : DFA (Set State) Symbol</code></p>",
        "id": 547919423,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761826595
    },
    {
        "content": "<p>Hmm. I was trying to determine if that first <code>State</code> type being shared meant we could share some infrastructure that is independent of the <code>Symbol</code>.</p>",
        "id": 547920038,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761826788
    },
    {
        "content": "<p>In an unbundled design, we would have the following signatures, where <code>S</code> and <code>A</code> are types of states and alphabets respectively:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"n\">NA</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">na</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"n\">εNA</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">na</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">εNA</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"n\">NA</span><span class=\"bp\">.</span><span class=\"n\">buchiLanguage</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">na</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωLanguage</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">mullerLanguage</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">accSet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωLanguage</span><span class=\"w\"> </span><span class=\"n\">A</span>\n</code></pre></div>\n<p>and definitions and theorems (which will be nameless for now) like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">na</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">na</span><span class=\"bp\">.</span><span class=\"n\">toDA</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">IsRegular</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ωLanguage</span><span class=\"bp\">.</span><span class=\"n\">IsRegular</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωLanguage</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">na</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">na</span><span class=\"bp\">.</span><span class=\"n\">buchiLanguage</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωLanguage</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">IsRegular</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">IsRegular</span><span class=\"w\">  </span><span class=\"c1\">-- this is the main result of Büchi's paper</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωLanguage</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">IsRegular</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">accSet</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">mullerLanguage</span><span class=\"w\"> </span><span class=\"n\">accSet</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\">  </span><span class=\"c1\">-- this is McNaughton's theorem</span>\n</code></pre></div>\n<p>Note that:</p>\n<ol>\n<li>The definitions of various languages will not involve any finite-ness assumption.</li>\n<li>The subset construction embodied by <code>NA.toDA</code> also does not depend on any finite-ness assumption.</li>\n<li>Finite-state assumptions come in with the notions of regular and ω-regular languages.</li>\n<li>All the closure results about regular languages actually do not need the finite-state assumption.  Many , though not all. of the closure results about ω-regular languages do not need the finite-state assumption, either.</li>\n<li>Nowhere above is the finite-alphabet assumption needed.  I think we need it only when proving the equivalence between regular languages and regular expressions, because you need a finite alphabet to make regular expressions finite.</li>\n</ol>",
        "id": 548040521,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761862175
    },
    {
        "content": "<p>I haven't thought about <code>εNA</code> carefully, but I believe that the <code>εNA.toNA</code> construction also does not depend on any finite-state assumption.  BTW, it would be nice to have a <code>NA.toEpsilonNA</code> construction as well.  I played with it a little bit and found that it is not trivial.</p>",
        "id": 548040975,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761862454
    },
    {
        "content": "<p>It is actually possible to prove all the closure properties of regular and ω-regular languages without using EpsilonNA.  I did that in my earlier automata theory project.</p>",
        "id": 548041292,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761862635
    },
    {
        "content": "<p>What about this?</p>\n<ul>\n<li>We get rid of <code>NFA</code> and <code>DFA</code>, nobody wants them for now anyway (me included, they were there only because we couldn't figure out good names for the acceptors yet).</li>\n<li>We create <code>NA.ExactAcceptor</code> (instantiates <code>Acceptor</code>, the <code>A</code> written by <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span>), <code>DA.ExactAcceptor</code>, and <code>NA.εAcceptor</code>, which do what the current <code>NFA</code>, <code>DFA</code>, and <code>εNA</code> do but without including the finiteness assumptions. Here I had to be creative: 'exact' comes from the fact that a string is accepted if it matches exactly the sequence of encountered transition symbols.</li>\n<li>We put all of this stuff under the <code>Cslib.Automata</code> namespace, including the <code>Acceptor</code> typeclass. (As <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> suggested once.)</li>\n</ul>\n<p>This design gets rid of the <code>F</code> in <code>DFA</code> and <code>NFA</code>, which is wrong to use since we don't need the finiteness assumptions.</p>\n<p>For omega stuff we'll do the same: <code>ωAcceptor</code>, instantiated by <code>NA.BuchiAcceptor</code>, etc.</p>\n<p>This scheme clarifies that the underlying structures are all the same, it's only the acceptance strategy that differs.</p>\n<p>I'm happy to make a PR for this restructuring, but we should discuss it here first.</p>",
        "id": 548133010,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761909941
    },
    {
        "content": "<p>These various <code>Exact*</code> are typeclass instances of <code>Acceptor</code>?</p>",
        "id": 548133469,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761910096
    },
    {
        "content": "<p>Yes, well, structures accompanied by an instance, I guess. Like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"bp\">.</span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">NA</span><span class=\"bp\">.</span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"n\">na</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 548134054,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761910292
    },
    {
        "content": "<p>This is a relevant aside that I feel we need to discuss regarding convention. You have expressed discomfort about structures named for finite automatons that do not enforce a finiteness condition. My view is that this a Lean formalization convention. Typically when defining a <code>def</code> or <code>strcuture</code>, we do not place typeclass or other <code>Prop</code> requirements on it, postponing these until the theorems where they are used. So yes, there is a mismatch of sorts in the name, but the theorems where this data are used all enforce these conditions. In this sense, I do not find the definitions/names of Mathlib's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NFA#doc\">docs#NFA</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFA#doc\">docs#DFA</a> so unusual.</p>\n<p>And in fact, modulo some LTS involvement, the <code>NA.Acceptor</code> you have defined above seems to converge on this, but with a different name, yes?</p>",
        "id": 548139495,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761912205
    },
    {
        "content": "<p>Can you point me to an example that is not NFA or DFA?</p>",
        "id": 548139683,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761912266
    },
    {
        "content": "<p>(Aside: I wouldn't necessarily have that <code>Acceptor</code> in the same file as NA, it could be a separate file.)</p>",
        "id": 548140071,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761912389
    },
    {
        "content": "<p>Also, what you wrote is exactly how we've been doing things. Perhaps I'm missing something?</p>\n<p>What I'm contesting here is that if a structure implicitly <em>declares</em> that it'll have a property in its name, it should <em>always</em> have it, not just in some cases.</p>",
        "id": 548141073,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761912724
    },
    {
        "content": "<p>I'd have to think for a sec to find a good Mathlib example, but consider the <code>[HasFresh Var] [DecidableEq Var]</code> condition we have in all the lambda calculus files. Terms definitely don't make sense without them, but none of the inductive types we define include these assumptions. You can construct such a term without an error, but find out when you try to use any of the theorems that there is a problem. We just don't normally think about it because it's not in the name.</p>",
        "id": 548141301,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761912802
    },
    {
        "content": "<p><code>Term</code> or <code>Var</code> (etc.) say nothing about <code>HasFresh</code> or <code>DecidableEq</code> in their names. So what you're describing is what I wanna do with <code>NA</code>/<code>DA</code>/etc.</p>\n<p>The example you gotta give me to support your argument is one where somebody wrote something called like <code>VarWithFresh</code>, it contains nothing about freshness whatsoever, and then there's a bunch of theorems that have <code>[HasFresh Var]</code> as parameter. What I'm arguing for is that such a thing should just be called <code>Var</code>.</p>",
        "id": 548144314,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761913662
    },
    {
        "content": "<p>I see if I can find another example, but I can understand your argument regardless.</p>",
        "id": 548145421,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761913986
    },
    {
        "content": "<p>What is the advantage of putting <code>accept : Set State</code> in a child structure verus including it in <code>DA</code> and <code>NA</code>? Then this really is the same definition as Mathlib, but without the undesirable name. (And as was suggested <a href=\"https://github.com/leanprover/cslib/pull/141#discussion_r2480355927\">here</a> at least for <code>DA</code> it could just be an <code>abbrev</code>)</p>",
        "id": 548145526,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761914012
    },
    {
        "content": "<p>For some omega-stuff and things that are not acceptors, there is no such field IIRC, but other things instead.</p>",
        "id": 548146085,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761914169
    },
    {
        "content": "<p>I see, this is reasonable then. Another consideration. Instead of having a child structure like <code>NA.Acceptor</code> that carries the <code>accept : Set State</code>, this could be in the <code>Acceptor</code> class. I see having one fewer structure definition as an advantage, and it groups together the data that <code>Acceptor</code> uses. What do you think?</p>",
        "id": 548147222,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761914494
    },
    {
        "content": "<p>We thought about this once and my recollection is that:</p>\n<p>This might be reasonable, but I'm not 100% sure because I'm not sure all acceptors have exactly that set of states. Isn't it also a bit weird to 'leak' internal details of how the acceptor works?</p>",
        "id": 548148953,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761914971
    },
    {
        "content": "<p>At least in omega-things, this is gonna be hard to replicate because of the different ways acceptance is modelled.</p>",
        "id": 548149043,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761915001
    },
    {
        "content": "<p>That's all I could think of, your proposal sounds reasonable to me.</p>",
        "id": 548150450,
        "sender_full_name": "Chris Henson",
        "timestamp": 1761915444
    },
    {
        "content": "<p>Let me produce a PR of an unbundled design on top of <a href=\"https://github.com/leanprover/cslib/pull/141\">cslib#141</a>.</p>",
        "id": 548245007,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761944365
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/stream/513188-CSLib/topic/Question.20Lean.20structure.20and.20extends/near/548139683\">said</a>:</p>\n<blockquote>\n<p>Can you point me to an example that is not NFA or DFA?</p>\n</blockquote>\n<p>Some mathlib examples are:</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MonoidHom#doc\">docs#MonoidHom</a>: not actually between monoids</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module#doc\">docs#Module</a>: actually a semimodule without other assumptions</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingEquiv#doc\">docs#RingEquiv</a>: not actually between rings</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingCon#doc\">docs#RingCon</a>: not actually about a ring</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=InnerProductSpace#doc\">docs#InnerProductSpace</a>: actually a pre-inner product space</li>\n</ul>",
        "id": 548251017,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1761947998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/stream/513188-CSLib/topic/Question.20Lean.20structure.20and.20extends/near/548141073\">said</a>:</p>\n<blockquote>\n<p>What I'm contesting here is that if a structure implicitly <em>declares</em> that it'll have a property in its name, it should <em>always</em> have it, not just in some cases.</p>\n</blockquote>\n<p>Either you over promise in the name and deliver something more general than expected, or you use a less discoverable and more verbose name and leave the user wondering why they can't find the less general thing that is wanted 90% of the time</p>",
        "id": 548251327,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1761948173
    },
    {
        "content": "<p>Of course if the name implies a property that the caller must assume separately to actually get, the docstring ought to make this clear.</p>",
        "id": 548251400,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1761948217
    },
    {
        "content": "<p>Well, one way to interpret the \"F\" in \"NFA\" and \"DFA\" is to say that it refers to the finiteness of the words being accepted, not necessarily to the finiteness of the state space.  <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 548252874,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761949214
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/513188-CSLib/topic/Question.20Lean.20structure.20and.20extends/near/548251327\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/stream/513188-CSLib/topic/Question.20Lean.20structure.20and.20extends/near/548141073\">said</a>:</p>\n<blockquote>\n<p>What I'm contesting here is that if a structure implicitly <em>declares</em> that it'll have a property in its name, it should <em>always</em> have it, not just in some cases.</p>\n</blockquote>\n<p>Either you over promise in the name and deliver something more general than expected, or you use a less discoverable and more verbose name and leave the user wondering why they can't find the less general thing that is wanted 90% of the time</p>\n</blockquote>\n<p>Can't one always have also the less general thing as a bundle (like NFA), with a docstring that tells people the story? The less general thing could be useful for people who want to use the theory for applications.</p>",
        "id": 548286268,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761984639
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/Question.20Lean.20structure.20and.20extends/near/548252874\">said</a>:</p>\n<blockquote>\n<p>Well, one way to interpret the \"F\" in \"NFA\" and \"DFA\" is to say that it refers to the finiteness of the words being accepted, not necessarily to the finiteness of the state space.  <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>Hehe, that's actually pretty good. But it also tells more about the acceptor/acceptance condition than the machine itself.. :-)</p>",
        "id": 548286346,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761984712
    },
    {
        "content": "<p>You can find in the following commit what I have in mind for an unbundled design of automata theory:<br>\n<a href=\"https://github.com/ctchou/cslib/commit/b9fd281d0148d2979bff97cb2a249534319a7308\">https://github.com/ctchou/cslib/commit/b9fd281d0148d2979bff97cb2a249534319a7308</a><br>\nThe key idea is that the notion of an accepting run of an automaton (which I guess is what Chris and Fabrizio referred to as an \"acceptor\" above) is abstracted out and put into the file Accept.lean.  Three different acceptance conditions are formalized: that for finite words, the Buchi and Muller acceptance conditions for infinite words.  Those acceptance conditions can be combined with DA and NA in any way you like.  Some example combinations and illustrative theorem statements are given.  Finite-state assumptions will be made only when necessary.  For example, they are made in the definition/theorem about regular and ω-regular languages. But they will not be made in (for example) the proof of the equivalence of NA and DA in terms of the (finite-word) languages they can accept.</p>\n<p>I'll port the rest of <a href=\"https://github.com/leanprover/cslib/pull/141\">cslib#141</a> to this design, but that will take me several days.</p>",
        "id": 548286457,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1761984808
    },
    {
        "content": "<p>Yes, you're basically defining acceptors. But I'd like to try out the typeclass approach (because, for example, it'll give us the resulting languages for free).</p>\n<p>I'd like to merge the pending PRs first though, so not to impede progress (this is 'just' a restructuring). (Currently I just need a couple of merge conflicts to be fixed in <a href=\"https://github.com/leanprover/cslib/pull/141\">cslib#141</a> and we're good to go).</p>",
        "id": 548287144,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1761985504
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span>: I've merged <a href=\"https://github.com/leanprover/cslib/pull/135\">cslib#135</a>, but I see <a href=\"https://github.com/leanprover/cslib/pull/141\">cslib#141</a> would require quite a few changes to be adapted to the new design. To minimise work, I'm opening a branch <code>automata</code> so that we can discuss and agree on the code before we commit to the design and do the work.</p>",
        "id": 548309358,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762004831
    },
    {
        "content": "<p>I've ended up simplifying and refining things a bit, you can see my code here: <a href=\"https://github.com/leanprover/cslib/tree/automata/Cslib/Computability/Automata\">https://github.com/leanprover/cslib/tree/automata/Cslib/Computability/Automata</a></p>\n<p>See in particular <code>Acceptor</code> and the <code>Deterministic</code> and <code>Nondeterministic</code> directories. I guess this is also closer to what you had in mind, <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span>.</p>\n<p>I still have to deal with the transformations between automata.</p>\n<p>An example of how a bundled version and its docstring will look like is given in <code>DFA</code> (I still have to update the others).</p>",
        "id": 548309542,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762004989
    },
    {
        "content": "<p>In OOP I'd just define an <code>Acceptor</code> interface and implement it from <code>DFA</code>. But there's no way to do this cleanly in Lean AFAIK.</p>",
        "id": 548310192,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762005528
    },
    {
        "content": "<p>After cherry-picking on top of the current <code>main</code>, <a href=\"https://github.com/leanprover/cslib/pull/141\">cslib#141</a> should be fixed.</p>",
        "id": 548319555,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762013461
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> I think <code>Acceptor</code> looks good at your link above. Regarding it being a typeclass or structure, I am not sure which is best. There are places in Mathlib where both are defined and proven to be related, for instance the structure <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Iso#doc\">docs#CategoryTheory.Iso</a> and <code>Prop</code> typeclass <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.IsIso#doc\">docs#CategoryTheory.IsIso</a>. If there are different use cases here that make having both worthwhile, I think that's fine. (I didn't quite understand your OOP analogy though)</p>\n<p>However, I continue my objection to bundling typeclasses. Eric has shown examples of the Mathlib convention, and for functions like <code>DFA.prod</code> (what <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> was writing at the very beginning of this thread) it means that you have to manually work with instances in defining functions rather than them being inferred, and as cited above, we have seen already from the Mathlib port the performance and organizational benefits of unbundling. If a different name is desired that is fine, but I strongly believe that this bundling will become technical debt.</p>",
        "id": 553194994,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762035480
    },
    {
        "content": "<p>The inferring issue goes away if you declare the field with <code>[theField : FieldType]</code> and <code>attribute [instance] TheType.theField</code> (which if you insist on bundling you should definitely do), but I agree that bundling typeclasses about the parameters inside structures is a bad idea</p>",
        "id": 553195811,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762036449
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span>  Could you elaborate more on what you mean by \"bundling typeclasses\"?  I don't understand it yet.  Thanks!</p>",
        "id": 553195991,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762036663
    },
    {
        "content": "<p>As to <span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>'s design, I think it is basically the same as mine, except that I have a single \"acceptor\" that is applicable to both NA and DA.  (The other two acceptors in my <code>Accept.lean</code> are for the Buchi and Muller acceptance conditions of automata on infinite words.).</p>",
        "id": 553196201,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762036919
    },
    {
        "content": "<p><code>DFA</code> for instance is \"bundled\" because it has typeclass instances <code>finite_state</code> and <code>finite_symbol</code> that appear as fields.</p>",
        "id": 553196282,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762037020
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/513188-CSLib/topic/Question.20Lean.20structure.20and.20extends/near/553195811\">said</a>:</p>\n<blockquote>\n<p>The inferring issue goes away if you declare the field with <code>[theField : FieldType]</code> and <code>attribute [instance] TheType.theField</code> (which if you insist on bundling you should definitely do), but I agree that bundling typeclasses about the parameters inside structures is a bad idea</p>\n</blockquote>\n<p>I tried this at some point, but was having some problems with typeclass inference that I didn't have time to debug.</p>",
        "id": 553196320,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762037076
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> I see.  Could you take a look at my design?  It doesn't have any finite-ness assumption bundled.</p>",
        "id": 553196395,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762037146
    },
    {
        "content": "<p>Indeed, in my design, we won't have <code>DFA</code> or <code>NFA</code> at all.</p>",
        "id": 553196428,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762037199
    },
    {
        "content": "<p>There is a \"This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.\" warning so I can't view the full diff. Is it in a branch somewhere?</p>",
        "id": 553196807,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762037746
    },
    {
        "content": "<p>I'm not sure about the difference between yours and Fabrizio's design of <code>Acceptor</code>, I'll leave that for you since you both understand what we'll want for later theory better. But it seems your bundling is in line with what I was thinking. You unbundled the finiteness assumptions, then rather have a structure that just provides <code>accept : Set State</code> , you move this to the <code>Acceptor</code> structure. This seems fine to me.</p>",
        "id": 553197180,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762038239
    },
    {
        "content": "<p>As I said above, Fabrizio's \"acceptor\" is basically the same as mine, except that he has one for DA and another one for NA while I have a single one for both.  I think we cam state and prove all the results without introducing DFA or NFA.</p>",
        "id": 553197299,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762038408
    },
    {
        "content": "<p>Here's the branch I'm working on:<br>\n<a href=\"https://github.com/ctchou/cslib/tree/unbundle-automata-work\">https://github.com/ctchou/cslib/tree/unbundle-automata-work</a><br>\nTake a look at DAtoNA.lean and NAtoDA.lean, which are the unbundled counterparts of DFAToNFA.lean and NFAToDFA.lean, respectively.  As you can see, nothing in the proof depends on any finite-ness assumption.  Now there should be enough results to prove the closure results in RegularLanguage.lean, which I will do next.  Then I'll port EpsilonNA related files and get rid of DFA, NFA, and EpsilonNFA altogether.</p>",
        "id": 553205150,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762048392
    },
    {
        "content": "<p>Yes, this is the direction I would go.</p>\n<p>One small style point about using <code>Type*</code>. The point is that it assigns fresh universes for each variable at once, so <code>{State : Type*} {Symbol : Type*}</code> is redundant and should be <code>{State Symbol : Type*}</code> instead. (And it is not required that you use <code>Type*</code>, Fabrizio for instance has expressed a preference for writing <code>Type _</code> and I don't feel we need to enforce one way or the other)</p>",
        "id": 553206125,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762049457
    },
    {
        "content": "<p>Ah, of course, I shouldn't have bundled the finiteness assumptions, I didn't consider they were typeclasses while making the refactoring. Does this look ok? Basically DFA bundles only the accept state set (but constructing it requires having the finiteness assumptions).</p>\n<p><a href=\"https://github.com/leanprover/cslib/blob/automata/Cslib/Computability/Automata/DFA.lean\">https://github.com/leanprover/cslib/blob/automata/Cslib/Computability/Automata/DFA.lean</a></p>",
        "id": 553258167,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762102358
    },
    {
        "content": "<p>At this point, I agree that DFA might just be useless... mmmh.</p>",
        "id": 553258484,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762102636
    },
    {
        "content": "<p>Yeah, this is fine, but you could go one step further and move the accept state set into the <code>Acceptor</code> structure and eliminate <code>DFA</code>.</p>",
        "id": 553258576,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762102721
    },
    {
        "content": "<p>(which is what <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> describes above)</p>",
        "id": 553258596,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762102735
    },
    {
        "content": "<p>Why would acceptor contain the accept state set?</p>",
        "id": 553258616,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762102750
    },
    {
        "content": "<p>Where would you place it if getting rid of <code>DFA</code>?</p>",
        "id": 553258718,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762102831
    },
    {
        "content": "<p>Nowhere? It's just a parameter for the constructor, e.g., <a href=\"https://github.com/leanprover/cslib/blob/automata/Cslib/Computability/Automata/Deterministic/ExactAcceptor.lean\">https://github.com/leanprover/cslib/blob/automata/Cslib/Computability/Automata/Deterministic/ExactAcceptor.lean</a></p>",
        "id": 553258808,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762102920
    },
    {
        "content": "<p>(DA.exactAcceptor)</p>",
        "id": 553258818,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762102929
    },
    {
        "content": "<p>Ah I see, yes that's fine.</p>",
        "id": 553258982,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762103093
    },
    {
        "content": "<p>A hypothetical discussion:</p>\n<p>What concerns me is that, following the same line of thought, shouldn't we unbundle <code>start : State</code> as well from DA and NA, because they're needed only to produce acceptors?</p>\n<p>That is, this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">exactAcceptor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">mtr</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n</code></pre></div>\n<p>could become</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">exactAcceptor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">mtr</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n</code></pre></div>\n<p>If we do this, hypothetically, NA would just literally be an LTS, and all results on NA would become 'unbundled statements' on LTS. Where does this end? :o)</p>",
        "id": 553260761,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762104857
    },
    {
        "content": "<p>I'm concerned because composition operations on acceptors need to know about these elements (start and accept), so statements might get pretty long.. is that a price we wanna pay?</p>",
        "id": 553260897,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762104951
    },
    {
        "content": "<p>even correctness theorems get to be like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toNA_exactAcceptor_language_eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">exactAcceptor</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">toNA</span><span class=\"bp\">.</span><span class=\"n\">exactAcceptor</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 553261030,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762105066
    },
    {
        "content": "<p>Tl;dr no, don't unbundle everything</p>\n<p>The line that is usually drawn is that we bundle some <em>data</em> into a definition when we want to build API around some concept. Mathlib doesn't have DA, and draws this line as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFA#doc\">docs#DFA</a> bundling the step (our LTS.Tr), <code>start</code> and <code>accept</code>. We certainly can choose to have the corresponding structure by extending <code>DA</code> with just <code>accept</code> if we prefer to give a name to it.</p>",
        "id": 553261602,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762105501
    },
    {
        "content": "<p>Let me try again with both start and accept states bundled in DA and NA.</p>",
        "id": 553261971,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762105860
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>  You may want to take a look at what I have done:<br>\n<a href=\"https://github.com/ctchou/cslib/tree/unbundle-automata-work\">https://github.com/ctchou/cslib/tree/unbundle-automata-work</a><br>\nI think you are going down the same path as me, just with slightly different name and namespace hierarchies.</p>",
        "id": 553266620,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762110170
    },
    {
        "content": "<p>Your <code>ExactAcceptor.Accepts</code> is a combination of my <code>Accept.Run</code> and <code>Accept.language</code>.  I store the set of accepting states as a field <code>xxAccept.acc*</code> in the <code>xxxAccept</code> structure, where the <code>xxx</code> corresponds to the different types of acceptance conditions .    My <code>xxxAccept.Run</code> captures  the notion of a \"run\" of an automaton, which is:<br>\n(1) a finite word over symbols)plus a final state in the case of finite runs, or<br>\n(2) an infinite word over symbols plus an infinite sequence of states in the case of infinite runs.<br>\nMy <code>xxxAccept.language</code> defines what it means for an automaton to accept a run under the <code>xxx</code> acceptance condition.  The above is separate from and orthogonal to the notions of DA and NA and the various constructions on DA and NA (such as product, subset construction, and the yet-to-be-defined sum, concatenation, and looping constructions).</p>",
        "id": 553267688,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762111223
    },
    {
        "content": "<p>I have ported all of automata theory up to <a href=\"https://github.com/leanprover/cslib/pull/141\">cslib#141</a> to the new unbundled design, which can now be reviewed as <a href=\"https://github.com/leanprover/cslib/pull/142\">cslib#142</a>.</p>",
        "id": 553297720,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762142036
    },
    {
        "content": "<p>It shows that all finite-ness assumptions can be safely dropped, except those embedded in the definition of regular languages.  In particular, Fabrizio's proofs in DFAToNFA.lean, NFAToDFA.lean, and EpsilonNFAToNFA.lean can all be carried over to DAtoNA.lean, NAtoDA.lean, and EpsilonNAtoNA.lean with very few changes.</p>",
        "id": 553298058,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762142259
    },
    {
        "content": "<p>I did look at it; I think we're all perfectly in line regarding dropping the assumptions (and we have been for a long time), I just wanted to be really sure about the architecture because there are interesting lessons here.</p>",
        "id": 553318142,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762156340
    },
    {
        "content": "<p>I left just a few style comments, nothing about the design.</p>",
        "id": 553331402,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762161097
    },
    {
        "content": "<p>Please wait a bit more before working too much on PRs, I'm still working on the updated proposal for restructuring. (<a class=\"message-link\" href=\"/#narrow/channel/513188-CSLib/topic/Question.20Lean.20structure.20and.20extends/near/553261971\">#CSLib &gt; Question Lean structure and extends @ 💬</a>)</p>",
        "id": 553333284,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762161686
    },
    {
        "content": "<p>I'm trying an idea to solve the 'missing' level of abstraction between deterministic transition systems and automata (which is present instead for NA, because it extends LTS), and see where it goes.</p>\n<p>In the <code>automata</code> branch I've introduced a 'Functional LTS' structure,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">A Functional Labelled Transition System (`FLTS`) for a type of states (`State`) and a type of</span>\n<span class=\"sd\">transition labels (`Label`) consists of a labelled transition function (`tr`).</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">FLTS</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Label</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The transition function. -/</span>\n<span class=\"w\">  </span><span class=\"n\">tr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">State</span>\n</code></pre></div>\n<p>plus the expected translations back and forth between LTS and FLTS and the accompanying theorems that relate transitions in LTS to those in FLTS and vice versa.</p>\n<p><code>DA</code> now extends <code>FLTS</code>, and adds the start and accept states. <code>NA</code> now does the same, but extending <code>LTS</code>.<br>\nTranslating between them now invokes the translations between <code>LTS</code> and <code>FLTS</code> and then simply adds the translations for the start and accept state (sets).</p>\n<p>Working like this things are pretty modular and acceptors can just be returned with no parameters, e.g.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"bp\">.</span><span class=\"n\">acceptor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">da</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">mtr</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">da</span><span class=\"bp\">.</span><span class=\"n\">accept</span>\n</code></pre></div>\n<p>and then theorems are started like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toDA_language_eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">na</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">na</span><span class=\"bp\">.</span><span class=\"n\">toDA</span><span class=\"bp\">.</span><span class=\"n\">acceptor</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">na</span><span class=\"bp\">.</span><span class=\"n\">acceptor</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>This means that composition of automata should be easy as well, because they bundle the important bits (instead of taking them as parameters to <code>acceptor</code>).</p>\n<p>Acceptor is still:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Accepts</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>I've pushed to <code>automata</code> but it's still a work in progress, I still have to remove some old stuff and gotta try epsilon automata (but they should work).</p>\n<p>Thoughts welcome. I tried hard to find a name in the literature for FLTS (which I'm pretty familiar with), but failed: it appears one has to be created.</p>",
        "id": 553382356,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762176982
    },
    {
        "content": "<p>Just to be clear, the problem this solves is that it makes <code>NA</code> and <code>DA</code> both extend analogous structures? When finished, would this remove <code>DFA</code> and <code>NFA</code> in the same way as the above PR?</p>\n<p>If this is a common enough concept in the literature to deserve its own definition, I don't have any objection. I see from the code that this is considered a special case of <code>LTS</code>, so we don't need to replicate the more complex machinery like the notation attribute I am guessing?</p>",
        "id": 553394466,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762180088
    },
    {
        "content": "<p>Yes. More specifically, it solves the problem that we didn't have a good place for the concept of 'transition system given by a function', which led to asymmetric hierarchies and some confusion (theorems were organised differently across DA vs NA+LTS). This allows for proving theorems where more appropriate (plenty can be stated across FLTS and LTS, without talking about any start or accept states).</p>\n<p>This in turn leaves us free to use <code>DA</code> and <code>NA</code> for, respectively, <code>FLTS</code> and <code>LTS</code> equipped with start and accept states, and then prove there the theorems that require talking about such states.</p>\n<p>Re the concept: there's no real established name for this concept that I could find, as I wrote, so it's a design choice. Calling 'transition system given by a function' LTS-something instead of Automaton-something seems more consistent to me and seems to give us a better hierarchy.</p>",
        "id": 553402376,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762181952
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>  Attaching the set of accepting states to DA or NA is a bad idea, because automata on infinite words have several types of acceptance conditions not all of which can be specified by a set of states:</p>\n<ul>\n<li>The Muller acceptance condition is a set of sets of states.</li>\n<li>The Rabin and Streett acceptance conditions are a set of pairs of sets of states.</li>\n<li>\n<p>The Buchi acceptance condition is a set of states.<br>\nHere's a good reference: <a href=\"https://www.imsc.res.in/~madhavan/papers/pdf/tcs-96-2.pdf\">https://www.imsc.res.in/~madhavan/papers/pdf/tcs-96-2.pdf</a><br>\nThis is why I keep insisting that DA and NA should NOT carry accepting states and moved the accepting states (or sets of sets of states, etc) to Accept.lean, which is now completely orthogonal to DA/NA and can be combined with them in any manner you like.  Currently <a href=\"https://github.com/leanprover/cslib/pull/142\">cslib#142</a> already illustrates several combinations:</p>\n</li>\n<li>\n<p>Finite acceptance condition with DA, NA, and EpsilonNA.</p>\n</li>\n<li>Buchi acceptance condition with NA, which is used to define the notion of ω-regular languages.</li>\n<li>Muller acceptance condition with DA, which is used to state McNaughton's theorem.</li>\n<li>More combinations will be added.  For example, a relatively simple result is that DA with Buchi acceptance condition is strictly weaker than Buchi with NA and hence does not capture ω-regular languages.  (This is a major difference between regular and ω-regular languages.  The former is insensitive to the DA vs NA distinction, while the latter requires one to go from the simple Buchi condition to the more complex Muller or Rabin or Streett condition when moving from NA to DA.)</li>\n</ul>",
        "id": 553448163,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762193455
    },
    {
        "content": "<p>As to having a notion of FLTS, I think it is pretty orthogonal to the design of automata theory.  We can easily switch to it just like we can easily switch to a different LTS implementation as long as the same API is kept.</p>",
        "id": 553448867,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762193613
    },
    {
        "content": "<p>More progress and a reply to your last comment <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> .</p>\n<p>The idea is that now that we have FLTS, it takes very little effort to define different automata and we can have a bit of a flat hierarchy. Each automaton would define both its elements on top of the transition function/relation (which is now contained in FLTS/LTS) and the acceptance condition. Then we can state things very simply as in here by using <code>Acceptor</code> as a typeclass: <a href=\"https://github.com/leanprover/cslib/blob/automata/Cslib/Computability/Automata/NAToDA.lean\">https://github.com/leanprover/cslib/blob/automata/Cslib/Computability/Automata/NAToDA.lean</a></p>\n<p>So now we could very easily define MullerAutomaton, BuchiAutomaton, etc. They wouldn't be extensions of NA or DA, just of FLTS or LTS.</p>\n<p>But if you think there's value in sharing the <code>start</code> field in the type hierarchy, we can of course discuss that. I'm basically trying to hit the sweet spot for the hierarchy here.</p>\n<p>What do you think?</p>",
        "id": 553654649,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762272377
    },
    {
        "content": "<p>Note that the proofs NAToDA and DAToNA now look really simple, because most details could be found by grind from the theory about FLTS/LTS. (I still have to do the others.)</p>",
        "id": 553654733,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762272398
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>  In my previous automata theory project, I found it very natural to package the initial state/states into DA/NA in almost all the automata constructions.  There were only a couple of occasions where I wanted to change the initial state/states of a DA/NA.  So I think DA/NA should contain the initial state/states, so that we don't have to mention them explicitly all the time in definitions and theorems.  I also think that the code you showed above demonstrates that moving more work into FLTS/LTS is really an issue orthogonal to the design of DA/NA.  For example, I don't really care about where the heavy-lifting in the argument for the subset construction happens.  Whether it happens in LTS or in NA is a matter of proof organization, not in the design of DA and NA.<br>\nBut I do want to insist that DA and NA should NOT contain the acceptance condition, for the simple reason that there are many different types of acceptance conditions in the automata theory on infinite words.  So acceptance conditions should be made orthogonal to DA/NA.</p>",
        "id": 553680644,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762279052
    },
    {
        "content": "<p>So you're saying that instead of my current</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">FLTS</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The initial state of the automaton. -/</span>\n<span class=\"w\">  </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The accept states of the automaton. -/</span>\n<span class=\"w\">  </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>we should have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">FLTS</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The initial state of the automaton. -/</span>\n<span class=\"w\">  </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span>\n</code></pre></div>\n<p>and then further extend this (in this example to have something like DFA; I'm making a name up here, DAExact is just for the sake of developing this argument)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DAExact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">DA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The accept states of the automaton. -/</span>\n<span class=\"w\">  </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DAExact</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>Right? What are you trying to accomplish by sharing the definition of 'start' across different automata definitions through this extra layer? Having a common definition of run or something similar?</p>",
        "id": 553699747,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762285441
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>  Please take a look at what I did in <a href=\"https://github.com/leanprover/cslib/pull/142\">cslib#142</a>, in particular DA.lean and NA.lean.</p>",
        "id": 553702082,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762286323
    },
    {
        "content": "<p>I just add more attributes to <code>DA</code> and <code>NA</code> like <code>DA.accept</code>, <code>DA.language</code>, <code>DA.mullerAccept</code>, <code>DA.mullerLanguage</code>, <code>NA.buchiAccept</code>, <code>NA.buchiLanguage</code>, etc.</p>",
        "id": 553702659,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762286551
    },
    {
        "content": "<p>Note that any combinations of {DA, NA} and {language, buchiLanguage, mullerLanguage} are allowed and can be instantiated when needed.  (For example, I'm going to add <code>DA.buchiLanguage</code> and show that it is strictly less expressive than <code>NA.buchiLanguage</code>.)</p>",
        "id": 553703089,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762286708
    },
    {
        "content": "<p>Also take a look at Prod.lean, where I define the product of two DA's, and how this product construction is used in RegularLanguage.lean, where the closure of regular languages under union and intersection are proved using the same product construction but two different accepting conditions.</p>",
        "id": 553703465,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762286867
    },
    {
        "content": "<p>Also take a look at OmegaRegularLanguage.lean, where I define ω-regular languages using <code>NA.buchiLanguage</code> and state McNaughton's theorem using <code>DA.mullerLanguage</code>.  (To be sure, it will take 1000s lines of code to prove that theorem.)</p>",
        "id": 553704331,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762287139
    },
    {
        "content": "<p>Now, if I don't have the initial state/states in DA/NA (or whatever we choose to call them), then they will have to be supplied as explicit parameters in all the above definitions and theorems like how the set of accepting state (<code>acc</code>) and the set of set of accepting states (<code>accSet</code>) are explicitly specified.  From my experience, I think that is one unbundling step too far.  In my view, bundling the initial state/states but not the acceptance condition strikes the right balance.</p>",
        "id": 553704977,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762287429
    },
    {
        "content": "<p>In my proposal (which is to have FLTS/LTS with only the transition function/relation + automata structures that extend those with bundled start and accept states), you'd get <code>DA</code>, <code>NA</code>, <code>MullerAutomaton</code>, <code>BuchiAutomaton</code>, etc., each instantiating either <code>Acceptor</code> or <code>ωAcceptor</code> (now added to the branch; I don't wanna add the rest for now because I'd like to import your commits there and merge somehow, to keep the right history). You have the same proliferation with the *Accept structures.</p>\n<p>Some statements would become more ergonomic, because you wouldn't have to bring around the acceptance states as parameter.</p>\n<p>For example IsRegular and McNaughton's would become:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsRegular</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωLanguage</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BuchiAutomaton</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span>\n\n<span class=\"n\">proof_wanted</span><span class=\"w\"> </span><span class=\"n\">IsRegular</span><span class=\"bp\">.</span><span class=\"n\">iff_muller_lang</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωLanguage</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">IsRegular</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MullerAutomaton</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>I see what you're doing with prod in the proofs for RegularLanguages (clever!). But these probably merit to be actual operations defined for DAs: intersection and union. Their definitions could reuse a shared base by defining <a href=\"http://FLTS.prod\">FLTS.prod</a>, where the heavy lifting would be done (the product of the transition functions).</p>\n<p>So all in all, the complexity is very similar but we get rid of having the accept parameter all over the place in places where it might be weird, like those above or </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toDA_language_eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">na</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">na</span><span class=\"bp\">.</span><span class=\"n\">toDA</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">na</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n</code></pre></div>\n<p>which in my branch is just</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toDA_language_eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">na</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NA</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">Acceptor</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">na</span><span class=\"bp\">.</span><span class=\"n\">toDA</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Acceptor</span><span class=\"bp\">.</span><span class=\"n\">language</span><span class=\"w\"> </span><span class=\"n\">na</span>\n</code></pre></div>\n<p>The only thing gained from an extra layer of indirection (as presented in my previous message) that I can see is having a modular notion of 'run' independent from accept states/conditions. But I don't see you using it without these conditions anywhere, so we could just use <code>Accepts</code> or <code>MTr</code>/<code>mtr</code> there.</p>\n<p>Hence my suggestion of my current design in the <code>automata</code> branch, with the opening of extending it further with another layer of abstraction in the future if we see a good opportunity.</p>\n<p>(Btw, I'm happy to try and merge your results and development in this branch before I propose this for main, so that it all goes in at the same time. I just wanna agree here before we do too much work on porting to this or that other design...)</p>",
        "id": 553820060,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762339579
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>  The product construction on DA is not the only occasion when you don't want the automaton to carry the acceptance condition.  There are  quite a few other occasions:</p>\n<p>The same automata construction on NA can be used to show that given regular languages L and L' and ω-regular language P,  L ∗ L' is regular and L ∗ P is ω-regular.:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Concat.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Concat.lean</a><br>\nIf NA has to carry the acceptance condition, I need to define two different automata concatenation operations, one concatenating two NFAs and a second one concatenating an NFA and a BuchiNA.</p>\n<p>The same automata construction on NA can be used to show that given a regular language L, L∗ is regular and L^ω is ω-regular:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Loop.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Loop.lean</a><br>\nIf NA has to carry the acceptance condition, I need to define two different automata looping operations, one producing an NFA and a second one producing a BuchiNA.</p>\n<p>To show that the intersection of two ω-languages is still ω-regular, I first construct the product of the two BuchiNA and then add \"history variables\" to the product:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Prod.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Prod.lean</a><br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Hist.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Hist.lean</a><br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/OI2.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/OI2.lean</a><br>\nIf I have to work on BuchiNA directly, the two steps need to be collapsed together because the intermediate product automaton result does not have meaningful liveness behavior to speak of (in other words, it is naturally modeled as a NA without an acceptance condition).</p>\n<p>The act of adding history variables mentioned above is an operation that has meaningful safety properties, but no meaningful liveness properties:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Hist.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Hist.lean</a><br>\nIf I'm forced to work on BuchiNA or MullerDA, I'll have to define automata constructions where the acceptance conditions are carried around but not really used.  Note that adding history variables is not used in just the above result, it is also used in proving other results:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Pair.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Pair.lean</a></p>\n<p>So, by separating out the acceptance condition from the automaton proper, we get more modular and reusable proofs and reduce the number of distinct automata constructions we need to deal with.  If the appearance of <code>acc</code> and <code>accSet</code> really bothers you, you can always define (say) BuchiNA which has the accepting states bundled in and state the final theorems in terms of the bundled entities.  But I still want to do my proofs in terms of the unbundled NA and DA, because I've learned from experience that doing otherwise doesn't make any sense.</p>",
        "id": 553947987,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762371722
    },
    {
        "content": "<p>BTW, the fact that union and intersection can be implemented using the product construction on DA is not just a happy coincidence.  It reflects a fundamental truth about deterministic machines.  Imagine that we form the product of any number of <code>DA</code>s.  Then any boolean operation on the accepted languages of those <code>DA</code>s can be implemented by the corresponding operation on the accepting sets.  This even works for ω-automata with basically the same proof, though you'll need to use the Muller acceptance condition.</p>",
        "id": 553956034,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762374412
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/Question.20Lean.20structure.20and.20extends/near/553956034\">said</a>:</p>\n<blockquote>\n<p>BTW, the fact that union and intersection can be implemented using the product construction on DA is not just a happy coincidence.  It reflects a fundamental truth about deterministic machines.  Imagine that we form the product of any number of <code>DA</code>s.  Then any boolean operation on the accepted languages of those <code>DA</code>s can be implemented by the corresponding operation on the accepting sets.  This even works for ω-automata with basically the same proof, though you'll need to use the Muller acceptance condition.</p>\n</blockquote>\n<p>Of course, I agree. My suggestion was to generalise this to (F)LTSs.</p>",
        "id": 554092037,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762436542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/Question.20Lean.20structure.20and.20extends/near/553947987\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span>  The product construction on DA is not the only occasion when you don't want the automaton to carry the acceptance condition.  There are  quite a few other occasions:</p>\n<p>The same automata construction on NA can be used to show that given regular languages L and L' and ω-regular language P,  L ∗ L' is regular and L ∗ P is ω-regular.:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Concat.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Concat.lean</a><br>\nIf NA has to carry the acceptance condition, I need to define two different automata concatenation operations, one concatenating two NFAs and a second one concatenating an NFA and a BuchiNA.</p>\n<p>The same automata construction on NA can be used to show that given a regular language L, L∗ is regular and L^ω is ω-regular:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Loop.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Loop.lean</a><br>\nIf NA has to carry the acceptance condition, I need to define two different automata looping operations, one producing an NFA and a second one producing a BuchiNA.</p>\n<p>To show that the intersection of two ω-languages is still ω-regular, I first construct the product of the two BuchiNA and then add \"history variables\" to the product:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Prod.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Prod.lean</a><br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Hist.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Hist.lean</a><br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/OI2.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/OI2.lean</a><br>\nIf I have to work on BuchiNA directly, the two steps need to be collapsed together because the intermediate product automaton result does not have meaningful liveness behavior to speak of (in other words, it is naturally modeled as a NA without an acceptance condition).</p>\n<p>The act of adding history variables mentioned above is an operation that has meaningful safety properties, but no meaningful liveness properties:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Hist.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Hist.lean</a><br>\nIf I'm forced to work on BuchiNA or MullerDA, I'll have to define automata constructions where the acceptance conditions are carried around but not really used.  Note that adding history variables is not used in just the above result, it is also used in proving other results:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Pair.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Pair.lean</a></p>\n<p>So, by separating out the acceptance condition from the automaton proper, we get more modular and reusable proofs and reduce the number of distinct automata constructions we need to deal with.  If the appearance of <code>acc</code> and <code>accSet</code> really bothers you, you can always define (say) BuchiNA which has the accepting states bundled in and state the final theorems in terms of the bundled entities.  But I still want to do my proofs in terms of the unbundled NA and DA, because I've learned from experience that doing otherwise doesn't make any sense.</p>\n</blockquote>\n<p>I'm a bit confused because you keep referring to not bundling the acceptance condition ('when you don't want the automaton to carry the acceptance condition', etc.), so let me try to clarify: I'm doing that too, I'm just doing it in another place to make things homogeneous (FLTS/LTS).<br>\nThat said, your links and arguments are still very useful, because the operators are important.<br>\nNevertheless, the prod and concat operators would be defined for (F)LTS and then automata would reuse it (they'd even have the same signature as far as I can see at a glance). Similarly for the other operations. One of my aims is exactly to give you (even better) modularity, and obtain a symmetric type hierarchy for deterministic and nondeterministic automata.</p>\n<p>The key point is whether it's useful enough to have an 'intermediate' structure that extends FLTS with just a start state, and another that extends LTS with a set of start states. So, for example, FLTS (transition function) -&gt; PreDA (start state) -&gt; DA (accept states) vs FLTS (transition function -&gt; DA (start + accept states).<br>\nBundled designs could then extend those intermediate structures, instead of FLTS/LTS directly. I'd like to understand why these intermediate structures are so useful, compared to just formulating operators on FLTS/LTS and extend those directly.</p>\n<p>(Sidenote: the names of the structures can be changed, now or later, I'm more interested in the abstract hierarchy here.)</p>",
        "id": 554097086,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762437706
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>   I think I understand what you want to do.  How about I elaborate <a href=\"https://github.com/leanprover/cslib/pull/142\">cslib#142</a> with what I think you want and then you can review it?</p>",
        "id": 554146939,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762449272
    },
    {
        "content": "<p>The structure I propose (without the intermediate structure) is already in the <code>automata</code> branch. It needs some fixes to EpsilonNA and to integrate your two PRs. We should:</p>\n<ul>\n<li>Decide if we want the intermediate layer or not (I'd first try without, and then if we see a problem with some part becoming inelegant we add it).</li>\n<li>Be sure we agree on the way I'm using typeclasses (Acceptor and OmegaAcceptor).</li>\n</ul>\n<p>Then we could switch to working on the same codebase so that we start building a linear history and ensure the APIs are aligned: merge the code from your PRs into the <code>automata</code> branch (accepting that stuff will be broken) and deal together with all the breakages (I could deal with porting some of your defs to FLTS/LTS and you with the omega-related stuff).<br>\nWhen we're satisfied, we just get a simple review on the proofs and merge the <code>automata</code> branch into <code>main</code>.</p>",
        "id": 554149103,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762449844
    },
    {
        "content": "<p>Or you can just shift your PRs to the <code>automata</code> branch, I review it there and then we merge, I guess? Basically I'm trying to figure out what's the quickest path to get the structure down, before we do too much work adjusting code (would like to avoid doing it too many times..!).</p>",
        "id": 554150621,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762450264
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/cslib/pull/142\">cslib#142</a> has more stuff to exercise the hierarchy on.</p>",
        "id": 554153761,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762451251
    },
    {
        "content": "<p>It has some actual proofs about regular languages and some definitions and theorem statements about omega automata.  We need to exercise the hierarchy especially on the latter to see that it actually works.</p>",
        "id": 554154468,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762451475
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>  I just pushed a new commit to <a href=\"https://github.com/leanprover/cslib/pull/142\">cslib#142</a>.  Please take a look.</p>\n<p>There are now 6 structures extending DA and NA, {DA,NA}.{FinAcc,Buchi,Muller}, for the finite, Buchi, and Muller acceptance conditions under DA and NA.  Each structure bundles in the set of accepting states (for FinAcc and Buchi) or the set of set of accepting states (for Muller).  Each of the 6 combinations also defines a namespace under which are the <code>Accept</code> and <code>language</code> definitions and the <code>mem_language</code> theorem.  The file Accept.lean is no longer needed and hence deleted.  See also RegularLanguage.lean and OmegaRegularLanguage.lean for how the above can be used.  Note that the automata constructions and their associated proofs are basically unchanged.  I also added an FLTS structure (which DA extends) that should be moved to its own file (which can be done with this or a different PR).</p>",
        "id": 554225300,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762481607
    },
    {
        "content": "<p>There is also a εNA.FinAcc.  Buchi and Muller acceptance conditions are not defined for εNA because εNA is useless in the automata theory on infinite words.</p>",
        "id": 554225926,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762481905
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/513188-CSLib/topic/Question.20Lean.20structure.20and.20extends/near/554225300\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span>  I just pushed a new commit to <a href=\"https://github.com/leanprover/cslib/pull/142\">cslib#142</a>.  Please take a look.</p>\n<p>There are now 6 structures extending DA and NA, {DA,NA}.{FinAcc,Buchi,Muller}, for the finite, Buchi, and Muller acceptance conditions under DA and NA.  Each structure bundles in the set of accepting states (for FinAcc and Buchi) or the set of set of accepting states (for Muller).  Each of the 6 combinations also defines a namespace under which are the <code>Accept</code> and <code>language</code> definitions and the <code>mem_language</code> theorem.  The file Accept.lean is no longer needed and hence deleted.  See also RegularLanguage.lean and OmegaRegularLanguage.lean for how the above can be used.  Note that the automata constructions and their associated proofs are basically unchanged.  I also added an FLTS structure (which DA extends) that should be moved to its own file (which can be done with this or a different PR).</p>\n</blockquote>\n<p>Thank you, great effort!</p>\n<p>Looking at your code, I think we're in line on the hierarchy now. I also like that you've namespaced the different automata under DA.</p>\n<p>There's quite a bit of work I'd done in the <code>automata</code> branch that I don't wanna redo/review from scratch or risk forgetting -- FLTS and its theory, the <code>Acceptor</code> typeclass (which is different from <code>Accept</code>), plenty of documentation, and more -- so I'm gonna try to merge the two developments into a single branch that we can review together. I think now we're near enough that it's worth the effort -- it's likely gonna be immediately right or almost there.</p>",
        "id": 554284010,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762510599
    },
    {
        "content": "<p>Just curious, have either of you run into more <code>grind</code> issues like <a href=\"https://github.com/leanprover/cslib/pull/88\">cslib#88</a> during this work? I feel it has something to do with how <code>grind</code> handles extended structures, but I wasn't able to figure exactly what the issue was.</p>",
        "id": 554286535,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762511281
    },
    {
        "content": "<p>A bit randomly, I still have to understand these issues better.. in my last design I didn't have any such issues. I hope this still holds when I'm finished merging <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span>'s work (WIP).</p>",
        "id": 554286813,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762511334
    },
    {
        "content": "<p>(If it all works out as I think, I might have at least something interesting to say about it though. :-) )</p>",
        "id": 554287177,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762511386
    },
    {
        "content": "<p>It did all work out, and more: it's a pretty pleasant development.<br>\nSee <a href=\"https://github.com/leanprover/cslib/pull/144\">cslib#144</a>, which merges the works that <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> and I have been doing in the <code>automata</code> branch and his PRs. It should all be in there.</p>",
        "id": 554305757,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762516946
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> I managed to get far with grind by defining transformations between automata based on transformations defined for the underlying structures (e.g., FLTS to LTS and vice versa), and using record update notation.</p>",
        "id": 554305853,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1762516983
    },
    {
        "content": "<p>I created a PR <a href=\"https://github.com/leanprover/cslib/pull/145\">cslib#145</a> to collect my modifications to <a href=\"https://github.com/leanprover/cslib/pull/144\">cslib#144</a>.</p>",
        "id": 554382785,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1762537866
    }
]