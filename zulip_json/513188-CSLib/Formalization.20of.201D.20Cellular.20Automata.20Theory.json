[
    {
        "content": "<p>I'm very happy to hear about the new project CSLib!</p>\n<p>I just finished the formalization and verification of various results regarding 1D cellular automata as formal language recognizers. The project is on <a href=\"https://github.com/hediet/lean-cellular-automata\">GitHub</a> (Lean 4 + Mathlib4, ~9,300 lines of definitions and proofs, 12 main theorems, all sorry-free and axiom-verified).</p>\n<p>Some results from the literature that I formalized and verified:</p>\n<ul>\n<li>One-way ↔ regular 1D Cellular Automata (CA) equivalence (modulo speedup factor of 2)</li>\n<li>Quiescent and dead border constructions</li>\n<li>Constant additive speedup and linear speedup by compression</li>\n<li>Real-time (RT) recognition of exponential word lengths via signal bouncing</li>\n</ul>\n<p>On top, I explored what power CAs gain with access to an advice (a length-preserving annotation of the input). I developed a theory of \"two-stage advice\" (CA transducer + right-to-left FST) and proved that RT transducers and two-stage advices are closed under composition, that two-stage advices don't extend RT-CA power, and that causal RT-closed advice is exactly CA-RT-transducer advice (more details <a href=\"https://hediet.github.io/lean-cellular-automata/summary.pdf\">here</a>).</p>\n<p>These advices simplify constructions as they allow for decomposition and could significantly simplify some proofs from the literature (especially the landmark result that L(RT-CA) = L(LT-CA) &lt;=&gt; L(RT-CA) = L(RT-CA-Rev), which I did not formalize).</p>\n<p>One challenge was finding the right definitions: I iterated many times on the formalization of cellular automata until arriving at a definition that is more flexible than the standard one in the literature (e.g., no a priori constraints on the border state), but provably equivalent - the formalization includes constructions showing that quiescent or dead borders can always be imposed without changing the recognized language.</p>\n<p>This falls under \"Programming Languages, Models of Computation and Interaction → Automata\" in the CSLib contributing guide. I'd be interested in discussing whether (parts of) this could fit into CSLib - particularly the base definitions and classical constructions. Happy to adapt style/structure to CSLib conventions if there is interest.</p>\n<p>Note: while the constructions and proof strategies are my own, the Lean proof engineering was heavily AI-assisted.</p>",
        "id": 575199505,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1771800935
    },
    {
        "content": "<p>I think integrating this will take some time. Firstly the definitions might have to be generalized to use cslib's definition of LTSes. Secondly it is 9300 lines. Thirdly, there is a lot of golfing and simplication that's bound to be necessary with any AI assistted development</p>",
        "id": 575201499,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771802523
    },
    {
        "content": "<blockquote>\n<p>Thirdly, there is a lot of golfing and simplication that's bound to be necessary with any AI assistted development</p>\n</blockquote>\n<p>That is very true, and I already did some code golfing (partially AI assisted). There are some proofs though which are just grind (that Lean's <code>grind</code> cannot handle), where the literature just leaves the details to the reader (for example in theorem 3.2 <a href=\"https://www.sciencedirect.com/science/article/pii/0304397588900400\">here</a> - which is not part of this project). I believe that without AI assistance it might be very difficult to formalize such proofs.</p>",
        "id": 575202335,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1771803366
    },
    {
        "content": "<p>Depends on the time frame. Given that that an AI can generate (or assist with generating) these proofs in 9000 lines, I would put this in the realm of 2 months with minimal to no AI use.</p>",
        "id": 575204181,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771805214
    },
    {
        "content": "<p>The key thing is finding good definitions that integrate well with CSLib. that will take more time.</p>",
        "id": 575204219,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771805236
    },
    {
        "content": "<blockquote>\n<p>I would put this in the realm of 2 months with minimal to no AI use.</p>\n</blockquote>\n<p>do you mean full time? :)</p>",
        "id": 575204380,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1771805360
    },
    {
        "content": "<blockquote>\n<p>The key thing is finding good definitions that integrate well with CSLib. that will take more time.</p>\n</blockquote>\n<p>I'm wondering, isn't that also a compromise on how these definitions are used in the literature? For cellular automata there is research for all kinds of variations (different neighborhoods, 1D vs 2D, different acceptance times and positions). It is very difficult and maybe not even practical to have an abstraction that can deal with all these variations and sometimes it might be simpler to have copies and some bridges to transfer results.</p>",
        "id": 575205193,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1771806278
    },
    {
        "content": "<p>The literature can afford to play fast and loose with results. We need to build a library. That means building something whose parts fit together</p>",
        "id": 575209192,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771809210
    },
    {
        "content": "<p>Btw, I heard about your thesis talk. All the best</p>",
        "id": 575541828,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1771939894
    }
]