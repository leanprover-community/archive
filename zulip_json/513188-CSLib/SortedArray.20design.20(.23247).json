[
    {
        "content": "<p>Why reinvent Finvecs from mathlib?</p>",
        "id": 565376244,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766674737
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SortedArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">array</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">sorted</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"w\"> </span><span class=\"n\">j</span>\n</code></pre></div>",
        "id": 565376573,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766674893
    },
    {
        "content": "<p><del>Also docstring comments only seem to work on top level declarations at the moment</del></p>",
        "id": 565376596,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766674920
    },
    {
        "content": "<p>Lean is complaining about your use of <code>where</code> in the first place</p>",
        "id": 565376796,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766675097
    },
    {
        "content": "<p>Another thing : you can save some effort with sorting if you count List.get calls as unit calls. Then you have sorted lists as well as all the List API including <code>List.Sorted</code>  : <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Deprecated/Sort.html#List.Sorted\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Deprecated/Sort.html#List.Sorted</a></p>",
        "id": 565376941,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766675256
    },
    {
        "content": "<p>Also core already has binary search on arrays : <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Array/BinSearch.html#Array.binSearch\">https://leanprover-community.github.io/mathlib4_docs/Init/Data/Array/BinSearch.html#Array.binSearch</a></p>",
        "id": 565377431,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766675841
    },
    {
        "content": "<p>Please read the content of the PR.</p>",
        "id": 565377577,
        "sender_full_name": "Sorrachai Yingchareonthawornchai",
        "timestamp": 1766676026
    },
    {
        "content": "<p>I have  already read and made review comments</p>",
        "id": 565377643,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766676110
    },
    {
        "content": "<p>Also Nat indexing would make your array potentially infinite and then it would just be a stream which is also defined in mathlib.</p>",
        "id": 565377668,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766676146
    },
    {
        "content": "<p>The indexing proof obligations are really not a big issue</p>",
        "id": 565377840,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766676348
    },
    {
        "content": "<p>There is a whole tactic for that <code>get_elem_tactic</code></p>",
        "id": 565377865,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766676367
    },
    {
        "content": "<p>In the future let's try to not veer too far off the topic of the thread (a specific problem adding a docstring), but since the discussion has started, I think we do need to discuss the design of <code>SortedArray</code> in this PR. </p>\n<p>My first question is how this fits in with <a href=\"https://github.com/leanprover/cslib/pull/165\">cslib#165</a>, where you defined operations on lists. We should standardize on these modules working over the same types. I agree with <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> that, especially given that there is already binary search in core, it doesn't seem to be too much of a burden to do this over arrays (or lists?).</p>",
        "id": 565378419,
        "sender_full_name": "Chris Henson",
        "timestamp": 1766676989
    },
    {
        "content": "<p>I tried it a bit using an array in the core; I think the proof becomes quite complex quickly (since more invariants are needed to verify the array index). If experts know a better way to write proofs using array in the core, I am fine with that. The principle here is that I want the analysis to be as simple as possible.  I cannot think a simpler way than this. My feeling is that objects in the core are not designed to aid analysis and proofs.</p>\n<p>If one insists on writing proofs on the core, I am happy to do so in a separate PR. One way to implement this strategy is to reduce this function to the form of the array representation. But if someone comes up with a direct proof that is as simple as this function representation, I am fine with that.</p>",
        "id": 565379900,
        "sender_full_name": "Sorrachai Yingchareonthawornchai",
        "timestamp": 1766678877
    },
    {
        "content": "<p>TimeM in general is a way to keep track of time complexity. In the analysis of binary search, I track only the number of array accesses, which is equal to the number of three-way comparisons (&lt;, =, &gt;). It is not hard to verify that it tracks correctly.</p>",
        "id": 565379992,
        "sender_full_name": "Sorrachai Yingchareonthawornchai",
        "timestamp": 1766679049
    },
    {
        "content": "<p>For a case study, <a href=\"https://www.researchgate.net/publication/238170147_A_Verification_of_Binary_Search\">this paper</a> illustrates formalization efforts for binary search. For me, using Lean to formalize binary search with functional array has been relatively easy and fun. Not sure if I need to write a technical report on this. But for sure, using an array in the core would not be as clean.</p>",
        "id": 565380969,
        "sender_full_name": "Sorrachai Yingchareonthawornchai",
        "timestamp": 1766680787
    },
    {
        "content": "<p>It’s a paper explaining verifun. Binary search is a good case study. It is fairly normal in PL and verification papers to choose basic examples for two reasons : formal verification (even of seemingly simple things) can be incredibly hard. This was even more so in 2002. There is usually little room in the paper to explain complicated examples. Further that would defeat the purpose of a case study, which is to showcase the tool itself.</p>",
        "id": 565381161,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766681045
    },
    {
        "content": "<p>I don’t immediately see if it would translate well to lean. Further my objection is not to using Lean Array. It is to not using Finvecs or streams for which the API already exists. It’s about reinventing definitions and (more so) notations that already exist.</p>",
        "id": 565381239,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766681192
    },
    {
        "content": "<p>I am in full agreement with Shreyas. We have plenty of existing definitions like <code>FinVec</code>, <code>Array</code>, etc. that are compatible with the <code>TimeM</code> notion. We should pick one and standardize on it for this area of CSLib.</p>",
        "id": 565381943,
        "sender_full_name": "Chris Henson",
        "timestamp": 1766682097
    },
    {
        "content": "<p>I realized I have permission to move messages within this channel (thanks whoever set that up!) so have moved these design questions into a separate topic.</p>",
        "id": 565387049,
        "sender_full_name": "Chris Henson",
        "timestamp": 1766690140
    },
    {
        "content": "<p>One small suggestion on top of all else above: when making a PR it is better to use a non-main branch of your fork. Otherwise you risk adding the commits of this PR to all future PRs</p>",
        "id": 565391887,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766698312
    },
    {
        "content": "<p>and I just noticed that <code>size := n</code> makes no sense here. When initialised there is no guarantee that <code>size = n</code>. All it does is set <code>size</code> to <code>n</code> if no one supplies a different value.</p>",
        "id": 565391910,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766698344
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/513188-CSLib/topic/SortedArray.20design.20.28.23247.29/near/565391887\">said</a>:</p>\n<blockquote>\n<p>One small suggestion on top of all else above: when making a PR it is better to use a non-main branch of your fork. Otherwise you risk adding the commits of this PR to all future PRs</p>\n</blockquote>\n<p>It is also nice for the reviewers because it is easier to push a commit to the PR directly when it's not made from the main branch.</p>",
        "id": 565392572,
        "sender_full_name": "Chris Henson",
        "timestamp": 1766699579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/513188-CSLib/topic/SortedArray.20design.20.28.23247.29/near/565376573\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SortedArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">array</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">sorted</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"w\"> </span><span class=\"n\">j</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This is just <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderHom#doc\">docs#OrderHom</a> Nat α</p>",
        "id": 565393601,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1766701164
    },
    {
        "content": "<p><code>Fin size</code> not <code>Nat</code>, but essentially yes</p>",
        "id": 565393789,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766701578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/513188-CSLib/topic/SortedArray.20design.20.28.23247.29/near/565393601\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/513188-CSLib/topic/SortedArray.20design.20.28.23247.29/near/565376573\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SortedArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">array</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">sorted</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"w\"> </span><span class=\"n\">j</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This is just <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderHom#doc\">docs#OrderHom</a> Nat α</p>\n</blockquote>\n<p>I thought of suggesting this, but <code>LinearOrder</code> seemed like a complication? I'd also just rather work with arrays/lists if it's not significantly more complex for consistency with other modules.</p>",
        "id": 565394035,
        "sender_full_name": "Chris Henson",
        "timestamp": 1766701952
    },
    {
        "content": "<p>Honestly I think with mvcgen that would be the best way to go</p>",
        "id": 565394050,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766701991
    },
    {
        "content": "<p>But as this PR stands, it still needs quite a bit of fixing (see above). For one thing, I believe indices can be <code>Fin</code> without too much effort.</p>",
        "id": 565394056,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766702012
    },
    {
        "content": "<p>If anything, it is a red flag if we cannot prove the side conditions (note the type of <code>lo</code> in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.binSearchAux#doc\">docs#Array.binSearchAux</a> )</p>",
        "id": 565394071,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766702057
    },
    {
        "content": "<p>Another broader point:  I think we need to have a <code>TimeMonad m</code> typeclass for a given monad m</p>",
        "id": 565394129,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766702145
    },
    {
        "content": "<p>Instead of a single <code>TimeM</code> monad</p>",
        "id": 565394136,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766702162
    },
    {
        "content": "<p>Because there is no reason this binary search can only run in the Time Monad. I just don't want to tinker with this until my Free monad stuff is done which will be around the end of the holidays</p>",
        "id": 565394146,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766702177
    },
    {
        "content": "<p>Can I make commits to this PR somehow? I ran into something weird called \"internal exception <a href=\"https://github.com/leanprover-community/mathlib4/pull/3\">#3</a>\"</p>",
        "id": 565405229,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766720939
    },
    {
        "content": "<p>which incredibly happens when a proof seems to go through (tried <code>done</code>)</p>",
        "id": 565405303,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766721020
    },
    {
        "content": "<p><code>internal exception #3</code> is the complete error message</p>",
        "id": 565405340,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766721062
    }
]