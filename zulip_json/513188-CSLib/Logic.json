[
    {
        "content": "<p>Starting a channel for general discussion of logic development in cslib (hope that's appropriate).</p>",
        "id": 543285188,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1759749913
    },
    {
        "content": "<p>My PR on natural deduction <a href=\"https://github.com/leanprover/cslib/pull/66\">cslib#66</a> is finally ready for review, I refactored it significantly so that deduction trees are defined for minimal logic (which matches more nicely with computational applications), and derivability/equivalence are relative to a <code>Theory</code> (set of propositions), which will make a more general semantic completeness result easy, as well as letting us add intuitionistic &amp; classical principles to the logic. Feedback appreciated!</p>",
        "id": 543285829,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1759750072
    },
    {
        "content": "<p>If this is CSLib specific conversation, it should probably be moved to that channel. Also you can link you can link to PRs like this: <a href=\"https://github.com/leanprover/cslib/pull/66\">cslib#66</a></p>",
        "id": 543312265,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759756714
    },
    {
        "content": "<p>oops my mistake, of course — should i open a topic there? who can move it?</p>",
        "id": 543315776,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1759757451
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"516743\" href=\"/#narrow/channel/516743-computer-science/topic/cslib.3A.20Logics\">#computer science &gt; cslib: Logics</a> by <span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span>.</p>",
        "id": 543455218,
        "sender_full_name": "Notification Bot",
        "timestamp": 1759819865
    },
    {
        "content": "<p>Moved. :)</p>",
        "id": 543455243,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759819874
    },
    {
        "content": "<p>Nice! I don't have a specific comment, but wanted to ask this about \"Logic in CSLib \" for a while already: do we have a plan for accommodating multiple (very many?) different logics (or different proof systems for the same logic) and how they relate? So for example will we later also have natural deduction for First-Order Logic and will that formally extend the Propositional system in some way?<br>\nOr suppose <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span> I want to do a specific modal logic, do I roll my own <code>Proposition</code> type for modal formulas and <code>Derivation</code> from scratch each time or can I somehow extend the types for the propositional system?</p>\n<p>I think this is known as the <a href=\"https://en.wikipedia.org/wiki/Expression_problem\">Expression_problem</a> and maybe my question is just whether people have thought about how to \"solve\" it in Lean.</p>",
        "id": 543463200,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1759822881
    },
    {
        "content": "<p>Yes, at least for me, the ideal vision for CSLib is exactly what you describe. However, as far as I know, there's no concrete roadmap for it just yet.</p>",
        "id": 543545651,
        "sender_full_name": "Maximiliano Onofre Martínez",
        "timestamp": 1759846982
    },
    {
        "content": "<p>I think that would be ideal, yes, but my two cents is that I feel there is a non-trivial tradeoff between generality in this sort of way and how closely things stick to computer science. </p>\n<p>For example, the <a href=\"https://github.com/FormalizedFormalLogic/Foundation\">Formalised Formal Logic</a> people have done a very good job of being modular — as I understand it, something like \"conjunction elimination\" is a typeclass on a deduction system, so results about conjunction elimination are valid for any deduction system which has it as a rule — but they (predominantly) use a Hilbert-style calculus. I started here with natural deduction because of how closely it sticks to the lambda calculus, and so it felt appropriate for inclusion specifically in a <em>computer science</em> library, even if it isn't the right formalism to prove things in full mathematical generality.</p>\n<p>All that being said, some machinery along the lines of, \"I want to define a type of derivations which is <code>NJ.Derivation</code> + some extra rules\" would be great, and I am very open to reworking my PR to include it if someone knows how!</p>",
        "id": 543577843,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1759855266
    },
    {
        "content": "<p>Also, I just added a note about a small design question to my PR <a href=\"https://github.com/leanprover/cslib/pull/66\">cslib#66</a> — whether derivations should be parametric in a theory, giving them two kinds of axiom rules. I'd love some feedback here or there! (ping <span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> as it's probably you who will review it)</p>",
        "id": 543583452,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1759856880
    },
    {
        "content": "<p>I much agree that there is a trade-off between generality and usability of the instances of the general thing (be it formula or derivation types). And typeclasses as used in FFL can get quite far. I also think it might make sense to wait until a bunch of different logics are in cslib and how they are used by other areas before trying to find a general definition of what \"a logic\" is. But maybe not wait too long until all hope of unifying things is gone <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 543606330,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1759865106
    },
    {
        "content": "<p>Related to this, <span class=\"user-mention\" data-user-id=\"315693\">@Ramy Shahin</span> gave a talk about a possible approach to the expression problem in Lean at TYPES2025, see  <a href=\"https://msp.cis.strath.ac.uk/types2025/abstracts/TYPES2025_paper64.pdf\">paper</a> and <a href=\"https://www.youtube.com/watch?v=vQS8kj8kqr8\">video</a>. I do not want to suggest to make cslib depend on this (still quite experimental) code, but for the long term future it might be a nice inspiration.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"vQS8kj8kqr8\" href=\"https://www.youtube.com/watch?v=vQS8kj8kqr8\"><img src=\"https://uploads.zulipusercontent.net/cd9d7dd3b276bedbc02d4a819137c0a41464be29/68747470733a2f2f692e7974696d672e636f6d2f76692f765153386b6a386b7172382f6d7164656661756c742e6a7067\"></a></div>",
        "id": 543607164,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1759865417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"931332\">Thomas Waring</span> <a href=\"#narrow/channel/513188-CSLib/topic/Logic/near/543583452\">said</a>:</p>\n<blockquote>\n<p>Also, I just added a note about a small design question to my PR <a href=\"https://github.com/leanprover/cslib/pull/66\">cslib#66</a></p>\n</blockquote>\n<p>The more I think about this the less I'm satisfied with the current presentation — I've closed the PR &amp; I'll put up a better version in pieces (sorry to anyone who spent time reviewing it, the new one should be relatively similar)</p>",
        "id": 543708839,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1759918490
    },
    {
        "content": "<p>For the record, the plan is that yes, we're very interested in finding general and reusable patterns across different logics. My plan for now is very simple: I'd like us to have at least 2 different logics and start the discussion from there. :)<br>\nI see a first likely candidate for generalisation in the concept of logical equivalence.</p>",
        "id": 543713192,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1759920019
    },
    {
        "content": "<p>This topic is relevant to lambda calculi too, but I don't have a great answer. I have plans to build something that generates lambda calculus boilerplate (similar to Austosubst2), but this is a pretty big undertaking that I don't plan to finish anytime soon, and I'm not sure that I want this to be a CSLib dependency.</p>",
        "id": 543715109,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759920621
    },
    {
        "content": "<p>Propositional logic definitions are now at <a href=\"https://github.com/leanprover/cslib/pull/89\">cslib#89</a> (once more with feeling!) — I'll add natural deduction in a follow up, this one is short so should easy the earlier burden on reviewers</p>",
        "id": 543720509,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1759922231
    },
    {
        "content": "<p>Hi all, finally got some bandwidth for logic, so I'd like to circle back to this. :)<br>\nLet's start from <a href=\"https://github.com/leanprover/cslib/pull/89\">cslib#89</a>. It looks really interesting, I'm just struggling a bit to distinguish what's a formalisation choice and what's in the original presentation (like representing bot as a possible member of the atoms and the use of <code>Theory</code>; which I like, it's pretty clever, just want to understand a bit). <span class=\"user-mention\" data-user-id=\"931332\">@Thomas Waring</span> could you maybe clarify and/or give a reference maybe?</p>",
        "id": 558512249,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1763666869
    },
    {
        "content": "<p>(Another reason for circling back now is that I think we've accumulated some relevant experience from other simpler parts in cslib.)</p>",
        "id": 558512439,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1763666933
    },
    {
        "content": "<p>Great! I agree that there are a lot of non-obvious choices to be made, &amp; I'm very open to discussion &amp;/or reworking what I've got as we go along. Probably the reference which is closest to how I've presented it is <a href=\"https://disi.unitn.it/~bernardi/RSISE11/Papers/curry-howard.pdf\">Sørensen &amp; Urzyczyn's lecture notes</a>, but I don't know of anywhere doing it exactly like I have, mostly because the needs of formalisation are a bit orthogonal to the usual way we write about proof theory imo.</p>\n<p>I'd say most of the things you mention fall under formalisation choices: I'll try to write some more clarifying documentation, but to answer the things you raise here:</p>\n<ul>\n<li>I wanted to capture minimal logic (intuitionistic without efq) because that's the one with the most obvious / direct computational content — essentially it <em>is</em> STLC with sums and products.</li>\n<li>Once you're in minimal logic, either you don't have falsum, or it behaves exactly like an atom (ie there are no rules for it), so it seemed reasonable to have it be optional for a given language of propositions. In the case that it is present, we have <code>⊥ = atom ⊥</code> definitionally, so it doesn't really add much overhead i think.</li>\n<li>The use of <code>Theory</code> is a bit less obvious. Usually on pen-and-paper you switch between minimal / intuitionistic / classical by adding and removing rules — since we don't have an easy way (cf above discussion) to do this as is stands, the best solution seemed to be to formulate the extra deduction rules as implications, and allow appealing to them as axioms.</li>\n<li>Another point in favour of <code>Theory</code> is it makes it easy to define \"equivalence modulo some axioms\", which is nice in itself and helps with developing semantics.</li>\n</ul>",
        "id": 558529499,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1763673042
    },
    {
        "content": "<p>Oh I didn't realize you were working from that, it's just a few feet away on my bookshelf. This is jumping way ahead, but if SOL is on your radar for the future, I would love to be able to formalize Wadler's <em><a href=\"https://homepages.inf.ed.ac.uk/wadler/papers/gr2/gr2.pdf\">The Girard-Reynolds Isomorphism</a></em>. IIRC those notes do not go into the detail of the each direction of transformations between System F and second order logic. It would be a fun milestone of the library to see that our lambda calculus and logic developments line up in this way.</p>",
        "id": 558540006,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763676968
    },
    {
        "content": "<p>nice, that's my bad i meant to put it in the references earlier. i found that paper kind of confusing to read when i looked at it (ages ago) but the idea is definitely interesting (all the more reason to formalise!). SOL is possibly beyond my lean abilities (i've been steering clear of free/bound variables for reasons you can probably understand), but that circle of ideas is definitely in my wheelhouse — realisability / reducibility / logical relations etc</p>",
        "id": 558542827,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1763678275
    },
    {
        "content": "<p>Hmm, I see. Next on my list is to add lambda calculus in the well scoped style (the type of Terms indexed by the number of free variables) which should be easier to use than the locally nameless System F I've done so far. If I make that a sufficiently good example to work from for simple types, I think it would be not so hard to transfer over the binding aspect. (A bridge to cross when we reach it...)</p>",
        "id": 558543860,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763678803
    },
    {
        "content": "<p>Re binding: I've been steering clear of polymorphism/variables in linear logic for exactly the same reason, would love to settle together on a 'good' way to do it in the future.</p>",
        "id": 558734307,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1763752149
    },
    {
        "content": "<p>My inclination is that well-scoped indices as I mention above are probably what we want. I have in my mind to make a Lean implementation of Autosubst that would allow you to have all the substitution/variable lemmas generated for you, but this is a big project. Maybe in the meantime I can just do simple types and polymorphism \"by hand\" as an example you can use.</p>",
        "id": 558736833,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763753123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"931332\">Thomas Waring</span> <a href=\"#narrow/channel/513188-CSLib/topic/Logic/near/558529499\">said</a>:</p>\n<blockquote>\n<p>Great! I agree that there are a lot of non-obvious choices to be made, &amp; I'm very open to discussion &amp;/or reworking what I've got as we go along. Probably the reference which is closest to how I've presented it is <a href=\"https://disi.unitn.it/~bernardi/RSISE11/Papers/curry-howard.pdf\">Sørensen &amp; Urzyczyn's lecture notes</a>, but I don't know of anywhere doing it exactly like I have, mostly because the needs of formalisation are a bit orthogonal to the usual way we write about proof theory imo.</p>\n<p>I'd say most of the things you mention fall under formalisation choices: I'll try to write some more clarifying documentation, but to answer the things you raise here:</p>\n<ul>\n<li>I wanted to capture minimal logic (intuitionistic without efq) because that's the one with the most obvious / direct computational content — essentially it <em>is</em> STLC with sums and products.</li>\n<li>Once you're in minimal logic, either you don't have falsum, or it behaves exactly like an atom (ie there are no rules for it), so it seemed reasonable to have it be optional for a given language of propositions. In the case that it is present, we have <code>⊥ = atom ⊥</code> definitionally, so it doesn't really add much overhead i think.</li>\n<li>The use of <code>Theory</code> is a bit less obvious. Usually on pen-and-paper you switch between minimal / intuitionistic / classical by adding and removing rules — since we don't have an easy way (cf above discussion) to do this as is stands, the best solution seemed to be to formulate the extra deduction rules as implications, and allow appealing to them as axioms.</li>\n<li>Another point in favour of <code>Theory</code> is it makes it easy to define \"equivalence modulo some axioms\", which is nice in itself and helps with developing semantics.</li>\n</ul>\n</blockquote>\n<p>Thanks, that's very helpful! I'll reflect a bit on this after I'm done with my current PR to revise CLL equivalences into proof-relevant ones.</p>",
        "id": 558916572,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1763925891
    },
    {
        "content": "<p>By the way, I'm doing stuff like this an awful lot:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">⫠</span><span class=\"w\"> </span><span class=\"bp\">::ₘ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">⫠</span><span class=\"w\"> </span><span class=\"bp\">::ₘ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::ₘ</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">b</span><span class=\"bp\">⫠</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"bp\">⫠</span><span class=\"o\">}))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"c1\">-- whatever rewriting of the sequent in the goal I need</span>\n<span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n<span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Proof</span><span class=\"bp\">.</span><span class=\"n\">tensor</span><span class=\"w\"> </span><span class=\"c1\">-- whatever rule I need to apply here</span>\n</code></pre></div>\n<p>Is there a more elegant way to express 'apply this rule by rewriting the goal with this, and that's fine because grind says it'? :-)</p>",
        "id": 558916694,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1763925998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Logic/near/558916572\">said</a>:</p>\n<blockquote>\n<p>Thanks, that's very helpful!</p>\n</blockquote>\n<p>Great! I think I addressed the main choice but let me know if there's anything else I can explain further</p>",
        "id": 558916971,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1763926277
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/513188-CSLib/topic/Logic/near/558916694\">said</a>:</p>\n<blockquote>\n<p>By the way, I'm doing stuff like this an awful lot:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">⫠</span><span class=\"w\"> </span><span class=\"bp\">::ₘ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">⫠</span><span class=\"w\"> </span><span class=\"bp\">::ₘ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::ₘ</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">b</span><span class=\"bp\">⫠</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"bp\">⫠</span><span class=\"o\">}))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"c1\">-- whatever rewriting of the sequent in the goal I need</span>\n<span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n<span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Proof</span><span class=\"bp\">.</span><span class=\"n\">tensor</span><span class=\"w\"> </span><span class=\"c1\">-- whatever rule I need to apply here</span>\n</code></pre></div>\n<p>Is there a more elegant way to express 'apply this rule by rewriting the goal with this, and that's fine because grind says it'? :-)</p>\n</blockquote>\n<p>Hmm you can golf slightly as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">⫠</span><span class=\"w\"> </span><span class=\"bp\">::ₘ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">⫠</span><span class=\"w\"> </span><span class=\"bp\">::ₘ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::ₘ</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">b</span><span class=\"bp\">⫠</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"bp\">⫠</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"o\">]</span>\n<span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Proof</span><span class=\"bp\">.</span><span class=\"n\">tensor</span><span class=\"w\"> </span><span class=\"c1\">-- whatever rule I need to apply here</span>\n</code></pre></div>\n<p>but more generally we should probably have a rule along the lines of eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk.copy#doc\">docs#SimpleGraph.Walk.copy</a> — when the type depends on data you have API to transfer elements along equalities of the index (not sure if I'm getting all the terminology right lol)</p>",
        "id": 558917152,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1763926448
    },
    {
        "content": "<p>Thanks!<br>\nRe the rule, yeah, I tried to write it, but it's not working as well as I wanted... I'll submit a PR as soon as I'm done fixing everything.</p>",
        "id": 558917238,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1763926501
    },
    {
        "content": "<p>Okay fair enough :) honestly I have been cheating and using weakening instead of defining that API (ie making grind prove <code>⊆</code> instead of <code>=</code>), but that (importantly!) doesn't apply to your case...</p>",
        "id": 558917365,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1763926615
    },
    {
        "content": "<p>I am not following what you want from grind. Any chance you have a full example in a branch I could work with?</p>",
        "id": 558917603,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763926831
    },
    {
        "content": "<p>I am guessing the problem here is that this is in the middle of a proof, rather than something terminal <code>grind</code> can finish?</p>",
        "id": 558917777,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763927009
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/513188-CSLib/topic/Logic/near/558917603\">said</a>:</p>\n<blockquote>\n<p>I am not following what you want from grind. Any chance you have a full example in a branch I could work with?</p>\n</blockquote>\n<p>Correct. Grind is doing wonders. It's apply that can't see that the goal is a 'simple' series of multiset rewrites away. (I'm not saying it should, it's just my problem here.)</p>",
        "id": 558917869,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1763927120
    },
    {
        "content": "<p>The general pattern I follow is trying to get everything grind needs to use at the end of a proof branch. Sometimes you can use <code>suffices</code> to move things around a bit, or use <code>have</code> to place a general theorem that <code>grind</code> can access. If you point out any of these in a review I'm happy to try golfing.</p>",
        "id": 558918122,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763927396
    },
    {
        "content": "<p>I think I'm <em>almost</em> there. Here's my current WIP: <a href=\"https://github.com/leanprover/cslib/blob/new-logic/Cslib/Logics/LinearLogic/CLL/Basic.lean\">https://github.com/leanprover/cslib/blob/new-logic/Cslib/Logics/LinearLogic/CLL/Basic.lean</a></p>\n<p>Basically I've rewritten <code>Proof</code> to use multisets directly (that's what most people do on paper nowadays anyway, and <code>grind</code> now makes working with this decent enough), and adapted all proofs of equivalences to be proof-relevant (I still have two small sorrys).</p>\n<p>Feedback/help welcome. :-)</p>\n<p>I feel this is well-behaved/simple enough that once we're done we could make a typeclass for the \\Downarrow notation and the \\===\\Downarrow equivalence notation (maybe it should just be \\===, but for now I'm trying to be explicit where I want actual types).</p>",
        "id": 558920057,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1763929347
    },
    {
        "content": "<p><code>grind</code> is having trouble doing proofs by itself, maybe I should annotate something more..</p>\n<p>Note also I'm annotating <code>Multiset</code> stuff. Maybe we wanna have a <code>Data/Multiset.lean</code> thing where we put this kind of stuff until mathlib annotates multiset defs/theorems for grind.</p>",
        "id": 558920145,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1763929418
    },
    {
        "content": "<p>I'm seeing some errors trying to build that branch that don't look <code>grind</code> related? Maybe let's not provision a file for it (you convinced me of this last time I suggested something similar!), but gathering together multiset <code>grind</code> annotations somewhere sounds like a good idea.</p>",
        "id": 558921508,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763930543
    },
    {
        "content": "<p>Yes look only at that file, I still gotta fix the rest. :⁠-⁠)</p>",
        "id": 558921571,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1763930607
    },
    {
        "content": "<p>Two small comments: I would be happy if proof sequents in general will be Multisets (in the PDL project we used Lists but mostly just because the API was nicer, Multisets feels more like \"the right thing to do\", e.g. because of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.IsDershowitzMannaLT#doc\">docs#Multiset.IsDershowitzMannaLT</a>). Second, I was wondering about how much notation CSlib wants to use/occupy and whether that can clash with mathlib or lean core: the <code>Proof</code> notation <code>⇓</code> is also used in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Do/PostCond.html#Std.Do.%C2%ABterm_%E2%87%93_=%3E_%C2%BB\"><code>Std.Do.PostCond</code></a>. Does the \"scoped\" mean this will not be a problem? (Hypothetically someone some day may want to write an imperative program working with <code>Proof</code>s <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> )</p>",
        "id": 558970150,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1763970928
    },
    {
        "content": "<p>Regarding notation: we have a convention (that we test for) that we do not add any declarations to a new top level namespace. This includes notation, meaning that all our notations are scoped. This isn't a guarantee of non-conflict with Mathlib/core notations, but covers a number of common unscoped notations. In your example above for instance, maybe there is still a problem of you want both scopes open. At minimum, there is a test of importing both Mathlib and CSLib.</p>",
        "id": 558995863,
        "sender_full_name": "Chris Henson",
        "timestamp": 1763978194
    },
    {
        "content": "<p>This is basically my concern in <a href=\"https://github.com/leanprover/cslib/issues/23\">https://github.com/leanprover/cslib/issues/23</a>. Suggestions/solutions are highly welcome. Notations are bound to be 'duplicated'. In this specific example, <code>⇓</code> is also a common symbol for termination in operational semantics and barbs in concurrency.</p>",
        "id": 559005415,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1763980650
    },
    {
        "content": "<p>Re the sequents: I agree multisets are now pretty nice to work with, yes. IIRC in some sequent calculi order is actually important, so there List will be the natural choice.</p>",
        "id": 559005655,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1763980719
    },
    {
        "content": "<p>Right, for substructural logics the sequents should be lists. Another edge case where <code>List</code> works better than <code>Multiset</code> is when we want to build formulas based on sequents, for example taking the conjunction or disjunction of all formulas in a <code>Multiset</code>-sequent would be noncomputable / need choice, but with a <code>List</code>-sequent is easy.</p>",
        "id": 559010194,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1763981885
    },
    {
        "content": "<p>Here's my PR: <a href=\"https://github.com/leanprover/cslib/pull/187\">https://github.com/leanprover/cslib/pull/187</a><br>\nPlease have a look, maybe we can make grind do better. Also, where should I put the grind annotations for Multiset? Mmh..</p>",
        "id": 559134141,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764012466
    },
    {
        "content": "<p>I don't think I've looked at these files previously. I am a bit more fundamentally concerned with the way it constructs data (non-<code>Prop</code> types) with tactics.</p>",
        "id": 560044077,
        "sender_full_name": "Chris Henson",
        "timestamp": 1764028873
    },
    {
        "content": "<p>Me too, but I couldn't figure out how to do it without tactics.. :-)<br>\nUsing tactics gives a very similar approach to the one followed on paper.</p>",
        "id": 560098773,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764061133
    },
    {
        "content": "<p>I ran into similar issues, though possibly for NJ it's easier to avoid bc the rules are a bit more relaxed. <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> you'll know better but as I understand it <em>some</em> uses of tactics for data are generally okay — like <code>refine</code> / <code>apply</code> — and improve readability, but some aren't — I'm guessing steering clear of <code>rw</code> is a start, but is there a reference / some documentation on this issue?</p>",
        "id": 560128240,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1764069963
    },
    {
        "content": "<p>I haven't tried hard to work this out but I <em>think</em> a lot of the problematic tactic use could be avoided with a functional <code>Proof.copy</code> API: at very least that could avoid <code>rw</code>ing the sequent in the goal. You can see a bit of this at work in <a href=\"https://github.com/leanprover/cslib/pull/91\">cslib#91</a> — I don't have a <code>copy</code> but I do have weakening, and often I avoid a <code>rw</code> by convincing lean that the sequent I prove is a subset of the sequent I want, which suffices in the non-linear setting</p>",
        "id": 560129213,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1764070283
    },
    {
        "content": "<p>Yes, <code>rw</code> is particularly troublesome. I'm not actually not sure of docs about this. I don't follow the last bit, can you explain what <code>Proof.copy</code> is?</p>",
        "id": 560151078,
        "sender_full_name": "Chris Henson",
        "timestamp": 1764076512
    },
    {
        "content": "<p>Right I see. The copy idea is pretty rough, based on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk.copy#doc\">docs#SimpleGraph.Walk.copy</a> — I'll write a mwe some time but the idea is roughly this: say in Fabrizio's example we want to <code>apply Proof.tensor</code>, but the goal is something like <code>⇓ a⫠ ::ₘ b⫠ ::ₘ {b ⊗ a}</code>, whereas the conclusion of the rule we want to apply is <code>⇓(a ⊗ b) ::ₘ (Γ + Δ)</code> — these are propeq but not defeq (I think), so using tactics we <code>rw</code> the goal to be what we want. I see now there actually is a rule doing what I want (though using tactics)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Proof</span><span class=\"bp\">.</span><span class=\"n\">sequent_rw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⇓</span><span class=\"n\">Γ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⇓</span><span class=\"n\">Δ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>The rough idea though is that we can push the use of <code>grind</code> etc inside the hypothesis <code>h</code>, so all the data is produced without tactics, and then cook up enough <code>simp</code> lemmas etc to make <code>sequent_rw</code> friendly to work with.</p>",
        "id": 560173880,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1764081914
    },
    {
        "content": "<p>I guess whether this helps or not depends on what problems actually arise from the use of tactics for data, which was why I asked about any docs / general intuition for why we try to avoid it</p>",
        "id": 560174184,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1764081995
    },
    {
        "content": "<p>I think can rewrite that <code>Proof.sequent_rw</code> to not use tactics. The intuition I have for why we do this is that tactics can unpredictability cause complicated terms that are hard to work with, <code>simp</code> and <code>rw</code> especially. I seem to recall a thread talking about how even <code>refine</code> can cause difficulties in some cases.</p>",
        "id": 560176122,
        "sender_full_name": "Chris Henson",
        "timestamp": 1764082429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/513188-CSLib/topic/Logic/near/560176122\">said</a>:</p>\n<blockquote>\n<p>I think can rewrite that <code>Proof.sequent_rw</code> to not use tactics</p>\n</blockquote>\n<p>right I think even <code>h ▸ p</code> would work? my intuition was similar (though i'd be interested to see how <code>refine</code> runs into trouble) — i think if we have enough API for <code>sequent_rw</code> that would make it easier to deal with, but the proof would be in the pudding i suppose</p>",
        "id": 560177283,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1764082685
    },
    {
        "content": "<p>You're getting where I wanted! But I didn't try enough to write a direct term.. :⁠-⁠)</p>\n<p>(Btw I should've probably cased sequent_rw differently.)</p>",
        "id": 560179520,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764083098
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"931332\">Thomas Waring</span> <a href=\"#narrow/channel/513188-CSLib/topic/Logic/near/560177283\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/513188-CSLib/topic/Logic/near/560176122\">said</a>:</p>\n<blockquote>\n<p>I think can rewrite that <code>Proof.sequent_rw</code> to not use tactics</p>\n</blockquote>\n<p>right I think even <code>h ▸ p</code> would work?</p>\n</blockquote>\n<p>Yes, exactly. I can make a pass later today through the PR and try to make this and other changes that as much as possible use terms instead of tactics.</p>",
        "id": 560215734,
        "sender_full_name": "Chris Henson",
        "timestamp": 1764092403
    },
    {
        "content": "<p>I've defined eta-expansion for CLL. <a href=\"https://github.com/leanprover/cslib/pull/198\">cslib#198</a></p>\n<p>This was useful to gain experience in rewriting conclusions as needed to build proofs (see the PR). I wonder if we could use <code>calc</code> in a smart way in this kind of <code>def</code>s (without entering <code>by</code>).</p>",
        "id": 561959497,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1764876532
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> <span class=\"user-mention\" data-user-id=\"422703\">@Malvin Gattinger</span>, regarding the goal of finding reusable patterns for different logics, I recently came across a paper from <a href=\"https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ITP.2024.28\">ITP 2024</a> that tackles this exact issue.</p>\n<p>They use a hierarchy of typeclasses (starting from a base <code>Pformula</code>) to manage different extensions like Coalition Logic, allowing them to reuse results and lemmas across different systems without code duplication. <span class=\"user-mention\" data-user-id=\"931332\">@Thomas Waring</span>, this might be worth a look for the design of your current PRs!</p>",
        "id": 570343661,
        "sender_full_name": "Maximiliano Onofre Martínez",
        "timestamp": 1769526076
    },
    {
        "content": "<p>Thanks, I'll read it, it sounds interesting!</p>\n<p>I've made some progress myself that covers another part of it, I hope to share it soon.</p>",
        "id": 570345012,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1769526390
    }
]