[
    {
        "content": "<p>cf. <a class=\"message-link\" href=\"/#narrow/channel/113486-announce/topic/Loom.3A.20framework.20for.20Multi.20Modal.20program.20verifiers.20in.20Lean/near/544200084\">#announce &gt; Loom: framework for Multi Modal program verifiers in Lean @ üí¨</a> </p>\n<p>I have to admit, I'm part of this lab (but I just joined, so no work from me in Loom yet).</p>\n<p>This is the discussion thread for Loom.</p>",
        "id": 544201781,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1760111283
    },
    {
        "content": "<p>Amazing. Are SMT proofs compiled into Lean or are they just blindly trusted <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 544205126,
        "sender_full_name": "(deleted)",
        "timestamp": 1760112324
    },
    {
        "content": "<p>If everything is verified by the Lean kernel then I'm using Loom</p>",
        "id": 544205181,
        "sender_full_name": "(deleted)",
        "timestamp": 1760112344
    },
    {
        "content": "<p>I think you can do both, based on working with Veil 1.0.  Proof reconstruction would be slower</p>",
        "id": 544211834,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760114668
    },
    {
        "content": "<p>Question : I already asked this once in a video chat and got a positive-ish but brief answer back then. So I‚Äôll ask again to hopefully get a detailed answer. It appears that one could in principle reason about resource usage by using the right kind of monad here. Possibly time and space complexity as well. Is this right?</p>",
        "id": 544212211,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760114817
    },
    {
        "content": "<p>Another question, slightly related : this seems like a good candidate language for use with CSLib. Is this so?</p>",
        "id": 544214147,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760115659
    },
    {
        "content": "<p>The main thing I intend to do in my PhD is formalising computational complexity, and apply the tools thus produced to CLRS. The resulting proofs may or may not enter CSLib</p>",
        "id": 544214600,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1760115828
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"511228\">Hu·ª≥nh Tr·∫ßn Khanh</span> <a href=\"#narrow/channel/113488-general/topic/Loom.20discussion/near/544205126\">said</a>:</p>\n<blockquote>\n<p>Amazing. Are SMT proofs compiled into Lean or are they just blindly trusted <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>\n</blockquote>\n<p>Loom uses the <code>auto</code> package for SMT, so <code>auto.smt</code> enables or disables SMT use, and <code>auto.smt.rconsProof</code> allows you to reconstruct the proof in pure Lean (assuming the SMT backend supports it)</p>",
        "id": 544215313,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1760116093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"598052\">Jeremy Tan</span> <a href=\"#narrow/channel/113488-general/topic/Loom.20discussion/near/544214600\">said</a>:</p>\n<blockquote>\n<p>The main thing I intend to do in my PhD is formalising computational complexity, </p>\n</blockquote>\n<p>Then we have something in common. Once you allow monadic reasoning with some notion of  ghost states, reasoning about computational complexity becomes feasible for many but not all computational models (i.e. not just a specific RAM model)</p>",
        "id": 544215538,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760116183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"511228\">Hu·ª≥nh Tr·∫ßn Khanh</span> <a href=\"#narrow/channel/113488-general/topic/Loom.20discussion/near/544205126\">said</a>:</p>\n<blockquote>\n<p>Amazing. Are SMT proofs compiled into Lean or are they just blindly trusted <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>\n</blockquote>\n<p>Hey! I guess your question has been responded already but let me add something. Loom is agnostic to the automation tactic which is called on produced goals. In Velvet we use lean auto and lean smt. The latter one supports proof reconstruction reducing TCB to Lean kernel. <br>\nYou can also dynamically link the automation tactic to grind or aesop too. In our latest experience grind solves almost all our goals. More information you can find in github README</p>",
        "id": 544220467,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1760118157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/Loom.20discussion/near/544212211\">said</a>:</p>\n<blockquote>\n<p>Question : I already asked this once in a video chat and got a positive-ish but brief answer back then. So I‚Äôll ask again to hopefully get a detailed answer. It appears that one could in principle reason about resource usage by using the right kind of monad here. Possibly time and space complexity as well. Is this right?</p>\n</blockquote>\n<p>Great question! We are doing some preliminary research in this direction. For example we have already verified complexity of merge sort. I hope soon we will release this part of project too</p>",
        "id": 544220745,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1760118284
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/Loom.20discussion/near/544214147\">said</a>:</p>\n<blockquote>\n<p>Another question, slightly related : this seems like a good candidate language for use with CSLib. Is this so?</p>\n</blockquote>\n<p>I think CSLib is not yet completely sure what framework to use. But as far as I know they might have done some experiments using Velvet <span aria-label=\"muscle\" class=\"emoji emoji-1f4aa\" role=\"img\" title=\"muscle\">:muscle:</span></p>",
        "id": 544220968,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1760118373
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690517\">Vladimir Gladstein</span> <a href=\"#narrow/channel/113488-general/topic/Loom.20discussion/near/544220745\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/Loom.20discussion/near/544212211\">said</a>:</p>\n<blockquote>\n<p>Question : I already asked this once in a video chat and got a positive-ish but brief answer back then. So I‚Äôll ask again to hopefully get a detailed answer. It appears that one could in principle reason about resource usage by using the right kind of monad here. Possibly time and space complexity as well. Is this right?</p>\n</blockquote>\n<p>Great question! We are doing some preliminary research in this direction. For example we have already verified complexity of merge sort. I hope soon we will release this part of project too</p>\n</blockquote>\n<p>Will it feature the ability to choose a custom cost model? In the CSLib presentations about Boole, it was mentioned that the cost model was fixed. In research level TCS, being able to count a selection of operations is very useful. Things like ‚ÄúThis procedure makes O(f(n)) matrix multiplication calls‚Äù and so we can connect things to the matrix multiplication constant (which we still only have upper and lower bounds for).</p>",
        "id": 544221462,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760118602
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/Loom.20discussion/near/544221462\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"690517\">Vladimir Gladstein</span> <a href=\"#narrow/channel/113488-general/topic/Loom.20discussion/near/544220745\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/Loom.20discussion/near/544212211\">said</a>:</p>\n<blockquote>\n<p>Question : I already asked this once in a video chat and got a positive-ish but brief answer back then. So I‚Äôll ask again to hopefully get a detailed answer. It appears that one could in principle reason about resource usage by using the right kind of monad here. Possibly time and space complexity as well. Is this right?</p>\n</blockquote>\n<p>Great question! We are doing some preliminary research in this direction. For example we have already verified complexity of merge sort. I hope soon we will release this part of project too</p>\n</blockquote>\n<p>Will it feature the ability to choose a custom cost model? In the CSLib presentations about Boole, it was mentioned that the cost model was fixed. In research level TCS, being able to count a selection of operations is very useful. Things like ‚ÄúThis procedure makes O(f(n)) matrix multiplication calls‚Äù</p>\n</blockquote>\n<p>Honestly, I cannot tell for sure at this point. But thanks for the question! We will definitely consider accounting for different cost models</p>",
        "id": 544221892,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1760118777
    },
    {
        "content": "<p>Another question : I recall that a key feature was the ability to prove functional equivalence between the imperative and functional definitions of a function, which makes the invariants nicer. Is this in one of the examples in the repository?</p>",
        "id": 544221948,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760118801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/Loom.20discussion/near/544221948\">said</a>:</p>\n<blockquote>\n<p>Another question : I recall that a key feature was the ability to prove functional equivalence between the imperative and functional definitions of a function, which makes the invariants nicer. Is this in one of the examples in the repository?</p>\n</blockquote>\n<p>Yes, you can check out chapter 8 of the paper and look for this file <a href=\"https://github.com/verse-lab/loom/blob/master/CaseStudies/Velvet/VelvetExamples/SpMSpV_Example.lean\">https://github.com/verse-lab/loom/blob/master/CaseStudies/Velvet/VelvetExamples/SpMSpV_Example.lean</a></p>",
        "id": 544222261,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1760118963
    },
    {
        "content": "<p>One more question: Where can I find Veil 2.0?</p>",
        "id": 544251418,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760132280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/Loom.20discussion/near/544251418\">said</a>:</p>\n<blockquote>\n<p>One more question: Where can I find Veil 2.0?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"542918\">@George P√Ærlea</span> ?</p>",
        "id": 544253854,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1760133470
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113488-general/topic/Loom.20discussion/near/544251418\">said</a>:</p>\n<blockquote>\n<p>One more question: Where can I find Veil 2.0?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"542918\">@George P√Ærlea</span> ?</p>",
        "id": 544253873,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1760133481
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> If you want to look at the version of Veil submitted along with the POPL paper, check out the <a href=\"https://github.com/verse-lab/veil/tree/popl26-artifact\"><code>popl26-artifact</code></a> branch in the Veil repo.</p>\n<p>That said, Veil 2.0 is not yet publicly released ‚Äî we are working on more features (and UX polish) compared to the POPL version and our plan is to release it in the new few weeks, hopefully by the end of the month.</p>\n<p>There will be a separate announcement about that <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 544262474,
        "sender_full_name": "George P√Ærlea",
        "timestamp": 1760138315
    },
    {
        "content": "<p>How does Loom compare/relate to <a href=\"http://std.do\">std.do</a> ?  And to iris-lean ?<br>\nI didn't have time to read the paper yet...</p>",
        "id": 544303935,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1760174707
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/113488-general/topic/Loom.20discussion/near/544303935\">said</a>:</p>\n<blockquote>\n<p>How does Loom compare/relate to <a href=\"http://std.do\">std.do</a> ?</p>\n</blockquote>\n<p>Hey! In the announcement tried briefly mention the biggest difference between Loom and <a href=\"http://std.do\">std.do</a>: In Loom we focus on intrinsic (annotations based) proofs whereas <a href=\"http://std.do\">std.do</a> develops the whole set of tactics and a custom proof-mode to reason about monadic computations extrinsically. <br>\nBroadly speaking, on the metatheory level Loom complements <a href=\"http://std.do\">std.do</a> with first 4 <em>new</em> features mentioned in announcement: multi-modal verification, intrinsic proof style, reasoning about termination and monad transformer for non-determinism. Please refer to the announcement for more details. <br>\nThat's said two frameworks are not compatible at this point, but we are exploring ways for possible collaboration. </p>\n<blockquote>\n<p>And to iris-lean ?</p>\n</blockquote>\n<p>As far as I am concerned, the main goal of iris-lean is optimising for iris level of generality. In Loom, our main concern is automation. For example, Loom doesn't support concurrency at this point, but VCs it generates are SMT-friendly. Of course, we are working towards framework generalisations, but our main priority is reducing manual proof effort to minimum.</p>",
        "id": 544331160,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1760198304
    },
    {
        "content": "<p>So exciting! I saw a demo of this a couple months ago and I've been waiting to play around with it ever since.</p>\n<p>I concur with your comparison to iris-lean--more specifically, a fairly central difference is that Iris-style logics can support deeply-embedded languages (ie. small-step semantics) that might not easily fit into the monadic framework. There is <a href=\"https://dl.acm.org/doi/10.1007/978-3-031-98668-0_4\">some work</a> on automating some parts of Iris with SMT, but I have the sense that a tool as cohesive as Loom would not be possible in Iris's complete generality. </p>\n<p>I asked Ilya about this a while ago but I'm wondering if there's any new info: have you folks experimented with using noncomputable monads in this framework? Specifically, something like a probability monad?</p>",
        "id": 545275957,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1760613519
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"690517\">@Vladimir Gladstein</span> ! Hi <span class=\"user-mention\" data-user-id=\"542918\">@George P√Ærlea</span> ! This looks interesting.</p>\n<p>Do I understand correctly that your definition of \"intrinsic\" means fully automatible? (<a href=\"https://verse-lab.github.io/papers/loom-preprint.pdf\">https://verse-lab.github.io/papers/loom-preprint.pdf</a>)<br>\nIn that case, could you help me understand your preference for SMT-solvers in Lean? <br>\nI understand the wish for automation, but I believe one of the motivations for Lean was precisely a more fluent combination between SMT and ITP.<br>\nThis has, at least partially, been realized by lean-smt, grind, hammer, ...<br>\nSo, there appears to be a fragment where <span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> 's <a href=\"http://std.do\">std.do</a> is \"intrinsic\", but I may be misreading your paper.</p>\n<p>This may be related to your comparison with Dijkstra Monads (<a href=\"https://verse-lab.github.io/papers/loom-preprint.pdf#page=25.12\">https://verse-lab.github.io/papers/loom-preprint.pdf#page=25.12</a>). You say that they are not always SMT-friendly.<br>\nDid you consider the more general question of whether it is automation-friendly (e.g. using hammer)?</p>\n<p>Incidentally, we've been working on Hax, a \"multimodal\" framework for Rust verification, which has a {F*,Rocq,lean} backends, but also connects to the Dijkstra monad framework with SSProve. <a href=\"https://hax.cryspen.com/publications/\">https://hax.cryspen.com/publications/</a></p>",
        "id": 545548723,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1760701591
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"721721\">@Markus de Medeiros</span> We haven't done much work in this regard yet, but we're planning to look at probability in the near future. We have a decent idea of how it would work. <span class=\"user-mention\" data-user-id=\"690517\">@Vladimir Gladstein</span> would be the one to ask for specific details if you're interested.</p>",
        "id": 545554871,
        "sender_full_name": "George P√Ærlea",
        "timestamp": 1760703578
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"721721\">@Markus de Medeiros</span> which probability monad? We have them in the Dijkstra monad framework in SSProve (<a href=\"https://github.com/SSProve/ssprove\">https://github.com/SSProve/ssprove</a>). In Rocq, but the theory should carry over to Lean. The discrete probabilities is computable, so maybe you are interested in continuous distributions?</p>",
        "id": 545555968,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1760703936
    },
    {
        "content": "<p>I think Markus might be talking about <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Probability/ProbabilityMassFunction/Monad.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Probability/ProbabilityMassFunction/Monad.html</a></p>",
        "id": 545556263,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760704044
    },
    {
        "content": "<p>But even otherwise, there are many situations where it is important and useful to reason with programs that use certain noncomputable operations as primitives</p>",
        "id": 545556385,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760704096
    },
    {
        "content": "<p>Geometric computations with Real RAM and continuous fair division problems come to mind as examples. Oracle computations where we don‚Äôt know or care about the implementation of the oracles might be another example.</p>",
        "id": 545556598,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760704172
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> By <em>intrinsic</em> we mean that the annotations (pre-post specifications and loop invariants) are inline with the program source.  This is often closely like with full automation, but strictly speaking is a different concept. In particular, auto-active verifiers like Dafny often require additional \"helper\" assertions to guide the SMT solver towards finding the proof in particular cases. Instead, with Velvet (the Dafny-like verifier built on Loom), you'd get these cases as goals you can solve interactively.</p>",
        "id": 545556674,
        "sender_full_name": "George P√Ærlea",
        "timestamp": 1760704199
    },
    {
        "content": "<p>And we do use <code>grind</code>, which sometimes solves goals on which CVC5 times out. <code>aesop</code> also proves useful from time to time.</p>",
        "id": 545556927,
        "sender_full_name": "George P√Ærlea",
        "timestamp": 1760704284
    },
    {
        "content": "<p>FWIW, here's an interesting blog post talking about the 'intrinsic' vs 'extrinsic' terminology: <a href=\"https://joomy.korkutblech.com/posts/2024-10-30-intrinsic-vs-extrinsic-verification.html\">https://joomy.korkutblech.com/posts/2024-10-30-intrinsic-vs-extrinsic-verification.html</a></p>",
        "id": 545557243,
        "sender_full_name": "George P√Ærlea",
        "timestamp": 1760704380
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> ! These PMF/ discrete probabilities appear to be computable, althought the particular formalization in (<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Probability/ProbabilityMassFunction/Basic.html#Probability-mass-functions\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Probability/ProbabilityMassFunction/Basic.html#Probability-mass-functions</a>) may not be.</p>",
        "id": 545557760,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1760704546
    },
    {
        "content": "<blockquote>\n<p>In that case, could you help me understand your preference for SMT-solvers in Lean?</p>\n</blockquote>\n<p>To answer this more directly: we do not have a preference for SMT over other kinds of automation. Any automation that works is great in our book, and we're very excited about <code>grind</code> in particular <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 545557972,
        "sender_full_name": "George P√Ærlea",
        "timestamp": 1760704604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/113488-general/topic/Loom.20discussion/near/545557760\">said</a>:</p>\n<blockquote>\n<p>Thanks <span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> ! These PMF/ discrete probabilities appear to be computable, althought the particular formalization in (<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Probability/ProbabilityMassFunction/Basic.html#Probability-mass-functions\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Probability/ProbabilityMassFunction/Basic.html#Probability-mass-functions</a>) may not be.</p>\n</blockquote>\n<p>So the implementation relies on expressing probabilities in terms of mathlib <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENNReal#doc\">docs#ENNReal</a></p>",
        "id": 545558208,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760704674
    },
    {
        "content": "<p>Operations on this type are almost always noncomputable in the lean sense as well as decidability sense</p>",
        "id": 545558327,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760704710
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"542918\">@George P√Ærlea</span>. I was aware of the distinction in type theory, but I didn't remember the terminology extended to imperative languages.</p>",
        "id": 545558760,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1760704830
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> yes, I agree, the mathematical concept of PMF is computable, but the mathlib formalization is not.</p>",
        "id": 545559251,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1760704965
    },
    {
        "content": "<p>FWIW, <a href=\"https://github.com/sgraf812/mpl/?tab=readme-ov-file#mpl\">MPL</a> (the prototype library that inspired Std.Do) used to have prototypical intrinsic verification syntax for <code>do</code> as well:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">fib_spec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">fib_spec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fib_spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fib_impl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Idd</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">ensures</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">fib_spec</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">invariant</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">fib_spec</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">rpref</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">fib_spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">rpref</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>However, the implementation is a huge hack. At the FRO we decided to postpone having intrinsic verification syntax until <code>do</code> elaboration becomes extensible. Hence I'll be working on a rewrite of the <code>do</code> elaborator this quarter, allowing users to extend <code>do</code> notation by writing custom <code>do</code> element elaborators such as for <code>invariant</code> above.</p>\n<p>We are also planning towards generalizing the semantic foundations (i.e., <code>WPMonad</code>, <code>Assertion</code>) of Std.Do enough so that Loom won't need to rewrite everything from scratch. Probabilistic assertions (<code>Œ± -&gt; Real</code> instead of <code>Œ± -&gt; Prop</code>) are on our radar, too.</p>",
        "id": 545560345,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1760705341
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> : concretely, what does making <code>do</code> notation more extensible mean? What will we be able to do?</p>",
        "id": 545564467,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1760706445
    },
    {
        "content": "<p>It means you can define custom <code>do</code> elaborators. Roughly</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">doIf</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"if \"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"s2\">\" then \"</span><span class=\"w\"> </span><span class=\"n\">doSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s2\">\" else \"</span><span class=\"w\"> </span><span class=\"n\">doSeq</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">doElem</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">doElem_elab</span><span class=\"w\"> </span><span class=\"n\">doIf</span><span class=\"kd\">]</span>\n<span class=\"n\">meta</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">elabElem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">syn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DoElemCont</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DoElabM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">syn</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">dooElem</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">cond</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">thenDooSeq</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">elseDooSeq?</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"n\">withDuplicableCont</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">then_</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">elabElems1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">getDooElems</span><span class=\"w\"> </span><span class=\"n\">thenDooSeq</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">else_</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">elseDooSeq?</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"n\">continueWithUnit</span><span class=\"w\"> </span><span class=\"n\">dooElem</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">elseDooSeq</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">elabElems1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">getDooElems</span><span class=\"w\"> </span><span class=\"n\">elseDooSeq</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">then_</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">exprToSyntax</span><span class=\"w\"> </span><span class=\"n\">then_</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">else_</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">exprToSyntax</span><span class=\"w\"> </span><span class=\"n\">else_</span>\n<span class=\"w\">      </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">cond</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">then_</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">else_</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwUnsupportedSyntax</span>\n</code></pre></div>\n<p><code>DoElabM</code> builds on <code>TermElabM</code> and allows for duplicating continuations (i.e., introducing join points as needed), getting a hold of the <code>let mut</code> vars, etc.</p>",
        "id": 545565708,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1760706801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"721721\">Markus de Medeiros</span> <a href=\"#narrow/channel/113488-general/topic/Loom.20discussion/near/545275957\">said</a>:</p>\n<blockquote>\n<p>a fairly central difference is that Iris-style logics can support deeply-embedded languages (ie. small-step semantics) that might not easily fit into the monadic framework.</p>\n</blockquote>\n<p>That‚Äôs right! I guess monadic frameworks can do deep embeddings to some extent with iTress like in <a href=\"https://maxv.dk/program_logics_a_la_carte.pdf\">https://maxv.dk/program_logics_a_la_carte.pdf</a>. But of course you need to do extra work if you want to embed your language into monadic framework.</p>\n<p>as for non-computational monads: you can read on section 6 of the paper where we work with non-determinism monads. Basically you can instantiate Loom whenever your assertion language is Complete Lattice. As far as I know, pre-expectations is a Complete Lattice, so I don‚Äôt immediately see obstacles to work with Probabilities. Thats said, we have not tried it yet! But we are looking into it rn</p>",
        "id": 545572229,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1760708663
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Loom.20discussion\">#general &gt; Loom discussion</a> by <span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span>.</p>",
        "id": 545874283,
        "sender_full_name": "Notification Bot",
        "timestamp": 1760927820
    }
]