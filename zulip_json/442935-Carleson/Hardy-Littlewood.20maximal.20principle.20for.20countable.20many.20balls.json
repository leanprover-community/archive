[
    {
        "content": "<p>The blueprint and formalization currently only proof the Hardy-Littlewood maximal principle for a finite collection of balls. We also need a part of this for countably many balls later, which is done in the blueprint using the monotone convergence theorem. <br>\nHowever, we can generalize the results a bit so that everything works well for countable collections. This is a little trickier since countable suprema can be infinite. And indeed, the Hardy-Littlewood maximal function can be infinite on a set of measure 0.</p>\n<p>This requires some changes:<br>\n(1) <a href=\"https://florisvandoorn.com/carleson/docs/find/?pattern=MeasureTheory.SubadditiveOn.biSup#doc\">carleson#MeasureTheory.SubadditiveOn.biSup</a> should be generalized so that <code>hT</code> hold only almost everywhere, not everywhere.<br>\n(2) This also requires that <a href=\"https://florisvandoorn.com/carleson/docs/find/?pattern=MeasureTheory.SubadditiveOn#doc\">carleson#MeasureTheory.SubadditiveOn</a> gets changed to be true only almost everywhere<br>\n(3) We also have to show that the Hardy-Littlewood maximal function is infinite only on a set of measure 0. This should follow from the fact that is has weak type (1,1), i.e. <a href=\"https://florisvandoorn.com/carleson/docs/find/?pattern=HasWeakType.MB_one#doc\">carleson#HasWeakType.MB_one</a>. However, that is not currently the case, because the way we formulate this result is by using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENNReal.toReal#doc\">docs#ENNReal.toReal</a>, so we're losing information about where the function is infinite. <br>\n(4) To properly do this, we would like to have generalize <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory#doc\">docs#MeasureTheory</a>.Memℒp and <a href=\"https://florisvandoorn.com/carleson/docs/find/?pattern=MeasureTheory.HasWeakType#doc\">carleson#MeasureTheory.HasWeakType</a> to also support codomain <code>ENNReal</code>. Currently it's only stated for normed groups. This generalization is possible (<a href=\"https://github.com/fpvandoorn/carleson/compare/master...enorm\">see this branch</a>), since we only need that the codomain has a norm to <code>ENNReal</code>, which can just be the identity function if the codomain is already <code>ENNReal</code>. </p>\n<p>Point (4) requires major changes in Mathlib, and I'm not sure how nice that is: probably many lemmas about normed groups don't generalize well to <code>ENNReal</code>, and it probably also requires adding some type-classes about precisely the behavior that both <code>ENNReal</code> + <code>NormedAddCommGroup</code> satisfy w.r.t. addition, scalar multiplication and the norm function. So maybe we should just do (3) directly, without doing (4) first.<br>\nI'll create new tasks for these steps.</p>",
        "id": 478069896,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1729519529
    },
    {
        "content": "<p>There are some updates here: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENorm#doc\">docs#ENorm</a> has been added to Mathlib and all <em>definitions</em> like <code>MemLp</code> and <code>Integrable</code> are now using them, but very few Mathlib lemmas. The Carleson project is now also heavily using this, and we can state that an operator with codomain <code>ENNReal</code> has weak or strong type (p,q) <a href=\"https://florisvandoorn.com/carleson/docs/find/?pattern=MeasureTheory.HasWeakType#doc\">carleson#MeasureTheory.HasWeakType</a> / <a href=\"https://florisvandoorn.com/carleson/docs/find/?pattern=MeasureTheory.HasStrongType#doc\">carleson#MeasureTheory.HasStrongType</a><br>\nHowever:</p>\n<ol>\n<li>For many lemmas we need more than <code>ENorm</code>, and we need classes like <a href=\"https://florisvandoorn.com/carleson/docs/find/?pattern=ENormedSpace#doc\">carleson#ENormedSpace</a> (not to be confused with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENormedSpace#doc\">docs#ENormedSpace</a>, which should probably be removed).</li>\n<li>The real interpolation theorem still doesn't work for functions into <code>ENNReal</code>, and we're still stating in the Carleson project a lot that <code>someOperator . . |&gt;.toReal</code> has weak/strong type, which doesn't say anything about how often <code>someOperator</code> is infinity. However, we have lemmas like <a href=\"https://florisvandoorn.com/carleson/docs/find/?pattern=MeasureTheory.hasWeakType_toReal_iff#doc\">carleson#MeasureTheory.hasWeakType_toReal_iff</a> which transition between the two statements.</li>\n</ol>\n<p>To get this to a satisfactory condition, there are a few things that need to be done, but these have nontrivial (circular?) dependencies on each other, and so far I've mostly been doing these myself, but help would be appreciated (and various of these tasks don't require deep mathematical knowledge).</p>\n<p>Tasks (I've incorporated these tasks as 111-117 on the main list, look there for the current status):</p>\n<p>E1: Remove <code>toReal</code> from all statements that <code>someOperator . . |&gt;.toReal</code> have weak/strong type. Use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.hasWeakType_toReal_iff#doc\">docs#MeasureTheory.hasWeakType_toReal_iff</a> and variants to fix proofs, possibly by including some sorries.<br>\nE2: Generalize all Mathlib lemmas about <code>MemLp</code> and similar definitions (see changes of <a href=\"https://github.com/leanprover-community/mathlib4/pull/20122\">#20122</a> for all \"similar definitions\") that hold for <code>ENorm</code> to <code>ENorm</code>.<br>\nE3: Upstream <a href=\"https://florisvandoorn.com/carleson/docs/Carleson/ToMathlib/ENorm.html\">https://florisvandoorn.com/carleson/docs/Carleson/ToMathlib/ENorm.html</a> (we might need to discuss if we're happy with these exact classes)<br>\nE4: Generalize all Mathlib lemmas that can be generalized to one of the classes in E3 to the appropriate class. (depends on E3)<br>\nE5: Generalize all results in <code>WeakType.lean</code> to ENorm-classes (depends partly on E4)<br>\nE6: Generalize the proof of the real interpolation theorem to also include operators mapping into <code>ENNReal</code> A start of this has been made in <a href=\"https://github.com/fpvandoorn/carleson/pull/209\">#209</a> (depends partly on E2, E4)<br>\nE7: Fix all <code>sorry</code>'s introduced in E1. (depends on E5, E6)</p>",
        "id": 495074910,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1737471530
    },
    {
        "content": "<p>There is one other task that I didn't foresee here. I tried to prove the boundedness of the Hardy-Littlewood maximal function right away for countable families of balls, whereas the blueprint does it for finitely many balls first, and then generalizes it to countably many balls by considering finite subfamilies of balls that exhaust all the countably many balls.</p>\n<p>There was one thing that I didn't realize, and that is that the Vitali covering lemma requires that the radii of the balls are bounded above, and so now the boundedness of the maximal function (<a href=\"https://florisvandoorn.com/carleson/docs/find/?pattern=hasStrongType_maximalFunction#doc\">carleson#hasStrongType_maximalFunction</a>) depends on this extra condition. However, we need to get the result even in the case that the balls are not bounded above. So there is one more task:</p>\n<p>E8: Prove <a href=\"https://florisvandoorn.com/carleson/docs/find/?pattern=hasStrongType_maximalFunction#doc\">carleson#hasStrongType_maximalFunction</a> without the assumption <code>hR</code> that the radii of the balls are bounded above. A proof for basically this result is given in Chapter 9, everything following after equation (9.0.36).</p>\n<p>(E7 + E8 should complete task 109)</p>",
        "id": 495077156,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1737471943
    },
    {
        "content": "<p>Mathlib PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/20806\">#20806</a> might also be related. Yael is slowly fixing this; I'm reviewing it. Should land \"soon\".</p>",
        "id": 495165017,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1737502581
    },
    {
        "content": "<p>ETA for landing: maybe 4-5 days?</p>",
        "id": 495170601,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1737505401
    },
    {
        "content": "<p>Oh, that is nice. Thanks for doing that Yael!</p>",
        "id": 495279051,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1737551336
    },
    {
        "content": "<p>I should add: that PR is really boiling the mathlib ocean, it feels like it changes every single lemma statement using \\norm_+ to enorms. This is really nice, thanks a lot!</p>",
        "id": 495285935,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1737553473
    },
    {
        "content": "<p>Yes, I am starting to think that <code>‖·‖ₑ</code> was the right object all along, and <code>‖·‖₊</code> merely an usurpator <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 495286359,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1737553595
    },
    {
        "content": "<p>I have started working on E2</p>",
        "id": 497255843,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1738500490
    },
    {
        "content": "<p>I incorporated this list into the V5 task list, where I'll keep track of who is working on what.</p>",
        "id": 497401734,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1738580981
    },
    {
        "content": "<p>Let me note some PRs, to they don't get forgotten:</p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/21380\">#21380</a> should be easy to review (just generalises co-domains of lemmas)</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/21423\">#21423</a> fixes a pre-existing issue (awaiting CI; should be easy to review)</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/21422\">#21422</a> adds the first classes to mathlib (<code>ContinuousENorm</code> and <code>ENormed{Add,}{Comm,}Monoid</code>: relevant lemmas were used with to_additive quite a bit, so I think we also need the multiplicative ones.</li>\n</ul>",
        "id": 497686165,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1738680989
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/21422\">#21422</a> fails CI, as it causes the simpNF linter to time out in a far later file (for no reason I find obvious). How would I even start diagnosing this? I'll ask elsewhere on zulip.</p>",
        "id": 497686286,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1738681025
    },
    {
        "content": "<p>Try <code>variable ... in #synth I.IsPrime</code> in both your branch and on master (in e.g. a fresh clone of mathlib master so you don't have to keep switching between branches) at the point of failure and see if there's any difference. IF necessary bump up the heartbeat count; see if you can get it to succeed, and then <code>set_option Meta.trace.synthInstance true</code> or whatever it's called, and see if you can spot the chaos that your PR may have caused by looking at the difference between the two traces.</p>",
        "id": 497771479,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738709316
    },
    {
        "content": "<p>Current blocker: <a href=\"https://github.com/leanprover-community/mathlib4/pull/22215\">#22215</a> fixes another simpNF linter time-out. I just maintainer merge'd it; this blocks <a href=\"https://github.com/leanprover-community/mathlib4/pull/21422\">#21422</a>.</p>",
        "id": 503243667,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1741088075
    },
    {
        "content": "<p>That's merged</p>",
        "id": 503258885,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1741092674
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/21422\">#21422</a> was just merged <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span>, I am working on getting <a href=\"https://github.com/leanprover-community/mathlib4/pull/21712\">#21712</a> ready for review now</p>",
        "id": 504066300,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1741345145
    },
    {
        "content": "<p>Next PR ready for review is <a href=\"https://github.com/leanprover-community/mathlib4/pull/22708\">#22708</a></p>",
        "id": 504254811,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1741424492
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/22798\">#22798</a> is another little PR, generalising a few lemmas</p>",
        "id": 504630923,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1741623150
    }
]