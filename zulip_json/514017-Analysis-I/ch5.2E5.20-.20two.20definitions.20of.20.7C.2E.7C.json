[
    {
        "content": "<p><a href=\"/user_uploads/3121/V6t89Q5ls7kZYd7FeraBTZ2O/Screenshot-2025-09-12-at-7.01.14AM.png\">Screenshot 2025-09-12 at 7.01.14 AM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/V6t89Q5ls7kZYd7FeraBTZ2O/Screenshot-2025-09-12-at-7.01.14AM.png\" title=\"Screenshot 2025-09-12 at 7.01.14 AM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"998x526\" src=\"/user_uploads/thumbnail/3121/V6t89Q5ls7kZYd7FeraBTZ2O/Screenshot-2025-09-12-at-7.01.14AM.png/840x560.webp\"></a></div><p>(Sometimes I feel Lean is just trolling me :)) After some more hovering around turns out somehow we ended up with two incompatible definitions of |.|</p>\n<p>the one I am working with generally coming from <code>LinearOrder Real</code> (I think)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">@_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"n\">inst_conditionallyCompleteLattice</span><span class=\"bp\">.</span><span class=\"n\">toLattice</span><span class=\"w\"> </span><span class=\"n\">addGroup_inst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span>\n</code></pre></div>\n<p>the one that <code>abs_mul</code> from mathlib creates</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">@_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"n\">instDistribLatticeOfLinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toLattice</span><span class=\"w\"> </span><span class=\"n\">instField</span><span class=\"bp\">.</span><span class=\"n\">toDivisionRing</span><span class=\"bp\">.</span><span class=\"n\">toAddGroupWithOne</span><span class=\"bp\">.</span><span class=\"n\">toAddGroup</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span>\n</code></pre></div>\n<p>(note noone of those are the custom <code>abs</code> in ch5.4, which we have swapped for mathlib |.| at this point, while still working with custom Reals)</p>\n<p>I unblocked myself by copying over the custom proof I have from chapter 4 for <code>abs_mul</code>, but this would be a stumbling block for future users, so would like to contribute a fix or hint once I understand this better.</p>",
        "id": 539109278,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757693157
    },
    {
        "content": "<p>Probably some typeclass diamond</p>",
        "id": 539123419,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757695675
    },
    {
        "content": "<p>Do you think this is 1) general mathlib issue, 2) issue with the setup for Reals in the companion 3) issue with the proof I am writing.</p>",
        "id": 539125509,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757696106
    },
    {
        "content": "<p>I guess 4) non-issue, just don't use <code>abs_mul</code></p>",
        "id": 539125640,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757696129
    },
    {
        "content": "<p>If you control-click the two inst* expressions you found by hovering, are they both in mathlib?</p>",
        "id": 539134737,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1757697954
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=inst_conditionallyCompleteLattice#doc\">docs#inst_conditionallyCompleteLattice</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instDistribLatticeOfLinearOrder#doc\">docs#instDistribLatticeOfLinearOrder</a></p>",
        "id": 539139310,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757699989
    },
    {
        "content": "<p>Looks like the first one isn't in mathlib so maybe is defined in the analysis project and is causing trouble.</p>",
        "id": 539139405,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757700016
    },
    {
        "content": "<p>Well the second one is forgetful inheritance so we would need to see the linear order instance it's taking to find out if it's causing trouble</p>",
        "id": 539140234,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757700344
    },
    {
        "content": "<p>The instance of the first one is defined in the Analysis project, but the definition of <code>ConditionallyCompleteLattice</code> is in mathlib.</p>\n<p><a href=\"https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_5_5.lean#L321-L326\">https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_5_5.lean#L321-L326</a><br>\nand <br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/ConditionallyCompleteLattice/Basic.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/ConditionallyCompleteLattice/Basic.html</a></p>\n<p>the second one similarly starts with an instance of <code>LinearOrder</code> in Analysis here - <a href=\"https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_5_4.lean#L200-L206\">https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_5_4.lean#L200-L206</a> and through some other chain build abs in a not defeq way.</p>",
        "id": 539163517,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757711591
    },
    {
        "content": "<p><code> Real.inst_conditionallyCompleteLattice</code> is towards the end of the file so not sure if we even need it for anything, so will try to remove it.</p>",
        "id": 539163957,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757711835
    },
    {
        "content": "<p>Yep, no errors in 5.5 or 5.6 so far after removing <code>inst_conditionallyCompleteLattice</code>. AFAIKT, that instance was added to show that we can have mathlibs <code>sSup</code> work on all custom Real sets. At some point we will be swapping with mathlib R so that instance doesn't seem important, other than showing that it is possible (albeit at the cost of picking up two incompatible |.|)</p>",
        "id": 539164471,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757712134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488971\">Rado Kirov</span> <a href=\"#narrow/channel/514017-Analysis-I/topic/ch5.2E5.20-.20two.20definitions.20of.20.7C.2E.7C/near/539163957\">said</a>:</p>\n<blockquote>\n<p><code> Real.inst_conditionallyCompleteLattice</code> is towards the end of the file so not sure if we even need it for anything, so will try to remove it.</p>\n</blockquote>\n<p>oh yeah that's the bad instance</p>",
        "id": 539164913,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757712389
    },
    {
        "content": "<p>this one? <a href=\"https://github.com/teorth/analysis/blob/31e7e41b5fd092c2ab10ad3747ec4245f54712a1/analysis/Analysis/Section_5_5.lean#L320-L325\">https://github.com/teorth/analysis/blob/31e7e41b5fd092c2ab10ad3747ec4245f54712a1/analysis/Analysis/Section_5_5.lean#L320-L325</a></p>",
        "id": 539164932,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757712404
    },
    {
        "content": "<p>the problem is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=conditionallyCompleteLatticeOfsSup#doc\">docs#conditionallyCompleteLatticeOfsSup</a></p>",
        "id": 539164993,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757712440
    },
    {
        "content": "<p>it explains why it's bad in the docstring</p>",
        "id": 539165014,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757712451
    },
    {
        "content": "<p>It <em>might</em> be useful for the chapter 5 epilogue but I haven’t playtested this. But I would hope there is some way to impose this structure on Real that doesnt cause diamonds</p>",
        "id": 539197327,
        "sender_full_name": "Terence Tao",
        "timestamp": 1757733938
    },
    {
        "content": "<p>Does this work better?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Use the `sSup` operation to build a conditionally complete lattice structure on `Real`-/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">inst_conditionallyCompleteLattice</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">ConditionallyCompleteLattice</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">conditionallyCompleteLatticeOfLatticeOfsSup</span><span class=\"w\"> </span><span class=\"n\">Real</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">solve_by_elim</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ExtendedReal</span><span class=\"bp\">.</span><span class=\"n\">sup_of_bounded</span><span class=\"o\">])</span>\n</code></pre></div>",
        "id": 539197827,
        "sender_full_name": "Terence Tao",
        "timestamp": 1757734348
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/channel/514017-Analysis-I/topic/ch5.2E5.20-.20two.20definitions.20of.20.7C.2E.7C/near/539197827\">said</a>:</p>\n<blockquote>\n<p>Does this work better?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Use the `sSup` operation to build a conditionally complete lattice structure on `Real`-/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">inst_conditionallyCompleteLattice</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">ConditionallyCompleteLattice</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">conditionallyCompleteLatticeOfLatticeOfsSup</span><span class=\"w\"> </span><span class=\"n\">Real</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">solve_by_elim</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ExtendedReal</span><span class=\"bp\">.</span><span class=\"n\">sup_of_bounded</span><span class=\"o\">])</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>maybe</p>",
        "id": 539197849,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757734367
    },
    {
        "content": "<p>I'll have a look at what fields we have here</p>",
        "id": 539197923,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757734426
    },
    {
        "content": "<p>no actually that should probably fix the diamond</p>",
        "id": 539197961,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757734455
    },
    {
        "content": "<p>assuming you don't also have some other diamond</p>",
        "id": 539197988,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757734480
    },
    {
        "content": "<p>The docstring <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=conditionallyCompleteLatticeOfLatticeOfsSup#doc\">docs#conditionallyCompleteLatticeOfLatticeOfsSup</a> seems to discourage its use which is probably why I didn't use it initially</p>",
        "id": 539198044,
        "sender_full_name": "Terence Tao",
        "timestamp": 1757734511
    },
    {
        "content": "<p>the best thing to do is to provide both <code>sSup</code> and <code>sInf</code> yourself</p>",
        "id": 539198225,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757734621
    },
    {
        "content": "<p>this doesn't seem to hard</p>",
        "id": 539198235,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757734625
    },
    {
        "content": "<p>but for <code>sSup</code> and <code>sInf</code> on the reals you really don't care about the defeqs</p>",
        "id": 539198274,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757734654
    },
    {
        "content": "<p>so it probably doesn't matter</p>",
        "id": 539198301,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757734666
    },
    {
        "content": "<p>In the file I defined sSup explicitly but didn't bother with sInf, was planning to outsource that to the <code>conditionallyCompleteLattice</code> instance</p>",
        "id": 539198471,
        "sender_full_name": "Terence Tao",
        "timestamp": 1757734796
    },
    {
        "content": "<p>yeah I doubt that defeq for either is going to be relevant for anything</p>",
        "id": 539198498,
        "sender_full_name": "Terence Tao",
        "timestamp": 1757734821
    },
    {
        "content": "<p>I'll let <span class=\"user-mention\" data-user-id=\"488971\">@Rado Kirov</span> take the lead on seeing if this patches the problem (if so, please send an appropriate PR).</p>",
        "id": 539198620,
        "sender_full_name": "Terence Tao",
        "timestamp": 1757734935
    },
    {
        "content": "<blockquote>\n<p>Does this work better?</p>\n</blockquote>\n<p>Yes, that fixes it. Should I send PR with just that or attempt to define <code>sInf</code> and skip <code>conditionallyCompleteLattice</code>?</p>",
        "id": 539200335,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757735725
    },
    {
        "content": "<p>OOC, this is my first diamond issue in Lean, so would like to learn a bit more about what is happening.</p>\n<p>What I can tell so far</p>\n<ul>\n<li>the |.| notation is driven by the <code>abs</code> function which needs <code>[Lattice α]</code> instance (because lattice gives <code>max</code> and abs is max of x and -x.</li>\n<li>in the companion code we provide two other type class instances<ul>\n<li><code>LinearOrder</code> pretty early on in 5.4</li>\n<li><code>ConditionallyCompleteLattice</code>   </li>\n</ul>\n</li>\n<li>each one of those independently creates a <code>Lattice</code> instance automatically.<ul>\n<li><code>LinearOrder</code> creates instance of <code>DistribLattice</code> which extends <code>Lattice</code></li>\n<li><code>ConditionallyCompleteLattice</code>  straight up extends <code>Lattice</code></li>\n</ul>\n</li>\n</ul>\n<p>So now Lean's type class search algorithm finds two instances of <code>Lattice Real</code>. What I don't get is how come the original statement <code>theorem Real.pow_abs (x:Real) (n:ℕ) : |x|^n = |x^n|</code> picked up the second instance, while the mathlib <code>abs_mul</code> theorem picks up the first?</p>\n<p>I see how the fix going from <code>conditionallyCompleteLatticeOfLatticeOfsSup</code> to <code>conditionallyCompleteLatticeOfLatticeOfsSup</code> fixes the problem, because the second takes the already existing <code>Lattice</code> instance and persumably uses it instead of creating a new Lattice insteance.</p>\n<p>I don't follow what are the concerns left with that solution?</p>\n<blockquote>\n<p>the best thing to do is to provide both <code>sSup</code> and <code>sInf</code> yourself</p>\n</blockquote>\n<p>why is this better than using <code>conditionallyCompleteLatticeOfLatticeOfsSup</code>?</p>\n<blockquote>\n<p>yeah I doubt that defeq for either is going to be relevant for anything</p>\n</blockquote>\n<p>defeq between which objects?</p>",
        "id": 539205553,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757737366
    },
    {
        "content": "<p><a href=\"https://github.com/teorth/analysis/pull/355\">https://github.com/teorth/analysis/pull/355</a></p>",
        "id": 539228903,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757745689
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488971\">Rado Kirov</span> <a href=\"#narrow/channel/514017-Analysis-I/topic/ch5.2E5.20-.20two.20definitions.20of.20.7C.2E.7C/near/539205553\">said</a>:</p>\n<blockquote>\n<p>What I don't get is how come the original statement <code>theorem Real.pow_abs (x:Real) (n:ℕ) : |x|^n = |x^n|</code> picked up the second instance, while the mathlib <code>abs_mul</code> theorem picks up the first?</p>\n</blockquote>\n<p>You can't control the typeclass inference algorithm, it's solving some big logic problem using the facts it knows at the time it has to solve it, in the order which the system finds them when answering this specific question, and the only thing you can guarantee is that once it finds a solution, it stops looking. So if you use different definitions or theorems which have different combinations of typeclass assumptions (and remember that mathlib will have a gazillion different classes which extend <code>LE</code>, and each lemma or definition will use precisely the minimal connection needed to make the lemma valid) and if you have a diamond then there's no way to guarantee that all these different theorems are going to find the same lattice structure if there are two non-syntactically-equal lattice structures in the system.</p>\n<blockquote>\n<p>I don't follow what are the concerns left with that solution?</p>\n</blockquote>\n<p>Is there definitely only one max,min,sSup,sInf etc etc in the system, up to syntactic equality?<br>\nAll data fields definitely match?</p>",
        "id": 539250508,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757751363
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488971\">@Rado Kirov</span> I think your analysis of the situation is broadly correct.  Tools such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=conditionallyCompleteLatticeOfLatticeOfsSup#doc\">docs#conditionallyCompleteLatticeOfLatticeOfsSup</a> take advantage of the mathematical fact that in a lattice, one can define <code>sInf</code> in terms of <code>sSup</code> in a moderately complicated fashion (basically, the <code>sInf</code> of a set <code>E</code> is the <code>sSup</code> of the lower bounds of <code>E</code>).  However, if one does so, the actual definition of <code>sInf</code> is likely to be a mess, so that one would not be advised to <code>unfold</code> <code>sInf</code> for instance, and that any statement involving <code>sInf</code> would probably need to be proven via the <code>ConditionallyCompleteLattice</code> API rather than the literal definition of <code>sInf</code> (this API for instance will tell you that <code>sInf E</code> is the greatest lower bound on <code>E</code> as long as <code>E</code> is non-empty and bounded from below).  But in the case of <code>Real</code>, this is basically what one wants to do anyways, so there should be no harm in sending a PR with the proposed fix.</p>",
        "id": 539265480,
        "sender_full_name": "Terence Tao",
        "timestamp": 1757764218
    },
    {
        "content": "<p>Thank you both for the detailed answers! The PR is sent.</p>\n<blockquote>\n<p>Is there definitely only one max,min,sSup,sInf etc etc in the system, up to syntactic equality?</p>\n</blockquote>\n<p>I think with the PR there is only a single <code>Lattice Real</code> so single <code>max</code> and <code>min</code>, and a single ConditionallyCompleteLattice - so single <code>sSup</code> <code>sInf</code>. The trick was passing the existing Lattice instance into the other <code>ConditionallyCompleteLattice</code> instance constructor method.</p>\n<p>There are separate concerns around <code>sInf</code> and that method, but these are moot in the context of this project it seems.</p>",
        "id": 539278924,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757776967
    }
]