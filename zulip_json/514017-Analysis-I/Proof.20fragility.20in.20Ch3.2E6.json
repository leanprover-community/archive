[
    {
        "content": "<p>I just rebased my solutions on top of upstream main, and while most changes are trivial solutions for 3.6 are very broken in way that are hard to me to quickly fix. I need to spend more time thinking about what happened, but I think <span class=\"user-mention\" data-user-id=\"418569\">@Dan Abramov</span> contributed a new simp form for Fin &lt;-&gt; Nat &lt;-&gt; Object embeddings, that is different than the one I used to work with. I can read his solutions to unblock myself, so not a big deal, just an interesting case to think about proof engineering and maintenance.</p>\n<p>Here is an example, this is how the proof looks like after rebasing (very annoying that I can't easily see the proof state when it used to work</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">hx''</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- expands to @Fin.toNat inst✝ 1 x : ℕ = 0</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"c1\">-- expands to @Subtype.val Object (fun x ↦ x ∈ Fin 1) x : Object</span>\n<span class=\"c1\">-- used to work</span>\n<span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hx''</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>\n<p>I am guessing hx'' was simplifying to a statement about Objects previously.</p>\n<p>Interesting example for my learning on how to write proofs better (now that I feel I can at least write some basic proofs in Lean) and on why Lean style matters for maintainability.</p>",
        "id": 541704362,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1758903219
    },
    {
        "content": "<p>Fixed all proofs in 3.6, but surprisingly had to add some new cast theorems:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">natToObject_toFin</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hm</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">):</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"bp\">⟩</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">toFin_iff_toNat_eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">hm</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">hm'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n'</span><span class=\"o\">:</span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"o\">((</span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"bp\">⟩</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">⟨</span><span class=\"n\">n'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hm'</span><span class=\"bp\">⟩</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n'</span>\n</code></pre></div>\n<p>I need to sit down and think properly what's a principled way to deal with all these statements about natural numbers, that can appear through casts in either of those types:</p>\n<ul>\n<li>matlib N</li>\n<li>the set of Nats</li>\n<li>Objects </li>\n<li>Fin sets</li>\n</ul>\n<p>but because everything is injective one aways can move them around to the type needed. But the composition of casts are not defeq equal to the appropriate direct cast, so one has to apply the right proofs to simplify through casts.</p>\n<p>Also sometimes one can't just peel off the outer cast because there might be incompatible inner type - e.g. ((&lt;x, ...&gt; : Fin n): Object) = ((&lt;y, ...&gt;: Fin m): Object) implies x = y, but one can't just apply object_inj. I need to think more about this, feels like there should be some tactic like <code>push_cast</code> that turns all statements into a normal form, not sure if <code>simp</code> can do it with appropriate annotations.</p>",
        "id": 541778799,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1758953159
    },
    {
        "content": "<p>It’s possible some simp lemmas I added break reasonable things and should have the simp attribute removed (or left for aesop). I haven’t looked yet but if you have a candidate for what seems to be breaking things, lmk!</p>",
        "id": 541833049,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1759001444
    },
    {
        "content": "<p>yeah, I wouldn't call my proofs \"reasonable\" :)  they are obviously \"my first proof\" level of quality, and from now on every other solver will likely benefit from the new simps. I don't think anyone will ever write them the way I did, I only wrote them like this because I was bruteforcing through the proof state without thinking deeply about principles.</p>\n<p>I think all new simps you added are valid, but I am curious if you used some heuristic/principle on which theorems need the attr vs ones that don't. Because we have isomorphisms between bunch of these objects:</p>\n<blockquote>\n<ul>\n<li>matlib N</li>\n<li>custom Nat</li>\n<li>Nat embedding in custom Objects </li>\n<li>Fin sets (technically the infinite union of those)</li>\n</ul>\n</blockquote>\n<p>it doesn't seem there is an obvious direction for simps, so it's a bit of a design choice. We can push all numeric statements into mathlib N or push them all into Nat, etc with simp. </p>\n<p>This is more a curious learning for me in general, as I am thinking about the basics of writing maintainable Lean proofs and similar proof engineering concerns. How should a core library identify and communicate such a choice, where there isn't appriori an obvious choice? How careful should the library be when changing that choice? Can the consumer write proofs that are more or less fragile in the face of a potential change here?</p>",
        "id": 541836782,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1759004938
    }
]