[
    {
        "content": "<p>I stole <span class=\"user-mention\" data-user-id=\"488971\">@Rado Kirov</span>'s approach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">singleton_iProd_equiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">iProd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">:({</span><span class=\"n\">i</span><span class=\"o\">}:</span><span class=\"n\">Set</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">mem_iProd</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">tuple</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_iProd</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">tauto</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">ext</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">mem_iProd</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tuple</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">congr!</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">i'</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hi'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_singleton</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">i'</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hi'</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">right_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">    </span><span class=\"n\">generalize_proofs</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"n\">hi</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">tuple_inj</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Notably, I had to learn two (!) new tactics. The left inverse seems to require <code>congr!</code> (with a bang) and the right inverse seems to require <code>generalize_proofs</code>.</p>\n<p>I'm wondering if there's any way to solve this without these tactics. I haven't needed them before so I wonder what is it that forces their use here. (I've spent a bunch of time trying other things and couldn't get anything else to work.)</p>\n<p>It seems a bit unfortunate if the exercise requires them because we've never \"seen\" them before yet.</p>",
        "id": 532816116,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754355362
    },
    {
        "content": "<p><code>congr!</code> is easier to replace, assuming you are ok with <code>ext</code>. Ultimately you need something to show equality of functions, and all <code>congr!</code>, <code>ext</code> and <code>funext</code> work but do more or less intermediate rewritings along the way too.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">ext</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">mem_iProd</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tuple</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">coe_of_fun_inj</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">val_inj</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hi'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_singleton</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">eta</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hi'</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 532820431,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754358947
    },
    {
        "content": "<p><code>generalize_proofs</code> is my dark horse. I was completely stuck without it on some previous problems in 3.3 and someone on this forum showed me first how to use it. Now I throw it every time I run into a messy goal with lots of ..., but it is so blunt and undirected that I feel a bit icky using it. </p>\n<p>Ultimately, every time one does <code>choose</code> in type producing terms, you need a matching <code>choose_spec</code> in theorems to go with it. So here we have some <code>choose h</code> in <code>toFun</code> and <code>invFun</code> so when working on proofs we need to rewrite <code>h</code> to pull <code>h.choose_spec</code>. The two options are:</p>\n<p>1) spell it out if it is short like you have done with <code>((mem_iProd _).mp t.property).choose_spec</code><br>\n2) let the proof unfolds and when stuck pull out the proofs with <code>generalize_proofs a b c d</code> and do <code>a.choose_spec</code>, <code>b.choose_spec</code>, etc on the appropriate variable that matches the proof we need to do more with.</p>\n<p>What I have found frustrating is sometimes I need to multipled <code>generalize_proofs</code> because the proofs get slightly rewritten and often get very long and unreadable (they look unrecongizable from what I wrote when I hover on ...)</p>",
        "id": 532821130,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754359431
    },
    {
        "content": "<p>(Unlike other <code>!</code> tactics where there's some feature being enabled, <code>congr!</code> is just an improved version of <code>congr</code>. I've been hoping to merge <code>congr!</code> into <code>congr</code> one day...)</p>",
        "id": 532821305,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754359557
    },
    {
        "content": "<blockquote>\n<p><code>congr!</code> is easier to replace, assuming you are ok with <code>ext</code>. Ultimately you need something to show equality of functions, and all <code>congr!</code>, <code>ext</code> and <code>funext</code> work but do more or less intermediate rewritings along the way too.</p>\n</blockquote>\n<p>Do you have a good strategy to figure out the sequence of rewrites done manually? In this example I find it pretty tricky to see \"in which direction\" to move. It's not clear to me how you determined which <code>rw</code>s to do.</p>",
        "id": 532821782,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754359975
    },
    {
        "content": "<p><code>congr</code> doesn't work using rewrites, so that's a bit hard. It works \"outside in\". For example, given <code>f a b c = g x y z</code>, it applies a lemma that reduces it to the goals <code>f = g</code>, <code>a = x</code>, <code>b = y</code>, <code>c = z</code>. If you want, it's like it applies <code>congr</code>/<code>congrFun</code>/<code>congrArg</code> repeatedly, but it also can handle more difficult situations that these lemmas can't.</p>\n<p>You can write <code>congr n</code> where <code>n</code> is a number to see how things like step-by-step. <code>congr!</code> accepts this too.</p>",
        "id": 532821937,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754360131
    },
    {
        "content": "<p>(I also failed at reading comprehension and thought you were quoting me, oops.)</p>",
        "id": 532821999,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754360206
    },
    {
        "content": "<p>Any help is welcome :D</p>\n<p>More concretely, what worries me here is that the situation is very fragile, and one wrong move means <code>congr!</code> wouldn't have worked either. E.g. if there was no <code>apply Subtype.ext</code> earlier.</p>\n<p>I'm not sure what's a better strategy than guessing here.</p>",
        "id": 532822038,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754360247
    },
    {
        "content": "<p>This is exactly what I did after I saw this message.</p>\n<ul>\n<li>pasted your proof</li>\n<li>started at congr!</li>\n<li>saw the state is - <code>**⊢** (fun i_1 ↦ ⟨↑(⋯.choose ⟨i, ⋯⟩), ⋯⟩) = fun i_1 ↦ ⟨↑(⋯.choose i_1), ⋯⟩</code></li>\n<li>started peeling the onion from the outside in</li>\n<li>first we have two functions so we do <code>ext j</code> to give them an argument to simplify with</li>\n<li>then I see  <code>↑⟨↑(⋯.choose ⟨i, ⋯⟩), ⋯⟩ = ↑⟨↑(⋯.choose j), ⋯⟩</code> - hover over the arrow, because I learned the hard way they can be like 5 different things - we are in luck all the same <code>.val</code> so we apply <code>rw [Subtype.val_inj]</code> to remove them from both sides. Turns out also <code>simp only</code> collapses two into one, because they are defeq equal I guess. I often do <code>simp?</code> and rewrite with simpler <code>rw</code> if it finds good ones.</li>\n<li>finally we are down to <code>⋯.choose ⟨i, ⋯⟩ = ⋯.choose j</code> I guess the things in the ... are same (but only generalize_proofs will make sure they are).</li>\n<li>notice LHS is writen as a full subtype pair while <code>j</code> is a subtype element, so I asked claude for theorem to break down j into <code>&lt;j.val, j.prop&gt;</code> which turns out was <code>Subtype.eta</code></li>\n<li>finally we are down to <code>⋯.choose ⟨i, ⋯⟩ = ⋯.choose ⟨↑j, ⋯⟩</code> which just means we need to prove <code>i = ↑j</code> and be done. You already had a proof for that.</li>\n</ul>",
        "id": 532822196,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754360431
    },
    {
        "content": "<p>Ah sick, thank you for the writedown! This is helpful.</p>",
        "id": 532822245,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754360474
    },
    {
        "content": "<p>So I guess the hardest part in this one is getting both sides to be function-ish.</p>",
        "id": 532822308,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754360541
    },
    {
        "content": "<p>It's part of it, I missed step 0 - there was a <code>rw [coe_of_fun_inj]</code> because actually you start with <code>↑ fun</code> not <code>fun</code> on both sides</p>",
        "id": 532822421,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754360627
    },
    {
        "content": "<p>basically at each step if you see <code>⊢ F ... = F ...</code> you can do something to remove the <code>F</code> if the <code>F</code> some coersion you find the corresponding <code>_inj</code> theorem, if it is <code>fun x =&gt;</code> you apply <code>ext</code></p>",
        "id": 532822516,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754360704
    },
    {
        "content": "<blockquote>\n<p>Ah sick, thank you for the writedown! This is helpful.</p>\n</blockquote>\n<p>No problem, I am self learning Lean, so spelling out my current likely flawed mental model of tactics is helpful for myself too as folks in the know can correct me.</p>",
        "id": 532822730,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754360890
    },
    {
        "content": "<p>This one worries me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">mem_iProd</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n<span class=\"w\">    </span><span class=\"c1\">-- apply Subtype.ext</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tuple</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">congr!</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">i'</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hi'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_singleton</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">i'</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hi'</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>You can see losing that <code>apply</code> only breaks way further (complaining about <code>i'</code> not being defined).</p>\n<p>I guess in this case <code>simp</code> is not very appropriate and I should use <code>simp_rw</code> to enforce that the rewrite fails if not found?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">mem_iProd</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">ext</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">tuple</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">congr!</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">i'</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hi'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_singleton</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">i'</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hi'</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Now if I comment out that <code>apply</code>, it breaks earlier (at <code>simp_rw</code>).</p>",
        "id": 532822870,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754361025
    },
    {
        "content": "<p>(btw, you can write <code>ext</code> instead of <code>apply Subtype.ext</code>)</p>",
        "id": 532822927,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754361076
    },
    {
        "content": "<p>This <code>apply Subtype.ext</code> is annoying because it makes the goal look _worse_ :</p>\n<p>from</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">tuple</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x_1</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⋯⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⋯.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⋯⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">t</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">tuple</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x_1</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⋯⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⋯.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⋯⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">t</span>\n</code></pre></div>\n<p>So it seems tricky to guess that it's actually a good idea.</p>",
        "id": 532822966,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754361112
    },
    {
        "content": "<p>It occurred to me that it's possible to make use of a fancy feature to get Lean to extract <code>choose</code>s and auto-apply <code>choose_spec</code>. Here's a proof that doesn't mention any complicated-looking terms (e.g. no <code>(mem_singleton _ _).mp i'.property</code>). It's not necessarily any better, but in case it's interesting, here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">choose_ind</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ind</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">ind</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  Example 3.5.10. I suspect most of the equivalences will require classical reasoning and only be</span>\n<span class=\"sd\">  defined non-computably, but would be happy to learn of counterexamples.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">singleton_iProd_equiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">iProd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">:({</span><span class=\"n\">i</span><span class=\"o\">}:</span><span class=\"n\">Set</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">mem_iProd</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">tuple</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_iProd</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">tauto</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ht</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_iProd</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">ht</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ht</span>\n<span class=\"w\">    </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"n\">only</span>\n<span class=\"w\">    </span><span class=\"n\">congr!</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hj</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_singleton</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hj</span>\n<span class=\"w\">    </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">    </span><span class=\"n\">congr!</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Now trying something fancy: let Lean figure out which choose we want</span>\n<span class=\"w\">    </span><span class=\"c1\">-- using the elab-as-elim mechanism! This effectively does generalize_proofs,</span>\n<span class=\"w\">    </span><span class=\"c1\">-- looking *only* for `choose` terms</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">choose_ind</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">tuple_inj</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"n\">right_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">omitted</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 532823037,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754361184
    },
    {
        "content": "<p>Actually maybe I wouldn't get stuck here if this <code>simp</code> wasn't misbehaving:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">mem_iProd</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span>\n<span class=\"w\">    </span><span class=\"c1\">-- rw [tuple] at hx</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- tactic 'simp' failed, maximum recursion depth has been reached</span>\n<span class=\"w\">    </span><span class=\"n\">congr!</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">i'</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hi'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_singleton</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">i'</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hi'</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Is there a way to show what the recursion is? I tried the debug thing it's suggesting and I didn't understand its output.</p>",
        "id": 532823161,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754361310
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  I can definitely use that in some abominations I had to in later exercises - <a href=\"https://github.com/rkirov/analysis/blob/main/analysis/Analysis/Section_3_5.lean#L750\">https://github.com/rkirov/analysis/blob/main/analysis/Analysis/Section_3_5.lean#L750</a> . Will give it a spin later.</p>",
        "id": 532823173,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754361331
    },
    {
        "content": "<p>More about <code>elab_as_elim</code>: Right before that <code>refine</code>, the goal is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"bp\">⋯.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>\n<p>and then right after it's</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">toSubtype</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">toSubtype</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">tuple</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">tuple</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>\n<p>Basically, <code>elab_as_elim</code> is a hint for how Lean should try to solve for the <code>q</code> argument. It finds any cases of <code>Exists.choose _</code> from the goal, then generalizes it, making a lambda.</p>\n<p>In this case it's pretty finicky because it's matching on proofs rather than values, so it won't always correctly solve for <code>_</code>, but maybe that's a Lean bug.</p>",
        "id": 532823229,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754361397
    },
    {
        "content": "<blockquote>\n<p>So it seems tricky to guess that it's actually a good idea.</p>\n</blockquote>\n<p>One way to justify it, you know you wrote <code>((mem_iProd _).mp t.property).choose</code> in <code>toFun</code>, so its <code>choose_spec</code> variant will come into play in the proof.</p>\n<p>So you can predict that and just write right as you introduce <code>t</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">mem_iProd</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n</code></pre></div>\n<p>but now this has <code>↑t</code> which seems hard to remove, so in reverse you introduce it in the goal</p>",
        "id": 532823387,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754361537
    },
    {
        "content": "<p>Btw, my guess is that if you want to remove <code>generalize_proofs</code> you can reverse engineer the <code>choose_spec</code> you need, but in the other direction it is <code>toFun \\comp invFun</code> so if you want to spell it out it is something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">((</span><span class=\"n\">mem_iProd</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">tuple</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_iProd</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">tauto</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n</code></pre></div>\n<p>which is a mouthful, and it is easier to let lean reduce it a bit and then pull out with <code>generalize_proofs</code></p>",
        "id": 532823485,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754361641
    },
    {
        "content": "<p>OK this one is stumping me completely.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">mem_iProd</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">tuple</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- This works</span>\n<span class=\"w\">    </span><span class=\"c1\">-- rw [hx]</span>\n<span class=\"w\">    </span><span class=\"n\">congr!</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">i'</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hi'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_singleton</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">i'</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hi'</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Why does <code>simp_rw</code> work here but <code>rw</code> doesn't?</p>\n<p>They <em>seem</em> to have the same effect on the right side. On the left side, <code>simp_rw</code> flashes green (<code>rw</code> doesn't) but even with <code>set_option pp.proofs true</code> I can't see meaningful difference.</p>\n<p><a href=\"/user_uploads/3121/MxQHGJnFkhvzHmVS2VvZX5bP/wut.mov\">wut.mov</a></p>",
        "id": 532825085,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754363007
    },
    {
        "content": "<p><span aria-label=\"hmm\" class=\"emoji emoji-1f928\" role=\"img\" title=\"hmm\">:hmm:</span>  also just adding <code>simp only</code> after <code>rw [hx]</code> fixes it. Good mystery.</p>",
        "id": 532828202,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754365619
    },
    {
        "content": "<p>Oh, what I see depends on whether the cursor is 1) one space before <code>simp_rw [hx]</code> 2) right at the beginning of <code>simp_rw [hx]</code> ?!?<br>\n<a href=\"/user_uploads/3121/vw5Q3IghptyzREdf3SWFUePf/Screenshot-2025-08-04-at-8.54.52PM.png\">Screenshot 2025-08-04 at 8.54.52 PM.png</a><br>\n<a href=\"/user_uploads/3121/PnfBVJ0L8lZYC4TZKR6NPMMl/Screenshot-2025-08-04-at-8.54.35PM.png\">Screenshot 2025-08-04 at 8.54.35 PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/vw5Q3IghptyzREdf3SWFUePf/Screenshot-2025-08-04-at-8.54.52PM.png\" title=\"Screenshot 2025-08-04 at 8.54.52 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"2326x546\" src=\"/user_uploads/thumbnail/3121/vw5Q3IghptyzREdf3SWFUePf/Screenshot-2025-08-04-at-8.54.52PM.png/840x560.webp\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/PnfBVJ0L8lZYC4TZKR6NPMMl/Screenshot-2025-08-04-at-8.54.35PM.png\" title=\"Screenshot 2025-08-04 at 8.54.35 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"2294x652\" src=\"/user_uploads/thumbnail/3121/PnfBVJ0L8lZYC4TZKR6NPMMl/Screenshot-2025-08-04-at-8.54.35PM.png/840x560.webp\"></a></div>",
        "id": 532828723,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754366106
    },
    {
        "content": "<p>looks like a bug in what <code>simp_rw</code> shows, I think it shows the state after the simp, while the cursor is still infront?</p>",
        "id": 532829033,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754366359
    },
    {
        "content": "<p><code> simp_rw</code> does an extra <code>simp only</code> for you and for some reason the position associated with that is in from of the tactic syntax</p>",
        "id": 532882841,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754388488
    }
]