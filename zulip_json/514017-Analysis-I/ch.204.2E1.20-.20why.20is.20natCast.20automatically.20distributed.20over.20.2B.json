[
    {
        "content": "<p>I am trying to prove something in Ch4.1 that reduces to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>statement is in Int, and casts are from Nats to Int (we are using mathlib Nats at this point). We have </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Section_4_1</span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">cast_eq_0_iff_eq_0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>So the next step is to apply this, but it doesn't apply because there is addition in the way.  So I tried to define my own theorem that the cast is a homomorphism between Nat and Int as monoids, but Lean keeps distributing it over addition so I can't even get to see <code>↑(u + t)</code> to apply <code>cast_eq_0_iff_eq_0</code></p>\n<p><a href=\"/user_uploads/3121/oq_PnsgjiR2rakWYb7AzC1qe/Screenshot-2025-08-06-at-10.39.21PM.png\">Screenshot 2025-08-06 at 10.39.21 PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/oq_PnsgjiR2rakWYb7AzC1qe/Screenshot-2025-08-06-at-10.39.21PM.png\" title=\"Screenshot 2025-08-06 at 10.39.21 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1154x170\" src=\"/user_uploads/thumbnail/3121/oq_PnsgjiR2rakWYb7AzC1qe/Screenshot-2025-08-06-at-10.39.21PM.png/840x560.webp\"></a></div>",
        "id": 533220916,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754545483
    },
    {
        "content": "<p>In the screen shot I expected to see <code>↑(a + b) = ↑a + ↑b</code> as the theorem statement, which is what I thought I wrote?</p>",
        "id": 533221011,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754545531
    },
    {
        "content": "<p>Add an up arrow between the two opening parentheses on the left hand side</p>",
        "id": 533233099,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1754551644
    },
    {
        "content": "<p>Or, add <code>: Nat</code> inside the brackets on the lhs</p>",
        "id": 533278913,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1754568204
    },
    {
        "content": "<p>Ah, I see, + is overloaded on Int too, so Lean is interpreting the cast (a + b): Int as + is in Int, and then making two casts for a and b. Indeed both <code>(↑(a + b) : Int)</code> and <code>(((a + b) : Nat): Int)</code> fix it.</p>",
        "id": 533293782,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754573459
    },
    {
        "content": "<p>My mental model of the design decision (not sure if accurate) is that we want <code>5/6 : Rat</code> to work as expected (ie produce a strictly positive number), so you have to write <code>(5:Nat/6) : Rat</code> if you want the cast to be performed as late as possible (ie produce 0). Then this carries over to all the other numeric types.</p>\n<p>I definitely keep accidentally doing the wrong thing though - I sometimes want a mode which is \"force me to specify all the coercions myself, and show a type error if the types don't match\" vs the default mode, which is something like \"if the types don't match, insert coercions as needed\"</p>",
        "id": 533351671,
        "sender_full_name": "Li Xuanji",
        "timestamp": 1754594889
    },
    {
        "content": "<p>You can use <code>@HDiv.hDiv</code> to force specific types for division (and <code>@HAdd.hAdd</code> for addition, etc.) if you really want, though it gets messy if you have too many of these operations together.</p>",
        "id": 533382834,
        "sender_full_name": "Terence Tao",
        "timestamp": 1754615263
    }
]