[
    {
        "content": "<p>I have been slogging away at chapter 3 exercises every night for 2-3 hours in the last month and finally finished all of Chapter3. It was lots of fun, I learned a lot of more about Lean than what I knew from the tutorials I read, and I am getting really hooked on formalization. Big thanks to everyone that answered my questions here. I am not university affiliated, and have no other place to discuss this (other than with Claude).</p>\n<p>Sadly, the last 1-2 weeks were spend almost exhaustively on exercise 3.6.12 i) - finally closed it today, but it is a 500 line proof (I don't golf) that only compiles with <code>set_option maxHeartbeats 1500000</code>.</p>\n<p><a href=\"https://github.com/rkirov/analysis/blob/856821e029ae309d70efd7e5eb4929189d6d2d59/analysis/Analysis/Section_3_6.lean#L2749\">https://github.com/rkirov/analysis/blob/856821e029ae309d70efd7e5eb4929189d6d2d59/analysis/Analysis/Section_3_6.lean#L2749</a></p>\n<p>I knew eventually I will have to learn how to style my proofs better and deal with performance improvements, but a bit surprised how quickly I ended up in that territory (given how basic the math involved is).</p>\n<p>The theorem is asking to show <code>(Permutations (n + 1)).card = (n + 1) * (Permutations n).card</code>, where <code>Permutations</code> are bijective functions from <code>Fin (n + 1)</code> to <code>Fin (n + 1)</code>. The proof goes something like this:</p>\n<ul>\n<li>define an explicit map F, it takes a permutation f and splits into \\&lt; f n, f' \\&gt;, where f' is same as f but subtracts one from all f x values that are above f n. Thus f' is Fin n \\to Fin n function.</li>\n<li>prove f' is injective</li>\n<li>prove f' is surjective</li>\n<li>prove F is injective, by getting two f' and g' and showing they must have come from the same f.</li>\n<li>prove F is surjective, by starting with f', and generate a new f by undoing the removal of fx. For this new f, show that it is a bijection, then show that F f = \\&lt; f n, f'\\&gt;.</li>\n<li>now the cardinalities are the same</li>\n</ul>\n<p>Not trivial, but still surprising how painful it all became at the end (especially with the performance problems). Note this very similar to the proof for <code>card_erase</code> and that was a great work up to it.</p>\n<p>Some specific surprises/areas of improvement for me:</p>\n<ul>\n<li>the high number of additional Fin lemmas I needed. Despite Fin being so simple, there are so many permutations of paths between Fin, Object, \\N and each can have _injective theorems, diagram commutes theorems, etc. see <a href=\"https://github.com/rkirov/analysis/blob/856821e029ae309d70efd7e5eb4929189d6d2d59/analysis/Analysis/Section_3_5.lean#L882-L943\">https://github.com/rkirov/analysis/blob/856821e029ae309d70efd7e5eb4929189d6d2d59/analysis/Analysis/Section_3_5.lean#L882-L943</a> Should I upstream them all (have to learn how to name them better)?</li>\n<li>learn how to refactor Lean proofs - despite knowing how work with 1000+ loc programs and how to refactor them into shape, I find myself struggling doing the same with lean code. On a very basic level, refactoring code begins with take a common expression and given it a name - a new variable, function. But in lean, I find that new lets actually pollute the proof state if they dont' come with just the right theorems. But it is hard to figure out which theorems to add right away - there could be more than actually needed. For example I learned from <code>card_erase</code> to add <code>hf_def</code> theorem right after defining <code>f</code> - <a href=\"https://github.com/rkirov/analysis/blob/856821e029ae309d70efd7e5eb4929189d6d2d59/analysis/Analysis/Section_3_6.lean#L2762-L2789\">https://github.com/rkirov/analysis/blob/856821e029ae309d70efd7e5eb4929189d6d2d59/analysis/Analysis/Section_3_6.lean#L2762-L2789</a> but I am not sure that is the precisely most useful shape of theorem (there are many variations like .val version instead of toNat)?</li>\n</ul>",
        "id": 532980795,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754423650
    },
    {
        "content": "<p>Any general advice for general lean refactoring 500+ loc proofs. Pulling out theorems is hard when dependent types make so much of the proof state interdependent.</p>\n<p>Is there a way to tell Lean something like <code>set i = &lt;some complex expression&gt;</code> and if &lt;complex expression&gt; pops up during some simplification rewrite it back to <code>i</code> throughout the whole proof. This of course should be turned off when I am writing helper theorems for <code>i</code>.</p>\n<p>Somewhat more concretely in the monster proof above I kept seeing <code> Fin_embed n (n+1) (by omega) i</code> so I defined <code> i': Fin (n + 1) := Fin_embed _ _ (by omega) i with hi'</code> but now I had the second problem of when to work with <code>i'</code> vs <code>i</code> and if my proof had a mixture it became even harder to see what to do next. So I wasn't even sure if that extra variable helped me write cleaner more readable proof. Is there a way to be consistent here?</p>",
        "id": 532984028,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754424940
    },
    {
        "content": "<p><code>set i := ... with hi</code> and <code>simp [← hi]</code> maybe?</p>",
        "id": 532985421,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1754425621
    },
    {
        "content": "<p>There is also the tactic <code>refold_let</code> though I personally haven't used it (I tend to just leave these terms expanded and rely on definitional equality to allow rewriting etc. to still work even if visually it doesn't look like it will)</p>",
        "id": 532985610,
        "sender_full_name": "Terence Tao",
        "timestamp": 1754425714
    },
    {
        "content": "<p>It may possibly be helpful to define functions on all of <code>Nat</code> rather than <code>Fin n</code> but assign junk values to the natural numbers beyond <code>n</code>.  This is less elegant mathematically but can remove one layer of casting in the whole process.</p>",
        "id": 532985745,
        "sender_full_name": "Terence Tao",
        "timestamp": 1754425792
    },
    {
        "content": "<p>eg count permutations from Nat to Nat that fix everybody above n, and only at the end show that this is in bijection to permutations on Fin n.  This should remove the need for a ton of Fin lemmas</p>",
        "id": 532985861,
        "sender_full_name": "Terence Tao",
        "timestamp": 1754425842
    },
    {
        "content": "<p>Or maybe even do it on Mathlib's Nat first so that one gains access to all sorts of toys like <code>linarith</code> and <code>omega</code>, and then biject it back to SetTheory.Set.Nat and then to Fin</p>",
        "id": 532986168,
        "sender_full_name": "Terence Tao",
        "timestamp": 1754425998
    },
    {
        "content": "<p>Of course Mathlib already has the permutation cardinality calculation at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.card_perm#doc\">docs#Nat.card_perm</a> and a few other places, so that's an even shorter option, though not in the spirit of the exercise, <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 532986356,
        "sender_full_name": "Terence Tao",
        "timestamp": 1754426089
    },
    {
        "content": "<blockquote>\n<p>It may possibly be helpful to define functions on all of <code>Nat</code> rather than <code>Fin n</code> but assign junk values to the natural numbers beyond <code>n</code>. This is less elegant mathematically but can remove one layer of casting in the whole process.</p>\n</blockquote>\n<p>That's a neat idea, will give it a try sometimes to see how the proof looks.</p>",
        "id": 533018956,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1754451711
    }
]