[
    {
        "content": "<p>I've noticed <a href=\"https://github.com/teorth/analysis/pull/251\">https://github.com/teorth/analysis/pull/251</a> broke one of my proofs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">image_preimage_f_3_4_2'</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">f_3_4_2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">preimage</span><span class=\"w\"> </span><span class=\"n\">f_3_4_2</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">f_3_4_2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">preimage</span><span class=\"w\"> </span><span class=\"n\">f_3_4_2</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_image</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- This simp no longer works</span>\n<span class=\"w\">  </span><span class=\"n\">simp_all</span>\n</code></pre></div>\n<p>Before the change, it worked and unrolled into</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_image</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"bp\">.</span><span class=\"n\">ofnat_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nat_coe_eq_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_eq_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_ne_one</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">false_and</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">and_false</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_const</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_false_eq_true</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>After the change, it doesn't work and unrolls to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pair_comm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">replacement_axiom</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"bp\">.</span><span class=\"n\">ofnat_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">specification_axiom''</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">coe_eta</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mem_triple</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nat_coe_eq_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_eq_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_ne_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false_and</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ne_eq</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_ne_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_eq_left₀</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false_or</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_prop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">exists</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">not_exists</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_and</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_or</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  ⊢ ∀ (x : Object) (x_1 : x ∈ nat), 1 = ↑(2 * nat_equiv.symm ⟨x, ⋯⟩) → x ∈ nat → ¬2 * nat_equiv.symm ⟨x, ⋯⟩ = 3 ∧ ¬nat_equiv.symm ⟨x, ⋯⟩ = 1</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p>I don't mind the change <em>per se</em> (easily fixable by changing my code to <code>simp; aesop</code>) but I was wondering whether this could indicate a legit regression? Like maybe some of the ones from <a href=\"https://github.com/teorth/analysis/pull/251\">https://github.com/teorth/analysis/pull/251</a> were unsafe to mark as <code>simp</code> for whatever reason. I don't have a mental model for which theorems are OK to mark with <code>simp</code>.</p>",
        "id": 532177385,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754000097
    },
    {
        "content": "<p>It seems to narrow down to having <code>@[simp]</code> on <code>replacement_axiom</code>.</p>\n<p>If that simp is present, it seems like it gets unfolded first, and turns</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">f_3_4_2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">preimage</span><span class=\"w\"> </span><span class=\"n\">f_3_4_2</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">})</span>\n</code></pre></div>\n<p>into</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"bp\">¬∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">f_3_4_2</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">preimage</span><span class=\"w\"> </span><span class=\"n\">f_3_4_2</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>which for some reason leads into corner.</p>\n<p>But if I exclude <code>replacement_axiom</code> and instead let <code>mem_image</code> simplify first with <code>simp [mem_image]</code>,  I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"bp\">¬∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">preimage</span><span class=\"w\"> </span><span class=\"n\">f_3_4_2</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">f_3_4_2</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>And then it's able to continue.</p>\n<p>I wonder if somehow <code>1 = ↑(f_3_4_2 x)</code> is easier to unroll than <code>↑(f_3_4_2 x) = 1</code> later?</p>",
        "id": 532179445,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754001095
    },
    {
        "content": "<p>An alternative fix that seems to work is to change <code>SetTheory.Set.image</code> to say <code>fun x y ↦ f x = y</code> rather than <code>fun x y ↦ y = f x</code> in its definition. Which I guess matches <code>mem_image</code>.</p>",
        "id": 532179720,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754001218
    },
    {
        "content": "<p><code>SetTheory.Set.pair_comm</code> looks like it shouldn't be a simp lemma</p>\n<p>Lemmas like <code>SetTheory.Set.subset_inter_iff</code> and <code>SetTheory.Set.union_subset_iff</code> can be problematic since they're \"nonlinear\" (there are more occurrences of a variable after the rewrite)</p>",
        "id": 532179797,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754001257
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/514017-Analysis-I/topic/Regression.20with.20simps.3F/near/532179445\">said</a>:</p>\n<blockquote>\n<p>I wonder if somehow <code>1 = ↑(f_3_4_2 x)</code> is easier to unroll than <code>↑(f_3_4_2 x) = 1</code> later?</p>\n</blockquote>\n<p>That seems worth looking into. Have you used <code>simp?</code> to see which lemmas are applying?</p>",
        "id": 532179843,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754001277
    },
    {
        "content": "<p>Yup, that's the <code>simp only</code> lists above in the first message</p>",
        "id": 532179892,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754001305
    },
    {
        "content": "<p>This is the list I get if I change <code>y = f x</code> to <code>f x = y</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pair_comm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">replacement_axiom</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"bp\">.</span><span class=\"n\">ofnat_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nat_coe_eq_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_eq_one</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_ne_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false_and</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">specification_axiom''</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">coe_eta</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mem_triple</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ne_eq</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_ne_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_eq_left₀</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false_or</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_prop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_const</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>It works.</p>\n<p>And this is the list that doesn't work (without that change):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pair_comm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">replacement_axiom</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"bp\">.</span><span class=\"n\">ofnat_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">specification_axiom''</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">coe_eta</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mem_triple</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nat_coe_eq_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_eq_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_ne_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false_and</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ne_eq</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_ne_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_eq_left₀</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false_or</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_prop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">exists</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">not_exists</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_and</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_or</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 532180117,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754001407
    },
    {
        "content": "<p>Narrowing it down a bit.</p>\n<p>On <code>main</code>, this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">replacement_axiom</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"bp\">.</span><span class=\"n\">ofnat_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nat_coe_eq_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_eq_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_ne_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false_and</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>leads to <code>¬∃ x, 1 = ↑(2 * nat_equiv.symm x) ∧ ↑x ∈ preimage f_3_4_2 {1, 2, 3}</code>.</p>\n<p>But if I edit <code>SetTheory.Set.image</code> to <code>f x = y</code>, then the same list leads to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"bp\">¬∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">False</span>\n</code></pre></div>",
        "id": 532180907,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754001785
    },
    {
        "content": "<p>Ok I think this is because <code>mul_eq_one</code> doesn't simplify <code>1 = ↑(2 * nat_equiv.symm x)</code> but it does simplify <code>↑(2 * nat_equiv.symm x) = 1</code>. This is why unfolding it as <code>f x = y</code> works but <code>y = f x</code> doesn't. And before <code>replacement_axiom</code> was marked as a simp, it wouldn't get unfolded at all and was being unfolded by <code>mem_image</code> which does have <code>f x = y</code>.</p>\n<p>I guess this is a case of me relying on fragile impl details?</p>",
        "id": 532181740,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754002218
    },
    {
        "content": "<p>Probably not a bad idea to align the order between <code>y</code> and <code>f x</code> between definitions to make it more consistent</p>",
        "id": 532182002,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754002348
    },
    {
        "content": "<p>And yea I agree <code>pair_comm</code> probably shouldn't be <code>@[simp]</code> although not the issue in this case</p>",
        "id": 532182080,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754002388
    },
    {
        "content": "<p>Marking <code>SetTheory.Set.pair_comm</code> as <code>@[simp]</code> was definitely a mistake, I will revert that now, as well as swap the equality in <code>SetTheory.Set.image</code> (at first I thought this was due to the way it was written in the book, but actually the book doesn't state either form).</p>\n<p>On the other hand, Mathlib marks <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.subset_inter_iff#doc\">docs#Set.subset_inter_iff</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.union_subset_iff#doc\">docs#Set.union_subset_iff</a> as <code>@[simp]</code> so I assume these particular types of simp lemmas are \"battle-tested\"?</p>",
        "id": 532182423,
        "sender_full_name": "Terence Tao",
        "timestamp": 1754002571
    },
    {
        "content": "<p>Thanks, confirmed it works after a rebase</p>",
        "id": 532182853,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1754002780
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/channel/514017-Analysis-I/topic/Regression.20with.20simps.3F/near/532182423\">said</a>:</p>\n<blockquote>\n<p>I assume these particular types of simp lemmas are \"battle-tested\"?</p>\n</blockquote>\n<p>I'm not really sure. Distributivity lemmas sometimes are and sometimes aren't simp lemmas, and it's not clear why or why not.</p>\n<p>Those subset lemmas are simp lemmas, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=map_mul#doc\">docs#map_mul</a> is a simp lemma, yet <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_add#doc\">docs#mul_add</a> is not a simp lemma.</p>\n<p>(Sometimes I've thought it would be nice if we had an <code>expand</code> simp set that contained all the distribution lemmas.)</p>",
        "id": 532188166,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754005386
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/514017-Analysis-I/topic/Regression.20with.20simps.3F/near/532181740\">said</a>:</p>\n<blockquote>\n<p><code>mul_eq_one</code></p>\n</blockquote>\n<p>Interesting, <code>mul_eq_one</code> is a simp lemma, but there's no <code>one_eq_mul</code>... That seems like a little bit of an oversight in the simp set.</p>\n<p>Possibly the answer is that there needs to be a <code>1 = x &lt;-&gt; x = 1</code> simp lemma, if <code>_ = 1</code> is decided to be the simp normal form.</p>",
        "id": 532188439,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754005520
    }
]