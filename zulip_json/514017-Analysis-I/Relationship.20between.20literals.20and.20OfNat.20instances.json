[
    {
        "content": "<p>I am doing Ch3.4 and again somewhat surprisingly the parts that have to do with concrete numbers feel harder to me than the proofs for unspecified f and x. </p>\n<p>I think a lot has to do with literals adding an extra wrinkle into the <code>Object</code>, <code>Nat</code>, \\N` picture. I think the mental model is something like this <br>\n<a href=\"/user_uploads/3121/nb6TWqzhqpYtEXpGDqeGM4fq/IMG_5249.jpg\">IMG_5249.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/nb6TWqzhqpYtEXpGDqeGM4fq/IMG_5249.jpg\" title=\"IMG_5249.jpg\"><img data-original-content-type=\"image/jpeg\" data-original-dimensions=\"2906x2175\" src=\"/user_uploads/thumbnail/3121/nb6TWqzhqpYtEXpGDqeGM4fq/IMG_5249.jpg/840x560.webp\"></a></div><p>Though I am not sure whether I should keep back arrows into <code>lit</code> or not? On one hand, not every natural number is written as a literal, on another <br>\n<a href=\"/user_uploads/3121/anYJH8cHxxDJLWxbZAq9VZV2/Screenshot-2025-07-07-at-9.48.57AM.png\">Screenshot 2025-07-07 at 9.48.57 AM.png</a><br>\nOfNat does take a \\N somewhat magically, I kinda expected it to take some opaque literal representation like a string.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/anYJH8cHxxDJLWxbZAq9VZV2/Screenshot-2025-07-07-at-9.48.57AM.png\" title=\"Screenshot 2025-07-07 at 9.48.57 AM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"534x194\" src=\"/user_uploads/thumbnail/3121/anYJH8cHxxDJLWxbZAq9VZV2/Screenshot-2025-07-07-at-9.48.57AM.png/840x560.webp\"></a></div><p>So basically all the problems boil down to, I have <code>some term = some literal</code> in one of <code>Nat</code> or <code>Object</code> (or for extra difficulty in Subset of either), I have to use injective theorems to move this into <code>\\N</code> where I can do actual computations. However, I struggle to find the right theorem to apply from the 5-6 ones provided in ch3.1.</p>\n<p>Specifically for literals, I am not even sure how to match the <code>onNat(n)</code> syntax in the theorem statement to the problem I have at hand. </p>\n<p>Is there a missing theorem or simp-annotation, that prevents simp from achieving the above.</p>",
        "id": 527521721,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1751907798
    },
    {
        "content": "<p>\"raw natural number literals\" are built into lean, they are always typed as the \"mathlib nat\"</p>",
        "id": 527522766,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751908170
    },
    {
        "content": "<p>If there is a hardcoded connection with mathlib Nat (which I write as \\N to avoid confusion with custom Nat), why do we need to complicate everything with extra OfNat instances for Object and Nat, given there are \\N -&gt; Object and \\N -&gt; Nat mappings.</p>",
        "id": 527525377,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1751909287
    },
    {
        "content": "<p>I thought that the point of OfNat was to get numerals working?</p>",
        "id": 527525524,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751909355
    },
    {
        "content": "<p>It's so you can also write numerals for <code>Int</code>, and for <code>Real</code>, and all the other types it would be useful to write a numeral for</p>",
        "id": 527526037,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751909583
    },
    {
        "content": "<p>I guess what I am wondering (sorry, I don't have the right language yet to make a lof ot his precise) is that it seems to me that literal have a direct mapping to some type X (in this case Object and Nat) though OfNat, but \\N also has an injective map into those, and literals obviously can be turned into \\N (and Lean does this someone preferentially? according to above?). So now we have two paths from lit to custom object that we 1) have to prove they commute 2) rewrite when necessary.</p>",
        "id": 527526461,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1751909771
    },
    {
        "content": "<p>yes this is a hassle</p>",
        "id": 527526516,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751909794
    },
    {
        "content": "<p>but for stuff like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Group#doc\">docs#Group</a> you only want the numeral <code>1</code> and you don't have a map from <code>Nat</code></p>",
        "id": 527526583,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751909819
    },
    {
        "content": "<p>and <code>OfNat</code> can do this too</p>",
        "id": 527526641,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751909841
    },
    {
        "content": "<p>but <code>NatCast</code> cannot</p>",
        "id": 527526657,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751909850
    },
    {
        "content": "<p>Wait, so <code>OfNat(17)</code> works (but presumably gives junk) in a group?</p>",
        "id": 527526859,
        "sender_full_name": "Terence Tao",
        "timestamp": 1751909925
    },
    {
        "content": "<p>no it doesn't</p>",
        "id": 527526905,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751909944
    },
    {
        "content": "<p>typeclass synthesis will find <code>∀ α [Group α], OfNat α 1</code></p>",
        "id": 527526996,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751909996
    },
    {
        "content": "<p>it will not find <code>∀ α [Group α], OfNat α 17</code></p>",
        "id": 527527013,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910002
    },
    {
        "content": "<p>Ah, so <code>OfNat</code> is not a function but rather some sort of metasyntactic object?</p>",
        "id": 527527085,
        "sender_full_name": "Terence Tao",
        "timestamp": 1751910034
    },
    {
        "content": "<p>it is a function</p>",
        "id": 527527109,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910043
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OfNat#doc\">docs#OfNat</a></p>",
        "id": 527527115,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910050
    },
    {
        "content": "<p>it return a type</p>",
        "id": 527527126,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910054
    },
    {
        "content": "<p>and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OfNat.ofNat#doc\">docs#OfNat.ofNat</a> gets the value out</p>",
        "id": 527527138,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910062
    },
    {
        "content": "<p>just like how <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Group#doc\">docs#Group</a> is a function that returns a type</p>",
        "id": 527527179,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910084
    },
    {
        "content": "<p>and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Group.inv_mul_cancel#doc\">docs#Group.inv_mul_cancel</a> is a gets you the cancellation</p>",
        "id": 527527210,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910102
    },
    {
        "content": "<p><code>Group α</code> is \"the type of all the ways you can make <code>α</code> into a group\"</p>",
        "id": 527527356,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910178
    },
    {
        "content": "<p>so what type would <code>OfNat α 17</code> return for <code>(α: Type u) [Group α]</code>?</p>",
        "id": 527527360,
        "sender_full_name": "Terence Tao",
        "timestamp": 1751910182
    },
    {
        "content": "<p><code>OfNat α 17</code> doesn't reduce</p>",
        "id": 527527429,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910210
    },
    {
        "content": "<p>but it's equivalent to <code>α</code></p>",
        "id": 527527464,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910227
    },
    {
        "content": "<p>typeclass synthesis is a way to find a \"canonical\" inhabitant of a type</p>",
        "id": 527527498,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910247
    },
    {
        "content": "<p>so for example it can find a \"canonical\" group structure on <code>α</code>, which is the \"canonical\" inhabitant of <code>Group α</code></p>",
        "id": 527527579,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910282
    },
    {
        "content": "<p>there is no \"canonical\" inhabitant of <code>∀ α [Group α], OfNat α 17</code>, according to typeclass</p>",
        "id": 527527661,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910320
    },
    {
        "content": "<p>so it fails</p>",
        "id": 527527669,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910324
    },
    {
        "content": "<p>Oh ok I think I see.</p>",
        "id": 527527689,
        "sender_full_name": "Terence Tao",
        "timestamp": 1751910332
    },
    {
        "content": "<p>A related question: <code>Int</code>, for instance, has the <code>Zero</code> and <code>One</code> classes which presumably give instances of <code>OfNat Int 0</code> and <code>OfNat Int 1</code>, but there is also the more general <code>OfNat Int n</code> coming from <code>Nat.cast</code> for arbitrary literals <code>n</code>.  What prevents instance diamonds from occurring here?</p>",
        "id": 527527858,
        "sender_full_name": "Terence Tao",
        "timestamp": 1751910410
    },
    {
        "content": "<p>they turn out defeq</p>",
        "id": 527527898,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910429
    },
    {
        "content": "<p>but this doesn't work for general <del>rings</del> <del>semirings</del> add monoids with one, so we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.AtLeastTwo#doc\">docs#Nat.AtLeastTwo</a></p>",
        "id": 527527986,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910468
    },
    {
        "content": "<p>It is indeed a pain point making these defeq, and this is the reason we have that weird \"at least two\" typeclass (which did not exist in Lean 3, which had another numeral system)</p>",
        "id": 527528048,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751910496
    },
    {
        "content": "<p>and the instance is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instOfNatAtLeastTwo#doc\">docs#instOfNatAtLeastTwo</a></p>",
        "id": 527528088,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751910512
    },
    {
        "content": "<p>got it</p>",
        "id": 527528134,
        "sender_full_name": "Terence Tao",
        "timestamp": 1751910527
    },
    {
        "content": "<p>When I wrote the Lean companion I basically copied off of what Mathlib classes like <code>Int</code> were doing to implement natural number coercions, literals, etc..  It worked so I didn't question it, but now I understand things a bit better.</p>",
        "id": 527528274,
        "sender_full_name": "Terence Tao",
        "timestamp": 1751910577
    },
    {
        "content": "<blockquote>\n<p>Ah, so <code>OfNat</code> is not a function but rather some sort of metasyntactic object?</p>\n</blockquote>\n<p>That's what I thought too, purely based on seeing the parens <code>ofNat(n)</code> instead of <code>ofNat n</code>. But now I see when I hover on those, that they are macros on top of the it's just a typeclass function <code>OfNat.ofNat</code> - <a href=\"https://florisvandoorn.com/carleson/docs/Mathlib/Tactic/OfNat.html\">https://florisvandoorn.com/carleson/docs/Mathlib/Tactic/OfNat.html</a> . So based on this and reading the docs more carefully, the metamagic happens when (3 : T) gets turned <code>OfNat.ofNat T 3 [instance of OfNat T 3]</code> (where 3 is now actual <code>\\N</code>) but the rest is normal type-class resolution.</p>",
        "id": 527541948,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1751914898
    },
    {
        "content": "<p>Back to something more concrete. I have <code>h: ↑x = 1</code> where <code>x: nat.toSubtype</code> and the up arrow (coersion?) is from <code>nat</code> to <code>Object</code>. I want to have <code>x = 1</code> in <code>nat</code>. Which <code>_inj</code> lemma to use?</p>\n<p>By trial and error I found out that</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">coe_inj</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>works but notice <code>coe_inj</code> doesn't mention the literal at all its injective property of the <code>nat -&gt; object</code>. Is there a better way? and if not how would I have known to use <code>coe_inj</code> despite all the literal machinery I see when I hover over <code>1</code> (in a sense I have transformed what 1 means when I went from the first statement to the second).</p>",
        "id": 527543151,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1751915248
    },
    {
        "content": "<p>Also why is the above not the same as just <code>rw [coe_inj] at h</code> (which lean doesn't accept)?</p>",
        "id": 527546612,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1751916322
    },
    {
        "content": "<p><code>norm_cast</code> does this kind of simplification</p>",
        "id": 527547345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751916543
    },
    {
        "content": "<p>rewriting with <code>coe_inj</code> doesn't work because it requires the hypothesis to have type <code>↑x = ↑1</code> instead of <code>↑x = 1</code></p>",
        "id": 527547783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751916674
    },
    {
        "content": "<p>How did <code>exact</code> exact succeed then?</p>",
        "id": 527547934,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1751916720
    },
    {
        "content": "<p>exact matches up to defeq, <code>rw</code> matches up to syntactic eq</p>",
        "id": 527548079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1751916764
    },
    {
        "content": "<p>I see. Is there a version of rw that matches fuzzily up to defeq objects?</p>",
        "id": 527548274,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1751916832
    },
    {
        "content": "<p>I figured I can rewrite the above to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">      </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">coe_inj</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>but it still feels like a mouthful.</p>",
        "id": 527548739,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1751916975
    },
    {
        "content": "<p>There's <code>erw</code>, though that fuzzy matching tends to be seen as an antipattern</p>",
        "id": 527552305,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1751918344
    }
]