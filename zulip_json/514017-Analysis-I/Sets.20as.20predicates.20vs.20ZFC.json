[
    {
        "content": "<p>When I looked a the <code>powerset</code> definition in <em>Mathlib itself</em>, I was surprised to find it was just</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- `ùí´ s` is the set of all subsets of `s`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">powerset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚äÜ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Given how much attention we pay to construct things \"from the ground up\" without using universal specification in the book, \"eh, it's just a set of all subsets\" in Mathlib confused me.</p>\n<p>I then remembered that in Mathlib, Sets are <em>literally</em> just predicates. And it does make sense that type theory protects us from the Russell's paradox. So I guess it's not really \"universal\" specification ‚Äî we're only selecting from the <code>Set (Set Œ±) </code> <em>type</em> ‚Äî and presumably somehow that construction can be shown to satisfy the ZFC axioms.</p>\n<p>Is there a good intuitive way to think about why type theory makes it \"okay\" to think about Sets as predicates? And how to bridge that with the axioms we use in the book? I know there's the 3.x epilogue which sets up the mapping but I get lost reading that.</p>",
        "id": 530238790,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753226622
    },
    {
        "content": "<p>The mental translation that one should make is:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>Type theory | Set theory\n========================\nType        | Set\nSet         | Subset\n</code></pre></div>\n<p>i.e. when you see the word <code>Set</code> in Lean, just say \"subset\" in your head -- </p>\n<p>with this translation, it becomes obvious that <code>Set (Set Œ±)</code> is allowed, because in ZFC <code>P(P(A))</code> is also allowed.</p>\n<p>Recall also that in ZFC you are allowed to form any (definable) subset of a set, with the axiom schema of specification.</p>",
        "id": 530239191,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753226930
    },
    {
        "content": "<p>Ok that seems insightful.</p>\n<p>So in Lean, the type theory takes care of building the hierarchy \"upwards\" that we can select from, and then the actual <code>Set</code> is like a way to \"specify\" a smaller thing from that already \"prebuilt\" hierarchy.</p>\n<p>And I guess we can think of the \"specifying predicate\" we pass to Lean <code>Set</code> as being 1:1 with the ZFC subsets of that type? Because a function to <code>true</code>/<code>false</code> is 1:1 with powerset elements?</p>",
        "id": 530239702,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753227366
    },
    {
        "content": "<p>yes, i mean, this is also \"literally true\" in mathlib's standard model of ZFC</p>",
        "id": 530239779,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753227416
    },
    {
        "content": "<p>Thanks for explaining, kind of obvious in retrospect but I had difficulty with it.</p>",
        "id": 530240032,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753227606
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"418569\">@Dan Abramov</span> here's the lean proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">set_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">sep</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_powerset</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">subset_def</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mem_sep</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">tauto</span><span class=\"bp\">‚ü©</span>\n<span class=\"w\">  </span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">right_inv</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_powerset</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">    </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>",
        "id": 530240637,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753228130
    },
    {
        "content": "<p>(and please don't PR this to mathlib)</p>",
        "id": 530240675,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753228167
    }
]