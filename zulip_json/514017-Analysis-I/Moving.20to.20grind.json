[
    {
        "content": "<p>I've noticed anecdotally that <code>grind</code> seems to work better than <code>aesop</code> (or <code>simp_all</code>) but it only seems activated for lemmas specifically tagged for grind.</p>\n<p>Should we tag existing simp lemmas as also being grind lemmas? Is the best practice to leave both or to fully move over to grind? Not sure what makes sense for the book content.</p>\n<p>Overall I wish <code>grind</code> could be used in more places because it feels faster. Though maybe it's because there aren't as many <code>grind</code> lemmas yet.</p>",
        "id": 539776846,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1758031118
    },
    {
        "content": "<p>One downside of <code>grind</code> is it seems less obvious how to check what lemmas it used. I'm sure there's some way to do that? With <code>aesop</code> I just write <code>aesop?</code> and it tells me.</p>",
        "id": 539777087,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1758031172
    },
    {
        "content": "<p>Grind is different from simp. This is explained in the lean reference manual</p>",
        "id": 539821584,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1758043267
    },
    {
        "content": "<p>I’m aware that it is not literally the same thing. My point is that <code>aesop</code> and <code>grind</code> seem to solve similar goals (or maybe that’s wrong?) but <code>aesop</code> seems slower and less powerful so I’d like to replace more of its usage by <code>grind</code>. But unlike <code>aesop</code>, which seems to be aware of simp lemmas, <code>grind</code> isn’t. So the question is whether we should go over already marked lemmas and mark then for grind too.</p>\n<p>If there’s a bigger point you disagree with, I’d appreciate you being more explicit. “RTFM” is rarely a helpful response.</p>",
        "id": 539822900,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1758043731
    },
    {
        "content": "<p>I'm still getting a feel for how best to use grind, but here's what I've found helpful so far:</p>\n<ol>\n<li>You can use <code>grind [myTheorem1, myTheorem2]</code> to try out specific theorems without \"committing\" to having them marked with the grind attributes</li>\n<li><code>grind</code> the tactic is also available in <code>grind?</code> and <code>grind only [...]</code> variants that can give you more visibility into the lemmas used. I don't think there is a way for it to tell you about lemmas that can be removed, it seems like the grind architecture is not designed for this.</li>\n<li>The grind \"tags\" are more complicated than simp tags, it teaches grind how to \"instantiate\" theorems, and you can use variants like <code>@[grind =]</code> (documented <a href=\"https://lean-lang.org/doc/reference/latest//The--grind--tactic/E___matching/#e-matching-patterns\">here</a>) to get finer control over the instantiation. I'm still trying to fully grok this, but playing around with the examples on that page was pretty useful.</li>\n<li>On simp vs grind, my mental model (others please correct if I'm wrong) is that there are some proofs that have \"rewrite this expression into a more complicated form\" as an intermediate step, and <code>grind</code> is designed to be able to find them, but <code>simp</code> is not, and this is why it's harder to annotate grind lemmas (you don't want <code>grind</code> to do a lot of useless simpler -&gt; more complicated rewriting). An example of such a proof might be, rewrite <code>1</code> with <code>10^0</code> so that at the next step, you can use some lemma like <code>a^x b^x = (ab)^x</code>. Also, if I have a proof step that looks like \"do the obvious simplifications\" (no clever rewriting), stylistically I prefer to use <code>simp</code> even when <code>grind</code> works, but that is just a personal preference.</li>\n</ol>",
        "id": 539825966,
        "sender_full_name": "Li Xuanji",
        "timestamp": 1758044730
    },
    {
        "content": "<blockquote>\n<p>One downside of <code>grind</code> is it seems less obvious how to check what lemmas it used. I'm sure there's some way to do that? With <code>aesop</code> I just write <code>aesop?</code> and it tells me.</p>\n</blockquote>\n<p><code>grind</code> also has <code>grind?</code> (EDIT: saw this mentioned). Or you can do <code>set_option trace.grind.ematch true</code>, which shows why a lemma was instantiated.</p>",
        "id": 541561434,
        "sender_full_name": "Lawrence Wu (llllvvuu)",
        "timestamp": 1758845004
    },
    {
        "content": "<p>I haven't used grind at all in this project so far, but also curious to start using it more. My mental model is there is a partial ordering:<br>\n1) rw &lt; simp<br>\n2) simp &lt; domain specific tactics - tauto, omega, positivitiy, norm_cast, linarith (all of those are not comparable with each other)<br>\n3) simp &lt; aesop<br>\n4) domain specific tactics &lt; aesop<br>\nIs this correct? Good style mandates one uses the least powerful tactic that closes the goal, but one needs a clear picture of the power of the tactic to apply that.</p>\n<p>I haven't read much about aesop, but also rarely use it because it is at the top of the tactics power order, so it is the last tactic to try (I noticed it shines when one needs to introduce by case analysis). AFAIU, grind is plays in the same spaces a aesop (not domain specific, and more powerful than simp). Is that true? If so I will start swapping aesop with it.</p>",
        "id": 541698855,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1758901482
    },
    {
        "content": "<p>simp and domain specific tactics have no ordering.</p>",
        "id": 541752727,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1758924868
    },
    {
        "content": "<p>They are meant to construct proofs differently under the presence of different kinds of hypothesis</p>",
        "id": 541752784,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1758924919
    }
]