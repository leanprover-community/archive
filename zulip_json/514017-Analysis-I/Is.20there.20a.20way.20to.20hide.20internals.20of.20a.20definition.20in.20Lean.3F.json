[
    {
        "content": "<p>I rebased and cleaned up some of my solutions for 3.3, and now I understand a lot of the pain comes from unintentionally expanding the definition of Function to its definitionally equal, but too complicated internals. Very similar thing happened in Ch3.5 for Cartesian product and OrderedPairs.</p>\n<p>For example, every time I wanted to do something with <code>f = g</code> I used <code>ext</code> which dropped all the way down to the underlying proposition <code>f.P x y \\iff g.P. x y</code>, but after looking over <span class=\"user-mention\" data-user-id=\"418569\">@Dan Abramov</span> 's answers I see it works way better to just use <code>Function.fn_ext</code> and just work with Lean functions. Similarly, calling <code>simp</code> will often reduce too deep.</p>\n<p>Is there a notion of information hiding, private/public, etc (trying not to bias towards OOPs way of solving this), where one is not allowed or at least discouraged to reduce too deep and thus nudged to look for the right theorems? The theorem themselves should be able to access the internal representation in their proofs.</p>",
        "id": 530257821,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1753243229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488971\">Rado Kirov</span> <a href=\"#narrow/stream/514017-Analysis-I/topic/Is.20there.20a.20way.20to.20hide.20internals.20of.20a.20definition.20in.20Lean.3F/near/530257821\">said</a>:</p>\n<blockquote>\n<p>Similarly, calling <code>simp</code> will often reduce too deep.</p>\n</blockquote>\n<p>Creating good API and curating a simp set are skills one acquires. In particular, having a lemma which unfolds any application of some definition <em>marked as simp</em> tends to be bad. (In particular, it doesn't <em>simplify</em> the goal.) Instead, good simp lemmas for a function tend to be one which describes the behaviour of classes of arguments. For example, a simp lemma might describe how <code>Prod.map</code> acts on <code>Prod.mk a b</code>, but not on a general variable of type <code>Prod A B</code>.</p>",
        "id": 530312236,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1753266759
    },
    {
        "content": "<p>Yes, it is pretty standard software engineering practice, but only after doing the exercises in Ch3 I am starting to get a sense of what does this practically mean in Lean. In regular software evaluation runs only in one direction, while in proof assistants rewriting could run both ways, and it takes extra care by the theorem writers to emulate that one-directionality.</p>\n<blockquote>\n<p>unfolds any application of some definitionÂ <em>marked as simp</em></p>\n</blockquote>\n<p>I have to go back and see what exactly happened, but I also noticed <code>simp only []</code> doing expansions. AFAIK, <code>simp only []</code> only does defeq rewriting, but what if sometimes we don't want that?</p>",
        "id": 530371980,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1753283793
    },
    {
        "content": "<p>afaik <code>simp only []</code> is unable to do any rewriting, only reductions like <code>(fun x =&gt; x + 1) y ~&gt; y + 1</code> and maybe proving a <code>True</code> goal... usually these are harmless</p>",
        "id": 530534965,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1753356444
    }
]