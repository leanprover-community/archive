[
    {
        "content": "<p>Hello, I'm new to both lean and analysis. I'm struggling to understand theorem <code>Nat.succ_ne</code>, specifically this line:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>Going in, we have tactic state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">False</span>\n</code></pre></div>\n<p>My understanding of injection is that it requires both sides of the equality to be expressible as the same constructor, and it will transform the equality into equalities between each of the arguments of the constructor. I don't understand how this can apply here, as <code>n++</code> and <code>0</code> do not use the same constructor.</p>\n<p>The book introduces this as an axiom, so it doesn't give any insight into the reasoning here either. The rest of the theorems in the section make sense to me (including <code>succ_cancel</code> which also uses injection), it's only this one I'm stumped on.</p>",
        "id": 539427648,
        "sender_full_name": "intarga",
        "timestamp": 1757872555
    },
    {
        "content": "<p>it works when both sides of the equality have the same constructor, and it will use constructor injectivity to break it into equality of the parts</p>\n<p>it also works when the equality is between two different constructors, and it will use constructor injectivity to derive a contradiction</p>",
        "id": 539427911,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757872777
    },
    {
        "content": "<p>Ahh I see!</p>\n<p>But then the book discusses a similar number system that \"wraps around\", so this theorem shouldn't apply there, does that mean that that number system could not be defined with two constructors like <code>Nat</code>?</p>",
        "id": 539428083,
        "sender_full_name": "intarga",
        "timestamp": 1757872912
    },
    {
        "content": "<p>the property of <code>Nat</code> which allows you to prove this is that <code>Nat</code> is initial</p>",
        "id": 539428178,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757872962
    },
    {
        "content": "<p>that means you can do recursive pattern matching on it and the resulting function satisfies some definitional reductions</p>",
        "id": 539428217,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757872989
    },
    {
        "content": "<p>Initial meaning it has an initial value <code>0</code> that others can be constructed from? What determines that <code>Nat</code> is initial? The fact that it has one and only one constructor which doesn't take an argument?</p>",
        "id": 539428438,
        "sender_full_name": "intarga",
        "timestamp": 1757873157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"935101\">intarga</span> <a href=\"#narrow/channel/514017-Analysis-I/topic/Understanding.20the.20use.20of.20.60injection.60.20in.20Ch2.2E1/near/539428438\">said</a>:</p>\n<blockquote>\n<p>Initial meaning it has an initial value <code>0</code> that others can be constructed from? What determines that <code>Nat</code> is initial? The fact that it has one and only one constructor which doesn't take an argument?</p>\n</blockquote>\n<p>initial in the category-theory sense, that for any other type <code>X</code> with functions <code>zero : X</code> and <code>succ : X → X</code>, there exists a unique map <code>f : Nat → X := Nat.rec zero (fun _ =&gt; succ)</code> such that <code>f 0 = zero</code> and <code>f n++ = succ (f n)</code></p>",
        "id": 539428636,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757873290
    },
    {
        "content": "<p>here's a proof using the raw recursors</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"bp\">@</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">False</span>\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">hn</span>\n</code></pre></div>",
        "id": 539428749,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757873374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"935101\">intarga</span> <a href=\"#narrow/channel/514017-Analysis-I/topic/Understanding.20the.20use.20of.20.60injection.60.20in.20Ch2.2E1/near/539428438\">said</a>:</p>\n<blockquote>\n<p>What determines that <code>Nat</code> is initial? The fact that it has one and only one constructor which doesn't take an argument?</p>\n</blockquote>\n<p>All inductive types are initial</p>",
        "id": 539428783,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757873398
    },
    {
        "content": "<p>it's like the definition of inductive type or something</p>",
        "id": 539428819,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757873431
    },
    {
        "content": "<p>Looking it from the lean side, no, a function where <code>succ succ succ ... zero</code> would be equal to <code>zero</code> can't be implemented in lean as an inductive type that looks like <code>Nat</code></p>",
        "id": 539428820,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1757873432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/514017-Analysis-I/topic/Understanding.20the.20use.20of.20.60injection.60.20in.20Ch2.2E1/near/539428783\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"935101\">intarga</span> <a href=\"#narrow/channel/514017-Analysis-I/topic/Understanding.20the.20use.20of.20.60injection.60.20in.20Ch2.2E1/near/539428438\">said</a>:</p>\n<blockquote>\n<p>What determines that <code>Nat</code> is initial? The fact that it has one and only one constructor which doesn't take an argument?</p>\n</blockquote>\n<p>All inductive types are initial</p>\n</blockquote>\n<p>Ok, this makes sense to me. So it would be correct to say that a \"wrapping\" number system as described in the book would not be definable as an inductive type?</p>",
        "id": 539428960,
        "sender_full_name": "intarga",
        "timestamp": 1757873536
    },
    {
        "content": "<p>you can't define such a wrapping number system in Lean as an inductive type with <code>succ</code> as a constructor</p>",
        "id": 539429094,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757873637
    },
    {
        "content": "<p>Excellent, thanks a bunch for the help!</p>",
        "id": 539429122,
        "sender_full_name": "intarga",
        "timestamp": 1757873656
    },
    {
        "content": "<p>It is an (in my mind) pretty amazing fact that Lean manages to shrink Peano's original bunch of axioms down to three:</p>\n<p>1) zero is a natural<br>\n2) the successor of a natural is a natural<br>\n3) That's it.</p>\n<p>What (3) means formally is \"the only way you can make naturals is via (1) and (2)\", a.k.a. \"if you want to do something for all naturals, it suffices to (a) do it for zero and, (b) assuming you've done it for n, do it for the successor of n\" a.k.a. the principle of mathematical recursion (which contains induction as a special case, where the thing you're doing for n is proving the statement P(n)). Using only this, you can actually prove things like the successor function being injective, 0 not being a successor and so on. I do this in the natural number game.</p>",
        "id": 539633856,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757964585
    }
]