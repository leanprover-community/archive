[
    {
        "content": "<p>Had a long flight back to San Francisco from London, so managed to wrap up ch4.2 too. I am down to one final error, but it is very mysterious to a beginner like me.</p>\n<p>I have added proofs for the 5 axioms needed to turn our homemade Rats into a Commutative Ring - <a href=\"https://github.com/rkirov/analysis/blob/main/analysis/Analysis/Section_4_2.lean#L354-L442\">https://github.com/rkirov/analysis/blob/main/analysis/Analysis/Section_4_2.lean#L354-L442</a>. The proofs type-check without error. However, I get an error over the <code>where</code> clause about failure to synthesize a default field <code>natCast_succ</code>.</p>\n<p><a href=\"/user_uploads/3121/5-wiyJhfIvaepHMgT_B5No5C/Screenshot-2025-08-23-at-4.47.39AM.png\">Screenshot 2025-08-23 at 4.47.39 AM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/5-wiyJhfIvaepHMgT_B5No5C/Screenshot-2025-08-23-at-4.47.39AM.png\" title=\"Screenshot 2025-08-23 at 4.47.39 AM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1592x600\" src=\"/user_uploads/thumbnail/3121/5-wiyJhfIvaepHMgT_B5No5C/Screenshot-2025-08-23-at-4.47.39AM.png/840x560.webp\"></a></div><p>How can I resolve this?</p>\n<ul>\n<li>should I try to manually define <code>natCast_succ</code>?</li>\n<li>given I have only provided proofs in the instance, I assume there is nothing I can do to the proofs themselves to fix this? Is there anything I can redefine to make this go away? What would that be?</li>\n</ul>",
        "id": 535801526,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1755949845
    },
    {
        "content": "<p>Various casts are here - <a href=\"https://github.com/rkirov/analysis/blob/main/analysis/Analysis/Section_4_2.lean#L162-L193\">https://github.com/rkirov/analysis/blob/main/analysis/Analysis/Section_4_2.lean#L162-L193</a> , can they be fixed for this to work?</p>",
        "id": 535801611,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1755949952
    },
    {
        "content": "<p>Yeah, you can manually define the field</p>",
        "id": 535803507,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1755951974
    },
    {
        "content": "<p>ok, will try that next, also rebasing to upstream head, to see if it will magically go away</p>",
        "id": 535804043,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1755952512
    },
    {
        "content": "<p>rebasing didn't help, but manually providing a proof fixed it - <a href=\"https://github.com/rkirov/analysis/blob/main/analysis/Analysis/Section_4_2.lean#L441-L448\">https://github.com/rkirov/analysis/blob/main/analysis/Analysis/Section_4_2.lean#L441-L448</a>.</p>\n<p>Surprised, this error didn't show up earlier, and only happened after I provided the proofs of the other 5 properties. Feels independent of those.</p>",
        "id": 535811491,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1755961488
    },
    {
        "content": "<p>Oh, this is because the lean file had already introduced a <code>NatCast Rat</code> at an earlier stage, which Lean doesn't \"know\" is equivalent to the autogenerated <code>NatCast Rat</code> that a <code>CommRing Rat</code> structure would provide.  One <em>could</em> delete that previous <code>NatCast</code> to allow the autogenerated <code>NatCast</code> to go through, and then provide a followup lemma to ensure that the autogenerated <code>NatCast</code> agrees with the book <code>NatCast</code>, but this would deviate from the spirit of the source text, so I guess one should just add <code>natCast_succ</code> as one of the fields the student has to fill in for this exercise (maybe with some comment to explain why it is needed).</p>",
        "id": 535858032,
        "sender_full_name": "Terence Tao",
        "timestamp": 1755975493
    },
    {
        "content": "<p>Ah, that makes sense. Indeed removing the custom NatCast makes the error go away.</p>\n<p>But it feels slightly different from mixing the custom NatCast from the autogenerated one, because hovering over the casts in <code>natCast_succ</code> it seems like there is a single instance - the custom one. The theorem Lean is asking for is not about equivalence between the custom and autogenerated one.</p>\n<p>Turns out even before defining <code>CommRing Rat</code>, our custom <code>natCast</code> doesn't have a simple <code>rfl</code> proof of <code>natCast_succ</code>, and it seems to me that when defining <code>CommRing</code> Lean tries to reuse the default <code>rfl</code> proof and fails.</p>\n<p>What do you think about making the following change (will send a PR shortly):</p>\n<ul>\n<li>add <code>theorem Rat.coe_Nat_succ (n: ℕ) : ((n + 1: ℕ): Rat) = (n: Rat) + 1 := by sorry</code> right after custom <code>natCast</code> is defined</li>\n<li>add <code>natCast_succ := Rat.coe_Nat_succ</code> with a comment to <code>CommRing</code> definition.</li>\n</ul>",
        "id": 535861722,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1755980540
    },
    {
        "content": "<p>Sounds good to me!</p>\n<p>I believe <code>CommRing</code> will not attempt to introduce an autogenerated <code>NatCast</code> if it detects that one already exists, since this would create a dreaded \"instance diamond\" which is almost never a good idea to introduce.  As a consequence, it will also fail to auto-generate <code>natCast_succ</code>.</p>\n<p>But I was mentioning an alternate way to resolve the issue by instantiating <code>CommRing</code> first - with the autogenerated <code>NatCast</code> - and only afterwards adding a lemma that <code>∀ n: ℕ, (n:Rat) = (n:ℤ) // 1</code> instead of introducing the custom <code>NatCast</code>.  But I prefer the current arrangement over this, as it aligns with the source text from the book.</p>",
        "id": 535863916,
        "sender_full_name": "Terence Tao",
        "timestamp": 1755983425
    },
    {
        "content": "<p>Makes sense - <a href=\"https://github.com/teorth/analysis/pull/314\">https://github.com/teorth/analysis/pull/314</a>. I just realized that the scaffold always had   <code>natCast_succ := by sorry</code> and I must have accidentally have deleted it at some point which add more confusion here, but I think the PR makes it a bit more explicit (in case some is comparing to the CommRing Int definition in ch4.1)</p>",
        "id": 535864777,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1755984740
    },
    {
        "content": "<p>I believe you'll run into the same issue for <code>Real.instCommRing</code>!</p>\n<p>Here was my old solution (transport everything to our custom <code>NatCast</code> instance) - but <span class=\"user-mention\" data-user-id=\"488971\">@Rado Kirov</span> 's looks cleaner. It was helpful for me to rename the custom instance to <code>Rat.instOurCustomNatCast</code> to see what's going on.</p>\n<p>If I understood correctly, the possible conflict was that our custom natcast sent <code>n</code> to <code>(n:ℤ) // 1</code>, but the CommRing instance presumably sent it to <code>1:Rat + 1:Rat + ... </code>, and we do not know a priori that these are equivalent?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Rat</span><span class=\"bp\">.</span><span class=\"n\">natCast_add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">Rat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">Rat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">Rat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">):</span><span class=\"n\">Rat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">Rat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">):</span><span class=\"n\">Rat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Rat</span><span class=\"bp\">.</span><span class=\"n\">intCast_add</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">norm_cast</span>\n\n<span class=\"sd\">/-- Proposition 4.2.4 (laws of algebra) / Exercise 4.2.3 -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">Rat</span><span class=\"bp\">.</span><span class=\"n\">instCommRing</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">Rat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">left_distrib</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">right_distrib</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">zero_mul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">mul_zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">mul_assoc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">natCast_succ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_cast</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">NatCast</span><span class=\"bp\">.</span><span class=\"n\">natCast</span><span class=\"w\"> </span><span class=\"n\">Rat</span><span class=\"w\"> </span><span class=\"n\">instNatCast</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">Rat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Rat</span><span class=\"bp\">.</span><span class=\"n\">natCast_add</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 535911057,
        "sender_full_name": "Li Xuanji",
        "timestamp": 1756051663
    },
    {
        "content": "<blockquote>\n<p>our custom natcast sent <code>n</code> to <code>(n:ℤ) // 1</code>, but the CommRing instance presumably sent it to <code>1:Rat + 1:Rat + ...</code></p>\n</blockquote>\n<p>If I understand <span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> comment correctly, in the presence of custom natcast, lean \"backs off\" from using <code>1:Rat + 1:Rat + ...</code> at together, but now we have the problem that the autogenerated proof for <code>natCast_succ</code> which uses <code>rfl</code> no longer works, so we just need to provide our own non-rfl proof.</p>\n<p>It would be interesting to me to understand how exactly the \"backing off\" works in terms of type class instances.</p>",
        "id": 535911676,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1756052477
    },
    {
        "content": "<p>I think it is <a href=\"https://github.com/leanprover-community/mathlib4/blob/f02623dd9f770baab4e4ad8aa7c969321b802af7/Mathlib/Data/Nat/Cast/Defs.lean#L59-L66\">here</a> in the <code>AddMonoidWithOne</code> class (which <code>CommRing</code> ultimately extends) that the default <code>natCast</code> and <code>natCast_succ</code> are set.  We override <code>natCast</code> with a new function (which is propositionally, but not definitionally, equal to the previous one), and the sequence of tactics provided as a default for <code>natCast_succ</code> no longer works and has to be replaced.</p>",
        "id": 535911933,
        "sender_full_name": "Terence Tao",
        "timestamp": 1756052808
    },
    {
        "content": "<p>yep, this confirms it</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">NatCast</span><span class=\"w\"> </span><span class=\"n\">Rat</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"c1\">--- in info view</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"n\">NatCast</span><span class=\"w\"> </span><span class=\"n\">Rat</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">instances</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">AddMonoidWithOne</span><span class=\"bp\">.</span><span class=\"n\">toNatCast</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Rat</span><span class=\"bp\">.</span><span class=\"n\">instNatCast</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Rat</span><span class=\"bp\">.</span><span class=\"n\">instNatCast</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">NatCast</span><span class=\"w\"> </span><span class=\"n\">Rat</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">tryResolve</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">NatCast</span><span class=\"w\"> </span><span class=\"n\">Rat</span><span class=\"w\"> </span><span class=\"bp\">≟</span><span class=\"w\"> </span><span class=\"n\">NatCast</span><span class=\"w\"> </span><span class=\"n\">Rat</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">answer</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">NatCast</span><span class=\"w\"> </span><span class=\"n\">Rat</span>\n</code></pre></div>\n<p>I think <code>Rat.instNatCast</code> wins because it is provided directly to <code>Rat</code> while <code>AddMonoidWithOne</code> is provided through <code>CommRing</code>.</p>",
        "id": 535931784,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1756076385
    }
]