[
    {
        "content": "<p>I read this several times and struggle to parse it:</p>\n<p><a href=\"/user_uploads/3121/R5PXAcEYduwBvWku73kJPTgo/Screenshot-2025-09-08-at-04.28.10.png\">Screenshot 2025-09-08 at 04.28.10.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/R5PXAcEYduwBvWku73kJPTgo/Screenshot-2025-09-08-at-04.28.10.png\" title=\"Screenshot 2025-09-08 at 04.28.10.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1356x440\" src=\"/user_uploads/thumbnail/3121/R5PXAcEYduwBvWku73kJPTgo/Screenshot-2025-09-08-at-04.28.10.png/840x560.webp\"></a></div><p>How can \"a permutation φ : {<em>i</em> ∈ <strong>N</strong> : 1 ≤ <em>i</em> ≤ <em>n</em>++} → {<em>i</em> ∈ <strong>N</strong> : 1 ≤ <em>i</em> ≤ <em>n</em>}\" make sense if we have 1 ≤ <em>i</em> ≤ <em>n</em>++ before the arrow but 1 ≤ <em>i</em> ≤ <em>n</em> after the arrow? This reads like <code>Fin (n+1) → Fin n</code> to me but then how can we call it a permutation (which has a type like <code>Bijective Fin n → Fin n</code>)?</p>",
        "id": 538124701,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757302251
    },
    {
        "content": "<p>Also, does \"from the set\" mean the same as \"of the set\" here or something different?</p>",
        "id": 538124764,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757302292
    },
    {
        "content": "<p>Maybe the right side should say 1 ≤ <em>i</em> ≤ <em>n++</em> too?</p>",
        "id": 538124824,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757302338
    },
    {
        "content": "<p>Ugh, the text got mangled here for some reason.  Yes, both sets should involve n++ instead of n, and the clause \"from the set {i in N: 1 \\leq i \\leq n++}\" should be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mrow><mi>n</mi><mo>+</mo><mo>+</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">S_{n++}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8917em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2583em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mtight\">++</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span>.  (And of course the parentheses should be closed up.)  This by the way is listed in the errata at <a href=\"https://terrytao.wordpress.com/books/analysis-i/\">https://terrytao.wordpress.com/books/analysis-i/</a></p>",
        "id": 538137326,
        "sender_full_name": "Terence Tao",
        "timestamp": 1757310845
    },
    {
        "content": "<p>Yeah, the extra math notation do make the sentence a bit awkward even with the typos fixed.</p>\n<blockquote>\n<p>Also, does \"from the set\" mean the same as \"of the set\" here or something different?</p>\n</blockquote>\n<p>it reads</p>\n<blockquote>\n<p>partition S into x subsets, depending on the value \\phi(y) a permutation \\phi from the set S assigns to y</p>\n</blockquote>\n<p>for some specific S, x, y and more expanded type for \\phi</p>\n<p>So, yes, I think <code>permutation of set X</code> or <code>permutation from set X (implicitly to X)</code> mean the same thing.</p>",
        "id": 538139913,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757312266
    },
    {
        "content": "<p>Ahh, I didn't scroll down the errata enough (assumed it's all sorted by page). This is page 62 if you'd like to add that (errata currently says <code>Page ???</code>):</p>\n<p><a href=\"/user_uploads/3121/jC6aakyYSIivEnBVOLKDkxhV/Screenshot-2025-09-08-at-10.05.48.png\">Screenshot 2025-09-08 at 10.05.48.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/jC6aakyYSIivEnBVOLKDkxhV/Screenshot-2025-09-08-at-10.05.48.png\" title=\"Screenshot 2025-09-08 at 10.05.48.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1370x668\" src=\"/user_uploads/thumbnail/3121/jC6aakyYSIivEnBVOLKDkxhV/Screenshot-2025-09-08-at-10.05.48.png/840x560.webp\"></a></div>",
        "id": 538169725,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757322369
    },
    {
        "content": "<p>I'm working through this exercise and I'm still not sure how to interpret the hint.</p>\n<p>The idea I'm trying to go with is:</p>\n<p>For each <code>f: Permutations (n + 1)</code>, take <code>f  n</code> (for the left part of the product). For the right side of the product, we need to produce <code>f' : Permutations n</code>. We do this by taking the original function <code>f</code> and restraining its domain to exclude <code>n</code>. This by itself would give us a function <code>Fin n -&gt;  Fin (n+1) \\ {f n}</code>. To \"repair\" its codomain, we reroute whichever <code>x</code> previously pointed at <code>n</code> to the hole left by excluding <code>f n</code>. Then we'd need to make an inverse that does the opposite of this rerouting, and to prove that it's actually an inverse.</p>\n<p>However, this already feels quite annoying (with lots of justifications for messing with Fins). I was wondering whether the hint in the text implies some more convenient approach — either for constructing the inner bijection (proving \"the rerouting\" gives us a bijective function), or for constructing the outer bijection (that this mapping between <code>Permutations (n+1)</code> and the product with our function is itself bijective).</p>\n<p>In particular I'm not sure what's meant by partitioning the set in the hint, and how that helps here.</p>",
        "id": 538327771,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757373332
    },
    {
        "content": "<p>This approach - setting up a bijection between <code>Permutations (n+1)</code> and <code>Fin (n+1) × (Permutations n)</code> - will work.  The hint suggests a very slightly different approach, in which one partitions <code>Permutations (n+1)</code>into <code>n+1</code> disjoint subsets, each of which is separately in bijection with <code>Permutations n</code>; these may end up having slightly different Lean formalizations but at a conceptual level they are nearly identical.</p>",
        "id": 538330268,
        "sender_full_name": "Terence Tao",
        "timestamp": 1757375321
    },
    {
        "content": "<blockquote>\n<p>This approach - setting up a bijection between <code>Permutations (n+1)</code> and <code>Fin (n+1) × (Permutations n)</code> - will work.</p>\n</blockquote>\n<p>Yep, that's what I did. Honestly, I wasn't even sure how to create a family of disjoint partitions and prove they are disjoint and union to the whole set, because there were not earlier exercises along these lines. But there were plenty of show cardinalities are equal by explicit bijection so my brain was biased.</p>\n<p>Btw, it just came to me that I can remove all the surjective directions since those are fns from Fin n to Fin n, so injective implies surjective. Now the proof is 200 lines shorter and Lean no longer chokes on it - <a href=\"https://github.com/rkirov/analysis/commit/c1018dba173b903a49d0bbc913e888d8b8be7d0c\">https://github.com/rkirov/analysis/commit/c1018dba173b903a49d0bbc913e888d8b8be7d0c</a> . Tons of room for improvement left.</p>",
        "id": 538341150,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757385407
    },
    {
        "content": "<p>Where I’m not following along is how does partitioning into disjoint subsets help. Is it because we could then “add them up” one by one and thus we don’t need to construct the outer bijection explicitly? But then we’d need a lemma to repeatedly do <code>card_union_disjoint</code>. Or is there something else I’m missing about how to construct the big bijection from partition bijections?</p>",
        "id": 538394561,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757411118
    },
    {
        "content": "<p>If that’s the intended approach, maybe it would be nice to stub out some intermediate lemma about cardinality of a union of distinct sets</p>",
        "id": 538396157,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757411621
    },
    {
        "content": "<p>Well, the problem was initially written for informal mathematics rather than for Lean, in which the concept of iterating the identity about cardinality of two disjoint sets to an arbitrary finite collection of disjoint sets would be considered \"obvious\".  But for the purposes of creating a Lean proof, an alternate hint may be better - feel free to add one based on your solutions in the docstring of the problem, or in the general \"tips\" section at the start of the file.</p>",
        "id": 538462097,
        "sender_full_name": "Terence Tao",
        "timestamp": 1757430770
    },
    {
        "content": "<blockquote>\n<p>If that’s the intended approach, maybe it would be nice to stub out some intermediate lemma about cardinality of a union of distinct sets</p>\n</blockquote>\n<p>If you go that route you want something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">card_iUnion_of_pairwise_disjoint</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_sub</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_disj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_complete</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">iUnion</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_finite</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But we never used \\sum so far, and never make \\sum support our custom Fin n. Ultimately, I am not even sure if the proof going this route is that much simpler than the explicit bijection that I did.</p>",
        "id": 538471057,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757433205
    },
    {
        "content": "<p>Thanks, that signature is helpful. I wasn't able to prove that one (I think we'd need <code>Finset</code>-like machinery for it) but I did manage to prove this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">card_iUnion_card_disjoint</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hSc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">has_card</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hScd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pairwise</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">iUnion</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">iUnion</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>I haven't looked closely at whether it actually \"helps\" 3.6.12 but I'll give a try later.</p>",
        "id": 538615808,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757500287
    },
    {
        "content": "<p>I've managed to complete the exercise (in a week) but the code is very ugly. The construction I went with initially (swapping items) was too complicated because I had to <code>by_cases</code> on a bunch of conditions. So I'm redoing it now with a \"shift by one\" strategy.</p>\n<p>I also found that the shape of the argument of showing the bijection, when following the path of least resistance (\"whatever the goal says\"), obscures what's happening. I'm sure there must be a much more concise way to talk about this. I've only yesterday realized that <code>Permutations n</code> is really just an <code>Equiv (Fin n) (Fin n)</code> (aka <code>Equiv.Perm (Fin n)</code>) in Mathlib terms. And what we're trying to establish is sort of an equivalence between equivalences — something like <code>{f : Fin (n+1) ≃ Fin (n+1) // f n' = i} ≃ (Fin n ≃ Fin n)</code>.</p>\n<p>So I'll try to redo my solution while following this \"nested equivalences\" structure which I expect to be much more legible.</p>\n<p>Annoyingly, the argument in my head is even more concise than what I'm writing. In my head, I split the original bijective function in two (based on whether the output is larger than <code>i</code> index of <code>S i</code>), they're both obviously bijective, then I apply a <code>x =&gt; x - 1</code> transformation to one of those slices (which is bijective so preserves the bijectivity), then I \"glue\" them together (and since their codomains don't overlap, the glued function also remains bijective). This transformation itself is a sequence of applying bijections, therefore it must also somehow be bijective and should be possible to apply in reverse.</p>\n<p>I suspect there's some very short way to write this armed with Mathlib idioms around <code>Fin</code> and <code>Equiv</code>. Mathlib has <code>succAbove</code> and  <code>predAbove</code> for <code>Fin</code> which seem relevant, or maybe <code>sumCompl</code> or something for splitting and gluing equivalences.</p>\n<p>For now I'll see if writing nested equivalences explicitly simplifies the argument from my original form.</p>",
        "id": 539746667,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1758023035
    },
    {
        "content": "<p>OK I have pretty good progress on this, should be able to PR some scaffolding I found useful in the next few days.</p>",
        "id": 539901785,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1758061221
    },
    {
        "content": "<p>Nice, looking forward to the scaffolding and will give it some playtesting.</p>\n<p>Mathematically, what you are describing makes sense, but I wonder if the Lean types will make this messier / awkward. The already provided solution  <code>card_erase</code> also deals with \"the create a new  function with all images after f n shifted down) <a href=\"https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_3_6.lean#L93-L112\">https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_3_6.lean#L93-L112</a> , so I styled my solution around that same method.</p>\n<p>If you instead split the original permutation, into two bijections: ones that map to images before f n and ones that map to after f n, you will have bijections (hence Equivs of sets), but the domains are no longer describable well (they some random sets that union to all of Fin n + 1). Anyways, sounds like you made it work, so looking forward to seeing it.</p>",
        "id": 539917576,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1758075033
    },
    {
        "content": "<p>Yeah I actually ended up close to your approach (nothing too fancy) but it can be made a lot more concise and legible by adding some machinery.</p>",
        "id": 539978177,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1758104501
    },
    {
        "content": "<p>Alright, here goes! <a href=\"https://github.com/teorth/analysis/pull/360\">https://github.com/teorth/analysis/pull/360</a></p>",
        "id": 540025355,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1758118119
    },
    {
        "content": "<p>Nice! You used the split to <code>n</code> disjoint sets approach and the specialized card lemma for this. That is cleaner that the explicit Permutations n + 1 ~ Fin (n + 1) \\x Permutations n bijection I used.</p>",
        "id": 540031979,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1758119666
    }
]