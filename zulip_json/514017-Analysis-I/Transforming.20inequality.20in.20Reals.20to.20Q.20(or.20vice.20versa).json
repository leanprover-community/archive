[
    {
        "content": "<p>I got one of the proofs down to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℚ</span>\n<span class=\"n\">hq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑|</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span>\n</code></pre></div>\n<p>(using <code>pp.coersions.types true</code>), but can't seem be able to transform the goal to be in Q and apply hq. This is after applying <code>norm_cast</code> on both.</p>",
        "id": 538771360,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757565753
    },
    {
        "content": "<p>I would try to find a lemma that for a b : Rat, a ≤ b iff (a:Real) ≤ (b:Real) and use that on hq. And then hope that simpa finishes</p>",
        "id": 538777108,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1757570400
    },
    {
        "content": "<p>I think I proved that here <a href=\"https://github.com/rkirov/analysis/blob/main/analysis/Analysis/Section_5_4.lean#L1305-L1315\">https://github.com/rkirov/analysis/blob/main/analysis/Analysis/Section_5_4.lean#L1305-L1315</a></p>\n<p>But I have two problems</p>\n<p>1) very basic - but how to actually use <code>Real.ratCast_ordered_hom: ℚ →+*o Real</code>? Do I just <code>rw [Real.ratCast_ordered_hom.monotone']</code>?<br>\n2) more importantly, the cast on the RHS is before the ^-1, so I have to move it out first.</p>",
        "id": 538778842,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757571503
    },
    {
        "content": "<p>Do you know about <code>rw?</code>? It is often useful for suggesting lemma names for rewrites from the current goal, particularly when the current goal is relatively small.</p>",
        "id": 538796684,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757578651
    },
    {
        "content": "<p>Presumably <code>Real.inv_ratCast</code> should help with (2).  For (1) we have <code>Real.lt_of_coe</code> but one needs the variant <code>Real.le_of_coe</code> which doesn't currently exist, but it makes sense to add it (and <code>Real.ge_of_coe</code> too, for completeness).  <code>Real.ratCast_ordered_hom.monotone'</code> is an implication, not an iff, so an <code>apply</code> (or perhaps a <code>convert Real.ratCast_ordered_hom.monotone' _ _</code>, in case things are not defeq enough) would be needed.</p>",
        "id": 538850261,
        "sender_full_name": "Terence Tao",
        "timestamp": 1757595028
    },
    {
        "content": "<blockquote>\n<p>Do you know about <code>rw?</code></p>\n</blockquote>\n<p>Yes, I use it a lot together with <code>exact?</code> and <code>apply?</code>. It doesn't seem to show me anything useful in this case.</p>\n<p><a href=\"/user_uploads/3121/1mCs2wH0nU_MyvftYujZn-Z2/Screenshot-2025-09-11-at-7.38.03AM.png\">Screenshot 2025-09-11 at 7.38.03 AM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/1mCs2wH0nU_MyvftYujZn-Z2/Screenshot-2025-09-11-at-7.38.03AM.png\" title=\"Screenshot 2025-09-11 at 7.38.03 AM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"682x936\" src=\"/user_uploads/thumbnail/3121/1mCs2wH0nU_MyvftYujZn-Z2/Screenshot-2025-09-11-at-7.38.03AM.png/840x560.webp\"></a></div><blockquote>\n<p>Presumably <code>Real.inv_ratCast</code> should help with (2).</p>\n</blockquote>\n<p>Surprisingly it didn't directly. Took a bit to figure out why? Turns out in the original expression <code>M + 1</code> is Nat, not Q, so there is no way to directly swap with ^-1.</p>\n<p>This lead me to add <code>rw [show (M:Real) = ((M:ℚ):Real) by rfl]</code> (in earlier state, which is easier than M + 1 to state, because then one has to force the right version of +). Turns out after this simple change <code>norm_cast</code> closes the whole proof <span aria-label=\"partying face\" class=\"emoji emoji-1f973\" role=\"img\" title=\"partying face\">:partying_face:</span></p>",
        "id": 538877987,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757601693
    },
    {
        "content": "<p>On the meta level, I am running into a bunch of cases like this and this thread - <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/Tactic.20for.20stupid.20inequality/with/537933027\">#Is there code for X? &gt; Tactic for stupid inequality</a> . Basically:</p>\n<ul>\n<li>I have my high-powered tactics list - <code>norm_num</code>, <code>linarith</code>, <code>simp</code>, <code>ring</code>, <code>field_simp</code> etc.</li>\n<li>I get to some statement that has no meaningful mathematical content left (vague statement I know, just based on what one would write on paper)</li>\n<li>the high-powered tactics surprisingly fail to close the statement. Note there are only ~10 of them, so I can basically brute-force try them all.</li>\n<li>if nothing works, I have to start thinking, roughly what is the shape of the statement, which tactic I expect to solve it, how does it work, why doesn't it work here, and how can I find the appropriate small <code>rw</code> to get it going.</li>\n</ul>\n<p>The last part is by far the hardest, because one has to understand much more precisely how these tactics works (I am thinking about reading the source code of linarith which has been the workhorse of chapter 5).</p>\n<p>So far, I have been able to unblock myself on most of chapter 4 and 5 this way, but also wondering if I should be treating incorporating the small pre-step of <code>rw</code> as \"bugs / feature requests\" for incorporating in the tactic and filling them as issues somewhere, or reporting on zulip. What makes this tricky is everyone has slightly different expectation of how \"high-powered\" these tactics should be, so a bunch of these cases will be closed as \"won't do\" (which is fine by me, but don't want to create junk for the maintainers).</p>",
        "id": 538898122,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757606802
    },
    {
        "content": "<p>There's an intermediate option as well, in between bashing through everything repeatedly and writing new tactics: every time you encounter a problem that or <code>simp</code> or <code>norm_cast</code> should solve, but doesn't, make sure to add any missing attributes (PRs to Mathlib adding a single <code>norm_cast</code> attribute are very welcome!).</p>\n<p>Polishing the annotations in existing libraries is extremely helpful.</p>",
        "id": 538986874,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757656270
    },
    {
        "content": "<p>That's a great point! Some tactics are externally extensible through annotations and sometimes the difference is just adding an annotation (much easier than extending the internals of the tactic). I still need to learn more about what makes a theorem good or bad candidate for the annotation, but that's easier than understanding internals. </p>\n<p>Other than <code>simp</code> and <code>norm_cast</code> what are the other major tactics that work with annotations?</p>",
        "id": 538988199,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757657092
    },
    {
        "content": "<p>OOC, is there ever a downside to adding the annotation, if I can produce a reasonable example of a proof that gets shorter?</p>",
        "id": 538988312,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757657140
    },
    {
        "content": "<p><code>aesop</code> and <code>grind</code> are also annotation driven.</p>\n<p>Unfortunately, yes, for all of these there are downsides to bad annotations. For <code>simp</code> we have some reasonably well developed linters that warn about some bad classes. For <code>grind</code> we are still working on this.</p>\n<p>Sometimes you just have to try. I'm generally supportive of \"try adding the annotation and remove it again if something goes wrong\".</p>",
        "id": 538992044,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757659209
    }
]