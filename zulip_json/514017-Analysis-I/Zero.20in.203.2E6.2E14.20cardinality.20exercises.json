[
    {
        "content": "<p>I'm finding cardinality exercises (3.6.14) fun to work out except for one detail — how empty sets are represented.</p>\n<p>Concretely, I often end up having  <code>.card = 0</code> because it's actually empty (like when I'm inducting). But since <code>.card = 0</code> is also used for encoding infinite cardinality, I can't just turn it into <code>.has_card 0</code> (and thus into a statement that it's an empty set) and have to mess around with some other <code>.finite</code> hypothesis to actually get <code>.has_card 0</code>.</p>\n<p>It's definitely doable but it's confused me a bunch of times so I wanted to raise it. I'm not sure what a better option could be though. I understand that I actually <em>need</em> to deal with infinite cases in a bunch of these proofs anyway but maybe it would be less confusing if zero and infinite cardinalities were distinct in the <code>.card</code> value itself. Like a sum type or something.</p>",
        "id": 536675910,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1756411421
    },
    {
        "content": "<p>I guess maybe part of the confusion is that I can usually do <code>card_to_has_card</code> but it doesn't work for <code>0</code> (even if it's finite). However, <code>has_card_card</code> + <code>rw</code> can actually do the job in this case.</p>",
        "id": 536676982,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1756411952
    },
    {
        "content": "<p>In Mathlib there are two different notions of cardinality for precisely this reason: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.ncard#doc\">docs#Set.ncard</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.encard#doc\">docs#Set.encard</a>, with the latter taking values in an extension <code>ENat</code> of the natural numbers <code>Nat</code> that also contains an \"infinite\" element.  (Actually, there are bunch of other closely related cardinality notions such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.card#doc\">docs#Nat.card</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENat.card#doc\">docs#ENat.card</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.card#doc\">docs#Finset.card</a>, and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.card#doc\">docs#Fintype.card</a>, but to reduce confusion it's best not to talk about them for now.)  I think the choice of which one to use is somewhat application-dependent; but there is so much more API for the natural numbers than the extended natural numbers that it is often more convenient to use a <code>Nat</code>-based cardinality notion even if an <code>ENat</code> version would be conceptually better.</p>\n<p>EDIT: in any event, any tips you might have for future students working through Section 3.6 can be added as a PR to the new \"tips\" section near the start of the Lean file.</p>",
        "id": 536681769,
        "sender_full_name": "Terence Tao",
        "timestamp": 1756414295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/channel/514017-Analysis-I/topic/Zero.20in.203.2E6.2E14.20cardinality.20exercises/near/536681769\">said</a>:</p>\n<blockquote>\n<p>but there is so much more API for the natural numbers than the extended natural numbers that it is often more convenient to use a <code>Nat</code>-based cardinality notion even if an <code>ENat</code> version would be conceptually better</p>\n</blockquote>\n<p>I think this is only half the reason the <code>Nat</code> version is more convenient. The other half being that, when everything is finite, you <em>really</em> want to ignore the possibility of anything having infinite cardinality, and so <code>ℕ</code> is honestly conceptually better. This is partly why <code>Finset.card</code> and <code>Fintype.card</code> exist, but those don't work with <code>Finite α</code> assumptions.</p>",
        "id": 536683071,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1756415002
    },
    {
        "content": "<blockquote>\n<p>I guess maybe part of the confusion is that I can usually do <code>card_to_has_card</code> but it doesn't work for <code>0</code> (even if it's finite). However, <code>has_card_card</code> + <code>rw</code> can actually do the job in this case.</p>\n</blockquote>\n<p>I think I added that theorem, but I can see this variant being more useful</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">card_to_has_card_fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hfin</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">has_card</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">has_card_card</span><span class=\"w\"> </span><span class=\"n\">hfin</span>\n</code></pre></div>\n<p>Can send a PR for it too.</p>",
        "id": 536691721,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1756420314
    },
    {
        "content": "<p>I sent a PR in <a href=\"https://github.com/teorth/analysis/pull/331\">https://github.com/teorth/analysis/pull/331</a> with what I personally found helpful.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"488971\">Rado Kirov</span> <a href=\"#narrow/channel/514017-Analysis-I/topic/Zero.20in.203.2E6.2E14.20cardinality.20exercises/near/536691721\">said</a>:</p>\n<blockquote>\n<p>I think I added that theorem, but I can see this variant being more useful</p>\n</blockquote>\n<p>Interestingly I had that too but ended up not having use for it thanks to lemmas directly dealing with the empty set.</p>",
        "id": 536709185,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1756435317
    },
    {
        "content": "<p>Just for future reference, here is a table that organizes six different ways one can formalize the assertion \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> is the cardinality of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>\" in Mathilb, depending on the type and finite nature of <code>X</code>, and whether we want <code>n</code> to be a natural number or permit it to be infinite.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th><code>[Finite X] (n: Nat)</code></th>\n<th><code>(n: Nat)</code></th>\n<th><code>(n: ENat)</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>X</code> is a set</td>\n<td><code>n = Finset.card X</code></td>\n<td><code>n = Set.ncard X</code></td>\n<td><code>n = Set.encard X</code></td>\n</tr>\n<tr>\n<td><code>X</code> is a type</td>\n<td><code>n = Fintype.card X</code></td>\n<td><code>n = Nat.card X</code></td>\n<td><code>n = ENat.card X</code></td>\n</tr>\n</tbody>\n</table>\n<p>There is one small lie in this table, which is that to use <code>Finset.card X</code> or <code>Fintype.card X</code> it is not enough for the set or type <code>X</code> to have a <code>Finite</code> instance; it must be a <code>Finset</code> or a <code>Fintype</code> instead, for technical reasons having to do with things like decidable equality and computability that are not particularly important for most mathematical applications.  There are a ton of helper lemmas relating these six notions to each other but none of them are particularly interesting.  I don't think there is consensus on which cardinality notion is the \"best\" to use; it depends on the specific application.  (For Analysis I, I didn't want to introduce the extended natural numbers at this stage of the text, nor did I want to introduce a set notion with a bundled notion of finiteness, nor did I want to introduce any type theory; so by the process of elimination, this left me with working with a cardinality notion similar to <code>Set.ncard</code>.)</p>",
        "id": 537167735,
        "sender_full_name": "Terence Tao",
        "timestamp": 1756758032
    },
    {
        "content": "<p>For completeness: worth mentioning that all three in the bottom row also function for the top row (by coercing Set to Type); and that there's also <code>n = Cardinal.mk X</code>.</p>",
        "id": 537328295,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756831992
    }
]