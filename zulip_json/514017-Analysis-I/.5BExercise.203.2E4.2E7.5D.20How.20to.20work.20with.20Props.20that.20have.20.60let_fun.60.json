[
    {
        "content": "<p>This is a bit messy and need context form the book, so bear with me.</p>\n<p>The exercises asks to build the set of partial functions X -&gt; Y using - powerset, exp, union and replacement axioms. Intuitively, the solution is simple - something like <code>union (powerset X).map(X' =&gt; powerset(Y).map(Y' =&gt; Y' ^ X'))</code></p>\n<p>However, the axioms we are working with don't have <code>map</code>, we have <code>replace</code> where we need to pass both a property and a proof that it behaves like a function (i.e. single output for a fixed input).</p>\n<p>So I have so far</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Exercise 3.4.7 -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">partial_functions</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"n\">Object</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">object_of</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">powerset</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hX'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_powerset</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">powerset</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hY'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_powerset</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n<span class=\"w\">      </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">hY'</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">hX'</span>\n<span class=\"w\">    </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">y'</span><span class=\"w\"> </span><span class=\"n\">hy</span>\n<span class=\"w\">        </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hy'</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hy</span>\n<span class=\"w\">        </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">y'</span><span class=\"w\"> </span><span class=\"n\">hy</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hy'</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hy</span>\n<span class=\"w\">    </span><span class=\"c1\">-- doesn't work</span>\n<span class=\"w\">    </span><span class=\"c1\">-- rw [replacement_axiom] at hy</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"c1\">-- actual proof below</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The problem is I don't know how to finish the proofs that the property I am passing is function-like, because the proof state now has <code>let_fun</code> in the <code>Prop</code>, which doesn't let me apply <code>rw [replacement_axiom]</code> which I usually use when dealing with <code>.replace</code></p>\n<p><a href=\"/user_uploads/3121/Uy2GQUEVj9MJdV4jzW8B34DQ/Screenshot-2025-07-10-at-9.39.53AM.png\">Screenshot 2025-07-10 at 9.39.53 AM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Uy2GQUEVj9MJdV4jzW8B34DQ/Screenshot-2025-07-10-at-9.39.53AM.png\" title=\"Screenshot 2025-07-10 at 9.39.53 AM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"418x210\" src=\"/user_uploads/thumbnail/3121/Uy2GQUEVj9MJdV4jzW8B34DQ/Screenshot-2025-07-10-at-9.39.53AM.png/840x560.webp\"></a></div><p>P.S. If you are wondering why I need <code>hX'</code> and <code>hY'</code> the first place, it is because simply trying <code>Y'.val ^ X'.val</code> doesn't work as Lean forgets that those came from a powerset and thus are Sets, not just Objects.</p>\n<p>Happy to pull relevant definitions into a playground link (shouldn't be too bad, just don't want to do it unless someone will end up actually looking).</p>",
        "id": 528122814,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1752165767
    },
    {
        "content": "<p>Does the <code>extract_lets</code> tactic do anything?</p>",
        "id": 528124290,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752166355
    },
    {
        "content": "<p>Didn’t even know about it, will try it later today after work.</p>",
        "id": 528125242,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1752166666
    },
    {
        "content": "<p>Yep, that got me further. Learned a new tactic, thanks!</p>\n<p>Also realized by initial solution was wrong - it should have been <code>union (powerset X).map(X' =&gt; union (powerset Y).map(Y' =&gt; Y' ^ X'))</code> and in Lean</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">partial_functions</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"n\">Object</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">object_of</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">powerset</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">Xout</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hX'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_powerset</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n<span class=\"w\">    </span><span class=\"n\">Xout</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">powerset</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"n\">Yout</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hY'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_powerset</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n<span class=\"w\">      </span><span class=\"n\">Yout</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">set_to_object</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">hY'</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">hX'</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">y'</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">y'</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>as it turns out the relationships-are-function-like proofs turn out to be trivial once I had the right definition.</p>\n<p>But now I still struggle to complete the proof. As you see I have to use <code>Classical.choose</code> to go from the prop that there is a subset member in the powerset, to the value to use with ^. In flashbacks to chapter 3.3 I am really struggling in working with Classical.choose again.</p>\n<p>I feel I should be allowed to turn <code>choose (Exists x _)</code> to <code>x</code> but Lean doesn't let me do the rewriting.</p>\n<p><a href=\"/user_uploads/3121/jknMgc7id1wFu20xh6gHYtK6/Screenshot-2025-07-10-at-10.40.30PM.png\">Screenshot 2025-07-10 at 10.40.30 PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/jknMgc7id1wFu20xh6gHYtK6/Screenshot-2025-07-10-at-10.40.30PM.png\" title=\"Screenshot 2025-07-10 at 10.40.30 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"2186x580\" src=\"/user_uploads/thumbnail/3121/jknMgc7id1wFu20xh6gHYtK6/Screenshot-2025-07-10-at-10.40.30PM.png/840x560.webp\"></a></div><p><a href=\"https://github.com/rkirov/analysis/blob/main/analysis/Analysis/Section_3_4.lean#L1218-L1275\">github link</a></p>",
        "id": 528200423,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1752212609
    },
    {
        "content": "<p>No, that's not true!</p>",
        "id": 528214233,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1752216908
    },
    {
        "content": "<p>&lt;2, ...&gt; and &lt;4, ...&gt; are equal terms of type Exists x, Even x, but if you were allowed to pull out the witness, that would imply that 2=4</p>",
        "id": 528217088,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1752217033
    },
    {
        "content": "<p>To work with a <code>choose</code> term, there should be a matching <code>choose_spec</code> theorem that tells you everything you can know about it</p>",
        "id": 528218447,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1752217091
    },
    {
        "content": "<p>hmm, that a good point, not sure how to read <code>Classical.choose_eq</code> then, which almost feels like it is allowing that.</p>\n<blockquote>\n<p>To work with a <code>choose</code> term, there should be a matching <code>choose_spec</code> theorem that tells you everything you can know about it.</p>\n</blockquote>\n<p>Can you show me a small example of how to do that? I am forced to use <code>choose</code> because of theorems like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_powerset</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">powerset</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>that have existential instead of the more direct  <code>x ∈ powerset X ↔  x ⊆ X</code> which doesn't work because of Set and Object are different types.</p>",
        "id": 528349976,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1752243569
    },
    {
        "content": "<p>If <code>h : ∃ x : X, P x</code> then <code>Classical.choose h : X</code> and <code>Classical.choose_spec h : P (Classical.choose h)</code></p>",
        "id": 528350356,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752243694
    },
    {
        "content": "<p>This (and all its consequences) is basically everything you can ever know about the term <code>Classical.choose h</code></p>",
        "id": 528350522,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752243741
    },
    {
        "content": "<p>There's also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.choose#doc\">docs#Exists.choose</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.choose_spec#doc\">docs#Exists.choose_spec</a> that do the same thing but let you use dot notation</p>",
        "id": 528350630,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752243769
    },
    {
        "content": "<p>so if <code>h : ∃ x : X, P x</code> then <code>h.choose : X</code> and <code>h.choose_spec : P h.choose</code></p>",
        "id": 528350704,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752243793
    },
    {
        "content": "<p>So if I have a <code>choose h</code> in my goal somewhere, do I have to add <code>have hspec  := choose_spec h</code> to my list of known things, and work from there.</p>",
        "id": 528351017,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1752243894
    },
    {
        "content": "<p>Mechanically, how can I do that without spelling out all of <code>h</code> (which is long term)</p>",
        "id": 528351145,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1752243934
    },
    {
        "content": "<p>The <code>generalize_proofs</code> tactic from mathlib is pretty handy</p>",
        "id": 528351196,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752243950
    },
    {
        "content": "<p>it lets you not have to write out all of the long proof term by giving a name to it</p>",
        "id": 528351267,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752243970
    },
    {
        "content": "<p>Ok, I got one direction of the proof working. The key observation was that instead of trying to do <code>obtain</code> to pull a witness and then show it equals to the one pulled from <code>choose</code>, I can simply use <code>use choose a</code> (where <code>generalize_proofs</code> can pull <code>a</code> into its own var).</p>\n<p>On some level <code>obtain</code> also pulls a witness from an existential like <code>choose</code> but not sure how to describe the difference precisely.</p>\n<p>I am stuck even worse on the inverse direction, but will keep staring at it.</p>",
        "id": 528358510,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1752246303
    },
    {
        "content": "<p>For the inverse direction, I am down to one final issue with <code>choose</code> and <code>choose_spec</code> that baffles me.</p>\n<p>We have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_powerset</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">powerset</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">X</span>\n</code></pre></div>\n<p>I also have proven already for a specific instance of <code>X': Set</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">hxpow</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">set_to_object</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">powerset</span>\n</code></pre></div>\n<p>not I just need to prove this lemma to complete the exercise</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hxchoose</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">mem_powerset</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hxpow</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>Basically, once we know the actual instance X', there isn't really any choice for the existential, has to be <code>X'</code>. I tried to complete the proof with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hxchoose</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">mem_powerset</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hxpow</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">choose_spec</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">mem_powerset</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hxpow</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n<span class=\"w\">      </span><span class=\"c1\">-- this should do it, but it does not :(</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>\n<p>The error at the last line is a bit inscrutable, using symbols way beyond what I have writen like <code>_proof_1✝</code>, <code>funext</code> and <code>congrArg</code>.<br>\n<a href=\"/user_uploads/3121/A3FwOTJa2j9RqqckqGWhq_KO/Screenshot-2025-07-11-at-11.03.43PM.png\">Screenshot 2025-07-11 at 11.03.43 PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/A3FwOTJa2j9RqqckqGWhq_KO/Screenshot-2025-07-11-at-11.03.43PM.png\" title=\"Screenshot 2025-07-11 at 11.03.43 PM.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1268x588\" src=\"/user_uploads/thumbnail/3121/A3FwOTJa2j9RqqckqGWhq_KO/Screenshot-2025-07-11-at-11.03.43PM.png/840x560.webp\"></a></div>",
        "id": 528435850,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1752300366
    },
    {
        "content": "<p><a href=\"https://live.lean-lang.org/#codez=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\">Playground link</a></p>",
        "id": 528436228,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1752300912
    },
    {
        "content": "<p>Claude figured it out, apparently the issue was that writing <code>(mem_powerset X).mp h</code> in the goal and in the argument to <code>choose_spec</code> results in slightly different underlying expressions (I have no idea why?). The fix was simply doing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_powerset</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">choose_spec</span><span class=\"w\"> </span><span class=\"n\">h'</span>\n</code></pre></div>\n<p>so that now both goal and local proof share the same expansion of  <code>(mem_powerset X).mp h</code>. Quite a tricky situation, not sure how would I have figure out that <code>(mem_powerset X).mp h</code> has different meaning in different contexts.</p>",
        "id": 528436927,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1752301825
    },
    {
        "content": "<p>I find that using <code>convert</code> instead of <code>exact</code> (or <code>apply</code>, or <code>refine</code>) can zero in on precisely what the discrepancy is.</p>",
        "id": 528472229,
        "sender_full_name": "Terence Tao",
        "timestamp": 1752340425
    },
    {
        "content": "<p>this feels like some weird casting issue though, having to do with the fact that types that are propositionally equal are not actually the same type (cf. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=cast#doc\">docs#cast</a>).</p>",
        "id": 528472377,
        "sender_full_name": "Terence Tao",
        "timestamp": 1752340611
    },
    {
        "content": "<p>Here’s what I ended up doing if you’re curious (after a lot of back and forth with Claude)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Helper lemma for Exercise 3.4.7. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_powerset'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">S'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">S'</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_powerset</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">partial_functions</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"n\">Object</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"bp\">.</span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">oY'</span><span class=\"w\"> </span><span class=\"n\">outer</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">    </span><span class=\"n\">outer</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"bp\">.</span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">oX'</span><span class=\"w\"> </span><span class=\"n\">inner</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">      </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">oX'</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">oY'</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">inner</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"o\">))</span>\n\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">F</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">hF</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">union_axiom</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hF</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hFS</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hS</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hF</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">replacement_axiom</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hS</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">oY'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hoY'</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hS</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hS</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EmbeddingLike</span><span class=\"bp\">.</span><span class=\"n\">apply_eq_iff_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hS</span>\n<span class=\"w\">    </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hS</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">union_axiom</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hFS</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hFS</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hS</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hFS</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">replacement_axiom</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hS</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">oX'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hoX'</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hS</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hS</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EmbeddingLike</span><span class=\"bp\">.</span><span class=\"n\">apply_eq_iff_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hS</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hS</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">powerset_axiom</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hFS</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hFS</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y'</span>\n<span class=\"w\">    </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_powerset'</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">tauto</span>\n\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">X'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hX'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hY'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_iUnion</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Y'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">union_axiom</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">constructor</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">powerset_axiom</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">replacement_axiom</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">X'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"bp\">⟩</span>\n<span class=\"w\">      </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y'</span>\n</code></pre></div>\n<p>Keeping an actual existential inside the union defintion (instead of collapsing it early with choice) makes it easier to pull it out later.</p>\n<p>Sent the lemma in a PR <a href=\"https://github.com/teorth/analysis/pull/242\">https://github.com/teorth/analysis/pull/242</a></p>",
        "id": 531466204,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753738378
    },
    {
        "content": "<p>To me, the mind bending part of this exercise is to realize that you need an existential inside the specification predicate P. I think (haven’t checked) most examples of P so far were just using equality like <code>out = …</code>. So it’s a leap to figure out that you can put an existential first and thus “spawn” some object you don’t already have.</p>",
        "id": 531467858,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753739046
    },
    {
        "content": "<p>I guess another mystery is how to get rid of <code>rw [mem_iUnion]</code> in my proof (since I'm not actually using indexed unions). Its shape just happens to coincide with union over replacements. But I'm having no luck applying <code>union_axiom</code> and <code>replacement_axiom</code> individually without <code>mem_iUnion</code>.</p>",
        "id": 531484174,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753747670
    },
    {
        "content": "<p>OK this should remove the need for <code>mem_iUnion</code> and simplify the flow of the proof: <a href=\"https://github.com/teorth/analysis/pull/243\">https://github.com/teorth/analysis/pull/243</a></p>",
        "id": 531491368,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753752144
    },
    {
        "content": "<blockquote>\n<p>To me, the mind bending part of this exercise is to realize that you need an existential inside the specification predicate.</p>\n</blockquote>\n<p>That is clever! My solution used <code>choose</code> in the predicate, which made it much harder to work with and as you have shown not really necessary. I think I understand how to work with <code>choose</code> better now (after much more wrestling with it in 3.5 and 3.6) and AFAIKT it is required when we are working with values (i.e. terms of type with type Type 0 :)), but here we are constructing a <code>Prop</code>.</p>",
        "id": 531509310,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1753763390
    }
]