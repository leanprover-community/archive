[
    {
        "content": "<p>We've discussed it briefly in other threads but I'm still running into difficulties with coercions between <code>Object</code>, <code>ℕ</code>, custom <code>Nat</code>, and the <code>Subtype</code> machinery.</p>\n<p>To give you a few examples, in <code>image_f_3_4_2</code>, after <code>simp</code> my goal becomes</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">toSubtype</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nat_equiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">toSubtype</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span>\n</code></pre></div>\n<p>So we have a statement that <code>((x: nat): Object) = (ofNat(2): Object)</code> and we want to show that <code>2 * ((x: Nat): ℕ) = (4: ℕ)</code>. That's pretty hard to think about when you don't <em>quite</em> have the right lemmas.</p>\n<p>Then further on in <code>preimage_f_3_4_2</code>, after <code>simp</code>s we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">toSubtype</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">nat_equiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>So we need to turn <code>(2:ℕ) * ((x: Nat): ℕ) = (4:ℕ)</code> into <code>((x: Nat): Object) = (ofNat(2): Object)</code>.</p>\n<p>And then we have a bunch of lemmas in 3.1 that try to do some of these conversions, but whenever a particular exercise (or a particular \"path\" through an exercise) doesn't hit the happy path, it really sucks the joy out of doing the exercises — and I'm not sure how much it is actually teaching.</p>\n<p>I'm wondering if there is a more systematic way to approach this problem. I would take as a given that we <em>want</em> to preserve the current hierarchy (and all the types). It's casts themselves that feel dubious to me.</p>\n<p><strong>I'd like to know, in particular, if there is a way to:</strong></p>\n<ul>\n<li>\n<p>(a) Either leverage more Lean/Mathlib machinery (like <code>norm_cast</code>?) to take care of these more automatically</p>\n</li>\n<li>\n<p>(b) Or to be more strategic about the choice of <code>simp</code> lemmas so that they reliably eliminate the patterns the reader is likely to encounter</p>\n</li>\n</ul>\n<p>Re (a), I just don't have enough Lean background to know whether this would significantly improve on the problem or not.</p>\n<p>Re (b), I'm wondering if there's some systematic way to deal with \"three types\" (e.g. to enumerate each permutation of nesting, or to only write lemmas of certain signatures — like \"double elimination\"). Intuitively it feels like there must be some way to \"work how Lean wants us to\" rather than fight against it, and that maybe we're missing some discipline in how the simp lemmas are chosen.</p>\n<p>If someone has ideas, the relevant definitions are mostly here: <a href=\"https://github.com/teorth/analysis/blob/5cacd4af98b4c3b02e75df1f4c0961c80b7e6569/analysis/Analysis/Section_3_1.lean#L621-L674\">https://github.com/teorth/analysis/blob/5cacd4af98b4c3b02e75df1f4c0961c80b7e6569/analysis/Analysis/Section_3_1.lean#L621-L674</a></p>\n<p>If you want to playtest a change to how they work, you can use <a href=\"https://github.com/rkirov/analysis\">https://github.com/rkirov/analysis</a> or <a href=\"https://github.com/gaearon/analysis-solutions\">https://github.com/gaearon/analysis-solutions</a> (and other forks). I'm also happy to playtest ideas myself if someone can suggest what concrete things to try.</p>\n<p>Thank you!</p>",
        "id": 528900095,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1752597194
    },
    {
        "content": "<p>It's also possible that this is just \"how it is\" and I need to bite the bullet and embrace individual tedious one-off conversions.</p>",
        "id": 528900479,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1752597329
    },
    {
        "content": "<p>It seems to me that if users are getting into this kind of mess because of <code>Object</code> and <code>nat.toSubtype</code> then a (bespoke?) tactic is needed which just does \"get me out of this mess please\".</p>",
        "id": 528908232,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1752600013
    },
    {
        "content": "<p>In this particular case, a new <code>@[simp]</code> lemma that <code>((x:nat):Object) = (ofNat(n):Object)</code> is equivalent to <code>x = ofNat(n)</code> may resolve the problem (this is a slight variant of the existing <code>@[simp]</code> lemma <code>SetTheory.Set.nat_coe_eq_iff</code>, which unfortunately doesn't quite apply in this context).  I'm not 100% sure how <code>norm_cast</code> actually works but perhaps such lemmas could also be tagged <code>@[norm_cast]</code>?</p>",
        "id": 528911199,
        "sender_full_name": "Terence Tao",
        "timestamp": 1752601139
    },
    {
        "content": "<p>Okay, I couldn't get this lemma to work but I figured a slightly different one that does. Folded that into <a href=\"https://github.com/teorth/analysis/pull/191\">https://github.com/teorth/analysis/pull/191</a>. Maybe that's enough but I'll keep poking later to see if something can be simplified.</p>",
        "id": 528923729,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1752605894
    }
]