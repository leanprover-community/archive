[
    {
        "content": "<p>I was doing exercise <code>3.6.6</code> which asks to prove <code>(a^b) * a^c = a^(b+c) </code> using cardinality theorems, and for <code>b + c</code> I can't just use <code>Fin b</code> and <code>Fin c</code> since they are not disjoint. So I figured to use the cartesian product <code>Fin c \\cross Fin 1</code> which I know has the same cardinality and surely it is disjoint from <code>Fin b</code>.</p>\n<p>But I seem to be blanking on how to prove that the object that <code>OrderedPair.toObject</code> produces is different from the one that the <code>Nat_equiv</code> injection from <code>N</code> for Fins produces. I am not even sure if that is provable in the current axiomatization or needs new axioms?</p>",
        "id": 531756424,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1753855648
    },
    {
        "content": "<p>I would instead split <code>Fin (b+c)</code> into a set in bijection with <code>Fin b</code> and a set in bijection with <code>Fin c</code>, using the identifications with <code>Nat</code>.</p>",
        "id": 531766569,
        "sender_full_name": "Terence Tao",
        "timestamp": 1753859894
    },
    {
        "content": "<p>This is exactly the kind of nonsense that type theory spares you from. You can try defining a \"disjoint union\" of sets.</p>",
        "id": 531818205,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753875163
    },
    {
        "content": "<p>In this custom set theory, perhaps the most natural disjoint union of <code>A:Set</code> and <code>B:Set</code> would be the slices of <code>(A ∪ B) ×ˢ (Fin 2)</code> coming from what is morally <code>A ×ˢ {0}</code> and <code>B ×ˢ {1}</code>.  Because no information is provided about how <code>ℕ</code> is actually encoded in the set theory other than that it is an embedding, I don't think one can actually guarantee that <code>Fin b</code> is disjoint from <code>Fin c ×ˢ Fin 1</code> (cf. the discussion on \"junk theorems\" in set theory in <a href=\"https://mathoverflow.net/questions/90820/set-theories-without-junk-theorems\">https://mathoverflow.net/questions/90820/set-theories-without-junk-theorems</a> .  Lean also has junk theorems, but they come from a different source, namely defining an operation to be total by assigning junk values to cases where mathematicians would ordinarily leave the operation undefined (e.g., division by zero).)</p>",
        "id": 531881273,
        "sender_full_name": "Terence Tao",
        "timestamp": 1753892210
    },
    {
        "content": "<blockquote>\n<p>I would instead split <code>Fin (b+c)</code> into a set in bijection with <code>Fin b</code> and a set in bijection with <code>Fin c</code>, using the identifications with <code>Nat</code>.</p>\n</blockquote>\n<p>That worked - <a href=\"https://github.com/rkirov/analysis/blob/main/analysis/Analysis/Section_3_6.lean#L2018-L2020\">https://github.com/rkirov/analysis/blob/main/analysis/Analysis/Section_3_6.lean#L2018-L2020</a>, thanks!</p>",
        "id": 531892683,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1753895991
    },
    {
        "content": "<blockquote>\n<p>This is exactly the kind of nonsense that type theory spares you from.</p>\n</blockquote>\n<p>Agree, it's nice, but I am also paying for it by having to explicitly work with <code>Subtype</code> theorems. I assume if working in set theory based proof assistants (I haven't ever done that, just thinking by analogy with programming with type systems that have subtyping ) some of that will be more implicit and handled internally. One of my learnings on Lean so far from these exercises is that <code>↑</code> is just a visual shortcut, but it is really up to me to always hover over those and know and use the appropriate theorems to manupulate them. A lot of my original confusion was from the fact that <code>↑</code> can mean 4 different things in Chapter 3 - subtype.val, nat_equiv, function_to_object, etc. So kinda of 'no free lunch'.</p>",
        "id": 531893870,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1753896404
    },
    {
        "content": "<p>You can always <code>set_option pp.coercions false</code> and not look at the <code>↑</code> at all</p>",
        "id": 531894159,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753896506
    },
    {
        "content": "<p>Yeah I was hoping the short syntax means “don’t worry about those”, but I leaned I need to very much understand and think about what’s behind the little arrows :)</p>",
        "id": 531898059,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1753897976
    },
    {
        "content": "<p>For me I just don't worry about them and it's usually fine</p>",
        "id": 531898982,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753898324
    },
    {
        "content": "<p>since I've understood them already I know if it becomes a problem the fix is usually not too hard</p>",
        "id": 531899056,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753898347
    },
    {
        "content": "<p>Yeah, I am getting to the point where I have enough tricks in my bag to not be stuck moving around the various casts. What I find dissatisfying is that at the end more than half of the lines of my proofs is messing with the casts and injections, to the point one can hardly see the usually single mathematical idea behind the proof. Once done with the exercises I plan to go back and see whether we are missing some simp lemmas to hide that noise from the proofs (<span class=\"user-mention\" data-user-id=\"418569\">@Dan Abramov</span> has been doing a much better job than me at that), but for now I like to just forge ahead - a proof is a proof.</p>",
        "id": 531972652,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1753932882
    }
]