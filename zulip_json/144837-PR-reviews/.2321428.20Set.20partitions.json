[
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/21428\">#21428</a> gives a version of <code>Finpartition</code> where there can be infinitely many parts. </p>\n<p>I've just included the definition and very basic API, but the use case I have in mind is the set partition associated with a symmetric, transitive binary relation that  isn't necessarily reflexive, and also the various lemmas relating <code>tsum</code> and <code>iUnion</code> with types like <code>ENat</code> and <code>Cardinal</code> for arbitrary collections of disjoint elements.</p>",
        "id": 497698688,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738684127
    },
    {
        "content": "<p>This seems quite similar to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Setoid.IsPartition#doc\">docs#Setoid.IsPartition</a> or the indexed version <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IndexedPartition#doc\">docs#IndexedPartition</a>; do one of those do what you wanted instead?</p>",
        "id": 497784585,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1738715952
    },
    {
        "content": "<p>No. The former is closer, but both are for partitions of all the elements of a type, and neither work when abstracted to lattices. </p>\n<p>Note that the design of <code>Finpartition</code> isn't just about there being finitely many cells - it is also that a <code>Finpartition</code> can be of something that's not the entire type. I want that for sets. </p>\n<p>(The specific use case is for the partition of the nonloop elements of a matroid into its 'parallel classes' - two nonloop elements are parallel iff they are in the same class, and the loop elements aren't parallel to anything, even eachother. The cells aren't naturally indexed by anything, and we are still interested in the parallel classes and the set of loops as sets, so using either <code>IndexedPartition</code> or <code>Setoid</code> would destroy relevant information. With this definition, <code>Partition {x | M.Nonloop x}</code> provides exactly the right structure. )</p>",
        "id": 497802107,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738726676
    },
    {
        "content": "<p>So to be clear, you don't need the lattice abstraction for your use case, only for consistency with FinPartition?</p>",
        "id": 497809489,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738731654
    },
    {
        "content": "<p>Currently, thatâ€™s right - the API I mostly have is for sets, though I think there will be nice applications in subspace lattices.</p>",
        "id": 497868167,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738754270
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2321428.20Set.20partitions/near/497802107\">said</a>:</p>\n<blockquote>\n<p>it is also that a <code>Finpartition</code> can be of something that's not the entire type. I want that for sets.</p>\n</blockquote>\n<p>Ah! That was the key distinction I'd missed.</p>",
        "id": 497985034,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1738790524
    }
]