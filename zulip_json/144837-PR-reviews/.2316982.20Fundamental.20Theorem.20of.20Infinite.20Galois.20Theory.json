[
    {
        "content": "<p>In this PR, I proved the Fundamental Theorem of Infinite Galois Theory<br>\n<a href=\"/user_uploads/3121/vO3sGNoi47lXtLI4bbY04F_W/1fb303d16958f9f032af47583b782d6.jpg\">1fb303d16958f9f032af47583b782d6.jpg</a><br>\nThe dependency grapgh is above. 4 PRs related to this one in total.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/vO3sGNoi47lXtLI4bbY04F_W/1fb303d16958f9f032af47583b782d6.jpg\" title=\"1fb303d16958f9f032af47583b782d6.jpg\"><img data-original-dimensions=\"1576x1080\" src=\"/user_uploads/thumbnail/3121/vO3sGNoi47lXtLI4bbY04F_W/1fb303d16958f9f032af47583b782d6.jpg/840x560.webp\"></a></div>",
        "id": 471899887,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1726904406
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/34be5bsGhU1XEbM-dMZ-NU_C/60dfa0436d29869bd7cec02af5dac72.jpg\">60dfa0436d29869bd7cec02af5dac72.jpg</a><br>\nDependency grapgh of all the PRs related.<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/16976\">#16976</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/16977\">#16977</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/16978\">#16978</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/16979\">#16979</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/16980\">#16980</a> and # 16991 have no dependency.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/34be5bsGhU1XEbM-dMZ-NU_C/60dfa0436d29869bd7cec02af5dac72.jpg\" title=\"60dfa0436d29869bd7cec02af5dac72.jpg\"><img data-original-dimensions=\"1590x1080\" src=\"/user_uploads/thumbnail/3121/34be5bsGhU1XEbM-dMZ-NU_C/60dfa0436d29869bd7cec02af5dac72.jpg/840x560.webp\"></a></div>",
        "id": 471900465,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1726904783
    },
    {
        "content": "<p>Asking for review of PR:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/16977\">#16977</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/16978\">#16978</a><br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/16979\">#16979</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/16982\">#16982</a><br>\nThank you.</p>",
        "id": 472035512,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1727000356
    },
    {
        "content": "<p>Hello, I got a question here:<br>\n<a href=\"/user_uploads/3121/NSsh2GS7zu_RSpAI41cfOBmE/.png\">图片.png</a><br>\nWhat is the possible reason of causing the reach of maximal heartbeat of synthInstance? It happened after only updating from upsteam.<br>\nSee <code>Mathlib.FieldTheory.Galois.Infinite</code> line 106</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/NSsh2GS7zu_RSpAI41cfOBmE/.png\" title=\"图片.png\"><img data-original-dimensions=\"2153x1279\" src=\"/user_uploads/thumbnail/3121/NSsh2GS7zu_RSpAI41cfOBmE/.png/840x560.webp\"></a></div>",
        "id": 479463361,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1730203540
    },
    {
        "content": "<p>As mathlib gets bigger and more typeclass instances are added, things get slower. Occasionally an addition can push unrelated code \"over the edge\" and this is perhaps what happened here.</p>\n<p>If you add the following debugging options to your code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">synthInstance</span><span class=\"bp\">.</span><span class=\"n\">maxHeartbeats</span><span class=\"w\"> </span><span class=\"mi\">40000</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">profiler</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">fixedField_fixingSubgroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IntermediateField</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsGalois</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>and keep unfolding the trace and \"following the big number\", you get to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">3.010006</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">restrictNormalHom_surjective</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>\n<p>(the line which you already isolated as the problem) and if you continue to unfold you get</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">2.428669</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">FiniteGaloisIntermediateField</span><span class=\"bp\">.</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">toIntermediateField</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n</code></pre></div>\n<p>(so the problem is that Lean is taking a very long time to synthesize that instance). If you continue to unfold you see</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">2.324804</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌️</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">IntermediateField</span><span class=\"bp\">.</span><span class=\"n\">instIsScalarTowerSubtypeMem</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"n\">L</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">FiniteGaloisIntermediateField</span><span class=\"bp\">.</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">toIntermediateField</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n</code></pre></div>\n<p>so now we see the actual problem, which is that Lean takes a wrong turn when attempting to synthesize the instance, and it take a long time to recover from the failure.</p>\n<p>The problem is a common one -- when we have terms coerced to types in typeclass inference, such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span>\n</code></pre></div>\n<p>with <code>X</code> a subtype of <code>X'</code>, then Lean very quickly decides that one way to find this instance is to look for <code>IsScalarTower X' Y Z</code>where <code>X'</code> is too big for this to be true. In particular, the application which is causing you trouble is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">2.324804</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌️</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">IntermediateField</span><span class=\"bp\">.</span><span class=\"n\">instIsScalarTowerSubtypeMem</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"n\">L</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">FiniteGaloisIntermediateField</span><span class=\"bp\">.</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">toIntermediateField</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span>\n</code></pre></div>\n<p>where <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IntermediateField.instIsScalarTowerSubtypeMem#doc\">docs#IntermediateField.instIsScalarTowerSubtypeMem</a> is applied and which leads to what is presumably a false goal (I did not check carefully but this is what usually happens). A while later on in the trace we see this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">synthInstance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">2.312161</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌️</span><span class=\"w\"> </span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">FiniteGaloisIntermediateField</span><span class=\"bp\">.</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">toIntermediateField</span>\n</code></pre></div>\n<p>and presumably this is not mathematically correct because it looks to me like <code>K</code> is the biggest field, so should not be acting on smaller fields I guess. In an attempt to solve this Lean desperately starts looking through the order heirarchy, so you have many intermediate results later on in the trace of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">StrictOrderedSemiring</span><span class=\"bp\">.</span><span class=\"n\">toSemiring</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">LinearOrderedSemiring</span><span class=\"bp\">.</span><span class=\"n\">toStrictOrderedSemiring</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">StrictOrderedSemiring</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">LinearOrderedCommSemiring</span><span class=\"bp\">.</span><span class=\"n\">toLinearOrderedSemiring</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">LinearOrderedSemiring</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">LinearOrderedRing</span><span class=\"bp\">.</span><span class=\"n\">toLinearOrderedSemiring</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">LinearOrderedSemiring</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">LinearOrderedCommRing</span><span class=\"bp\">.</span><span class=\"n\">toLinearOrderedRing</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">LinearOrderedRing</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">StrictOrderedCommSemiring</span><span class=\"bp\">.</span><span class=\"n\">toStrictOrderedSemiring</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">StrictOrderedSemiring</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">StrictOrderedRing</span><span class=\"bp\">.</span><span class=\"n\">toStrictOrderedSemiring</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">StrictOrderedSemiring</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">LinearOrderedRing</span><span class=\"bp\">.</span><span class=\"n\">toStrictOrderedRing</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">StrictOrderedRing</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">StrictOrderedCommRing</span><span class=\"bp\">.</span><span class=\"n\">toStrictOrderedRing</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">StrictOrderedRing</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅️</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">OrderedSemiring</span><span class=\"bp\">.</span><span class=\"n\">toSemiring</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n</code></pre></div>\n<p>which are all true but useless, they say things like \"it would suffice to somehow find an ordering on K with some properties\" but clearly no ordering will exist.</p>\n<p>There are hacks which would fix the problem, for example by lowering the priority of <code>IntermediateField.instIsScalarTowerSubtypeMem</code>.</p>",
        "id": 479571230,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730238741
    },
    {
        "content": "<p>Is it acceptable to leave the 25000 heartbeats in this PR for now or I should fix it imediately in this one? Lowering the priority of the instance you mentioned works, but do it need to be more carefully designed?</p>",
        "id": 479628528,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1730276876
    },
    {
        "content": "<p>Depends on your patience level. Merging the PR with the heartbeats limit raised takes something off your TODO list, but puts it on someone else's. :-)</p>",
        "id": 479649638,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1730284071
    },
    {
        "content": "<p>The way of resolving is simple, just lower the priority of the instance <code>IntermediateField.instIsScalarTowerSubtypeMem</code> to <code>900</code> would work for the whole Mathlib, and lowering it is reasonable because else it would cause trouble when synthize instance <code>IsScalarTower K L E</code> where <code>K &lt; L</code> are <code>IntermediateField F E</code> . My question is do the <code>900</code> need to be set more carfully? And do other lemmas about <code>IsScalarTower</code> and  <code>subtype</code> need to do this shift too?</p>",
        "id": 479656343,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1730286040
    },
    {
        "content": "<p>Clarification: when I claimed that lowering the priority was a \"hack\" I meant that lowering it locally in this file was a hack. Lowering it globally to 900 with a one-line PR, getting mathlib to compile again if necessary and then <code>!bench</code>ing the results on GitHub would be a great way to proceed! This would then give us more data to understand the problem better.</p>",
        "id": 479670431,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730290944
    },
    {
        "content": "<p>One line PR created, <a href=\"https://github.com/leanprover-community/mathlib4/pull/18436\">#18436</a>, the compile succeed. I wonder if the priority of the few instances following it, which are also about the <code>smul</code> of subtype need more careful design too.<br>\nActually, I did this because I doesn't know how to lower it locally</p>",
        "id": 479679746,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1730294041
    },
    {
        "content": "<p>I think you may need to run <code>!bench</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/18436\">#18436</a> to see its impact on the compilation speed of the entire Mathlib.</p>",
        "id": 479683102,
        "sender_full_name": "Yongle Hu",
        "timestamp": 1730295056
    },
    {
        "content": "<p>The result:<br>\n<a href=\"/user_uploads/3121/qzjuqioNL1Jh95VSSViqfDli/.png\">图片.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/qzjuqioNL1Jh95VSSViqfDli/.png\" title=\"图片.png\"><img data-original-dimensions=\"1701x556\" src=\"/user_uploads/thumbnail/3121/qzjuqioNL1Jh95VSSViqfDli/.png/840x560.webp\"></a></div>",
        "id": 479712857,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1730303267
    },
    {
        "content": "<p>Looks great!</p>",
        "id": 479786144,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1730335524
    }
]