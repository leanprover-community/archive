[
    {
        "content": "<p>(This thread was moved from <a href=\"#narrow/stream/144837-PR-reviews/topic/!3.2318230.20Positivity.20of.20linear.20maps\">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/!3.2318230.20Positivity.20of.20linear.20maps</a>, hence the confusing first statement)</p>\n<p>First, note above that I wasn't opposed to the <em>definition</em> of <code>LinearMap.IsPositive</code>, but I was opposed to <em>developing the API based on it</em> (e.g., <code>LinearMap.isPositive_one</code> and the like). Although, as we've discussed elsewhere before, it would be cool but maybe infeasible to unify the <code>IsPositive</code> predicate so that it simultaneously works for <code>LinearMap</code>, <code>ContinuousLinearMap</code> and <code>LinearPMap</code>.</p>\n<p>My plan after <a href=\"https://github.com/leanprover-community/mathlib4/pull/4871\">#4871</a> is essentially that, for a <code>StarOrderedRing R</code>, the canonical spelling for <code>x : R</code> to be positive is <code>x ∈ positive R</code>. However, the partial order on <code>R</code> can be defined to be anything we want because it's a parameter to <code>StarOrderedRing</code>; e.g., for (continuous or not) linear maps, we may choose <code>f₁ ≤ f₂ ↔ ∀ x, ⟪f₁ x, x⟫ ≤ ⟪f₂ x, x⟫</code>, reducing to the <code>LinearMap.IsPositive</code> condition when <code>f₁ = 0</code>. Likewise, for continuous functions <code>C(X, R)</code> we want <code>f₁ ≤ f₂ ↔ ∀ x, f₁ x ≤ f₂ x</code>. For an abstract C⋆-algebra <code>A</code>, you just assume <code>StarOrderedRing A</code> as part of your hypotheses.</p>\n<p>The reason we want <code>x ∈ positive R</code> to be the canonical spelling is that it is the one that works in the most generality, so we can unify the API across all the different domains. (linear maps, continuous functions, unital and non-unital abstract C⋆-algebras, ...)</p>",
        "id": 379258114,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690481190
    },
    {
        "content": "<p>If anyone is not happy with that plan for some reason, please say so.</p>",
        "id": 379258548,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690481279
    },
    {
        "content": "<p>Note: for types <code>A</code> with a continuous functional calculus, we will be able to define a <code>PartialOrder A</code> (not registered as an instance) by <code>x ≤ y ↔ y - x ∈ selfAdjoint A ∧ spectrum ℂ (y - x) ⊆ Set.range (algebraMap ℝ≥0 ℂ)</code> (there could be a separate one which uses <code>ℝ</code> instead of <code>ℂ</code> in certain circumstances) and prove that with this order <code>A</code> becomes a <code>StarOrderedRing</code>. This would give the user the option <em>not</em> to supply their own <code>≤</code>, and then they could prove a lemma which characterizes positivity in a different way.</p>",
        "id": 379260235,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690481611
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/!3.2318230.20Positivity.20of.20linear.20maps/near/379146282\">said</a>:</p>\n<blockquote>\n<p>I don’t know enough about the theory of partial operators, but I’m sure Moritz can tell us if we have a way around that. In particular, does it help if we extend to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearPMap#doc\">docs#LinearPMap</a> ? It is true that symmetric linear maps are exactly those which are equal to their adjoint as <code>LinearPMap</code>s, right?</p>\n</blockquote>\n<p>This is correct assuming that your spaces are all complete. This is already in mathlib as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousLinearMap.toPMap_adjoint_eq_adjoint_toPMap_of_dense#doc\">docs#ContinuousLinearMap.toPMap_adjoint_eq_adjoint_toPMap_of_dense</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.IsSymmetric.toSelfAdjoint#doc\">docs#LinearMap.IsSymmetric.toSelfAdjoint</a></p>",
        "id": 379292246,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1690488918
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/!3.2318230.20Positivity.20of.20linear.20maps/near/379258114\">said</a>:</p>\n<blockquote>\n<p>First, note above that I wasn't opposed to the <em>definition</em> of <code>LinearMap.IsPositive</code>, but I was opposed to <em>developing the API based on it</em> (e.g., <code>LinearMap.isPositive_one</code> and the like). Although, as we've discussed elsewhere before, it would be cool but maybe infeasible to unify the <code>IsPositive</code> predicate so that it simultaneously works for <code>LinearMap</code>, <code>ContinuousLinearMap</code> and <code>LinearPMap</code>.</p>\n</blockquote>\n<p>It should be possible for <code>LinearMap</code> and <code>ContinuousLinearMap</code> if in the former case we assume finite dimensions. For <code>LinearPMap</code> I see very few chances simply because we have almost no properties for <code>star</code> satisfied because of domain issues (scalar multiplication should be fine though).<br>\n(mathematically this is trivial because for finite dimensions we have continuity for free, but people seem to have very strong opinions against using CLM for finite dimensions and dropping LM)</p>",
        "id": 379293594,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1690489288
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span>  in the bit you quoted above, the <code>IsPositive</code> predicate I'm talking about is <code>IsSymmetric f ∧ ∀ x, 0 ≤ ⟪f x, x⟫</code>; there is no <code>star</code> operation necessary.</p>",
        "id": 379294695,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690489638
    },
    {
        "content": "<p>sorry, I thought you meant the star-ordered proposal. I think for the above condition to generalize we would need some <code>LinearMap</code> to <code>LinearPMap</code> coercion and we did an experiment for that and it failed.</p>",
        "id": 379298719,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1690490802
    },
    {
        "content": "<p>btw it might be possible to change typeclasses in a slightly funny way (not assuming <code>star_add</code> holds) so that the abstract definition works, but I don't know whether it is worth it because you probably can't prove much with it.</p>",
        "id": 379301931,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1690491755
    },
    {
        "content": "<p>What is your thought for changing the typeclasses? I don't quite understand.</p>",
        "id": 379303834,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690492457
    },
    {
        "content": "<p>I think our combined <code>LinearMap</code> / <code>LinearPMap</code> positivity definition took place in Lean 3 though. I would be interested to know if it still fails in Lean 4. I suspect we can overcome the previous problem we had (IIRC the issue was two <code>FunLike</code> instances) because we can assign <code>default_instance</code>s now. So it may be worth retrying. I'll see if I can locate that attempt.</p>",
        "id": 379304345,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690492646
    },
    {
        "content": "<p>Oh, here is <a href=\"#narrow/stream/116395-maths/topic/linear_pmap_class\">that thread</a>. It seems you tried it in Lean 4 and it worked?</p>",
        "id": 379305233,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690492955
    },
    {
        "content": "<p>If I remember correctly it was very messy since I could not reproduce how to get the correct instances, I did not know about <code>default_instance</code>s</p>",
        "id": 379306076,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1690493280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/!3.2318230.20Positivity.20of.20linear.20maps/near/379303834\">said</a>:</p>\n<blockquote>\n<p>What is your thought for changing the typeclasses? I don't quite understand.</p>\n</blockquote>\n<p>the problem is that things like<code>star (a + b) = star a + star b</code> are not true, but for the definition of the order this is not needed. If I have time I can try to build a toy class that does everything that is needed and works for <code>LinearPMap</code>.</p>",
        "id": 379307019,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1690493646
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/!3.2318230.20Positivity.20of.20linear.20maps/near/379258114\">said</a>:</p>\n<blockquote>\n<p>My plan after <a href=\"https://github.com/leanprover-community/mathlib4/pull/4871\">#4871</a> is essentially that, for a <code>StarOrderedRing R</code>, the canonical spelling for <code>x : R</code> to be positive is <code>x ∈ positive R</code>. </p>\n<p>The reason we want <code>x ∈ positive R</code> to be the canonical spelling is that it is the one that works in the most generality, [...]</p>\n</blockquote>\n<p>I'm confused, why do we not just want the canonical spelling to be <code>0 ≤ x</code>?</p>",
        "id": 379307493,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690493866
    },
    {
        "content": "<p>Sorry, yes, that spelling should be the canonical one. I guess what I meant is that the API should be developed around <code>StarOrderedRing.positive</code> because that's the thing that works in the most generality (at least until Moritz comes up with something for <code>LinearPMap</code>).</p>",
        "id": 379308115,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690494109
    },
    {
        "content": "<p>Should <code>StarOrderedRing.positive</code> be an abbreviation for <code>{x // 0 ≤ x}</code> instead of for the add_submonoid? That would match how we handle <code>nnreal</code>, <code>nnrat</code>, etc</p>",
        "id": 379308299,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690494177
    },
    {
        "content": "<p>I guess I'm not really sure what the trade-offs are. Although I would be continually worried about instances applying for <code>OrderedStarRing</code> and a different (i.e., non-defeq) one applying for <code>OrderedRing</code>, and then for <code>ℝ</code> we're screwed.</p>",
        "id": 379308907,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690494409
    },
    {
        "content": "<p>But I guess semireducibility instead of an <code>abbrev</code> would fix that.</p>",
        "id": 379309125,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690494492
    },
    {
        "content": "<blockquote>\n<p>Although I would be continually worried about instances applying for OrderedStarRing and a different (i.e., non-defeq) one applying for OrderedRing,</p>\n</blockquote>\n<p>do you have any instances in mind?</p>",
        "id": 379309325,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690494566
    },
    {
        "content": "<p>None of these instances construct any new data, right? If all the instances are just \"do the corresponding operation on <code>Subtype.val</code>\" then there are no diamonds that will appear</p>",
        "id": 379309464,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690494606
    },
    {
        "content": "<p>Maybe <code>AddCommMonoidWithOne</code>? It's the same operation on the full type, but the proof that it is positive will be different depending on <code>OrderedStarRing</code> vs. <code>OrderedRing</code>. I convinced myself at one point this might matter (despite proof irrelevance), but I've been fighting a lot of DTT hell recently, so maybe it was just that.</p>",
        "id": 379309924,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690494792
    },
    {
        "content": "<p>I think proof irrelevance should save you here. It would have a been a problem with your previous <code>natCast</code> definition, but not the one you just pushed.</p>",
        "id": 379309988,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690494822
    },
    {
        "content": "<p>But still, it would be annoying if we had to consider such things.</p>",
        "id": 379310036,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690494842
    },
    {
        "content": "<p>I don't think there's any danger of defeq problems here. Are there any prop-eq problems where you genuinely would mean something mathematically different?</p>",
        "id": 379310184,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690494878
    },
    {
        "content": "<p>Because right now it seems like the <code>positive</code> you're building is genuinely a generalization of <code>nnreal</code></p>",
        "id": 379310265,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690494919
    },
    {
        "content": "<p>I don't <em>think</em> so.</p>",
        "id": 379310316,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690494938
    },
    {
        "content": "<p>Is there a natural topology to put on <code>positive</code>, and would it agree with the one on <code>nnreal</code>?</p>",
        "id": 379310406,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690494970
    },
    {
        "content": "<p>Sure, it's the subtype topology.</p>",
        "id": 379310469,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690494999
    },
    {
        "content": "<p>I mean, it shouldn't be any surprise that we're generalizing <code>nnreal</code>, right? Or is your point that you want to make them defeq so that we can get some things for free?</p>",
        "id": 379311462,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690495364
    },
    {
        "content": "<p>I mean, they're already defeq in your PR anyway</p>",
        "id": 379311499,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690495383
    },
    {
        "content": "<p>I'm suggesting we may as well make them reducibly defeq to make things slightly free-er</p>",
        "id": 379311538,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690495396
    },
    {
        "content": "<p>Why isn't <code>ℝ≥0</code> itself reducible?</p>",
        "id": 379312237,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690495658
    },
    {
        "content": "<p>Should we move the last messages to a thread about Jireh's PR? (I don't know how to do it...)</p>",
        "id": 379312257,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690495665
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/!3.2318230.20Positivity.20of.20linear.20maps/near/379312237\">said</a>:</p>\n<blockquote>\n<p>Why isn't <code>ℝ≥0</code> itself reducible?</p>\n</blockquote>\n<p>That's a good question, and possibly a reasonable counterargument for my suggestion</p>",
        "id": 379312364,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690495698
    },
    {
        "content": "<p>But I think even if it's not reducible, it might be better to make <code>positive</code> be the type rather than the submonoid, for consistency</p>",
        "id": 379312416,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690495716
    },
    {
        "content": "<p>35 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"144837\" href=\"/#narrow/stream/144837-PR-reviews/topic/.213.2318230.20Positivity.20of.20linear.20maps\">#PR reviews &gt; !3#18230 Positivity of linear maps</a> by <span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span>.</p>",
        "id": 379312472,
        "sender_full_name": "Notification Bot",
        "timestamp": 1690495739
    },
    {
        "content": "<p>Yes, Eric, you've convinced me.</p>",
        "id": 379312577,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690495788
    },
    {
        "content": "<p>Also, how different will that be from the content of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Order/Nonneg/Ring.html\">Mathlib.Algebra.Order.Nonneg.Ring</a> ?</p>",
        "id": 379313088,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690495980
    },
    {
        "content": "<p>Annoyingly we don't even have a name for it, everything is done with the subtype, but that could be changed easily</p>",
        "id": 379313308,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690496071
    },
    {
        "content": "<p>It's not. It's just that we can add some (defeq) instances under the hypotheses of <code>OrderedSemiring</code> or <code>StarOrderedRing</code> (like <code>AddCommMonoidWithOne</code>)</p>",
        "id": 379313335,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690496086
    },
    {
        "content": "<p>Right so you could just add instances in the same way (and have a <code>positive</code> name for convenience too)?</p>",
        "id": 379313463,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690496156
    },
    {
        "content": "<p>Yes, but probably we don't want to add them to that file to minimize imports.</p>",
        "id": 379313586,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690496197
    },
    {
        "content": "<p>Sure</p>",
        "id": 379313656,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690496228
    },
    {
        "content": "<p>If we can come up with a reasonable notation then the name isn't as important. But I think <code>A≥0</code> isn't going to work for general types <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 379313758,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690496277
    },
    {
        "content": "<p>And I just went looking for a (I believe nonexistent) unicode subscript <code>≥</code>.</p>",
        "id": 379313889,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690496323
    },
    {
        "content": "<p>On a separate note, this PR doesn't build. I think it's because of the changes to <code>Data.Nat.Cast</code> which explode type class search from <code>OrderedSemiring</code> to a bag of classes (but I could be wrong). Do we need an <code>OrderedAddCommMonoidWithOne</code> class? (I don't really want it, but if we must...)</p>",
        "id": 379314396,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690496547
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.234871.20StarOrderedRing.2Epositive/near/379313758\">said</a>:</p>\n<blockquote>\n<p>But I think <code>A≥0</code> isn't going to work for general types <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>\n</blockquote>\n<p>I think <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> tried out this type of notation in Lean 3 some time ago</p>",
        "id": 379315138,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690496915
    },
    {
        "content": "<p>Also, this is a very naive proposal, but I wonder wether we should have a <code>IsStarPositive</code> typeclass (similar to <code>IsStarNormal</code>) expressing that an element can be written as (a sum of) <code>(star x) * x</code>, which crucially <strong>would not depend on the existence of an order</strong>. There are two reasons I think this could be useful:</p>\n<ul>\n<li>first, having a typeclass means we can have an instance saying that a positive element is self adjoint. In particular, Lean would be able to understand by itself that it has a functional calculus. We could use <code>Fact</code> of course, but that is messy.</li>\n<li>second, although we definitely don't want to equip all star algebras with the order defined by the star operation, I think it will be a bit annoying to <em>require</em> a predefined order for being able to talk about positive operators. In proofs that wouldn't be too annoying (maybe we should have a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Tactic.Borelize.tacticBorelize___#doc\">docs#Mathlib.Tactic.Borelize.tacticBorelize___</a> -like tactic), but for statement that would probably be annoying. This would be even more useful if some type happens to have a truly different order as an instance, but I don't have any example for that.</li>\n</ul>\n<p>Of course the risk is API duplication. A possible solution is to make sure that <code>IsStarPositive</code> is actually defeq to non-negativity in the (non-instance) order induced by the star, so that we can duplicate the statements without duplicating the proofs.</p>",
        "id": 379317095,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690497945
    },
    {
        "content": "<p>I think the only reason to do that would be:</p>\n<ul>\n<li>We have a type that has a different canonical ordering</li>\n<li>We find the existing order on <code>complex</code> to gross to be a <code>LE</code> instance</li>\n</ul>",
        "id": 379318614,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690498713
    },
    {
        "content": "<p>I think the current order on <code>complex</code> should work actually, right? Is it an instance anyway?</p>",
        "id": 379322184,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690500599
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.234871.20StarOrderedRing.2Epositive/near/379315138\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.234871.20StarOrderedRing.2Epositive/near/379313758\">said</a>:</p>\n<blockquote>\n<p>But I think <code>A≥0</code> isn't going to work for general types <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>\n</blockquote>\n<p>I think <span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> tried out this type of notation in Lean 3 some time ago</p>\n</blockquote>\n<p>I am not sure that I pushed my attempts to mathlib, but <a href=\"#narrow/stream/113488-general/topic/notation.20for.20positive.20elements\">here is one of the relevant conversations</a>.</p>\n<p>My conclusion was that, as much as I liked the idea of the notation, I ended up working with the subtype directly.</p>",
        "id": 379348657,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1690513585
    }
]