[
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/13166\">#13166</a> replaces just under 8000 <code>refine'</code> with <code>refine</code>.  A parallel PR with the same replacement (and a linter to help the process) built all of mathlib, so I am hopeful that this one will also build.</p>",
        "id": 440493236,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716551202
    },
    {
        "content": "<p>The way the replacement happened is as follows.</p>\n<p>A linter detected <code>refine'</code>, replaced them by <code>refine</code> and logged the locations of the \"unsynthesized <code>_</code>\" and then replaced each <code>refine'</code> in succession with <code>refine</code>.  If the substitution built, it would output the position of the <code>refine'</code> and of the <code>_</code>, otherwise it would skip the <code>refine'</code>.</p>",
        "id": 440493493,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716551314
    },
    {
        "content": "<p>A second (python) script removed the flagged <code>'</code>s and added the needed <code>?</code>.</p>",
        "id": 440493573,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716551350
    },
    {
        "content": "<p>This worked \"almost\" well!</p>",
        "id": 440493585,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716551357
    },
    {
        "content": "<p>As a consequence, on that branch, there are 1634 <code>refine'</code> left.</p>",
        "id": 440494038,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716551545
    },
    {
        "content": "<p>The PR is linting now, after a merge conflict.  I tried to use <code>!bench</code>, but it told me that there are no runs to compare to: can I do something to get <code>!bench</code> to compare to something somewhat recent?</p>",
        "id": 440507065,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716556536
    },
    {
        "content": "<p><a href=\"http://speed.lean-fro.org/mathlib4/compare/e7b27246-a3e6-496a-b552-ff4b45c7236e/to/7154f447-eacb-45e1-b172-599fa45c4fa8?hash1=801a7d0eef7f568fbb26de3770097abcd981977d\">http://speed.lean-fro.org/mathlib4/compare/e7b27246-a3e6-496a-b552-ff4b45c7236e/to/7154f447-eacb-45e1-b172-599fa45c4fa8?hash1=801a7d0eef7f568fbb26de3770097abcd981977d</a> -100B</p>",
        "id": 440507480,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716556678
    },
    {
        "content": "<p>If you click on the little scales icon you can select another commit to compare against. I just went back two commits in the history to get one that had been benched</p>",
        "id": 440507663,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716556732
    },
    {
        "content": "<p>Oh, thanks!  So... this has not made mathlib worse, right?  I am always unsure how to read these results...</p>",
        "id": 440507688,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716556740
    },
    {
        "content": "<p>No file significantly regressed. Some significantly improved and overall there are ~100B (or ~.1%) less instructions</p>",
        "id": 440507833,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716556790
    },
    {
        "content": "<p>You made lean do 0.081% less work</p>",
        "id": 440507863,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1716556802
    },
    {
        "content": "<p>Not sure if that's reliable</p>",
        "id": 440507918,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1716556809
    },
    {
        "content": "<p>I would be shocked if it was noise</p>",
        "id": 440507964,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716556828
    },
    {
        "content": "<p>Ok, thanks!  I just get confused by so many parameters and do not really know which ones to take seriously and which ones to disregard.</p>",
        "id": 440508023,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716556854
    },
    {
        "content": "<p>Overall instruction changes in the 10s of billions is almost certainly signal</p>",
        "id": 440508120,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716556888
    },
    {
        "content": "<p>Whereas wall clock improvements of 3% might be that the server is feeling its oats that day</p>",
        "id": 440508314,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716556936
    },
    {
        "content": "<p>Ok, great, thanks for the explanations!</p>",
        "id": 440508316,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716556937
    },
    {
        "content": "<p>Is there any automated tool that will consume the diff and tell me if the only changes are </p>\n<ul>\n<li><code>refine'</code> =&gt; <code>refine</code> are the only deletions </li>\n<li><code>_</code> =&gt; <code>?_</code> are the only additions?</li>\n</ul>",
        "id": 440508741,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716557063
    },
    {
        "content": "<p>I also added some line breaks for the 100 chars linter.</p>",
        "id": 440508856,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557100
    },
    {
        "content": "<p>That would be a good test :)</p>",
        "id": 440508917,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716557122
    },
    {
        "content": "<p>I am not sure about automating what you asked, other than looking at git diff and maybe a more refined word diff.</p>",
        "id": 440508939,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557130
    },
    {
        "content": "<p>(The long lines should all be in the same commit, btw, so should be easy to filter out, after the test!)</p>",
        "id": 440509009,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557154
    },
    {
        "content": "<p>I mean that if told me the line breaks were not of this type it would make me feel more confident about the automated diff checking tool</p>",
        "id": 440509445,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716557300
    },
    {
        "content": "<p>You could replace on master and the PR <code>refine'</code> with <code>refine</code> and remove all <code>?</code> and diff the output.</p>",
        "id": 440509450,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557301
    },
    {
        "content": "<p>Right, so if we write something that does what I said, it should report just the line breaks.</p>",
        "id": 440509524,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557328
    },
    {
        "content": "<p>I tried to ask GPT to do it for me on the last batch <code>refine'</code> PR but decided powering through was quicker that fixing the code</p>",
        "id": 440509650,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716557382
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>  1    _, _‚ü©\n  1      a‚ÇÇ * a‚ÇÅ, a‚ÇÇ * b‚ÇÅ + b‚ÇÇ, mul_nonneg ha‚ÇÇ ha‚ÇÅ, hab.le, _, _‚ü©\n  1      ‚ü®a, b, ‚ü®‚ü®‚ü®_, fun p hp =&gt; _‚ü©, hab‚ÇÇ‚ü©, ‚ü®_, fun p hp =&gt; _‚ü©‚ü©, by simp_rw [hab‚ÇÅ, m.add_one_sub_one]‚ü©\n  1    and_congr_right&#39;\n  1      ‚ü®by rw [repr, ihb.1, add_succ, repr], fun H =&gt; H.fst.oadd _ (NF.below_of_lt&#39; _ (ihb.2 H.snd))‚ü©\n  1    (_ : _ ‚â§ card (succ (typein (¬∑ &lt; ¬∑) (g p))) * card (succ (typein (¬∑ &lt; ¬∑) (g p)))) _\n  1      ciSup_eq_of_forall_le_of_forall_lt_exists_gt (fun j =&gt; _) fun n hn =&gt; ‚ü®i, hn.trans_eq _‚ü©\n  1    closure_cycle_coprime_swap (Nat.Coprime.symm (h0.coprime_iff_not_dvd.mpr fun h =&gt; h4 _)) h1 h2 x\n  1      (Continuous.continuousOn _) (Continuous.continuousOn _) _).continuousOn\n  1    (continuous_if_le _ _\n  1      (continuous_if_le _ _ (Continuous.continuousOn _) (Continuous.continuousOn _) _).continuousOn\n  1            disjoint_left.mp\n  1    (eq_pow_second_of_chain_of_has_chain hs (fun t u h =&gt; _) (@fun r =&gt; ‚ü®@fun hr =&gt; _, _‚ü©) _).symm\n  1    exists_congr fun a =&gt; ‚ü®fun ha b =&gt; ‚ü®fun hba hb =&gt; _, fun hb =&gt; _‚ü©, fun ha =&gt; ‚ü®_, fun b hb =&gt; _‚ü©‚ü©\n  1      Filter.EventuallyEq.trans _ (indicator_ae_eq_of_restrict_compl_ae_eq_zero (hm _ hs_m) hf_zero)\n  1      Finset.Subset.trans (vars_add_subset _ _) (Finset.union_subset_union (Finset.Subset.refl _) _)\n  1              ‚ü®f.num, f.num_mem_deg‚ü©, mem2‚ü©, _, _‚ü©, rfl‚ü©\n  1    forall_congr&#39; fun _hp =&gt; forall_congr&#39; fun q =&gt; forall_congr&#39; fun hq =&gt; _\n  1    forall_congr&#39; fun p =&gt; forall_congr&#39; fun _hp =&gt; forall_congr&#39; fun q =&gt; forall_congr&#39; fun hq =&gt; _\n  1            fun a ha =&gt; by simpa [ha] using hp ‚ü®a, ha‚ü©, _‚ü©\n  1      ‚ü®fun a =&gt; if h : a ‚àà s then p ‚ü®a, h‚ü© else univ, fun a ha =&gt; by simpa [ha] using hp ‚ü®a, ha‚ü©, _‚ü©\n  1                          fun _ =&gt; h‚ÇÇ.1, fun _ =&gt; h‚ÇÇ.1‚ü©, _‚ü©\n  1    ‚ü®fun ha b =&gt; ‚ü®fun hba hb =&gt; _, fun hb =&gt; _‚ü©, fun ha =&gt; ‚ü®_, fun b hb =&gt; _‚ü©‚ü©\n  1    ‚ü®fun h ‚Ü¶ _, fun h ‚Ü¶ _‚ü©\n  1        ‚ü®fun h =&gt; ‚ü®fun i hi j hj hij =&gt; _, fun i hi j hj hij =&gt; _‚ü©, fun h =&gt; h.1.prod_left h.2‚ü© &lt;;&gt;\n  1      ‚ü®fun h =&gt; ‚ü®fun i hi j hj hij =&gt; _, fun i hi j hj hij =&gt; _‚ü©, fun h =&gt; h.1.prod_left h.2‚ü© &lt;;&gt;\n  1    fun h ‚Ü¶ ‚ü®fun J hJ hIJ hJX ‚Ü¶ hIJ.antisymm (fun e heJ ‚Ü¶ by_contra (fun heI ‚Ü¶ _)), _‚ü©‚ü©\n  1    fun h ‚Ü¶ ‚ü®fun J hJ hIJ hJX ‚Ü¶ hIJ.antisymm (fun e heJ ‚Ü¶ by_contra (fun heI ‚Ü¶ _)),_‚ü©‚ü©\n  1    ‚ü®fun h : (preadditiveYonedaObj J ‚ãô (forget &lt;| ModuleCat (End J))).PreservesEpimorphisms =&gt; _, _‚ü©\n  1          fun hx =&gt; hx.map S.subtype‚ü©\n  1      fun hx =&gt; hx.map S.subtype‚ü©\n  1      ‚ü®fun h x hx y hy a b ha hb hab =&gt; h hx hy ha.le hb.le hab, fun h x hx y hy a b ha hb hab =&gt; _‚ü©\n  1    ‚ü®fun h x hx y hy a b ha hb hab =&gt; h hx hy ha.le hb.le hab, fun h x hx y hy a b ha hb hab =&gt; _‚ü©\n  1    ‚ü®fun hx =&gt; ‚ü®‚ü®x, ‚ü®(‚Üëhx.unit‚Åª¬π : A), StarSubalgebra.isUnit_coe_inv_mem hS hx x.prop‚ü©, _, _‚ü©, rfl‚ü©,\n  1    (@fun r =&gt; ‚ü®@fun hr =&gt; _, _‚ü©) _).symm\n  1            fun s =&gt; _\n  1            fun x =&gt; _, u_open.lowerSemicontinuous_indicator (zero_le _), _‚ü©\n  1              (h2 (mem_disjiUnion.mpr ‚ü®_, a.prop, hfa‚ü©) (mem_disjiUnion.mpr ‚ü®_, b.prop, hfb‚ü©) _) hga\n  1            (h2 (mem_disjiUnion.mpr ‚ü®_, a.prop, hfa‚ü©) (mem_disjiUnion.mpr ‚ü®_, b.prop, hfb‚ü©) _) hga\n  1    (h.const_mul ‚ÄñL‚Äñ).mono&#39; (hmf.convolution_integrand_snd&#39; L hmg) (eventually_of_forall fun x =&gt; _)\n  1    (hd.comp differentiable_neg.diffContOnCl H) _ (fun x hx =&gt; _) (fun x hx =&gt; _) hz_re hz_im\n  1    ((hf.comp_tendsto hg).symm.congr&#39; (hfg.mono _) (eventually_of_forall fun _ =&gt; rfl)).trans_isBigO\n  1    (hfg.mono _) (eventually_of_forall fun _ =&gt; rfl)).trans_isBigO _\n  1              hgb\n  1            hgb\n  1        (h (g * C f.leadingCoeff) (f * C g.leadingCoeff) _ _ _).symm.imp\n  1        (h (g * C f.leadingCoeff) (f * C g.leadingCoeff) _ _ _).symm.imp (isUnit_of_mul_eq_one f _)\n  1    (hmf.convolution_integrand_snd&#39; L hmg) (eventually_of_forall fun x =&gt; _)\n  1    hm (Lp.stronglyMeasurable f) _ _ _ _ hs hŒºs\n  1    hz_re hz_im\n  1    (IccExtend_eq_self zero_le_one smoothTransition (fun x hx =&gt; _) fun x hx =&gt; _) x\n  1      indicator_ae_eq_of_restrict_compl_ae_eq_zero (hm _ hs_m) hf_zero\n  1      intros &lt;;&gt; simp only [zero_smul, add_smul]\n  1    intro x hx &lt;;&gt; apply_assumption &lt;;&gt;\n  1          (isUnit_of_mul_eq_one f _)\n  1          le_antisymm (le_of_add_le_add_left ((hmn.trans (Nat.succ_le_of_lt h)).trans _)) n&#39;.zero_le\n  1    le_antisymm (sup_le (prod_mono le_sup_left le_sup_left) (prod_mono le_sup_right le_sup_right)) _\n  1    le_antisymm (Œ± := Ideal R) (fun i hi =&gt; _) &lt;|\n  1    le_antisymm (Œ± := Ideal R) (fun i hi =&gt; _) &lt;| (span_singleton_mul_span_singleton a b).ge.trans _\n  1          (le_of_add_le_add_left ((hmn.trans (Nat.succ_le_of_lt h)).trans _)) n&#39;.zero_le\n  1        le_of_forall_nnreal_lt fun r hr =&gt; le_radius_of_bound_nnreal _ (max 1 ‚Äñ(1 : A)‚Äñ‚Çä) fun n =&gt; _\n  1        le_radius_of_bound_nnreal _ (max 1 ‚Äñ(1 : A)‚Äñ‚Çä) fun n =&gt; _\n  1    lintegral_nnnorm_le_of_forall_fin_meas_integral_eq hm (Lp.stronglyMeasurable f) _ _ _ _ hs hŒºs\n  1    lt_of_le_of_lt (_ : _ ‚â§ card (succ (typein (¬∑ &lt; ¬∑) (g p))) * card (succ (typein (¬∑ &lt; ¬∑) (g p))))\n  1    lt_of_le_of_ne ((real_inner_le_norm _ _).trans (mul_le_mul_of_nonneg_right _ (norm_nonneg _))) _\n  1        mem_shadow_iff.2\n  1    ‚ü®M.evalFrom s ((x.take m).take n), (x.take m).take n, (x.take m).drop n,\n  1    ‚ü®M.evalFrom s ((x.take m).take n), (x.take m).take n, (x.take m).drop n, x.drop m, _, _, _, by\n  1    (Multiset.le_prod_nonempty_of_submultiplicative_on_pred f p h_mul hp_mul _ _ _) _\n  1    (Nat.Coprime.symm (h0.coprime_iff_not_dvd.mpr fun h =&gt; h4 _)) h1 h2 x\n  1    ne_zero_of_dvd_ne_zero hn (d ‚ü®p, _‚ü©).prop).mp ‚ü®_, fun b hb =&gt; _‚ü©\n  1          (p.changeOriginSeries_summable_aux‚ÇÇ (mem_emetric_ball_zero_iff.1 x_mem_ball) k)\n  1          (p.changeOriginSeries_summable_aux‚ÇÇ (mem_emetric_ball_zero_iff.1 x_mem_ball) k) fun s =&gt; _\n  1    ‚ü®P.recOnHorner (by simp) (fun p r hp‚ÇÄ _ hp hpr i ‚Ü¶ _) (fun p _ hnp hpX i ‚Ü¶ _), fun h ‚Ü¶ _‚ü©\n  1        ‚ü®pullback (Abelian.factorThruImage f) c, ùüô _, pullback.snd, inferInstance, inferInstance, _‚ü©\n  1              pullback.snd, inferInstance, inferInstance, _‚ü©\n  1    ((real_inner_le_norm _ _).trans (mul_le_mul_of_nonneg_right _ (norm_nonneg _))) _\n  3          refine\n 17        refine\n 71      refine\n 17    ¬∑ refine\n 43  ¬∑ refine\n651  refine\n  1    refine ‚ü®a, b, ‚ü®‚ü®‚ü®_, fun p hp =&gt; _‚ü©, hab‚ÇÇ‚ü©, ‚ü®_, fun p hp =&gt; _‚ü©‚ü©, by\n  1  refine and_congr_right&#39;\n  1  refine (Associates.isAtom_iff &lt;|\n  1  refine (Associates.isAtom_iff &lt;| ne_zero_of_dvd_ne_zero hn (d ‚ü®p, _‚ü©).prop).mp ‚ü®_, fun b hb =&gt; _‚ü©\n  1    refine ‚ü®ax + ay, fun i =&gt; I.add_mem (hax i) (hay i), Finsupp.sum_add_index&#39; _ _‚ü© &lt;;&gt;\n  1    refine ‚ü®ax + ay, fun i =&gt; I.add_mem (hax i) (hay i), Finsupp.sum_add_index&#39; _ _‚ü© &lt;;&gt; intros &lt;;&gt;\n  1  ¬∑ refine ‚ü®by\n  1    refine ciSup_eq_of_forall_le_of_forall_lt_exists_gt (fun j =&gt; _) fun n hn =&gt; ‚ü®i, hn.trans_eq _‚ü©\n  1  refine closure_cycle_coprime_swap\n  1  refine congr_fun\n  1  refine congr_fun (IccExtend_eq_self zero_le_one smoothTransition (fun x hx =&gt; _) fun x hx =&gt; _) x\n  1          refine disjoint_left.mp\n  1  refine (eq_pow_second_of_chain_of_has_chain hs (fun t u h =&gt; _)\n  1  refine exists_congr fun a =&gt;\n  1    refine Filter.EventuallyEq.trans _ &lt;|\n  1    refine Finset.Subset.trans\n  1  refine forall_congr&#39; fun p =&gt;\n  1    refine ‚ü®‚ü®f, Quotient.mk&#39;&#39; ‚ü®f.deg, ‚ü®f.den, f.den_mem_deg‚ü©,\n  1    refine ‚ü®‚ü®f, Quotient.mk&#39;&#39; ‚ü®f.deg, ‚ü®f.den, f.den_mem_deg‚ü©, ‚ü®f.num, f.num_mem_deg‚ü©, mem2‚ü©, _, _‚ü©,\n  1    refine ‚ü®fun a =&gt; if h : a ‚àà s then p ‚ü®a, h‚ü© else univ,\n  1  refine ‚ü®fun h : (preadditiveYonedaObj J ‚ãô (forget &lt;| ModuleCat (End J))).PreservesEpimorphisms =&gt;\n  1  refine ‚ü®fun hx =&gt;\n  1      ¬∑ refine fun n =&gt; eventually_of_forall fun y =&gt;\n  1      ¬∑ refine fun n =&gt; eventually_of_forall fun y =&gt; SimpleFunc.norm_approxOn_zero_le _ _ (x, y) n\n  1  refine (h.const_mul ‚ÄñL‚Äñ).mono&#39;\n  1  refine ((hf.comp_tendsto hg).symm.congr&#39;\n  1    refine hmn.mul_dvd_of_dvd_of_dvd _ _ &lt;;&gt;\n  1    refine hmn.mul_dvd_of_dvd_of_dvd _ _ &lt;;&gt; rw [‚Üê natCast_dvd_natCast, natAbs_dvd, dvd_natAbs] &lt;;&gt;\n  1  refine (Iff.trans _ &lt;| hfg.sum_smul_comp_perm_eq_sum_smul_iff hœÉinv).trans\n  1  refine (Iff.trans _ &lt;| hfg.sum_smul_comp_perm_eq_sum_smul_iff hœÉinv).trans ‚ü®fun h ‚Ü¶ _, fun h ‚Ü¶ _‚ü©\n  1        refine le_antisymm\n  1  refine le_antisymm\n  1      refine le_of_forall_nnreal_lt fun r hr =&gt;\n  1  refine le_trans\n  1  refine le_trans (Multiset.le_prod_nonempty_of_submultiplicative_on_pred f p h_mul hp_mul _ _ _) _\n  1  refine lhopital_zero_right_on_Ioo hau _ _ _ hfa hga hdiv &lt;;&gt;\n  1  refine lhopital_zero_right_on_Ioo hau _ _ _ hfa hga hdiv &lt;;&gt; intro x hx &lt;;&gt; apply_assumption &lt;;&gt;\n  1  refine lintegral_nnnorm_le_of_forall_fin_meas_integral_eq\n</code></pre></div>",
        "id": 440511078,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557828
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>  1  refine lt_of_le_of_lt\n  1  refine lt_of_le_of_ne\n  1    ¬∑ refine mem_shadow_iff.2\n  1  refine ‚ü®P.recOnHorner (by simp) (fun p r hp‚ÇÄ _ hp hpr i ‚Ü¶ _) (fun p _ hnp hpX i ‚Ü¶ _), fun h ‚Ü¶ _‚ü©\n  1      refine ‚ü®pullback (Abelian.factorThruImage f) c, ùüô _,\n  1  refine quadrant_II\n  1  refine quadrant_II (hd.comp differentiable_neg.diffContOnCl H) _ (fun x hx =&gt; _) (fun x hx =&gt; _)\n  1      refine RelHomClass.wellFounded\n  1  refine ‚ü®R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel &lt;| htu.trans &lt;| P.le hu‚ÇÅ), _, _, _‚ü©\n  1    refine ‚ü®Set.indicator u fun _ =&gt; c,\n  1        RelHomClass.wellFounded\n  1          (RelHom.mk _ _ : (DvdNotUnit : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üír ((¬∑ &lt; ¬∑) : ‚Ñï‚àû ‚Üí ‚Ñï‚àû ‚Üí Prop)) wellFounded_lt\n  1        (RelHom.mk _ _ : (DvdNotUnit : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üír ((¬∑ &lt; ¬∑) : ‚Ñï‚àû ‚Üí ‚Ñï‚àû ‚Üí Prop)) wellFounded_lt\n  1    ‚ü®R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel &lt;| htu.trans &lt;| P.le hu‚ÇÅ), _, _, _‚ü©\n  1        rfl‚ü©\n  1      rfl, _‚ü©\n  1      rw [‚Üê natCast_dvd_natCast, natAbs_dvd, dvd_natAbs] &lt;;&gt;\n  1      rw [repr, ihb.1, add_succ, repr], fun H =&gt; H.fst.oadd _ (NF.below_of_lt&#39; _ (ihb.2 H.snd))‚ü©\n  1      ‚ü®Set.indicator u fun _ =&gt; c, fun x =&gt; _, u_open.lowerSemicontinuous_indicator (zero_le _), _‚ü©\n  1          SimpleFunc.norm_approxOn_zero_le _ _ (x, y) n\n  1      simp only [zero_smul, add_smul]\n  1      simp_rw [Function.onFun, iSup_disjoint_iff, disjoint_iSup_iff] &lt;;&gt;\n  1    simp_rw [Function.onFun, iSup_disjoint_iff, disjoint_iSup_iff] &lt;;&gt;\n  1        simp_rw [hab‚ÇÅ, m.add_one_sub_one]‚ü©\n  1      (span_singleton_mul_span_singleton a b).ge.trans _\n  1    (sup_le (prod_mono le_sup_left le_sup_left) (prod_mono le_sup_right le_sup_right)) _\n  1      supports_insert.2 ‚ü®‚ü®fun _ =&gt; h‚ÇÅ, fun _ =&gt; h‚ÇÇ.2 _ (Or.inl W),\n  1      supports_insert.2 ‚ü®‚ü®fun _ =&gt; h‚ÇÅ, fun _ =&gt; h‚ÇÇ.2 _ (Or.inl W), fun _ =&gt; h‚ÇÇ.1, fun _ =&gt; h‚ÇÇ.1‚ü©, _‚ü©\n  1            sup_sdiff_mem_of_mem_compression Ht hvt &lt;| disjoint_of_erase_right hau huvs.1, a, _, _‚ü©\n  1          sup_sdiff_mem_of_mem_compression Ht hvt &lt;| disjoint_of_erase_right hau huvs.1, a, _, _‚ü©\n  1          ‚ü®(t ‚äî u) \\ v,\n  1        ‚ü®(t ‚äî u) \\ v,\n  1      (vars_add_subset _ _) (Finset.union_subset_union (Finset.Subset.refl _) _)\n  1                    x.drop m, _, _, _, by rfl, _‚ü©\n  1           ‚ü®‚ü®x, ‚ü®(‚Üëhx.unit‚Åª¬π : A), StarSubalgebra.isUnit_coe_inv_mem hS hx x.prop‚ü©, _, _‚ü©, rfl‚ü©,\n  1      ‚ü®y, hy, z, hz, _, _, _, _, _, rfl‚ü©,\n  1      ‚ü®y, hy, z, hz, _, _, _, _, _, rfl‚ü©, a‚ÇÇ * a‚ÇÅ, a‚ÇÇ * b‚ÇÅ + b‚ÇÇ, mul_nonneg ha‚ÇÇ ha‚ÇÅ, hab.le, _, _‚ü©\n</code></pre></div>",
        "id": 440511086,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557831
    },
    {
        "content": "<p>I am not sure if this is helpful: here is what it is.</p>",
        "id": 440511163,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557846
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>git<span class=\"w\"> </span>diff<span class=\"w\"> </span>--unified<span class=\"o\">=</span><span class=\"m\">0</span><span class=\"w\"> </span>origin/master...HEAD<span class=\"w\"> </span><span class=\"p\">|</span>\n<span class=\"w\">  </span>sed<span class=\"w\"> </span>-n<span class=\"w\"> </span><span class=\"s1\">'s=^+\\([^+]\\)==p; s=^-\\([^-]\\)==p'</span><span class=\"w\"> </span><span class=\"p\">|</span>\n<span class=\"w\">  </span>sed<span class=\"w\"> </span><span class=\"s1\">'s=refine'</span><span class=\"s2\">\"'\"</span><span class=\"s1\">'=refine=g; s=?==g'</span><span class=\"w\"> </span><span class=\"p\">|</span>\n<span class=\"w\">  </span>sort<span class=\"w\"> </span><span class=\"p\">|</span><span class=\"w\"> </span>uniq<span class=\"w\"> </span>-c<span class=\"w\"> </span><span class=\"p\">|</span><span class=\"w\"> </span>grep<span class=\"w\"> </span>-v<span class=\"w\"> </span><span class=\"s2\">\"^ *[0-9]*[02468] \"</span>\n</code></pre></div>",
        "id": 440511255,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557874
    },
    {
        "content": "<ul>\n<li>Gets the diff printing only the line changes (plus fluff)</li>\n<li>extracts the lines that begin with either a single <code>+</code> or a single <code>-</code> (these should be the lines of the actual diff)</li>\n<li>changes <code>refine'</code> to <code>refine</code> and strips out <code>?</code></li>\n<li>sorts, prefixes multiplicities on repeated lines, removes lines whose multiplicity is even.</li>\n</ul>",
        "id": 440511611,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557992
    },
    {
        "content": "<p>(at least, these are many fewer lines than the diff the GitHub shows...).</p>",
        "id": 440511831,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716558062
    },
    {
        "content": "<p>Oh, you can check that no declaration was lost!</p>",
        "id": 440511869,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716558070
    },
    {
        "content": "<p>Let me do that!</p>",
        "id": 440511882,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716558074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313166.20.60refine'.60.20to.20.60refine.60/near/440509450\">said</a>:</p>\n<blockquote>\n<p>You could replace on master and the PR <code>refine'</code> with <code>refine</code> and remove all <code>?</code> and diff the output.</p>\n</blockquote>\n<p>I created <a href=\"https://github.com/leanprover-community/mathlib4/tree/MR-refine-master-with-replacement\">branch#MR-refine-master-with-replacement</a> and <a href=\"https://github.com/leanprover-community/mathlib4/tree/MR-refine-to-refine-butchered\">branch#MR-refine-to-refine-butchered</a> doing exactly this:</p>\n<ul>\n<li>replacing all <code>refine'</code> be <code>refine</code> and all <code>?_</code> by <code>_</code> (automatically),</li>\n<li>both on the parent commit of <a href=\"https://github.com/leanprover-community/mathlib4/pull/13166\">#13166</a> (the first branch) and on top of the PR.</li>\n</ul>",
        "id": 440517374,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1716559727
    },
    {
        "content": "<p>In theory, <a href=\"https://github.com/leanprover-community/mathlib4/compare/MR-refine-master-with-replacement...MR-refine-to-refine-butchered\">this diff</a> is supposed to give the output and be virtually empty...</p>",
        "id": 440517583,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1716559795
    },
    {
        "content": "<p>Wrong link?</p>",
        "id": 440517730,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1716559830
    },
    {
        "content": "<p>In practice, something's off - I would think with github's diff, or my local methodology.</p>",
        "id": 440517820,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1716559867
    },
    {
        "content": "<p>(I don't have time until the evening to look into what is going wrong, sorry.)</p>",
        "id": 440518093,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1716559952
    },
    {
        "content": "<p>I thought that the issue was that in the replacement you had removed the first <code>?</code> of each line, so I went ahead and tried removing all <code>?</code>s, but I still can't get the diff to show that I think that it should...</p>",
        "id": 440528279,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716563346
    },
    {
        "content": "<p>Also, note that there were quite a few <code>refine</code> that spanned several lines and the <code>?</code> are not necessarily added on the same line where there is a <code>refine</code>.</p>",
        "id": 440528987,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716563612
    },
    {
        "content": "<p>I did enough spot testing to convince myself that things look good. <img alt=\":merge:\" class=\"emoji\" src=\"https://zulip-avatars.s3.amazonaws.com/3121/emoji/images/18527.png\" title=\"merge\"></p>",
        "id": 440537842,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716567018
    },
    {
        "content": "<p>Much thanks!</p>",
        "id": 440537876,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716567028
    }
]