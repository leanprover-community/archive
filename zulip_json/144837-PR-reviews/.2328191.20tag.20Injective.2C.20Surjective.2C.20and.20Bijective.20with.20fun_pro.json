[
    {
        "content": "<p>I don't think it's possible to move the attributes to the definitions, because of the following import graph:</p>",
        "id": 533810994,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754923843
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/MBjX2fT1dHPMZ6nriak6JxM0/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/MBjX2fT1dHPMZ6nriak6JxM0/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"614x826\" src=\"/user_uploads/thumbnail/3121/MBjX2fT1dHPMZ6nriak6JxM0/image.png/840x560.webp\"></a></div>",
        "id": 533811022,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754923851
    },
    {
        "content": "<p>One could presumably split <code>DFunLike.Basic</code> to eliminate the <code>Logic.Unique</code> import.</p>",
        "id": 533812472,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1754924345
    },
    {
        "content": "<p>... though I'm not sure if this would fully solve the import knot.</p>",
        "id": 533813513,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1754924630
    },
    {
        "content": "<p>What's wrong with tagging them in the tactic file?</p>",
        "id": 533814683,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754925001
    },
    {
        "content": "<p>It's not terrible, but it then requires non-local knowledge to understand the setup. It's also missing a chance to fight against the tide of increasing import tangles. :-)</p>",
        "id": 533894535,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1754964775
    },
    {
        "content": "<p>I've looked into this more, fun_prop has to deal with function coercions, and <a href=\"https://github.com/leanprover-community/mathlib4/blob/26144eba0dcb7621dbe5a6adfcebe26f719d696b/Mathlib/Data/FunLike/Basic.lean#L143\">DFunLike uses Function.Injective</a>, so I think we should just accept this PR.</p>",
        "id": 535116820,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755606401
    },
    {
        "content": "<p>But does the <em>attribute</em> need to know about coercions?</p>",
        "id": 535229707,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1755657836
    },
    {
        "content": "<p>All you need for tagging is the attribute.</p>",
        "id": 535229722,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1755657847
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> could comment on whether this would be feasible. Currently, the <code>@[fun_prop]</code> attribute does import <code>Function.Injectice</code> etc.</p>",
        "id": 536642297,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756397691
    },
    {
        "content": "<p>I don't really remember but maybe before using <code>getCoeFnInfo?</code>in <code>FunProp.Mor</code> file I just checked if the constant is <code>DFunLike.coe</code> with a double tick which needs the import.</p>\n<p>Maybe the import can be simplified a lot. Just by looking at the file I don't see anything but pure Lean meta code i.e. no mathlib.</p>",
        "id": 536643753,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1756398215
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> if you can relatively easily untangle the imports to avoid <code>FunLike</code>, then go for it. If not, I think tagging <code>Surjective</code>, <code>Injective</code> etc. later than where they are declared it acceptable.</p>",
        "id": 536662776,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1756405512
    },
    {
        "content": "<p>I made a start in <a href=\"https://github.com/leanprover-community/mathlib4/pull/29078\">#29078</a>; please feel free to adopt it!</p>",
        "id": 536664432,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1756406223
    },
    {
        "content": "<p>And the first attempt built already! I'm running the build with a second commit now, which goes a bit further.</p>",
        "id": 536669701,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1756408406
    },
    {
        "content": "<p>It appears the second commit also works (edit: CI passed).</p>",
        "id": 536673131,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1756410079
    },
    {
        "content": "<p>That's great! However, looking at the import graph after the change, I'm still not sure we want to import all of <code>fun_prop</code> all the way down at <code>Logic.Function.Defs</code>. This is one of the lowest level files in Mathlib. Its only imports after <code>Mathlib.Init</code> are <code>Tactic.{Lemmas, Eqns, AdaptationNote, Attr.Register, TypeStar}</code>.</p>\n<p>I'm not necessarily saying we shouldn't do it though.</p>",
        "id": 536674827,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1756410938
    },
    {
        "content": "<p>My impression is that the fun_prop tactic files are also relatively light on imports: they don't import any mathlib. Yes, they are 10-20 files importing each other, so it will be felt; but I'm not sure how bad this is.</p>",
        "id": 536677597,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1756412233
    },
    {
        "content": "<p>(By the way: where did you see the import graphs? Did you generate them locally?)</p>",
        "id": 536677624,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1756412247
    },
    {
        "content": "<p>get the cache, then you can run <code>lake exe graph --to=\"Mathlib.Tactic.FunProp.Attr\",\"Mathlib.Logic.Function.Defs\" graph.html</code></p>",
        "id": 536677698,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1756412283
    },
    {
        "content": "<p>I wonder, once we have some kind of tags in place to automatically prove injectivity, would we want to have a \"reverse congr\" tactic? I'm thinking if we have a hypothesis <code>h : a + 1 = b + 1</code>, then something like <code>reverse_congr at h</code> would turn it into <code>h : a = b</code>. Or does such a tactic already exist? I have heard of <code>injection</code>, which specifically does this kind of thing for inductive constructors. And then of course there can be a generalized version that similarly turns <code>h : a + 1 &lt; b + 1</code> into <code>h : a &lt; b</code>.</p>",
        "id": 536695365,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756423100
    },
    {
        "content": "<p>I've been wanting this tactic myself. I suggest <code>gcongr at &lt;loc&gt;</code> for the syntax</p>",
        "id": 536724243,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1756448025
    }
]