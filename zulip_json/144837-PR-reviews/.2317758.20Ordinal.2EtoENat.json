[
    {
        "content": "<p>This file defines the map <code>Ordinal → ENat</code> in the obvious way and establishes its API.</p>",
        "id": 479768508,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730324215
    },
    {
        "content": "<p>It mostly just copies the <code>Cardinal/ENat</code> file, so reviewing it should be pretty straightforward.</p>",
        "id": 479768584,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730324262
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/17758\">#17758</a></p>",
        "id": 479768590,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730324266
    },
    {
        "content": "<p>Is there any way to avoid this duplication?</p>",
        "id": 480099580,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730486438
    },
    {
        "content": "<p>I don't think so. Cardinals and especially ordinals are pretty bad as algebraic structures - cardinals are only a commutative semiring, ordinals are not even that. The fact that the initial segment of natural numbers is so nicely behaved in both cases is a pretty big deal, which isn't really reflected in the instances of these types.</p>",
        "id": 480112242,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730491874
    },
    {
        "content": "<p>They are both <code>AddMonoidWithOne</code> and <code>toENat</code> can be defined on that (and since they are also <code>CharZero</code> it's fairly nice). I'm not sure how to generalize the fact that the integers are an initial segment, though</p>",
        "id": 480181077,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730520919
    },
    {
        "content": "<p>Something else that's really nice about the <code>toENat</code> map is that it preserves addition and multiplication</p>",
        "id": 480181209,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730521056
    },
    {
        "content": "<p>But perhaps we can still reduce duplication by defining the map in the more general setting and then proving its properties in the more specific settings</p>",
        "id": 480181281,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730521113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2317758.20Ordinal.2EtoENat/near/480181077\">said</a>:</p>\n<blockquote>\n<p>They are both <code>AddMonoidWithOne</code> and <code>toENat</code> can be defined on that (and since they are also <code>CharZero</code> it's fairly nice). I'm not sure how to generalize the fact that the integers are an initial segment, though</p>\n</blockquote>\n<p>I think <code>SuccAddOrder</code> can do that (perhaps with some monotonicity on the monoid)</p>",
        "id": 480181284,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730521118
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2317758.20Ordinal.2EtoENat/near/480181209\">said</a>:</p>\n<blockquote>\n<p>Something else that's really nice about the <code>toENat</code> map is that it preserves addition and multiplication</p>\n</blockquote>\n<p>I think <code>AddLeftMono</code>, <code>AddMonoidWithOne</code> and <code>SuccAddOrder</code> should give that it preserves addition, and adding <code>LeftDistribClass</code> should also give preserving multiplication (perhaps some monotonicity is also needed for that)</p>",
        "id": 480181589,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730521438
    },
    {
        "content": "<p>If we had a <code>BotEqZero</code> typeclass, that plus the assumptions on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.succ_iterate#doc\">docs#Order.succ_iterate</a> should be enough to show N is an initial segment</p>",
        "id": 480181659,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730521482
    },
    {
        "content": "<p>Though I'm not sure what good that would be, since that doesn't imply operations on N match operations on the type</p>",
        "id": 480181688,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730521513
    },
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.cast_add#doc\">docs#Nat.cast_add</a>, and although the assumptions of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.cast_mul#doc\">docs#Nat.cast_mul</a> aren't what we want, it should also be true for an <code>AddMonoidWithOne</code> with either <code>AddLeftMono</code> or <code>AddRightMono</code></p>",
        "id": 480181797,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730521573
    },
    {
        "content": "<p>Yeah, note that we currently have to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ordinal.natCast_mul#doc\">docs#Ordinal.natCast_mul</a> instead</p>",
        "id": 480181969,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730521650
    },
    {
        "content": "<p>Maybe it is indeed possible to define <code>AddMonoidWithOne.toENat</code> and load its theorems with enough typeclass assumptions to make them applicable to both <code>Ordinal</code> and <code>Cardinal</code></p>",
        "id": 480182086,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730521763
    },
    {
        "content": "<p>The proof of <code>toENat</code> preserving addition also requires addition to be monotonic on the left and right, so that <code>toENat (x + y) = top</code> for either <code>x</code> or <code>y</code> infinite</p>",
        "id": 480182171,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730521824
    },
    {
        "content": "<p>The proof that it preserves multiplication requires monotonicity of multiplication for nonzero values, not sure if there's a typeclass for that</p>",
        "id": 480182202,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730521852
    },
    {
        "content": "<p>And that should be it, I think</p>",
        "id": 480182229,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730521869
    },
    {
        "content": "<p>I think the relevant structure is a <a href=\"https://en.wikipedia.org/wiki/Near-semiring\">left near-semiring</a> with unity, if I understand it correctly</p>",
        "id": 480182847,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730522408
    },
    {
        "content": "<p>What about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cardinal.ofENat#doc\">docs#Cardinal.ofENat</a> ? That seems like it can't be generalized without at least losing the def-eq <code>ofENat ⊤ = ℵ₀</code></p>",
        "id": 480191536,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730530977
    },
    {
        "content": "<p>Though even then, I'm not sure how to generalize it. Every infinite well-order has <code>ℕ</code> as an initial segment but I'm not sure what other typeclass assumption you could tack in to extend that into <code>ENat</code></p>",
        "id": 480191638,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730531083
    },
    {
        "content": "<p>You can use <code>sSup (Set.range Nat.cast)</code>, but that would lose the def-eq, yes</p>",
        "id": 480191792,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730531240
    },
    {
        "content": "<p>Well, even then, I don't think I'd be able to show many of the desired properties</p>",
        "id": 480192033,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730531406
    },
    {
        "content": "<p>e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cardinal.ofENat_strictMono#doc\">docs#Cardinal.ofENat_strictMono</a> would require <code>Set.range Nat.cast</code> to be bounded above, and I don't think there's really any typeclass implying that</p>",
        "id": 480192058,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730531446
    },
    {
        "content": "<p>Or maybe, we can show <code>ofENat_strictMono</code> taking that as an assumption, then prove <code>Cardinal.ofENat_strictMono</code> and <code>Ordinal.ofENat_strictMono</code> using that.</p>",
        "id": 480192226,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730531620
    },
    {
        "content": "<p>Uncountable well order should, although maybe it would be best to make an <code>OrdCardLike</code> at this point, just like there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RCLike#doc\">docs#RCLike</a></p>",
        "id": 480192326,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730531674
    },
    {
        "content": "<p>We don't have an <code>Uncountable</code> typeclass</p>",
        "id": 480192337,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730531692
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Uncountable#doc\">docs#Uncountable</a></p>",
        "id": 480192350,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730531702
    },
    {
        "content": "<p>Oh, nevermind</p>",
        "id": 480192365,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730531716
    },
    {
        "content": "<p>There's clearly a <em>lot</em> of important instances missing here<br>\n<a href=\"/user_uploads/3121/oBd1lLP_sXpsgotAQniIU79m/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/oBd1lLP_sXpsgotAQniIU79m/image.png\" title=\"image.png\"><img data-original-dimensions=\"416x318\" src=\"/user_uploads/thumbnail/3121/oBd1lLP_sXpsgotAQniIU79m/image.png/840x560.webp\"></a></div>",
        "id": 480192376,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730531734
    },
    {
        "content": "<p>Perhaps this discussion should be moved to <a class=\"stream\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4\">#mathlib4</a> . Is there any type this might be relevant for, other then ordinals and cardinals?</p>",
        "id": 480192563,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730531884
    },
    {
        "content": "<p>I guess there's the type aliases <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NatOrdinal#doc\">docs#NatOrdinal</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nimber#doc\">docs#Nimber</a>, though for the latter this map preserves neither addition nor multiplication.</p>",
        "id": 480192679,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730532004
    },
    {
        "content": "<p>And for the former the usefulness of this map is a bit questionable.</p>",
        "id": 480192695,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730532028
    },
    {
        "content": "<p>Other extensions of the natural numbers will generally include numbers in between, or negative numbers, or both, and in those cases this map is not very useful either.</p>",
        "id": 480192717,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730532056
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2317758.20Ordinal.2EtoENat/near/480192563\">said</a>:</p>\n<blockquote>\n<p>Perhaps this discussion should be moved to <a class=\"stream\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4\">#mathlib4</a> . Is there any type this might be relevant for, other then ordinals and cardinals?</p>\n</blockquote>\n<p>Sure, do you have move perms? Or is there someone else we should ask?</p>",
        "id": 480192767,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730532099
    },
    {
        "content": "<p>I don't have permission to move this to another channel, no. I think only moderators can</p>",
        "id": 480192920,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730532207
    },
    {
        "content": "<p>Opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/18546\">#18546</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/18547\">#18547</a> with some missing instances</p>",
        "id": 480194393,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730533542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2317758.20Ordinal.2EtoENat/near/480192326\">said</a>:</p>\n<blockquote>\n<p>Uncountable well order should, although maybe it would be best to make an <code>OrdCardLike</code> at this point, just like there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RCLike#doc\">docs#RCLike</a></p>\n</blockquote>\n<p>I'm not so sure about this anymore. e.g. you could define <code>NatCast</code> on <code>ω₁ + ω</code> by <code>n ↦ ω₁ + n</code> and then <code>Set.range Nat.cast</code> would not be bounded above.</p>",
        "id": 480196334,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730535140
    },
    {
        "content": "<p>The <code>RCLike</code> idea is interesting, though I wonder if it's worth doing just for these two functions on these two types.</p>",
        "id": 480196456,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730535267
    },
    {
        "content": "<p>Avoiding 300 lines of code by writing another 300 is a dubious tradeoff</p>",
        "id": 480196467,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730535285
    },
    {
        "content": "<p>Are there other functions which are common to them and could be generalized like this?</p>",
        "id": 480196574,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730535381
    },
    {
        "content": "<p>There's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cardinal.lift#doc\">docs#Cardinal.lift</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ordinal.lift#doc\">docs#Ordinal.lift</a>, but since that involves universes I doubt it can be neatly generalized</p>",
        "id": 480196610,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730535443
    },
    {
        "content": "<p>That's pretty much it I think</p>",
        "id": 480196624,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730535460
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2317758.20Ordinal.2EtoENat/near/480196334\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2317758.20Ordinal.2EtoENat/near/480192326\">said</a>:</p>\n<blockquote>\n<p>Uncountable well order should, although maybe it would be best to make an <code>OrdCardLike</code> at this point, just like there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RCLike#doc\">docs#RCLike</a></p>\n</blockquote>\n<p>I'm not so sure about this anymore. e.g. you could define <code>NatCast</code> on <code>ω₁ + ω</code> by <code>n ↦ ω₁ + n</code> and then <code>Set.range Nat.cast</code> would not be bounded above.</p>\n</blockquote>\n<p>Oh here's an idea, we define <code>ofENat ⊤ = sInf (Set.range Nat.cast)ᶜ</code> instead</p>",
        "id": 480196701,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730535512
    },
    {
        "content": "<p>If the type is uncountable and well-founded then this infimum is guaranteed to exist</p>",
        "id": 480196731,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730535538
    },
    {
        "content": "<p>And we can use this to prove <code>ofENat_strictMono</code></p>",
        "id": 480196781,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730535593
    },
    {
        "content": "<p>No, that doesn't work either. In the <code>ω₁ + ω</code> example this would give <code>ofENat ⊤ = 0</code>.</p>",
        "id": 480196993,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730535759
    },
    {
        "content": "<p>Maybe it is fine to duplicate a couple of hundred lines of code</p>",
        "id": 480197035,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730535818
    },
    {
        "content": "<p>Note that even if we did manage to write these more general <code>toENat</code> / <code>ofENat</code> functions, we'd still need to prove a bunch of theorems about them for both <code>Cardinal</code> and <code>Ordinal</code>, such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cardinal.ofENat_lt_aleph0#doc\">docs#Cardinal.ofENat_lt_aleph0</a> / Ordinal.ofENat_lt_omega, or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cardinal.lift_ofENat#doc\">docs#Cardinal.lift_ofENat</a> / Ordinal.lift_ofENat.</p>",
        "id": 480197253,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730535967
    },
    {
        "content": "<p>So the gains here aren't even that great.</p>",
        "id": 480197269,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730535989
    },
    {
        "content": "<p>Alright <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 480197320,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730536044
    },
    {
        "content": "<p>I'm revisiting this again and I'm wondering if an RCLike class for ordinals and cardinals is in fact the cleanest solution.</p>",
        "id": 489125703,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1734306903
    },
    {
        "content": "<p>The issues I pointed out above were that the existing typeclasses were too weak to properly encapsulate the behavior of ordinals and cardinals. But we could, I think, make our own typeclass to achieve this instead.</p>",
        "id": 489125778,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1734306967
    },
    {
        "content": "<p>The relevant properties here seem to be:</p>\n<ul>\n<li>there is an initial segment of natural numbers</li>\n<li>this initial segment preserves all of the basic operations</li>\n<li>there is a least infinite number</li>\n</ul>",
        "id": 489125943,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1734307127
    },
    {
        "content": "<p>Now, the issue that I see is that this might be a case where we're just moving complexity from place A to place B. If our development of OCLike is any longer than the 300-ish lines of code we're saving then this is clearly not worth it.</p>",
        "id": 489125987,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1734307187
    },
    {
        "content": "<p>Besides, whereas the similarities between ℝ and ℂ are strong enough to support entire fields of math, all we're really achieving here is minimizing a bit of duplication.</p>",
        "id": 489126100,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1734307227
    },
    {
        "content": "<p>...yeah, I am unconvinced that this is sufficient justification for an OCLike class</p>",
        "id": 489131025,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1734311579
    }
]