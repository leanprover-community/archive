[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/16140\">#16140</a>, I got the suggestion to generalise \"relatively representability\" with respect to any functor (instead of just with respect to the yoneda functor). I think it's a good idea, if it is not too painful to implement. It seems to work well, except that I need to assume <code>FullyFaithful</code> in many statements, which is a problem as it is a structure and not a class. I have a question about how to proceed with this, as I see 2 options (with a secret third option which is to not go ahead with the suggestion).</p>\n<ol>\n<li>Have <code>FullyFaithful</code> as an explicit parameter to the statements that need it. Then write a separate API in the case of yoneda which specializes these theorems (and hence does not force the user to explicitly provide this parameter). This feels somewhat awkward, but I have done this locally. Also, this would make relative representability more annoying to maintain, as one would often have to add 2 theorems each time one wants to add a theorem about relative representability which needs <code>FullyFaithful</code> (because in practice I think that people will just use the case of <code>yoneda</code> anyways).</li>\n<li>Use <code>[Full F]</code> and <code>[Faithful F]</code> as arguments instead. Then one would not need a new API in the case of yoneda. However, one loses the fact that <code>Yoneda.fullyFaithful</code> knows the explicit preimage, and not just the existence of one. This feels a lot cleaner, but maybe losing the knowledge of a specific preimage is too big of a sacrafice for maintainability and shorter code?</li>\n</ol>\n<p>What do people think about this?</p>",
        "id": 465378293,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1724749727
    },
    {
        "content": "<p>And actually, I am not very familiar with the new <code>FullyFaithful</code> changes, so maybe its not even a sacrafice to go with <code>[Full F]</code> and <code>[Faithful F]</code> as parameters.</p>",
        "id": 465380146,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1724750071
    },
    {
        "content": "<p>Using <code>Full </code> and <code>Faithful</code> seems better to me. <code>Functor.FullyFaithful</code> is more useful when we want to have good definitional properties, but in this situation, I do not think it matters very much.</p>",
        "id": 465415909,
        "sender_full_name": "Joël Riou",
        "timestamp": 1724757986
    }
]