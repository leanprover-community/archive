[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/16792\">#16792</a> we define <code>Derivation.liftOfRightInverse</code> and <code>Derivation.liftOfSurjective</code> for lifting a derivation <code>d</code> via a algebra homomorphism such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Ker</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>⊆</mo><mi mathvariant=\"normal\">Ker</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">d(\\operatorname{Ker}(f)) \\subseteq \\operatorname{Ker}(f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mop\"><span class=\"mord mathrm\">Ker</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Ker</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span>.<br>\nThis is blocking <a href=\"https://github.com/leanprover-community/mathlib4/pull/16797\">#16797</a>, the algebraic case of Liouville's theorem, so if anybody could take a look that'd be great.</p>",
        "id": 481549478,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731235125
    },
    {
        "content": "<p>Sorry, my github notifications are out of control right now. I now notice that you asked me a question last week. Yes, my concern was (other than the proofs looking very long) that your definition makes a random auxiliary choice (a section of a surjection) and there's no proof in the PR that the definition is independent of the surjection. Can you add a theorem saying that if <code>f_inv1</code> and <code>f_inv2</code> are two inverses for <code>f</code> then <code>liftOfRightInverse f f_inv1 h1 = liftOfRightInverse f f_inv2 h2</code>? I find it hard to believe that you won't need this at some point.</p>",
        "id": 481553665,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731238641
    },
    {
        "content": "<p>I never know whether it's worth golfing tiny proofs but lines like <code>rw [← sub_eq_zero, ← map_sub, ← map_sub]</code> usually make me think \"surely we can get automation to do this\". You wrote </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">map_add'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">map_add</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">sub_eq_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">map_sub</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">map_sub</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">hd</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>but I would write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">map_add'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">suffices</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f_inv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f_inv</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">f_inv</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">sub_eq_zero</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>it isolates the key intermediate goal and gets there more quickly so I feel like it's more readable. But this might just be a personal style preference.</p>",
        "id": 481554573,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731239468
    },
    {
        "content": "<p>Cleaned up the proofs and added the lemma. I don't actually need it, as <code>liftOfRightInverse_apply</code> implies it and is what I actually use</p>",
        "id": 481563841,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731246855
    },
    {
        "content": "<p>I don't think <code>liftOfRightInverse_apply</code> implies the lemma, for the following reason: you can imagine Lean's version of the axiom of choice as saying \"at the beginning of time, choose and fix a special element of every nonempty type\". When you apply this to splitting a surjective function you get \"the one-sided inverse which Lean chose at the beginning of time\", so you can't make any deductions about any of the other sections. But it's just my instinct saying that you'll need the lemma at some point, and obviously if you've proved something else without needing it then this is evidence that I'm wrong! I'm just saying that it was the first thing which popped into my head when I looked at the PR a couple of weeks ago. Thanks for adding it, even if it is just to shut me up :-) I'll take another look.</p>",
        "id": 481570453,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731251943
    },
    {
        "content": "<p>Since <code>f</code> is surjective it does imply it, as every <code>x</code> is some <code>f z</code>, and then the lemma applies to give the value <code>f (d z)</code> independently of which inverse function was chosen</p>",
        "id": 481575542,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731255707
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/16797\">#16797</a> is now ready for review, if anybody wants to take a look</p>",
        "id": 482201338,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731512287
    }
]