[
    {
        "content": "<p>This PR introduces a new Prop-valued mixin <code>ExistsAddOfLEOrGE</code> which states <code>(∀ a b, a ≤ b → ∃ c, b = a + c) ∨ ∀ a b, b ≤ a → ∃ c, b = a + c</code>.</p>",
        "id": 460079738,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723468201
    },
    {
        "content": "<p>This generalisation of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ExistsAddOfLE#doc\">docs#ExistsAddOfLE</a> (which states <code>∀ a b, b ≤ a → ∃ c, b = a + c</code>) is precisely the condition under which I can prove the binary rearrangement inequality (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_add_mul_le_mul_add_mul#doc\">docs#mul_add_mul_le_mul_add_mul</a>) and, importantly, <code>ExistsAddOfLEOrGE α</code> implies <code>ExistsAddOfLEOrGE αᵒᵈ</code> which means that I can dualise proofs that use binary rearrangement.</p>",
        "id": 460080016,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723468290
    },
    {
        "content": "<p>In contrast, <code>mul_add_mul_le_mul_add_mul</code> is currently stated using <code>ExistsAddOfLE</code>, and <code>ExistsAddOfLE α</code> does <strong>not</strong> imply <code>ExistsAddOfLE αᵒᵈ</code>, which means that any proof using it would have to be duplicated to be dualised.</p>",
        "id": 460080193,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723468350
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> has called my solution \"baroque\", but hopefully the explanation above gives enough context to see why it is the natural answer to my current problem?</p>",
        "id": 460080358,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723468425
    },
    {
        "content": "<p>I'm sorry if \"baroque\" was not a good way to express my objection, but I still think this is an unnatural notion that should not be part of our core hierarchy.</p>",
        "id": 460089122,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1723471347
    },
    {
        "content": "<p>Arguably, it's not going to be: There are no instances taking <code>ExistsAddOfLE</code> as an assumption (probably won't ever be), and only a handful of theorems will mention it (they are often later specialised to <code>ℝ</code>)</p>",
        "id": 460092780,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723472512
    },
    {
        "content": "<p>This \"handful of theorems\" however contains some 100 lines proofs which I would rather not repeat</p>",
        "id": 460092907,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723472549
    },
    {
        "content": "<p>I agree with Kim that this feels pretty unnatural; my hope is that there's some more natural notion that is  just as helpful for your situation?</p>",
        "id": 460094250,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723473001
    },
    {
        "content": "<p>I would like to agree, but that elusive more natural notion has eluded me so far. Here are three situations which I believe are representative of my use cases: <code>ℤ</code>, <code>ℕ</code>, <code>ℕᵒᵈ</code>.</p>",
        "id": 460095008,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723473232
    },
    {
        "content": "<p>And to be clear, what you want is a reversed version of <code>mul_add_mul_le_mul_add_mul</code> for when the inequalities in the assumptions are also reversed?</p>",
        "id": 460097469,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723474072
    },
    {
        "content": "<p>No, because that wouldn't hold. I can only reverse one of the assumptions (+ the goal), not both. What I want instead is a reversed version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=smul_add_smul_le_smul_add_smul#doc\">docs#smul_add_smul_le_smul_add_smul</a>, where the inequalities in <code>β</code> are reversed.</p>",
        "id": 460098040,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723474270
    },
    {
        "content": "<p>Can you give examples where the second alternative applies and </p>\n<ul>\n<li>either which are not order duals of cases where the first alternative applies?</li>\n<li>or which are indeed duals of such cases but where the statement appears naturally under this form?</li>\n</ul>",
        "id": 461034312,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1723486510
    },
    {
        "content": "<p>Sorry, what alternatives are you talking about, Antoine?</p>",
        "id": 462132360,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723559827
    },
    {
        "content": "<p>The RHS part of the OR in your ExistsAddOfLeOrGe</p>",
        "id": 462222660,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1723588466
    },
    {
        "content": "<p>I guess <code>ℕᵒᵈ</code> is an example?</p>",
        "id": 462285256,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1723621788
    },
    {
        "content": "<p>Would adding <code>ExistsAddOfGE</code> not work? Then <code>ExistsAddOfLE a &lt;-&gt; ExistsAddOfGE a\\od</code></p>",
        "id": 462287802,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723622615
    },
    {
        "content": "<p>Sure, but then you still can't have a unified statement of the theorem that <span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> wants. Unless the assumption becomes <code>ExistsAddOfLE \\or ExistsAddOfGE</code></p>",
        "id": 462288354,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1723622833
    },
    {
        "content": "<p>Is this equivalent to the binary rearrangement inequality, under the rest of the assumptions there?</p>",
        "id": 462292282,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723624300
    },
    {
        "content": "<p>The binary rearrangement inequality (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=smul_add_smul_le_smul_add_smul#doc\">docs#smul_add_smul_le_smul_add_smul</a>) is invariant under swapping the order on the right so, yes this equivalent is there, and it's the binary rearrangement inequality</p>",
        "id": 462292599,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723624419
    },
    {
        "content": "<p>I feel like this discussion is really arduous, which makes me think people haven't understood what I'm talking about. Here let me try to explain it differently</p>",
        "id": 462292869,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723624540
    },
    {
        "content": "<p>We have an inequality (<code>∀ (a₁ a₂ : α) (b₁ b₂ : β), a₁ ≤ a₂ → b₁ ≤ b₂ → a₁ • b₂ + a₂ • b₁ ≤ a₁ • b₁ + a₂ • b₂</code>) which, if true for <code>α</code> and <code>β</code>, is also true for <code>α</code> and <code>βᵒᵈ</code>.</p>",
        "id": 462293791,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723624778
    },
    {
        "content": "<p>I know how to prove this inequality under the assumptions <code>[OrderedRing α] [OrderedAddCommGroup β] [Module α β] [PosSMulMono α β]</code>. These assumptions holding for <code>α</code> and <code>β</code> <em>does</em> imply they hold for <code>α</code> and <code>βᵒᵈ</code></p>",
        "id": 462294065,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723624873
    },
    {
        "content": "<p><strong>However</strong>, these assumptions don't hold for eg <code>α := ℕ</code> (and any <code>β</code>), even though the inequality does hold in that case.</p>",
        "id": 462294647,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723625094
    },
    {
        "content": "<p>Hence I set out to generalise my proof of the inequality to the following set of assumptions: <code>[OrderedSemiring α] [ExistsAddOfLE α] [OrderedAddCommMonoid β] [Module α β] [PosSMulMono α β]</code></p>",
        "id": 462294798,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723625153
    },
    {
        "content": "<p>But now, these assumptions holding for <code>α</code> and <code>β</code> <em>does not</em> imply they hold for <code>α</code> and <code>βᵒᵈ</code></p>",
        "id": 462294904,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723625170
    },
    {
        "content": "<p>My proposal: Generalise the <code>[ExistsAddOfLE α]</code> assumption to a weaker <code>[ExistsAddOfLEOrGE α]</code> which is dualisable</p>",
        "id": 462295477,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723625279
    },
    {
        "content": "<p>Does it make more sense now?</p>",
        "id": 462295631,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723625300
    },
    {
        "content": "<p>I should add that the reason I care about being able to dualise my assumptions like this is that I use the self-dual (in <code>β</code>) inequality <code>∀ (a₁ a₂ : α) (b₁ b₂ : β), a₁ ≤ a₂ → b₁ ≤ b₂ → a₁ • b₂ + a₂ • b₁ ≤ a₁ • b₁ + a₂ • b₂</code> in proofs of inequalities which are not self-dual, eg <code>∀ (a₁ a₂ b₁ b₂ : α), a₁ ≤ a₂ → b₁ ≤ b₂ → a₁ * b₂ + a₂ * b₁ ≤ a₁ * b₁ + a₂ * b₂</code> (since now dualising involves all three of the conclusion and the two assumptions).</p>",
        "id": 462297141,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723625725
    },
    {
        "content": "<p>My question is then, for an <code>OrderedSemiring α</code>, does <code>ExistsAddOfLEOrGE α ↔ (∀ {β : Type*} [OrderedAddCommMonoid β] [Module α β] [PosSMulMono α β] (a₁ a₂ : α) (b₁ b₂ : β), a₁ ≤ a₂ → b₁ ≤ b₂ → a₁ • b₂ + a₂ • b₁ ≤ a₁ • b₁ + a₂ • b₂)</code> hold? If yes, I think this is fine to add. If not, I think it might be better to search for a more natural requirement on <code>α</code> which satisfies this</p>",
        "id": 462303498,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723627738
    },
    {
        "content": "<p>It most certainly isn't equivalent, no. But note that the way we use <code>ExistsAddOfLE</code> is to find an element <code>c</code> which acts like <code>a - b</code> (we don't have access to subtraction) and substitute <code>a = b + c</code>. <code>ExistsAddOfLE</code> gives us such a <code>c</code> when <code>b ≤ a</code>. The strategy also works if <code>b = a + c</code>, but <code>ExistsAddOfLE</code> doesn't help here.</p>",
        "id": 462304716,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723628201
    },
    {
        "content": "<p>In some sense, <code>ExistsAddOfLEOrGE</code> is the continuation of this strategy</p>",
        "id": 462304781,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723628236
    },
    {
        "content": "<p>Another option would be to use a <em>stronger</em> hypothesis on <code>α</code> saying something of the form <code>∀ a b, ∃ c, a = b + c ∨ b = a + c</code>. That would also work for my purposes, but technically dismisses things like <code>α := ℕ × ℕ</code> in my original inequality</p>",
        "id": 462304980,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723628313
    },
    {
        "content": "<p>Would <code>∀ a b, ∃ a' b', a + a' = b + b'</code> work?</p>",
        "id": 462306009,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723628741
    },
    {
        "content": "<p>That covers <code>α := ℕ × ℕ</code></p>",
        "id": 462306169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723628772
    },
    {
        "content": "<p>I don't see how, as you can't rewrite anything, and you can't do stuff like add <code>a₁' • b₁</code>, as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=le_of_add_le_add_left#doc\">docs#le_of_add_le_add_left</a> doesn't necessarily hold in a monoid</p>",
        "id": 462308108,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723629454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313950.20Dualisable.20notion.20of.20ExistsAddOfLE/near/462304716\">said</a>:</p>\n<blockquote>\n<p>It most certainly isn't equivalent, no. But note that the way we use <code>ExistsAddOfLE</code> is to find an element <code>c</code> which acts like <code>a - b</code> (we don't have access to subtraction) and substitute <code>a = b + c</code>. <code>ExistsAddOfLE</code> gives us such a <code>c</code> when <code>b ≤ a</code>. The strategy also works if <code>b = a + c</code>, but <code>ExistsAddOfLE</code> doesn't help here.</p>\n</blockquote>\n<p>I think it'll be good to figure out exactly what's the required condition on <code>α</code>. Do you have an example where <code>ExistsAddOfLEOrGE</code> doesn't hold but the binary rearrangement inequality does? It seems pretty close - if you have <code>a₁, a₂</code> for which neither <code>a₁ + c = a₂</code> or <code>a₂ + c = a₁</code> the module instance doesn't require almost any relation between <code>(a₁ • ·)</code> and <code>(a₂ • ·)</code>, right?</p>",
        "id": 462309185,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723629684
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313950.20Dualisable.20notion.20of.20ExistsAddOfLE/near/462308108\">said</a>:</p>\n<blockquote>\n<p>I don't see how, as you can't rewrite anything, and you can't do stuff like add <code>a₁' • b₁</code>, as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=le_of_add_le_add_left#doc\">docs#le_of_add_le_add_left</a> doesn't necessarily hold in a monoid</p>\n</blockquote>\n<p>I think requiring the ordered monoid to be cancellative is a fine assumption</p>",
        "id": 462309566,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723629814
    },
    {
        "content": "<p>Why do you need a multiplication on <code>α</code> and a module there? You only need the smul distributing on addition on both sides, don't you?</p>",
        "id": 462310815,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723630175
    },
    {
        "content": "<p>You are right, probably I don't. My current generalisation of binary rearrangement is in <a href=\"https://github.com/leanprover-community/mathlib4/pull/11448\">#11448</a></p>",
        "id": 462311396,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723630295
    },
    {
        "content": "<p>I see that the <code>ExistsAddOfLEOrGE</code> assumption is on <code>β</code>, not <code>α</code>, there</p>",
        "id": 462314585,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723631329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313950.20Dualisable.20notion.20of.20ExistsAddOfLE/near/462310815\">said</a>:</p>\n<blockquote>\n<p>Why do you need a multiplication on <code>α</code> and a module there? You only need the smul distributing on addition on both sides, don't you?</p>\n</blockquote>\n<p>I investigated this suggestion, and currently the weakest typeclass implying \"smul distributing on addition on both sides\" is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module#doc\">docs#Module</a>, which forces me to assume a multiplication on <code>α</code>.</p>",
        "id": 462346057,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723641898
    },
    {
        "content": "<p>There is another proof involving only one of the distributivity laws, but it requires <code>SMulPosMono α β</code> instead of <code>PosSMulMono α β</code>, and <code>SMulPosMono α β</code> only implies <code>SMulPosMono α βᵒᵈ</code> under the assumptions <code>[Preorder α] [Ring α] [OrderedAddCommGroup β] [Module α β]</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderDual.instSMulPosMono#doc\">docs#OrderDual.instSMulPosMono</a>) which are too strong for my purposes (and yet again involve multiplication on <code>α</code>.</p>",
        "id": 462346480,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723642027
    },
    {
        "content": "<p>Personally, I am fine with overassuming stuff about <code>α</code>. <code>β</code> is the one that matters in practice</p>",
        "id": 462346564,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723642062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313950.20Dualisable.20notion.20of.20ExistsAddOfLE/near/462306009\">said</a>:</p>\n<blockquote>\n<p>Would <code>∀ a b, ∃ a' b', a + a' = b + b'</code> work?</p>\n</blockquote>\n<p>I thought about this again: Isn't this condition vacuous as soon as addition is commutative?</p>",
        "id": 465016308,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724595021
    },
    {
        "content": "<p>This <span aria-label=\"wait one second\" class=\"emoji emoji-261d\" role=\"img\" title=\"wait one second\">:wait_one_second:</span> remark inspired me to get rid of the <code>ExistsAddOfLEOrGE</code> argument altogether. So I guess I don't need this new typeclass at all anymore</p>",
        "id": 465023218,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724599389
    }
]