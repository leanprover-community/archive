[
    {
        "content": "<p>PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/29639\">#29639</a> adds Euler's polyhedron formula (V - E  + F = 2) to Mathlib, completing Wiedijk theorem <a href=\"https://github.com/leanprover-community/mathlib4/pull/13\">#13</a>.</p>\n<p>The proof uses homological algebra: we construct a chain complex from a geometric polyhedron and show that acyclicity implies the Euler characteristic formula.</p>\n<p>The PR adds:</p>\n<p>- New module \\`Mathlib.Algebra.Homology.EulerPolyhedronFormula\\` with the main theorems<br>\n  - General telescoping sum theorem to <code>Finset.Basic</code><br>\n  - Chain complex Euler characteristic to <code>HomologicalComplex</code></p>\n<p>Would appreciate reviews, especially from folks familiar with homological algebra!</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/29639\">https://github.com/leanprover-community/mathlib4/pull/29639</a></p>",
        "id": 539404631,
        "sender_full_name": "Jesse Alama",
        "timestamp": 1757852762
    },
    {
        "content": "<p>according to CI, this doesn't even build</p>",
        "id": 539411080,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1757859046
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"754512\">Jesse Alama</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329639/near/539404631\">said</a>:</p>\n<blockquote>\n<p>PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/29639\">#29639</a> adds Euler's polyhedron formula (V - E  + F = 2) to Mathlib, completing Wiedijk theorem <a href=\"https://github.com/leanprover-community/mathlib4/pull/13\">#13</a>.</p>\n<p>The proof uses homological algebra: we construct a chain complex from a geometric polyhedron and show that acyclicity implies the Euler characteristic formula.</p>\n<p>The PR adds:</p>\n<p>- New module \\`Mathlib.Algebra.Homology.EulerPolyhedronFormula\\` with the main theorems<br>\n  - General telescoping sum theorem to <code>Finset.Basic</code><br>\n  - Chain complex Euler characteristic to <code>HomologicalComplex</code></p>\n<p>Would appreciate reviews, especially from folks familiar with homological algebra!</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/29639\">https://github.com/leanprover-community/mathlib4/pull/29639</a></p>\n</blockquote>\n<p>I've started working on splitting up the PR into a few chunks; <a href=\"https://github.com/leanprover-community/mathlib4/pull/29643\">#29643</a> is the first, containing a little telescoping sum result that is used at the end of the proof of Euler's polyhedron formula. I think it could be helpful in other settings, too. I was a bit surprised when I couldn't find this in Mathlib. There's a <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/BigOperators/Group/Finset/Basic.html#Finset.sum_range_tsub\">close analogue</a> that the telescoping we need is a bit more complicated than that.</p>",
        "id": 539413766,
        "sender_full_name": "Jesse Alama",
        "timestamp": 1757861844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329639/near/539411080\">said</a>:</p>\n<blockquote>\n<p>according to CI, this doesn't even build</p>\n</blockquote>\n<p>Yeah -- I screwed up a couple of things, but I pushed a fix that's currently building (and ought to cleanly build).</p>\n<p>(That said, this work will be broken up into a few smaller chunks, as requested.)</p>",
        "id": 539413878,
        "sender_full_name": "Jesse Alama",
        "timestamp": 1757861989
    },
    {
        "content": "<p>I am afraid there are several issues with this PR. First, it is not a proof of Theorem 13 <a href=\"https://www.cs.ru.nl/~freek/100/\">https://www.cs.ru.nl/~freek/100/</a> as it makes no connection between topology and combinatorics. Also, the definition of a polyhedron is wrong (it leads to a contradiction).</p>",
        "id": 539430393,
        "sender_full_name": "Joël Riou",
        "timestamp": 1757874788
    },
    {
        "content": "<p>Could you explain a little bit your process working with an AI?</p>",
        "id": 539430415,
        "sender_full_name": "Joël Riou",
        "timestamp": 1757874810
    },
    {
        "content": "<p>The usual principles of mathlib generality mean you should try to build an API for Euler's polyhedron formula that can be used in the different contexts people might want to use it in. For example, prove something about combinatorial maps, which have been discussed several times before for formalization of planar graphs, and something about actual drawings of maps in the plane as well as about polyhedra in three dimensions. (A fully general version with drawings of maps in the plane may depend on the Jordan curve theorem, but there should be meaningful versions e.g. for maps whose regions are convex that don't need the Jordan curve theorem.)</p>",
        "id": 539432157,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1757876411
    },
    {
        "content": "<p>Thanks for the feedback! This is my first Mathlib PR so I'm probably unintentionally getting a lot of things wrong.  Indeed, I've formulated Euler's polyhedron formula less as an API but as a theorem about chain complexes over (ZMod 2).  Indeed, I initially pursued a version of Euler's formula for combinatorial polyhedra (essentially just a list of finite incidence relations/binary matrices), with an exactness/acyclicity condition (thereby making them effectively geometric polyhedra, while still being ultimately combinatorial). But following this approach, I made a lot of progress but got stuck in a couple of key places, ultimately having to do with the non-equality of n and (n + 1) - 1 or (n - 1) + 1 and similar things, nested inside constructors for vector spaces (whose dimension is the cardinality of the face sets).  This brought me to the chain space, which indeed delivers on its promse to relieve the formalizer of a lot of dependent type problems, which I had encountered my fair share of! But it seems that I can do even better (thanks <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> ), so I'll cotinue iterating on this.</p>\n<p>I'd love to talk about the previous work on combinatorial maps, planar graphs, whether to embrace or avoid the Jordan curve theorem. Perhaps on the next Mathlib community call? Or maybe we can continue the discussion here or in another thread (if there's already one, please do let me know).</p>\n<p>My understanding was that a result about chain complexes would qualify as \"enough\" for a proof of Euler's polyhedron formula, at least in a first iteration. I'm aware that the theorem has different forms. One might say that if we don't see a theorem whose conclusion is V - E + F = 2,  we haven't done it. It depends on what one means by \"polyhedron\". Does the definition of polyhedron have to touch the real numbers or are we satisifed with a combinatorial approach? (I'm aware of realizability theorems that relate different approaches.)  I'm  chew on the idea of making an API for it.</p>",
        "id": 539436981,
        "sender_full_name": "Jesse Alama",
        "timestamp": 1757881422
    },
    {
        "content": "<p>Similarly to what <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> is suggesting in <a href=\"https://github.com/leanprover-community/mathlib4/pull/29713\">#29713</a>, I would think that what we should do, in order to have greater generality, is the following:</p>\n<ul>\n<li>\n<p>Given an abelian category <code>C</code> equipped with a function <code>χ : C → G</code> with <code>G</code> an abelian group, <code>ι</code> a type, and a function <code>ε : ι → ℤˣ</code>, define a map <code>GradedObject ι C → Finset ι → G</code> which would send a <code>X</code> to the sum of the <code>ε i • χ (X i)</code>. We may also define a map <code>GradedObject ι C → G</code> which would behave well when <code>X i</code> vanishes for all but finitely many indices <code>i</code>. (The better mathlib generality would be <code>G</code> an additive monoid equipped with <code>SMul R G</code> for some type <code>R</code>, and <code>ε : ι → R</code>.)</p>\n</li>\n<li>\n<p>Study how these definitions behave with respect to short exact sequences of graded objects under the assumption that <code>χ</code> is \"additive on short exact sequences\".</p>\n</li>\n<li>\n<p>When <code>c : ComplexShape ι</code> and <code>ε</code> satisfy <code>ε i = - ε j</code> when <code>c.Rel i j</code>, and <code>K : HomologicalComplex C c</code> we may apply the definitions above to <code>K.X</code> in order to get maps <code>HomologicalComplex C c → Finset ι → G</code> and <code>HomologicalComplex C c → G</code>. One may also apply the definitions above to the homology of <code>K</code> as a graded object. Then, we may analyse how this Euler characteristic of the homology behave with respect to short exact sequences of complexes, canonical, stupid truncations, etc.</p>\n</li>\n<li>\n<p>Under suitable (yet to be made more precise) assumptions, the Euler characteristic of the <code>K.X i</code> should coincide with the Euler characteristic of <code>K.homology i</code>.</p>\n</li>\n</ul>\n<p>These definitions could be applied to the universal map <code>χ</code> from <code>C</code> to its Grothendieck group, but in order to recover your lemmas, we may also apply it with <code>C</code> the category of finite dimensional vector spaces and <code>χ</code> is the dimension.</p>",
        "id": 539974949,
        "sender_full_name": "Joël Riou",
        "timestamp": 1758103395
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>, I'm tempted to suggest in this case that we don't insist this generality happens right away --- perhaps a link to this discussion (or a translation of some of it into a module doc) could suffice?</p>",
        "id": 540001295,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1758111927
    },
    {
        "content": "<p>Could you explain how you worked with AI?</p>",
        "id": 540002214,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758112160
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329639/near/540002214\">said</a>:</p>\n<blockquote>\n<p>Could you explain how you worked with AI?</p>\n</blockquote>\n<p>I used Claude Code to help me search through Mathlib, as well as suggest some proof sketches. I generaelly used it as a rubber duck on my desk, helping me to think through proof strategies, uncover invalid proof steps, and explain to me why I'm wrong, or reassure me that I haven't lost the thread and am still on track. I found it especially useful when thinking about boundary cases: \"Why is this result true when x = 0?\" At times, Claude also completed some proofs outright, though I often needed to clean them up. I also used it to explain Mathlib theorems and definitions in natural language.</p>\n<p>In additon to Claude, I also used <a href=\"http://leansearch.net\">leansearch.net</a>. Sometimes, when Claude was thinking out loud, I would take its output and give it to <a href=\"http://leansearch.net\">leansearch.net</a> to find a lemma or definition that would help get a proof over the finish line.</p>\n<p>In VS Code, I used GitHub Copilot a couple of times,  to (try to) fix up an incomplete proof or type error, but it often didn't work (though it did work sometimes, especially when working with casts).</p>",
        "id": 540028796,
        "sender_full_name": "Jesse Alama",
        "timestamp": 1758118969
    },
    {
        "content": "<p>More ambitiously, I've had some success with Claude Code helping me to generalize theorems. For instance, there was a request to generalize a result I'm working on from the natural numbers to the integers. Claude helped me do that generalization by finding relevant theorems, editing my theorems, lemmas, and proofs appropriately.</p>\n<p>A more down-to-earth use is to identify unused theorems, update names of theorems and definitions to match Mathlib conventions, and also lightly generalize two lemmas that are so similar that they can be put under a single \"umbrella\" lemma.</p>",
        "id": 540210415,
        "sender_full_name": "Jesse Alama",
        "timestamp": 1758195406
    },
    {
        "content": "<p>I wonder if I should close this PR, for now, to focus on <a href=\"https://github.com/leanprover-community/mathlib4/pull/29713\">#29713</a>. I'd base the Euler polyhedron formula contained here work on top of that PR, but it would require some non-trivial adaptation.I don't want to add any noise/spam to the review pipeline. On the other hand, it is marked as a draft. I'm not sure; let me know what you think.</p>",
        "id": 540211414,
        "sender_full_name": "Jesse Alama",
        "timestamp": 1758195730
    },
    {
        "content": "<p>I've closed the PR to focus on the Euler polyhedron formula, working on top of the Euler-Poincaré formula in <a href=\"https://github.com/leanprover-community/mathlib4/pull/29713\">#29713</a>.</p>",
        "id": 540389961,
        "sender_full_name": "Jesse Alama",
        "timestamp": 1758267065
    }
]