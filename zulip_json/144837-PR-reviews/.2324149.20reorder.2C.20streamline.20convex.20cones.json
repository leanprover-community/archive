[
    {
        "content": "<p>I would like to advertise <a href=\"https://github.com/leanprover-community/mathlib4/pull/24149\">#24149</a>, which is a medium-sized refactor redoing basically the whole cones library from scratch (it is currently not a bit library). The changes are motivated by the fact that Toric needs dual cones over perfectly paired vector spaces, while right now we only have <em>inner</em> dual cones in inner product spaces.</p>",
        "id": 513311970,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745187202
    },
    {
        "content": "<p>Since I spent so long writing the PR description, here it is again</p>",
        "id": 513311983,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745187217
    },
    {
        "content": "<p>The current library on cones is very centered around normed and Hilbert spaces.</p>\n<p>This is inconvenient for us in Toric where we have two spaces <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> that are non-canonically isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb R^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> (for the same <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>). Although we could identify <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb R^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> and get an inner product on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mi>N</mi><mo>=</mo><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">M = N = \\mathbb R^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> this way, we would lose the contravariance (resp. covariance) of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> (resp. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>) in the group scheme that indexes them.</p>\n<p>We would instead like to have results that apply to perfect pairings <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>:</mo><mi>M</mi><mo>‚Üí</mo><mi>N</mi><mo>‚Üí</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">p : M \\to N \\to \\mathbb R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> out of the box.</p>\n<p>Not all the theory can be generalised, of course. So, in terms of file structure, we need to draw the line somewhere. We propose to draw it at the import of <code>NormedAddCommGroup</code>, as this is the time where the scalars suddenly get fixed to the reals, instead of an arbitrary ordered ring. This line passes through individual files, which therefore need to be split.</p>\n<p>We operate this separation by moving the cone content that doesn't require a norm under a new folder <code>Geometry.Convex.Cone</code>. The content that does require it stays in <code>Analysis.Convex.Cone</code>. A similar operation could be performed for the rest of the <code>Analysis.Convex</code>, but it seems wiser to do so simultaneously with the convexity refactor.</p>\n<p>Changes performed include:</p>\n<ul>\n<li>Renaming the variable <code>ùïú</code> to <code>R</code> when it is merely a ring</li>\n<li>Splitting files according to normless normful parts</li>\n<li>Completing the existing APIs</li>\n<li>Redefining <code>ProperCone R M</code> as an <code>abbrev</code> for <code>ClosedSubmodule R‚â•0 M</code>, similarly to how <code>PointedCone R M</code> is an <code>abbrev</code> for <code>Submodule R‚â•0 M</code>.</li>\n<li>\n<p>Replacing the three dual cones definitions we have:</p>\n<ul>\n<li><code>Set.innerDualCone : Set H ‚Üí ConvexCone ‚Ñù H</code></li>\n<li><code>PointedCone.dual : PointedCone ‚Ñù H ‚Üí PointedCone ‚Ñù H</code></li>\n<li><code>ProperCone.dual : ProperCone ‚Ñù H ‚Üí ProperCone ‚Ñù H</code></li>\n</ul>\n<p>by three new ones:</p>\n<ul>\n<li><code>ConvexCone.innerDual : Set H ‚Üí ConvexCone ‚Ñù H</code></li>\n<li><code>PointedCone.innerDual : Set H ‚Üí PointedCone ‚Ñù H</code></li>\n<li><code>ProperCone.innerDual : Set H ‚Üí ProperCone ‚Ñù H</code></li>\n</ul>\n<p>and reuse the existing names for the dual cones coming from a perfect pairing <code>p : M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] R</code>:</p>\n<ul>\n<li><code>ConvexCone.dual : Set M ‚Üí ConvexCone R N</code></li>\n<li><code>PointedCone.innerDual : Set M ‚Üí PointedCone R N</code></li>\n<li><code>ProperCone.innerDual : Set M ‚Üí ProperCone R N</code></li>\n</ul>\n</li>\n</ul>",
        "id": 513311991,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745187222
    },
    {
        "content": "<p>Could this please move forward? There will be a long chain of PRs to be merged before <a href=\"https://github.com/leanprover-community/mathlib4/pull/24149\">#24149</a>, and the lemmas at the start of the chain have been idle for two weeks, ie</p>",
        "id": 516122469,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1746428955
    },
    {
        "content": "<ul>\n<li>feat: closed submodules <a href=\"https://github.com/leanprover-community/mathlib4/pull/24236\">#24236</a></li>\n</ul>",
        "id": 516122476,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1746428958
    },
    {
        "content": "<ul>\n<li>chore(Convex/Cone): move ConvexCone under Geometry <a href=\"https://github.com/leanprover-community/mathlib4/pull/24237\">#24237</a></li>\n</ul>",
        "id": 516122496,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1746428965
    },
    {
        "content": "<ul>\n<li>feat: continuous perfect pairings <a href=\"https://github.com/leanprover-community/mathlib4/pull/24304\">#24304</a></li>\n</ul>",
        "id": 516122501,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1746428967
    },
    {
        "content": "<p>Since this PR is a pretty big refactor, I'd personally like to see some evidence that this refactor is in fact useful for Toric (or at all) before aggressively pushing forward with it, particularly since it is \"redoing from scratch\". From looking at the discussion in <a class=\"stream\" data-stream-id=\"487278\" href=\"/#narrow/channel/487278-toric\">#toric</a>, it seems that it hasn't been battle-tested yet in that project. Do you have any examples of mathematically meaningful uses of the new API?</p>",
        "id": 516208720,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1746454257
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>, I am pushing this refactor through in PRs which should all be agreeable on their own. If that's not the case, I am explicitly flagging it.</p>",
        "id": 517336973,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1746950398
    },
    {
        "content": "<p>I would also like to note that the existing cone library is very small and, to the extent of my knowledge, hasn't been \"battle-tested\" either</p>",
        "id": 517337075,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1746950444
    },
    {
        "content": "<p>As for the mathematically meaningful uses of the new API, <span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> recently added the fact that <a href=\"https://github.com/YaelDillies/Toric/blob/master/Toric/Mathlib/Geometry/Convex/Cone/Polyhedral.lean#L54-L56\">the double dual of a polyhedral cone is itself</a>: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">IsPolyhedral</span><span class=\"bp\">.</span><span class=\"n\">dual_flip_dual</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PointedCone</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsPolyhedral</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">dual'</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dual'</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">C</span>\n</code></pre></div>",
        "id": 517337653,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1746950892
    },
    {
        "content": "<p>This <code>dual'</code> is <code>PointedCone.dual : (M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] R) ‚Üí Set M ‚Üí PointedCone R N</code> from <a href=\"https://github.com/leanprover-community/mathlib4/pull/24149\">#24149</a>. The existing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PointedCone.dual#doc\">docs#PointedCone.dual</a> has type <code>PointedCone ‚Ñù H ‚Üí PointedCone ‚Ñù H</code> where <code>InnerProductSpace ‚Ñù H</code> and cannot be used for several reasons:</p>\n<ol>\n<li>It takes in a pointed cone, rather than a set.</li>\n<li>It requires an inner product, and the source and target spaces are the same, rather than being related via a bilinear pairing.</li>\n</ol>",
        "id": 517337804,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1746951006
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2324149.20reorder.2C.20streamline.20convex.20cones/near/517337075\">said</a>:</p>\n<blockquote>\n<p>I would also like to note that the existing cone library is very small and, to the extent of my knowledge, hasn't been \"battle-tested\" either</p>\n</blockquote>\n<p>I don't agree with this - the cone library currently is well over a thousand lines of code, and gets imported for Bochner integrals, the Radon-Nikodym theorem, and got imported in LTE. To me, these are signs that some properties of the current API should be kept (but I don't disagree that it could be improved :) )</p>",
        "id": 517878234,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1747154575
    },
    {
        "content": "<p>Whatever the fate of the toric project, the general way to study cone duality is via a (not necessarily perfect) pairing over an ordered field. This has implications for model theory, in linear programming, tropical geometry, etc.</p>",
        "id": 517989142,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1747207516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2324149.20reorder.2C.20streamline.20convex.20cones/near/517878234\">said</a>:</p>\n<blockquote>\n<p>I don't agree with this - the cone library currently is well over a thousand lines of code, and gets imported for Bochner integrals, the Radon-Nikodym theorem, and got imported in LTE.</p>\n</blockquote>\n<p>Can you clarify? <code>PointedCone</code> and <code>ProperCone</code> never appear outside the cone library, and <code>ConvexCone</code> appears exactly once outside, namely in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=riesz_extension#doc\">docs#riesz_extension</a>, which is itself used exactly once in the next result down the file, ie <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=exists_extension_of_le_sublinear#doc\">docs#exists_extension_of_le_sublinear</a>. I do agree cones got used in LTE, but IIRC a lot of convexity results were bypassed there anyway, so I don't think this counts as \"battle-testing\" either.</p>",
        "id": 518031126,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1747219584
    },
    {
        "content": "<p>Regardless, I have provided you with a mathematically meaningful result that cannot be stated before the series of PRs, and can be stated after. What else do you want?</p>",
        "id": 518031241,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1747219627
    },
    {
        "content": "<p>Another result that's possible to prove after <a href=\"https://github.com/leanprover-community/mathlib4/pull/24149\">#24149</a> and not before is that (continuous) cone duality holds in any locally convex real vector space, rather than merely Hilbert spaces</p>",
        "id": 518043410,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1747223234
    }
]