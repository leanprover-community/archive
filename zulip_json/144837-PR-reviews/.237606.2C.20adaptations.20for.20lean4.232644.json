[
    {
        "content": "<p>I have just finished going through <a href=\"https://github.com/leanprover-community/mathlib4/pull/7606\">#7606</a>, a large PR containing adaptations for <a href=\"https://github.com/leanprover/lean4/pull/2644\">lean4#2644</a>. Thanks very much to <span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span> and <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> for lots of work fixing this up and understanding the problems.</p>",
        "id": 396791093,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697413388
    },
    {
        "content": "<p>The underlying issue here is that there was a bug in the <code>IsDefEq</code> cache in Lean 4, which resulted in some <code>IsDefEq</code> calculations at <code>transparency := .default</code> being cached and reused at <code>transparency := .reducible</code>. This means that more things were identified as defeq than should have been (of course, they still really were defeq, just it should have required a different calculation to discover this).</p>",
        "id": 396791096,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697413394
    },
    {
        "content": "<p>It turns out the Mathlib has been extensively taking advantage of this, and so both <code>simp</code> and <code>rw</code> were \"over-powered\" relative to what they should have been, particularly in cases where we are \"abusing\" defeq. I know people are going to be sad to hear that we've been cheating and in fact <code>simp</code> and <code>rw</code> are not meant to be doing some of the things we've been using them to do, but I think we're all pretty confident that this will be an improvement in the long run.</p>",
        "id": 396791100,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697413398
    },
    {
        "content": "<p>The Lean4 PR that identified and fixed this issue, <a href=\"https://github.com/leanprover/lean4/pull/2644\">lean4#2644</a>, also brings a massive speedup to Mathlib -- I think more than 15%. So that's the silver lining. :-)</p>",
        "id": 396791103,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697413403
    },
    {
        "content": "<p>This PR has already hit Lean4 master, and hopefully over the next few hours I will be cutting a new release candidate and bringing lots of goodies to Mathlib (by popular demand!)</p>",
        "id": 396791107,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697413408
    },
    {
        "content": "<p>The current situation in <a href=\"https://github.com/leanprover-community/mathlib4/pull/7606\">#7606</a> is that we have not attempted to address the <em>many</em> cases of defeq abuse in Mathlib that are now showing up. Nearly all the Mathlib regressions are of the form:</p>\n<ul>\n<li><code>simp</code> will no longer use a lemma, and you need to use <code>erw</code> for it instead</li>\n<li>similarly for <code>rw</code> -&gt; <code>erw</code></li>\n<li>The <code>simpNF</code> linter now correctly identifies that a lemma is bad, where before it was silent<ul>\n<li>Many of these lemmas are generated by <code>simps</code>, and we are hopefully that these can be fixed all in one go, see <a href=\"https://github.com/leanprover-community/mathlib4/pull/7657\">#7657</a>.</li>\n</ul>\n</li>\n</ul>",
        "id": 396791109,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697413412
    },
    {
        "content": "<p>All of these regressions have now been labelled as resulting from <a href=\"https://github.com/leanprover/lean4/pull/2644\">lean4#2644</a> (although, as per above, it's better to think of this as Mathlib's fault, but Lean was allowing us to cheat a bit).</p>",
        "id": 396791111,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697413416
    },
    {
        "content": "<p>It's going to be a big cleanup job to sort this all out. We'll need to work out how to \"entice\" contributors into doing so!</p>",
        "id": 396791115,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697413420
    },
    {
        "content": "<p>But the main point of this message is: I'm now happy with <a href=\"https://github.com/leanprover-community/mathlib4/pull/7606\">#7606</a>, and am off to starting creating a new release, so if there's anything you'd like to add or modify in it, please do so ASAP! Because I would like to merge it into <code>master</code> as soon as the relevant release toolchain is ready. (Probably +4 hours or so?)</p>",
        "id": 396791117,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697413421
    },
    {
        "content": "<p>Does this fix <a href=\"https://github.com/leanprover/lean4/pull/2461\">lean4#2461</a> as well? </p>\n<p>Second question: is one reason that simp sometimes fails in lean 4 but worked in lean 3 because lean 3 also had this <del>feature</del>bug?</p>",
        "id": 396821069,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697430974
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, the code example in your <a href=\"https://github.com/leanprover/lean4/pull/2461\">lean4#2461</a> is a bit unhelpful. Ideally code examples in issues should fail, demonstrating the issue, and the succeed if someone fixes them! I <strong>think</strong> your example is the opposite?</p>",
        "id": 396821861,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697431544
    },
    {
        "content": "<p>Comment out <code>fail_if_success</code> to see reasonable-looking code not work.</p>",
        "id": 396822742,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697432121
    },
    {
        "content": "<p>Yes. My point is that whenever you use <code>fail_if_success</code> in an issue report, it probably deserves a clear comment immediately adjacent saying whether you do or do not want the failure.</p>",
        "id": 396828755,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697436181
    },
    {
        "content": "<p>My recommendation is to write MWEs such that they are actually failing while the issue in question exists (which I guess is the same thing Scott said)</p>",
        "id": 396828977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697436312
    },
    {
        "content": "<p>I see. Thanks! Would you like me to edit the issue? Or feel free to do this yourself?</p>",
        "id": 396832335,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697438127
    },
    {
        "content": "<p>This doesn't make <code>simp</code> behave more like lean 3 <code>simp</code> so won't do what you want here <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>.  It does supercharge lean 4 <code>simp</code> as evidenced by all the new failures of the linter.</p>",
        "id": 396906156,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1697463781
    },
    {
        "content": "<p>Before I got pulled away I was experimenting with keeping <code>def</code>'s and cleaning up API boundaries but that was quickly thwarted by the behavior of <code>cases</code> <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/cases.20exposes.20type\">#mathlib4 &gt; cases exposes type</a></p>",
        "id": 396906522,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1697463894
    },
    {
        "content": "<p>Are we using <code>cases</code> wrong?</p>",
        "id": 396908596,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1697464499
    },
    {
        "content": "<p>When should <code>X =?= op X.unop</code> fail?</p>",
        "id": 397565918,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1697744112
    },
    {
        "content": "<blockquote>\n<p>Now that Lean 4 supports definitional eta equality for records,<br>\n  both <code>unop (op X) = X</code> and <code>op (unop X) = X</code> are definitional equalities.</p>\n</blockquote>\n<p>from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Opposite#doc\">docs#Opposite</a></p>",
        "id": 397566623,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1697744453
    },
    {
        "content": "<p>Maybe during typeclass search where they need to be reducibly defeq?</p>",
        "id": 397570470,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697746168
    },
    {
        "content": "<p>What's the context of the question?</p>",
        "id": 397570496,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697746182
    },
    {
        "content": "<p>Failures of <code>rw</code> after <a href=\"https://github.com/leanprover/lean4/pull/2644\">lean4#2644</a></p>",
        "id": 397570577,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1697746208
    },
    {
        "content": "<p>The first example I dug into had <code> ❌ X =?= Opposite.op X.unop </code></p>",
        "id": 397570721,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1697746284
    },
    {
        "content": "<p>It looks like <a href=\"https://github.com/leanprover-community/mathlib4/blob/29fc60fc4b560bab33577a74af62a32c5e415c4e/Mathlib/CategoryTheory/Limits/Presheaf.lean#L463\">this</a> is purely unification.</p>",
        "id": 397574693,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1697748264
    },
    {
        "content": "<p>What's the implicit argument to <code>.op</code>?</p>",
        "id": 397575402,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697748599
    },
    {
        "content": "<p>(or for that matter, <code>.unop</code>)</p>",
        "id": 397575472,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697748617
    },
    {
        "content": "<p><code>C : Type u1</code></p>",
        "id": 397575564,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1697748659
    },
    {
        "content": "<p>Here is the trace</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.isDefEq</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">s.pt.map</span> <span class=\"n\">f</span>\n      <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">CategoryTheory.yonedaEquiv</span>\n        <span class=\"o\">(</span><span class=\"n\">s.ι.app</span>\n          <span class=\"o\">(</span><span class=\"n\">CategoryTheory.CostructuredArrow.mk</span>\n            <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">CategoryTheory.yonedaEquiv.symm</span> <span class=\"n\">t</span><span class=\"o\">))))</span> <span class=\"bp\">=?=</span> <span class=\"bp\">?</span><span class=\"n\">m.122621.map</span> <span class=\"bp\">?</span><span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">CategoryTheory.yonedaEquiv</span> <span class=\"bp\">?</span><span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n  <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"n\">s.pt.toPrefunctor</span> <span class=\"bp\">=?=</span> <span class=\"bp\">?</span><span class=\"n\">m.122621.toPrefunctor</span> <span class=\"bp\">▶</span>\n  <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"n\">X</span> <span class=\"bp\">=?=</span> <span class=\"bp\">?</span><span class=\"n\">m.122619</span> <span class=\"bp\">▶</span>\n  <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"n\">Y</span> <span class=\"bp\">=?=</span> <span class=\"bp\">?</span><span class=\"n\">m.122620</span> <span class=\"bp\">▶</span>\n  <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"n\">f</span> <span class=\"bp\">=?=</span> <span class=\"bp\">?</span><span class=\"n\">g</span> <span class=\"bp\">▶</span>\n  <span class=\"o\">[]</span> <span class=\"bp\">❌</span> <span class=\"bp\">↑</span><span class=\"n\">CategoryTheory.yonedaEquiv</span>\n        <span class=\"o\">(</span><span class=\"n\">s.ι.app</span>\n          <span class=\"o\">(</span><span class=\"n\">CategoryTheory.CostructuredArrow.mk</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">CategoryTheory.yonedaEquiv.symm</span> <span class=\"n\">t</span><span class=\"o\">)))</span> <span class=\"bp\">=?=</span> <span class=\"bp\">↑</span><span class=\"n\">CategoryTheory.yonedaEquiv</span> <span class=\"bp\">?</span><span class=\"n\">f</span> <span class=\"bp\">▼</span>\n    <span class=\"o\">[]</span> <span class=\"n\">found</span> <span class=\"n\">messy</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">s.pt.obj</span> <span class=\"n\">X</span> <span class=\"bp\">=?=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">s.pt.obj</span> <span class=\"o\">(</span><span class=\"n\">Opposite.op</span> <span class=\"n\">X.unop</span><span class=\"o\">))</span> <span class=\"n\">a</span>\n    <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"n\">CategoryTheory.yonedaEquiv</span> <span class=\"bp\">=?=</span> <span class=\"n\">CategoryTheory.yonedaEquiv</span>\n    <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"n\">s.ι.app</span> <span class=\"o\">(</span><span class=\"n\">CategoryTheory.CostructuredArrow.mk</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">CategoryTheory.yonedaEquiv.symm</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"bp\">=?=</span> <span class=\"bp\">?</span><span class=\"n\">f</span> <span class=\"bp\">▶</span>\n    <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"o\">(</span><span class=\"n\">CategoryTheory.yoneda.obj</span> <span class=\"n\">X.unop</span> <span class=\"bp\">⟶</span> <span class=\"n\">s.pt</span><span class=\"o\">)</span> <span class=\"bp\">≃</span>\n          <span class=\"n\">s.pt.obj</span> <span class=\"n\">X</span> <span class=\"bp\">=?=</span> <span class=\"o\">(</span><span class=\"n\">CategoryTheory.yoneda.obj</span> <span class=\"n\">X.unop</span> <span class=\"bp\">⟶</span> <span class=\"n\">s.pt</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">s.pt.obj</span> <span class=\"o\">(</span><span class=\"n\">Opposite.op</span> <span class=\"n\">X.unop</span><span class=\"o\">)</span> <span class=\"bp\">▶</span>\n    <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"n\">CategoryTheory.yoneda.obj</span> <span class=\"n\">X.unop</span> <span class=\"bp\">⟶</span> <span class=\"n\">s.pt</span> <span class=\"bp\">=?=</span> <span class=\"n\">CategoryTheory.yoneda.obj</span> <span class=\"n\">X.unop</span> <span class=\"bp\">⟶</span> <span class=\"n\">s.pt</span>\n    <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"n\">Equiv.instFunLikeEquiv</span> <span class=\"bp\">=?=</span> <span class=\"n\">Equiv.instFunLikeEquiv</span> <span class=\"bp\">▶</span>\n    <span class=\"o\">[]</span> <span class=\"bp\">❌</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">s.pt.obj</span> <span class=\"n\">X</span> <span class=\"bp\">=?=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">s.pt.obj</span> <span class=\"o\">(</span><span class=\"n\">Opposite.op</span> <span class=\"n\">X.unop</span><span class=\"o\">))</span> <span class=\"n\">a</span> <span class=\"bp\">▼</span>\n      <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"n\">CategoryTheory.yoneda.obj</span> <span class=\"n\">X.unop</span> <span class=\"bp\">⟶</span> <span class=\"n\">s.pt</span> <span class=\"bp\">=?=</span> <span class=\"n\">CategoryTheory.yoneda.obj</span> <span class=\"n\">X.unop</span> <span class=\"bp\">⟶</span> <span class=\"n\">s.pt</span>\n      <span class=\"o\">[]</span> <span class=\"bp\">❌</span> <span class=\"n\">s.pt.obj</span> <span class=\"n\">X</span> <span class=\"bp\">=?=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">s.pt.obj</span> <span class=\"o\">(</span><span class=\"n\">Opposite.op</span> <span class=\"n\">X.unop</span><span class=\"o\">))</span> <span class=\"n\">a</span> <span class=\"bp\">▼</span>\n        <span class=\"o\">[]</span> <span class=\"bp\">❌</span> <span class=\"n\">s.pt.obj</span> <span class=\"n\">X</span> <span class=\"bp\">=?=</span> <span class=\"n\">s.pt.obj</span> <span class=\"o\">(</span><span class=\"n\">Opposite.op</span> <span class=\"n\">X.unop</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n          <span class=\"o\">[]</span> <span class=\"bp\">❌</span> <span class=\"n\">s.pt.toPrefunctor.1</span> <span class=\"n\">X</span> <span class=\"bp\">=?=</span> <span class=\"n\">s.pt.toPrefunctor.1</span> <span class=\"o\">(</span><span class=\"n\">Opposite.op</span> <span class=\"n\">X.unop</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n            <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"n\">s.pt.toPrefunctor.1</span> <span class=\"bp\">=?=</span> <span class=\"n\">s.pt.toPrefunctor.1</span>\n            <span class=\"o\">[]</span> <span class=\"bp\">❌</span> <span class=\"n\">X</span> <span class=\"bp\">=?=</span> <span class=\"n\">Opposite.op</span> <span class=\"n\">X.unop</span> <span class=\"bp\">▼</span>\n              <span class=\"o\">[</span><span class=\"n\">onFailure</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">X</span> <span class=\"bp\">=?=</span> <span class=\"n\">Opposite.op</span> <span class=\"n\">X.unop</span>\n</code></pre></div>",
        "id": 397575994,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1697748851
    },
    {
        "content": "<p>is it maybe a case of reducibility?</p>",
        "id": 397585377,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1697754131
    },
    {
        "content": "<p>How does one tell the reducibility level in a trace like that?</p>",
        "id": 397587725,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697755766
    },
    {
        "content": "<p>Yeah, it’s not unfolding <code>op</code> like it does elsewhere in the trace. So I guess the transparency must be <code>.reducible</code> there.</p>",
        "id": 397594892,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1697760504
    },
    {
        "content": "<p>Heh, so the answer to my question is \"you can tell what the transparency is by what happens\" :-)</p>",
        "id": 397629606,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697778010
    },
    {
        "content": "<p><a href=\"https://gist.github.com/mattrobball/562fbecd8ae34624f556db9ebf99c31d\">Minimized</a></p>",
        "id": 397706919,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1697807522
    }
]