[
    {
        "content": "<p>I don't know if there is general interest in <code>RevLex</code>, but I would like to use it to compare coefficients between elements of <code>V((X))((Y))</code> and <code>V((Y))((X))</code>, where <code>V</code> is a vector space, and <code>-((X))</code> denotes taking Laurent series with specified coefficients.</p>\n<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/24690\">#24690</a> I chose to write the type synonym using a one-field structure (mostly to make defeq abuse harder), but I don't know what disadvantages that has over <code>def</code> (which is how <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lex#doc\">docs#Lex</a> is implemented).</p>\n<p>Does anyone have opinions about implementation? Should I move the definition to <code>Mathlib.Order.Synonym</code> to be with <code>Lex</code>?</p>",
        "id": 519496856,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1747788220
    },
    {
        "content": "<p>How does this relate to <code>OrderDual (Lex A B)</code>?</p>",
        "id": 519505740,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747793568
    },
    {
        "content": "<p>I see:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">LexEquiv</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×ₗ</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">×ᵣ</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>",
        "id": 519507711,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747794725
    },
    {
        "content": "<p>I have a broken PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/19456\">#19456</a> where I tried to implement the degrevlex monomial order on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp#doc\">docs#Finsupp</a>. I have something such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- `Finsupp.DegRevLex r s` is the homogeneous reverse lexicographic order on `α →₀ M`,</span>\n<span class=\"sd\">where `α` is ordered by `r` and `M` is ordered by `s`.</span>\n<span class=\"sd\">The type synonym `DegRevLex (α →₀ M)` has an order given by `Finsupp.DegRevLex (· &lt; ·) (· &lt; ·)`. -/</span>\n<span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">DegRevLex</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→₀</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→₀</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">Lex</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">swap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">Lex</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">swap</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">degree</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 520203644,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1748097861
    }
]