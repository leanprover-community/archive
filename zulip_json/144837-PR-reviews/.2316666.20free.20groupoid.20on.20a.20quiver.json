[
    {
        "content": "<p>Hey, could I get some feedback on this PR? It's still WIP, since there are a few things I'm not totally sure about:</p>\n<ul>\n<li>I've added lemmas in <code>category_theory/quiver.lean</code> to deal with inverses, since using the <code>is_iso.…</code> version didn't seem to work easily, so I thought I might as well add them directly.</li>\n<li>I'm using \"on the nose\" extensionality of functors/prefunctors, which <code>mathlib</code> doesn't provide.</li>\n<li>My construction for <code>words</code> is perhaps not ideal (instead, should I rely on <code>quiver.symmetrify</code>?)</li>\n</ul>\n<p>Thanks!</p>",
        "id": 300383557,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1663944649
    },
    {
        "content": "<p>It seems that the groupoid on a quiver Q is a particular case of a localized category <a href=\"https://leanprover-community.github.io/mathlib_docs/category_theory/localization/construction.html\">https://leanprover-community.github.io/mathlib_docs/category_theory/localization/construction.html</a>. It might be better to use this construction rather than redoing a variant of it.  More precisely, one may construct a groupoid from a category by formally inverting all the maps. Then the groupoid on a quiver <code>Q</code> seems to be the groupoid obtained by inverting all the maps in the path category of <code>Q</code>. I would suggest defining it this like.</p>\n<p>I am currently developing the API for localized categories (I have a draft for everything that is mentioned in the TODO in the link above, and much more including a predicate for a functor to be a localization with respect to a class for morphisms, compatibilities with opposite categories, adjunctions, product categories, existence of finite products in some localized categories, etc). I do not think that two separate API are necessary.</p>",
        "id": 300674806,
        "sender_full_name": "Joël Riou",
        "timestamp": 1664127313
    },
    {
        "content": "<p>Thanks for that link. <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> also proposed that. It's kind of frustrating: I spent the day trying to reimplement the free groupoid using path symmetrization of a quiver, path categories and quotient <a href=\"https://github.com/leanprover-community/mathlib/compare/bottine/free_groupoid_cats?expand=1\">here</a>, so now I'll start again with a third approach!</p>",
        "id": 300675433,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1664127746
    },
    {
        "content": "<p>But I agree the localization probably provides the fastest path to a working implementation, so I'll work with that.</p>",
        "id": 300675480,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1664127786
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2316611.20free.20groupoid.20on.20a.20quiver/near/300674806\">said</a>:</p>\n<blockquote>\n<p>I am currently developing the API for localized categories (I have a draft for everything that is mentioned in the TODO in the link above, and much more including a predicate for a functor to be a localization with respect to a class for morphisms, compatibilities with opposite categories, adjunctions, product categories, existence of finite products in some localized categories, etc). I do not think that two separate API are necessary.</p>\n</blockquote>\n<p>Looks fantastic! Are you gonna add <a href=\"https://ncatlab.org/nlab/show/calculus+of+fractions\">calculus of fractions</a> too? It's actually in the title of the reference you use :)</p>\n<p>Unfortuantely no general APIs seem to help to obtain the explicit description of the morphisms in the free groupoid as reduced words/paths, which I was discussing with <span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> in PM. Looks like we need to duplicate some work around <a href=\"https://leanprover-community.github.io/mathlib_docs/find/free_group.to_word\">docs#free_group.to_word</a> if we want that. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quiver.has_reverse\">docs#quiver.has_reverse</a> seems to be the right setting to define reduced paths in the groupoid setting.</p>",
        "id": 300676969,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1664128822
    },
    {
        "content": "<p>Yes, I also have left/right calculus of fractions... Ok, then, your approach <span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> should be mostly ok. Indeed, the only way I know how to compute precisely morphisms in localized categories is by obtaining a strict universal property, like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">strict_universal_property_fixed_target</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">morphism_property</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">inverts</span> <span class=\"o\">:</span> <span class=\"n\">W.is_inverted_by</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lift</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">W.is_inverted_by</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"n\">D</span> <span class=\"bp\">⥤</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">fac</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">W.is_inverted_by</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"n\">L</span> <span class=\"bp\">⋙</span> <span class=\"n\">lift</span> <span class=\"n\">F</span> <span class=\"n\">hF</span> <span class=\"bp\">=</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">uniq</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">F₁</span> <span class=\"n\">F₂</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">⥤</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">⋙</span> <span class=\"n\">F₁</span> <span class=\"bp\">=</span> <span class=\"n\">L</span> <span class=\"bp\">⋙</span> <span class=\"n\">F₂</span><span class=\"o\">),</span> <span class=\"n\">F₁</span> <span class=\"bp\">=</span> <span class=\"n\">F₂</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Then, once we have a solution to this universal property, with a certain description of morphisms in this category, one may state a more general result saying that any localization functor for <code>W</code> will have the same property. This is the way I have done computations of morphisms when there is left or right calculus of fractions, and obtained the fundamental lemma of homotopical algebra.</p>",
        "id": 300678024,
        "sender_full_name": "Joël Riou",
        "timestamp": 1664129587
    },
    {
        "content": "<p>So you'd say it's not worth using localization because I can't easily deal with words? Isn't it just a matter of taking representatives in the path category I'm taking the localization of?</p>",
        "id": 300722239,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1664171907
    },
    {
        "content": "<p>I am saying that this fits into the framework of localization, but your construction is relevant. I would only suggest that the universal property be stated as they appear in the fields of <code>strict_universal_property_fixed_target</code> above (not yet in mathlib), i.e. a functor from the path category of a quiver to any category which inverts all maps lifts in a unique way. Then, you may deduce the universal property as you stated it (when the target category is a groupoid, the functor must invert all maps!). Eventually, when the API for localization of categories enters mathlib, an instance saying that the functor above is a localization can be added.</p>",
        "id": 300735628,
        "sender_full_name": "Joël Riou",
        "timestamp": 1664178952
    },
    {
        "content": "<p>OK, I've finished a sorry-less version using path categories and quotients: would welcome some feedback <a href=\"https://github.com/leanprover-community/mathlib/compare/bottine/free_groupoid_cats?expand=1\">here</a></p>",
        "id": 300804720,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1664195979
    },
    {
        "content": "<p>And I opened a PR <a href=\"https://github.com/leanprover-community/mathlib/pull/16666/files\">here</a></p>",
        "id": 300944905,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1664259858
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> Thanks for your suggestions! I don't expect that the whole of it, is it?</p>",
        "id": 301772925,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1664604451
    },
    {
        "content": "<p>My main other remark is about the three universal properties that are in the PR:<br>\n1) Lifting of prefunctor from a quiver to a category as functors from the path category<br>\n2) Lifting of prefunctors to get functors from <code>quiver.symmetrify</code><br>\n3) Lifting of prefunctors from a quiver to a groupoid as functors from the free groupoid</p>\n<p>I would think that 3) should be first stated as<br>\n3') Lifting of prefunctors from a quiver to a category (which sends maps to invertible maps) as functors from the free groupoid</p>\n<p>Then 3) would a particular case of 3'). (Thanks to the class inference system, if the assumption is phrased as <code>[∀ (X Y) (f : X ⟶ Y), is_iso (φ.map f)]</code> in 3'), then you do not even need to restate 3).)</p>",
        "id": 301781785,
        "sender_full_name": "Joël Riou",
        "timestamp": 1664611019
    },
    {
        "content": "<p>Ah, that's a good point. Let me try and do that, thanks!</p>",
        "id": 301783527,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1664611984
    },
    {
        "content": "<p>In the meantime, <a href=\"https://github.com/leanprover-community/mathlib/pull/16742\">here</a> is a PR for subgroupoids. I feel like it's patterned closely enough on other files to be OK, but maybe not</p>",
        "id": 301790740,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1664616006
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2316666.20free.20groupoid.20on.20a.20quiver/near/301781785\">said</a>:</p>\n<blockquote>\n<p>My main other remark is about the three universal properties that are in the PR:<br>\n1) Lifting of prefunctor from a quiver to a category as functors from the path category<br>\n2) Lifting of prefunctors to get functors from <code>quiver.symmetrify</code><br>\n3) Lifting of prefunctors from a quiver to a groupoid as functors from the free groupoid</p>\n<p>I would think that 3) should be first stated as<br>\n3') Lifting of prefunctors from a quiver to a category (which sends maps to invertible maps) as functors from the free groupoid</p>\n<p>Then 3) would a particular case of 3'). (Thanks to the class inference system, if the assumption is phrased as <code>[∀ (X Y) (f : X ⟶ Y), is_iso (φ.map f)]</code> in 3'), then you do not even need to restate 3).)</p>\n</blockquote>\n<p>Mmh, the problem is that this actually implies also changing 1), since for now the lift to <code>symmetrify</code> assumes all arrows have \"formal\" inverses, which in turns means I can't use <code>has_reverse</code> at all… </p>\n<p>Sort of a pickle: I wonder if this changes is worth overhauling the whole <code>has_reverse</code> usage. Maybe a more compatible approach would be to reverse your argument and simply prove that if I have a functor mapping arrows to invertible ones, I can restrict to the core of the category… hence no need to change my code, but only to add stuff.<br>\nWhat do you think of that?</p>",
        "id": 301792503,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1664616977
    },
    {
        "content": "<p>Ok, so it is not as immediate as I thought, so that it may certainly be done later, in a separate PR.</p>",
        "id": 301874310,
        "sender_full_name": "Joël Riou",
        "timestamp": 1664665316
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2316666.20free.20groupoid.20on.20a.20quiver/near/301874310\">said</a>:</p>\n<blockquote>\n<p>Ok, so it is not as immediate as I thought, so that it may certainly be done later, in a separate PR.</p>\n</blockquote>\n<p>Alright! Well, then I need to find someone with \"bors\"-rights to review and hopefully accept it then.<br>\nBy the way, I'd like to refactor the <code>quiver</code> part at some point, to get stuff about <code>symmetrify</code> and <code>paths</code> and reversal and reduction of paths in a common file, rather than abusing <code>connected_component</code>, but I think for now it's fine.</p>",
        "id": 301899403,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1664694005
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> Thanks for the PR!<br>\n<span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> Thanks for the reviews!</p>\n<p>I've kicked it on the queue.</p>",
        "id": 302006830,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1664779744
    },
    {
        "content": "<p>(first PR not entirely overhauled by Kyle, I'm overly proud)</p>",
        "id": 302007703,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1664780258
    }
]