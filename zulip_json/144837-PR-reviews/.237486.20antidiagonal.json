[
    {
        "content": "<p>Let <code>n : μ</code>, where <code>μ</code> is a canonically ordered add monoid with locally finite order.</p>\n<p>For <code>s : Finset ι</code>, we define <code>Finset.Pi.antidiagonal s n</code> as the <code>Finset (ι → μ)</code> of functions with support in <code>s</code> whose sum is equal to <code>n</code>.</p>\n<p>We also define <code>Finset.antidiagonal n : Finset (μ × μ)</code> of pairs adding to <code>n</code>.</p>\n<p>These definitions generalize <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.Nat.antidiagonal#doc\">docs#Finset.Nat.antidiagonal</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.antidiagonal#doc\">docs#Finsupp.antidiagonal</a> which are defined in <code>Mathlib.Data.Finset.NatAntidiagonal</code> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Data.Finsupp.Antidiagonal#doc\">docs#Mathlib.Data.Finsupp.Antidiagonal</a> and we make the comparisons there.</p>\n<p>This definition does not exactly match with that of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.antidiagonal#doc\">docs#Multiset.antidiagonal</a> which is defined in Mathlib.Data.Multiset.Antidiagonal, because of the multiplicities. Indeed, by counting multiplicities, <code>Multiset α</code> is equivalent to <code>α →₀ ℕ</code>, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.antidiagonal#doc\">docs#Finset.antidiagonal</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.antidiagonal#doc\">docs#Multiset.antidiagonal</a> will return different objects. For example, for <code>s : Multiset ℕ := {0,0,0}</code>, <code>Multiset.antidiagonal s</code> has 8 elements but <code>Finset.antidiagonal s</code> has only 4.</p>\n<p>Co-authored by: <span class=\"user-mention\" data-user-id=\"406490\">@María Inés de Frutos Fernández</span> <br>\nInspired by a mathlib3 file by <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span></p>",
        "id": 395886479,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1696945371
    },
    {
        "content": "<p>Could you rename that to <code>Finset.piAntidiag</code>?</p>",
        "id": 395894944,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1696947665
    },
    {
        "content": "<p>Also I have quite a few lemmas to add here which I used for LeanAPAP.</p>",
        "id": 395895077,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1696947704
    },
    {
        "content": "<p><code>Finset.piAntidiagonal</code> would look fine.<br>\nAnd please add those lemmas.</p>",
        "id": 395912383,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1696953005
    },
    {
        "content": "<p>I have some code for antidiagonal products with <code>μ = ℕ</code> that I want to merge soon. Sadly I couldn't find a good way to integrate it into this code since <code>ℕ</code> is not a canonically ordered monoid (<code>2&lt;3</code> yet there is no <code>k</code> such that <code>3=2*k</code>). </p>\n<p>Maybe this is just a necessary special case the way <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.divisorsAntidiagonal#doc\">docs#Nat.divisorsAntidiagonal</a> is.</p>",
        "id": 395913810,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1696953493
    },
    {
        "content": "<p>Perhaps we should have a pair of <code>HasAntidiagonal</code> and <code>HasMulAntidiagonal</code> typeclasses so that we can prove things in one place even if the implementations are different?</p>",
        "id": 395914329,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696953677
    },
    {
        "content": "<p>Anyway, I don't feel we use the full strength of canonically ordered monoids.</p>",
        "id": 395915480,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1696953946
    },
    {
        "content": "<p>We just added these lines to the first file. Eventually, we will adjust the other definitions of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.antidiagonal#doc\">docs#Nat.antidiagonal</a> when people agree with something along these lines.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The class of monoids with an antidiagonal -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">HasMulAntidiagonal</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n<span class=\"sd\">/-- The antidiagonal function -/</span>\n  <span class=\"o\">(</span><span class=\"n\">antidiagonal</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"bp\">→</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"bp\">×</span> <span class=\"n\">μ</span><span class=\"o\">))</span>\n<span class=\"sd\">/-- A pair belongs to `antidiagonal n` iff the product of its components is equal to `n` -/</span>\n  <span class=\"o\">(</span><span class=\"n\">mem_antidiagonal</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"bp\">×</span> <span class=\"n\">μ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">antidiagonal</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"n\">a.fst</span> <span class=\"bp\">*</span> <span class=\"n\">a.snd</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The class of additive monoids with an antidiagonal -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">HasAntidiagonal</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AddMonoid</span> <span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n<span class=\"sd\">/-- The antidiagonal function -/</span>\n  <span class=\"o\">(</span><span class=\"n\">antidiagonal</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"bp\">→</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"bp\">×</span> <span class=\"n\">μ</span><span class=\"o\">))</span>\n<span class=\"sd\">/-- A pair belongs to `antidiagonal n` iff the sum of its components is equal to `n` -/</span>\n  <span class=\"o\">(</span><span class=\"n\">mem_antidiagonal</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"bp\">×</span> <span class=\"n\">μ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">antidiagonal</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"n\">a.fst</span> <span class=\"bp\">+</span> <span class=\"n\">a.snd</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 395919627,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1696955427
    },
    {
        "content": "<p>Note <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.mem_divisorsAntidiagonal#doc\">docs#Nat.mem_divisorsAntidiagonal</a> has an additional condition that <code>n ≠ 0</code>, so you would either have to add a finiteness condition to <code>mem_antidiagonal</code>, or you would have to use <code>PNat</code> instead of <code>Nat</code></p>",
        "id": 395920849,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1696955905
    },
    {
        "content": "<p>I understand. This important example makes unclear that a general class is useful. <br>\nIn general, it takes its values into <code>Set μ</code>, and maybe useful as such; in important cases, it has to be shown to be finite; in some more specific cases, we may have a <code>Finset μ</code> that represents it.<br>\nThe idea that a class might be an interesting thing to add comes from a remark of <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  who notes that for an integer <code>n</code>, the present definition of <code>Finset.antidiagonal n</code> has complexity <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> O(n^2) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> because it filters the set out of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">;</mo><mi>n</mi><mo stretchy=\"false\">]</mo><mo>×</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">;</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\"> [0;n] \\times [0;n] </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span></span></span></span>, while <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.antidiagonal#doc\">docs#Nat.antidiagonal</a> builds it in time <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> O (n) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 395927387,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1696958465
    },
    {
        "content": "<p>We could change <code>HasMulAntidiagonal</code> to take a <code>MonoidWithZero</code></p>",
        "id": 395955351,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696969347
    },
    {
        "content": "<p>What types do we envisage wanting the multiplicative version for other than <code>Nat</code>?</p>",
        "id": 395955384,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696969370
    },
    {
        "content": "<p>What I like with this suggestion is that in <code>MonoidWithZero</code>, it makes sense to give a different role to<code>Zero</code>.</p>",
        "id": 395955948,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1696969638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.237486.20antidiagonal/near/395955384\">said</a>:</p>\n<blockquote>\n<p>What types do we envisage wanting the multiplicative version for other than <code>Nat</code>?</p>\n</blockquote>\n<p><code>PNat</code> <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>\n<p>I say this half-seriously only because there have been some off-hand comments that <code>ArithmeticFunction</code>s should be defined on <code>PNat</code> instead of <code>Nat</code>.</p>",
        "id": 395956836,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1696970086
    },
    {
        "content": "<p>I have not seen these comments, but arithmetic functions correspond to what Bourbaki calls the “algèbre large du monoïde multiplicatif de N*” which comes from a general construction of an algebra on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>k</mi><mi>M</mi></msup></mrow><annotation encoding=\"application/x-tex\"> k^ M </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span></span></span></span></span></span></span></span> whenever <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\"> k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> is a commutative ring and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\"> M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a monoid such that the the multiplication has finite fibers. When <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"bold\">N</mi><mo separator=\"true\">,</mo><mo>+</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> M =( \\mathbf N, +) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathbf\">N</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mclose\">)</span></span></span></span>, we get power series ; when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"bold\">N</mi><mo>∖</mo><mo stretchy=\"false\">{</mo><mn>0</mn><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><mo>×</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> M = (\\mathbf N\\setminus\\{0\\}, \\times) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathbf\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∖</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mclose\">}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">×</span><span class=\"mclose\">)</span></span></span></span>, we get arithmetic functions. So yes, this makes sense.</p>",
        "id": 395963198,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1696973353
    },
    {
        "content": "<p>To be clear, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.ArithmeticFunction#doc\">docs#Nat.ArithmeticFunction</a> is currently defined as a zero-hom from <code>Nat</code> with Dirichlet convolution as multiplication, which is equivalent to what you wrote. The worry is just that this leads to annoying <code>0&lt;n</code> side-goals that might better be dealt with by using <code>PNat</code> consistently. <br>\nActually getting that to work might cause more trouble downstream though, for example you would have to rewrite <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.divisors#doc\">docs#Nat.divisors</a> to use <code>PNat</code>, and the refactored code might actually be harder to use.</p>",
        "id": 395965987,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1696975025
    },
    {
        "content": "<p>I kind of get the feeling that a lot of this divisors stuff would be cleaner with <code>PNat</code> everywhere</p>",
        "id": 395966112,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696975105
    },
    {
        "content": "<p>I agree with both of you. It seems (as often in mathlib) that definitions which fit into a very general framework lead to a cleaner formalization.</p>",
        "id": 395968344,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1696976438
    },
    {
        "content": "<p>Perhaps the answer here is to declare the multiplicative version out of scope, and use the typeclass for the additive case</p>",
        "id": 395968501,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696976539
    },
    {
        "content": "<p>At some point we should port and pr <a href=\"https://github.com/leanprover-community/mathlib/pull/11656\">https://github.com/leanprover-community/mathlib/pull/11656</a>, it was actually in reasonable shape iirc</p>",
        "id": 396082409,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1697028712
    },
    {
        "content": "<p>In any case, our main use of this PR is to manipulate products / powers of power series and prove results on them. <br>\nThen the type is <code>sigma to_0 nat</code> for some arbitrary type sigma.</p>",
        "id": 396115694,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1697038577
    }
]