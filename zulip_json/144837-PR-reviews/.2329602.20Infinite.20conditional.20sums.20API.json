[
    {
        "content": "<p>So I have some questions about this. Lots of the stuff I've done is simply take the infinite sum stuff we have now and just add filters. I expect lots of this works. Now, would we want to develop all this conditionally convergent API completely separetely or generalise what we have now (where possible) but then have some notation/alias for the absolutely convergent case? I think we should still have <code>Summable f</code>, <code>tsum f</code> etc for these things.</p>",
        "id": 539138774,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1757699761
    },
    {
        "content": "<ol>\n<li>We should definitely keep the existing notation of the unconditionally convergent case.</li>\n<li>I think we should also keep <code>Summable</code> and <code>HasSum</code> as <code>abbrev</code>s for the filter version.</li>\n<li><code>tsum</code> is behind notation, so it's not so necessary there I don't think. </li>\n<li>You're welcome to work on this, I don't have tons of time for it. </li>\n<li>I think the tricky part is that we probably need to remove the extra <code>if</code> in <code>tsum</code> for the case when the support is finite, otherwise it will return the wrong value for some filters.</li>\n</ol>",
        "id": 539161558,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1757710572
    },
    {
        "content": "<p>Wouldn't it be clever to prepare the API so that it includes various summation rules? Conditionally convergent is one, but there is also the Abel one consisting in taking the limit for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>‚Üí</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">t\\to 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>‚àë</mo><msub><mi>a</mi><mi>n</mi></msub><msup><mi>t</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\sum a_n t^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">‚àë</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>. All of them would lead to a similar API. For Fourier Series, there is also the possibility of summing symmetrically on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord mathbf\">Z</span></span></span></span>.</p>",
        "id": 539176530,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1757718846
    },
    {
        "content": "<p>Summing symmetrically is included in the filter approach.</p>",
        "id": 539281870,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1757779878
    },
    {
        "content": "<p>Ok so it sounds like we want to just refactor the code where possible and use abbrevs for the previous notation. As for the finite support case. Do you know why this was added? Am I right in thinking that this wasnt there when this was all done originally, but only added later?</p>\n<p>As for Abel summation. How would this work for multipliable squences? Since lots of the API is done multiplicatively and then we <code>to_additive</code> it. Is there Abel multipliability?</p>",
        "id": 539491764,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1757924835
    },
    {
        "content": "<p>Yes, the finite support case was added later to make sure that the tsum always coincides with the sum, even without separation assumptions. This is really nice to have, and I think we should definitely keep it!</p>",
        "id": 539509072,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1757929430
    },
    {
        "content": "<p>Aha ok I understand, in which case I agree we should keep it. Do you think if we just did something like changing <code> if (mulSupport f).Finite then finprod f</code> to something like <code>if (mulSupport f).Finite ‚àß L = atTop then finprod f</code> (where <code>L</code> is the filter) that it would be ok. I don't know what conditions exactly you'd need on the filter in general for this to work, but this coincides with what we have now.</p>",
        "id": 539509777,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1757929609
    },
    {
        "content": "<p>Yes, adding an <code>if</code> in the definition is perfectly fine, in any case it's an <code>irreducible_def</code> that one should never unfold. Instead of <code>L = atTop</code> it's probably even better to use an inequality, so that it applies also for instance to conditional convergence over the naturals.</p>",
        "id": 539510371,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1757929776
    },
    {
        "content": "<p>Yes, adding a condition with a filter inequality seems like the right approach to me.</p>",
        "id": 539551026,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1757941142
    },
    {
        "content": "<p>OK so <a href=\"https://github.com/leanprover-community/mathlib4/pull/29602\">#29602</a> now has a big chunk of the changes needed. I've so far ignored Abel summation since I'm not sure how to combine it with the multipliability setup. I have also not really generalised things relatings to sums with finite support. Some things will definitely be true in these cases, but I've left them as their unconditionally convergent versions, since this can be done in another PR (as this is already long enough). Elsewhere I have generalised things where possible and not too much trouble. </p>\n<p>I have some questions (since I've not done a refactor of this scale before). I've left these questions as reviews in the PR so that they are easy to find. But essentially the main one is, having a general result for filters followed by one for unconditionally convergent sums seems to be more annoying that it should. Since the general result unfolds the definitions, but then the specific one can't then be applied (even though it should be able to see through the notation).</p>",
        "id": 540779469,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758541736
    },
    {
        "content": "<p>I think the approach in the current PR requires too much downstream change to functions using the standard <code>HasSum</code>/<code>HasProd</code>. </p>\n<p>Rather than defining <code>HasProd</code> as an <code>abbrev</code> for <code>HasProdFilter (L := atTop)</code>, can you have a single declaration taking the filter as argument but with a default value of <code>atTop</code> (similar to the way many integration results have a measure argument which defaults to <code>volume</code>)?</p>",
        "id": 540996887,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758629530
    },
    {
        "content": "<p>So if you adjust the definition of <code>HasProd</code> as follows</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HasProd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">atTop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Tendsto</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"bp\">‚àè</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ùìù</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>then this extends the existing API \"conservatively\", i.e. all the existing lemmas and syntax continue to work as before but we have the extra flexibility in the definition.</p>",
        "id": 541024720,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758636588
    },
    {
        "content": "<p>Ok so this sounds different to what I understood from <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> comment above. I thought we wanted to keep HasProd, Summable as is, by using abbrevs for them.  Doing it this way would mean that Summable doesnt always mean absolutely convergent. Are happy with this? I thought having Summable/ SummableFilter, etc would be similar to deriv/ fderiv setup we have there.</p>",
        "id": 541025879,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758636867
    },
    {
        "content": "<p>Yes, it's a different approach ‚Äì but with the same overall goal, which is to find a way of adding in this extra functionality while causing the least disturbance to the existing code using the <code>atTop</code> filter.</p>",
        "id": 541034937,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758639017
    },
    {
        "content": "<p>That's an interesting idea, I'll have to think about it.</p>",
        "id": 541051090,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1758643132
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover-community/mathlib4/pull/29914\">#29914</a> for a \"proof of concept\". (There are a few downstream files which don't build at the moment.)</p>",
        "id": 541060703,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758646460
    },
    {
        "content": "<p>So this would still need all the things like <code>tsum_mul_left</code> etc to be generalised, but would stop the need for all the find and replace in changing names like 'HasSum' to 'HasSumFilter', which is nice. I guess the thing with keeping the names is that it might cause confusion now that HasSum doesnt mean what it used to mean.</p>",
        "id": 541061893,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758646860
    },
    {
        "content": "<p>I'm happy to go with this, if that's the consensus, but I'll hold off making anymore changes until we can agree on what the best option is.</p>",
        "id": 541062223,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758646979
    },
    {
        "content": "<p>I think I prefer the <code>hasSumFilter / hasSum</code> approach in the long run, because this is such a fundamental notion that it deserves API distinguishing clearly between the two situations, in the same way that we have <code>HasFDerivAtFilter</code> and <code>hasFDerivAt</code>, say. It is true that the refactor is more disruptive with this approach than with the autoParam approach, but still it looks cleaner to me.</p>",
        "id": 541062722,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1758647157
    },
    {
        "content": "<p>I had a look at <a href=\"https://github.com/leanprover-community/mathlib4/pull/29602\">#29602</a>, and I think it would be better to duplicate the API, to have it both for <code>hasSumFilter</code> and then specialized versions for <code>hasSum</code> (deduced by just applying the <code>hasSumFilter</code> version). In this way, one wouldn't need to touch downstream files, they would still use the already existing <code>hasSum</code> API.</p>",
        "id": 541063296,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1758647374
    },
    {
        "content": "<p>I just looked at the PR, and I agree with <span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> here, both that we should have separate <code>HasSum</code> declarations, and also that the API should be duplicated. This is what we do also in many other places in the library where there is a \"filter-generic\" version of common concepts. (e.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TendstoUniformlyOnFilter#doc\">docs#TendstoUniformlyOnFilter</a>).</p>",
        "id": 541063620,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1758647498
    },
    {
        "content": "<p>Sure that would work. It would also solve the issues I was having with things getting unfolded. I just didn't know how much duplication we wanted.</p>",
        "id": 541063632,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758647502
    },
    {
        "content": "<p>I am a little concerned about the amount of work that will be involved in taking the (very very substantial) API we have for topological sums and duplicating virtually all of it. I'm also worried it will be an ongoing maintenance burden, because every time someone wants to add a new lemma about topological sums in future, either they'll have to write two copies of it, or the <code>HasSum</code> and <code>HasSumFilter</code> API's will get out of sync. </p>\n<p>What are the practical downsides of the optional-parameter approach? I fully agree with Jireh and Sebastien that this is a fundamental notion; but that doesn't necessarily mean we should ignore opportunities to save effort and avoid duplication. I was surprised how easily this worked (how little downstream code broke) in my proof-of-concept PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/29914\">#29914</a>. [Edit: This now builds cleanly, modulo commenting out a <code>positivity</code> tactic extension which I don't know enough to tinker with.]</p>",
        "id": 541089285,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758657361
    },
    {
        "content": "<p>I am in the optional parameter camp after my experience with <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/Polynomial/Resultant/Basic.html#Polynomial.resultant\">Polynomial.resultant</a>.</p>",
        "id": 541092381,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758658668
    },
    {
        "content": "<p>An analogue would be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sum#doc\">docs#Finset.sum</a>: <code>‚àë x : X, f x</code> for a fintype <code>X</code> is a pretty fundamental notion too, but it's actually defined as a notational shortcut for <code>‚àë x ‚àà univ, f x</code>; and this seems to work fine, and saves defining a whole API for <code>Fintype</code> sums as distinct from <code>Finset</code> sums.</p>",
        "id": 541092511,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758658720
    },
    {
        "content": "<p>The <code>Finset.sum</code> analogy is qualitatively different, because the notation does the disambiguation for you. Note that I would <em>not</em> propose having both <code>tsum</code> and <code>tsumOnFilter</code> for exactly this reason: you can use the notation to distinguish.</p>",
        "id": 541092820,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1758658866
    },
    {
        "content": "<p>My solution also has the notation disambiguation: we have <code>‚àè' b, f b</code> for the <code>atTop</code> version and <code>‚àè'[L] b, f b</code> for the version with a custom choice of filter <code>L</code>.</p>",
        "id": 541093084,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758658982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541063620\">said</a>:</p>\n<blockquote>\n<p>(e.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TendstoUniformlyOnFilter#doc\">docs#TendstoUniformlyOnFilter</a>)</p>\n</blockquote>\n<p>This example is different because you cannot define it using an optional parameter.<br>\n(the correspondence is :</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">tendstoUniformlyOn_iff_tendstoUniformlyOnFilter</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">TendstoUniformlyOn</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">TendstoUniformlyOnFilter</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">principal</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>)</p>",
        "id": 541093290,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758659070
    },
    {
        "content": "<p>yes, I know, I'm just saying that the fact that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sum#doc\">docs#Finset.sum</a> is the same underlying declaration for <code>‚àë _ :</code> and <code>‚àë _ ‚àà</code> isn't in and of itself supporting the optional parameter approach.</p>",
        "id": 541093371,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1758659112
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> sorry for repeating a question above, but what are the downsides of using optional parameter in your opinion?</p>",
        "id": 541093612,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758659206
    },
    {
        "content": "<p>I admit it's a bit unfamiliar at first, but as I used it in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.resultant#doc\">docs#Polynomial.resultant</a> I quickly realised how much extra work it saves me</p>",
        "id": 541093703,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758659232
    },
    {
        "content": "<p>Confusion is one issue. Another is the silent loss of generality incurred whenever someone writes <code>HasSum f a</code> instead of <code>HasSum f a L</code>. It's easier to spot if the default is to use <code>HasSumOnFilter</code> and only specialize when necessary.</p>",
        "id": 541095420,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1758659886
    },
    {
        "content": "<p>I'm not opposed to being persuaded though. I'll certainly consider further the <code>optParam</code> approach.</p>",
        "id": 541095490,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1758659914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541095420\">said</a>:</p>\n<blockquote>\n<p>Confusion is one issue. Another is the silent loss of generality incurred whenever someone writes <code>HasSum f a</code> instead of <code>HasSum f a L</code>. It's easier to spot if the default is to use <code>HasSumOnFilter</code> and only specialize when necessary.</p>\n</blockquote>\n<p>I don‚Äôt follow: isn‚Äôt the availability of the generalisation easier, not harder, to spot with the optional parameter? If you use some HadSum lemma in the orthodox case, and then see in the docstring that it takes an optional argument to give more generality,  that‚Äôs more ‚Äúfindable‚Äù than having to look for lemmas under a different name and in a different ref manual page.</p>",
        "id": 541156524,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758697654
    },
    {
        "content": "<p>My main issue is confusion: people using <code>Summable f</code> for <code>f : N -&gt; R</code> will see in the infoview <code>Summable f Filter.atTop</code>  and are likely to think that this is the <code>atTop</code> filter on <code>N</code>, so conditional convergence, while this is in fact absolute convergence and <code>atTop</code> is a filter on finsets of <code>N</code> -- a slightly scary object.</p>",
        "id": 541157696,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1758698102
    },
    {
        "content": "<p>Would it be possible to do something like what <code>to_additive</code> does and have a <code>to_absolute</code> (or whatever) that just gives  HasSum/Summable versions of any HasSumFilter/SummableFilter lemmas. That way we can just tag the results with this, which avoids the direct duplication and also distinguishes absolutely convergent ones from conditional convergent ones.</p>",
        "id": 541159545,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758698760
    },
    {
        "content": "<p>(well I'm guessing this is possible, the question is more is this feasible/worth trying).</p>",
        "id": 541160080,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758698949
    },
    {
        "content": "<p>But is there so much API that would need duplication? I guess that many many lemmas on unconditional convergence would not be true for the general notion of convergence.</p>",
        "id": 541166160,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1758701011
    },
    {
        "content": "<p>So I think lots/if not most of what is in <code>Topology/Algebra/InfiniteSum/..</code> also holds for the filter versions. Things like <code>tsum_mul_left</code>, etc would all be needed for both. In doing the refactor I did also notice several other places where results held more generally and generalised them there as well (like in <code>Topology/Instances/Matrix.lean</code> although these are maybe less important)</p>",
        "id": 541168815,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758701887
    },
    {
        "content": "<p>That said, I don't know how much future work would need duplicating. But at least lots of the basic API we have now would need duplicating.</p>",
        "id": 541173656,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758703323
    },
    {
        "content": "<p>Yes, the deeper lemmas don‚Äôt generalise, it‚Äôs only the boring ones that need duplicating; but there are a lot of those!</p>",
        "id": 541178366,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758704745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541157696\">said</a>:</p>\n<blockquote>\n<p>My main issue is confusion: people using <code>Summable f</code> for <code>f : N -&gt; R</code> will see in the infoview <code>Summable f Filter.atTop</code>  and are likely to think that this is the <code>atTop</code> filter on <code>N</code>, so conditional convergence, while this is in fact absolute convergence and <code>atTop</code> is a filter on finsets of <code>N</code> -- a slightly scary object.</p>\n</blockquote>\n<p>Perhaps we could make a <code>SummationDirection</code> class which was a wrapper around <code>Filter (Finset _)</code>, with appropriate docstrings? We could also build in the consistency condition that the filter is <code>‚â§ atTop</code>.</p>",
        "id": 541180135,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758705291
    },
    {
        "content": "<p>Then <code>Summable f</code> would expand to <code>Summable f (unconditional ‚Ñï)</code>, or something, which is not too scary; and we could give similar mnemonic names to other natural finset filters.</p>",
        "id": 541181279,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758705611
    },
    {
        "content": "<p>(Of course this is something that might make sense even if we don‚Äôt go with the optional parameter approach)</p>",
        "id": 541182142,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758705873
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541180135\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>My main issue is confusion: people using <code>Summable f</code> for <code>f : N -&gt; R</code> will see in the infoview <code>Summable f Filter.atTop</code> and are likely to think that</p>\n</blockquote>\n</blockquote>\n<p>(I just realised that the infoview  wouldn't print that anyway: it would just print <code>Summable f</code>. Apparently default arguments aren't shown in the infoview, matching the input syntax, which seems very sensible. You have to hover over it to see the extra argument, as one does with implicit and instance arguments. Apologies if that was what you meant all along!)</p>",
        "id": 541212323,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758715648
    },
    {
        "content": "<p>No, I hadn't checked, and obviously I should have :-) Thanks for checking! Then I have no objection to the auto_param approach (other than \"it's not the way we usually do it\" but I don't think that's a good objection). Rewrites with autoparams are sometimes a little bit awkward (if you don't put an underscore where the autoparam is then <code>rw</code> doesn't work) but I don't expect we will rewrite <code>HasSum</code> or <code>Summable</code> often, so it's not an issue here.</p>",
        "id": 541213731,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1758716106
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/29914\">#29914</a> now has generalisations of a substantial fraction of the <code>HasSum</code> API to take a <code>SummationFilter</code> structure (as optional argument to the defs <code>HasSum</code>, <code>tsum</code> and <code>summable</code>, and implicit argument to lemmas about them). This is just a filter on <code>Finset Œ≤</code> together with proofs that it is <code>‚â§ atTop</code> and <code>NeBot</code>. </p>\n<p>Virtually all of the modifications are just copy-pasting an argument <code>L : SummationFilter Œ≤</code> into the existing code and observing that the existing proof continues to work.</p>",
        "id": 541250990,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758725847
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span> Thanks!</p>",
        "id": 541251693,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758726003
    },
    {
        "content": "<p>Yes I noticed almost everything works. So just to check, does what you have now, mean that results like <code>tsum_mul_left</code> hold already for the filter version, or do these things also need updating?</p>",
        "id": 541252476,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758726171
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"389019\">@Chris Birkbeck</span> <a href=\"https://github.com/leanprover-community/mathlib4/pull/29914/files#diff-7e8476967bc86a1da1964ba2c0be0bd05283f4ff003244ff77a53894166a3ad2R45\">https://github.com/leanprover-community/mathlib4/pull/29914/files#diff-7e8476967bc86a1da1964ba2c0be0bd05283f4ff003244ff77a53894166a3ad2R45</a></p>",
        "id": 541252887,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758726265
    },
    {
        "content": "<p>in that PR David hasn't updated it to the filter version yet</p>",
        "id": 541252978,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758726286
    },
    {
        "content": "<p>That's the goal, yes, although I didn't get as far as <code>InfiniteSum/Ring.lean</code> yet</p>",
        "id": 541253027,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758726298
    },
    {
        "content": "<p>Ok fine I understand, thanks. I played with this pr this morning and this also does solve the annoyances I had in the PR I made.</p>",
        "id": 541253219,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758726353
    },
    {
        "content": "<p>does the <code>SummationFilter</code> need to have the ne_bot field? I think this is only ever really needed for tsum results, not for summable/hasSum. although I don't know if we care about this filter.</p>",
        "id": 541253525,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758726428
    },
    {
        "content": "<p>Why would one ever want to consider a limit along the <code>bot</code> filter? It's junk.</p>",
        "id": 541253659,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758726464
    },
    {
        "content": "<p>what happens when the filter is bot? is it always summable or never summable?</p>",
        "id": 541253696,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758726476
    },
    {
        "content": "<p>always summable</p>",
        "id": 541253729,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758726484
    },
    {
        "content": "<p>Everything's sumamble with every possible sum</p>",
        "id": 541253759,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758726492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541253659\">said</a>:</p>\n<blockquote>\n<p>Why would one ever want to consider a limit along the <code>bot</code> filter? It's junk.</p>\n</blockquote>\n<p>yes, but what breaks exactly?</p>",
        "id": 541253785,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758726498
    },
    {
        "content": "<p>Uniqueness results (because the same function can have two different sums)</p>",
        "id": 541253882,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758726522
    },
    {
        "content": "<p>yeah I not saying we need it. It just felt more the mathlib way to not \"restrict\" if not needed.</p>",
        "id": 541253965,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758726543
    },
    {
        "content": "<p>and the same thing breaks if we don't have <code>le_atTop</code>?</p>",
        "id": 541254055,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758726564
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"389019\">Chris Birkbeck</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541253965\">said</a>:</p>\n<blockquote>\n<p>yeah I not saying we need it. It just felt more the mathlib way to not \"restrict\" if not needed.</p>\n</blockquote>\n<p>well we're gonna need it for <code>tsum</code> and we will end up introducing a new typeclass for it and at that point it just feels like extra burden</p>",
        "id": 541254142,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758726587
    },
    {
        "content": "<blockquote>\n<p>and the same thing breaks if we don't have¬†<code>le_atTop</code>?</p>\n</blockquote>\n<p>No, that's different. The <code>le_atTop</code> condition is needed to make the summation method \"consistent\" in some sense (e.g. when the support of the function is finite then the sum is just the ordinary sum, etc).</p>",
        "id": 541254502,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758726679
    },
    {
        "content": "<p>So I just pushed the modifications to <code>InfiniteSum/Ring.lean</code> necessary to make <code>tsum_mul_left</code> work for arbitrary summation filters. I deliberately did this \"minimally\" to show how small the changes needed are (i.e. I only patched this one lemma and its direct dependencies). You'll see it's literally just a case of adding an <code>L</code> in a few places.</p>",
        "id": 541254800,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758726763
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 541254971,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758726814
    },
    {
        "content": "<p>Yeah I know, that was the case before. I just added L's and changed the name. But this way we don't need to change the names which is nice, since it means later we don't need to update anything downstream.</p>",
        "id": 541255035,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758726833
    },
    {
        "content": "<p>So, if we want to go this way, I'm happy to help you finish off <a href=\"https://github.com/leanprover-community/mathlib4/pull/29914\">#29914</a></p>",
        "id": 541255286,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758726899
    },
    {
        "content": "<p>Great, would appreciate that! Thanks!</p>",
        "id": 541255337,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758726915
    },
    {
        "content": "<p>(Do I need to do anything to make it possible for Chris, or anyone else, to push to this PR branch? Not sure how this works since the switch to forks.)</p>",
        "id": 541256513,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758727224
    },
    {
        "content": "<p>ha yes I was just about to ask this</p>",
        "id": 541256607,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758727251
    },
    {
        "content": "<p>I found the \"invite collaborator\" button and sent you an invite</p>",
        "id": 541257276,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758727413
    },
    {
        "content": "<p>I'm not following the discussion very closely, but thanks for this work, it looks very nice.</p>\n<p>I would indeed suggest removing the <code>ne_bot</code> restriction, because it's easy to add as a typeclass argument if needed. <br>\nI don't have such a clear opinion about <code>le_atTop</code> since this is more annoying to have as an extra assumption. But I'm also tempted to say that we could remove it ideally: after all, you could want to sum a function <code>f : ‚Ñ§ √ó ‚Ñ§ ‚Üí ‚Ñù</code> along just finsets contained in the diagonal. I also think (but may be wrong) that some of the results you didn't manage to filterize could be stated if this restriction was removed.</p>",
        "id": 541257567,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1758727485
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541257567\">said</a>:</p>\n<blockquote>\n<p>I would indeed suggest removing the <code>ne_bot</code> restriction</p>\n</blockquote>\n<p>What's the benefit of this?</p>",
        "id": 541258750,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758727796
    },
    {
        "content": "<p>On the contrary, I think some of the results I <em>did</em> manage to filterize would not work without the <code>le_atTop</code> assumption¬†‚Äì¬†and it seems to be annoying to add it in with the optional-argument mechanism. I tried something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SummationFilter</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">unconditional</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hL</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">atTop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">le_rfl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but then <code>apply</code>-ing this lemma doesn't fill in the default argument for <code>hL</code>, so some existing code using <code>hasSum</code> broke, because <code>apply</code> was spawning extra side-goals proving that atTop was le itself (which that could all be killed with <code>rfl</code>).</p>",
        "id": 541258802,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758727804
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span> <code>by exact le_rfl</code></p>",
        "id": 541258955,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758727840
    },
    {
        "content": "<p>also I just don't use <code>apply</code> in general <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 541259065,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758727860
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541258955\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <code>by exact le_rfl</code></p>\n</blockquote>\n<p>Yes, that was a typo, in fact I had <code>by rfl</code> I think, but it still didn't work.</p>",
        "id": 541259604,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758727939
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_refl</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hn</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"c1\">-- autoParam (4 ‚â§ 4) _auto‚úù</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n</code></pre></div>",
        "id": 541260501,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758728073
    },
    {
        "content": "<p>I've stopped using <code>apply</code> since the days of Lean 3</p>",
        "id": 541260569,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758728084
    },
    {
        "content": "<p>Here's an annoying question. Does structure want to be called <code>SummationFilter</code> when lots of the results are stated for multipliable things. Maybe it should be like <code>ArithmeticFilter</code>??? I don't know.</p>",
        "id": 541261979,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758728326
    },
    {
        "content": "<p>Here's an annoying response:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"n\">SummationFilter</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">ProductFilter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SummationFilter</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span>\n</code></pre></div>",
        "id": 541262319,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758728390
    },
    {
        "content": "<p>Hmm I guess thats an option, I'm not sure how I feel about it</p>",
        "id": 541264657,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758728949
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541253882\">said</a>:</p>\n<blockquote>\n<p>Uniqueness results (because the same function can have two different sums)</p>\n</blockquote>\n<p>uniqueness needs a lot of assumptions</p>",
        "id": 541265492,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758729173
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541257567\">said</a>:</p>\n<blockquote>\n<p>after all, you could want to sum a function <code>f : ‚Ñ§ √ó ‚Ñ§ ‚Üí ‚Ñù</code> along just finsets contained in the diagonal.</p>\n</blockquote>\n<p>I think that's still le attop</p>",
        "id": 541266156,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758729328
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541265492\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541253882\">said</a>:</p>\n<blockquote>\n<p>Uniqueness results (because the same function can have two different sums)</p>\n</blockquote>\n<p>uniqueness needs a lot of assumptions</p>\n</blockquote>\n<p>Only two: the filter needs to be NeBot and the target space T2.</p>",
        "id": 541267329,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758729564
    },
    {
        "content": "<p>that's a lot of assumptions</p>",
        "id": 541268089,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758729706
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541266156\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541257567\">said</a>:</p>\n<blockquote>\n<p>after all, you could want to sum a function <code>f : ‚Ñ§ √ó ‚Ñ§ ‚Üí ‚Ñù</code> along just finsets contained in the diagonal.</p>\n</blockquote>\n<p>I think that's still le attop</p>\n</blockquote>\n<p>No, it‚Äôs not. Being le atTop is a strong condition, in particular it implies that any unconditionally cvgt sum is also cvgt for the filter, with the same sum.</p>",
        "id": 541268375,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758729794
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541268089\">said</a>:</p>\n<blockquote>\n<p>that's a lot of assumptions</p>\n</blockquote>\n<p>Two isn‚Äôt a lot imho!</p>",
        "id": 541268465,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758729818
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541212323\">said</a>:</p>\n<blockquote>\n<p>(I just realised that the infoview wouldn't print that anyway: it would just print <code>Summable f</code>. Apparently default arguments aren't shown in the infoview, matching the input syntax, which seems very sensible. You have to hover over it to see the extra argument, as one does with implicit and instance arguments. Apologies if that was what you meant all along!)</p>\n</blockquote>\n<p>This really surprises me, but given that, I suppose it's not as confusing as I had suspected. Although I'm still <em>slightly</em> concerned that people won't understand the magical difference between <code>Summable f</code> and (the only sometimes present) <code>Summable f L</code>. But given that everyone else seems convinced, I'm willing to drop this.</p>",
        "id": 541270587,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1758730378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541270587\">said</a>:</p>\n<blockquote>\n<p>people won't understand the magical difference between <code>Summable f</code> and (the only sometimes present) <code>Summable f L</code></p>\n</blockquote>\n<p>and those people can prove and use theorems about <code>Summable f</code> all they want</p>",
        "id": 541271342,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758730551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541258802\">said</a>:</p>\n<blockquote>\n<p>On the contrary, I think some of the results I <em>did</em> manage to filterize would not work without the <code>le_atTop</code> assumption</p>\n</blockquote>\n<p>Isn't it the case that this assumption works for some of the results, but it doesn't work for others? I seem to remember thinking that the condition should be something like <code>L ‚â§ ùìü {(mulSupport f)}</code> to get the <code>finprod</code> stuff to work. Of course, this doesn't quite work because <code>mulSupport</code> is a set, not a <code>Finset</code>, but in the relevant setting of <code>tprod</code>, we have <code>(mulSupport f).Finite</code>, so maybe the condition should be <code>L ‚â§ ùìü {hf.toFinset}</code>, where <code>hf : (mulSupport f).Finite</code>?</p>",
        "id": 541272545,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1758730851
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541271342\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541270587\">said</a>:</p>\n<blockquote>\n<p>people won't understand the magical difference between <code>Summable f</code> and (the only sometimes present) <code>Summable f L</code></p>\n</blockquote>\n<p>and those people can prove and use theorems about <code>Summable f</code> all they want</p>\n</blockquote>\n<p>I guess there‚Äôs still the issue is that ‚Äúthose people‚Äù might be confused by the fact that the docstrings for the lemmas they‚Äôre wanting to use include this funny L thing, that isn‚Äôt (visibly) present in the statements they‚Äôre trying to prove. But this is IMHO a small loss, esp if we make sure the distinction is clearly explained in docstrings.</p>",
        "id": 541273765,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758731109
    },
    {
        "content": "<p>Yes, good docstrings will go a long way to avoiding the confusion.</p>",
        "id": 541274049,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1758731173
    },
    {
        "content": "<p>Just to revisit a few comments that got left behind:<br>\n<span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541272545\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541258802\">said</a>:</p>\n<blockquote>\n<p>On the contrary, I think some of the results I <em>did</em> manage to filterize would not work without the <code>le_atTop</code> assumption</p>\n</blockquote>\n<p>Isn't it the case that this assumption [<code>le_atTop</code>] works for some of the results, but it doesn't work for others? I seem to remember thinking that the condition should be something like <code>L ‚â§ ùìü {(mulSupport f)}</code> to get the <code>finprod</code> stuff to work. Of course, this doesn't quite work because <code>mulSupport</code> is a set, not a <code>Finset</code>, but in the relevant setting of <code>tprod</code>, we have <code>(mulSupport f).Finite</code>, so maybe the condition should be <code>L ‚â§ ùìü {hf.toFinset}</code>, where <code>hf : (mulSupport f).Finite</code>?</p>\n</blockquote>\n<p>I'm not sure what you mean by \"work\". The assumption <code>le_atTop</code> is definitely sufficient for finite products to have the expected value (&amp; this is already in the PR). Possibly it's not the weakest condition that would suffice; but I don't think <code>L ‚â§ ùìü {(mulSupport f)}</code> is the right condition (this is not true for <code>L = atTop</code> unless the underlying type is finite). Even if there are weaker conditions that work, I would be wary of using them here, because we don't want end-users only interested in the <code>atTop</code> case to need to supply proof arguments to show that <code>atTop</code> satisfies the conditions.</p>",
        "id": 541283107,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758733584
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541268375\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541266156\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541257567\">said</a>:</p>\n<blockquote>\n<p>after all, you could want to sum a function <code>f : ‚Ñ§ √ó ‚Ñ§ ‚Üí ‚Ñù</code> along just finsets contained in the diagonal.</p>\n</blockquote>\n<p>I think that's still le attop</p>\n</blockquote>\n<p>No, it‚Äôs not. Being le atTop is a strong condition, in particular it implies that any unconditionally cvgt sum is also cvgt for the filter, with the same sum.</p>\n</blockquote>\n<p>Oh yeah I think I get it now</p>",
        "id": 541292454,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758736552
    },
    {
        "content": "<p>I think we should drop the <code>le_atTop</code> condition, for the following reason. Currently, there is no way to talk about the tsum on a subset <code>s</code> of the space, we have to go to a subtype for this, and this is quite painful. If we allow arbitrary filters, then we could take the filter of finsets contained in <code>s</code> and eventually covering <code>s</code>. For this filter <code>L</code>, then <code>tsum f L</code> would be the tsum on <code>s</code>. Allowing this would be a great improvement over the current state of the library.</p>",
        "id": 541295097,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1758737150
    },
    {
        "content": "<p>It would be nice to cook up a definition of <code>tsum</code> such that, for this filter <code>L</code> equal to \"<code>atTop</code> on <code>s</code>\", if <code>f</code> has finite support on <code>s</code> then <code>tsum f L</code> is the sum of <code>f x</code> over <code>x</code> in the support of <code>f</code> inside <code>s</code>.</p>",
        "id": 541306909,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1758740077
    },
    {
        "content": "<p>To make sure lemmas needing <code>le_atTop</code> don't break when applied in the standard situation of the <code>atTop</code> filter, we could introduce a typeclass for <code>Filter.leAtTop</code> and write the lemmas as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SummationFilter</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">unconditional</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">leAtTop</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 541307323,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1758740241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541295097\">said</a>:</p>\n<blockquote>\n<p>I think we should drop the <code>le_atTop</code> condition</p>\n</blockquote>\n<p>I think this is a really nice and persuasive idea; but I ran into a problem when implementing it. The issue is the combination of the following two things: </p>\n<ul>\n<li>in cases where the limit exists but isn't unique, our convention is to choose an arbitrary limit for <code>tsum</code> <em>unless</em> the support of the function is finite, in which case we take the finite sum as the \"best\" choice of limit.</li>\n<li>if the filter <code>L</code> doesn't satisfy <code>le_atTop</code>, then even for finitely-supported functions, the tsum w.r.t. L doesn't necessarily agree with the naive finite sum.</li>\n</ul>\n<p>So, if we embrace filters that aren't <code>le_atTop</code>, what is the \"correct\" value to use for the product when the mul support is finite?</p>\n<p>(My personal view is that this special-case handling of finite supports in the definition of tsum / tprod is pretty much obsolete now that we have a whole separate theory of finsums / finprods, and we should just get rid of it and use an arbitrary <code>Classical.choose</code>.)</p>",
        "id": 541499067,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758817042
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541295097\">said</a>:</p>\n<blockquote>\n<p>the filter of finsets contained in <code>s</code> and eventually covering <code>s</code></p>\n</blockquote>\n<p>I guess you mean <code>map (Finset.mapEmbedding (.subtype (¬∑ ‚àà s))) atTop</code>?</p>",
        "id": 541510765,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1758821288
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541510765\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541295097\">said</a>:</p>\n<blockquote>\n<p>the filter of finsets contained in <code>s</code> and eventually covering <code>s</code></p>\n</blockquote>\n<p>I guess you mean <code>map (Finset.mapEmbedding (.subtype (¬∑ ‚àà s))) atTop</code>?</p>\n</blockquote>\n<p>that seems correct</p>",
        "id": 541510896,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758821339
    },
    {
        "content": "<p>(Something I just realised is that there's an intrinsic definition of the \"support\" of a summation filter,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ·∂†</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>and the condition that <code>L ‚â§ atTop</code> implies ‚Äì indeed I think is equivalent to ‚Äì <code>support L = univ</code>. I'm pretty sure that the L-tsum for a finitely supported function is just the sum over nonzero values contained in <code>L.support</code>. </p>\n<p>If I've got this right, the support of Jireh's <code>map (Finset.mapEmbedding (.subtype (¬∑ ‚àà s))) atTop</code> is precisely <code>s</code>.)</p>",
        "id": 541511353,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758821512
    },
    {
        "content": "<p>aha, so maybe we can replace <code>L ‚â§ atTop</code> with <code>support f ‚â§ support L</code> to handle the special-casing for finite sums?</p>",
        "id": 541511871,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1758821711
    },
    {
        "content": "<p>Indeed <code>support f ‚â§ support L</code> does seem to be the right condition for <code>L</code> to give the \"obvious\" answer for finitely supported sums.</p>",
        "id": 541511981,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758821763
    },
    {
        "content": "<p>But this still adds further complication to the special-casing of finite sums, and I'm wondering how much we need this ‚Äì how often do we want to use <code>tsum</code> with finitely-supported sums valued in non-Hausdorff top spaces?</p>",
        "id": 541512265,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758821851
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541306909\">said</a>:</p>\n<blockquote>\n<p>It would be nice to cook up a definition of <code>tsum</code> such that, for this filter <code>L</code> equal to \"<code>atTop</code> on <code>s</code>\", if <code>f</code> has finite support on <code>s</code> then <code>tsum f L</code> is the sum of <code>f x</code> over <code>x</code> in the support of <code>f</code> inside <code>s</code>.</p>\n</blockquote>\n<p>I think to get this though, we want something like: if <code>(support f ‚à© support L).Finite</code>, then <code>finprod ((support L).indicator f)</code>.</p>",
        "id": 541512376,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1758821887
    },
    {
        "content": "<p>I think keeping the special casing is nice.</p>",
        "id": 541512488,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1758821924
    },
    {
        "content": "<p>Using <code>support f</code> also then needs us to add that the codomain of <code>f</code> has a zero. Do we also want to do this?</p>",
        "id": 541620698,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758878041
    },
    {
        "content": "<p>I may have been too hasty about <code>support</code>; the problem is that one can ask for which <code>b</code> we have <code>‚àÄ·∂† s in L, b ‚àà s</code>, and for which <code>b</code> we have <code>‚àÉ·∂† s in L, b ‚àà s</code>. These conditions are not always the same, and if they aren't, then our summation method is rather bizarre (e.g. finitely supported functions may not be summable).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">‚àÖ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">atTop</span>\n</code></pre></div>\n<p>on <code>Finset (Fin 1)</code> does not have a well-defined support, and not every function on the fintype <code>Fin 1</code> is summable w.r.t. this filter. I think we need to assume that filters used for summation have the following property:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚àÄ·∂†</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">filter</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚àÄ·∂†</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">filter</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚àâ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 541621296,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758878222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"389019\">Chris Birkbeck</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541620698\">said</a>:</p>\n<blockquote>\n<p>Using <code>support f</code> also then needs us to add that the codomain of <code>f</code> has a zero. Do we also want to do this?</p>\n</blockquote>\n<p>I think Jireh may have written <code>support</code> when he meant <code>mulSupport</code>. We only ever consider sums when the codomain has a zero, and products when the codomain has 1.</p>",
        "id": 541621592,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758878328
    },
    {
        "content": "<p>The definition of <code>tsum</code> should probably be something like: \"if <code>f</code> is not summable then 0; else, if <code>L</code> has a well-defined support (whatever that means) and the intersection of <code>support f</code> and <code>support L</code> is finite, then use the (finite) sum of <code>f</code> on this intersection; else, use some limit of the finite sums along the filter\". In this way, for nice filters and finitely supported functions you get what you want, and otherwise you always get a limit along the filter, which is still the primary requirement.</p>",
        "id": 541623537,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1758878941
    },
    {
        "content": "<p>Then we need to have some way of automatically inferring \"the support is well defined\" for the filters of interest (such as <code>atTop</code>). One option is to include this as a proof field for the <code>SummationFilter</code> structure; another is to make it a typeclass.</p>",
        "id": 541624611,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758879257
    },
    {
        "content": "<p>We would need a theorem saying that the <code>tsum</code> is equal to the finsum for finitely supported functions, and this would involve some assumptions on the filter <code>L</code> (that <code>L \\le atTop</code>, for instance). This assumption could be formulated as a typeclass, indeed, but it could also be a regular assumption with an opt_param <code>:= by exact le_rfl</code> to discharge it automatically for <code>atTop</code>.</p>\n<p>I'm not convinced that we need a <code>SummationFilter</code> class, since we want to drop both the <code>le_atTop</code> field to allow summation on subsets, and the <code>neBot</code> field because we can include it as a typeclass assumption whenever it's needed.</p>",
        "id": 541625970,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1758879683
    },
    {
        "content": "<p>I thought we should have a <code>SummationFilter</code> class mainly so we can have somewhere to put an explanatory doc-string ‚Äì so it looks less scary than just using <code>Filter (Finset _)</code> directly.</p>",
        "id": 541626303,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758879796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541625970\">said</a>:</p>\n<blockquote>\n<p>but it could also be a regular assumption with an opt_param <code>:= by exact le_rfl</code> to discharge it automatically for <code>atTop</code>.</p>\n</blockquote>\n<p>This doesn't work as well as it should, because <code>apply</code> doesn't play well with auto-params for proof arguments, cf. Kenny's mathlib-free MWE earlier in this thread (<a class=\"message-link\" href=\"/#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541260501\">#PR reviews &gt; #29602 Infinite conditional sums API @ üí¨</a> )</p>",
        "id": 541626803,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758879950
    },
    {
        "content": "<p>FWIW, if we want to pursue Sebastien's suggestion of allowing things like \"atTop along <code>s</code>\" for a subset <code>s</code>, we will need a more general statement than</p>\n<blockquote>\n<p>a theorem saying that the¬†<code>tsum</code>¬†is equal to the finsum for finitely supported functions, and this would involve some assumptions on the filter¬†<code>L</code>¬†(that¬†<code>L \\le atTop</code>, for instance)</p>\n</blockquote>\n<p>We would rather need the more general statement that whenever <code>L</code> has a well-defined support, the <code>tsum</code> is equal to the finsum <em>restricted to the support of <code>L</code></em>. I have a proof of this worked out now, but it is awkward to even state it without a <code>SummationFilter</code> class.</p>",
        "id": 541627625,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758880243
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541621296\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">‚àÖ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">atTop</span>\n</code></pre></div>\n<p>on <code>Finset (Fin 1)</code> does not have a well-defined support</p>\n</blockquote>\n<p>What do you mean?</p>",
        "id": 541629855,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758880967
    },
    {
        "content": "<p>To me \"¬†finsum¬†<em>restricted to the support of¬†<code>L</code></em>\" sounds like what we want to have.</p>",
        "id": 541629977,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758881004
    },
    {
        "content": "<p>oh I see that's</p>",
        "id": 541630146,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758881054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541629855\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541621296\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">‚àÖ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">atTop</span>\n</code></pre></div>\n<p>on <code>Finset (Fin 1)</code> does not have a well-defined support</p>\n</blockquote>\n<p>What do you mean?</p>\n</blockquote>\n<p>Consider the (unique) element of <code>Fin 1</code>, namely 0. Then neither <code>{s | 0 ‚àà s}</code> nor <code>{s | 0 ‚àâ s}</code> is in the filter, so 0 is sort of half-in and half-out of the support!</p>",
        "id": 541630649,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758881220
    },
    {
        "content": "<p>Yeah this is sort of weird but it does a well-defined thing when we use <code>HasSum</code> instead of <code>tsum</code></p>",
        "id": 541632228,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758881721
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541632228\">said</a>:</p>\n<blockquote>\n<p>Yeah this is sort of weird but it does a well-defined thing when we use <code>HasSum</code> instead of <code>tsum</code></p>\n</blockquote>\n<p>No, I don‚Äôt think it does.</p>",
        "id": 541632891,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758881935
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541632891\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541632228\">said</a>:</p>\n<blockquote>\n<p>Yeah this is sort of weird but it does a well-defined thing when we use <code>HasSum</code> instead of <code>tsum</code></p>\n</blockquote>\n<p>No, I don‚Äôt think it does.</p>\n</blockquote>\n<p>Why not</p>",
        "id": 541633307,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758882074
    },
    {
        "content": "<p>Aaron, what makes you think it does work? Please contemplate the <code>Filter.map</code> example I gave above; if the sequence has any sum, that sum must also be the limit along <code>atTop Nat</code> of the function on <code>Nat</code> sending even numbers to <code>f 0</code> and odd numbers to <code>1</code>. So if <code>f 0 \\ne 1</code> (and the target space is Hausdorff) no limit can exist.</p>",
        "id": 541636093,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758883016
    },
    {
        "content": "<p>yes that makes sense to me</p>",
        "id": 541636236,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758883064
    },
    {
        "content": "<p>do you have a problem with that</p>",
        "id": 541636356,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758883099
    },
    {
        "content": "<p>sequences not having a sum is not strange</p>",
        "id": 541636509,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758883157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541636356\">said</a>:</p>\n<blockquote>\n<p>do you have a problem with that ... sequences not having a sum is not strange</p>\n</blockquote>\n<p>Aaron, I remind you of the context: we were attempting to define \"support\" of a filter <code>L</code> on <code>Finset _</code> in such a way that for every finite set <code>S</code> and every function <code>f</code> that is <del>zero</del> one outside <code>S</code>, then <code>f</code> is L-<del>summable</del> multipliable with product <code>‚àè b ‚àà S ‚à© L.support, f b</code> (finite product since <code>S</code> is finite). The example above shows that there exist summation filters which do not have a well-defined support in this sense.</p>",
        "id": 541641157,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758884605
    },
    {
        "content": "<p>Well I guess working with the finsets directly gives you a lot of freedom</p>",
        "id": 541641848,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758884862
    },
    {
        "content": "<p>If you have a <code>T1Space</code> then you don't have to worry about this and you don't seem to think <code>T2Space</code> is a lot of assumptions</p>",
        "id": 541642295,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758885054
    },
    {
        "content": "<p>This isn't about separation axioms. We're trying to justify the claim that, in the situation I just explained, the proposition <code>HasProd f (‚àè b ‚àà S ‚à© L.Support, f b) L</code> holds. [Edit: muddled sums and products; corrected]</p>\n<p>Separation axioms are only needed if you want to claim that <code>HasProd f c L</code> holds <em>if and only if</em> <code>c =  ‚àè b ‚àà S ‚à© L.support, f b</code>. But I am not talking about the \"only if\" direction here, I am talking about the \"if\" direction.</p>",
        "id": 541644869,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758886065
    },
    {
        "content": "<p>Oh that's completely impossible</p>",
        "id": 541645333,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758886238
    },
    {
        "content": "<blockquote>\n<p>Oh that's completely impossible</p>\n</blockquote>\n<p>Well, it needs more assumptions on the filter; that's exactly the point. I have a proof that it does work for all filters satisfying the condition I wrote down, namely <code>‚àÄ (b : Œ≤), (‚àÄ·∂† s in filter, b ‚àà s) ‚à® (‚àÄ·∂† s in filter, b ‚àâ s)</code>.</p>",
        "id": 541645633,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758886354
    },
    {
        "content": "<p>so what will you do with that assumption</p>",
        "id": 541645872,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758886438
    },
    {
        "content": "<p>I hope you won't just assume it everywhere</p>",
        "id": 541645905,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758886449
    },
    {
        "content": "<p>Well, why not? It's satisfied for <code>atTop</code>; it's satisfied for the \"atTop along a subset\" filter discussed above; and it's satisfied for the filters corresponding to conditional summation on <code>Nat</code>, symmetric and asymmetric conditional summation on <code>Int</code>, etc. What do you have against it?</p>",
        "id": 541646249,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758886553
    },
    {
        "content": "<p>Not preserved by maps</p>",
        "id": 541646501,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758886639
    },
    {
        "content": "<p>Explain?</p>",
        "id": 541646539,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758886650
    },
    {
        "content": "<p>You can map filters</p>",
        "id": 541647112,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758886854
    },
    {
        "content": "<p>mapping doesn't preserve the condition</p>",
        "id": 541647155,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758886867
    },
    {
        "content": "<p>The definition of <code>tsum</code> will be: \"if <code>L</code> satisfies David's condition and the function has finite support inside the support of <code>L</code>, then use the finite sum over this finite support. Otherwise, take any limit along <code>L</code>\". Then there will be a theorem that, if <code>f</code> is summable, then it satisfies <code>HasSum f L (tsum f L)</code>. So most theorems won't involve the condition, only those talking about the coincidence between finite sums and tsums.</p>",
        "id": 541648280,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1758887261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541647155\">said</a>:</p>\n<blockquote>\n<p>You can map filters [...] mapping doesn't preserve the condition</p>\n</blockquote>\n<p>I'm aware that one can map filters; and I have a proof that mapping along <em>embeddings</em> does preserve the condition. On the other hand, mapping along arbitrary maps doesn't seem to be a reasonable thing to expect here: if <code>g</code> is not injective, there is no relation between the sum of <code>f ‚àò g</code>and the sum of <code>f</code> over the range of <code>g</code>.</p>",
        "id": 541648698,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758887413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541648698\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541647155\">said</a>:</p>\n<blockquote>\n<p>You can map filters [...] mapping doesn't preserve the condition</p>\n</blockquote>\n<p>I'm aware that one can map filters; and I have a proof that mapping along <em>embeddings</em> does preserve the condition. On the other hand, mapping along arbitrary maps doesn't seem to be a reasonable thing to expect here: if <code>g</code> is not injective, there is no relation between the sum of <code>f ‚àò g</code>and the sum of <code>f</code> over the range of <code>g</code>.</p>\n</blockquote>\n<p>Oh I didn't realize yeah that is true</p>",
        "id": 541650006,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758887839
    },
    {
        "content": "<p>Ok so what is the status now? I'm guessing we want <code>‚àÄ (b : Œ≤), (‚àÄ·∂† s in filter, b ‚àà s) ‚à® (‚àÄ·∂† s in filter, b ‚àâ s)</code> to have a name, so should we make it a class and then just assume this where needed and then get rid of <code>SummationDirection</code>? or alternatively, keep <code>SummationDirection</code> and add it there.</p>",
        "id": 541655868,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758889594
    },
    {
        "content": "<p>I'm working on a draft, give me a moment <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 541662160,
        "sender_full_name": "David Loeffler",
        "timestamp": 1758891405
    },
    {
        "content": "<p>thanks!</p>",
        "id": 541663103,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1758891639
    },
    {
        "content": "<p>I opened a new thread <a class=\"stream-topic\" data-stream-id=\"144837\" href=\"/#narrow/channel/144837-PR-reviews/topic/.2329914.20Infinite.20conditional.20sums.20API.20.28redux.29/with/541837734\">#PR reviews &gt; #29914 Infinite conditional sums API (redux)</a> since the original PR has now been overtaken.</p>",
        "id": 541837840,
        "sender_full_name": "David Loeffler",
        "timestamp": 1759005997
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541626803\">said</a>:</p>\n<blockquote>\n<p>This doesn't work as well as it should, because <code>apply</code> doesn't play well with auto-params for proof arguments, cf. Kenny's mathlib-free MWE earlier in this thread (<a class=\"message-link\" href=\"/#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/541260501\">#PR reviews &gt; #29602 Infinite conditional sums API @ üí¨</a> )</p>\n</blockquote>\n<p>filed as a bug under <a href=\"https://github.com/leanprover/lean4/pull/10681\">lean#10681</a> (please upvote if you want to see this fixed)</p>",
        "id": 543267706,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1759744756
    },
    {
        "content": "<p>I'm late to the infinite conditional sums \"party\"; it just came up in my real analysis class (we were proving <a href=\"https://en.wikipedia.org/wiki/Riemann_series_theorem\">Riemann's rearrangement theorem</a> and I realized I couldn't state it with mathlib definitions because <code>tsum</code>s essentially need absolute convergence). Do we have a proof of this theorem, or is this perhaps something someone might be working on? I was curious to see how others might approach it...</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">Topology</span><span class=\"w\"> </span><span class=\"n\">Finset</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ConvergesTo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Tendsto</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">atTop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ùìù</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ConditionallyConvergent</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ConvergesTo</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">|</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">riemann_rearrangement</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ConditionallyConvergent</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ConvergesTo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Thanks!</p>",
        "id": 555677506,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1763154174
    },
    {
        "content": "<p>There was a refactor and now we have sums with conditional convergence</p>",
        "id": 555682046,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763156318
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasSum#doc\">docs#HasSum</a></p>",
        "id": 555682054,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763156323
    },
    {
        "content": "<p>Yes so I <em>think</em> you'd state the result as: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">riemann_rearrangement'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SummationFilter</span><span class=\"bp\">.</span><span class=\"n\">conditional</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SummationFilter</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"bp\">.</span><span class=\"n\">NeBot</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\">  </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 555682305,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1763156435
    },
    {
        "content": "<p>hmm although I am not sure how you get your permutation back...</p>",
        "id": 555682777,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1763156666
    },
    {
        "content": "<p>I see, thanks! Do we have this theorem in the library? (The permutation version seems quite challenging to me, to formalize the proof in my head...)</p>",
        "id": 555686200,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1763158318
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"389019\">Chris Birkbeck</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/555682777\">said</a>:</p>\n<blockquote>\n<p>hmm although I am not sure how you get your permutation back...</p>\n</blockquote>\n<p>You don't, setting <code>œÉ</code> to be the bottom filter gives you convergence to every limit simultaneously so your statement is sort of empty</p>",
        "id": 555688370,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763159532
    },
    {
        "content": "<p>Ah good point, how could I forget this bot filter!</p>",
        "id": 555688492,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1763159613
    },
    {
        "content": "<p>How about now?</p>",
        "id": 555688606,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1763159680
    },
    {
        "content": "<p>Still no good</p>",
        "id": 555688665,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763159712
    },
    {
        "content": "<p>Summation filters is just a filter with no conditions imposed, there's nothing forcing it to be a permutation of the conditional summaton filter</p>",
        "id": 555688714,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763159751
    },
    {
        "content": "<p>do you understand how filters encode convergence? I can explain it if you want</p>",
        "id": 555688752,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763159773
    },
    {
        "content": "<p>Yeah thats what I was worried about. I'm not sure how to get the permutation back or at least I don't know how to easily encode this into the summation filter, but I've not though about this much.</p>",
        "id": 555688808,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1763159812
    },
    {
        "content": "<p>Just use a permutation</p>",
        "id": 555688893,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763159860
    },
    {
        "content": "<p>don't change the summation filter</p>",
        "id": 555688904,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763159870
    },
    {
        "content": "<p>summation filter doesn't have a permutation inside</p>",
        "id": 555688953,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763159901
    },
    {
        "content": "<p>Ah ok, maybe this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">riemann_rearrangement'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SummationFilter</span><span class=\"bp\">.</span><span class=\"n\">conditional</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SummationFilter</span><span class=\"bp\">.</span><span class=\"n\">conditional</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 555689079,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1763159975
    },
    {
        "content": "<p>almost</p>",
        "id": 555689171,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763160021
    },
    {
        "content": "<p>would be great if it was true</p>",
        "id": 555689190,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763160039
    },
    {
        "content": "<p>unfortunately the statement you have is false</p>",
        "id": 555689207,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763160049
    },
    {
        "content": "<p>You need to assume <code>¬¨ Summable f</code>.</p>",
        "id": 555689209,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1763160052
    },
    {
        "content": "<p>you need to exclude unconditionally summable functions</p>",
        "id": 555689235,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763160067
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">riemann_rearrangement</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">|</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SummationFilter</span><span class=\"bp\">.</span><span class=\"n\">conditional</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SummationFilter</span><span class=\"bp\">.</span><span class=\"n\">conditional</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 555689254,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763160078
    },
    {
        "content": "<p>This one isn't good either</p>",
        "id": 555689285,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763160103
    },
    {
        "content": "<p>This is a version that you would see in calculus.</p>",
        "id": 555689301,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763160117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329602.20Infinite.20conditional.20sums.20API/near/555689235\">said</a>:</p>\n<blockquote>\n<p>you need to exclude unconditionally summable functions</p>\n</blockquote>\n<p>Oops yes I forgot that bit from Alex's post.</p>",
        "id": 555689308,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1763160121
    },
    {
        "content": "<p>I can diverge to infinity without giving you any negative terms to go back down</p>",
        "id": 555689310,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763160123
    },
    {
        "content": "<p>oh, sure, sorry</p>",
        "id": 555689326,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763160134
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">riemann_rearrangement</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚äî</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚äì</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SummationFilter</span><span class=\"bp\">.</span><span class=\"n\">conditional</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 555689629,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763160321
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">riemann_rearrangement'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SummationFilter</span><span class=\"bp\">.</span><span class=\"n\">conditional</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hf'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">conditional</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 555689653,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1763160340
    },
    {
        "content": "<p>Yeah, from Etienne's you first prove the hypotheses in my theorem, and then from my two hypothesis, you construct the nonnegative and negative subsequences of <code>f</code>, each of which has sum diverging to infinity.</p>",
        "id": 555689913,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763160494
    },
    {
        "content": "<p>It's a bit fiddly because you have to deal with the zeros, as you would really prefer to have nonincreasing sequences.</p>",
        "id": 555690090,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763160606
    },
    {
        "content": "<p>There's also a complex version of this, but it's significantly harder to state.</p>",
        "id": 555690194,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763160669
    },
    {
        "content": "<p>I did actually use this result in a paper once, surprisingly enough.</p>",
        "id": 555690390,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763160756
    },
    {
        "content": "<p>There's a more general vector version (<a href=\"https://en.wikipedia.org/wiki/L%C3%A9vy%E2%80%93Steinitz_theorem\">Levy-Steinitz</a>): the set of limit points of rearrangements (if any) is homogeneous (in fact, the translate of a linear subspace). Would the new API allow for a clean statement (perhaps even proof) of this?...</p>",
        "id": 555712552,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1763181469
    },
    {
        "content": "<p>Indeed, it's actually not as bad as I imagined. This is a statement of L√©vy-Steinitz:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Equiv</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">levy_steinitz</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SummationFilter</span><span class=\"bp\">.</span><span class=\"n\">conditional</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hf'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AffineSubspace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">conditional</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 555740651,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763209244
    },
    {
        "content": "<p>I think you can probably drop one of those assumptions</p>",
        "id": 555740776,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763209377
    },
    {
        "content": "<p>(do you really need <code>hf</code>)?</p>",
        "id": 556601842,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763209395
    },
    {
        "content": "<p>(also, do you really need <code>hf'</code>)?</p>",
        "id": 556601875,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763209432
    },
    {
        "content": "<p>You have to avoid the set being empty, so I think you need <code>hf</code>, but indeed, I think you can drop <code>hf' : ¬¨ Summable f</code>.</p>",
        "id": 556601959,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763209537
    },
    {
        "content": "<p>Affine subspaces can be empty</p>",
        "id": 556602005,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763209587
    },
    {
        "content": "<p>ah, right. That always messes with my intuition. Sure, then I think you can drop both.</p>",
        "id": 556602130,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763209711
    },
    {
        "content": "<p>It's better that way since then affine subspaces are a complete lattice</p>",
        "id": 556602145,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763209733
    },
    {
        "content": "<p>Probably this is even better as a <code>def</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"w\">  </span><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"w\">  </span><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Equiv</span>\n\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">levy_steinitz</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AffineSubspace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">conditional</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)}</span>\n<span class=\"w\">    </span><span class=\"n\">smul_vsub_vadd_mem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 556602239,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763209833
    },
    {
        "content": "<p>Thanks Aaron for helping get the cleanest statement.</p>",
        "id": 556602315,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763209908
    },
    {
        "content": "<p>Nice! How far are we from being able to prove it in Mathlib?...</p>",
        "id": 556708838,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1763321018
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252920\">@Alex Kontorovich</span> <a href=\"https://arxiv.org/abs/1711.04136\">this paper</a> has a nice argument. It's all doable now, but the proof is nontrivial, so it's a bit of work.</p>",
        "id": 556720525,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763333287
    },
    {
        "content": "<p>Prompted by <span class=\"user-mention\" data-user-id=\"252920\">@Alex Kontorovich</span> 's Real Analysis course, I did a formalization of the usual proof of the Conditional Convergence Theorem for real sequences (I think it actually works for linearly ordered rings) from first principles (i.e., without using Mathlib's filters). It is in a reasonable state, but can certainly be improved a bit. The code is <a href=\"https://github.com/MichaelStollBayreuth/JacobiSum/blob/main/JacobiSum/ConditionalConvergence.lean\">here</a> (~700 loc).</p>",
        "id": 560991659,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1764502441
    }
]