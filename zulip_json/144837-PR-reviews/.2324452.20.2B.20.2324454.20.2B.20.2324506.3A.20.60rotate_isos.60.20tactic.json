[
    {
        "content": "<p>I just contributed a series of two PRs that brings a <code>rotate_isos</code> tactic to the category theory part of the library. It provides both a tactic and a term elaborator to easily move around terms that are invertible in equalities of possibly lengthy strings of morphisms in categories. <br>\nFor instance, out of a term of type <code>f â‰ªâ‰« g â‰ªâ‰« h = f' â‰ªâ‰« g' â‰ªâ‰« h'</code>, it generates equalities like <br>\n<code>h  â‰ªâ‰« h'.symm =g.symm â‰ªâ‰« f.symm â‰ªâ‰«  f' â‰ªâ‰« g'</code>, or <code>f â‰ªâ‰« g = f' â‰ªâ‰« g' â‰ªâ‰« h' â‰ªâ‰« h.symm</code></p>\n<p>It can also generate lemmas like : </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">rotate_isos</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"o\">)))))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"bp\">â‰«</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">ğŸ™</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which can be given to <code>simp</code> to ease some automation calls, or to <code>rw</code> if one wants manual rewriting. You can see more example and usages in the <a href=\"https://github.com/leanprover-community/mathlib4/blob/c974f2e94a8c740048e326691d621aff6865f6e4/MathlibTest/CategoryTheory/RotateIsos.lean\">test suite</a>.</p>",
        "id": 515096844,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1745940518
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/24452\">#24452</a> provides some boilerplate lemmas and abstraction to infer that some expressions are expressions of isomorphisms in categories, and to construct their inverse as well as the lemmas needed to move them around.</p>",
        "id": 515097077,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1745940587
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/24454\">#24454</a> contains the actual core of the tactic, and provides some tests.</p>",
        "id": 515097243,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1745940622
    },
    {
        "content": "<p>(it seems CI currently has an issue: it fails saying lake is not available...)</p>",
        "id": 515097478,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1745940692
    },
    {
        "content": "<p>(Also, a disclaimer for the reviewers: I am a metaprogramming newbie. There is potentially a lot of details and idioms that I am not aware of, Iâ€™d really appreciate feedback on the overall code/design choice/way of handling things.)</p>",
        "id": 515103266,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1745942240
    },
    {
        "content": "<p>I cannot have a look right now, but this seems very useful. Last week, <span class=\"user-mention\" data-user-id=\"648495\">@Christian Merten</span> and I spent some time rotating lemmas <a href=\"https://github.com/leanprover-community/mathlib4/pull/24384/files#diff-318498b28b00af779bbc95ab49cb489823d97aeafb301b617ab2577c0abeefceR87-R127\">https://github.com/leanprover-community/mathlib4/pull/24384/files#diff-318498b28b00af779bbc95ab49cb489823d97aeafb301b617ab2577c0abeefceR87-R127</a></p>",
        "id": 515110694,
        "sender_full_name": "JoÃ«l Riou",
        "timestamp": 1745944293
    },
    {
        "content": "<p>Sadly, in the cases you linked, there will be some extra work needed on my end on the tactic to make it simplify e.g <code>(F.map fâ‚€â‚ â— (F.mapComp' fâ‚â‚‚ fâ‚‚â‚ƒ fâ‚â‚ƒ hâ‚â‚ƒ)).hom</code> to <code>F.map fâ‚€â‚ â— (F.mapComp' fâ‚â‚‚ fâ‚‚â‚ƒ fâ‚â‚ƒ hâ‚â‚ƒ).hom</code> (ideally, whatever the tactic generates should try to be as close as possible to the \"categorical normal form\"), it should still recognize the latter as an isomorphism, as I believe an <code>IsIso</code> instance will be infered, but then its inferred inverse will be the generic <code>inv (F.map fâ‚€â‚ â— (F.mapComp' fâ‚â‚‚ fâ‚‚â‚ƒ fâ‚â‚ƒ hâ‚â‚ƒ))</code>.<br>\nI thought about implementing this kind of thing, but I did not want to force importing monoidal or bicategorical stuff transitively for using the tactic. <br>\nBut I realize that to make it extra nice there should be a way to register some \"extra\" cancellable patterns (e.g <code>x â— Î±.hom</code>, which is not currently recognized as \"a functor applied to hom of an iso)).<br>\nThere is probably a suboptimal design on my end that this is not readily possible.<br>\nIâ€™ll think about it, and am open to suggestions by meta gurus on how to achieve this in both a maintainable and readable way.</p>",
        "id": 515113875,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1745945277
    },
    {
        "content": "<p>(since implementing this will probably involve some refactor in the <code>Cancelable</code> structure to be more flexible, Iâ€™ll convert both PR to drafts for now, at least for the time that I think about how to do this, but Iâ€™m still very much open to comment on the tactic and on the code!)</p>",
        "id": 515118026,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1745946176
    },
    {
        "content": "<p>As I said earlier, I'm skeptical this should be done by custom tactics when <code>grind</code> will shortly be available.</p>",
        "id": 515160159,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1745961775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2324452.20.2B.20.2324454.3A.20.60rotate_isos.60.20tactic/near/515160159\">said</a>:</p>\n<blockquote>\n<p>As I said earlier, I'm skeptical this should be done by custom tactics when <code>grind</code> will shortly be available.</p>\n</blockquote>\n<p><code>grind</code> intends to be a \"one-call, prove it all\" kind of tactic like <code>aesop_cat</code>, right?<br>\nI understand that it will be able to solve much more goals, but I also fear there will be times where <code>grind</code> will fail, and where manual <code>simp</code> calls or rewriting will be necessary, and in these cases I believe \"single-purposes\" tactics like this might be useful. <br>\nOf course you can do <code>have ... := by grind</code>, <code>suffices ... by grind</code> and likes, but when <code>...</code> might be a rather long and complicated string of compositions youâ€™d have to copy-paste, Iâ€™m not sure itâ€™s that much of a win.</p>\n<p>This tactic and the terms elaborator are <em>not</em> intended to be used for \"easy\" goals like <code>I.map (H.map (G.map (F.map f.hom))) â‰« I.map (H.map (G.map (F.map f.inv))) = ğŸ™ _</code> that are easily closed by a simple <code>call</code> simp already, but rather as ways to generate intermediate steps and terms to help <code>simp</code> calls that get stuck and that would loop if you were to add <code>[â† Functor.map_comp] </code> to their simp set, much like the <code>reassoc_of%</code> elaborator which  is very, <em>very</em> useful.</p>",
        "id": 515162443,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1745962798
    },
    {
        "content": "<p>The code for the \"Cancelable\" structure has been refactored in a way that allows more easy registration of new lemmas. The series is now made of 3 PRs. The first PR is now fully about the <code>Cancelable</code> (to be fair, Iâ€™m not fully satisfied by that name, but I donâ€™t know any better... perhaps just \"Invertible\"?)  structure, and the PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/24506\">#24506</a> takes care of registering an initial set of ways to recognize invertible morphisms (so far, these are only the ones from the original PR series).<br>\nIâ€™ll take some time within a few days to add files that register lemmas in monoidal and bicategorical contexts, but this can now be done in a way that leaves the core code of the tactic unchanged.</p>",
        "id": 515494671,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1746101705
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/24634\">#24634</a> Extends the tactic to monoidal contexts. With this as well as <code>reassoc_of%</code>, lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Bicategory.pentagon_inv_inv_hom_hom_inv_assoc#doc\">docs#CategoryTheory.Bicategory.pentagon_inv_inv_hom_hom_inv_assoc</a> can be generated purely in term mode.</p>",
        "id": 516451618,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1746539688
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/24633\">#24633</a> is similar for bicategorical contexts.</p>",
        "id": 516451768,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1746539731
    }
]