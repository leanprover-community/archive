[
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/24122\">#24122</a> is a definition of multigraphs, with API for incidence, adjacency and extensionality - this is a result of a conversation with <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>. </p>\n<p>The definition use a <code>Matroid</code>-like design with the vertex and edge sets as <code>Set</code>s rather than types. This will allow minors, subgraphs etc to have the same type as a graph itself, and I growing convinced that many complicated proofs in graph theory will get bogged down in DTT hell if they can't do this.</p>",
        "id": 512678847,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744834657
    },
    {
        "content": "<p>Just giving this a bump - I think it would be good to finally have this definition in mathlib.</p>",
        "id": 516279072,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746473079
    },
    {
        "content": "<p>I wrote a comment to express that I am not sure that this is a good definition.</p>",
        "id": 516372349,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1746517535
    },
    {
        "content": "<p>Unless I am mistaken, the approach proposed by Serre in his book <em>Trees</em> is more flexible and, importantly, leads to a combinatorial object which is related with topological structures such as CW-complexes ‚Äî¬†In particular, it allows (multi)graphs to have a topological realization, while I'm not sure this one does. It builds on the notion of quiver (whose edges are arrows, hence oriented) by adding a fixed point free involution on edges that exchanges source and tail.</p>",
        "id": 516396128,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1746524290
    },
    {
        "content": "<p>I haven‚Äôt thought hard about the tradeoffs involved in having two copies of each edge, but the existing definition in the PR certainly allows topological realizations. They would be maps <code>f: (h : G.Inc2 e u v) -&gt; A</code>, where <code>A</code> is a type of arcs in a topological space, combinatorial map, or similar, and <code>f h = f h.symm</code></p>",
        "id": 516406076,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746527193
    },
    {
        "content": "<p>A disadvantage of including a function or functions in the definition of a graph is that it makes it harder for the vertices and edge sets to be <code>Set</code>s, and so the subgraphs of G have to have a different type from G itself.</p>",
        "id": 516408326,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746527821
    },
    {
        "content": "<p>The example of a loop is the simplest example where the notions differ, and it should say why Serre's notion is better.</p>\n<p>In your sense, a loop is a multigraph with one vertex and one edge. My impression it has no nontrivial automorphism. </p>\n<p>In Serre's description, it is given by one vertex, two edges, which are exchanged by the involution. It has two automorphisms.</p>",
        "id": 516410011,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1746528358
    },
    {
        "content": "<p>Why is that better? I would say a loop (as a multigraph) has exactly one automorphism.</p>",
        "id": 516410228,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746528428
    },
    {
        "content": "<p>Because the topological realization has two automorphisms.</p>",
        "id": 516410298,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1746528459
    },
    {
        "content": "<p>And why is that an essential feature of the definition of a graph itself?</p>",
        "id": 516410422,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746528494
    },
    {
        "content": "<p>Having two copies of every edge is a complication from many other perspectives.</p>",
        "id": 516410783,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746528614
    },
    {
        "content": "<p>Because it is a feature of mathematics developed in the second part of 20th century that topological notions can be described as faithfully as possible by combinatorial structures. Can one define the fundamental group of a multigraph in your sense?</p>",
        "id": 516411087,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1746528710
    },
    {
        "content": "<p>I don‚Äôt know. But again, that‚Äôs not what motivates most graph theorists doing graph theory today.</p>",
        "id": 516411271,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746528762
    },
    {
        "content": "<p>(Serre's notion has been tailored to allow the description of graphs of groups, HNN extensions, etc.)</p>",
        "id": 516411313,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1746528771
    },
    {
        "content": "<p>Graphs are not (primarily) combinatorial gadgets that one uses to study algebra and topology.</p>",
        "id": 516411523,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746528833
    },
    {
        "content": "<p>The immensity of seemingly analogous notions in graph theory, each of them requiring a new name, seems to me a sign that they are not appropriate to formalization in a monolithic system. On the other side, there are two notions (quivers  and graphs) and all other notions can be seen as fitting in.</p>",
        "id": 516411943,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1746528960
    },
    {
        "content": "<p>This seems like saying ‚Äòmathlib should not include the graph theory that is done by graph theorists‚Äô.</p>",
        "id": 516412138,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746529023
    },
    {
        "content": "<p>No, it says ‚Äúmathlib should not include the <em>formalization</em> of graph theory done by graph theorists‚Äù, because this will force to multiplication of closely related structures and API.</p>",
        "id": 516412313,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1746529081
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2324122.20Multigraphs/near/516410298\">said</a>:</p>\n<blockquote>\n<p>Because the topological realization has two automorphisms.</p>\n</blockquote>\n<p>i'm not terribly familiar with this subject, but isn't this only if you consider directed realizations? which is to say, precisely because you consider two paths different when you reverse the direction, it doesn't correspond to a multigraph, but instead a directed multigraph with all inverse edges?</p>",
        "id": 516413716,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1746529486
    },
    {
        "content": "<p>The definition of a quiver has existed in mathlib for a while, and this has not led to the formalization of any results of interest to graoh theorists. A multigraph is not ‚Äòjust a type of quiver‚Äô in the same way that a simple graph is not ‚Äòjust a symmetric relation‚Äô. </p>\n<p>I‚Äôve been a graph theorist (or at least closely adjacent) for my whole career, and I had not heard the word ‚Äòquiver‚Äô to describe a graph-like object before encountering mathlib. </p>\n<p>The graph theory that graph theorists do is its own large area of maths, that is different in its obsessions and motivating questions from what people interested in quivers do. Forcing one perspective on the other is unreasonable.</p>",
        "id": 516414519,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746529709
    },
    {
        "content": "<p>I agree that we need to have several formalizations of graphs: depending on what kind of theorem one wants to formalize, different implementations can really make a difference, especially regarding DTT hell. If we need in the end to transfer results from one formalism to the other, then so be it. It really looks like an area where there is no \"one size fits all\" approach.</p>\n<p>For instance, Serre's approach would probably lead to a nightmare if you try to prove Robertson-Seymour with it.</p>",
        "id": 516416364,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1746530298
    },
    {
        "content": "<p>It's not ‚Äúone size fits all‚Äù, is that one can choose to have two basic types, and various properties on them, or a multitude of basic types consisting of all possible notions that arise in practice. When one opens a basic graph theory book (I just checked in one of them), there is a permanent ambiguity on terminology with sentence such as the Cayley graph which is ‚Äúdirected multigraph‚Äù, or variants of theorems which are evoked but not proved. A convenient formalization of the structure will avoid all that.</p>",
        "id": 516420046,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1746531402
    },
    {
        "content": "<p>Serre‚Äôs is not convenient for graph theory if loops have nontrivial automorphisms.</p>",
        "id": 516420235,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746531468
    },
    {
        "content": "<p>I think my resistance is to the notion that arcs are a 'basic type' for undirected graphs. They really aren't, and this shows in the relationship between digraphs and graphs. </p>\n<p>For instance, for some problems, you have a directed graph, perhaps with multiple arcs in both directions between a pair of vertices, and you want to turn it into an undirected graph by forgetting the edge directions. With Serre's definition, this corresponds to <em>adding</em> data (synthetically producing a new inverse arc for each existing arc). But mathematically, we are removing data. This would be a pain to work with if one were doing anything set-theoretic, and frequently graph theorists are doing things that are set-theoretic.</p>",
        "id": 516427303,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746533392
    },
    {
        "content": "<p>Kyle's post¬†here contains a similar comment :  <a class=\"message-link\" href=\"/#narrow/channel/252551-graph-theory/topic/What.20kind.20of.20graphs.20are.20in.20Mathlib.20already.3F/near/508810658\">#graph theory &gt; What kind of graphs are in Mathlib already? @ üí¨</a></p>",
        "id": 516427611,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746533474
    },
    {
        "content": "<p>Just a remark inspired by the thread that you just linked to: in the handshaking lemma, as explained in <a href=\"https://en.wikipedia.org/wiki/Handshaking_lemma\">Wikipedia</a>, one has to decide that the loop counts twice, but with Serre's definition this comes naturally.</p>",
        "id": 516778605,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1746658435
    },
    {
        "content": "<p>This also comes naturally with Peter's definition, as mentioned in that thread</p>",
        "id": 516779389,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1746658863
    },
    {
        "content": "<p><a href=\"https://github.com/apnelson1/Matroid/blob/f3bf23c65c0b788adec2151a00e14c208f1f733a/Matroid/Graph/Basic.lean\">This permalink</a> is to a file where the handshake lemma is the simple double-counting proof it should be, with no special-casing for loops. </p>\n<p>(The only non-mathlib dependency¬†is to do with summing <code>ENat</code>s and is not hiding anything graph-theoretic).</p>",
        "id": 516779957,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746659195
    },
    {
        "content": "<p>(The definition of a graph used there is not the same one as in the PR, but the data is the same).</p>",
        "id": 516780064,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746659269
    },
    {
        "content": "<p>I've now changed a bunch of things as per the new bikeshed threads: </p>\n<ul>\n<li><code>Inc‚ÇÇ</code> has been changed to <code>IsLink</code></li>\n<li>The edge type has been changed from <code>Œµ</code> back to <code>Œ≤</code></li>\n<li>the vertex and edge sets are now <code>G.vertexSet</code> and <code>G.edgeSet</code>, with scoped notations <code>V(G)</code> and <code>E(G)</code>.</li>\n</ul>",
        "id": 517251432,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746877131
    },
    {
        "content": "<p>The one potentially unresolved thing is the <code>IsLink</code> name - <a href=\"#narrow/channel/287929-mathlib4/topic/Multigraph.20notation.20-.20naming.20poll/with/516927036\">the poll</a> is basically a tie. <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  hasn't voted and suggested <code>Links</code> in the PR comments.</p>",
        "id": 517252336,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746877987
    },
    {
        "content": "<p>There is <a href=\"https://github.com/leanprover-community/mathlib4/pull/24122#discussion_r2083519481\">another design point</a> where <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> and I disagree - I would like the edge set to be a structure field for nicer defeqs, even though it can be inferred from the incidence predicate. Would be interested to hear others‚Äô views on this.</p>",
        "id": 517373561,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746979317
    },
    {
        "content": "<p>See also <a href=\"https://github.com/leanprover-community/mathlib4/pull/24122#discussion_r2075243771\">the comment here</a> which started the discussion. The defeqs I‚Äôm talking about are things like <code>rfl: (G.edgeDelete F).E = G.E \\ F</code></p>",
        "id": 517373870,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746979543
    },
    {
        "content": "<p>Just to be clear, is the claim that the defeq is nice because it makes proving <code>E_edgeDelete : (G.edgeDelete F).E = G.E \\ F</code> easier (at the cost of making defining <code>edgeDelete</code> harder)? Or that it's nice because downstream code doesn't need to <code>rw [E_edgeDelete]</code> / can use <code>dsimp</code> instead of <code>simp</code>?</p>",
        "id": 517374122,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746979722
    },
    {
        "content": "<p>It means that if <code>h : e in G.edgeDelete F</code>, then <code>h.1</code> and <code>h.2</code> are useful terms.</p>",
        "id": 517374530,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746980013
    },
    {
        "content": "<p>Making use of that feels like a code smell, though</p>",
        "id": 517375847,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1746981001
    },
    {
        "content": "<p>We are certainly guilty of using that style instead of calling out to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.mem_inter_iff#doc\">docs#Set.mem_inter_iff</a>, but we seem to survive ok with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.mem_inter_iff#doc\">docs#Finset.mem_inter_iff</a></p>",
        "id": 517375962,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746981067
    },
    {
        "content": "<p>This was never a question of survival.</p>",
        "id": 517375978,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746981089
    },
    {
        "content": "<p>The design will call for frequent proof obligations like <code>e ‚àà E(G.edgeDelete F)</code> when invoking lemmas. This is the difference between using <code>(mem_edgeDelete_edgeSet_iff.mpr ‚ü®heE, heF‚ü©)</code> for all of them, vs just <code>‚ü®heE, heF‚ü©</code>.</p>",
        "id": 517376285,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1746981324
    },
    {
        "content": "<p>Thanks for the extra context. I'll ping <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> and <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, both of whom I think have expressed opinion about defeqs in the past.</p>",
        "id": 517376447,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746981437
    },
    {
        "content": "<p>I'm torn about this one. Having E as an explicit field is mathematically more natural, and having defeqs for it is valuable. On the other hand, we shouldn't be overly reliant on defeqs, and E is redundant, and I usually err on the side of having a more straightforward constructor (even though here we do have the alternate constructor available). My gut feeling is to keep E as a field, provided it's clearly documented, since we have the constructor  and ext lemma which avoids it, and makes more sense on paper.</p>",
        "id": 517388722,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1746991082
    },
    {
        "content": "<p>I'm being pinged but I don't know the first thing about design decisions in graph theory. I'm with Antoine on the edge question but that's because I've used Serre's book in my own work (to understand groups acting on the upper half plane) whereas I strongly suspect that Peter uses multigraphs in a very different way (he mutates them and I don't), and I have nothing to say about that which Antoine didn't already say. My instinct here is basically: if nobody has a project which uses multigraphs then all our arguments are just hot air, and if someone has a project which uses them then they should probably be making the decisions and dealing with the consequences. But this reflects my general attitude towards Lean: we made schemes 3 times before they made it into mathlib because of my \"just have a go\" attitude, whereas there are other people who care a lot more about getting it right the first time.</p>",
        "id": 517394519,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746995885
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2324122.20Multigraphs/near/517394519\">said</a>:</p>\n<blockquote>\n<p>(he mutates them and I don't)</p>\n</blockquote>\n<p>I think this hits the nail on the head. </p>\n<p>(I say this with all due respect for the type of applications of graphs that don‚Äôt mutate them.)</p>",
        "id": 517399218,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1747000136
    },
    {
        "content": "<p>I also see the advantages of Serre‚Äôs definition even for my kind of maths, where groups sometimes still do act on graphs . My definition of multigraphs will be less convenient when that comes up, but it‚Äôs not that often.</p>",
        "id": 517399547,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1747000456
    },
    {
        "content": "<p>Thanks everyone for your help with this PR. Kyle has delegated merging to me - I will give it until the end of the day before merging, in case anyone has any last-minute changes to suggest.</p>",
        "id": 518138338,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1747248893
    }
]