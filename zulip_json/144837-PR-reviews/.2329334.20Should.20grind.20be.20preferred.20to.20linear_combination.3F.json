[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> and I have been discussing on <a href=\"https://github.com/leanprover-community/mathlib4/pull/29334\">#29334</a> the question of whether some <code>linear_combination</code>s (originally <code>polyrith</code> output) should be changed to <code>grind</code>s.  Let's move the discussion here, since there are now several points being discussed.  Quotes are from the last comment on the PR (by Kim, giving reasons for the change).</p>",
        "id": 538333267,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1757378173
    },
    {
        "content": "<blockquote>\n<ol>\n<li><code>grind</code> will keep getting more capable, and I'd like \"<code>linarith</code>'s scope exceeds <code>grind</code>'s\" to eventually not be true. :-) (Inequalities and non-commutativity are certainly on the longer term plan.)</li>\n</ol>\n</blockquote>\n<p>(I'm guessing Kim means <code>linear_combination</code> here, not <code>linarith</code>)</p>\n<p>This seems to be the key place where our intuitions differ: it's just not clear to me that there's a decision procedure that can replace the current scope of <code>linear_combination</code>. \"Inequalities\", especially, are complicated!  What algorithm do you (=Kim) have in mind here that would subsume <code>linear_combination</code>?</p>\n<p>.... And then there are other domains of application, e.g. in modules.</p>\n<p>I think this basic skepticism is why I have been assuming that <code>linear_combination</code> is here to stay.</p>",
        "id": 538333358,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1757378233
    },
    {
        "content": "<blockquote>\n<ol start=\"2\">\n<li>It's really hard for me to keep track of what <code>grind</code> can and can't do, and so replacing replaceable tactics more clearly \"marks\" the other use cases as future test cases for improvements to <code>grind</code>.</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"4\">\n<li>I want users to be able to learn that <code>grind</code> can do Grobner basis problems (I was surprised recently that someone didn't know this; in retrospect we haven't really told people!), by seeing it happening in the code base (if not via <code>grind</code> itself, via tactics that are using its internal solvers, and the doc-string explains the relationship).</li>\n</ol>\n</blockquote>\n<p>I'm sympathetic to these two sentiments (I have definitely felt that way about the new tactics I have developed myself), <em>but</em> I don't think they should be factors we weight strongly when reviewing proposed changes to Mathlib.  For example, (2) can be addressed with tooling -- isn't Anne's new tool directly relevant here?</p>",
        "id": 538333415,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1757378293
    },
    {
        "content": "<p>Perhaps for (4) the longer term strategy should be to work some <code>grind</code> examples into MIL?</p>",
        "id": 538333994,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757378772
    },
    {
        "content": "<p><img alt=\":closed-pr:\" class=\"emoji\" src=\"https://avatars.zulip.com/3121/emoji/images/b87212e0.png\" title=\"closed-pr\"></p>",
        "id": 538359649,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757399397
    },
    {
        "content": "<p>I'm curious what others think of:</p>\n<blockquote>\n<ol start=\"3\">\n<li>I think writing out coefficients in the source code is unhelpful to the reader, because they have to decide whether they need to care about them or not.</li>\n</ol>\n</blockquote>",
        "id": 538359859,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757399512
    },
    {
        "content": "<p>(To a lesser extend I'm interested also in responses to</p>\n<blockquote>\n<ol start=\"5\">\n<li>I am terrified of the maintenance burden of duplicated tactics, and always want to cut things things that are no longer needed. (This isn't relevant here, but I really want to mark <code>omega</code> as for internal use only once <code>grind</code> beats it; its implementation is gross.)</li>\n</ol>\n</blockquote>\n<p>but I appreciate I am more terrified than most in this regard. :-)</p>",
        "id": 538359947,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757399572
    },
    {
        "content": "<p>I think we should keep in mind the goal of having formal proofs that can convey understanding of why things are true. I would be much happier with all this if <code>grind</code> could explain what it does. <code>linear_combination</code> is really hard to beat here.</p>",
        "id": 538366518,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1757402416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329334.20Should.20grind.20be.20preferred.20to.20linear_combination.3F/near/538359859\">said</a>:</p>\n<blockquote>\n<p>I'm curious what others think of:</p>\n<blockquote>\n<ol start=\"3\">\n<li>I think writing out coefficients in the source code is unhelpful to the reader, because they have to decide whether they need to care about them or not.</li>\n</ol>\n</blockquote>\n</blockquote>\n<p>On this one: I think it's a reasonable point (I would probably prefer <code>polyrith</code> to <code>linear_combination [stuff]</code> if <code>polyrith</code> were mathlib-legal), but not decisive, since there are also stylistic reasons (e.g. conveying \"this goal is just Grobner\") why people might prefer the other way.</p>\n<p>Analogy: we allow both <code>assumption</code> and <code>exact h</code> in mathlib, and don't proactively change one to the other.</p>",
        "id": 538371715,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1757404100
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329334.20Should.20grind.20be.20preferred.20to.20linear_combination.3F/near/538359947\">said</a>:</p>\n<blockquote>\n<p>(To a lesser extend I'm interested also in responses to</p>\n<blockquote>\n<ol start=\"5\">\n<li>I am terrified of the maintenance burden of duplicated tactics, and always want to cut things things that are no longer needed.</li>\n</ol>\n</blockquote>\n</blockquote>\n<p>On this one: I agree in principle, but is this point relevant to <code>linear_combination</code>? As I <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329334.20Should.20grind.20be.20preferred.20to.20linear_combination.3F/near/538333358\">said above</a>, it's not at all obvious that <code>grind</code> could ever subsume <code>linear_combination</code>.</p>\n<p>(Also, to Patrick's point: even if <code>grind</code> could subsume <code>linear_combination</code>, we might want to keep <code>linear_combination</code> around for teaching and for the Informalization machine.)</p>",
        "id": 538373537,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1757404724
    },
    {
        "content": "<p>First things first: I am impressed what grind can already do, and look forward to it becoming more powerful (and users having to do much fewer tedious proofs of things \"that should be obvious, yes really\"). Thanks for your (and Leo, and probably others') continued efforts here.</p>",
        "id": 538377757,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1757406081
    },
    {
        "content": "<p>That said, at the moment replacing <code>linear_combination</code> with <code>grind</code> is a regression for understanding the proof. While I know the big picture how grind works, there's no way to tell what exactly grind did here. \"This is just a linear combination of existing facts\" is useful information.</p>",
        "id": 538377787,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1757406093
    },
    {
        "content": "<p>Is there a way to express this as grind with some options set? (Is the grind configuration fine enough?) That would be fine with me.</p>",
        "id": 538377881,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1757406129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329334.20Should.20grind.20be.20preferred.20to.20linear_combination.3F/near/538371715\">said</a>:</p>\n<blockquote>\n<p>On this one: I think it's a reasonable point (I would probably prefer <code>polyrith</code> to <code>linear_combination [stuff]</code> if <code>polyrith</code> were mathlib-legal),</p>\n</blockquote>\n<p><code>polyrith</code> is not only not mathlib-legal, it is broken and may never be fixed, right? We told LLMs how to spam a sage instance on the cloud and then they proceeded to kill it.</p>",
        "id": 538398742,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757412439
    },
    {
        "content": "<p>Yes, as discussed on the PR, we can define <code>grind_ring</code> as a macro for <code>grind (ematch := 0) (splits := 0) -ext -mbtc -linarith -cutsat</code> (actually I'd implement it differently, so additional <code>-</code> flags aren't needed as new solvers are added), which would solve ring normalization + grobner basis problems, without everything else from <code>grind</code>.</p>",
        "id": 538408243,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757415645
    },
    {
        "content": "<p>I have to say I have the opposite worry that grind becomes a kitchen sink tactic with no real way to get an understanding of what it should or should not be able to do and no way to debug if (when) it breaks</p>",
        "id": 538415437,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1757417936
    },
    {
        "content": "<p>If we introduce such a macro, there's no need to call it <code>grind_ring</code>. It should be called <code>polyrith</code>!</p>",
        "id": 538428155,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1757421734
    },
    {
        "content": "<p>But is core Lean really willing to commit long-term to exposing specific pieces of the <code>grind</code> internals? I had the impression that core wants to keep the flexibility to refactor <code>grind</code> easily, and this may not be compatible with such commitments. We already have this problem with <code>simp</code>: tactics built as wrappers around <code>simp</code> unexpectedly acquiring other powers when <code>simp</code> gets improved.</p>",
        "id": 538428919,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1757421958
    },
    {
        "content": "<p>To quote from the PR discussion:</p>\n<blockquote>\n<p>when a tactic is built as a thin layer around a more powerful tactic, it's quite hard to maintain <em>limits</em> on that tactic's scope as the underlying tactic evolves. Test suites don't usually catch tactics unexpectedly solving <em>more</em> than they're supposed to. For example, the way the old <code>field_simp</code> bloated because it contained a full simp call, or the way <code>ring_nf</code>'s error messages got worse at some point <a href=\"https://github.com/leanprover/lean4/issues/5046\">because of a new builtin simproc</a></p>\n</blockquote>",
        "id": 538429259,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1757422068
    },
    {
        "content": "<p>Another example: when simp has adjusted its handling of transparency/zeta-delta/etc, downstream tactics have sometimes had unwanted effects that are not caught by tests, because they are changes in the \"doing too much\" direction rather than \"doing too little\"</p>",
        "id": 538430428,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1757422381
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>, I'm confused by what you're asking for now. Are you saying we <em>shouldn't have</em> a grobner basis tactic at all?</p>",
        "id": 538568250,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757480518
    },
    {
        "content": "<p>In any case, I would like <a href=\"https://github.com/leanprover-community/mathlib4/pull/29468\">#29468</a> merged, so I can make sure these are the right configuation options. <a href=\"https://github.com/leanprover/lean4/pull/10322\">lean#10322</a> already has more robust (i.e. non-macro based) versions, which will land in <code>v4.24.0</code> next week. The core ones are set up in such a way that if we add more solvers, <code>cutsat</code> and <code>grobner</code> will not mistakenly gain their capabilities.</p>",
        "id": 538568454,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757480659
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329334.20Should.20grind.20be.20preferred.20to.20linear_combination.3F/near/538428919\">said</a>:</p>\n<blockquote>\n<p>But is core Lean really willing to commit long-term to exposing specific pieces of the <code>grind</code> internals? I had the impression that core wants to keep the flexibility to refactor <code>grind</code> easily, and this may not be compatible with such commitments. We already have this problem with <code>simp</code>: tactics built as wrappers around <code>simp</code> unexpectedly acquiring other powers when <code>simp</code> gets improved.</p>\n</blockquote>\n<p>Have a look at the implementation of <a href=\"https://github.com/leanprover/lean4/pull/10322\">lean#10322</a>. We are not committing to much here: just that you can conveniently turn off all but one of the solvers.</p>",
        "id": 538569543,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757481630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329334.20Should.20grind.20be.20preferred.20to.20linear_combination.3F/near/538569543\">said</a>:</p>\n<blockquote>\n<p>We are not committing to much here: just that you can conveniently turn off all but one of the solvers.</p>\n</blockquote>\n<p>It would be nice if core could also commit to prioritising any <a href=\"https://github.com/leanprover/lean4/pull/5046\">lean4#5046</a>-like issues which arise with these tactics, as well as to adding checks for potential such issues to the <code>grind</code> review process.</p>\n<p>I'm worried that, two years down the line, after we have started relying on it, the new <code>grobner</code>/<code>polyrith</code> gains a new capability which (e.g.) makes it useless for teaching, and core decides that this is \"a feature, not a bug\".</p>",
        "id": 538597774,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1757494091
    },
    {
        "content": "<p>You won't be able to say you haven't been warned. :-)</p>",
        "id": 538642314,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757508404
    },
    {
        "content": "<p>I've converted the <code>polyrith</code> tests.</p>",
        "id": 538642409,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757508431
    },
    {
        "content": "<p>re: the name. I'm not at all excited about <code>polyrith</code> to be honest. I've always thought it was an obscure pun on <code>linarith</code>.</p>",
        "id": 538642541,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757508471
    },
    {
        "content": "<p>Surely it's called <code>polyrith</code> because it's <code>poly</code>nomial a<code>rith</code>metic of sorts?</p>",
        "id": 538656641,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1757512040
    },
    {
        "content": "<p>So I don't think it's so obscure at all.</p>",
        "id": 538656779,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1757512073
    },
    {
        "content": "<p><span aria-label=\"light bulb\" class=\"emoji emoji-1f4a1\" role=\"img\" title=\"light bulb\">:light_bulb:</span>I never knew what it was standing for. <code>polyarith</code> would convey the meaning a lot better</p>",
        "id": 538670470,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1757515377
    },
    {
        "content": "<p>but that's more syllables :(</p>",
        "id": 538680288,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757517724
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329334.20Should.20grind.20be.20preferred.20to.20linear_combination.3F/near/538597774\">said</a>:</p>\n<blockquote>\n<p>I'm worried that, two years down the line, after we have started relying on it, the new <code>grobner</code>/<code>polyrith</code> gains a new capability which (e.g.) makes it useless for teaching, and core decides that this is \"a feature, not a bug\".</p>\n</blockquote>\n<p>Obviously we want to provide some stability. But there are different requirements for teaching, for mathematics formalization, and for software verification. (As you move along that list, the more important it becomes to \"get things done, even if it's done by a black box\".)</p>\n<p>I think for teaching ideally there would just be a standalone implementation of grobner, perhaps even written in Mathlib, with zero aspiration to work on even medium size problems.</p>\n<p>As a toy example, consider what happens if we add existentials to the grobner solver. This would mean that instead of just solving problems with some polynomial equalities as hypotheses, and the goal some equation, the goal could be an iterated existential, followed by a polynomial goal which is affine in the existential variables. That's lovely, and enables us to do lots of new things, so <code>grind</code> by default would just enable this new feature. Presumably the <code>grobner</code> wrapper would too, but it's no effort to add <code>grind -ringExistentials</code> or <code>grobner -ringExistentials</code>. Then a further teaching wrapper could turn it off by default. Does that seem reasonable?</p>\n<p>Note though that right now if you disable everything in <code>grind</code> except the ring module, you get both ring normalization (i.e. Mathlib's <code>ring</code>) <em>and</em> using polynomial equations in the context (i.e. Mathlib's former <code>polyrith</code>). There's currently no way to get just <code>ring</code> without <code>polyrith</code> from what <code>grind</code> provides.</p>",
        "id": 538783300,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757573811
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329334.20Should.20grind.20be.20preferred.20to.20linear_combination.3F/near/538783300\">said</a>:</p>\n<blockquote>\n<p>Note though that right now if you disable everything in <code>grind</code> except the ring module, you get both ring normalization (i.e. Mathlib's <code>ring</code>) <em>and</em> using polynomial equations in the context (i.e. Mathlib's former <code>polyrith</code>). There's currently no way to get just <code>ring</code> without <code>polyrith</code> from what <code>grind</code> provides.</p>\n</blockquote>\n<p>So loosing Mathlib’s <code>ring</code> would be a huge regression for teaching.</p>",
        "id": 538803747,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1757580909
    },
    {
        "content": "<p>On the other hand, replacing <code>ring</code> by a grind-based analogue (such as <code>grobner</code>) in mathlib need not imply deleting <code>ring</code>.</p>",
        "id": 538805004,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1757581274
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329334.20Should.20grind.20be.20preferred.20to.20linear_combination.3F/near/538805004\">said</a>:</p>\n<blockquote>\n<p>On the other hand, replacing <code>ring</code> by a grind-based analogue (such as <code>grobner</code>) in mathlib need not imply deleting <code>ring</code>.</p>\n</blockquote>\n<p>But, on the other other hand, there is no particular reason to make this replacement!</p>",
        "id": 538812784,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1757583663
    },
    {
        "content": "<p>Yes, hopefully we can have both <code>ring</code> which does not look at hypotheses, and <code>grobner</code> which does.</p>",
        "id": 538820069,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757585941
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>, I wanted to come back with some update after talking to Leo.</p>\n<p>Here's what we're planning:</p>\n<ul>\n<li>We're going to add more flexible variants of <code>grind?</code>, that not only generate <code>grind only [X, Y, Z]</code> suggestions, but will also be able to suggest things like <code>grind -ring [X, Y, Z]</code> (i.e. indicating the ring module is not needed), or <code>grobner [sin_sq_add_cos_sq]</code> (to indicate turning everything off except the grobner module, but adding <code>sin_sq_add_cos_sq</code> from the environment).</li>\n<li>The <code>try?</code> tactic (which already exists, please use and and encourage people to try it) is going to receive a lot of love next quarter. We'll make sure it is extensible with all the mathlib tactics, and we'll continue improving the existing mechanism by which once it finds a working suggestion, it can minimize and/or improve it before presenting it to the user. Certainly we want <code>try?</code> to suggest <code>cutsat</code> or <code>grobner</code> (or grind's frontends to <code>linarith</code>, etc, as they are prepared) in favour of suggesting <code>grind</code>, where applicable. (We're also hoping to make <code>try?</code> run automatically on <code>sorry</code>s. when CPUs/battery is available. :-)</li>\n<li>We also want to work on <code>ungrind</code>, which will try to produce a tactic script that entirely replaces the <code>grind</code> call. (But possibly calling individual solvers via <code>cutsat</code>, <code>grobner</code>, <code>linarith</code>, etc.) This will generate <code>cases</code>, <code>have</code>, <code>rw</code>, etc. statements. Ideally we can even have it work when <code>grind</code> fails to close the goal, showing you the steps it made up to failure. This is a difficult goal; there's a lot of engineering work required to make it work nicely.</li>\n<li>We can add a mode to <code>grobner</code> that reports directly the coefficients. But it's worth noting that from an efficiency point of view a nullstellensatz certificate is <em>really bad</em> compared to the certificate we actually produce internally, so this is only useful for very small problems. It's pretty unclear to me how to produce a good try this suggestion without adopting linear_combination wholesale, which doesn't seem desirable. Suggestions very welcome here.</li>\n</ul>",
        "id": 538977599,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757648839
    },
    {
        "content": "<p>Thanks for the update, Kim. This direction of work sounds promising. In particular, if these features are added, it sounds like core would be committing to long-term maintainance of restricted-scope tactics like <code>grobner</code>, which I feel is a key point here.</p>",
        "id": 539491436,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1757924751
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329334.20Should.20grind.20be.20preferred.20to.20linear_combination.3F/near/538977599\">said</a>:</p>\n<blockquote>\n<ul>\n<li>We can add a mode to <code>grobner</code> that reports directly the coefficients. But it's worth noting that from an efficiency point of view a nullstellensatz certificate is <em>really bad</em> compared to the certificate we actually produce internally, so this is only useful for very small problems. It's pretty unclear to me how to produce a good try this suggestion without adopting linear_combination wholesale, which doesn't seem desirable. Suggestions very welcome here.</li>\n</ul>\n</blockquote>\n<p>Because <code>linear_combination</code> depends on <code>positivity</code>, it's not something which could be absorbed by core. A nice solution here would be for core to offer that part of <code>grind</code>'s functionality as a metaprogram -- then we could write the <code>try this?</code> part in Mathlib. Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">coeffs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MVarId</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Poly</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">LocalDecl</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>where <code>Poly</code> is <code>List (Rat × List (Term × Nat))</code> or however grind internally represents polynomials.</p>\n<p>Cc <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> since one of the big motivations (other than maintainability) for adding a coefficient-reporting mode to <code>grobner</code> is \"explainability\" applications like the informalization machine.  In that application they would probably use this metaprogram directly, not the <code>linear_combination</code> wrapper.</p>",
        "id": 539495864,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1757926007
    },
    {
        "content": "<p>I am always enthusiastic about tactic providing more access to their internals, both because I want to reuse them for teaching tactics and in Informal Lean. For instance in Verbose Lean I have a lot of code duplicated from the <code>cc</code> tactic because the <code>cc</code> tactic does not expose enough to have a version using only a subset of local assumptions.</p>",
        "id": 539555355,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1757942128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329334.20Should.20grind.20be.20preferred.20to.20linear_combination.3F/near/539495864\">said</a>:</p>\n<blockquote>\n<p>Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">coeffs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MVarId</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Poly</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">LocalDecl</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>where <code>Poly</code> is <code>List (Rat × List (Term × Nat))</code> or however grind internally represents polynomials.</p>\n</blockquote>\n<p>We can probably do this. Note that this is new functionality: the current Grobner implementation never calculates these coefficients, because in practice it is extremely inefficient to do so merely to close the goal.</p>",
        "id": 539668618,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757985507
    },
    {
        "content": "<p>There'll be a subtlety for the case when the polynomial actually belongs to the radical of the ideal, not the ideal itself -- one then needs to report which power of the polynomial belongs to the ideal (you can look at how <code>polyrith</code> does this).</p>",
        "id": 539693946,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1758005316
    },
    {
        "content": "<p>(random comment about <code>polyrith</code> vs <code>polyarith</code>: I wonder if there's an American bias here? I always found <code>polyrith</code> pretty understandable, but in America there's a saying that schools teach the \"three R's\": reading, writing, and rithmetic. My understanding is that this pronounciation is mostly local to the US, but may contribute to easily parsing it as \"polynomial rithmetic\".)</p>",
        "id": 540085995,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1758136400
    },
    {
        "content": "<p>(american) I have never heard of that saying before but <code>polyrith</code> was very understandable after I figured out <code>linarith</code> was <code>lin</code>ear <code>arith</code>metic</p>",
        "id": 540086392,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758136553
    },
    {
        "content": "<p>(non-american) same, I always parsed <code>polyrith</code> as <code>linarith</code> but polynomial instead of linear</p>",
        "id": 540359398,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1758247642
    },
    {
        "content": "<p>Cross-referencing here that <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329334.20Should.20grind.20be.20preferred.20to.20linear_combination.3F/near/538977599\">some comments above</a> about core's plans may now be out of date, per Kim's comment on <a href=\"https://github.com/leanprover-community/mathlib4/pull/29692\">#29692</a>:</p>\n<blockquote>\n<p>We're increasingly skeptical of providing a stand alone <code>grobner</code> tactic interface to <code>grind</code></p>\n</blockquote>",
        "id": 540396178,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1758269246
    },
    {
        "content": "<p>Heather, I think I need to <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> with you a bit about what you would do with the MetaM function above. I can understand that it's useful for computer algebra applications (but there I'm sceptical grind should be involved at all --- someone needs to write a high performance engine with support for flexible monomials orderings, F4, etc), but I think I'm failing so far to understand the motivation for a \"Try this\" tactic using it.</p>",
        "id": 540414763,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1758275246
    },
    {
        "content": "<p>Today we were considering the possibility of <code>ungrind</code> \"delaborators\", i.e. user extension points that specify grind configurations, with some scope for flexibility, and some (this is very vague!) mechanism so that when you write <code>grind?</code> and it works what which configuration options are necessary, it is able to give \"Try this\" suggestions based on the user supplied configurations, with custom syntax. </p>\n<p>E.g. so a library might be able to specify \"if you can close the goal using just the +ring solver, print <code>grobner</code>\", and once we attempt to write the ungrind mechanism, it could work out \"ah, I just had to case split on <code>h</code> then use the <code>+ring</code> solver\" and suggest \"Try this: <code>cases h; grobner</code>\"</p>",
        "id": 540415982,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1758275658
    },
    {
        "content": "<p>The point is that we already have about half a dozen solvers, and we expect to have many more over the next year, plus users to add more. So we feeling cautious about providing individual front-ends for all of them, and want to think about generic mechanisms to allow users to do this themselves.</p>",
        "id": 540416213,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1758275736
    },
    {
        "content": "<p><code>cutsat</code> will be handled differently, because we want to get everyone off <code>omega</code> so it becomes possible to deprecate it.</p>",
        "id": 540416397,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1758275803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329334.20Should.20grind.20be.20preferred.20to.20linear_combination.3F/near/540414763\">said</a>:</p>\n<blockquote>\n<p>Heather, I think I need to <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> with you a bit about what you would do with the MetaM function above.</p>\n</blockquote>\n<p><del>Two</del> Three things I had in mind:</p>\n<ul>\n<li>In Patrick and Kyle's informalizer, you are supposed to be able to click deeper and deeper to get further details.  The natural way to support <code>grobner</code>/<code>linarith</code> in the informalizer would be to have a way of expanding them to linear combinations.  Patrick can probably say more himself, or maybe there's already discussion of this on Zulip -- it's an idea I've heard him mention several times over the years.</li>\n<li>For maintenance, if a <code>grobner</code> call breaks in an update, one would like to track down the issue by finding out what the corresponding <code>linear_combination</code> call was in the old version, then running that with <code>linear_combination (norm := ring_nf)</code> in the new version.</li>\n</ul>",
        "id": 540422510,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1758277973
    },
    {
        "content": "<ul>\n<li>Same as above but with \"maintenance\" changed to \"refactoring\"/\"generalization\".</li>\n</ul>",
        "id": 540423113,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1758278197
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329334.20Should.20grind.20be.20preferred.20to.20linear_combination.3F/near/540423113\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Same as above but with \"maintenance\" changed to \"refactoring\"/\"generalization\".</li>\n</ul>\n</blockquote>\n<p>As an example, when I was discovering the (to my mind more elegant) proof in <a href=\"https://github.com/leanprover-community/mathlib4/pull/29783\">#29783</a>, I spent a lot of time staring at the <code>linear_combination (norm := ring_nf)</code> version of the concluding <code>linear_combination</code> call to see why things weren't working. This allowed me to track down the bug <a href=\"https://github.com/leanprover-community/mathlib4/pull/29778\">#29778</a>, the unexpected missing feature <a href=\"https://github.com/leanprover-community/mathlib4/pull/29782\">#29782</a>, and a simp-lemma I hadn't expected to need. If the old proof's final line had been <code>grobner</code>, I wouldn't have been able to find this new proof.</p>",
        "id": 540424405,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1758278636
    },
    {
        "content": "<p>For the analogous question of being able to expand <code>linarith</code> (or its <code>grind</code> alternative) to <code>linear_combination</code>, <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> has a nice example of having hand-converted the <code>linarith</code>s in a file to <code>linear_combination</code>s so that he could use <code>linear_combination (norm := something_custom)</code> to track down the slack in inequalities, thus improving the final constant in a bound.</p>",
        "id": 540426844,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1758279421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2329334.20Should.20grind.20be.20preferred.20to.20linear_combination.3F/near/538977599\">said</a>:</p>\n<blockquote>\n<p>It's pretty unclear to me how to produce a good try this suggestion without adopting linear_combination wholesale, which doesn't seem desirable. Suggestions very welcome here.</p>\n</blockquote>\n<p>Of course, this is a nontrivial feature request for <code>grind</code>, and I am not demanding that core work on it: I just proposed it because you had asked for suggestions.</p>\n<p>But my examples above do illustrate why we should be hesitant about changing <code>linear_combination</code> to <code>grind</code> across the library, and why a <code>grind</code> feature which squeezed to <code>linear_combination</code> would mitigate the risk.</p>",
        "id": 540429063,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1758280121
    },
    {
        "content": "<p>Thanks for these, I will think on them!</p>\n<p>(I am thoroughly convinced by now that the answer to the thread title is no: hopefully continuing the discussion here doesn't convey otherwise. But I do want to prioritise what comes next!)</p>",
        "id": 540429679,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1758280319
    }
]