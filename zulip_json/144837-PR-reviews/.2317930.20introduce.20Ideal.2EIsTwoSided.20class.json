[
    {
        "content": "<p>Let me try and summarise my understanding with this PR, which introduces a Prop-valued typeclass <code>IsTwoSided (I : Ideal R)</code> for R a (non-commutative in general) ring.</p>\n<p>Right now we already have a structure <code>TwoSidedIdeal</code> for talking about two-sided ideals. This structure is useful because with it, we can define a ring to be simple if <code>IsSimpleOrder (TwoSidedIdeal R)</code>. </p>\n<p>However what we can't do with this structure is the following. Right now we can quotient out a group G by an arbitrary subgroup H and get a quotient type. If however the subgroup is normal, then we would like G/H to become a group, and this is done via the Prop-valued class <code>Subgroup.Normal</code>.  Similarly here, want to quotient out a ring by an ideal and get a module for that ring, but if the ideal is two-sided then we want the quotient to be a ring. So <code>Ideal.IsTwoSided</code> follows the pattern of <code>Subgroup.Normal</code>.</p>\n<p>So there are arguments for wanting both the <code>TwoSidedIdeal</code> structure and the <code>IsTwoSided</code> Prop-valued class on ideals.</p>\n<p>But then we have two ways of saying the same thing, which feels kind of bad. But is it so bad? We already have the <code>OpenNormalSubgroup</code> structure as well as <code>IsOpen</code> and <code>IsNormal</code>predicates, for example. And we have several ways of talking about finiteness.</p>\n<p>I am not worried about the slowdowns in the file, they are very manageable, there are other PRs which cause similar total increases in heartbeats. I think the question is the design decision and it would be nice to get a decision here because this work is blocking other stuff (i.e. the Prop-valued typeclass has uses) (for example <a class=\"message-link\" href=\"/#narrow/channel/144837-PR-reviews/topic/.2317908.20Hopkins.E2.80.93Levitzki.20theorem/near/477788638\">#PR reviews &gt; #17908 Hopkinsâ€“Levitzki theorem @ ðŸ’¬</a>  ). </p>\n<p>So what do we do here? My instinct is to merge because there are clearly use cases.</p>",
        "id": 497394622,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738579289
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/17930\">#17930</a></p>\n<p>I think it's reasonable (and better) to redefine <code>TwoSidedIdeal R</code> to be <code>{I : Ideal R // I.IsTwoSided}</code> (or make a dedicated structure for it). The current definition in terms of RingCon doesn't agree with mathematical convention for a semiring R.</p>\n<p>There is currently no quotients by <code>TwoSidedIdeal</code>s defined in mathlib (otherwise we would already have two ways of talking about quotient rings, because currently all quotient rings are commutative and uses <code>Ideal</code> instead of <code>TwoSidedIdeal</code>). If you want to switch to using <code>TwoSidedIdeal</code> for quotients of noncommutative rings, you would need to change all existing code about quotient rings, which is likely 100+ files. The approach in this PR simply changes <code>instance {R} [CommRing R] (I : Ideal R) : CommRing (R â§¸ I)</code> to <code>instance {R} [Ring R] (I : Ideal R) [I.IsTwoSided] : Ring (R â§¸ I)</code>, and the <code>IsTwoSided</code> instance is automatically inferred given <code>[CommRing R]</code>, so it requires minimal change to existing code and should be preferred.</p>",
        "id": 497398949,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1738580314
    },
    {
        "content": "<p>As I've made clear before, I am skeptical about this, but still willing to be proven wrong, and it seems that evidence might be leaning that way, e.g., the slowdowns are quite manageable, which is why I've mostly kept my mouth shut about it recently.</p>\n<p>Let me try to highlight why this concerns me, perhaps in a way different from before. There is a key difference in my mind between <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subgroup.IsNormal#doc\">docs#Subgroup.IsNormal</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.IsTwoSided#doc\">docs#Ideal.IsTwoSided</a>, despite their clear similarity. In the case of groups, if we ignore rings, there aren't tons and tons of structures extending them for which we need to know that an underlying subgroup is normal.  Of course, that seems like slight-of-hand since rings, fields, normed fields, etc. are exactly those \"tons and tons\" of structures, and so I shouldn't be ignoring them. However, the distinction is that, for <em>any</em> ring, and any <code>AddSubgroup</code> of that ring, it's automatically normal because addition is commutative. So, it is straightforward for Lean to find this instance (especially because there are very few actual <code>Subgroup.IsNormal</code> instances floating around Mathlib.</p>\n<p>In contrast, outside of the commutative algebra world, there is not going to be any such simple instanceÂ¹ to figure out that an ideal <code>IsTwoSided</code>. So it is necessary to pass this assumption around all the time explicitly when working in the noncommutative world. It seems to me that the problem is that there is a huge amount of technical debt (as you mention, 100+ files) associated to the fact that Mathlib defined ideals as left-ideals, and all the theory for quotients was developed under the assumption of commutativity. </p>\n<p>Â¹In the context of Câ‹†-algebras, there could be: if <code>A</code> is a <code>NonUnitalCStarAlgebra</code> and <code>I : Ideal A</code> with an instance of <code>IsClosed (I : Set A)</code>, then it is possible to proved <code>I.IsTwoSided</code>. This seems like even more trouble to me, because now we're using both <code>IsClosed</code> and <code>Ideal.IsTwoSided</code> in ways that make me think we're abusing type class synthesis.</p>",
        "id": 497455304,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738594142
    },
    {
        "content": "<p>By the way, the reason we don't have quotients of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TwoSidedIdeal#doc\">docs#TwoSidedIdeal</a> is just that we haven't gotten around to writing them yet.</p>",
        "id": 497458242,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738594805
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> So you are proposing that whenever you have an <code>I : Ideal R</code> and you happen to know it is two sided, then you <code>let I' : TwoSidedIdeal R := \\&lt;I, prf\\&gt;</code>, and then quotient by <code>I'</code>?</p>\n<p>Or is it something else you have in mind?</p>",
        "id": 497469710,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1738597316
    },
    {
        "content": "<p>Yes, essentially. And I would have quotients only for <code>TwoSidedIdeal</code> (at least if the result is meant to be a ring). In the commutative case, you can go back and forth with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TwoSidedIdeal.orderIsoIdeal#doc\">docs#TwoSidedIdeal.orderIsoIdeal</a>.</p>\n<p>In any case, I really am happy to be wrong about this, so feel free to say this is a terrible approach.</p>",
        "id": 497474532,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738598367
    },
    {
        "content": "<blockquote>\n<p>if <code>A</code> is a <code>NonUnitalCStarAlgebra</code> and <code>I : Ideal A</code> with an instance of <code>IsClosed (I : Set A)</code>, then it is possible to prove <code>I.IsTwoSided</code>. This seems like even more trouble to me, because now we're using both <code>IsClosed</code> and <code>Ideal.IsTwoSided</code> in ways that make me think we're abusing type class synthesis.</p>\n</blockquote>\n<p>I'm not sure this is an abuse of typeclass synthesis. Suppose that you want your quotient to be T2Space, which is probably common. By your argument it seems you'd introduce a bundled <code>ClosedIdeal</code> and only take quotients by <code>ClosedIdeal</code> when you want the quotient to be T2Space, rather than getting T2Space automatically from <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Algebra/Group/Quotient.html#QuotientGroup.instT3Space\">QuotientGroup.instT3Space</a> by assuming [IsClosed]. Is such proliferation of quotients good for mathlib?</p>",
        "id": 497486284,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1738601348
    },
    {
        "content": "<p>I'd like to draw another analogy of <code>IsTwoSided</code> with existing classes <code>IsPrime</code> and <code>IsMaximal</code> in mathlib: when the ideal is prime you get a domain (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.Quotient.isDomain#doc\">docs#Ideal.Quotient.isDomain</a>), when it's maximal you get a field (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.Quotient.field#doc\">docs#Ideal.Quotient.field</a>, not an instance for defeq reasons), and when it's two-sided you get a ring. (and in all cases you at least get a module)</p>",
        "id": 497487912,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1738601750
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2317930.20introduce.20Ideal.2EIsTwoSided.20class/near/497486284\">said</a>:</p>\n<blockquote>\n<p>By your argument it seems you'd introduce a bundled <code>ClosedIdeal</code> and only take quotients by <code>ClosedIdeal</code> when you want the quotient to be T2Space</p>\n</blockquote>\n<p>Indeed, I've argued for this many times. I think we should have a <code>Closed : Type â†’ Type</code> that eats a <code>SetLike</code> and produces another. YaÃ«l frequently says that this is bad because you won't be able to recover the lattice structure on <code>Closed</code> in a reasonable way. But the idea is that you would write <code>I : Closed (Ideal R)</code>.</p>",
        "id": 497491707,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738602762
    },
    {
        "content": "<p>It seems that you are proposing introducing <code>PrimeIdeal</code>, <code>MaximalIdeal</code> and possibly combinations like <code>Closed (PrimeIdeal _)</code>. I cannot imagine how much time it would take to refactor mathlib this way. Right now, we can't even make <code>M â§¸ S</code> reducibly defeq to <code>M â§¸ S.toAddSubgroup</code> for <code>S : Submodule R M</code> (for instance purposes) due to <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Quotients.20are.20not.20reducibly.20defeq.20to.20their.20definitions/near/497501112\">#mathlib4 &gt; Quotients are not reducibly defeq to their definitions @ ðŸ’¬</a> (see <a href=\"https://github.com/leanprover-community/mathlib4/pull/21384/files\">#21384</a>), so each time you introduce a new bundled <code>Ideal</code> type, you add one more non-reducibly-defeq way to talk about the same thing, and lemmas/instances need to be copied over.</p>",
        "id": 497508730,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1738608285
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> I'm concerned that operators like <code>Closed : Type -&gt; Type</code> will not commute well with things like <code>TwoSided</code>. My gut feeling says: let's try out the current design. We can explore other designs in the future, if we need to.</p>",
        "id": 497607179,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1738657933
    }
]