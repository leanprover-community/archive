[
    {
        "content": "<p>I have submitted a PR that proves the classic Ore's theorem<a href=\"https://github.com/leanprover-community/mathlib4/pull/34481\">#34481</a> in graph theory. Currently, the proof exceeds 4,000 lines. I look forward to more people participating to simplify it and make it more compliant with Mathlib standards, so that it can be merged into Mathlib as soon as possible.</p>",
        "id": 571051337,
        "sender_full_name": "SHAO YU",
        "timestamp": 1769785145
    },
    {
        "content": "<p>Wow! Is that a record for longest-Lean-proof-ever?</p>",
        "id": 571071158,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1769790009
    },
    {
        "content": "<p>Of course it isn't the longest proof in Lean.</p>",
        "id": 571076121,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1769791285
    },
    {
        "content": "<p>The question is whether <code>maximal_path_extends_or_hamiltonian</code> is the longest atomic proof written in Lean.</p>",
        "id": 571076336,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1769791345
    },
    {
        "content": "<p><code>set_option maxHeartbeats 200000000000000</code></p>",
        "id": 571076444,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1769791375
    },
    {
        "content": "<p>It's more than one theorem, but there's 500+ line proofs in there</p>",
        "id": 571088664,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1769794780
    },
    {
        "content": "<p>The Wikipedia proof for this is a single paragraph. I don't think this should take more than 200 lines or so.</p>",
        "id": 571336123,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1769999909
    },
    {
        "content": "<p>AI is good at proving theorems, but it's not good at proving them well. If you want to PR this sort of material to Mathlib, you have to make sure you understand the argument the computer is making, and trim all of the extra fat.</p>",
        "id": 571336200,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1769999990
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/Ore's.20Theorem/near/571336123\">said</a>:</p>\n<blockquote>\n<p>The Wikipedia proof for this is a single paragraph. I don't think this should take more than 200 lines or so.</p>\n</blockquote>\n<p>That's a slick proof, but I think 200 is far too low for non-trivial graph-theory in Mathlib right now (unless you're counting each theorem individually).<br>\nFor example, IIUC the Wikipedia proof uses this at the start (at \"let x and y be any two non-adjacent vertices in H\") :</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">IsHamiltonian</span><span class=\"bp\">.</span><span class=\"n\">top_of_three_le_card</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">IsHamiltonian</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Here's how my attempt ended</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Tried and failed with various induction principles, such as<code>Fintype.induction_empty_option</code>.<br>\nInstead let's prove that <code>⊤</code> has a Hamiltonian path (not a cycle) which is true for any <code>[Nonempty α]</code>, then we'll close it to a cycle afterwards.<br>\nIdeally I'd want to use <code>ofPathGraph</code> from <a href=\"https://github.com/leanprover-community/mathlib4/pull/34171\">#34171</a> and <code>.map</code> it to the <code>⊤</code> graph, but to avoid extra imports lets <code>let rec</code> inline.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">Walks</span><span class=\"bp\">.</span><span class=\"n\">Maps</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: PANIC at Lean.EnvExtension.modifyState Lean.Environment:1399:17: `asyncDecl` `SimpleGraph.foo.f` is outside current context SimpleGraph.foo</span>\n<span class=\"sd\">backtrace:</span>\n<span class=\"sd\">---</span>\n<span class=\"sd\">warning: declaration uses `sorry`</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">zero_ne_one</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">succ_inj</span><span class=\"bp\">.</span><span class=\"n\">not</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Nope.</p>\n</div></div>\n<p>Not that I'm in any way justifying the PR above, but I think 1,000 lines is a more reasonable bound.<br>\nbtw if anyone can easily prove this small theorem I'd love to know.</p>",
        "id": 571347622,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770008291
    },
    {
        "content": "<p>It seems to me that we're missing a function to construct a walk from a <code>Fin (n + 1) → G</code>, or a cycle from a <code>Fin n → G</code>. Then the Hamiltonian path in question would just be given by <code>Fintype.equivFin G</code>.</p>",
        "id": 571353615,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770012804
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/15720\">#15720</a> is an abandoned PR proving Bondy-Chvatal which is a generalization of Ore. It's +900, but 1.5 years old so unclear to to me what it would be with the current API, grind, and further review. I noticed scrolling through that there are at least a few API lemmas in there that I recognize having contributed since then, though half of the PR is specific to the main theorem.</p>",
        "id": 571357719,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1770015481
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"761203\">@Vlad Tsyrklevich</span> thanks for pointing that out! Do you also want to cross-link the PRs?</p>",
        "id": 571367601,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1770019734
    },
    {
        "content": "<p>I'm not sure what 'cross-link' means. You mean just mention <a href=\"https://github.com/leanprover-community/mathlib4/pull/15720\">#15720</a> in a GitHub comment on this PR?</p>",
        "id": 571369131,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1770020312
    },
    {
        "content": "<p>Yup, just copy this zulip comment to a github comment on <a href=\"https://github.com/leanprover-community/mathlib4/pull/34481\">#34481</a>. Then the other PR will also be notified.</p>",
        "id": 571369341,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1770020398
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/Ore's.20Theorem/near/571347622\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">IsHamiltonian</span><span class=\"bp\">.</span><span class=\"n\">top_of_three_le_card</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">IsHamiltonian</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I started working on this and quickly got bogged down in induction arguments. This feels like something where it would be great to have a Walk.ofList. Then you pass [0, ..., card - 1, 0] mapped across the Fintype equiv and prove adjacency. Hopefully proving it's a path and a cycle would then be trivial from having the support explicitly specified (but I'm probably oversimplying.)</p>\n<p>EDIT: <a href=\"https://github.com/leanprover-community/mathlib4/pull/34799\">#34799</a></p>",
        "id": 571371528,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1770021178
    },
    {
        "content": "<p>I have re-proven my theorem and uploaded it. I have extracted some of the lemmas into separate <code>lemma</code>s to better align with Mathlib's standards. Alternatively, I also see PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/15720\">#15720</a> (although this PR has been abandoned), and my proof approach is based on the idea that a graph satisfying Ore's condition must contain a Hamiltonian path, from which both the Hamiltonian path and Hamiltonian cycle are constructed. Comparing the two PRs, do you think it is still worthwhile for me to persist in revising my proof with the expectation of merging it into Mathlib?</p>",
        "id": 571379209,
        "sender_full_name": "SHAO YU",
        "timestamp": 1770023538
    }
]