[
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/12157\">#12157</a> introduces the <code>have</code> vs <code>let</code> linter.  I looked at the output and most flags were correct.</p>\n<p>Some doubts:</p>\n<ul>\n<li><code>classical!</code> gets ignored,</li>\n<li><code>tauto</code> gets ignored,</li>\n<li><code>replace</code> gets <del>flagged and I changed a couple of <code>replace</code> to <code>let</code>s instead</del>ignored.</li>\n</ul>\n<p>The linter currently ignores completely <code>haveI</code>.</p>\n<p>Do you agree with these suggestions?  You can take a look at the CI output to see what else get flagged: I made not attempt at screening, just took a few consecutive warnings and replaced <code>have</code> by <code>let</code>.  Only once a proof did not go through and I unlinted.</p>",
        "id": 433367446,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713208610
    },
    {
        "content": "<p>Ah, one nolinted <code>unusedHave</code> was also flagged by the <code>have/let</code> linter: I changed it to <code>let</code> and removed the nolint.</p>",
        "id": 433367580,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713208657
    },
    {
        "content": "<p>I don't really see the point: often, when I introduce complicated data but the data is irrelevant, I use <code>have</code> instead of <code>let</code> on purpose, to help Lean by lowering the complexity in the proof. If we had a syntax like <code>have!</code> instead of <code>have</code> to introduce irrelevant data and signal it to the linter, this could be fine, but otherwise <a href=\"https://github.com/leanprover-community/mathlib4/pull/12157\">#12157</a> looks counterproductive to me.</p>",
        "id": 433443651,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1713244619
    },
    {
        "content": "<p>I can introduce some syntax like <code>have!</code> that the linter ignores.</p>",
        "id": 433452012,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713249650
    },
    {
        "content": "<p>Looking at the changes, there have been a couple of places where using <code>let</code> simplified the proofs and no regression (I do not know about timings, though -- I am only talking about proofs that compile).</p>",
        "id": 433452049,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713249669
    },
    {
        "content": "<p>Is the idea that the <code>have</code>s in current mathlib should not be touched?</p>",
        "id": 433452103,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713249708
    },
    {
        "content": "<p>Here is a summary of the PR.  Besides changes <code>have --&gt; let</code> this is everything else.</p>\n<ul>\n<li><code>Mathlib/Analysis/Convolution.lean</code>: two parallel simplified proofs.</li>\n<li><code>Mathlib/CategoryTheory/Limits/Final.lean</code>: a <code>have</code> that could not be replaced by <code>let</code>.</li>\n<li><code>Mathlib/Combinatorics/SimpleGraph/Connectivity.lean</code>: vanishing <code>haveSuffices</code> due to <code>have --&gt; let</code>.</li>\n<li><code>Mathlib/LinearAlgebra/TensorProduct/Graded/Internal.lean</code>: <code>have := ...; exact this</code> becoming <code>exact ...</code>.</li>\n<li><code>Mathlib/FieldTheory/Finite/GaloisField.lean</code>: using <code>let</code> makes the <code>unusedVariable</code> linter complain.</li>\n<li><code>Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean</code>: unset linter since <code>clear_value</code> complains.</li>\n<li><code>Mathlib/Tactic/NormNum/Inv.lean</code>: unset linter since <code>generalize</code> complains.</li>\n</ul>",
        "id": 433453604,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713250424
    },
    {
        "content": "<p>Update.</p>\n<ul>\n<li>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/12157\">#12157</a>, the PR with <code>have</code> to <code>let</code>, I have pleased the linter as is and I am now benchmarking <em>just <code>have --&gt; let</code>, not the linter</em> at <a href=\"https://github.com/leanprover-community/mathlib4/pull/12180\">#12180</a>.</li>\n<li>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/12181\">#12181</a>, I am trying out the reverse linter: <code>Prop</code>-valued <code>let</code>s.  It turns out that there are a few of those.</li>\n</ul>",
        "id": 433480626,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713260043
    },
    {
        "content": "<p>I benchmarked the <code>have</code> vs <code>let</code> changes and they are all non-significant:</p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/12189\">#12189</a> bi-directional <code>have</code> to <code>let</code> and <code>let</code> to <code>have</code>, as appropriate;</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/12180\">#12180</a> just <code>have</code> to <code>let</code>.</li>\n</ul>\n<p>Thus, regardless of whether or not these changes are an improvement style-wise, they appear to be largely irrelevant from a performance point of view.</p>",
        "id": 433610821,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713303139
    },
    {
        "content": "<p>If desired, we could have macros for <code>i_am_willingly_using_have_for_data</code> and <code>i_am_willingly_using_let_for_proofs</code>.</p>\n<p>In these changes, there might have been one or two situations where Lean was complaining about the \"correct\" usage, but otherwise it seemed to accept either with no issues.</p>",
        "id": 433611298,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713303354
    },
    {
        "content": "<p>The PR description of <a href=\"https://github.com/leanprover-community/mathlib4/pull/12157\">#12157</a> contains a summary of all the changes of the <code>have</code> to <code>let</code> PR that are not just <code>have</code> to <code>let</code> replacements.</p>",
        "id": 433611444,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713303411
    },
    {
        "content": "<p>/poll  Should there be a <code>have</code> vs <code>let</code> linter?<br>\nYes, with the adaptations that it suggests applied to all of mathlib<br>\nYes, but there needs to be further discussion about what happens to the current mathlib proofs<br>\nNo</p>",
        "id": 433611728,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713303531
    },
    {
        "content": "<p>It seems that you found three files where changing <code>have</code> to <code>let</code> made a proof simpler, and you found four files where you had to disable the linter. This does not seem like a good tradeoff.</p>",
        "id": 433619113,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1713307456
    },
    {
        "content": "<p>Can you explain why it's bad style to use <code>have</code> instead of <code>let</code> for non Prop-valued data? To take a specific example, why is it wrong to write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"n\">Y</span> <span class=\"bp\">⨿</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">colimit.isoColimitCocone</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>\n<p>(from <a href=\"https://github.com/leanprover-community/mathlib4/pull/12157/files#diff-4c5f30b51ec6b396da211ec938f0e10db2566da088a4095fa2453e73d61fef26\">Mathlib/CategoryTheory/Galois/Decomposition.lean</a>) if the rest of the proof only uses the fact that <code>X</code> and <code>Y ⨿ Z</code> are isomorphic and not the specific isomorphism between them?</p>",
        "id": 433620894,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1713308520
    },
    {
        "content": "<p>The problem is that this routinely bites beginners, who get broken proofs because the definition of their have is not available, because it should be a let.</p>",
        "id": 433629154,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1713314593
    },
    {
        "content": "<p>This doesn't show up in committed code, but is a common papercut for new users.</p>",
        "id": 433629169,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1713314607
    },
    {
        "content": "<p>I'm even bitten by this from time to time just from lack of careful thinking. I would appreciate this linter.</p>",
        "id": 433633096,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713317820
    },
    {
        "content": "<p>How would a linter help with that problem, though? By the time the linter runs, the proof is already confirmed not to be broken.</p>\n<p>In the diff of <a href=\"https://github.com/leanprover-community/mathlib4/pull/12180\">#12180</a>, I see a lot of things being changed even though (in my opinion) there is nothing wrong with them. For example, in <a href=\"https://github.com/leanprover-community/mathlib4/pull/12180/files#diff-daef0dcb628557383518bbc8aaabe4b289271a26e17ffd78ab3c1aae7ba1d3b2\">Mathlib/Algebra/BigOperators/Basic.lean</a>, the line</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.decEq</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>would get picked up by the linter.</p>\n<p>So would this line, from <a href=\"https://github.com/leanprover-community/mathlib4/pull/12180/files#diff-5b54b008b210441df7644bd52f457fc4b9cee98c0f2b999530b9c2a8e0fff37d\">Mathlib/Algebra/Homology/ShortComplex/Abelian.lean</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">hπ</span> <span class=\"o\">:</span> <span class=\"n\">IsColimit</span> <span class=\"o\">(</span><span class=\"n\">CokernelCofork.ofπ</span> <span class=\"n\">_</span> <span class=\"n\">wπ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"n\">CokernelCofork.IsColimit.ofπ</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cokernel.desc</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n      <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">cancel_epi</span> <span class=\"n\">e.hom</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">cancel_epi</span>\n</code></pre></div>",
        "id": 433633258,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1713317949
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"695266\">@Mitchell Lee</span>, there are two different types of linters. I was assuming this one is a \"runs in the editor\" one, not a \"runs in CI\" one, which I agree is less helpful.</p>",
        "id": 433638770,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1713322215
    },
    {
        "content": "<p>Currently, this is running in CI. For example: <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/8692043746/job/23835714084\">https://github.com/leanprover-community/mathlib4/actions/runs/8692043746/job/23835714084</a></p>",
        "id": 433643641,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1713325757
    },
    {
        "content": "<p>I agree that an online linter (in the sense of: available while the user is writing the code) is much more useful than an offline linter (in the sense of: runs after the user is \"finished\" with the code).</p>",
        "id": 433643898,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1713325952
    },
    {
        "content": "<p>As Kim said, the linter is a \"syntax\" linter that runs in the editor.  However, it does log warnings that get picked up by the noisy test in CI as well.</p>",
        "id": 433643921,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713325968
    },
    {
        "content": "<p>Nice!</p>",
        "id": 433643956,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1713326010
    },
    {
        "content": "<p>If you check-out the PR and you write a proof using <code>have</code> for data, you will see that your <code>have</code> gets underlined and you see the warning.</p>",
        "id": 433643980,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713326031
    },
    {
        "content": "<p>In fact, there was a suggestion to get the linter to emit its warnings only on incomplete proofs.  If you have a working proof with a <code>have</code> for data, then the linter could be quiet.  This is not the current behaviour, though.</p>",
        "id": 433644120,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713326110
    },
    {
        "content": "<p>I see. I apologize for misunderstanding what this PR does.</p>",
        "id": 433644281,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1713326229
    },
    {
        "content": "<p>No worries!  Mathlib tries to test as much as possible for \"quietness\": this means that you can get warnings in non-merged code, but you also get notified by CI in case your PR is \"noisy\".</p>",
        "id": 433644363,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713326297
    },
    {
        "content": "<p>I still have some concerns about this, though. The diff of <a href=\"https://github.com/leanprover-community/mathlib4/pull/12180\">#12180</a> strikes me as a list of almost 168 different situations where <code>have</code> is the stylistically better option. It more clearly conveys that the term does not matter, it causes less clutter in the goal view, and it is theoretically more performant. However, you're enforcing the use of <code>let</code> anyway.</p>",
        "id": 433647131,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1713328120
    },
    {
        "content": "<p>It seems like this is another situation where having different default options for local vs remote would be beneficial.</p>\n<p>I do not think that this is currently possible without hacks, but maybe having the linter run locally by default and not run on remote would be better?</p>",
        "id": 433647378,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713328317
    },
    {
        "content": "<p>(To be clear, I do not feel strongly about using <code>let</code> extensively, but I do find that being warned about a potential misstep is an improvement.)</p>",
        "id": 433647492,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713328389
    },
    {
        "content": "<p>I think that not running the linter on completed proofs would address all of my concerns.</p>",
        "id": 433649197,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1713329749
    },
    {
        "content": "<p>Can those 168 cases use the hypothetical <code>have!</code> that <span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> suggested?</p>",
        "id": 433663775,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1713331901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"695266\">Mitchell Lee</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312157.20.60have.60.20vs.20.60let.60.20linter/near/433647131\">said</a>:</p>\n<blockquote>\n<p>I still have some concerns about this, though. The diff of <a href=\"https://github.com/leanprover-community/mathlib4/pull/12180\">#12180</a> strikes me as a list of almost 168 different situations where <code>have</code> is the stylistically better option. It more clearly conveys that the term does not matter, it causes less clutter in the goal view, and it is theoretically more performant. However, you're enforcing the use of <code>let</code> anyway.</p>\n</blockquote>\n<p>Have you seen my suggestion? It seems to completely address your concerns:<br>\n<span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"https://github.com/leanprover-community/mathlib4/pull/12157#issuecomment-2059954426\">said</a>:</p>\n<blockquote>\n<p>The linter should send a warning on:</p>\n<ul>\n<li>a Prop-valued <code>let</code></li>\n<li>a Type-valued <code>have</code> in an erroring branch of a proof</li>\n</ul>\n<p>Note that the \"Type-valued <code>have</code> in a completed sorry-free <code>def</code>\" that I was referring to before is actually not bad since it's defeq to its value once the def is completed.</p>\n</blockquote>",
        "id": 433685496,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713337695
    },
    {
        "content": "<p>Yes, I agree with your suggestion.</p>",
        "id": 433685777,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1713337733
    },
    {
        "content": "<p>Am I right in saying that Prop-valued let us very rarely needed for reduction of well-founded recursion?</p>",
        "id": 433690822,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713338925
    },
    {
        "content": "<p>In those cases I think it's reasonable to explicitly silence the linter with an explanation (if you are correct that they are sometimes needed).</p>",
        "id": 433750824,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713358907
    },
    {
        "content": "<p>Is the consensus that, regardless of what happens with present usages of <code>have/let</code>, that in the future there should be a <code>have_for_data</code> and a <code>let_for_proof</code> syntax?</p>",
        "id": 433765624,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713362157
    },
    {
        "content": "<p>Or is the decision to quiet the linter something that would not be so fine-grained and you would just prepend the theorem with <code>set_option linter.haveLet false in</code>?</p>",
        "id": 433765650,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713362159
    },
    {
        "content": "<p>I wonder if it would be a good idea to adopt a convention that pre-pending <code>_</code> means \"do not lint\", so that</p>\n<ul>\n<li><code>_have</code> would be <code>have_for_data</code>;</li>\n<li><code>_let</code> would be <code>let_for_prop</code>.</li>\n</ul>\n<p>This would parallel the <code>!</code> for \"try harder\" and there would be the <code>_</code> for \"I consider myself warned\".</p>",
        "id": 433768861,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713362467
    },
    {
        "content": "<p>Personally, I prefer the explicit silencing of the linter instead of creating new <code>_have</code> and <code>_let</code> syntax, even if it does have some motivation.</p>",
        "id": 433772297,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713362841
    },
    {
        "content": "<p><code>have_anyway myName : myData := myTerm</code></p>",
        "id": 433772534,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1713362867
    },
    {
        "content": "<p>I think while this does occur across Mathlib, it's not so prevalent as to worry about the profileration of the explicit silencing.</p>",
        "id": 433772848,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713362896
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312157.20.60have.60.20vs.20.60let.60.20linter/near/433772848\">said</a>:</p>\n<blockquote>\n<p>I think while this does occur across Mathlib, it's not so prevalent as to worry about the profileration of the explicit silencing.</p>\n</blockquote>\n<p>Currently there are over 300 occurrences of <code>have</code> that should be <code>let</code>s.</p>",
        "id": 433774792,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713363121
    },
    {
        "content": "<p>I know. In my mind that's not too many. Others are free to disagree.</p>",
        "id": 433775734,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713363231
    },
    {
        "content": "<p>Ok, sure.  There are a about 200 uses of <code>let</code> for <code>have</code> as well.</p>",
        "id": 433775996,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713363260
    },
    {
        "content": "<p>I disagree that they \"should be\" <code>let</code>s</p>",
        "id": 433776050,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1713363267
    },
    {
        "content": "<p>What do we have 50000 explicit theorems (i.e., not autogenerated)? So we're talking about 1%?</p>",
        "id": 433776200,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713363284
    },
    {
        "content": "<p>(I am just mentioning the numbers, since that is what the linter says!)</p>",
        "id": 433776239,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713363289
    },
    {
        "content": "<p>Yes, they are spread across about 500 files.</p>",
        "id": 433776430,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713363310
    },
    {
        "content": "<p>So, yes, not many, but not negligible either.</p>",
        "id": 433776643,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713363334
    },
    {
        "content": "<p><code>have</code> vs <code>let</code> is only a footgun when writing a proof. If anything, using <code>have</code> instead of <code>let</code> when it's appropriate makes it easier to read a proof.</p>",
        "id": 433777730,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1713363456
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"560559\">Richard Osborn</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312157.20.60have.60.20vs.20.60let.60.20linter/near/433777730\">said</a>:</p>\n<blockquote>\n<p><code>have</code> vs <code>let</code> is only a footgun when writing a proof. If anything, using <code>have</code> instead of <code>let</code> when it's appropriate makes it easier to read a proof.</p>\n</blockquote>\n<p>Indeed, this is why one of the proposals was to make the linter noisy only when the proof is already noisy for other reasons.  If the proof compiles, the linter shuts up.</p>",
        "id": 433778860,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713363587
    },
    {
        "content": "<p>(Note that I have not actually implemented this to see how it would work, but I am pretty sure that it would be exactly what you would hope for, except possibly for random events when errors, rather than warnings, are present.)</p>",
        "id": 433779297,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713363634
    },
    {
        "content": "<p>So, e.g., a proof with a <code>sorry</code> that uses <code>have</code> instead of <code>let</code> would mention this, but a completed proof would not.</p>",
        "id": 433779677,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713363679
    },
    {
        "content": "<p>Another advantage of a \"chatty if noisy\" linter, is that there may not be the need to maintain further syntax shadowing the existing <code>have</code> and <code>let</code> which already have quite a few features.</p>",
        "id": 433792049,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713365085
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/12190\">#12190</a> implements the \"chatty if noisy\" <code>haveLet</code> linter: the linter inspects the MessageLog of the declaration and emits its waning only if the messagelog is non-empty.</p>",
        "id": 433799392,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713365884
    },
    {
        "content": "<p>So now it should be silent on all those 500 cases, right?</p>",
        "id": 433800261,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713365985
    },
    {
        "content": "<p>It should, but I have not imported the file in Tactic.Basic.  Let me try that!</p>",
        "id": 433801999,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713366161
    },
    {
        "content": "<p>CI is now running on it.</p>",
        "id": 433805985,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713366596
    },
    {
        "content": "<p>CI was successful on <a href=\"https://github.com/leanprover-community/mathlib4/pull/12190\">#12190</a> and the tests show that the linter is ready to act, but would not be the first to say something!</p>",
        "id": 433850944,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713378959
    },
    {
        "content": "<p>I am going to see if I can add an option to make the linter be noisy even on finished proofs, in case you are curious to see if there are any <code>have</code>s for <code>let</code>s.</p>",
        "id": 433851089,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713379011
    },
    {
        "content": "<p>I updated <a href=\"https://github.com/leanprover-community/mathlib4/pull/12190\">#12190</a>: the linter now has three states:</p>\n<ul>\n<li><code>0</code> -- inactive;</li>\n<li><code>1</code> -- active only on noisy declarations;</li>\n<li><code>2</code> or more -- always active.</li>\n</ul>\n<p>The default value is <code>1</code>.</p>",
        "id": 434472477,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713591467
    },
    {
        "content": "<p>I also made <a href=\"https://github.com/leanprover-community/mathlib4/pull/12190\">#12190</a> the \"main\" PR and converted to <code>draft</code> the original <a href=\"https://github.com/leanprover-community/mathlib4/pull/12157\">#12157</a> with all the \"effects\" of the linter on mathlib.</p>",
        "id": 434472542,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713591517
    },
    {
        "content": "<p>The <code>have</code> vs <code>let</code> issue was brought up again <a href=\"#narrow/stream/113489-new-members/topic/Working.20with.20uniformities.20to.20show.20separability/near/435794680\">here</a>.</p>\n<p>Are there any further thoughts on the linter?</p>",
        "id": 435846229,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1714291436
    },
    {
        "content": "<p>After bumping the PR to v4.8.0, are there more comments on <a href=\"https://github.com/leanprover-community/mathlib4/pull/12190\">#12190</a>?  Is there interest to have the linter in mathlib?</p>",
        "id": 437798819,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1715250803
    },
    {
        "content": "<p>Sorry to necromance this PR, but I just opened up the file more or less by accident, and found several unfortunate things.</p>\n<ul>\n<li>Line 98, please don't use <code>qsort</code> followed by <code>.getD 0</code> to get the smallest element of something! This is not at all efficient.</li>\n<li><code>areProp_toFormat</code> is calling <code>ppExpr</code> even on all the propositional types, where the format is never going to be displayed (indeed, it is discarded immediately after)</li>\n<li>don't return an <code>Array (Bool × α)</code>, only to immediately <code>.partition</code> and discard one half. First, if you're using <code>partition</code> and then discarding you should just use <code>filter</code>. But even better, use <code>filterMap</code> in the first place and only return the values you want.</li>\n<li>similarly on line 95 and 103 the <code>map</code> followed by <code>reduceOption</code> should be <code>filterMap</code>.</li>\n<li>line 123, <code>for t in trees.toArray do</code> should just be <code>for t in trees do</code>. No need to do an extra pass!</li>\n</ul>\n<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>, <span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span>, <span class=\"user-mention\" data-user-id=\"385895\">@Jon Eugster</span> </p>\n<p>(I appreciate that most of these criticisms do not actually reflect measureable performance problems. But they easily <em>could</em>, and it is not really any harder to do it right.)</p>",
        "id": 486013460,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1733288315
    },
    {
        "content": "<p>Oh, and I see a <code>map</code> followed by <code>flatten</code> that could be a <code>flatMap</code> on line 105.</p>",
        "id": 486014083,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1733288566
    },
    {
        "content": "<p>Kim, thanks for the comments!  I'm somewhat busier than normal now, since it is the last week of term.  I will get to this once my schedule looks saner again, likely next week!</p>",
        "id": 486032764,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1733299678
    },
    {
        "content": "<p>I'm working on this for a bit. If you also want to, let's coordinate!</p>",
        "id": 486134844,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1733330195
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/19730\">#19730</a>. Further comments welcome!</p>",
        "id": 486140675,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1733331984
    },
    {
        "content": "<p>See also <a href=\"https://github.com/leanprover-community/mathlib4/pull/19733\">#19733</a>, which was inspired by this.</p>",
        "id": 486189172,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1733350956
    },
    {
        "content": "<p>Side note: is there any \"optimising interpreted Lean code 101\" documentation? I found myself wondering things like \"given a <code>List A</code>, is it more efficient to call <code>toArray</code> and then <code>Array.map</code>, or should I call <code>List.map</code> and then <code>.toArray</code>? Or: which basic things should I be aware of?</p>\n<p>I can well imagine the answer to be \"compile your Lean code and just think about readability\" (which is fair... but then, this is about syntax linters which are currently interpreted). I've also vaguely heard the term \"tail call optimisation\" before (pointers to docs welcome).</p>",
        "id": 486189485,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1733351107
    },
    {
        "content": "<p>I don't think there is any such documentation.</p>",
        "id": 486196960,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1733355075
    },
    {
        "content": "<p>It would not be insane actually to have <code>List.toArrayMap</code> which would have a simp lemma to <code>L.map.toArray</code>. This would have a more efficient implementation, and it unfortunately rather common in practice.</p>",
        "id": 486197107,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1733355165
    },
    {
        "content": "<p>I really wish we had something like rust iterators as a way to unify the APIs without performance overhead</p>",
        "id": 486299163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733403451
    },
    {
        "content": "<p>Isn't part of Rust's zero-cost abstractions that you have a compiler which can inline them? As syntax linters are interpreted, I'm not sure how that would apply here. (Or do you propose compiling syntax linters? Let me start a separate thread about that.)</p>",
        "id": 486303867,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1733404920
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2312190.20.60have.60.20vs.20.60let.60.20linter/near/486197107\">said</a>:</p>\n<blockquote>\n<p>It would not be insane actually to have <code>List.toArrayMap</code> which would have a simp lemma to <code>L.map.toArray</code>. This would have a more efficient implementation, and it unfortunately rather common in practice.</p>\n</blockquote>\n<p>Interesting! To make I understand correctly, you're saying that</p>\n<ul>\n<li>List.map.toArray is currently more efficient that <a href=\"http://List.toArray.map\">List.toArray.map</a> (or merely that it <em>could be</em> in the future?)</li>\n<li>you suggest adding a new function <code>List.toArrayMap</code>... is that just <code>List.map (...).toArray</code>? Or does that need a new implementation?</li>\n<li>to complement this, add a simp lemma that <code>L.toArrayMap</code> equals <code>L.map.toArray</code></li>\n</ul>",
        "id": 486303983,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1733404945
    },
    {
        "content": "<p>my comment was in response to Kim's comment about <code>toArrayMap</code>, not about linters</p>",
        "id": 486305882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733405525
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2312190.20.60have.60.20vs.20.60let.60.20linter/near/486303983\">said</a>:</p>\n<blockquote>\n<ul>\n<li>List.map.toArray is currently more efficient that <a href=\"http://list.toarray.map/\">List.toArray.map</a> (or merely that it <em>could be</em> in the future?)</li>\n</ul>\n</blockquote>\n<p>No, neither <code>List.map.toArray</code> nor <code>List.toArray.map</code> has optimal performance, <code>List.toArrayMap</code> is better than both. The simp lemma is because we don't want to have more API for reasoning purposes here, and <code>List.map.toArray</code> is more sensible from a reasoning perspective</p>",
        "id": 486306331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733405666
    },
    {
        "content": "<p>The reason is that in both cases you have to create an intermediate allocation which you could skip. In haskell the optimal code is built by \"stream fusion\", in rust this is done using iterators</p>",
        "id": 486306557,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733405745
    },
    {
        "content": "<p>Either approach (stream fusion or iterators) would be more general than <code>toArrayMap</code> since it would also apply to <code>List.toArray.filter</code> and a dozen other list functions</p>",
        "id": 486306770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733405798
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2312190.20.60have.60.20vs.20.60let.60.20linter/near/486306557\">said</a>:</p>\n<blockquote>\n<p>The reason is that in both cases you have to create an intermediate allocation which you could skip. In haskell the optimal code is built by \"stream fusion\", in rust this is done using iterators</p>\n</blockquote>\n<p>I was thinking about that (and not sure how <a href=\"http://List.toArray.map\">List.toArray.map</a> or List.map.toArray would achieve that)... thanks for confirming, that's re-assuring!</p>",
        "id": 486339286,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1733414333
    },
    {
        "content": "<p>Here's a naive attempt at implementing <code>toArrayMap</code>... but then, proving something interesting about it becomes difficult. I'll be happily mentored towards a better implementation, if you like. (Or told that this is by far not general enough, that's also fine.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">List</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toArrayMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">mkEmpty</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">res</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">toArrayMap</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toArrayMap_eq_toArray_map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">toArrayMap</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toArray</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- reasoning about the above definition is hard...</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">List</span>\n</code></pre></div>",
        "id": 486403497,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1733437350
    },
    {
        "content": "<p>I think </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toArrayMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- info: #[3, 4, 5, 6] -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">toArrayMap</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>would suffice for the definition. You probably need to generalize <code>#[]</code> for the proof.</p>",
        "id": 486415962,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1733443824
    },
    {
        "content": "<p>Thanks for the hint. Here's a proof - should I open a PR (to core, I guess)?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">List</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toArrayMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- info: #[3, 4, 5, 6] -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">toArrayMap</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toArrayMap_toListGen</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">revert</span><span class=\"w\"> </span><span class=\"n\">arr</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"n\">tail_ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">arr</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">arr</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">foldl_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">tail_ih</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toArrayMap_toList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">toArrayMap</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">toArrayMap_toListGen</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toArrayMap_eq_toArray_map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">toArrayMap</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toArray</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">ext'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">toArrayMap_toList</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">List</span>\n</code></pre></div>",
        "id": 486556354,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1733504097
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/tree/MR-listArrayMap\">branch#MR-listArrayMap</a> golfs mathlib using that function. (Before that PR can land, imho <code>toArrayMap</code> should go into batteries or core first; then all the imports can be eliminated.)</p>",
        "id": 486580356,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1733512871
    },
    {
        "content": "<p>Yes, that's fine, I'd accept that. Slight preference that it goes to Batteries first (for one, this will be available faster in Mathlib), and then I can decide to upstream it at my leisure. :-)</p>\n<p>Please make <code>..._toListGen</code> into just a <code>suffices</code> in the next theorem. Add a doc-string to <code>toArrayMap</code> to the effect \"This function is provided as a more efficient runtime alternative to <code>(l.map f).toArray</code>. For verification purposes, we immediately simplify it to that form.\"</p>",
        "id": 486752051,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1733649527
    },
    {
        "content": "<p>You should avoid the <code>revert</code>/<code>intro</code> dance using <code>induction ... generalizing</code>.</p>",
        "id": 486752073,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1733649545
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/batteries/pull/1090\">batteries#1090</a></p>",
        "id": 492713229,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1736426806
    }
]