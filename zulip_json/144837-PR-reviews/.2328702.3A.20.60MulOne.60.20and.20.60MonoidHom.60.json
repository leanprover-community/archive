[
    {
        "content": "<p>Following up on the conversation at <a href=\"#narrow/channel/287929-mathlib4/topic/RingHom.20for.20not-a-ring\">#mathlib4 &gt; RingHom for not-a-ring</a>, I've got <a href=\"https://github.com/leanprover-community/mathlib4/pull/28702\">#28702</a>. It adds new classes <code>MulOne</code>(and <code>AddZero</code>) very low in the algebra hierarchy, I wanted to get an impression what others thought</p>",
        "id": 538122579,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1757299897
    },
    {
        "content": "<p>(The eventual goal would be to have <code>RingHom</code> similarly not require any prop axioms, only data, on the input and output types. This is a smaller step.)</p>",
        "id": 538122648,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1757299997
    },
    {
        "content": "<p>Not sure about this, but surely at least you should consider renaming <code>MonoidHom</code> to <code>MulOneHom</code>?</p>",
        "id": 540032383,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758119756
    },
    {
        "content": "<p>It occurred to me, I thought about it, personally would think it's better to stay MonoidHom.</p>\n<p>Certainly I <em>wouldn't</em> want to change RingHom to AddMulZeroOneHom. :) Mathlib has a tendency to name structures after what they will \"typically mean\", even if the minimal requirement data for that structure is weaker. For instance, that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsOrderedModule#doc\">docs#IsOrderedModule</a> doesn't require it to be a module, or indeed that there be any additive structure at all</p>",
        "id": 540035059,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1758120334
    },
    {
        "content": "<p>That's true. Do you envisage being able to derive MulOne from the presence of a Mul instance and a One instance?</p>",
        "id": 540036807,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1758120717
    },
    {
        "content": "<p>I don't think that should be done, no. I think my image of the ideal setup is: there are classes for holding more or less data, bundled to whatever level of specificity makes sense; and then there are also classes that bundle facts in.</p>\n<p>It's the responsibility of instances to provide the correct classes. So if you can derive a One and a Mul under certain assumptions, you should also derive a MulOne under the right assumptions.</p>\n<p>Going \"back to atoms\" would remove the need to give the combination classes, but I think that's the wrong place for the responsibility to be, and it's going to kill performance all over</p>",
        "id": 540067476,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1758129875
    },
    {
        "content": "<p>Mm. Maybe making it a non-instance that can then be enabled as a local instance</p>",
        "id": 540067558,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1758129912
    },
    {
        "content": "<p>Yes I agree that we shoudn't add these reverse instances synthesizing <code>MulOne</code> from <code>Mul</code> and <code>One</code>. It isn't really useful, and it can be harmful to performance.</p>",
        "id": 540121193,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758154012
    }
]