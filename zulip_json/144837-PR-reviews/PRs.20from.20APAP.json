[
    {
        "content": "<p>The PRs from my Arithmetic Progressions - Almost Periodicity project are starting to pile up. Could I get some reviews/merges, please? The full list is <a href=\"https://github.com/leanprover-community/mathlib4/pulls?q=is%3Aopen+is%3Apr+author%3AYaelDillies+LeanAPAP\">here</a> and here is a more detailed description of the important PRs:</p>",
        "id": 466885888,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725268844
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/15441\">#15441</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/15441\">feat(AddChar): Additive group structure and double dual embedding</a>: Provide the <em>additive</em> group structure on <code>AddChar G ℂ</code> (it equals the multiplicative group structure, which already exists, but that's necessary for <code>AddChar (AddChar G ℂ) ℂ</code> to make sense), then define the double dual embedding as a map <code>G → AddChar (AddChar G ℂ) ℂ</code>. Approved on principles by <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>, <span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span>, <span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span>.</li>\n</ul>",
        "id": 466885925,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725268851
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/15443\">#15443</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/15443\">feat: The Marcinkiewicz-Zygmund inequality</a>: Prove the Marcinkiewicz-Zygmund inequality for a uniform random variable indexed by a fintype. Golfed by <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> and reviewed by <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span>. This was partly written by Bhavik.</li>\n</ul>",
        "id": 466885969,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725268862
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/15883\">#15883</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/15883\">feat: Expectation of a function over a finset</a>: Define the expectation of a random variable over a finset. This is a special case of the barycenter in a convex space. However this generality depends on a huge refactor I am currently preparing. Approved by <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>, reviewed by <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> and <span class=\"user-mention\" data-user-id=\"690858\">@Daniel Weber</span>. This was partly written by Bhavik.</li>\n</ul>",
        "id": 466886002,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725268867
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/16181\">#16181</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/16181\">feat: Conjugation-negation operator</a>: Define the conjugation-negation <code>conjneg f</code> of a function <code>f</code> as <code>fun x ↦ conj f (-x)</code>. This is an important operator in Fourier analysis as convolution by <code>f</code> is adjoint to convolution by <code>conjneg f</code>: <code>⟨f ∗ g, h⟩ = ⟨g, conjneg f ∗ h⟩</code>. Reviewed by <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>.</li>\n</ul>",
        "id": 466886039,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725268873
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/16183\">#16183</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/16183\">feat: The translation operator</a>: Define the translation <code>τ a f</code> of a function <code>f</code> by an element <code>a</code> of the domain. This is \"just\" <code>DomMulAct.mk (-a) • f</code> but it seems tough to make <code>τ a f</code>notation for it as then <code>τ (-a) f</code> would get \"simplified\" to <code>DomMulAct.mk a • f</code>. One option would be to depart from mathematical convention by making <code>τ a f</code> be notation for <code>DomMulAct.mk a • f</code>. It would work fine for my application but it might be unexpected to people for <code>τ a f a</code> to be <code>f (2 • a)</code> rather than <code>f 0</code>. Approved by <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>, reviewed by <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>.</li>\n</ul>",
        "id": 466886076,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725268879
    },
    {
        "content": "<p>Note that, even though Bhavik was not involved in all of the above PRs, he is involved enough in the underlying project that we would like someone else to sign off the above PRs.</p>",
        "id": 466886419,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725268952
    },
    {
        "content": "<p>So far one PR merged and one reviewed. Thanks! Here's one more:</p>",
        "id": 467223411,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725363764
    },
    {
        "content": "<ul>\n<li>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/16447\">#16447</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/16447\">feat: L2 inner product of finite sequences</a>: Define the discrete L2 inner product of functions <code>f g : ι → R</code> where <code>ι</code> is a fintype as <code>∑ i, conj (f i) * g i</code>. This \"duplicates\" <code>inner</code> but is necessary for two reasons:</p>\n<ol>\n<li>It does not need the codomain to be <code>RCLike</code>, notably allowing its use for <code>NNReal</code>-valued functions.</li>\n<li>This is the inner product in the discrete normalisation. A future PR will add a similar API for the \"compact\" one.</li>\n</ol>\n</li>\n</ul>",
        "id": 467223429,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725363769
    },
    {
        "content": "<p>1) feels like it is revealing the existence of a rather larger can of worms</p>",
        "id": 467377893,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1725407332
    },
    {
        "content": "<p>Perhaps Eric is suggesting that it would be good to indicate how this is going to be used later? Understanding just how big the can is might be a prerequisite for reviewing <a href=\"https://github.com/leanprover-community/mathlib4/pull/16447\">#16447</a>.</p>",
        "id": 467417805,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1725427550
    },
    {
        "content": "<p>APAP is freely available online. Searching through, you can find <a href=\"https://github.com/search?q=repo%3AYaelDillies%2FLeanAPAP%20%E2%9F%AB_%5B&amp;type=code\">all uses of the new notation</a> and indeed all of them are either on a generic type or <code>ℝ</code> or <code>ℂ</code>, so I would be happy with the <code>RCLike</code> generality.</p>",
        "id": 467429286,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725431949
    },
    {
        "content": "<p>Let me therefore replace point 1) above by</p>\n<ol start=\"3\">\n<li>I keep on manipulating functions <code>G → K</code> (where <code>G</code> is a finite abelian group) in different norms, so I don't want to be dealing with type synonyms all the time.</li>\n<li>The design of having operations on the original type which can be interpreted as some algebraic or metric structure on a type synonym already exists, eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.eLpNorm#doc\">docs#MeasureTheory.eLpNorm</a> vs <code>‖_‖</code>.</li>\n</ol>",
        "id": 467430136,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725432282
    },
    {
        "content": "<p>My take on the inner product stuff is that we do need duplication somewhere, and having an inner product defined for functions indexed by a finite type is valuable (in the same way we have finite sums as well as integrals, despite the former being a special case of the latter). But I'm not convinced that we need three different versions depending on the choice of normalisation: I think we should give an inner product parametrised by a weighting function (I believe this part is already planned), then the discrete+compact normalisations can be abbreviations of this.</p>",
        "id": 468108827,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1725610125
    },
    {
        "content": "<p>Yes, this seems like an appropriate solution to me.</p>",
        "id": 468260691,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1725647356
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>, <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span>, any more thoughts on <a href=\"https://github.com/leanprover-community/mathlib4/pull/15443\">#15443</a> ?</p>",
        "id": 468881583,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725906617
    },
    {
        "content": "<p><span aria-label=\"ping pong\" class=\"emoji emoji-1f3d3\" role=\"img\" title=\"ping pong\">:ping_pong:</span> <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span></p>",
        "id": 477027016,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729009554
    }
]