[
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/23503\">#23503</a> gives API for the interactions between <code>tsum</code> and <code>ENat</code>. The type is especially nice, because every function is summable, and there are simplifying lemmas like the statement that a sum is infinite iff either some term is infinite, or the support is infinite. </p>\n<p>This provides one of the missing pieces for working painlessly with discrete objects, 'propositional' finiteness and cardinality. For instance, one can sum a function <code>f : a -&gt; ENat</code> over an arbitrary <code>s : Set a</code> with the term <code>‚àë' x : s, 1</code>, and it will be provable that <code>‚àë' x : s, 1 = s.encard</code> and <code>(support f).encard ‚â§ ‚àë' x, f x</code> without ever having to split into finite/infinite cases. </p>\n<p>As is pointed out in the module docstring for <code>Data.ENat.Lattice</code>, there are strong analogies between <code>ENat</code> and <code>ENNReal</code>, and the API runs parallel to the API for <code>tsum</code>/<code>ENNReal</code>. One could call it 'duplication', but I have yet to find a common generalization of the two that saves work, or a third example of a natural type with these same properties.</p>",
        "id": 509276812,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743446620
    },
    {
        "content": "<p>For <code>s : Set a</code>, the PR uses the naming convention <code>tsum_subtype</code> to refer to every summation of the form <code>‚àë' x : s, f x</code>. This is a little inaccurate, but is in line with the established convention for <code>ENNReal</code>. I think ideally both (and <code>tsum</code> API more generally) should be refactored to use the terminology <code>tsum_mem</code> with accompanying notation <code>‚àë' x ‚àà s, f x</code>.</p>",
        "id": 509277162,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743446746
    },
    {
        "content": "<p>The convention coming from general big operators would be to call <code>\\tsum x \\in s, f x</code> <code>btsum</code></p>",
        "id": 509285870,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1743449854
    },
    {
        "content": "<p>This convention (rightly or wrongly) isn't followed by <code>finsum</code>.</p>",
        "id": 509286126,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743449943
    },
    {
        "content": "<p>When you say big operators, what are the examples other than <code>Union</code> and <code>Inter</code>?</p>",
        "id": 509286383,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743450028
    },
    {
        "content": "<p>And <code>Inf</code>/<code>Sup</code>, I suppose. The <code>b</code> being <code>bounded</code> has always sounded unnatural to me.</p>",
        "id": 509286723,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743450166
    },
    {
        "content": "<p>Was there a thread somewhere about why <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENat#src\">src#ENat</a> (and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENNReal#src\">src#ENNReal</a>) is not just an <em><code>abbrev</code></em> for <code>WithTop</code>?</p>",
        "id": 509287370,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743450401
    },
    {
        "content": "<p>I don't remember. Does that change the picture here?</p>",
        "id": 509287983,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743450607
    },
    {
        "content": "<p>Ah, I see your comment now.</p>",
        "id": 509288125,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743450663
    },
    {
        "content": "<p>If both were an abbrev, then you could easily write one set of lemmas for both <code>ENat</code> and <code>ENNReal</code></p>",
        "id": 509288245,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743450709
    },
    {
        "content": "<p>This will be true for a good number of the topology lemmas, yes. This refactor would naturally go back to the lattice lemmas, as per the TODO in the module docstring of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/ENat/Basic.html\">the ENat file</a>.</p>",
        "id": 509288931,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743450947
    },
    {
        "content": "<p>And presumably <code>abbrev</code> comes with tradeoffs in other places?</p>",
        "id": 509289083,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743450991
    },
    {
        "content": "<p>I don't really think it does, because semantically <code>ENat</code> <em>is</em> the same as <code>WithTop Nat</code></p>",
        "id": 509290574,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1743451531
    },
    {
        "content": "<p>Eric, do you think that this is worth holding up this PR over? I agree that it's probably a good refactor, but it will be a nontrivial amount of work.</p>",
        "id": 509291164,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743451734
    },
    {
        "content": "<p>And it's work that I would have rather done before, say, <a href=\"https://github.com/leanprover-community/mathlib4/pull/23454\">#23454</a>, which was just merged.</p>",
        "id": 509291385,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743451816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/509291164\">said</a>:</p>\n<blockquote>\n<p>but it will be a nontrivial amount of work.</p>\n</blockquote>\n<p>I'd at least like to have an implementation note explaining why this is; so far <a href=\"https://github.com/leanprover-community/mathlib4/pull/23509\">#23509</a>  suggests that it is trivial after all</p>",
        "id": 509292489,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743452264
    },
    {
        "content": "<p>The most likely problem I can think of is something like \"<code>ENat</code> has a canonically different X to <code>WithTop Nat</code>\", where <code>X</code> is \"topology\" or similar</p>",
        "id": 509293028,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743452433
    },
    {
        "content": "<p>yeah with <code>finsum</code> people write <code>finsum_mem</code> I guess?</p>",
        "id": 509293074,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743452449
    },
    {
        "content": "<p>The work I am imagining is mathematically trivial, but annoying:  going through a lot of lemmas in the <code>ENat/ENNReal</code> APIs, checking which ones are specific to the type and which ones are abstractly true because of <code>WithTop</code> with the appropriate typeclass, how <code>WithBot</code> interacts with that abstraction, etc etc.</p>",
        "id": 509293182,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743452487
    },
    {
        "content": "<p>My argument for looking at this now is that what you describe becomes more annoying the longer we put off doing it</p>",
        "id": 509293365,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743452546
    },
    {
        "content": "<p>That seems to me like a general argument for not developing API, simply because there exists a hypothetical refactor. <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>  would like to refactor <code>ENat.card</code> to avoid cardinals. Any API in that area will make that harder, but it doesn't mean that adding to the API is unreasonable. There are presumably many other examples in areas of mathlib I'm unfamiliar with that aren't stopping people.</p>",
        "id": 509293987,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743452787
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/509292489\">said</a>:</p>\n<blockquote>\n<p>so far <a href=\"https://github.com/leanprover-community/mathlib4/pull/23509\">#23509</a> suggests that it is trivial after all</p>\n</blockquote>\n<p>Ok, we're now in nontrivial territory, but I think this has identified an instance diamond for <code>WithTop</code> that we should fix anyway</p>",
        "id": 509296799,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743453891
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/509293987\">said</a>:</p>\n<blockquote>\n<p>That seems to me like a general argument for not developing API, simply because there exists a hypothetical refactor.</p>\n</blockquote>\n<p>Yes, I think to a certain extent it is such an argument; if it looks like you are going to develop 100s of theorems of parallel API, then it's probably wise to spend some time exploring the hypothetical refactor, and at least record why it doesn't look promising / is a very large amount of effort.</p>",
        "id": 509297368,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743454100
    },
    {
        "content": "<p>Probably, the main issue with making <code>ENat</code> an <code>abbrev</code> is that the conflict between two coercions (<code>WithTop.some</code> and <code>Nat.cast</code>).</p>",
        "id": 509299635,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1743454978
    },
    {
        "content": "<p>It just occurred to me that the abstraction outlined in the <code>ENat</code> docstring isn‚Äôt quite right, at least for the toplogy aspects. In the monoid of nonnegative rationals with infinity, every element is cancellable or absorbing, but suprema/sums of arbitrary functions aren‚Äôt always defined.</p>",
        "id": 509299921,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743455077
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/509299921\">said</a>:</p>\n<blockquote>\n<p>but suprema/sums of arbitrary functions aren‚Äôt always defined.</p>\n</blockquote>\n<p>What goes wrong if you try to define them as <code>top</code>?</p>",
        "id": 509300357,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743455244
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/509299921\">said</a>:</p>\n<blockquote>\n<p>It just occurred to me that the abstraction outlined in the <code>ENat</code> docstring isn‚Äôt quite right, at least for the toplogy aspects. In the monoid of nonnegative rationals with infinity, every element is cancellable or absorbing, but suprema/sums of arbitrary functions aren‚Äôt always defined.</p>\n</blockquote>\n<p>I can't find that docstring, can you link it for me here?</p>",
        "id": 509300751,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743455399
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/509300357\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/509299921\">said</a>:</p>\n<blockquote>\n<p>but suprema/sums of arbitrary functions aren‚Äôt always defined.</p>\n</blockquote>\n<p>What goes wrong if you try to define them as <code>top</code>?</p>\n</blockquote>\n<p>Then you wouldn't want to use <code>WithTop</code>, you would use something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OnePoint#doc\">docs#OnePoint</a></p>",
        "id": 509301985,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743455681
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/509300751\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/509299921\">said</a>:</p>\n<blockquote>\n<p>It just occurred to me that the abstraction outlined in the <code>ENat</code> docstring isn‚Äôt quite right, at least for the toplogy aspects. In the monoid of nonnegative rationals with infinity, every element is cancellable or absorbing, but suprema/sums of arbitrary functions aren‚Äôt always defined.</p>\n</blockquote>\n<p>I can't find that docstring, can you link it for me here?</p>\n</blockquote>\n<p>On mobile, but it‚Äôs the module docstring of <code>Data.ENat.Basic</code></p>",
        "id": 509302116,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743455736
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/509300357\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/509299921\">said</a>:</p>\n<blockquote>\n<p>but suprema/sums of arbitrary functions aren‚Äôt always defined.</p>\n</blockquote>\n<p>What goes wrong if you try to define them as <code>top</code>?</p>\n</blockquote>\n<p>Non-monotonicity. The supremum of the dedekind cut for an irrational presumably shouldn‚Äôt be <code>top</code></p>",
        "id": 509302327,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743455813
    },
    {
        "content": "<p>Are you referring to this part?</p>\n<blockquote>\n<h2>TODO</h2>\n<p>Unify <code>ENat.add_iSup</code>/<code>ENat.iSup_add</code> with <code>ENNReal.add_iSup</code>/<code>ENNReal.iSup_add</code>. The key property<br>\nof <code>ENat</code> and <code>ENNReal</code> we are using is that all <code>a</code> are either absorbing for addition (<code>a + b = a</code><br>\nfor all <code>b</code>), or that it's order-cancellable (<code>a + b ‚â§ a + c ‚Üí b ‚â§ c</code> for all <code>b</code>, <code>c</code>), and<br>\nsimilarly for multiplication.</p>\n</blockquote>",
        "id": 509302358,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743455826
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/509302358\">said</a>:</p>\n<blockquote>\n<p>Are you referring to this part?</p>\n<blockquote>\n<h2>TODO</h2>\n<p>Unify <code>ENat.add_iSup</code>/<code>ENat.iSup_add</code> with <code>ENNReal.add_iSup</code>/<code>ENNReal.iSup_add</code>. The key property<br>\nof <code>ENat</code> and <code>ENNReal</code> we are using is that all <code>a</code> are either absorbing for addition (<code>a + b = a</code><br>\nfor all <code>b</code>), or that it's order-cancellable (<code>a + b ‚â§ a + c ‚Üí b ‚â§ c</code> for all <code>b</code>, <code>c</code>), and<br>\nsimilarly for multiplication.<br>\n</p>\n</blockquote>\n</blockquote>\n<p>Yes.</p>",
        "id": 509302431,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743455856
    },
    {
        "content": "<p>It‚Äôs hard to think of a good common reason that suprema always exist for <code>ENat</code> and <code>ENNReal</code>.</p>",
        "id": 509305772,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743456962
    },
    {
        "content": "<p>I guess <code>Nat</code> and <code>Real</code> are both <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConditionallyCompleteLattice#doc\">docs#ConditionallyCompleteLattice</a></p>",
        "id": 509305901,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743457001
    },
    {
        "content": "<p>Right, that‚Äôs true. So the <code>WithTop</code> of a conditionally complete lattice is enough. What about sums always existing?</p>",
        "id": 509306142,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743457096
    },
    {
        "content": "<p>Canonical ordering plus conditionally complete should be enough, I guess.</p>",
        "id": 509306246,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743457153
    },
    {
        "content": "<p>There are unfortunately no typeclasses I could find that express a conditionally complete ordered monoid <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 509306558,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743457257
    },
    {
        "content": "<p>Probably because there are basically just two of them :)</p>",
        "id": 509306615,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743457283
    },
    {
        "content": "<p>Anyway, I hope this PR can see its way to being merged for the time being. I just want to prove the handshake theorem for infinite graphs!</p>",
        "id": 509306798,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743457354
    },
    {
        "content": "<p>Maybe the Long Line is an example :-) (or some variant)</p>",
        "id": 509306921,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743457416
    },
    {
        "content": "<p>You can cut off <code>Icc (0 : NNReal) n</code> from the real line and replace it with <code>Icc (0 : Nat) n</code></p>",
        "id": 509308858,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743457990
    },
    {
        "content": "<p>You get a conditionally complete <del>canonically</del> linear ordered cancel add comm monoid (what a mouthful)</p>",
        "id": 509309425,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743458162
    },
    {
        "content": "<p>Could we perhaps revisit this? It seems clear that a refactor which would allow <code>ENat</code>/<code>ENNReal</code> to be unified could be a way off (due to a missing typeclass, among other things), and in the meantime, I would love to be able to sum <code>ENat</code>-valued functions without fussing about finiteness.</p>",
        "id": 510372439,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743858981
    },
    {
        "content": "<p>This doesn't motivate you to do it properly? :-)</p>",
        "id": 510413914,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743888337
    },
    {
        "content": "<p>Somewhat. Half the reason I'm in combinatorics is so I could avoid all this kind of abstract nonsense!</p>\n<p>It looks like I'll need to wait for the unbundling in <a href=\"https://github.com/leanprover-community/mathlib4/pull/20676\">#20676</a> at least, since <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=tsum_le_tsum#doc\">docs#tsum_le_tsum</a> currently needs <code>OrderedAddCommMonoid</code>, which won't play nice with complete lattices + canonical orderings.</p>",
        "id": 510478998,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743943128
    },
    {
        "content": "<p>Ok, I have a question about this. It seems to me that the right setting for abstracting <code>ENNReal</code> and <code>ENat</code> is an 'all sums converge to their supremum' typeclass, but I can't figure out how to express this without quantifying over universes. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- An ordered topological monoid `M` is `SupSummable` if every function `f : Œπ ‚Üí M` is summable,</span>\n<span class=\"sd\">with sum equal to the supremum of the sums of finite subsets. Examples include `‚Ñï‚àû` and `‚Ñù‚â•0‚àû`. -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">SupSummable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SupSet</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">forall_hasSum</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚®Ü</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This typechecks fine, but I don't think it's possible to prove the following theorem, because the indexing type for <code>f</code> is in the wrong universe. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SupSummable</span><span class=\"bp\">.</span><span class=\"n\">hasSum</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SupSet</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">SupSummable</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚®Ü</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Is there a way around this?</p>",
        "id": 510530208,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743982020
    },
    {
        "content": "<p>I think it's sufficient to just consider functions <code>f : (M ‚Üí M) ‚Üí M</code></p>",
        "id": 510530632,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743982360
    },
    {
        "content": "<p>And then this extends to all functions over any universe</p>",
        "id": 510530669,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743982411
    },
    {
        "content": "<p>How does one prove this?</p>",
        "id": 510530763,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743982479
    },
    {
        "content": "<p>I'll try to come up with a proof</p>",
        "id": 510531756,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743983324
    },
    {
        "content": "<p>Maybe that works. Alternatively... does mathlib ever use infinite sums with uncountable indexing types?</p>",
        "id": 510621265,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744020845
    },
    {
        "content": "<p>The other similar question is whether there are any examples that aren‚Äôt just canonically ordered sup-semilattices. This might simply be abstraction for its own sake</p>",
        "id": 510621809,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744020977
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/510621265\">said</a>:</p>\n<blockquote>\n<p>Maybe that works. Alternatively... does mathlib ever use infinite sums with uncountable indexing types?</p>\n</blockquote>\n<p>Actually maybe the answer here is yes - one of the basic lemmas in this area is that the <code>tsum</code> of <code>1 : ENat</code> over <code>a : Type u</code> is <code>ENat.card a</code>. It would be annoying if that and the many other similar lemmas didn‚Äôt slot into the API because there is a universe constraint.</p>",
        "id": 510622946,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744021295
    },
    {
        "content": "<p>Ok, after more tinkering I believe that a new class is the wrong approach - I think that in practice, 'all sums exists' coincides with 'canonical ordering' in all the interesting cases, so the API should be written in terms of canonically ordered monoids with <code>Sup</code>. </p>\n<p>This will lead to lots of pairs of theorems like the following: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- already exists in mathlib</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">tsum_add</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">T2Space</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ContinuousAdd</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">‚àë'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚àë'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">‚àë'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- version in a setting where summability comes for free</span>\n<span class=\"c1\">-- This will replace both `ENNReal.tsum_add` and a hypothetical `ENat.tsum_add`.</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">tsum_add'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteLattice</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">IsOrderedAddMonoid</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CanonicallyOrderedAdd</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">T2Space</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">‚àë'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚àë'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">‚àë'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Priming the names of all these as above is not ideal - a protected namespace is maybe the best option? <br>\nI was thinking <code>Summable.tsum_add</code> in place of <code>tsum_add'</code>, even though the dot notation might make more sense with the first one. <code>CanonicallyOrderedAdd.tsum_add</code> is maybe more true to the mathematics, but it is a long name for an API lemma. </p>\n<p>Any thoughts?</p>",
        "id": 510707031,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744040645
    },
    {
        "content": "<p>Here's another version of your definition which simplifies things to avoid indexing at all:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">InfiniteSum</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">Topology</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">SupSummable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SupSet</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">forall_hasSum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">‚®Ö</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ùìü</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">ùìù</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n\n<span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SupSummable</span><span class=\"bp\">.</span><span class=\"n\">hasSum</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SupSet</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">SupSummable</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚®Ü</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forall_hasSum</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">le_def</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">subset_def</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">classical</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum_union</span><span class=\"w\"> </span><span class=\"n\">disjoint_sdiff_self_right</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">union_eq_right</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>it's not really the same property (it's stronger) but I think it still holds for enat and ennreal</p>",
        "id": 510714022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744042552
    },
    {
        "content": "<p>and yeah, this is basically saying that the sup is well behaved with respect to the canonical order induced by the addition</p>",
        "id": 510714308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744042625
    },
    {
        "content": "<p>I think the sum of <code>f : Œπ ‚Üí M</code> is equivalent to the sum of the following function from <code>‚Ñï √ó M</code> to <code>M</code>: if <code>f ‚Åª¬π' {m}</code> is infinite for <code>m : M</code> then set <code>(n, m) ‚Ü¶ m</code> for all <code>n : ‚Ñï</code>, and if <code>f ‚Åª¬π' {m}</code> has finite cardinality <code>c</code> then set <code>(n, m) ‚Ü¶ m</code> for <code>n &lt; c</code> and <code>(n, m) ‚Ü¶ 0</code> otherwise.</p>\n<p>They're equivalent in the sense that if one function HasSum then the other also, in which case they have the same sum(s). The reason is that if you have a Finset in <code>Œπ</code> then you can produce a Finset in <code>‚Ñï √ó M</code> that has the same sum and the sets of sums of their finite supersets are equal, and vice versa.</p>",
        "id": 510725492,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1744045801
    },
    {
        "content": "<p>I have a partially completed proof here</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"sd\">/-- An ordered topological monoid `M` is `SupSummable` if every function `f : Œπ ‚Üí M` is summable,</span>\n<span class=\"sd\">with sum equal to the supremum of the sums of finite subsets. Examples include `‚Ñï‚àû` and `‚Ñù‚â•0‚àû`. -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">SupSummable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SupSet</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">forall_hasSum</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚®Ü</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SupSummable</span><span class=\"bp\">.</span><span class=\"n\">hasSum</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SupSet</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">SupSummable</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚®Ü</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">classical</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SupSummable</span><span class=\"bp\">.</span><span class=\"n\">forall_hasSum</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mU</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toEnumFinset</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hmU</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">mU</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mU</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">sum_toEnumFinset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">mapEquiv</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum_comp</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">mapEquiv_apply</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">conv_lhs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">enter</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">equals</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">if_pos</span>\n<span class=\"w\">        </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">cast_lt</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">isLt</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans_le</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">count_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">mapEquiv_apply</span><span class=\"o\">,</span>\n<span class=\"w\">          </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">filter_val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">card_val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">encard_coe_eq_coe_finsetCard</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">encard_mono</span>\n<span class=\"w\">        </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">coe_filter</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_preimage</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_singleton</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum_eq_multiset_sum</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">map_univ</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">cRev</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"bp\">.</span><span class=\"n\">to_subtype</span><span class=\"bp\">.</span><span class=\"n\">equivFin</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">          </span><span class=\"bp\">‚ü®</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card_coe_set_eq</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∏</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">cast_lt</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"bp\">.</span><span class=\"n\">cast_ncard_eq</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∏</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">‚ü©</span>\n<span class=\"w\">      </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Infinite</span><span class=\"bp\">.</span><span class=\"n\">natEmbedding</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mL</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">filterMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cRev</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">na</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nb</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">hac</span><span class=\"w\"> </span><span class=\"n\">hbc</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">mem_def</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">map_eq_some'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hac</span><span class=\"w\"> </span><span class=\"n\">hbc</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">‚ü®‚ü®</span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hal</span><span class=\"bp\">‚ü©</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hla</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hac</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">‚ü®‚ü®</span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hbl</span><span class=\"bp\">‚ü©</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hlb</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hbc</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_preimage</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_singleton_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hal</span><span class=\"w\"> </span><span class=\"n\">hbl</span>\n<span class=\"w\">    </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hal</span><span class=\"w\"> </span><span class=\"n\">hbl</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">cRev</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">dite_none_right_eq_some</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">some_inj</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hla</span><span class=\"w\"> </span><span class=\"n\">hlb</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">ha</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hla</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hla</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">hb</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hlb</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hlb</span>\n<span class=\"w\">    </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">Finite</span>\n<span class=\"w\">    </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">dif_pos</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hla</span><span class=\"w\"> </span><span class=\"n\">hlb</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hla</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">hlb</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)))</span>\n<span class=\"w\">    </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">dif_neg</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hla</span><span class=\"w\"> </span><span class=\"n\">hlb</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Embedding</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hla</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">hlb</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hmL</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">mL</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mL</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">iSup</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hfg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">    </span><span class=\"n\">constructor</span>\n<span class=\"w\">    </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">‚ü©</span>\n<span class=\"w\">      </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">mU</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hmU</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">    </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">‚ü©</span>\n<span class=\"w\">      </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">mL</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hmL</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hfg</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n<span class=\"w\">  </span><span class=\"n\">specialize</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">mem_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">mem_atTop_sets</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hu</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hg</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">mL</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">hv</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">iI</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"o\">(({</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span><span class=\"bp\">·∂ú</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">finite_toSet</span><span class=\"bp\">.</span><span class=\"n\">infinite_compl</span><span class=\"bp\">.</span><span class=\"n\">to_subtype</span>\n<span class=\"w\">  </span><span class=\"n\">specialize</span><span class=\"w\"> </span><span class=\"n\">hu</span>\n<span class=\"w\">    </span><span class=\"o\">(((</span><span class=\"n\">mU</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">mL</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span>\n<span class=\"w\">      </span><span class=\"bp\">‚ü®</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">,</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">orderIsoOfNat</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span><span class=\"bp\">·∂ú</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">          </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">na</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nb</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"n\">hab</span>\n<span class=\"w\">          </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">ext_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span>\n<span class=\"w\">          </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hab</span>\n<span class=\"w\">          </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hab</span>\n<span class=\"w\">          </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">OrderIso</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"bp\">‚ü©‚ü©</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">disjUnion</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">disjoint_left</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">hu</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">mem_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">exists</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Embedding</span><span class=\"bp\">.</span><span class=\"n\">coeFn_mk</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">ext_iff</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"bp\">@</span><span class=\"n\">and_left_comm</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_and_left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_eq_left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mU</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mL</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">mem_of_mem_toEnumFinset</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">mem_map</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">orderIsoOfNat</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span><span class=\"bp\">·∂ú</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prop</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hff</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">mem_filter</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">hu</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">‚ü©</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">mem_image_of_mem</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hff</span>\n<span class=\"w\">    </span><span class=\"n\">rwa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">mem_coe</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">disjUnion_eq_union</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∏</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">subset_union_right</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_preimage</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hu</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum_disjUnion</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Embedding</span><span class=\"bp\">.</span><span class=\"n\">coeFn_mk</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hu</span>\n<span class=\"w\">  </span><span class=\"n\">conv</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hu</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">lhs</span>\n<span class=\"w\">    </span><span class=\"n\">equals</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">mU</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">mL</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum_congr</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"o\">(({</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span><span class=\"bp\">·∂ú</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)}</span><span class=\"bp\">.</span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">        </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">infinite_coe_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iI</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">g</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mU</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">mem_toEnumFinset</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">count_map</span><span class=\"o\">,</span>\n<span class=\"w\">        </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">filter_val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">card_val</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hun</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">          </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">orderIsoOfNat</span><span class=\"w\"> </span><span class=\"o\">(({</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span><span class=\"bp\">·∂ú</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">          </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">nth</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"o\">(({</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span><span class=\"bp\">·∂ú</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">nth_eq_orderIsoOfNat</span><span class=\"w\"> </span><span class=\"n\">hI</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">          </span><span class=\"o\">((</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">orderIsoOfNat</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span><span class=\"bp\">·∂ú</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span>\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hun</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"gr\">sorry</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hh</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span>\n<span class=\"w\">          </span><span class=\"o\">((</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">orderIsoOfNat</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span><span class=\"bp\">·∂ú</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">        </span><span class=\"n\">hun</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∏</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_nth</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hF</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hF</span><span class=\"bp\">.</span><span class=\"n\">not_infinite</span><span class=\"w\"> </span><span class=\"n\">hI</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">if_pos</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">if_pos</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">cast_le</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"n\">hh</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_lt</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">rwa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hmU</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">hmL</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum_sdiff</span><span class=\"w\"> </span><span class=\"n\">hv</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hu</span>\n</code></pre></div>",
        "id": 510726890,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744046255
    },
    {
        "content": "<p>Thanks all three for your help!</p>",
        "id": 510727439,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744046432
    },
    {
        "content": "<p>We could aim for the more general result:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Card</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">InfiniteSum</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hasSum_iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and the first step would be to define maps <code>Œ≤ ‚Üí Œ≥</code> and <code>Œ≥ ‚Üí Œ≤</code> and then monotonic maps <code>Finset Œ≤ ‚Üí Finset Œ≥</code> and <code>Finset Œ≥ ‚Üí Finset Œ≤</code>. On the finite fibers an Equiv can be obtained from the identity on cardinalities, and on the infinite fibers we'd need <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/SetTheory/Cardinal/SchroederBernstein.html#Function.Embedding.total\">Function.Embedding.total</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Logic/Function/Basic.html#Function.invFun\">Function.invFun</a>.</p>",
        "id": 510743815,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1744051869
    },
    {
        "content": "<p>Re the naming: there are lemmas for groups and analogous lemmas for groups-with-zero which have got a 0 subscript rather than a <code>'</code>, I wonder if you can do the same thing here? Like a subscript e for extended or something?</p>",
        "id": 510755590,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744055852
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/510707031\">said</a>:</p>\n<blockquote>\n<p>I was thinking <code>Summable.tsum_add</code> in place of <code>tsum_add'</code>, even though the dot notation might make more sense with the first one. <code>CanonicallyOrderedAdd.tsum_add</code> is maybe more true to the mathematics, but it is a long name for an API lemma.</p>\n</blockquote>\n<p>I think the answer to the naming issue is obvious: <code>Summable.tsum_add</code> for the one that take a summability hypothesis, and <code>tsum_add</code> for the ones that don't. (And no, I don't care that this means we're switching the existing names.)</p>",
        "id": 510772342,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744062215
    },
    {
        "content": "<p>Won't that be really annoying because most of the time people are working with the reals so will want <code>Summable.tsum_add</code> and they'll open <code>Summable</code> and then get a name clash?</p>",
        "id": 510772521,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744062287
    },
    {
        "content": "<p><code>protected</code>, obviously.</p>",
        "id": 510772589,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744062322
    },
    {
        "content": "<p>I would argue that many times you'll be taking advantage of dot notation anyway.</p>",
        "id": 510772654,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744062360
    },
    {
        "content": "<p>And this regex has only a false positive hit: <code>open [A-Za-z ]* Summable</code></p>",
        "id": 510772830,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744062433
    },
    {
        "content": "<p>It just seems very weird to have the more common usage in a namespace and the rarer one in the root namespace. Is all of this just to save supplying the theorem that sums in ENNReal and enat are all summable? Why not just give <em>that</em> a short name or abbrev and just supply it where needed?</p>",
        "id": 510776146,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744064015
    },
    {
        "content": "<ol>\n<li>It's not at all obvious to me that <code>‚Ñù‚â•0‚àû</code> is less common than <code>‚Ñù</code>. (in fact,  after writing this bullet I did <code>rg tsum_add Mathlib</code> which seems to suggest otherwise, and even some of the uses of <code>_root_.tsum_add</code> should actually be replaced with <code>ENNReal.tsum_add</code> <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span>)</li>\n<li>and as I've evidenced above, apparently no one does <code>open Summable</code>, despite the fact that there are 105 things in the <span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> \"Summable.\" namespace. Dot notation is evidently sufficient.</li>\n</ol>\n<p>So ... ball is in your court Kevin. <span aria-label=\"tennis\" class=\"emoji emoji-1f3be\" role=\"img\" title=\"tennis\">:tennis:</span></p>",
        "id": 510783367,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744068017
    },
    {
        "content": "<p><span aria-label=\"exclamation\" class=\"emoji emoji-2757\" role=\"img\" title=\"exclamation\">:exclamation:</span> &lt;input&gt;:1:12: expected end of input</p>",
        "id": 510783369,
        "sender_full_name": "loogle",
        "timestamp": 1744068018
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> \"Summable.\"</p>",
        "id": 510783406,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744068033
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Algebra/InfiniteSum/Defs.html#Summable.eq_1\">Summable.eq_1</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Algebra/InfiniteSum/Defs.html#Summable.hasSum\">Summable.hasSum</a>, and <a href=\"https://loogle.lean-lang.org/?q=%22Summable.%22\">103 more</a></p>",
        "id": 510783411,
        "sender_full_name": "loogle",
        "timestamp": 1744068033
    },
    {
        "content": "<p>(and after inspection, I think all of the <code>_root_.tsum_add</code> uses could benefit from the dot notation introduced by <code>Summable.tsum_add</code>)</p>",
        "id": 510783887,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744068275
    },
    {
        "content": "<p>and there is some small precedent: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Summable.tsum_mul_left#doc\">docs#Summable.tsum_mul_left</a></p>",
        "id": 510784088,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744068382
    },
    {
        "content": "<p>Would the same argument apply to moving things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=deriv_add#doc\">docs#deriv_add</a> ?</p>",
        "id": 510785282,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744069078
    },
    {
        "content": "<p>In that case, I'm not sure whether the dot notation argument wins or not. But the situations aren't really analogous because there isn't some type where you're always guaranteed differentiability that should warrant the root namespace.</p>",
        "id": 510787982,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744070569
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/510776146\">said</a>:</p>\n<blockquote>\n<p>Is all of this just to save supplying the theorem that sums in ENNReal and enat are all summable? Why not just give <em>that</em> a short name or abbrev and just supply it where needed?</p>\n</blockquote>\n<p><code>simp</code> will definitely prefer the version where you don't need to supply anything.</p>",
        "id": 510832870,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744085310
    },
    {
        "content": "<p>sure, but simp can definitely handle having two theorems, one for ennreal and one for enat in the simpset</p>",
        "id": 510856976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744097029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/510772521\">said</a>:</p>\n<blockquote>\n<p>Won't that be really annoying because most of the time people are working with the reals so will want <code>Summable.tsum_add</code> and they'll open <code>Summable</code> and then get a name clash?</p>\n</blockquote>\n<p>Why would you <code>open Summable</code>?</p>",
        "id": 510859437,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1744097787
    },
    {
        "content": "<p>My memory of using this stuff in LTE (the only time I ever used it) was that you rewrote the theorem and then you got the summability hypothesis as an extra goal. This now becomes <code>rw [Summable.tsum_add]</code>. I guess the question is whether the typical application has a summability hypothesis lying around or whether it's something one expects to deal with later. </p>\n<p>In the algebra hierarchy we're moving away from <code>MonoidHom.map_mul,</code> and trying to make a global <code>map_mul</code> the default. This feels like going the other way.</p>",
        "id": 510861465,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744098363
    },
    {
        "content": "<p>But I'm not a big user of these theorems so my opinion should be taken with a pinch of salt</p>",
        "id": 510861824,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744098483
    },
    {
        "content": "<p>I agree that the summability will rather come off as a side condition, instead of being something that is available for dot notation. So, having the two versions in the root namespace, but with a subscript like <code>tsum_add</code> and <code>tsum_add‚Çë</code> (like we have a zero subscript for groups with zero), looks better to me.</p>",
        "id": 510862427,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1744098651
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/510861465\">said</a>:</p>\n<blockquote>\n<p>In the algebra hierarchy we're moving away from <code>MonoidHom.map_mul,</code> and trying to make a global <code>map_mul</code> the default. This feels like going the other way.</p>\n</blockquote>\n<p>I think the connection between the two situations you're referring to is as tenuous as \"both lemmas are in a namespace\"</p>",
        "id": 510872659,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1744101674
    },
    {
        "content": "<p>Fair enough. As I say, I am not a frequent user of this API.</p>",
        "id": 510875539,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744102467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/510776146\">said</a>:</p>\n<blockquote>\n<p>Is all of this just to save supplying the theorem that sums in ENNReal and enat are all summable? Why not just give <em>that</em> a short name or abbrev and just supply it where needed?</p>\n</blockquote>\n<p>There are also other conditions in certain lemmas, like global nonnegativity, that come from canonicality for <code>ENat</code>/<code>ENNReal</code>, but need to be explicit at the setting of the general api. <code>(by simp)</code> is not that big a deal, but having it appear twice just in api lemma invocations is annoying. And the pragmatic decision to have specialized assumption-free lemmas has apparently already been made for ENNReal, independently of this discussion.</p>",
        "id": 510903269,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744110824
    },
    {
        "content": "<p>Could we assign an autoparam to the various side condition arguments?</p>",
        "id": 510928415,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1744117749
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/510862427\">said</a>:</p>\n<blockquote>\n<p>I agree that the summability will rather come off as a side condition, instead of being something that is available for dot notation.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> did you actually run <code>rg [^\\.]tsum_add Mathlib</code>?</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>output</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code><span class=\"o\">[</span>jireh@boston<span class=\"w\"> </span>mathlib4<span class=\"o\">]</span>$<span class=\"w\"> </span>rg<span class=\"w\"> </span><span class=\"o\">[</span>^<span class=\"se\">\\.</span><span class=\"o\">]</span>tsum_add<span class=\"w\"> </span>Mathlib\nMathlib/Probability/Kernel/Defs.lean\n<span class=\"m\">288</span>:<span class=\"w\">    </span>Measure.coe_add,<span class=\"w\"> </span>tsum_add<span class=\"w\"> </span>ENNReal.summable<span class=\"w\"> </span>ENNReal.summable<span class=\"o\">]</span>\n\nMathlib/NumberTheory/LSeries/Nonvanishing.lean\n<span class=\"m\">296</span>:<span class=\"w\">    </span>‚Üê<span class=\"w\"> </span>tsum_add<span class=\"w\"> </span>hsum‚ÇÄ<span class=\"w\"> </span>hsum‚ÇÅ,<span class=\"w\"> </span>‚Üê<span class=\"w\"> </span>tsum_add<span class=\"w\"> </span><span class=\"o\">(</span>hsum‚ÇÄ.add<span class=\"w\"> </span>hsum‚ÇÅ<span class=\"o\">)</span><span class=\"w\"> </span>hsum‚ÇÇ<span class=\"o\">]</span>\n\nMathlib/NumberTheory/LSeries/Linearity.lean\n<span class=\"m\">43</span>:<span class=\"w\">  </span>simpa<span class=\"w\"> </span><span class=\"o\">[</span>LSeries,<span class=\"w\"> </span>term_add<span class=\"o\">]</span><span class=\"w\"> </span>using<span class=\"w\"> </span>tsum_add<span class=\"w\"> </span>hf<span class=\"w\"> </span>hg\n\nMathlib/Topology/Instances/ENNReal/Lemmas.lean\n<span class=\"m\">619</span>:protected<span class=\"w\"> </span>theorem<span class=\"w\"> </span>tsum_add<span class=\"w\"> </span>:<span class=\"w\"> </span>‚àë<span class=\"s1\">' a, (f a + g a) = ‚àë'</span><span class=\"w\"> </span>a,<span class=\"w\"> </span>f<span class=\"w\"> </span>a<span class=\"w\"> </span>+<span class=\"w\"> </span>‚àë<span class=\"s1\">' a, g a :=</span>\n<span class=\"s1\">620:  tsum_add ENNReal.summable ENNReal.summable</span>\n<span class=\"s1\">799:theorem tsum_add_one_eq_top {f : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} (hf : ‚àë'</span><span class=\"w\"> </span>n,<span class=\"w\"> </span>f<span class=\"w\"> </span><span class=\"nv\">n</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span>‚àû<span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span>hf0<span class=\"w\"> </span>:<span class=\"w\"> </span>f<span class=\"w\"> </span><span class=\"m\">0</span><span class=\"w\"> </span>‚â†<span class=\"w\"> </span>‚àû<span class=\"o\">)</span><span class=\"w\"> </span>:\n\nMathlib/Topology/MetricSpace/PiNat.lean\n<span class=\"m\">826</span>:<span class=\"w\">      </span><span class=\"nv\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span>dist<span class=\"w\"> </span>x<span class=\"w\"> </span>y<span class=\"w\"> </span>+<span class=\"w\"> </span>dist<span class=\"w\"> </span>y<span class=\"w\"> </span>z<span class=\"w\"> </span>:<span class=\"o\">=</span><span class=\"w\"> </span>tsum_add<span class=\"w\"> </span><span class=\"o\">(</span>dist_summable<span class=\"w\"> </span>x<span class=\"w\"> </span>y<span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span>dist_summable<span class=\"w\"> </span>y<span class=\"w\"> </span>z<span class=\"o\">)</span>\n\nMathlib/Analysis/InnerProductSpace/l2Space.lean\n<span class=\"m\">133</span>:<span class=\"w\">        </span><span class=\"nv\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">(</span>‚àë<span class=\"s1\">' i, ‚ü™f‚ÇÅ i, g i‚ü´) + ‚àë'</span><span class=\"w\"> </span>i,<span class=\"w\"> </span>‚ü™f‚ÇÇ<span class=\"w\"> </span>i,<span class=\"w\"> </span>g<span class=\"w\"> </span>i‚ü´<span class=\"w\"> </span>:<span class=\"o\">=</span><span class=\"w\"> </span>tsum_add<span class=\"w\"> </span>?_<span class=\"w\"> </span>?_\n<span class=\"m\">189</span>:<span class=\"w\">    </span>simp<span class=\"w\"> </span>only<span class=\"w\"> </span><span class=\"o\">[</span>tsum_add<span class=\"w\"> </span><span class=\"o\">(</span>hV.summable_of_lp<span class=\"w\"> </span>f<span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span>hV.summable_of_lp<span class=\"w\"> </span>g<span class=\"o\">)</span>,<span class=\"w\"> </span>lp.coeFn_add,<span class=\"w\"> </span>Pi.add_apply,\n\nMathlib/MeasureTheory/OuterMeasure/OfAddContent.lean\n<span class=\"m\">95</span>:<span class=\"w\">  </span>rw<span class=\"w\"> </span><span class=\"o\">[</span>tsum_add<span class=\"w\"> </span>ENNReal.summable<span class=\"w\"> </span>ENNReal.summable<span class=\"o\">]</span>\n\nMathlib/MeasureTheory/Measure/MeasureSpace.lean\n<span class=\"m\">1231</span>:<span class=\"w\">  </span>exact<span class=\"w\"> </span>tsum_add_tsum_compl<span class=\"w\"> </span><span class=\"o\">(</span>f<span class=\"w\"> </span>:<span class=\"o\">=</span><span class=\"w\"> </span>fun<span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"o\">=</span>&gt;<span class=\"w\"> </span>Œº<span class=\"w\"> </span>i<span class=\"w\"> </span>t<span class=\"o\">)</span><span class=\"w\"> </span>ENNReal.summable<span class=\"w\"> </span>ENNReal.summable\n<span class=\"m\">1239</span>:<span class=\"w\">    </span>tsum_add<span class=\"w\"> </span>ENNReal.summable<span class=\"w\"> </span>ENNReal.summable<span class=\"o\">]</span>\n</code></pre></div>\n</div></div>",
        "id": 510936070,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744119334
    },
    {
        "content": "<p>Nice! In all these examples, the side condition is sufficiently simple to discharge that it could be done directly with dot notation, so indeed they seem to point in the direction that <code>Summable.tsum_add</code> is a very good option.</p>",
        "id": 510940717,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1744120357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/510928415\">said</a>:</p>\n<blockquote>\n<p>Could we assign an autoparam to the various side condition arguments?</p>\n</blockquote>\n<p>I never know when autoparams should be used - I tend to find them annoying and slow, but this might just be because the ones I use the most use a slow tactic. </p>\n<p>Are there analogous situations where they have worked well?</p>",
        "id": 510940902,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744120410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/510743815\">said</a>:</p>\n<blockquote>\n<p>We could aim for the more general result:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Card</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">InfiniteSum</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hasSum_iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and the first step would be to define maps <code>Œ≤ ‚Üí Œ≥</code> and <code>Œ≥ ‚Üí Œ≤</code> and then monotonic maps <code>Finset Œ≤ ‚Üí Finset Œ≥</code> and <code>Finset Œ≥ ‚Üí Finset Œ≤</code>. On the finite fibers an Equiv can be obtained from the identity on cardinalities, and on the infinite fibers we'd need <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/SetTheory/Cardinal/SchroederBernstein.html#Function.Embedding.total\">Function.Embedding.total</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Logic/Function/Basic.html#Function.invFun\">Function.invFun</a>.</p>\n</blockquote>\n<p>This is a tempting honeypot - but I think it calls for a sanity check. Is there any reasonable example of a type where <code>tsum</code>s always converge, that is <em>not</em> a canonically ordered complete lattice? Because that's where a <code>SupSummable</code> typeclass would make sense.</p>",
        "id": 510942162,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744120708
    },
    {
        "content": "<p>My example <a class=\"message-link\" href=\"/#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/509308858\">#PR reviews &gt; #23503 ENat and tsum @ üí¨</a> is not canonically ordered</p>",
        "id": 510946092,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744121567
    },
    {
        "content": "<p>But I also see that as a constructed example unlikely to be encountered in practice.</p>",
        "id": 510946231,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744121601
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/510940902\">said</a>:</p>\n<blockquote>\n<p>I never know when autoparams should be used - I tend to find them annoying and slow, but this might just be because the ones I use the most use a slow tactic.</p>\n</blockquote>\n<p>We use autoparams liberally in the continuous functional calculus, for arguments involving continuity (using a wrapper around <code>fun_prop</code>), showing <code>f 0 = 0</code> for the function <code>f</code> in question (using <code>aesop</code>, note that <code>map_zero f</code> generally doesn't apply), and for showing that an eleement <code>a : A</code> in a C‚ãÜ-algebra is normal, selfadjoint, or nonnegative (using an <code>aesop</code> wrapper).</p>\n<p>It works well, for the most part. There are a few places where it can be slow which we are still debugging (e.g., certain <code>aesop</code> calls take a long time, or <code>fun_prop</code> can be slow due to too much type class synthesis, which is not the fault of <code>fun_prop</code> exactly).</p>\n<p>However, I wouldn't recommend an autoparam for <code>Summable</code>, as I don't think there is a one-size-fits-most approach to proving goals of that form.</p>",
        "id": 510948202,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744122073
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 510948834,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744122230
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 510957298,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744124288
    },
    {
        "content": "<p>Ok : my plan, based on the above discussion, is the  following: </p>\n<ol>\n<li>make a PR moving all <code>tsum_foo</code> lemmas with <code>Summable</code> hypotheses to a protected <code>Summable</code> namespace, and deprecating the old names. </li>\n<li>In a couple of weeks, make a PR that abstracts the lemmas of the form <code>ENNReal.tsum_foo</code> to <code>tsum_foo</code>, with <code>[CanonicallyOrderedAdd]</code> and <code>[CompleteLattice]</code> hypotheses. </li>\n</ol>\n<p>Of course, I probably mean <code>tprod</code>/<code>mul</code> with to <code>@[toAdditive]</code> everywhere.</p>",
        "id": 510967071,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744126747
    },
    {
        "content": "<p>Please, anyone, let me know now if you think this doesn't reflect a consensus.</p>",
        "id": 510967420,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744126831
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/23959\">#23959</a> (part 1 of the above) is now ready.</p>",
        "id": 511696357,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744390628
    },
    {
        "content": "<p>In the changes that needed to be made, I think there was only one place where I couldn't use dot notation in fixing it. Nearly everywhere, the summability hypotheses either already existed or were proved inline. This bodes well for minimal levels of annoyingness from this change.</p>",
        "id": 511696799,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744390799
    },
    {
        "content": "<p>As <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> pointed out, my process for deprecating with <code>to_additive</code> was incorrect. The current version of <a href=\"https://github.com/leanprover-community/mathlib4/pull/23959\">#23959</a> actually renames/deprecates everything correctly, and so it touches 60 files, mostly just inside proofs. In more than 90% of cases, having to write <code>Summable.tsum_foo</code> can be trivially avoided with dot notation. </p>\n<p>Because of the large footprint, I am guessing this will rot quickly. It took me a while, so if someone could merge soon, that would be great!</p>",
        "id": 511844927,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744492080
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/509306558\">said</a>:</p>\n<blockquote>\n<p>There are unfortunately no typeclasses I could find that express a conditionally complete ordered monoid <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>\n</blockquote>\n<p>This can now be done with <code>IsOrderedMonoid</code> on <code>master</code>, meaning that it should now be possible unify <code>ENNReal</code> and <code>ENat</code> I'm guessing? Although it's not clear to me that this helps, because e.g. <code>ENNReal</code> isn't an abbrev.</p>",
        "id": 511913542,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744555111
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2323503.20ENat.20and.20tsum/near/511913542\">said</a>:</p>\n<blockquote>\n<p>Although it's not clear to me that this helps, because e.g.<code> ENNReal</code> isn't an abbrev.</p>\n</blockquote>\n<p>It is if we merge <a href=\"https://github.com/leanprover-community/mathlib4/pull/23509\">#23509</a></p>",
        "id": 511915195,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744556397
    },
    {
        "content": "<p>(or more realistically, spend some time working out what the performance issue is, then do so)</p>",
        "id": 511915263,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744556436
    },
    {
        "content": "<p>Just for clarity : my plan is orthogonal to the <code>abbrev</code> issue - I am simply going to write <code>tsum</code> API for <code>CompleteLattice</code> + <code>AddCommMonoid</code> + <code>IsOrderedAddMonoid</code> + <code>CanonicallyOrderedAdd</code>, which will then apply to <code>ENat</code> and <code>ENNReal</code>, independently of how they are defined using <code>WithTop</code>.</p>\n<p>The <code>abbrev</code> will allow them to get these instances automatically via <code>Nat</code>/<code>NNReal</code>. </p>\n<p>Does this look right?</p>",
        "id": 511918194,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744558970
    },
    {
        "content": "<p>Yes that looks sensible.</p>",
        "id": 511918302,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744559044
    },
    {
        "content": "<p>Great. And thanks for the review, Kevin. Now there are a lot more protected <code>Summable</code> lemmas in mathlib.</p>",
        "id": 511921706,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1744561367
    }
]