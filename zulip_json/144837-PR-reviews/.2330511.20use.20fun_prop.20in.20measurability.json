[
    {
        "content": "<p>In this PR, I experimented with changing the <code>measurability</code> tactic to use <code>fun_prop</code> for solving <code>Measurable</code> goals. This way, the tactic becomes more reliable (for example,  <code>Measurable (inner ℝ (1 : ℝ))</code> is currently only solved by <code>fun_prop</code>), and hopefully faster, since there is less need for unification. There are a few lemmas that can't be used anymore by <code>measurability</code>, but no changes to proofs were needed.</p>\n<p>I also changed the <code>@[measurability]</code> attribute to automatically apply <code>@[fun_prop]</code> when it detects a <code>fun_prop</code> statement, so the backward compatibility impact in downstream projects should be minimal, unless they use <code>@[aesop ...]</code> directly.</p>",
        "id": 547048382,
        "sender_full_name": "Attila Gáspár",
        "timestamp": 1761389561
    },
    {
        "content": "<p>This is great, thank you. Backwards compatible changes are nice, and faster proofs also.</p>",
        "id": 547054357,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1761395615
    },
    {
        "content": "<p>At the same time, I wonder what the eventual goal should be: if <code>measurability</code> just calls <code>fun_prop</code> for some goals, I think we should use <code>fun_prop</code> for them. Similarly, I think we should rather tag a lemma <code>fun_prop</code> on the nose than via a <code>measurability</code> attribute.</p>",
        "id": 547054421,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1761395690
    },
    {
        "content": "<p><code>measurability</code> can also prove <code>MeasurableSet</code> goals, which fun_prop cannot (and is not meant to). IIRC, there are medium-term plans for a replacement also, but I don't remember what it was (and how far away this is). <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> I believe you mentioned them, can you fill in the details?</p>",
        "id": 547054503,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1761395772
    },
    {
        "content": "<p>There are some cases where <code>fun_prop</code> cannot solve a <code>Measurable</code> goal, see <a href=\"https://github.com/leanprover-community/mathlib4/blob/3b127adc1d72b833915fb15bb0340dbbe83897fd/MathlibTest/measurability.lean#L131\">this example</a>. I solved this using <code>fun_prop (disch := measurability)</code> so that it can switch back and forth between <code>aesop</code> and <code>fun_prop</code>.</p>\n<p>Turning <code>@[measurability]</code> into <code>@[fun_prop]</code> is just for backward compatibility. In the future, a warning could be added when this happens, but we would need to remove them first. This PR removes only the <code>@[aesop ...]</code> attributes from <code>Measurable</code> statements.</p>",
        "id": 547057347,
        "sender_full_name": "Attila Gáspár",
        "timestamp": 1761398409
    },
    {
        "content": "<p>Indeed, <code>fun_prop</code> cannot prove measurability of sets (but using the measurability discharger is a nice solution).</p>",
        "id": 547058407,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1761399458
    },
    {
        "content": "<p>We could also add the <code>fun_prop</code> tag to all measurability lemmas which can use it. That's welcome work (it just needs careful reviewing, as not all measurability lemmas are good fun_prop lemmas).</p>",
        "id": 547058439,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1761399502
    },
    {
        "content": "<p>If you'd like to work on that, I'll try to review it!</p>",
        "id": 547058450,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1761399512
    },
    {
        "content": "<p>I think this is a great first step!</p>\n<p>The end goal I want to achieve is:</p>\n<ul>\n<li><code>measurability</code> (for functions), <code>continuity</code>, etc. are deprecated and then removed in favor of <code>fun_prop</code></li>\n<li><code>measurability</code> (for sets) is implemented using <code>grind</code> (or maybe can be replaced by <code>grind</code> altogether).</li>\n</ul>\n<p>Does it make sense to just make <code>measurability</code> (for functions) call <code>fun_prop (disch := measurability)</code>? If you do that, are there any cases where <code>fun_prop</code> is weaker than the current <code>measurability</code>?</p>",
        "id": 547239790,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1761560819
    },
    {
        "content": "<p>I see now that you're already calling <code>fun_prop (disch := measurability)</code>.</p>",
        "id": 547240565,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1761561029
    },
    {
        "content": "<p>If I'm understanding correctly, the underlying of <code>measurability</code> for <code>MeasurableSet</code> is still <code>aesop</code> rules. Can we then adapt <code>fun_prop</code> to properties of sets (maybe it should be called <code>set_prop</code>)?</p>",
        "id": 563080077,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1765409850
    },
    {
        "content": "<p>I'm asking so because in model theory we have <code>Definable</code> on sets and (in future) <code>DefinableFun</code> on functions (see <a href=\"#narrow/channel/287929-mathlib4/topic/Model.20Theory.3A.60DefinableFun.60.20definition.20and.20preimage.20lemma.2E/with/562845215\">this</a> and <a href=\"#narrow/channel/287929-mathlib4/topic/.28ModelTheory.29Automation.20for.20proving.20first-order.20definability/with/560884741\">this</a>) and we want a tactic to automate these proofs. I hope a stronger <code>fun_prop</code> can unify measurability and definability together.</p>",
        "id": 563080112,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1765409872
    },
    {
        "content": "<p><code>measurability</code> is now just <code>fun_prop</code>, it no longer uses <code>aesop</code></p>",
        "id": 563291976,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1765491259
    },
    {
        "content": "<p>I think what you want is to design your own discharger for use with <code>fun_prop</code>.</p>",
        "id": 563292158,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1765491326
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2330511.20use.20fun_prop.20in.20measurability/near/563291976\">mondta</a>:</p>\n<blockquote>\n<p><code>measurability</code> is now just <code>fun_prop</code>, it no longer uses <code>aesop</code></p>\n</blockquote>\n<p>This is not true, <code>measurability</code> still uses <code>aesop</code> for everything that isn't a <code>fun_prop</code> goal.</p>",
        "id": 563293021,
        "sender_full_name": "Attila Gáspár",
        "timestamp": 1765491778
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"734814\">@Dexin Zhang</span> A similar approach with a combination of <code>aesop</code> and <code>fun_prop</code> would likely work for definability. I believe that the main source of slowness with  <code>aesop</code> was the lack of indexing for functions, which led to it trying most of the tagged <code>Measurable</code> theorems every time. But for goals that don't involve functions, it shouldn't cause issues. Also, a new <code>aesop</code>-based tactic can easily disable <code>simp</code>, eliminating another potential source of slowdowns.</p>\n<p>However, <code>fun_prop</code> may not work that well for definability, as it currently doesn't support foralls as functions. This is also an issue for measurability, for example, the current implementation can't prove <code>MeasurableSet {x | p x → q x}</code>. So the same approach would fail to prove something like <code>Definable {x | ∀ y, p x y}</code>. But this doesn't seem to be a fundamental limitation of <code>fun_prop</code>, so it's probably not that difficult to add support for foralls.</p>",
        "id": 563295837,
        "sender_full_name": "Attila Gáspár",
        "timestamp": 1765493264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"932362\">Attila Gáspár</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2330511.20use.20fun_prop.20in.20measurability/near/563295837\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> A similar approach with a combination of <code>aesop</code> and <code>fun_prop</code> would likely work for definability. I believe that the main source of slowness with  <code>aesop</code> was the lack of indexing for functions, which led to it trying most of the tagged <code>Measurable</code> theorems every time. But for goals that don't involve functions, it shouldn't cause issues. Also, a new <code>aesop</code>-based tactic can easily disable <code>simp</code>, eliminating another potential source of slowdowns.</p>\n<p>However, <code>fun_prop</code> may not work that well for definability, as it currently doesn't support foralls as functions. This is also an issue for measurability, for example, the current implementation can't prove <code>MeasurableSet {x | p x → q x}</code>. So the same approach would fail to prove something like <code>Definable {x | ∀ y, p x y}</code>. But this doesn't seem to be a fundamental limitation of <code>fun_prop</code>, so it's probably not that difficult to add support for foralls.</p>\n</blockquote>\n<p>That sounds like a problem of <code>fun_prop</code>! Since it can tag <code>∃</code> indeed.</p>",
        "id": 563544347,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1765566520
    },
    {
        "content": "<p>Another concern I have is that <code>fun_prop</code> must take <code>α → Prop</code> instead of <code>Set α</code>. For <code>MeasurableSet</code> there is <code>Measurable</code> on predicates, but it seems quite duplication if in model theory we define two <code>Definable</code> for sets and predicates.</p>",
        "id": 563544359,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1765566523
    }
]