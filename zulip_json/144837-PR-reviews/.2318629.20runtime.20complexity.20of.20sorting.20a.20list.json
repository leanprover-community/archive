[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"712641\">@Tom Kranz</span> has written <a href=\"https://github.com/leanprover-community/mathlib4/pull/18629\">#18629</a> which is an interesting PR in the sense that it is the first runtime formalisation (I am aware of) in Lean. As such, it should probably spark more debate than it has (the original PR was opened in August)</p>",
        "id": 483283528,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732028322
    },
    {
        "content": "<p>Nitpick: That's <span class=\"user-mention\" data-user-id=\"360938\">@Tomaz Gomes</span></p>",
        "id": 483283686,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1732028366
    },
    {
        "content": "<p>That's not me.</p>",
        "id": 483283721,
        "sender_full_name": "Tom Kranz",
        "timestamp": 1732028379
    },
    {
        "content": "<p>Wow wait, I was noticing this as well</p>",
        "id": 483283866,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732028412
    },
    {
        "content": "<p>But you also formalised some runtime complexity, right?</p>",
        "id": 483283922,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732028427
    },
    {
        "content": "<p>I think <a href=\"#narrow/channel/236449-Program-verification/topic/Sorting.20has.20.60.CE.98.28n.20log.20n.29.60.20query.20complexity/near/462854117\">the approach in this thread</a> might be a better one</p>",
        "id": 483283942,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732028434
    },
    {
        "content": "<p>Yes, that's what I wanted to get to, Eric</p>",
        "id": 483283987,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732028447
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/18629\">#18629</a>, the approach used is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The redesigned version of `orderedInsert`, which also returns the number of comparisons</span>\n<span class=\"sd\">performed. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">orderedInsert</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\">      </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">([</span><span class=\"n\">a</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≼</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">orderedInsert</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which is a little fishy because I could instead implement it as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The redesigned version of `orderedInsert`, which also returns the number of comparisons</span>\n<span class=\"sd\">performed. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">orderedInsert</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\">      </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">([</span><span class=\"n\">a</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≼</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">12</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">orderedInsert</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">12</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and a make a different claim about its complexity</p>",
        "id": 483284376,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732028536
    },
    {
        "content": "<p>The alternative approach makes it 100% impossible to cheat like that?</p>",
        "id": 483284961,
        "sender_full_name": "Tomaz Mascarenhas",
        "timestamp": 1732028689
    },
    {
        "content": "<p>I believe so, since it formalizes \"no algorithm can exist with better-than-<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Θ</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Θ(n \\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Θ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> query complexity\". In your version, you can't state that predicate, because obviously I can implement a function <code>List α → List α × ℕ</code> that returns a sorted list and any natural number it likes!</p>",
        "id": 483286197,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732028972
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"514145\">@Geoffrey Irving</span> can comment further.</p>",
        "id": 483286484,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732029038
    },
    {
        "content": "<p>I wonder whether anyone has studied a question \"this list of 10000000 ints cannot be sorted on an x86 processor in less than 1 microsecond\". That's the kind of runtime bound I actually want to have tools to prove</p>",
        "id": 483287533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732029301
    },
    {
        "content": "<p>That doesn't seem like a very interesting question, because my algorithm could be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">isMariosList</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">sortedMariosList</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">qsort</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">`</span>\n</code></pre></div>",
        "id": 483288726,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732029627
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2318629.20runtime.20complexity.20of.20sorting.20a.20list/near/483286197\">said</a>:</p>\n<blockquote>\n<p>I believe so, since it formalizes \"no algorithm can exist with better-than-<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Θ</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Θ(n \\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Θ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> query complexity\". In your version, you can't state that predicate, because obviously I can implement a function <code>List α → List α × ℕ</code> that returns a sorted list and any natural number it likes!</p>\n</blockquote>\n<p>But still, isn't it something like \"no algorithm <em>that lives inside the <code>SComp</code> monad</em> have that complexity\"? Is there a way to be 100% sure that the number inside <code>SComp</code> always represents the correct number of comparisons?</p>\n<p>But yes, either way I agree that this other approach is better</p>",
        "id": 483289318,
        "sender_full_name": "Tomaz Mascarenhas",
        "timestamp": 1732029789
    },
    {
        "content": "<p>Happy to comment further, but my impression is that people here already understand the Comp monad approach quite well. I don’t see how you do without it: somehow you need an object that is the computation without the oracle filled in, and once you have that proving things is straightforward. Nearly all the work on the lower bound was establishing the basic theory of the entropy of a probability distribution, after which the sort lower bound is a corollary of “you can only learn one bit about a random oracle per query”.</p>",
        "id": 483290907,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1732030218
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/144837-PR-reviews/topic/.2318629.20runtime.20complexity.20of.20sorting.20a.20list/near/483288726\">said</a>:</p>\n<blockquote>\n<p>That doesn't seem like a very interesting question, because my algorithm could be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">isMariosList</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">sortedMariosList</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">qsort</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">`</span>\n</code></pre></div>\n</blockquote>\n<p>Well there are two issues with that algorithm:</p>\n<ul>\n<li>It still has to test and return a sorted list (in fact it probably has to overwrite the original depending on how the problem is stated). This is linear time, but it can still be expensive. (As stated the problem already has a linear time solution, but the actual point of my question is about hard real time bounds on real systems, not asymptotics.)</li>\n<li>If the concern is that I specified a particular input, you can also have a version of that theorem that quantifies over all inputs of a given length</li>\n</ul>",
        "id": 483290919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732030221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360938\">Tomaz Gomes</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2318629.20runtime.20complexity.20of.20sorting.20a.20list/near/483289318\">said</a>:</p>\n<blockquote>\n<p>But still, isn't it something like \"no algorithm <em>that lives inside the <code>SComp</code> monad</em> have that complexity\"? Is there a way to be 100% sure that the number inside <code>SComp</code> always represents the correct number of comparisons?</p>\n</blockquote>\n<p>To trust that you have to check the definitions of <a href=\"https://github.com/girving/debate/blob/1e0362f4edb6719bdba6530fa99d34a506671ecb/Comp/Defs.lean#L56\">https://github.com/girving/debate/blob/1e0362f4edb6719bdba6530fa99d34a506671ecb/Comp/Defs.lean#L56</a> and similar, but those are just a couple dozen lines of simple code. I agree you have to have checked them carefully.</p>",
        "id": 483293119,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1732030800
    },
    {
        "content": "<p>But as with other Mathlib theories, the fact that you can prove true theorems with them also serves as evidence that the definitions are right. Here, we define Comp and then get both the correct upper and lower bounds for sort (via merge sort and information theory, respectively).</p>",
        "id": 483293562,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1732030916
    },
    {
        "content": "<p>I see. So, what should we do? Should I adapt my code to your approach or you plan to PR your results to mathlib?</p>",
        "id": 483297289,
        "sender_full_name": "Tomaz Mascarenhas",
        "timestamp": 1732031916
    },
    {
        "content": "<p>A technicality: current Comp lifts up one universe level, but this is not hard to remove: one just needs to inline the Prob monad into the Comp definition.</p>",
        "id": 483297325,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1732031928
    },
    {
        "content": "<p>I won’t have capacity to upstream it, but I’d be happy to advise if you or someone else wants to.</p>",
        "id": 483297413,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1732031960
    },
    {
        "content": "<p>One thing I am happy to do is refactor the current thick debate repo to be a thin debate repo on top of a complexity repo that just has the basic theories including Prob and Comp, but this would take me a week or two.</p>",
        "id": 483297646,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1732032014
    },
    {
        "content": "<p>Ah, also: I don’t know if you want the stochastic version or not. Comp is stochastic, because the original purpose is modeling stochastic ML algorithms. If you want a deterministic version it’d be simpler, though you still need some relationship to probability to do information theory.</p>",
        "id": 483297930,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1732032081
    },
    {
        "content": "<p>I think we could start simple and then upstream more gradually... is it okay if I take a closer look at your work later today and then we discuss? I would be happy to work upstreaming it to mathlib</p>",
        "id": 483298414,
        "sender_full_name": "Tomaz Mascarenhas",
        "timestamp": 1732032198
    },
    {
        "content": "<p>Sounds great!</p>",
        "id": 483298925,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1732032341
    },
    {
        "content": "<p>I was talking to Geoffrey, and I believe it would be easier to initially do a PR with a deterministic oracle, instead of the stochastic one in <code>debate</code>. With this we could prove the upper bound for the complexity of the algorithms but not for the lower bound, initially. The upside is that we could skip the code related to probability in Geoffrey's work and do a much simpler PR. Geoffrey added that his impression was that we probably will want both oracles in the future anyway. Do you think it is okay to do this simplification in the first PR?</p>\n<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span></p>",
        "id": 484167935,
        "sender_full_name": "Tomaz Mascarenhas",
        "timestamp": 1732470302
    },
    {
        "content": "<p>Yes, looks like a sensible plan for a first PR <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 484168250,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732470635
    },
    {
        "content": "<p>Hi, sorry for the delay, I opened two PRs, one with the infrastructure of oracle-based computation (<a href=\"https://github.com/leanprover-community/mathlib4/pull/20924\">https://github.com/leanprover-community/mathlib4/pull/20924</a>) and another one using it to formalize the upper bound on merge sort (<a href=\"https://github.com/leanprover-community/mathlib4/pull/20956\">https://github.com/leanprover-community/mathlib4/pull/20956</a>)</p>\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> I saw your recent comment on the old PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/18627\">#18627</a>). Does that also apply to this new version? Which also will involve in the future using information theory to formalize lower bounds on the complexity of algorithms</p>",
        "id": 495323006,
        "sender_full_name": "Tomaz Mascarenhas",
        "timestamp": 1737563143
    },
    {
        "content": "<p>I'm uncertain. I can see major design decision being worked out in review, which suggests to me this broad topic (complexity of algorithms, whether via oracles or otherwise) is not yet ready for Mathlib. But ... the general approach looks good, and I don't want to discourage this work from happening at all.</p>",
        "id": 496243206,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738028999
    },
    {
        "content": "<p>The alternative to getting stuff into Mathlib is leaving it where it is and continuing to build on it. I’ll be proving more AI safety theory stuff soon, and I’m also going to do the black box complexity of discrete logarithm to try out flexible oracle outputs.</p>",
        "id": 496285449,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1738054706
    },
    {
        "content": "<p>My general plan is (time permitting), do a mix of</p>\n<ol>\n<li>Safety theory</li>\n<li>Complexity upper + lower bounds that use different machinery. E.g., sorting required entropy, discrete log needs different outputs and the compression lemma, etc.</li>\n</ol>\n<p>But (1) is 80% hobby and (2) is 95% hobby, so I won’t do it very fast.</p>",
        "id": 496287647,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1738055377
    },
    {
        "content": "<p>My take is that probably the foundations here do belong in mathlib, as hopefully their centralized presence should encourage those interested to work out issues in one common design rather than each building their own copy</p>",
        "id": 496303520,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738060509
    },
    {
        "content": "<p>A lot of the interesting results are probabilistic, BTW, so we’d also need to figure out what to do with my <code>Prob</code> machinery (finitely supported probability distributions). I do think it’s a lot more ergonomic than PMF would be.</p>",
        "id": 496318200,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1738065592
    }
]