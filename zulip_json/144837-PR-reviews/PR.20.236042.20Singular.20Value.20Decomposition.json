[
    {
        "content": "<p>PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/6042\">#6042</a> contains definitions and proofs for Singular Value Decompositon. <a href=\"https://github.com/leanprover-community/mathlib4/pull/6042\">PR #6042</a></p>",
        "id": 377430276,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1689974375
    },
    {
        "content": "<p>Hello Mathlib Reviewer Team,</p>\n<p>I received this <a href=\"https://github.com/leanprover-community/mathlib4/pull/6042#issuecomment-1735519864\">comment</a></p>\n<blockquote>\n<p>We've been discussing this PR with the mathlib reviewer team, and I'm afraid that we concluded that this result still needs quite some work. Namely, we find it important to get the decomposition also for homomorphisms (specifically, elements of <code>Module.End</code>), and it seems better to first prove SVD for homomorphisms, and then derive the matrix result from that. Basically, the same approach as we already have for eigenvalues in mathlib.</p>\n</blockquote>\n<p>I do not understand what is required?  Or whether this is a rejection of the PR ? Any thoughts are welcome</p>",
        "id": 393701576,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1695903557
    },
    {
        "content": "<p>It is saying that the PR is not being accepted as is. This is not because it is poorly written or anything of that nature, but rather that we feel it doesn't match the design choices of mathlib. In this case, that means the result should first be proven in the basis-free setting of linear maps (note: Anne was slightly incorrect here, it's not specialized to <code>Module.End</code>), and then specialize to matrices. The same approach is taken for eigenvalues (where it really is <code>Module.End</code>).</p>\n<p>So, what is required, as a first step, is that you prove SVD for linear maps (not using the matrix version you've already established). One statement of this would be: Given a <code>T : V →ₗ[𝕜] W</code> linear map between finite dimensional <code>IsRorC 𝕜</code>-inner product spaces, there exists an antitone map <code>σ : Fin (rank T) → ℝ≥0</code> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Orthonormal#doc\">docs#Orthonormal</a> collections <code>v : Fin (rank T) → V</code>, <code>w : Fin (rank T) → W</code> such that for all <code>i : Fin (rank T)</code>, <code>T (v i) = (σ i : 𝕜) • (w i)</code>, and for any <code>v' : V</code>, if for all <code>i : FIn (rank T)</code>, <code>⟪v i, v'⟫ = 0</code>, then <code>T v' = 0</code>. Alternatively, this second condition could be phrased in a slightly different but provably equivalent way, like: <code>(Submodule.span 𝕜 (Set.range v)).orthogonal ≤ T.ker</code></p>",
        "id": 393745312,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695913528
    },
    {
        "content": "<p>I don't claim that the suggested version above is necessarily the <em>best</em> basis-free version, but its the kind of thing we're looking for.</p>",
        "id": 393745539,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695913588
    },
    {
        "content": "<p>Here is a formalized statement (again, not necessarily the best; probably there should be discussion in this thread about what exactly is the best statement to formalize):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Matrix.PosDef</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">IsROrC</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"bp\">𝕜</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"bp\">𝕜</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">LinearMap</span> <span class=\"n\">Submodule</span> <span class=\"n\">NNReal</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">LinearMap.singular_value_decomposition</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">T.rank</span> <span class=\"bp\">∧</span> <span class=\"bp\">∃</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">r</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Antitone</span> <span class=\"n\">σ</span> <span class=\"bp\">∧</span> <span class=\"bp\">∃</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">r</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">r</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">,</span>\n      <span class=\"n\">Orthonormal</span> <span class=\"bp\">𝕜</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">Orthonormal</span> <span class=\"bp\">𝕜</span> <span class=\"n\">w</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">𝕜</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">∧</span>\n      <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">Set.range</span> <span class=\"n\">v</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">orthogonal</span> <span class=\"bp\">≤</span> <span class=\"n\">ker</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 393748931,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695914529
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> , <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> What do you think is the correct version of SVD to state for linear maps? I took a stab at it above, but we should probably come up with the precise version of what we want for Monahad.</p>",
        "id": 393749822,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695914675
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/PR.20.236042.20Singular.20Value.20Decomposition/near/393745312\">said</a>:</p>\n<blockquote>\n<p>So, what is required, as a first step, is that you prove SVD for linear maps (not using the matrix version you've already established).</p>\n</blockquote>\n<p>what's wrong with using the matrix version to prove the <del>basis-free</del> linear map one? Are there particular intermediate results you think are also useful in a basis free setting?</p>",
        "id": 393760367,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1695917671
    },
    {
        "content": "<p>My reading of <span class=\"user-mention silent\" data-user-id=\"497480\">MohanadAhmed</span>'s matrix version is that they would prefer there to be a structural distinction between the zero and non-zero entries of <code>σ</code>, and the corresponding entries of your <code>v</code>/ <code>w</code> (which I think would be less confusing as <code>u</code>/<code>v</code>)</p>",
        "id": 393761790,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695918190
    },
    {
        "content": "<p>Ah, looking again; it's not that your version doesn't make this distinction, it's that it doesn't extend the orthonormal basis to the whole space</p>",
        "id": 393762033,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695918273
    },
    {
        "content": "<p>Right, you can always extend, but this also gives you the reduced SVD for free (I can't remember what that's called off the top of my head).</p>",
        "id": 393762389,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695918375
    },
    {
        "content": "<p>Wikipedia suggests \"compact SVD\"</p>",
        "id": 393763735,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695918817
    },
    {
        "content": "<p>Certainly deciding between the compact or \"full\" SVD is an important decision in either the matrix or linear map case, and I'm not sure there was any discussion about it.</p>",
        "id": 393764457,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695919026
    },
    {
        "content": "<p>How about: a linear map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>→</mo><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">V\\to W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> can be composed as an isometry <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>ι</mi></msup><mo>→</mo><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^\\iota\\to W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">ι</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span>, the adjoint of an isometry <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>ι</mi></msup><mo>→</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^\\iota\\to V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">ι</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>, and a strictly positive diagonal map on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>ι</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^\\iota</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">ι</span></span></span></span></span></span></span></span></span></span></span>.</p>\n<p>Note: like Jireh I stated it for <code>IsROrC 𝕜</code>, but I don't know whether it's true for <code>ℂ</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.InnerProductSpace.Spectrum</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">IsROrC</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"bp\">𝕜</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"bp\">𝕜</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">LinearMap</span> <span class=\"n\">Matrix</span> <span class=\"n\">NNReal</span>\n\n<span class=\"c1\">-- once this exists, some of `OrthonormalBasis` should be re-routed through it</span>\n<span class=\"kd\">def</span> <span class=\"n\">Orthonormal.toIsometry</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">Orthonormal</span> <span class=\"bp\">𝕜</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">EuclideanSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">ι</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">LinearMap.singular_value_decomposition</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hσ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">Orthonormal</span> <span class=\"bp\">𝕜</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hw</span> <span class=\"o\">:</span> <span class=\"n\">Orthonormal</span> <span class=\"bp\">𝕜</span> <span class=\"n\">w</span><span class=\"o\">),</span>\n    <span class=\"n\">T</span> <span class=\"bp\">=</span> <span class=\"n\">hw.toIsometry</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">toLin'</span> <span class=\"o\">(</span><span class=\"n\">diagonal</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span><span class=\"o\">))</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">adjoint</span> <span class=\"n\">hv.toIsometry</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 393785251,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1695926539
    },
    {
        "content": "<p>Singular values should definitely be ordered from the largest one to the smallest one.</p>",
        "id": 393785817,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1695926729
    },
    {
        "content": "<p>Indeed, in <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span>'s version there also appears the fact that <code>ι</code> can be taken to be <code>Fin k</code> and <code>σ</code> then to be antitone, but this is secondary, in my opinion, and could appear as a separate lemma proved by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Tuple.sort#doc\">docs#Tuple.sort</a>.</p>",
        "id": 393785907,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1695926758
    },
    {
        "content": "<p>So that version would look like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">LinearMap.singular_value_decomposition</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">r</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hσ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">σ</span> <span class=\"n\">i</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">r</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">r</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">Orthonormal</span> <span class=\"bp\">𝕜</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hw</span> <span class=\"o\">:</span> <span class=\"n\">Orthonormal</span> <span class=\"bp\">𝕜</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">Antitone</span> <span class=\"n\">σ</span> <span class=\"bp\">∧</span>\n    <span class=\"n\">T</span> <span class=\"bp\">=</span> <span class=\"n\">hw.toIsometry</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">toLin'</span> <span class=\"o\">(</span><span class=\"n\">diagonal</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span><span class=\"o\">))</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">adjoint</span> <span class=\"n\">hv.toIsometry</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 393786263,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1695926888
    },
    {
        "content": "<p>To be honest, in my version there is something that annoys me: we should be saying exactly what <code>σ</code> is (i.e., square roots of eigenvalues of <code>T.adjoint * T</code> listed in nonincreasing order), but I don't think we can do this yet because we don't have enough material about positive operators (my fault!).</p>",
        "id": 393786490,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695926994
    },
    {
        "content": "<p>\"can't\" is maybe too strong a word, I just mean, \"probably not in a nice way\"</p>",
        "id": 393786622,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695927039
    },
    {
        "content": "<p>Hmm -- don't you think this would follow from the spectral theorem we have in mathlib?</p>",
        "id": 393786707,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1695927075
    },
    {
        "content": "<p>which one?</p>",
        "id": 393786898,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695927140
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.IsSymmetric.hasEigenvector_eigenvectorBasis#doc\">docs#LinearMap.IsSymmetric.hasEigenvector_eigenvectorBasis</a> or one of the other ones in that file?</p>",
        "id": 393787255,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1695927225
    },
    {
        "content": "<p>Aha, that probably wouldn't be too bad. I guess I want a constructor which takes a positive operator and lists the eigenvalues as terms of <code>ℝ≥0</code> in decreasing order. Then we would just use that in the above.</p>",
        "id": 393787595,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695927372
    },
    {
        "content": "<p>I wrote (or rather, got Kyle to write) <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Tuple.sort#doc\">docs#Tuple.sort</a> precisely for that last part (the ordering), but never glued it into the spectral theorem.</p>",
        "id": 393787691,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1695927413
    },
    {
        "content": "<p>By the way, I think we probably want <em>decreasing</em> order, instead of increasing order as suggested by the docstring.</p>",
        "id": 393787961,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695927515
    },
    {
        "content": "<p>I have to go teach now.</p>",
        "id": 393787975,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695927519
    },
    {
        "content": "<p>Oh but before I forget: yes, I prefer your <code>Orthonormal.toIsometry</code> version.</p>",
        "id": 393788180,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695927613
    },
    {
        "content": "<p>Also: there is a SVD theorem for linear maps between two distinct vector spaces.</p>",
        "id": 393890108,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1695978084
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span>, I'm confused by that comment, as both <span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> and <span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span>'s versions above use <code>T : V →ₗ[𝕜] W</code> already.</p>",
        "id": 393891742,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695978723
    },
    {
        "content": "<p>Perhaps this is just in response to the incorrect <code>Module.End</code> claim made in the top post</p>",
        "id": 393891859,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695978752
    },
    {
        "content": "<p>Yes, and I misunderstood another explicit statement. So it's my confusion, sorry…</p>",
        "id": 393912011,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1695986607
    },
    {
        "content": "<p>Hello everyone,<br>\nThanks a lot for the lively discussion.</p>",
        "id": 394086622,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1696081413
    },
    {
        "content": "<h2>Sorting of Eigenvalues</h2>\n<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/PR.20.236042.20Singular.20Value.20Decomposition/near/393787691\">said</a>:</p>\n<blockquote>\n<p>I wrote (or rather, got Kyle to write) <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Tuple.sort#doc\">docs#Tuple.sort</a> precisely for that last part (the ordering), but never glued it into the spectral theorem.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> <br>\nI started on the sorting of eigenvalues in PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/7427\">#7427</a>. You will find I have added next to every lemma a lemma starting with the letter x that uses the ordered eigenvalues. The PR now builds (minus the linter asking for a docstring), but I think there is a question here that needs to be answered:</p>\n<p>Sorting requires a LinearOrder on the domain. Some of the linear map lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PiLp.basis_toMatrix_basisFun_mul#doc\">docs#PiLp.basis_toMatrix_basisFun_mul</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Basis.basis_toMatrix_basisFun_mul#doc\">docs#Basis.basis_toMatrix_basisFun_mul</a> are written with arbitrary unordered finite types. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">nonrec</span> <span class=\"kd\">theorem</span> <span class=\"n\">basis_toMatrix_basisFun_mul</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"n\">ι</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">PiLp</span> <span class=\"n\">p</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">𝕜</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">ι</span> <span class=\"n\">ι</span> <span class=\"bp\">𝕜</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">b.toMatrix</span> <span class=\"o\">(</span><span class=\"n\">PiLp.basisFun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">A</span> <span class=\"bp\">=</span>\n      <span class=\"n\">Matrix.of</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b.repr</span> <span class=\"o\">((</span><span class=\"n\">WithLp.equiv</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">ᵀ</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>\n<p>which I modified to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">nonrec</span> <span class=\"kd\">theorem</span> <span class=\"n\">xbasis_toMatrix_basisFun_mul</span>\n    <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">ι</span><span class=\"o\">))</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">PiLp</span> <span class=\"n\">p</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">𝕜</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">ι</span> <span class=\"n\">ι</span> <span class=\"bp\">𝕜</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">b.toMatrix</span> <span class=\"o\">(</span><span class=\"n\">PiLp.basisFun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">A</span> <span class=\"bp\">=</span>\n      <span class=\"n\">Matrix.of</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b.repr</span> <span class=\"o\">((</span><span class=\"n\">WithLp.equiv</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">ᵀ</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>\n<p>What is the desired solution?</p>",
        "id": 394087290,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1696082050
    },
    {
        "content": "<h2>Order of Singular Values and Eigenvalues (Antitone vs. Monotone)</h2>\n<p>I prefer the order to be decreasing. I implemented the note as is i.e. increasing order. My preference is purely because that is how I learned them. </p>\n<p>(And slightly because it makes it easier to define a function from Fin R to \\Reals for non-zero singular values). </p>\n<p>Are there other reasons for the decreasing order: <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> , <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span></p>",
        "id": 394087453,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1696082235
    },
    {
        "content": "<h2>Compact vs Full SVD</h2>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/PR.20.236042.20Singular.20Value.20Decomposition/near/393763735\">said</a>:</p>\n<blockquote>\n<p>Wikipedia suggests \"compact SVD\"</p>\n</blockquote>\n<p>The partitioning between zero and nonzero eigenvalues and corresponding partition in the left/right singular vector matrices. Makes this distinction a minor issue. The compact version is easily derivable from the full version as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">full_svd_theroem</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"bp\">𝕂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">A.svdU</span> <span class=\"bp\">*</span> <span class=\"n\">A.svdξ</span> <span class=\"bp\">*</span> <span class=\"n\">A.svdV</span><span class=\"bp\">ᴴ</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- about 5 lines here</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">svd_compact</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"bp\">𝕂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">A.svdU₁</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">A.svdσ</span> <span class=\"o\">(</span><span class=\"n\">algebraMap</span> <span class=\"n\">ℝ</span> <span class=\"bp\">𝕂</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"n\">A.svdV₁</span><span class=\"bp\">ᴴ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">nth_rw</span> <span class=\"mi\">1</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">full_svd_theroem</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span> <span class=\"n\">svdU</span><span class=\"o\">,</span> <span class=\"n\">svdξ</span><span class=\"o\">,</span> <span class=\"n\">svdV</span><span class=\"o\">,</span> <span class=\"n\">fromColumns_mul_fromBlocks</span><span class=\"o\">,</span>\n    <span class=\"n\">conjTranspose_fromColumns_eq_fromRows_conjTranspose</span><span class=\"o\">,</span> <span class=\"n\">fromColumns_mul_fromRows</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 394089137,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1696083356
    },
    {
        "content": "<p>I agree that the order should be decreasing, because the most interesting singular value is the largest one.</p>",
        "id": 394089466,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1696083637
    },
    {
        "content": "<p>One can argue the largest singular value will still be most interesting, even in the last position i.e. at (n-1) position instead of 0 -position <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>\n<p>By the way I recall the names <code>svdU, svdU₁, svdσ, svdV, ... etc</code> were not descriptive enough. Any particular suggestion on what names to use?</p>",
        "id": 394089945,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1696084092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/PR.20.236042.20Singular.20Value.20Decomposition/near/393760367\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/PR.20.236042.20Singular.20Value.20Decomposition/near/393745312\">said</a>:</p>\n<blockquote>\n<p>So, what is required, as a first step, is that you prove SVD for linear maps (not using the matrix version you've already established).</p>\n</blockquote>\n<p>what's wrong with using the matrix version to prove the <del>basis-free</del> linear map one? Are there particular intermediate results you think are also useful in a basis free setting?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> <br>\nI also have the same question as Alex here.</p>",
        "id": 394090105,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1696084242
    },
    {
        "content": "<p>The other reason to prefer decreasing: in the infinite dimensional setting, for compact operators, it is the <em>only</em> available ordering (at least if the index set is <code>\\N</code>). This is my primary motivation to prefer decreasing, but Sebastien's is also sensible.</p>",
        "id": 394265028,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1696195614
    },
    {
        "content": "<p>It's nearly always preferable to go from the general theory of linear maps and then coordinatize only when necessary. The matrix results should fall out almost for free after the general version, but I expect the other direction isn't quite as easy. And note that we definitely want the linear map version.</p>\n<p>I expect the linear map version to be easier to prove and shorter (no guarantees of course, and if I'm wrong then this would be an argument against this suggestion). Finally, it simply fits the design of the library; we prove things first for general linear maps, then specialize to matrices.</p>\n<p>As for intermediate results, I'm not sure I have any off the top of my head, but I might be able to think of some.</p>",
        "id": 394266208,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1696196595
    },
    {
        "content": "<p>Can I ask (cc <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>) what the status is of this PR now? Should I mark it as work in progress, to be replaced with the linear map based SVD?</p>",
        "id": 407430848,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1702372946
    }
]