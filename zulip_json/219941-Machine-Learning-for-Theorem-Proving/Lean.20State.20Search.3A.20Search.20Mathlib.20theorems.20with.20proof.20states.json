[
    {
        "content": "<p><strong>Announcing <a href=\"https://premise-search.com/\">Lean State Search</a>: A Proof State based Search Engine for Mathlib Theorems</strong></p>\n<p>We are thrilled to introduce <strong><a href=\"https://premise-search.com/\">Lean State Search</a></strong>, a semantic search engine powered by a pretrained model specifically designed for retrieving Mathlib theorems using formal proof states as queries. Developed by the AI4Math team at Renmin University of China, this tool aims to streamline formalization in Lean.</p>\n<p><strong>Resources</strong></p>\n<ul>\n<li>\n<p><strong><a href=\"https://arxiv.org/abs/2501.13959\">arXiv Paper</a></strong>: Technical details and methodology.</p>\n</li>\n<li>\n<p><strong><a href=\"https://github.com/ruc-ai4math/Premise-Retrieval\">GitHub Repository</a></strong>: Open-source code for training and inference.</p>\n</li>\n<li>\n<p><strong><a href=\"https://huggingface.co/ruc-ai4math/Lean_State_Search_Random\">Hugging Face Model</a></strong>: Pretrained model for direct integration.</p>\n</li>\n</ul>\n<p><strong>Clarification</strong><br>\nUnlike existing tools like <a href=\"https://leansearch.net/\">LeanSearch.net</a> and <a href=\"https://moogle.ai/\">Moogle.ai</a>, Lean State Search focuses exclusively on formal proof states as input—mirroring the premise retrieval functionality of LeanDojo. </p>\n<p><strong>Open-Source Commitment</strong><br>\nWe have open-sourced our model and training/inference code. Self-hosting support will be released shortly. The lightweight BERT-based architecture ensures seamless deployment even on CPU-only laptops, lowering barriers to adoption.<br>\n<strong>Community-Driven Improvement</strong><br>\nUser feedback is vital to refining our model. All anonymized interaction data will be publicly shared and periodically updated to foster transparency and collaborative progress.</p>\n<p>We welcome your engagement and look forward to supporting the formalization community with this tool.</p>",
        "id": 503449750,
        "sender_full_name": "Yicheng Tao",
        "timestamp": 1741163193
    },
    {
        "content": "<p>This seems nice. </p>\n<p>I did a single test with it, using a small lemma proven in the Carleson project:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">MeasureTheory</span><span class=\"bp\">.</span><span class=\"n\">Integral</span><span class=\"bp\">.</span><span class=\"n\">Average</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">laverage_mono_ae</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀ᵐ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">⨍⁻</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">⨍⁻</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This is proven in the Carleson project using the term-mode proof </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">lintegral_mono_ae</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">filter_mono</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">ae_mono'</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">smul_absolutelyContinuous</span>\n</code></pre></div>\n<p>(implicitly unfolding the average)</p>\n<p>The first proof state is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀ᵐ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"bp\">⨍⁻</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">⨍⁻</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∂</span><span class=\"n\">μ</span>\n</code></pre></div>\n<p>This gives as second suggestion a useful lemma here: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.setLaverage_eq#doc\">docs#MeasureTheory.setLaverage_eq</a></p>\n<p>After <code>simp_rw [MeasureTheory.laverage_eq]</code> we get the proof state</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀ᵐ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∫⁻</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∫⁻</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span>\n</code></pre></div>\n<p>here the tool has more trouble, the lemma I want is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENNReal.div_le_div_right#doc\">docs#ENNReal.div_le_div_right</a>, which is the 30th result. Many other lemmas look similar to the goal, but don't apply.</p>\n<p>After <code>apply ENNReal.div_le_div_right</code> (or <code>gcongr ?_ / _</code>) the remaining goal is </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀ᵐ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"bp\">∫⁻</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">∫⁻</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∂</span><span class=\"n\">μ</span>\n</code></pre></div>\n<p>and the model finds <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.lintegral_mono_ae#doc\">docs#MeasureTheory.lintegral_mono_ae</a> as its first hit.</p>",
        "id": 503619025,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1741204211
    },
    {
        "content": "<p>I think this is a useful tool to find related lemmas, especially when you are not experienced with the library yourself. You still have to heavily judge yourself which lemmas are useful, and which tactic to use to apply the lemmas.</p>\n<p>The interface is very clean, and I am excited about the fact that the model already supports two versions of Lean. I hope that means that it will stay updated with a pretty recent (&lt;= 1 month old) version of Mathlib for a while.</p>",
        "id": 503619141,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1741204258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20State.20Search.3A.20Search.20Mathlib.20theorems.20with.20proof.20states/near/503619141\">said</a>:</p>\n<blockquote>\n<p>I think this is a useful tool to find related lemmas, especially when you are not experienced with the library yourself. You still have to heavily judge yourself which lemmas are useful, and which tactic to use to apply the lemmas.</p>\n<p>The interface is very clean, and I am excited about the fact that the model already supports two versions of Lean. I hope that means that it will stay updated with a pretty recent (&lt;= 1 month old) version of Mathlib for a while.</p>\n</blockquote>\n<p>Thanks for the comment! We have expected that this tool could be more helpful for those who are new to Lean and Mathlib to find useful theorems or just relevant modules.  Rather than directly find the exact theorem in your mind, it more likely to provide a bunch of premises that might be useful or instructive, serving as supplementary information.</p>\n<p>Our paper introduces a re-ranking procedure to improve the accuracy of the model. But for the concern of computation cost, we didn't adopt re-ranking in this application. So the best-match may not be presented as first few results.</p>",
        "id": 503673561,
        "sender_full_name": "Yicheng Tao",
        "timestamp": 1741225387
    },
    {
        "content": "<p>We plan to keep our database up-to-date with Mathlib. But our model may not be updated frequently. We may retrain our model every half a year. For now, it was trained on data extracted from v4.10.0 of Mathlib. As to the next update, we can use the newest version along with user feedbacks collected from this website.</p>",
        "id": 503673828,
        "sender_full_name": "Yicheng Tao",
        "timestamp": 1741225555
    },
    {
        "content": "<p>Can we make it callable directly from VSCode, like the <code>#leansearch</code> command? PRs to the <a href=\"https://github.com/leanprover-community/LeanSearchClient\">https://github.com/leanprover-community/LeanSearchClient</a> repository very welcome!</p>",
        "id": 503700343,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1741239216
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20State.20Search.3A.20Search.20Mathlib.20theorems.20with.20proof.20states/near/503700343\">said</a>:</p>\n<blockquote>\n<p>Can we make it callable directly from VSCode, like the <code>#leansearch</code> command? PRs to the <a href=\"https://github.com/leanprover-community/LeanSearchClient\">https://github.com/leanprover-community/LeanSearchClient</a> repository very welcome!</p>\n</blockquote>\n<p>We are now serving on a AWS EC2 server with 8 vcpus and 16G memory, which has low load-bearing capacity. So for now we haven't exposed our API. But we can have a try until any issue happens.</p>",
        "id": 503703100,
        "sender_full_name": "Yicheng Tao",
        "timestamp": 1741240256
    },
    {
        "content": "<p>I have made a PR to LeanSearchClient <a href=\"https://github.com/leanprover-community/LeanSearchClient/pull/13\">https://github.com/leanprover-community/LeanSearchClient/pull/13</a>. cc <span class=\"user-mention\" data-user-id=\"266304\">@Siddhartha Gadgil</span></p>",
        "id": 503759052,
        "sender_full_name": "Yicheng Tao",
        "timestamp": 1741257769
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"646276\">@Yicheng Tao</span> <br>\nSome suggestions:</p>\n<ul>\n<li>Can you add a brief decription to the PR?</li>\n<li>Please move the examples to the <code>LeanSearchClientTest</code> directory like <a href=\"https://github.com/leanprover-community/LeanSearchClient/blob/main/LeanSearchClientTest/MoogleExamples.lean\">https://github.com/leanprover-community/LeanSearchClient/blob/main/LeanSearchClientTest/MoogleExamples.lean</a></li>\n<li>For configuration, I feel it is more idiomatic in Lean to use <code>set_option</code> and that is what is done for the other searches. Please add <code>register_option</code> commands to <a href=\"https://github.com/leanprover-community/LeanSearchClient/blob/main/LeanSearchClient/Basic.lean\">https://github.com/leanprover-community/LeanSearchClient/blob/main/LeanSearchClient/Basic.lean</a> for the Lean version and number of responses like the ones there and use these. It is fine to also override with syntax (though as the Lean version is per project <code>set_option</code> does feel more natural).</li>\n</ul>",
        "id": 503772714,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1741261825
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266304\">Siddhartha Gadgil</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20State.20Search.3A.20Search.20Mathlib.20theorems.20with.20proof.20states/near/503772714\">said</a>:</p>\n<blockquote>\n<p>Thanks <span class=\"user-mention silent\" data-user-id=\"646276\">Yicheng Tao</span> <br>\nSome suggestions:</p>\n<ul>\n<li>Can you add a brief decription to the PR?</li>\n<li>Please move the examples to the <code>LeanSearchClientTest</code> directory like <a href=\"https://github.com/leanprover-community/LeanSearchClient/blob/main/LeanSearchClientTest/MoogleExamples.lean\">https://github.com/leanprover-community/LeanSearchClient/blob/main/LeanSearchClientTest/MoogleExamples.lean</a></li>\n<li>For configuration, I feel it is more idiomatic in Lean to use <code>set_option</code> and that is what is done for the other searches. Please add <code>register_option</code> commands to <a href=\"https://github.com/leanprover-community/LeanSearchClient/blob/main/LeanSearchClient/Basic.lean\">https://github.com/leanprover-community/LeanSearchClient/blob/main/LeanSearchClient/Basic.lean</a> for the Lean version and number of responses like the ones there and use these. It is fine to also override with syntax (though as the Lean version is per project <code>set_option</code> does feel more natural).</li>\n</ul>\n</blockquote>\n<p>Thanks for the suggestions. I have committed my changes.</p>",
        "id": 503783037,
        "sender_full_name": "Yicheng Tao",
        "timestamp": 1741264949
    },
    {
        "content": "<p>BTW, the tactic I implement sends the current main goal to the search engine. The user can not manually modify the query. I did this because I think it would be inconvenient for people to enter the proof state by hand. But it will cost flexibility. If the proof state is some kind of \"dirty\", the search results will be less satisfying. Any suggestions? Or what do you prefer?</p>",
        "id": 503785057,
        "sender_full_name": "Yicheng Tao",
        "timestamp": 1741265508
    },
    {
        "content": "<p>I think the current proof state is usually the best thing</p>",
        "id": 503785745,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1741265684
    },
    {
        "content": "<p>It looks fine to me now. If <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> and <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> think it is ready, one of us can merge.</p>",
        "id": 504078138,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1741349007
    },
    {
        "content": "<p>Are there any plans to integrate this into the premise selection API (<a href=\"https://github.com/leanprover/lean4/pull/7061\">https://github.com/leanprover/lean4/pull/7061</a>)?</p>",
        "id": 504387772,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1741522377
    },
    {
        "content": "<p>My personal view is that if and when someone hosts a premise selection server, we can add support.</p>",
        "id": 504390895,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1741524905
    },
    {
        "content": "<p>Personally, I would be very happy using such a server.</p>",
        "id": 504390932,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1741524934
    },
    {
        "content": "<p>For that API, I think the service provider should be an option decided by the user. Relying on any public server may be not a wise choice.</p>",
        "id": 504528790,
        "sender_full_name": "Yicheng Tao",
        "timestamp": 1741601308
    }
]