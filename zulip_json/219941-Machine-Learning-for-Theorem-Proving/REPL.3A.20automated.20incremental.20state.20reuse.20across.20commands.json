[
    {
        "content": "<p>Hello everyone! I have been working on an experimental feature for the Lean REPL that adds automatic incremental state reuse across commands to improve performance.</p>\n<h2>How it works</h2>\n<p>The idea, originally from <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> in the <code>repl++</code> branch, is to automatically reuse incremental states from previous commands and files submitted to the REPL. If you are familiar with the VSCode Lean extension, this works similarly to the orange progress bar that shows incremental elaboration only restarts from where changes occur.</p>\n<p>The key difference in the current <a href=\"https://github.com/leanprover-community/repl/pull/110\">PR</a> is that incremental state reuse happens across <strong>all</strong> previously submitted commands and files, not just the latest version of a single file.</p>\n<h2>Example</h2>\n<p>A concrete example is always better than a long explanation:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Files</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p><strong>File1.lean:</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"mi\">35</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p><strong>File2.lean:</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mathd_numbertheory_188</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">gcd</span><span class=\"w\"> </span><span class=\"mi\">180</span><span class=\"w\"> </span><span class=\"mi\">168</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">12</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n</code></pre></div>\n<p><strong>File3.lean:</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"mi\">35</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n</div></div>\n<p>Executing <code>{\"path\": \"File1.lean\"}</code>, <code>{\"path\": \"File2.lean\"}</code>, and <code>{\"path\": \"File3.lean\"}</code> in order produces the following results:</p>\n<ul>\n<li><code>File1.lean</code>: elaborated from scratch (~8s on my laptop)</li>\n<li><code>File2.lean</code>: reuses the <code>import Mathlib</code> from <code>File1.lean</code> (~0.02s)</li>\n<li><code>File3.lean</code>: reuses everything from <code>File1.lean</code> up to the <code>foo</code> theorem (~0.01s)</li>\n</ul>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Output after running the 3 commands above</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"p\">{</span><span class=\"nt\">\"messages\"</span><span class=\"p\">:</span>\n<span class=\"w\"> </span><span class=\"p\">[{</span><span class=\"nt\">\"severity\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"info\"</span><span class=\"p\">,</span>\n<span class=\"w\">   </span><span class=\"nt\">\"pos\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"nt\">\"line\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nt\">\"column\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">},</span>\n<span class=\"w\">   </span><span class=\"nt\">\"endPos\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"nt\">\"line\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nt\">\"column\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">},</span>\n<span class=\"w\">   </span><span class=\"nt\">\"data\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"9227465\"</span><span class=\"p\">}],</span>\n<span class=\"w\"> </span><span class=\"nt\">\"env\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">}</span>\n\n<span class=\"p\">{</span><span class=\"nt\">\"env\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">}</span>\n\n<span class=\"p\">{</span><span class=\"nt\">\"messages\"</span><span class=\"p\">:</span>\n<span class=\"w\"> </span><span class=\"p\">[{</span><span class=\"nt\">\"severity\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"info\"</span><span class=\"p\">,</span>\n<span class=\"w\">   </span><span class=\"nt\">\"pos\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"nt\">\"line\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nt\">\"column\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">},</span>\n<span class=\"w\">   </span><span class=\"nt\">\"endPos\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"nt\">\"line\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nt\">\"column\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">},</span>\n<span class=\"w\">   </span><span class=\"nt\">\"data\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"9227465\"</span><span class=\"p\">}],</span>\n<span class=\"w\"> </span><span class=\"nt\">\"env\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">}</span>\n</code></pre></div>\n</div></div>\n<h2>Use cases</h2>\n<ul>\n<li>Instead of manually decomposing Lean content into several commands individually sent to the REPL to reuse states later, you can now just submit whole files or commands, and the REPL will automatically determine the best incremental state to reuse.</li>\n<li>In the LLM era where test-time scaling is important, thousands of sampled file edits can be checked efficiently using this feature.</li>\n</ul>\n<h2>Try it yourself</h2>\n<p>I would be happy to get your opinion and feedback on this feature, as it's still in development. This feature is backported and available for all Lean versions between <strong>v4.8.0-rc1</strong> and <strong>v4.21.0</strong>, so choose the one you prefer ;)</p>\n<p>You can try it with <a href=\"https://github.com/augustepoiroux/LeanInteract\">LeanInteract</a>:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>LeanInteract example</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<h3>Setup:</h3>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>lean-interact<span class=\"o\">==</span><span class=\"m\">0</span>.6.2\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">lean_interact</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">AutoLeanServer</span><span class=\"p\">,</span> <span class=\"n\">Command</span><span class=\"p\">,</span> <span class=\"n\">LeanREPLConfig</span><span class=\"p\">,</span> <span class=\"n\">TempRequireProject</span><span class=\"p\">,</span> <span class=\"n\">LocalProject</span>\n\n<span class=\"c1\"># Running this will take a few minutes the first time, as it will set up a project depending on mathlib</span>\n<span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">LeanREPLConfig</span><span class=\"p\">(</span>\n    <span class=\"n\">lean_version</span><span class=\"o\">=</span><span class=\"s2\">\"v4.21.0\"</span><span class=\"p\">,</span>  <span class=\"c1\"># or any other version you want to test</span>\n    <span class=\"n\">project</span><span class=\"o\">=</span><span class=\"n\">TempRequireProject</span><span class=\"p\">(</span><span class=\"s2\">\"mathlib\"</span><span class=\"p\">),</span>  <span class=\"c1\"># swap this for your own local project with `LocalProject`</span>\n    <span class=\"n\">repl_rev</span><span class=\"o\">=</span><span class=\"s2\">\"v1.1.0-dev\"</span><span class=\"p\">,</span>\n    <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n<span class=\"n\">server</span> <span class=\"o\">=</span> <span class=\"n\">AutoLeanServer</span><span class=\"p\">(</span><span class=\"n\">config</span><span class=\"p\">)</span>\n</code></pre></div>\n<h3>Running examples:</h3>\n<p><strong>File1.lean:</strong></p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">time</span>\n\n<span class=\"n\">start_time</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">server</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">Command</span><span class=\"p\">(</span><span class=\"n\">cmd</span><span class=\"o\">=</span><span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">import Mathlib</span>\n\n<span class=\"s2\">def fib : Nat → Nat</span>\n<span class=\"s2\">  | 0 =&gt; 0</span>\n<span class=\"s2\">  | 1 =&gt; 1</span>\n<span class=\"s2\">  | n + 2 =&gt; fib (n + 1) + fib n</span>\n<span class=\"s2\">#eval fib 35</span>\n\n<span class=\"s2\">theorem foo : n = n := by rfl</span>\n<span class=\"s2\">\"\"\"</span><span class=\"p\">)))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Execution time:\"</span><span class=\"p\">,</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"n\">start_time</span><span class=\"p\">)</span>\n</code></pre></div>\n<p><strong>File2.lean:</strong></p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"n\">start_time</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">server</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">Command</span><span class=\"p\">(</span><span class=\"n\">cmd</span><span class=\"o\">=</span><span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">import Mathlib</span>\n\n<span class=\"s2\">theorem mathd_numbertheory_188 : Nat.gcd 180 168 = 12 := by norm_num</span>\n<span class=\"s2\">\"\"\"</span><span class=\"p\">)))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Execution time:\"</span><span class=\"p\">,</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"n\">start_time</span><span class=\"p\">)</span>\n</code></pre></div>\n<p><strong>File3.lean:</strong></p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"n\">start_time</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">server</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">Command</span><span class=\"p\">(</span><span class=\"n\">cmd</span><span class=\"o\">=</span><span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">import Mathlib</span>\n\n<span class=\"s2\">def fib : Nat → Nat</span>\n<span class=\"s2\">  | 0 =&gt; 0</span>\n<span class=\"s2\">  | 1 =&gt; 1</span>\n<span class=\"s2\">  | n + 2 =&gt; fib (n + 1) + fib n</span>\n<span class=\"s2\">#eval fib 35</span>\n\n<span class=\"s2\">theorem bar : n + 0 = n := by rfl</span>\n<span class=\"s2\">\"\"\"</span><span class=\"p\">)))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Execution time:\"</span><span class=\"p\">,</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"n\">start_time</span><span class=\"p\">)</span>\n</code></pre></div>\n</div></div>\n<p>If you prefer to use the REPL directly or your own wrapper, you can simply clone my <a href=\"https://github.com/augustepoiroux/repl\">repl fork</a> and checkout <code>v1.1.0-dev_lean-toolchain-{lean_version}</code>, or directly the <a href=\"https://github.com/leanprover-community/repl/pull/110\">PR</a> using Lean v4.21.0.</p>\n<h2>Implementation details</h2>\n<ul>\n<li>The prefix matching is implemented using a <strong>trie</strong>, meaning that the complexity of finding the best match is <em>constant</em> in the number of commands, and linear in the length of the command (i.e., the number of characters).</li>\n<li>In practice, so far I observed that the overhead, both in terms of runtime and memory, is negligible compared to elaborating a command. I would be happy to hear your experience and feedback on this.</li>\n</ul>\n<h2>Current limitations</h2>\n<p><del>- Incremental state reuse is only applied at the command-block level, meaning that changes in proofs still require a full re-elaboration of the proofs.</del></p>\n<ul>\n<li>If the content of the modules you import changes, the REPL has to be restarted (similar to having to do <code>Restart File</code> in VSCode). I am open to suggestions on how to improve this.</li>\n</ul>",
        "id": 526391386,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1751287076
    },
    {
        "content": "<p>Thanks! This seems super helpful, and I am really excited to use it.</p>",
        "id": 526408179,
        "sender_full_name": "Justin Asher",
        "timestamp": 1751291724
    },
    {
        "content": "<p>I think this feature could be quite useful in a MCP server. Current AI code agents tend to generate multiple file edits. This feature would allow the model to check the effect of each edit more efficiently.</p>",
        "id": 526412041,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1751292657
    },
    {
        "content": "<p>I agree 100%. This should speed a lot of things up.</p>",
        "id": 526415267,
        "sender_full_name": "Justin Asher",
        "timestamp": 1751293452
    },
    {
        "content": "<p>Turns out that I was wrong. Changes in proofs also benefit from incremental states out of the box (just like in VS Code). Good news for researchers generating thousands of proofs, you can now optimize your stack to maximize prefix matching per REPL instance to check proofs faster and with less memory ;)</p>",
        "id": 526429793,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1751297553
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321854\">Auguste Poiroux</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/REPL.3A.20automated.20incremental.20state.20reuse.20across.20commands/near/526412041\">said</a>:</p>\n<blockquote>\n<p>I think this feature could be quite useful in a MCP server. Current AI code agents tend to generate multiple file edits. This feature would allow the model to check the effect of each edit more efficiently.</p>\n</blockquote>\n<p>This sounds interesting! I have a use case where an agent can effectively check multiple single-line snippets to find the best way forward:<br>\n<a href=\"https://github.com/oOo0oOo/lean-lsp-mcp/blob/87f23ffccec16a2d77c47b6c55d383e3a13ce7f0/src/lean_lsp_mcp/server.py#L397\">https://github.com/oOo0oOo/lean-lsp-mcp/blob/87f23ffccec16a2d77c47b6c55d383e3a13ce7f0/src/lean_lsp_mcp/server.py#L397</a></p>\n<p>Currently this is a crude serial implementation using file updates via LSP. Am I right, that this could be sped up quite a bit using LeanInteract?</p>",
        "id": 526432669,
        "sender_full_name": "Oliver Dressler",
        "timestamp": 1751298448
    },
    {
        "content": "<p>Hmm maybe, I am not sure. The LSP is also relying on incremental states, right? So it should elaborate files starting from the line you edit. Or maybe I am missing something?</p>",
        "id": 526442295,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1751301596
    },
    {
        "content": "<p>You are right, it is incremental. There might still be some gains, as the LSP performs a relatively complex analysis. Another thing complicating the comparison is the (relatively new) parallel elaboration in the LSP.<br>\nI'll run some benchmarks soon to compare.</p>",
        "id": 526452687,
        "sender_full_name": "Oliver Dressler",
        "timestamp": 1751305689
    },
    {
        "content": "<p>Oh nice, I am interested in the results :)</p>",
        "id": 526456524,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1751306692
    },
    {
        "content": "<p>Now that I think of it, this opens up new possibilities. We can basically do tactic by tactic proofs by doing this:<br>\n<code>{\"cmd\": \"example ... := by\\n  tac1\"}</code>, then <code>{\"cmd\": \"example ... := by\\n  tac1\\n  tac2\"}</code>, and so on... The complexity will be linear in nb of tactics because of the incremental states. So, this offers an alternative to the REPL tactic mode, without the buggy parts, while being more flexible and just as efficient.<br>\nThis \"appending tactics one by one\" approach is mentioned in this old <a href=\"https://github.com/leanprover-community/repl/issues/6\">issue</a> (quadratic complexity), and I believe it is used by <a href=\"https://github.com/trishullab/itp-interface\">itp-interface</a> <span class=\"user-mention\" data-user-id=\"644040\">@George Tsoukalas</span>.<br>\nI think this should also make easier the development of \"block-by-block generation\" proving approaches. Generating proof blocks is probably a good intermediate between tactic-by-tactic and whole-proof generation methods.</p>",
        "id": 526470786,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1751310824
    }
]