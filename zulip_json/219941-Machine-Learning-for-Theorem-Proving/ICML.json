[
    {
        "content": "<p>ICML (one of the big AI conferences) is happening this week.  I’m attending and will present a poster on our recent <a href=\"https://icml.cc/virtual/2024/poster/34785\">Graph2Tac</a> work (updated from when I last talked about it here).</p>\n<p>Also, there is going to be an <a href=\"https://sites.google.com/view/ai4mathworkshopicml2024\">AI for Math workshop</a> which has some invited talks and lots of papers.  If anyone else here is coming, I’d love to attend your talk poster and/or chat about AI for theorem proving!</p>",
        "id": 452959334,
        "sender_full_name": "Jason Rute",
        "timestamp": 1721550700
    },
    {
        "content": "<p>I will also be presenting a poster on <a href=\"https://icml.cc/virtual/2024/poster/33614\">our paper on autoformalization</a>. Looking forward to seeing you there Jason!</p>",
        "id": 453034585,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1721592804
    },
    {
        "content": "<p>I don't think many of us are here, but for those who are (and for those who want to follow along from home), here are the most relevant posters I've found (not including all the many great works on the workshop on Friday):</p>\n<ul>\n<li>Wed 1:30 PM CET: <a href=\"https://icml.cc/virtual/2024/poster/34785\">Graph2Tac: Online Representation Learning of Formal Math Concepts</a> (<span class=\"user-mention\" data-user-id=\"306713\">@Lasse Blaauwbroek</span>, <span class=\"user-mention\" data-user-id=\"133339\">@Mirek Olšák</span>, <span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span>, Fidel I. Schaposnik, Jelle Piepenbrock, and Vasily Pestun)   </li>\n<li>Thu 1:30 PM CET: <a href=\"https://icml.cc/virtual/2024/poster/33040\">Subgoal-based Demonstration Learning of Formal Theorem Proving</a> (Xueliang Zhao,  <span class=\"user-mention\" data-user-id=\"384425\">@Wenda Li</span>, Lingpeng Kong) </li>\n<li>Thu 1:30 PM CET: <a href=\"https://icml.cc/virtual/2024/poster/33614\">Autoformalizing Euclidean Geometry</a> (<span class=\"user-mention\" data-user-id=\"319223\">@Logan Murphy</span>, <span class=\"user-mention\" data-user-id=\"584504\">@Kaiyu Yang</span>, Jialiang Sun, Zhaoyu Li, Anima Anandkumar, and Xujie Si)</li>\n</ul>",
        "id": 453626883,
        "sender_full_name": "Jason Rute",
        "timestamp": 1721809332
    },
    {
        "content": "<p>Besides all the above-mentioned papers, here are two posters I saw at ICML that I thought were very applicable to AI for formal theorem proving.</p>",
        "id": 457122130,
        "sender_full_name": "Jason Rute",
        "timestamp": 1723040473
    },
    {
        "content": "<p><a href=\"https://icml.cc/virtual/2024/poster/33107\">Language Agent Tree Search Unifies Reasoning Acting and Planning in Language Models</a><br>\nThis paper uses Monte Carlo Tree Search for solving a number of tasks, including generating computer code (the HumanEval benchmark).  In the code generation setting, each action is generating a complete Python function.  If the unit tests fail, the agent sees the test errors and gives a self-reflection in natural language about what it could do differently.  All those things, the previous attempt, the test errors, and the self-reflection are added to the next state which is used as a prompt for the LLM.  Since it is a tree search algorithm, it can choose to try a different branch of the search or to continue down this branch.</p>",
        "id": 457122201,
        "sender_full_name": "Jason Rute",
        "timestamp": 1723040497
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/VK7nZy6Id-90hEbtPDTDe3cU/Screen-Shot-2024-08-07-at-8.35.01-AM.png\">Screen-Shot-2024-08-07-at-8.35.01-AM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/VK7nZy6Id-90hEbtPDTDe3cU/Screen-Shot-2024-08-07-at-8.35.01-AM.png\" title=\"Screen-Shot-2024-08-07-at-8.35.01-AM.png\"><img data-original-dimensions=\"1778x760\" src=\"/user_uploads/thumbnail/3121/VK7nZy6Id-90hEbtPDTDe3cU/Screen-Shot-2024-08-07-at-8.35.01-AM.png/840x560.webp\"></a></div>",
        "id": 457122317,
        "sender_full_name": "Jason Rute",
        "timestamp": 1723040523
    },
    {
        "content": "<p>Many of the current LLM approaches for formal theorem proving approaches either predict individual tactics (which can get expensive) or do whole proof generation, with many independent samples ignoring system feedback (which defeats the point of an interactive theorem prover).  I wonder if a technique like this could work well in interactive theorem proving, or if it would just get expensive quickly.</p>",
        "id": 457122377,
        "sender_full_name": "Jason Rute",
        "timestamp": 1723040544
    },
    {
        "content": "<p><a href=\"https://icml.cc/virtual/2024/poster/34329\">MathScale: Scaling Instruction Tuning for Mathematical Reasoning</a><br>\n(Video: <a href=\"https://www.youtube.com/watch?v=BS4rrzajSdg\">https://www.youtube.com/watch?v=BS4rrzajSdg</a>)</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"BS4rrzajSdg\" href=\"https://www.youtube.com/watch?v=BS4rrzajSdg\"><img src=\"https://uploads.zulipusercontent.net/c7713f9fd16d2fba9425ac2fab15b8d4e0df785a/68747470733a2f2f692e7974696d672e636f6d2f76692f42533472727a616a5364672f64656661756c742e6a7067\"></a></div>",
        "id": 457122475,
        "sender_full_name": "Jason Rute",
        "timestamp": 1723040586
    },
    {
        "content": "<p>The goal of this paper is to create a synthetic natural language mathematic question-and-answer dataset for training an LLM to solve math problems.</p>",
        "id": 457122546,
        "sender_full_name": "Jason Rute",
        "timestamp": 1723040608
    },
    {
        "content": "<p>They do this by extracting mathematical data from an LLM (GPT 3.5) in the form of a graph of mathematical concepts.  This graph isn’t very sophisticated.  It includes a topic graph made up of high-level concepts, like Calculus and Trigonometry, and a Knowledge Point graph made up of specific examples like the chain rule and derivative of trigonometric functions.  Related nodes (both within the topic and knowledge point graphs as well as between them) are connected by an edge.</p>",
        "id": 457122600,
        "sender_full_name": "Jason Rute",
        "timestamp": 1723040631
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/zrOfIzvlg2h6iGFS8Pl5qglu/Screen-Shot-2024-08-07-at-9.22.40-AM.png\">Screen-Shot-2024-08-07-at-9.22.40-AM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/zrOfIzvlg2h6iGFS8Pl5qglu/Screen-Shot-2024-08-07-at-9.22.40-AM.png\" title=\"Screen-Shot-2024-08-07-at-9.22.40-AM.png\"><img data-original-dimensions=\"1374x560\" src=\"/user_uploads/thumbnail/3121/zrOfIzvlg2h6iGFS8Pl5qglu/Screen-Shot-2024-08-07-at-9.22.40-AM.png/840x560.webp\"></a></div>",
        "id": 457122696,
        "sender_full_name": "Jason Rute",
        "timestamp": 1723040650
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/RJO6yPQi5oK86lL1jWdS3Qqx/Screen-Shot-2024-08-07-at-9.22.54-AM.png\">Screen-Shot-2024-08-07-at-9.22.54-AM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/RJO6yPQi5oK86lL1jWdS3Qqx/Screen-Shot-2024-08-07-at-9.22.54-AM.png\" title=\"Screen-Shot-2024-08-07-at-9.22.54-AM.png\"><img data-original-dimensions=\"2158x1292\" src=\"/user_uploads/thumbnail/3121/RJO6yPQi5oK86lL1jWdS3Qqx/Screen-Shot-2024-08-07-at-9.22.54-AM.png/840x560.webp\"></a></div>",
        "id": 457122724,
        "sender_full_name": "Jason Rute",
        "timestamp": 1723040663
    },
    {
        "content": "<p>Once one has this graph, one can do random walks on it to brainstorm topics and knowledge points.  Then from those brainstormed nodes, one generates new math questions and uses GPT-3.5 to answer those questions.  I’m pretty sure there are no guarantees that the answers are correct, and they even say it doesn’t matter in their experiments.  Just having the additional data helps.</p>",
        "id": 457122794,
        "sender_full_name": "Jason Rute",
        "timestamp": 1723040687
    },
    {
        "content": "<p>I can’t help but wonder if an approach like this could be used to extract data in a more formal structure, like better knowledge graphs (using triples) or even in Lean.  One could imagine a system like this iteratively coming up with concepts, theorems, definitions, and small exercise problems for training an automated formal theorem prover.  This could be the next frontier in auto-formalization.</p>",
        "id": 457122818,
        "sender_full_name": "Jason Rute",
        "timestamp": 1723040696
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/ICML/near/457122201\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://icml.cc/virtual/2024/poster/33107\">Language Agent Tree Search Unifies Reasoning Acting and Planning in Language Models</a><br>\nThis paper uses Monte Carlo Tree Search for solving a number of tasks, including generating computer code (the HumanEval benchmark).  In the code generation setting, each action is generating a complete Python function.  If the unit tests fail, the agent sees the test errors and gives a self-reflection in natural language about what it could do differently.  All those things, the previous attempt, the test errors, and the self-reflection are added to the next state which is used as a prompt for the LLM.  Since it is a tree search algorithm, it can choose to try a different branch of the search or to continue down this branch.</p>\n</blockquote>\n<p>I have been following the Language Agent Tree Search (LATS) paper for a while now. It was initially submitted to (and rejected from) ICLR 2024 (<a href=\"http://url\">https://openreview.net/forum?id=6LNTSrJjBe</a>). A core concern of the ICLR reviewers was that LATS requires external environment feedback (mentioned in LATS Abstract: ... A key feature of our approach is the incorporation of an environment for external feedback, ...), and this is problematic for datasets like HotpotQA (reasoning in natural language) because the environment won't actually tell you the correct answer. This concern wasn't completely addressed in the ICML submission. In section 5.1 on page 6, they mention \"... Note that consistent with previous work (<a href=\"https://arxiv.org/abs/2210.03629\">Yao et al., 2023b</a> ; <a href=\"https://arxiv.org/abs/2303.11366\">Shinn et al., 2023</a> ), we use an oracle setup for HotPotQA, in which the environment provides feedback about the answer’s correctness upon receiving an answer. This enables a fair comparison between our method and baselines ...\", so the comparison is fair now, but it doesn't really solve the problem at hand.</p>\n<p>It seems to me that the main challenge of applying this method is getting the crucial \"external feedback from the environment\" mentioned in the abstract. In the context of Machine Learning for Theorem Proving, this likely means a way to assess the value of proof states. From other works it seems that this is a highly non-trivial task:  There is Proofsize objective in <a href=\"https://arxiv.org/abs/2202.01344\">Formal Mathematics Statement Curriculum Learning</a>, using a critic model in <a href=\"https://arxiv.org/abs/2205.11491\">HyperTree Proof Search</a>, and probably many many more that I am unaware of right now.</p>",
        "id": 457296748,
        "sender_full_name": "Yufan Zhao",
        "timestamp": 1723104506
    },
    {
        "content": "<p>I would say it is non-trivial but not “highly non-trivial” to get a value function from Lean’s feedback.  Sure you need a model which takes Lean’s feedback and converts it into a scalar.  The best way would be to use RL.  The AlphaZero algorithm provides a way to learn that scalar.  Start with a value of one if solved, zero otherwise.  And then use the backpropogated MCTS value as the training target for the valuation.  (Of course RL is expensive, especially in this setting.)</p>\n<p>But I’ve also just seen papers use an off the shelf LLM as a rough scorer of quality.  The DeepSeek-Prover paper does this.  And the LATS paper also does this.  If it works for LATS to turn Python unit test errors into a scalar, it may work fine for Lean errors as well.  (Although Python errors are more common than Lean errors in LLM training data.)</p>",
        "id": 457336627,
        "sender_full_name": "Jason Rute",
        "timestamp": 1723114448
    },
    {
        "content": "<p>(Also most tree search algorithms need some kind of a scalar value, so it isn’t like this is a problem unique to their method.)</p>",
        "id": 457336862,
        "sender_full_name": "Jason Rute",
        "timestamp": 1723114547
    }
]