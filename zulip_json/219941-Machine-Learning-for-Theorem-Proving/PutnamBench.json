[
    {
        "content": "<p>Happy to share <a href=\"https://github.com/trishullab/PutnamBench\">PutnamBench</a>, an evaluation benchmark for theorem-proving consisting of problems from the William-Lowell Putnam Mathematical Competition (a popular collegiate math exam in the US &amp; Canada) that our team at UT Austin has been working on for the past several months. We've gone through the competition exams from 1962-present and manually produced formalizations for 640 problems in Lean 4, Isabelle, and (partially) Coq. We've also included the informal problem statements with thanks to the MAA.</p>\n<p>We're sharing PutnamBench to allow the community to test their methods and give feedback as we continue to iterate on the benchmark. For the foreseeable future we will be actively maintaining the benchmark (including adding problems from future year's exams), and hope that it can serve as a useful measure of performance for systems aimed at competition-math problems.</p>\n<p>A majority of Putnam problems do not just require proving a theorem, but also finding a \"solution\" or \"answer\" and then proving its correctness. For such problems, our formalizations also factor out the solution from the theorem statement to enable two tasks: finding the solution (where applicable) and proving it correct, or proving the theorem directly.</p>",
        "id": 452196205,
        "sender_full_name": "George Tsoukalas",
        "timestamp": 1721252380
    },
    {
        "content": "<p>We've done cross-checking of the formalizations to help minimize the number of errors in the formalizations. However, we acknowledge that the benchmark is likely imperfect and hope that the community can help with patching any mistakes. We have not included any proofs and plan to avoid including any proofs as a way to minimize potential test-set leakage from LLM-based approaches (but we are open to your thoughts!).</p>\n<p>An evaluation of PutnamBench on several recent approaches finds that the benchmark is quite hard - in Lean only 1 problem of 640 was solved by any of the methods. In the other languages the case is similar, with no more than a handful of problems being currently solvable. We see PutnamBench as a hard open challenge for the research community, also aligned with the IMO Grand Challenge/AIMO Prize (in recent years, top performers on Putnam are IMO medalists).</p>",
        "id": 452196392,
        "sender_full_name": "George Tsoukalas",
        "timestamp": 1721252430
    },
    {
        "content": "<p>Noting that many recent approaches have used the valid split of miniF2F outside of pure evaluation, we think it makes sense to similarly split PutnamBench. We've been thinking that we can do a (train or valid)/test split year-wise, setting the validation/potential training split to be problems from 1962 to a certain year, and the remainder to serve as a true testing split. We're interested in making a choice for the splits that the community can agree upon so usage of the benchmark can remain consistent across new approaches. We would love to hear your thoughts on this! Ultimately the chosen split will form the basis for a public leaderboard which we are hosting, and we are likely to only accept new evaluation results which conform to the community agreed-upon split.</p>\n<p>We'd also love to discuss any questions or thoughts you have about the benchmark and (specifically) the best way to ensure its longevity as a useful benchmark. If you have feedback about particular formalizations in the benchmark, feel free to raise an issue at the github repository and we will be sure to address it!</p>",
        "id": 452196851,
        "sender_full_name": "George Tsoukalas",
        "timestamp": 1721252579
    },
    {
        "content": "<p>We've also recently released a <a href=\"https://arxiv.org/abs/2407.11214\">paper on arxiv</a> which presents PutnamBench in some more detail. This work would not have been possible without the full effort of my very talented collaborators: Jasper Lee, John Jennings, Jimmy Xin, Michelle Ding, Michael Jennings, Amitayush Thakur, and my advisor Swarat Chaudhuri.</p>\n<p>For folks who happen to be attending at ICML, some of us will be there and we would love to chat about PutnamBench and all things AI4Math!</p>",
        "id": 452196917,
        "sender_full_name": "George Tsoukalas",
        "timestamp": 1721252606
    },
    {
        "content": "<p>The <a href=\"https://github.com/trishullab/PutnamBench/blob/main/lean4/src/putnam_1962_a3.lean#L17\">very first question I clicked on</a> points to an obvious hole in mathlib: we still don't know what the <code>volume</code> of a triangle is!</p>",
        "id": 452198533,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721253117
    },
    {
        "content": "<p>Maybe future models need to not only solve the problem, but PR all the needed background material to Mathlib. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 452200543,
        "sender_full_name": "Jason Rute",
        "timestamp": 1721253708
    },
    {
        "content": "<p><a href=\"https://github.com/trishullab/PutnamBench/blob/main/lean4/src/putnam_2008_b5.lean\">putnam_2008_b5</a>, which shows up in Figure 2 of the paper, uses optParams for <code>fqsat</code> and <code>fsat</code>. I suspect the theorem does not mean what it is intended to mean.</p>",
        "id": 452200629,
        "sender_full_name": "David Renshaw",
        "timestamp": 1721253727
    },
    {
        "content": "<p><del>Would it be possible to put a <code>LICENSE</code> file in the repo? The norm for lean code is usually the Apache 2 license, but obviously the Coq and Isabelle communities may have different conventions.</del> Nevermind, I can't read</p>",
        "id": 452200934,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721253841
    },
    {
        "content": "<p>I look forward to seeing real measurable progress on this benchmark, hopefully in a generalizable way which equally applies to solving real world problems and lowering the difficulty of ITP use!</p>",
        "id": 452201552,
        "sender_full_name": "Jason Rute",
        "timestamp": 1721254017
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243791\">David Renshaw</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/PutnamBench/near/452200629\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/trishullab/PutnamBench/blob/main/lean4/src/putnam_2008_b5.lean\">putnam_2008_b5</a>, which shows up in Figure 2 of the paper, uses a optParams for <code>fqsat</code> and <code>fsat</code>. I suspect the theorem does not mean what it is intended to mean.</p>\n</blockquote>\n<p>That's not the only one... looking through just a few more problems, I found another optParam here: <a href=\"https://github.com/trishullab/PutnamBench/blob/main/lean4/src/putnam_1988_a2.lean\">https://github.com/trishullab/PutnamBench/blob/main/lean4/src/putnam_1988_a2.lean</a></p>",
        "id": 452202146,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1721254325
    },
    {
        "content": "<p>Here's the problem itself (1988 A-2):<br>\n<a href=\"/user_uploads/3121/NekYcvVvduVyJwVVGHycSqlW/Screenshot-2024-07-17-at-16-13-22-1988.pdf.png\">Screenshot-2024-07-17-at-16-13-22-1988.pdf.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/NekYcvVvduVyJwVVGHycSqlW/Screenshot-2024-07-17-at-16-13-22-1988.pdf.png\" title=\"Screenshot-2024-07-17-at-16-13-22-1988.pdf.png\"><img src=\"/user_uploads/3121/NekYcvVvduVyJwVVGHycSqlW/Screenshot-2024-07-17-at-16-13-22-1988.pdf.png\"></a></div>",
        "id": 452202253,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1721254398
    },
    {
        "content": "<p>I'll open an issue on the repo.</p>",
        "id": 452202878,
        "sender_full_name": "David Renshaw",
        "timestamp": 1721254658
    },
    {
        "content": "<p>It's also suspicious to formulate problems of the form \"determine whether this is true\" by making a <code>sorry</code>'ed prop, and asking for an <code>iff</code> assertion.</p>",
        "id": 452203016,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1721254724
    },
    {
        "content": "<p>you could just formulate the same exact prop, and the <code>iff</code> is then trivial.</p>",
        "id": 452203067,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1721254748
    },
    {
        "content": "<p>How are you currently testing current models?  Are you plugging the answer in directly?</p>",
        "id": 452203117,
        "sender_full_name": "Jason Rute",
        "timestamp": 1721254780
    },
    {
        "content": "<p>In particular, are you leaving <code>solution</code> in the proposition?  (Or are you replacing <code>solution</code> with the solution?)</p>",
        "id": 452203510,
        "sender_full_name": "Jason Rute",
        "timestamp": 1721254965
    },
    {
        "content": "<p><a href=\"https://github.com/trishullab/PutnamBench/issues/166\">https://github.com/trishullab/PutnamBench/issues/166</a></p>",
        "id": 452203591,
        "sender_full_name": "David Renshaw",
        "timestamp": 1721255030
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/PutnamBench/near/452198533\">said</a>:</p>\n<blockquote>\n<p>The <a href=\"https://github.com/trishullab/PutnamBench/blob/main/lean4/src/putnam_1962_a3.lean#L17\">very first question I clicked on</a> points to an obvious hole in mathlib: we still don't know what the <code>volume</code> of a triangle is!</p>\n</blockquote>\n<p>Yeah, although we have done our best to state the problems correctly, there may not be support in Mathlib to easily prove them. It may also be that some problems are stated correctly but may be difficult to prove because of the nature of the formalization, not the difficulty of the problem. In the case of this problem, we are stating area of a triangle as the volume of convex hull of three points (in that one we assert noncollinearity but in general we might not include nondegeneracy conditions if the truth value of the statement remains unchanged). We haven't written proofs for the theorems so we can't be sure if the formalizations represent the most natural way to state the problems.</p>",
        "id": 452205454,
        "sender_full_name": "George Tsoukalas",
        "timestamp": 1721255963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/PutnamBench/near/452203016\">said</a>:</p>\n<blockquote>\n<p>It's also suspicious to formulate problems of the form \"determine whether this is true\" by making a <code>sorry</code>'ed prop, and asking for an <code>iff</code> assertion.</p>\n</blockquote>\n<p>In the case of solution type Prop, one can easily enforce the solution value to be True or False. In general, it is unclear how to specify the boundary between values which we deem closed-form and those not closed-form as the solution to a problem. This can vary quite a lot depending on the problem and output type. Of course, if a method writes in as the solution the same statement, the theorem is true via reflexivity. </p>\n<p>At this point, we've not tried to specify what a closed-form solution is in general. I think this can be a nice topic to discuss as a community. We have not tested (and afaik no open-source ones exist) any models which try to do the solving and the proving in tandem.</p>",
        "id": 452206493,
        "sender_full_name": "George Tsoukalas",
        "timestamp": 1721256425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/PutnamBench/near/452203510\">said</a>:</p>\n<blockquote>\n<p>In particular, are you leaving <code>solution</code> in the proposition?  (Or are you replacing <code>solution</code> with the solution?)</p>\n</blockquote>\n<p>We replace <code>putnam_{year}_{num}_solution</code> with whatever the ground truth solution is, and then run the baselines on those formalizations. We haven't tested any methods which try to generate a solution and then prove its correctness (I'm not sure if any currently exist). A simple method one could try is to use the formalization to get a program/equation to solve and use the output of the executed problem/computer algebra solver to fill in the theorem statement, and then prove it via some established method. Since the baselines we try aren't able to prove that many problems with the correct solution written in, we haven't done this and probably future approaches should be much more intertwined.</p>",
        "id": 452207106,
        "sender_full_name": "George Tsoukalas",
        "timestamp": 1721256643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"644040\">George Tsoukalas</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/PutnamBench/near/452205454\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/PutnamBench/near/452198533\">said</a>:</p>\n<blockquote>\n<p>The <a href=\"https://github.com/trishullab/PutnamBench/blob/main/lean4/src/putnam_1962_a3.lean#L17\">very first question I clicked on</a> points to an obvious hole in mathlib: we still don't know what the <code>volume</code> of a triangle is!</p>\n</blockquote>\n<p>Yeah, although we have done our best to state the problems correctly, there may not be support in Mathlib to easily prove them.</p>\n</blockquote>\n<p>To be clear, this was a criticism of mathlib not your dataset!</p>",
        "id": 452208386,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721257189
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/PutnamBench/near/452203016\">said</a>:</p>\n<blockquote>\n<p>It's also suspicious to formulate problems of the form \"determine whether this is true\" by making a <code>sorry</code>'ed prop, and asking for an <code>iff</code> assertion.</p>\n</blockquote>\n<p>I don't think providing boolean answers in this way is meaningfully different from the issues that \"determine the set of all things that satisfy P\"-style questions have; and it's reasonable to declare solving this out of scope for the benchmark</p>",
        "id": 452208921,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721257359
    },
    {
        "content": "<p>I mostly agree, but I think questions of the form \"determine if this is true or false\" should not be out of scope! E.g. you could formulate it in the form <code>def foo : Bool := sorry ; def problem : P \\iff foo</code> or something like this (exploiting the fact that we can interpret bools as props)</p>",
        "id": 452209202,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1721257510
    },
    {
        "content": "<p>Oh, Nevermind. Of course <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=decPropToBool#doc\">docs#decPropToBool</a> will make the two equivalent.</p>",
        "id": 452209452,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1721257662
    },
    {
        "content": "<p>And even if you somehow enforce the prop to be either True or False, that still won't fix the issue since you can use <code>iff_true</code>, <code>iff_false</code> and <code>em</code></p>",
        "id": 452209744,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1721257848
    },
    {
        "content": "<p>no, \"prove or disprove this statement\" is strictly stronger than \"prove this statement is true or false\"</p>",
        "id": 452215146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721260983
    },
    {
        "content": "<p>assuming the normal form is forced to be <code>True</code> or <code>False</code>, proving <code>RiemannHypothesis &lt;-&gt; solution</code> will indeed net you a million dollars</p>",
        "id": 452215256,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721261044
    },
    {
        "content": "<p>the key point is that the solution expression must <em>externally</em> have a normal form, it can't simply be reducible to a normal form and it certainly can't be an arbitrary well typed proposition</p>",
        "id": 452215442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721261168
    },
    {
        "content": "<p>I guess you can enforce the normal form to be True or False using metaprogramming (so at the Expr level). Is that what you mean?</p>",
        "id": 452215707,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1721261331
    },
    {
        "content": "<p>Right now the setup is <code>def solution : Prop := sorry</code> and if I understand correctly the AI can just fill in anything in place of the sorry</p>",
        "id": 452215829,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1721261403
    },
    {
        "content": "<p>All I'm saying is that (even if <code>solution : Bool</code>) you can do things like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">solution</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">RiemannHypothesis</span>\n\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">million_bucks_please</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RiemannHypothesis</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">solution</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">solution</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 452218123,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1721262854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/PutnamBench/near/452215829\">said</a>:</p>\n<blockquote>\n<p>Right now the setup is <code>def solution : Prop := sorry</code> and if I understand correctly the AI can just fill in anything in place of the sorry</p>\n</blockquote>\n<p>My understanding is that this is incorrect. The format of the benchmark includes two sorries, but the way in which this is turned into a solving task is not specified, and in particular the approach you are assuming - which is that the solver is supposed to replace both <code>sorry</code>s with expressions/proofs making the file typecheck - is apparently not under consideration, and instead the task is split into two parts, one for guessing the first <code>sorry</code> and one for solving the problem given a solution for the first <code>sorry</code>.</p>",
        "id": 452221887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721265094
    },
    {
        "content": "<p>It seems the \"correct\" overall task is to supply a value for the first <code>sorry</code> matching some ill-defined normalization condition (which could be programmatically verified by reading <code>Expr</code>s as you suggest), and then supplying any value for the second <code>sorry</code> making the resulting file typecheck.</p>",
        "id": 452222142,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721265239
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644040\">@George Tsoukalas</span> You may want to share this benchmark directly with the Coq and Isabelle folks.  The Coq Zulip has a similar machine learning channel for example.  That way, you will get full breadth and also you will have experts looking over your translations.  (I think Coq is especially tricky with the many possible ways to express things.  I think this issue really held up the translation of MiniF2F to Coq.)</p>",
        "id": 452359034,
        "sender_full_name": "Jason Rute",
        "timestamp": 1721312691
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/PutnamBench/near/452359034\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"644040\">George Tsoukalas</span> You may want to share this benchmark directly with the Coq and Isabelle folks.  The Coq Zulip has a similar machine learning channel for example.  That way, you will get full breadth and also you will have experts looking over your translations.  (I think Coq is especially tricky with the many possible ways to express things.  I think this issue really held up the translation of MiniF2F to Coq.)</p>\n</blockquote>\n<p>Some of us are travelling this week and won't have the capacity to review feedback for all languages in a timely manner, so we're going to hold off on sharing for the time being. We are also still doing some reviews of newly added problems. But, feel free to share it if you please.</p>",
        "id": 452370446,
        "sender_full_name": "George Tsoukalas",
        "timestamp": 1721315425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"644040\">George Tsoukalas</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/PutnamBench/near/452205454\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/PutnamBench/near/452198533\">said</a>:</p>\n<blockquote>\n<p>The <a href=\"https://github.com/trishullab/PutnamBench/blob/main/lean4/src/putnam_1962_a3.lean#L17\">very first question I clicked on</a> points to an obvious hole in mathlib: we still don't know what the <code>volume</code> of a triangle is!</p>\n</blockquote>\n<p>Yeah, although we have done our best to state the problems correctly, there may not be support in Mathlib to easily prove them. It may also be that some problems are stated correctly but may be difficult to prove because of the nature of the formalization, not the difficulty of the problem. In the case of this problem, we are stating area of a triangle as the volume of convex hull of three points (in that one we assert noncollinearity but in general we might not include nondegeneracy conditions if the truth value of the statement remains unchanged). We haven't written proofs for the theorems so we can't be sure if the formalizations represent the most natural way to state the problems.</p>\n</blockquote>\n<p>Volume of convex hull is fine for the volume of a simplex, but to talk about it in proper generality (i.e. Euclidean affine spaces not just Euclidean vector spaces) we need the convexity refactor that has been talked about for a long time.</p>",
        "id": 452437765,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1721335629
    },
    {
        "content": "<p>(I don't know what the proper generality for this particular problem is - some competition geometry problems do talk about an origin / coordinates, in which case a more concrete Euclidean vector space is appropriate - but for problems that don't do that, a Euclidean affine space is more appropriate.)</p>",
        "id": 452438082,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1721335732
    },
    {
        "content": "<p>I mean, if you really want to make things hard for yourself you can talk about the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure.hausdorffMeasure#doc\">docs#MeasureTheory.Measure.hausdorffMeasure</a> of order 2 of the convex hull, <code>μH[2] (convexHull ℝ {A, B, C})</code>, so that you can work with triangles in 3D too</p>",
        "id": 452456629,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721346029
    },
    {
        "content": "<p>In fact, due to <em>not</em> using this more complex spelling, <a href=\"https://github.com/trishullab/PutnamBench/blob/84beb3b44bf025a3c7c26087e47d349e73edc3eb/lean4/src/putnam_2013_a5.lean#L14-L15\">this problem</a> incorrectly defines the areas as zero.</p>",
        "id": 452456900,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721346248
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I think we would all love to see the AlphaProof paper test on PutnamBench (and MiniF2F).  But of course the worry is that if you spend 3 days per problem that is a lot of time and doesn’t capture if the solution if coming just from massive scale in time or from a good algorithm.  This topic came up at the AI for Math workshop yesterday.</p>",
        "id": 454436233,
        "sender_full_name": "Jason Rute",
        "timestamp": 1722062719
    },
    {
        "content": "<p>I’m being a bit polemic when I say 3 days per problem.  I assume you would not do that here, but I think you get the point.  Our own experiments in Graph2Tac show that pass rate is something like logarithmic in the time used, so it is hard to compare approaches using vastly different time scales (or other resources) unless you show the scaling plot.</p>",
        "id": 454436580,
        "sender_full_name": "Jason Rute",
        "timestamp": 1722063041
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> Not only is it three days per problem but  also ran on a massive amount on TPU's as I understand it...</p>",
        "id": 454447795,
        "sender_full_name": "Lasse Blaauwbroek",
        "timestamp": 1722071397
    },
    {
        "content": "<p>On the other hand I am of the opinion that it's a good thing they have an algorithm that can do more given 3 days and huge amounts of compute. I think it indicates it is more likely to improve and scale with the addition of even more compute--which will inevitably come in the future.</p>",
        "id": 454466489,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1722081882
    },
    {
        "content": "<p>Yeah, in Graph2Tac we saw a log-linear scaling  so with even more compute it would do better and here it looks like through RL and good engineering they (hopefully) maximized the log linear scaling rate even more.  I think over long time horizons, RL is really efficient as a search algorithm and it looks like they actually put that to the test here.  What would be the best is if, even in lower compute budgets, one could see this log linear trend and know it will extrapolate to the 3-day regime.  It would be great if we could compare algorithms by their log linear scaling rate instead of raw theorems proved.</p>",
        "id": 454474908,
        "sender_full_name": "Jason Rute",
        "timestamp": 1722088969
    },
    {
        "content": "<p>The scaling certainly can't be log linear forever, since that implies with enough compute you would prove more than 100% of the theorems. So it might be problematic to say one algorithm is better since its scaling rate is faster, because the log linear curve of this algorithm might cross over the log linear curve of another algorithm after the point where the scaling stops following a log linear curve. As long as you test two algorithms at the same compute budget you can compare their performance with equal amounts of compute.</p>",
        "id": 454509936,
        "sender_full_name": "Will Sawin",
        "timestamp": 1722104837
    },
    {
        "content": "<p>The replacement for log linear with a cap is inverse-sigmoid linear, incidentally.</p>",
        "id": 454511073,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1722105195
    },
    {
        "content": "<p>Yes.  I mostly agree.  It isn’t perfectly log linear and the math wouldn’t allow it (although I think ideally one should also take into account that the problems themselves are sampled according to some distribution, so the cap in that regard is not fixed, <em>Edit: I’m being silly.  It is still 100%.</em>).  So one can’t be certain that an algorithm will scale without checking, but showing those numbers (which are trivial to make a graph of) really help to tell a story.  I don’t understand why more papers don’t plot this sort of thing.  You don’t even have to run any new experiments!</p>",
        "id": 454511623,
        "sender_full_name": "Jason Rute",
        "timestamp": 1722105406
    },
    {
        "content": "<p>Actually here is a mathematical question.  I think this “log linear” behavior has also been observed for the setting of n independent samples.  Say sampling independent proofs from DeekSeek-Prover shows that the percent of test proofs solved is proportional to log(n) .  But since it is independent, we actually should know the math.  Do we know what that linear scaling law is?  Is it inverse sigmoid linear?  (The issue is that it isn’t one test problem but a set (or distribution) of them, so I think this is sampling from a binary exchangeable sequence instead of an i.i.d sequence. First you select the problem randomly from the test set and then sample independently until success.)</p>",
        "id": 454512791,
        "sender_full_name": "Jason Rute",
        "timestamp": 1722106242
    },
    {
        "content": "<p>I think you can get a bunch of inequalities that the function has to satisfy but no identities. The success probability as a function of time will be a convex combination of functions of the form 1 - c^(-x) which is equivalent to being &lt;1 with positive first derivative, negative second derivative, positive third derivative, ...</p>",
        "id": 454549332,
        "sender_full_name": "Will Sawin",
        "timestamp": 1722128633
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/PutnamBench/near/452456629\">said</a>:</p>\n<blockquote>\n<p>I mean, if you really want to make things hard for yourself you can talk about the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure.hausdorffMeasure#doc\">docs#MeasureTheory.Measure.hausdorffMeasure</a> of order 2 of the convex hull, <code>μH[2] (convexHull ℝ {A, B, C})</code>, so that you can work with triangles in 3D too</p>\n</blockquote>\n<p>I think you'll probably need to scale the Hausdorff measure to get the right notion of area in a Euclidean space. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.hausdorffMeasure_pi_real#doc\">docs#MeasureTheory.hausdorffMeasure_pi_real</a> is specifically about n-dimensional measures in an n-dimensional space with sup metric; changing to the Euclidean metric will scale the Hausdorff measure. The PutnamBench problem you found trying to use areas in three dimensions is using <code>Fin 3 → ℝ</code> (i.e. sup metric), and 2-dimensional Hausdorff measure with 3-dimensional sup metric has its own problems; you probably get the sup of the areas of the projections of the triangle onto the spaces spanned by any two of the coordinate axes, which is also not the standard notion of area of a triangle in three dimensions.</p>\n<p>I guess this all goes to illustrate how it's hard to be confident in the correctness of a formal problem statement without formalizing a solution, and hard to be confident in the correctness of a formal definition (say, of the area of a triangle) if you don't add enough API lemmas to show it behaves as expected. And we could certainly do with an appropriate API for volumes of arbitrary sets in Euclidean space (using scaled Hausdorff measure, say) - but it does need API, not just a definition we hope gets the scaling right.</p>",
        "id": 459467267,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1723208247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243791\">David Renshaw</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/PutnamBench/near/452202878\">said</a>:</p>\n<blockquote>\n<p>I'll open an issue on the repo.</p>\n</blockquote>\n<p>I've already opened a draft PR about it (<a href=\"https://github.com/trishullab/PutnamBench/pull/202\">trishullab/PutnamBench#202</a>), but you've run into a very common Lean footgun here: <code>set_option autoImplicit false</code> is not the default, and as a result a handful of the formalizations have nonsensical auto-inserted quantifiers.</p>",
        "id": 462327010,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723635785
    },
    {
        "content": "<p>Howdy folks! Sharing some updates for PutnamBench:</p>\n<ol>\n<li>Since release we have had a lot of community support in adding new problems and patching formalization errors - big thanks to <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> , <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> , <span class=\"user-mention\" data-user-id=\"474578\">@Edward Lockhart</span> , <span class=\"user-mention\" data-user-id=\"313038\">@Moritz Firsching</span>, <span class=\"user-mention\" data-user-id=\"766274\">@Simon Sorg</span> , <span class=\"user-mention\" data-user-id=\"376152\">@Paul Lezeau</span> , <span class=\"user-mention\" data-user-id=\"650358\">@Salvatore Mercuri</span>, and <span class=\"user-mention\" data-user-id=\"210057\">@Fabian Glöckle</span>. In particular, the problems from 2024's Putnam Competition have been added.</li>\n<li>We have also received some leaderboard entries - the best performing model on PutnamBench presently is Self-Play Theorem Prover (<a href=\"https://github.com/kfdong/STP\">https://github.com/kfdong/STP</a>), which solves 8 of the 657 problems in pass@4096. Afterwards we have Goedel-Prover SFT (pass@512) &amp; ABEL (pass@596) which prove 7 of the 657 problems.</li>\n<li>We have now run evaluations with several leading models in generating one proof attempt per problem (pass@1): o3-mini, Claude 3.7, Gemini 2.0 Flash Thinking Experimental, Deepseek R1. Here are the results, as well as the costs of these experiments:</li>\n</ol>\n<ul>\n<li><strong>OpenAI o3-mini</strong>: 0/657. Cost: ~$20.</li>\n<li><strong>Claude Sonnet 3.7</strong>: 0/657. Cost: ~$21.</li>\n<li><strong>Gemini 2.0 Flash Thinking Experimental (1/21)</strong>: 0/657. Cost: ~Free through AIStudio API.</li>\n<li><strong>DeepSeek R1</strong>: 0/657. Cost: ~$3 (ran through API)</li>\n</ul>\n<p>While the final numbers are poor - the models do produce proofs which <em>look</em> correct, but usually for syntactic reasons the proofs fail. My general feeling is that the models try to produce very human readable proofs, which are often extremely verbose and produce many steps as opposed to a simple <code>linarith</code>. Some of the models confuse Lean 3 and Lean 4 syntax, which is a well known issue. Most of the problems which have been solved before by other methods rely heavily on such automated tactics, and the proofs themselves usually aren't very long. Given the syntax adherence issues I think it's critical that LLM + theorem proving approaches use Lean error information in an agentic loop. For instance, I expect that an agent using Sonnet 3.7 that can revise its proof over N iterations could take the top spot on the leaderboard. Another important angle is effective retrieval from Mathlib.</p>\n<p>You can also run these experiments yourself! See the code at <a href=\"https://github.com/GeorgeTsoukalas/FTPEvals/\">https://github.com/GeorgeTsoukalas/FTPEvals/</a> - feel free to use it for your own evaluations! The Lean interaction relies on <span class=\"user-mention\" data-user-id=\"657996\">@Amitayush Thakur</span> 's itp-interface (<a href=\"https://github.com/trishullab/itp-interface/\">https://github.com/trishullab/itp-interface/</a>), which has an extremely easy setup (assuming Lean is installed, the whole project can be setup with a simple setup script).</p>",
        "id": 504960653,
        "sender_full_name": "George Tsoukalas",
        "timestamp": 1741728645
    },
    {
        "content": "<p>Here is an example of the generated proofs of the \"easiest\" problem in PutnamBench:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">o3</span><span class=\"bp\">-</span><span class=\"n\">mini</span>\n<span class=\"c1\">-- Error: need to do use x,y,z not use x, use y, use z (and split will fail)</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">putnam_1988_b1</span>\n<span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">hb</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">z</span>\n<span class=\"n\">split</span>\n<span class=\"w\">  </span><span class=\"n\">linarith</span>\n<span class=\"n\">split</span>\n<span class=\"w\">  </span><span class=\"n\">linarith</span>\n<span class=\"n\">split</span>\n<span class=\"w\">  </span><span class=\"n\">norm_num</span>\n<span class=\"n\">ring</span>\n\n<span class=\"n\">Gemini</span><span class=\"w\"> </span><span class=\"n\">Thinking</span><span class=\"o\">:</span>\n<span class=\"c1\">-- Error: split not applicable</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">putnam_1988_b1</span>\n<span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">hb</span>\n<span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"n\">split</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sub_pos_of_lt</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"n\">split</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sub_pos_of_lt</span><span class=\"w\"> </span><span class=\"n\">hb</span>\n<span class=\"n\">split</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">zero_lt_one</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">ring</span>\n\n<span class=\"n\">Sonnet</span><span class=\"w\"> </span><span class=\"mf\">3.7</span><span class=\"o\">:</span>\n<span class=\"c1\">-- Error: Calc block fails</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">putnam_1988_b1</span>\n<span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">hb</span>\n<span class=\"n\">use</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">-</span><span class=\"mi\">1</span>\n<span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">ha'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">  </span><span class=\"n\">linarith</span>\n<span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hb'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hb</span>\n<span class=\"w\">  </span><span class=\"n\">linarith</span>\n<span class=\"n\">constructor</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"n\">constructor</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ha'</span>\n<span class=\"n\">constructor</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hb'</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">congr</span>\n<span class=\"w\">      </span><span class=\"n\">ring</span>\n<span class=\"w\">    </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ring</span>\n\n<span class=\"n\">Deepseek</span><span class=\"w\"> </span><span class=\"n\">R1</span><span class=\"o\">:</span>\n<span class=\"c1\">-- Error: did not intro the hypotheses a ≥ 2, b ≥ 2</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">putnam_1988_b1</span>\n<span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"n\">use</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"n\">constructor</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">nlinarith</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mul_le_mul_left</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"bp\">```</span>\n</code></pre></div>",
        "id": 504961515,
        "sender_full_name": "George Tsoukalas",
        "timestamp": 1741728920
    },
    {
        "content": "<p>In my experience these frontier models generally do better when given the opportunity to fix its code in a feedback loop with the lean executable. (Saw that you mentioned this direction in your post as well.) E.g. here's a correct solution from Sonnet 3.7 with <a href=\"https://github.com/GasStationManager/LeanTool\">LeanTool</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">--theorem putnam_1988_b1</span>\n<span class=\"c1\">--: ∀ a ≥ 2, ∀ b ≥ 2, ∃ x y z : ℤ, x &gt; 0 ∧ y &gt; 0 ∧ z &gt; 0 ∧ a * b = x * y + x * z + y * z + 1</span>\n\n\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">problem_statement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">,</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- We'll prove this by constructing specific values for x, y, and z</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">hb</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Let's try x = a - 1, y = 1, z = b - 1</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Now we need to prove the four conditions</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Prove x &gt; 0</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">    </span><span class=\"n\">linarith</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Prove y &gt; 0</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">norm_num</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hy</span>\n\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Prove z &gt; 0</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hz</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hb</span>\n<span class=\"w\">    </span><span class=\"n\">linarith</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hz</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Prove a * b = x * y + x * z + y * z + 1</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Substitute x = a - 1, y = 1, z = b - 1</span>\n<span class=\"w\">  </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">ring</span>\n</code></pre></div>",
        "id": 505189278,
        "sender_full_name": "GasStationManager",
        "timestamp": 1741797655
    },
    {
        "content": "<p>Interestingly the non-reasoning versions of the models seems to be a bit better at diligently checking the code with Lean, and responding to the error messages, compared to their reasoning counterparts. Here's GPT 4o with LeanTool:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">putnam_1988_b1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">hb</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">linarith</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">linarith</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">linarith</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ring</span>\n</code></pre></div>",
        "id": 505232653,
        "sender_full_name": "GasStationManager",
        "timestamp": 1741808447
    },
    {
        "content": "<p>For harder problems it may be interesting to let a reasoning model to come up with a proof sketch, then finish up with a non-reasoning model.</p>",
        "id": 505232993,
        "sender_full_name": "GasStationManager",
        "timestamp": 1741808549
    },
    {
        "content": "<p>question for those on the ML side: how much work/cost would it be to RL post train deepseek R1 against lean 4 environment to mitigate these syntactic issues (and hopefully also to improve math skills with more training)? Let's say you have already gathered 100k lean4 problem statements roughly in distribution of this test set for argument sake. Is it something we could hope to achieve outside of industry level funding? Is there hope to get this sort of funding from academia sources and to do it in a more open/collaborative way?</p>",
        "id": 505287613,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1741827950
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"662620\">Andy Jiang</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/PutnamBench/near/505287613\">said</a>:</p>\n<blockquote>\n<p>question for those on the ML side: how much work/cost would it be to RL post train deepseek R1 against lean 4 environment to mitigate these syntactic issues (and hopefully also to improve math skills with more training)? Let's say you have already gathered 100k lean4 problem statements roughly in distribution of this test set for argument sake. Is it something we could hope to achieve outside of industry level funding? Is there hope to get this sort of funding from academia sources and to do it in a more open/collaborative way?</p>\n</blockquote>\n<p>I think augmenting 100k lean4 problems will lead to many of them nonprovable and make RL very hard to work.</p>",
        "id": 505304776,
        "sender_full_name": "Zheng Yuan",
        "timestamp": 1741835255
    },
    {
        "content": "<p>Do you mean like they will be false or too high in difficulty? I'm more asking about how doable the rest of process is after getting a curated 100k dataset. That being said I don't think human-curating 100k problem statements is an astronomical task with a small team</p>",
        "id": 505311162,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1741837929
    },
    {
        "content": "<p>They will be false and hard at the same time. And we have no way to verify if this problem is too hard or incorrectly formalized. I think this part could be harder than actual RL. Also if only focus on RL, there exists some datasets including lean-workbook, deepseek-prover-v1, and stp which can be used.</p>",
        "id": 505338295,
        "sender_full_name": "Zheng Yuan",
        "timestamp": 1741850494
    },
    {
        "content": "<p>So are you saying that you don't trust a group of human curators to do a good enough job of producing/choosing a huge dataset of formal problems unless we also ask them to provide formal proofs? Let me accept your premise for a second--how bad is it for RL if say 50% of statements are false? It will just increase compute right? It's not like they will be rewarded for wrong behaviors</p>",
        "id": 505379546,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1741861453
    },
    {
        "content": "<p>Such questions could also be approached experimentally: generate (synthetically) just 100 problems, and have a team of humans inspect them to count how many are: trivially true, trivially false, true and doable to prove, false and doable to disprove, too hard to decide either way...</p>",
        "id": 505396565,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1741866112
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"662620\">Andy Jiang</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/PutnamBench/near/505379546\">said</a>:</p>\n<blockquote>\n<p>So are you saying that you don't trust a group of human curators to do a good enough job of producing/choosing a huge dataset of formal problems unless we also ask them to provide formal proofs? Let me accept your premise for a second--how bad is it for RL if say 50% of statements are false? It will just increase compute right? It's not like they will be rewarded for wrong behaviors</p>\n</blockquote>\n<p>I am considering 100k is obtained by LLM. If you say expert curated 100k, i will believe RL just works.</p>",
        "id": 505413270,
        "sender_full_name": "Zheng Yuan",
        "timestamp": 1741870472
    },
    {
        "content": "<p>But do you have an estimate of how much the RL part would cost--as in do you expect it could be done by the lean community if such an open dataset appeared? Or would it have to be done in a big AI lab? Do you think if such a dataset appeared one of the medium/large labs would post train R1 on it and release the weights after training?</p>",
        "id": 505547116,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1741909650
    },
    {
        "content": "<p>I think current PutnamBench still has the 2013 A5 problem discussed above (2-dimensional Hausdorff measure in <code>Fin 3 → ℝ</code> does not correspond to any standard notion of area). If you used <code>EuclideanSpace ℝ (Fin 3)</code> you still wouldn't have area (we still need a definition / API in mathlib for a version of Hausdorff measure that's appropriately scaled for the Euclidean metric), but you would at least have area scaled by some positive constant (so be clearly-to-humans equivalent to the original problem in this case, where scaling the area doesn't actually matter to the statement).</p>",
        "id": 505547722,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1741910003
    },
    {
        "content": "<p>The difficulty in getting the right formal statement without writing a formal proof is evident from experience in many contexts (not just benchmarks or competition problems, but also a range of formalization projects). But we do know from AlphaProof that RL (for learning how to prove things in Lean) works given a collection of formal problem statements, some of which are wrong (and trying both proving and disproving the statements), since proving anything can be useful training for an AI even if the formal statement proved doesn't correspond to the intended informal statement.</p>",
        "id": 505548173,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1741910237
    },
    {
        "content": "<p>Of course, even if a benchmark full of misformalizations is still usable for training an AI, it's not great as an evaluation intended to imply comparisons to humans, as the humans almost always get the correct questions which are usually harder.</p>",
        "id": 505549069,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741910680
    },
    {
        "content": "<p>I think correcting such evaluation benchmarks as mistakes are found is the right thing to do though; while this can invalidate old evaluations, the same could be said of bumping the Lean/Mathlib version which can certainly affect problem difficulty. The alternative of everyone evaluating their models only on frozen benchmark on Lean/Mathlib 4.7.0 (say) forevermore would result in models that excel at the benchmark but are far less useful to the real users on the bleeding edge.</p>",
        "id": 505549589,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741910901
    },
    {
        "content": "<p><em>Some</em> types of mistakes in writing formal statements could be addressed by a checklist - both standard Lean translations of informal concepts (like in my proposed conventions for formal IMO problem statements), and common pitfalls (which include such things as the metric on <code>Fin 3 → ℝ</code>, and natural number subtraction, for example) - as well as more general things such as \"check each condition in the informal problem is mentioned in the formal statement (and not just in an auxiliary definition you forgot to use in the actual statement)\" and \"check the types in the formal statement are consistent with the informal one\". But I don't know what level of accuracy is likely to be achieved even with a careful checklist. (The next step from such a checklist is maybe \"multiple people independently write formal statements for the same problem, verify their own and each other's against the checklist, and then discuss the statements with each other and decide which single statement is the best one to use for the benchmark / competition for AI entrants / ....)</p>",
        "id": 505549661,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1741910939
    },
    {
        "content": "<p>Although humans do almost always get the correct questions, to some extent that depends on the same sort of checks for matching types etc. between human languages as are important in checking formal problem statements. When draft translations of the problems are displayed at an international olympiad for leaders to review each others' translations, getting a type wrong (e.g. saying \"integer\" instead of \"real\") or missing a condition (e.g. forgetting \"positive\"), or having a typo resulting in the wrong variables being used in an equation, are fairly common mistakes found in the drafts and fixed before they go to contestants. (Those are also things you can often spot without knowing the language in question.) On the rarer occasions where such a mistake gets through to contestants, it helps that most contestants will have requested the (correct) English version in addition to their native language.</p>",
        "id": 505550645,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1741911398
    },
    {
        "content": "<p>For comparison to humans, as well as correcting mistakes in the statements being a good idea, updating Lean and mathlib is a good idea, not just to encourage practical usefulness in an AI, but also because newer mathlib means more definitions so more problems can be cleanly stated at all. (Does PutnamBench have any list somewhere of the missing mathlib definitions that were the reasons for each omitted Putnam problem in the given date range not being included - an analogue of my checklist at the bottom of <a href=\"https://github.com/jsm28/IMOLean\">https://github.com/jsm28/IMOLean</a> of geometrical definitions that should be added to mathlib in support of being able to cleanly state more past and probably more future IMO problems?)</p>",
        "id": 505551520,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1741911815
    },
    {
        "content": "<p>There's no list like this right now, but I think it would be a good idea to add one. There are some contributors adding a fairly large set of new problems, once that's all in I can go through and annotate the remaining ones. I also think having a checklist of common formalization bugs would be good to have and can be compiled from PRs for PutnamBench. I have been meaning to do this because I'm interested in having one of the new LLMs do an automated sweep through PutnamBench for more bugs, but haven't had the bandwidth to carry it out. If anyone wants to be involved in a small project to do that I would be very happy to support it :)</p>",
        "id": 509047501,
        "sender_full_name": "George Tsoukalas",
        "timestamp": 1743354842
    },
    {
        "content": "<p>Also, there was a slight bug in our evaluation code (written ontop of <code>itp-interface</code>, not in our Lean tool itself) that caused a small number of correct proofs to be reported incorrect. This has been fixed, the numbers for Claude 3.7 &amp; o3-mini are still both 0 solved. However, R1 did solve 1 problem, as did Gemini 2.0 Flash Thinking.</p>\n<p>We also ran the recently released Gemini 2.5 Pro Experimental with pass@1, same prompt as the other models, and it solved 3/657 problems. Like before, I think wrapping 3.7/R1/Gemini models in an agent loop, with an optimized prompt, is going to solve many more. Still no eval for Grok 3 because I have not gotten API access yet.</p>",
        "id": 509048135,
        "sender_full_name": "George Tsoukalas",
        "timestamp": 1743355355
    },
    {
        "content": "<p>What do the hearts (\"<span aria-label=\"green heart\" class=\"emoji emoji-1f49a\" role=\"img\" title=\"green heart\">:green_heart:</span>\", \"<span aria-label=\"blue heart\" class=\"emoji emoji-1f499\" role=\"img\" title=\"blue heart\">:blue_heart:</span>\") mean on the <a href=\"https://trishullab.github.io/PutnamBench/leaderboard.html\">leaderboard</a>?</p>",
        "id": 509072259,
        "sender_full_name": "David Renshaw",
        "timestamp": 1743375435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243791\">David Renshaw</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/PutnamBench/near/509072259\">said</a>:</p>\n<blockquote>\n<p>What do the hearts (\"<span aria-label=\"green heart\" class=\"emoji emoji-1f49a\" role=\"img\" title=\"green heart\">:green_heart:</span>\", \"<span aria-label=\"blue heart\" class=\"emoji emoji-1f499\" role=\"img\" title=\"blue heart\">:blue_heart:</span>\") mean on the <a href=\"https://trishullab.github.io/PutnamBench/leaderboard.html\">leaderboard</a>?</p>\n</blockquote>\n<p>According to <a href=\"https://github.com/trishullab/PutnamBench/blob/ffa8cb06d51593f87887f5ee29b918b56cee7240/docs/leaderboard.html#L424-L430\">this</a>, it seems it means that the model is fully (<span aria-label=\"green heart\" class=\"emoji emoji-1f49a\" role=\"img\" title=\"green heart\">:green_heart:</span>) or partially (<span aria-label=\"blue heart\" class=\"emoji emoji-1f499\" role=\"img\" title=\"blue heart\">:blue_heart:</span>) open sourced (it would indeed be good if the webpage itself explained this) (EDIT: Now it does, kudos!)</p>",
        "id": 509074651,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1743377716
    },
    {
        "content": "<p>why is lean green and the others red?</p>",
        "id": 509075298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743378353
    },
    {
        "content": "<p>Why is \"<a href=\"https://github.com/kfdong/STP\">Self-play Theorem Prover</a>\" not considered open sourced?</p>",
        "id": 509225213,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1743432980
    },
    {
        "content": "<p>Ah, I forgot to update that when they open sourced the model. Will add info about the hearts to the page, and make the border colors uniform, not sure how I never noticed that before. Also, I've run an eval with DeepSeek-V3-0324 and it solves no problems.</p>",
        "id": 509239566,
        "sender_full_name": "George Tsoukalas",
        "timestamp": 1743436069
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">--theorem putnam_1988_b1</span>\n<span class=\"c1\">--: ∀ a ≥ 2, ∀ b ≥ 2, ∃ x y z : ℤ, x &gt; 0 ∧ y &gt; 0 ∧ z &gt; 0 ∧ a * b = x * y + x * z + y * z + 1</span>\n</code></pre></div>\n<p>I think this formalization is slightly easier than the original (which just states that the LHS is composite) since it sets it up for the algebraic substitution, which in this problem works for any non-trivial factorization.<br>\nThen the key trick is making the substitution.  The substitution is non-obvious (requires some thought and trials) so I would suspect any non-reasoning model that has pass@1 has seen this problem in training.<br>\nThe rest is wrapping up the algebra, which is where the models seem to be struggling.</p>",
        "id": 515559685,
        "sender_full_name": "Ralph Furman",
        "timestamp": 1746124844
    },
    {
        "content": "<p>Actually, testing it out the performance is pretty similar.   With the original statement all LLMs get the trick quickly, though only Qwen3 explicitly reasons its way there  (<a href=\"https://sugaku.net/qna/04280798-5121-492e-a5c3-d1226d6d6f66/\">see here</a>).<br>\nRephrasing in terms of n not being prime (and removing putnam_1988_b1 from the name) they <a href=\"https://sugaku.net/qna/62bdc116-0ae7-4c0a-9936-bb9442d7564c/\">mostly all</a> reason through it and get it right (Llama 4 fails)</p>",
        "id": 515591276,
        "sender_full_name": "Ralph Furman",
        "timestamp": 1746137871
    }
]