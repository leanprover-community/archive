[
    {
        "content": "<p>Let OTDOTC = \"open training data, open training weight\" ; ex. excludes OpenAI, DeepMind, Anthropic, Llama; as well as their fine tunes</p>\n<p>Let's also go ahead and exclude the geometry IMO problems, as I believe they are solved via (procedure for adding points, decision procedure.)</p>\n<ol>\n<li>subject to the above constraints, I'm curious if there is anything that can solve &gt; 50% of { lean4 formalized, non-geometry } IMO problems</li>\n<li>basically I'm looking for a system I can train + run end to end myself and that can solve some portion of the non-geometry IMO problems</li>\n</ol>\n<p>I expect this to be easier than training a generic foundation model, as miniF2F dataset &lt;&lt; all of internet.</p>\n<p>Context: I'm curious if hobbyists, outside of the top math-super-intelligence labs, can build mini-versions of these solvers on their own. In particular, I think this tech is useful for guiding code synthesis;<br>\ni.e. if<br>\nvibe coding = \"english input; maybe correct code output\" and<br>\nhoogle / loogle = \"type sig input; find def w/ type sig\"<br>\nthen maybe this can help build<br>\ninput = formal spec of input/output conditions<br>\noutput = code that satisfies formal conditions</p>",
        "id": 560889985,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764399821
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/any.20.22open.20training.20data.3B.20open.20training.20code.22.20IMO.20solvers.20.3F\">#general &gt; any \"open training data; open training code\" IMO solvers ?</a> by <span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span>.</p>",
        "id": 560898034,
        "sender_full_name": "Notification Bot",
        "timestamp": 1764407535
    },
    {
        "content": "<p>Maybe check out <a href=\"https://github.com/lean-dojo/ReProver\">Reprover</a>. It's a ByT5 model with weights on <a href=\"https://huggingface.co/kaiyuy/leandojo-lean4-tacgen-byt5-small\">Hugging Face</a> and the dataset can be found <a href=\"https://zenodo.org/records/12740403\">here</a> (its basically a dict of pointers into Mathlib commit <code>29dcec074de168ac2bf835a77ef68bbe069194c5</code>). You might also be interested in <a href=\"https://huggingface.co/AI-MO/Kimina-Prover-72B\">Kimina-Prover</a> with various <a href=\"https://huggingface.co/collections/AI-MO/kimina-prover\">smaller versions</a>, but I haven't had any experience with it yet.</p>",
        "id": 560925409,
        "sender_full_name": "Gerben Koopman",
        "timestamp": 1764431820
    },
    {
        "content": "<p>(Warning, shameless self plug ahead haha) You could also check out <a href=\"https://github.com/gerbenkoopman/leanreinforcement\">Lean Reinforcement</a>. It's basically intended to be an mcts wrapper of the ReProver model, with a custom-trained value-head. It's still in development, but last Sunday I got a full end-to-end successful run on the cluster used. Sadly they are currently undergoing maintenance, but once it's back online I hope to  do a full run with proof parallelization implemented (current parallelization in the last 4 commits is <em>not</em> that).</p>",
        "id": 560925752,
        "sender_full_name": "Gerben Koopman",
        "timestamp": 1764432094
    },
    {
        "content": "<p>By the time that I have something more concrete I might post something, for now it is very much early days. Of course models like HyperTree or AlphaProof take much of the same ideas with better / more efficient implementation.</p>",
        "id": 560925871,
        "sender_full_name": "Gerben Koopman",
        "timestamp": 1764432192
    },
    {
        "content": "<p>My very limited understanding of AlphaGo / MCTS is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Cell</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">White</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Black</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Empty</span>\n<span class=\"n\">BoardState</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[[</span><span class=\"n\">Cell</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"mi\">19</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"mi\">19</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>ideally, we want a function <code>evalFn : BoardState -&gt; f32 </code> (having it would tell us best next move)<br>\nwe don't have such a fn, but we lean a NN approximation of it via lots of MCTS self play</p>\n<p>Questions:</p>\n<ol>\n<li>is the core of these non-geometry IMO provers \"just merely\" MCTS applied to proof states &amp; scaled up ?</li>\n<li>BoardState is always fixed size; an Lean4 ProofState however, might have arbitrary number of hypothesis, each themself which might be arbitrarily long; how is \"ProofState\" represented in the mcts provers ?</li>\n</ol>",
        "id": 560935150,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764440880
    },
    {
        "content": "<p>There is something else I am misunderstanding here.</p>\n<ol>\n<li>ByT5 refers to <a href=\"https://arxiv.org/abs/2105.13626\">https://arxiv.org/abs/2105.13626</a> right ?</li>\n<li>To the best of my knowledge, ByT5 is a normal LLM model, with tokenizer replaced with just processing the raw bytes.</li>\n<li><a href=\"https://github.com/lean-dojo/ReProver\">https://github.com/lean-dojo/ReProver</a> then states \"Our tactic generator is a <a href=\"https://huggingface.co/docs/transformers/model_doc/byt5\">ByT5</a> model finetuned to generate tactics given a proof state.\"</li>\n<li>(3) confuses me because -- why is the world knowledge used in ByT5 useful for <strong>generating Lean tactics</strong> ? [I expect only a tiny fraction of ByT5 training data involves Lean tactics, and knowing things like the various capitals of states/countries in the world to be useless for Lean tactics]</li>\n</ol>\n<p>I don't know what I am misunderstanding, but clearly I am getting something wrong as I hold a set of self-contradictory beliefs. What am I fundamentally misunderstanding ?</p>\n<p>Thanks!</p>",
        "id": 560936204,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764441859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1001511\">TongKe Xue</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/any.20.22open.20training.20data.3B.20open.20training.20code.22.20IMO.20solvers.20.3F/near/560935150\">said</a>:</p>\n<blockquote>\n<p>Questions:</p>\n<ol>\n<li>is the core of these non-geometry IMO provers \"just merely\" MCTS applied to proof states &amp; scaled up ?</li>\n<li>BoardState is always fixed size; an Lean4 ProofState however, might have arbitrary number of hypothesis, each themself which might be arbitrarily long; how is \"ProofState\" represented in the mcts provers ?</li>\n</ol>\n</blockquote>\n<p>So to first answer these questions, in short, no. The idea is I guess twofold.</p>\n<p>Firstly, the LLMs are basically good enough at string generation that they can be used as tactic generators. Nothing in this setup yet forces legal tactics(/moves/actions). This is then applied to the Lean interface (LeanDojo/REPL/Lean Interact/etc), where it is checked to be valid. Now you could stop there. If the LLM is good enough, it will iteratively provide tactics to further the proof state until complete.</p>\n<p>However, the second idea is that you can do something a bit more elaborate. AlphaProof, for example. Instead of feeding the tactic straight into the Lean interface, and discarding a proof if you went down a wrong branch, you keep several branches with this mcts algorithm from reinforcement learning. This way you have more chances to find a correct proof (though this is slightly vacuous, as you also use correspondingly more compute). Importantly, however, you smartly save results from used compute as nodes in your tree. Finally, a bit more on the training/engineering side, by doing this you also generate much richer data that you could later train on again. Either a value head as you need in certain mcts implementations, the tactic generator LLM, or your whole set-up if you like.</p>\n<p>Regarding board size, we don't have to know it in this case. For Chess or Go you need to simulate an opponents actions and board value, but with Lean you only need succes/failure/finished/error. That way we can decide a max number of nodes in our tree, or set a max compute time, and let the model explore as long as it likes within those constraints. 'Moving off' the board is not a thing here.</p>",
        "id": 561136106,
        "sender_full_name": "Gerben Koopman",
        "timestamp": 1764589519
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1001511\">TongKe Xue</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/any.20.22open.20training.20data.3B.20open.20training.20code.22.20IMO.20solvers.20.3F/near/560936204\">said</a>:</p>\n<blockquote>\n<ol>\n<li>ByT5 refers to <a href=\"https://arxiv.org/abs/2105.13626\">https://arxiv.org/abs/2105.13626</a> right ?</li>\n<li>To the best of my knowledge, ByT5 is a normal LLM model, with tokenizer replaced with just processing the raw bytes.</li>\n<li><a href=\"https://github.com/lean-dojo/ReProver\">https://github.com/lean-dojo/ReProver</a> then states \"Our tactic generator is a <a href=\"https://huggingface.co/docs/transformers/model_doc/byt5\">ByT5</a> model finetuned to generate tactics given a proof state.\"</li>\n<li>(3) confuses me because -- why is the world knowledge used in ByT5 useful for <strong>generating Lean tactics</strong> ? [I expect only a tiny fraction of ByT5 training data involves Lean tactics, and knowing things like the various capitals of states/countries in the world to be useless for Lean tactics]</li>\n</ol>\n</blockquote>\n<p>For these questions, let's do them one by one.</p>\n<ul>\n<li>\n<p>Yes, that's the ByT5 model I mean.</p>\n</li>\n<li>\n<p>Yes, ByT5 is in that sense a normal LLM. The question is implicit I guess, but we'll get there in point 4 <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>\n</li>\n<li>\n<p>(This is not really a question either.)</p>\n</li>\n<li>\n<p>Indeed, it carries facts as a side effect of the thing we care about; knowledge of the English language, how words are formed, and what they mean. Think of all the theorems and tactics that behave roughly like English. That sounds a bit flippant, but algorithms need to be pedantic afterall. When we finetune for Mathlib, we don't have to first teach the model English, saving compute. [And this is a huge tangent, but it might also save the creation of certain types of attention heads, <a href=\"https://transformer-circuits.pub/2022/in-context-learning-and-induction-heads/index.html\">see here</a>]. Finally, why ByT5 and not another LLM? Because byte encoding allows us to nicely capture Lean symbols such as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∃</mi></mrow><annotation encoding=\"application/x-tex\">\\exists</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∃</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>→</mo></mrow><annotation encoding=\"application/x-tex\">\\to</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">→</span></span></span></span>, etc.</p>\n</li>\n</ul>\n<p>Final note, I'm not sure how much knowledge is still in the ByT5 model after finetuning. I suspect very little compared to the original ByT5. But this is beside the point I guess.</p>",
        "id": 561137767,
        "sender_full_name": "Gerben Koopman",
        "timestamp": 1764590019
    },
    {
        "content": "<p>Thank you for your detailed posts. I found them quite instructive. I want to focus on one thing in particular: How do we generate tactics to send Lean4 ?</p>\n<p>I still find using LLMs for this a bit counter intuitive (given how much structure there is in a lean expr tactic, it's not only an AST like Lisp code, but it's a <strong>typed</strong> AST, with <strong>dependent types</strong>, and we're throwing all that away and telling a LLM trained on reddit threads: hey, try to generate this for us.)</p>\n<p>But to steelman the existing tech, based on your description, it goes something like this right:</p>\n<ol>\n<li>Use ByT5 is trained on reddit posts, shopify pages, SEO spam, ... but in doing so, it learns certain primitive functions/procedures, and this part is expensive, and we don't want to do it ourselves.</li>\n<li>During the finetune phase, we feed it so much lean4 tactics / springer math books, that it's basically a lobotomy, where it keeps the basic \"primitive funcs/procedures\", and has all the knowledge replaced with math/lean4 tactics.</li>\n<li>This is the current best way to generate Lean4 tactics ?</li>\n</ol>\n<p>I think the natural followup to this is:</p>\n<ol>\n<li>What exactly are the data we use to finetune ByT5 ?</li>\n<li>How do we get Lean4 training data? Is it via running all the existing Lean4 proofs, after every tactic, recording the (hypothesis, goal)-state along with the tactic applied ?</li>\n</ol>\n<p>Lastly, using the word \"crutch\" non-offensively here, is this whole \"LLM generates tactic\" a bit of a crutch in that (1) we don't have anything better, (2) we don't really know how to train this, so (3) we just throw away lots of structure, looking at the hyopthesis/goal/tactic as just \"merely strings\", and feed it to the LLM, hoping for the best ?</p>",
        "id": 561190583,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764602335
    },
    {
        "content": "<p>My pleasure. I'm glad you find it helpful <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>\n<p>As for types and AST, it's a bit complex, and there certainly have been smart people doing smart stuff, but I don't recall everything I've read. IIRC there was one paper that explicitly used the whole Lean metadata that you get in the infoview (and maybe more, e.g. with ASTs). I'll post a link when I find/remember it.</p>\n<p>Similarly there are also other approaches that integrate certain hypothesis into the model structure. E.g. <a href=\"https://arxiv.org/pdf/2401.02949\">Graph2Tac</a> is a nice example I think, give it a read for graph neural nets used for Lean.</p>\n<p>As for throwing away the things we learned on reddit etc., that really is just junk to us. We only care about the embedding space that comes with ByT5 pretrained. When we finetune on Mathlib proofs, the LLM starts learning these tactic names.</p>\n<p>As for an explicit example of how that might work, let's take ReProver (which I'm most familiar with). You pass it the theorem's full statement, up to the  <code>:= by</code> part, and it embeds it into a vector space via an encoder-style transformer. Then, this vector that we get is used to rank all accessible premises (definitions, theorems, etc.) to retrieve the top-k of these. Next, we pass the theorem statement + these top k retrieved premises to the encoder-decoder transformer to generate a tactic. If you are familiar with the term in-context learning, we are basically giving the encoder-decoder in-context info on premises (anyone please correct me if this intuition I have here is wrong). This model generates our full tactic to apply.</p>\n<p>To answer your numbered questions:</p>\n<ol>\n<li>Yes, it is trained on whatever, and we'll piggyback that embedded language understanding for our own purposes. When choosing between pre-trained or random initialization, ByT5 sounds pretty good <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> (to be clear, models such as AlphaProof doubtless train from scratch, but then everything is in-house and purpose built. Different team sizes, different solutions.)</li>\n<li>We usually feed it Lean proofs (+ potential synthetic data), as Springer textbooks are almost never formal. Though I can perhaps be proven wrong on this. Maybe there are smart tricks for using non-formal proofs. If you have an auto-formalizer, then things really kick off for data generation and training. Don't have any experience there yet though. For knowledge, yeah. I know I mentioned knowledge/memory earlier, but I should really be careful with those terms in LLMs. It's very much the gray-matter of any transformer, and understanding it or trying to anthropomorphize [I just realized why the company is called that! hahah] it can be counterproductive. There is plenty of interesting research into the memory of LLMs though, and the difference between reproduction and originality.</li>\n<li>I dare not say. All I can say is, for AI, scale=good and freedom=good (in the sense of freedom for the model to learn arbitrary connections), but freedom requires scale. So in practice, if we want better models, transformers are the current way to go. Due to data restrictions in this field though, some priors (such as the premise retrieval, graph nn, etc.) are beneficial. I guess best needs to be defined more precisely anyway.</li>\n</ol>\n<p>Sorry, the post is getting long. Let me re-read and I'll answer the second part.</p>",
        "id": 561223086,
        "sender_full_name": "Gerben Koopman",
        "timestamp": 1764608802
    },
    {
        "content": "<p>For your other two questions, I would just recommend reading either the <a href=\"https://github.com/lean-dojo/ReProver\">paper</a> or <a href=\"https://leandojo.org/\">website</a> of ReProver. They explain how the trained it, and precisely what on.</p>",
        "id": 561225576,
        "sender_full_name": "Gerben Koopman",
        "timestamp": 1764609359
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"878646\">Gerben Koopman</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/any.20.22open.20training.20data.3B.20open.20training.20code.22.20IMO.20solvers.20.3F/near/561223086\">said</a>:</p>\n<blockquote>\n<p>As for an explicit example of how that might work, let's take ReProver (which I'm most familiar with). You pass it the theorem's full statement, up to the <code>:= by</code> part, and it embeds it into a vector space via an encoder-style transformer. Then, this vector that we get is used to rank all accessible premises (definitions, theorems, etc.) to retrieve the top-k of these. Next, we pass the theorem statement + these top k retrieved premises to the encoder-decoder transformer to generate a tactic. If you are familiar with the term in-context learning, we are basically giving the encoder-decoder in-context info on premises (anyone please correct me if this intuition I have here is wrong). This model generates our full tactic to apply.</p>\n</blockquote>\n<ol>\n<li>\n<p>This is where the \"Retrieval-Augmented\" part of \"Retrieval-Augmented Theorem Provers for Lean\" comes from ?</p>\n</li>\n<li>\n<p>Is this literal euclidean / cosine distance, or is there something smarter going on. I 100% believe your claim that this is how ReProver works, but the fact </p>\n</li>\n</ol>\n<blockquote>\n<p>You pass it the theorem's full statement, up to the <code>:= by</code> part, and it embeds it into a vector space via an encoder-style transformer. Then, this vector that we get is used to rank all accessible premises (definitions, theorems, etc.) to retrieve the top-k of these. Next, we pass the theorem statement + these top k retrieved premises to the encoder-decoder transformer to generate a tactic.</p>\n</blockquote>\n<p>works at all is astonishing to me (because of how \"lossy / imprecise / nothing like a compiler-stage\" each step of this is.</p>",
        "id": 561225946,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764609437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"878646\">Gerben Koopman</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/any.20.22open.20training.20data.3B.20open.20training.20code.22.20IMO.20solvers.20.3F/near/561225576\">said</a>:</p>\n<blockquote>\n<p>For your other two questions, I would just recommend reading either the <a href=\"https://github.com/lean-dojo/ReProver\">paper</a> or <a href=\"https://leandojo.org/\">website</a> of ReProver. They explain how the trained it, and precisely what on.</p>\n</blockquote>\n<p>Will do, thanks for your explainations. I think I now have enough \"high level context\" of how this is meant to work. Thanks again!</p>",
        "id": 561226196,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764609492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1001511\">TongKe Xue</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/any.20.22open.20training.20data.3B.20open.20training.20code.22.20IMO.20solvers.20.3F/near/561190583\">said</a>:</p>\n<blockquote>\n<p>Lastly, using the word \"crutch\" non-offensively here, is this whole \"LLM generates tactic\" a bit of a crutch in that (1) we don't have anything better, (2) we don't really know how to train this, so (3) we just throw away lots of structure, looking at the hyopthesis/goal/tactic as just \"merely strings\", and feed it to the LLM, hoping for the best ?</p>\n</blockquote>\n<p>The last part is a bit hard for me to judge, but I think we shouldn't discount the value of a good LLM. After all, much of the inspiration for using LLMs is that they are pretty good guiding agents according to experience. E.g. ask it to prove an undergraduate result and it can probably give you a reasonable idea. Maybe there are better ways, but hence the research.<br>\nAnd I do seem to remember some paper explicitly using all these rich signals, but I simply can't think of the source right now.</p>",
        "id": 561226967,
        "sender_full_name": "Gerben Koopman",
        "timestamp": 1764609654
    },
    {
        "content": "<p>Basically yes to both the retrieval augmented and the distance (not sure of the metric right now but probably dot product). As for lossy, I guess so. Interactive self-play kind of let's the agent explore these structures itself though, like I mentioned for mcts. But this can also be done with ppo for example.</p>",
        "id": 561227538,
        "sender_full_name": "Gerben Koopman",
        "timestamp": 1764609784
    },
    {
        "content": "<p>If you're not already, check this out.   The progress is astounding 11 days in on a 4 month comp with large prize (for kaggle) -  though they may have made the questions too easy.</p>\n<p><a class=\"stream-topic\" data-stream-id=\"219941\" href=\"/#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Kaggle.2C.2038.2F50.20already.20via.20open.20models.2C.20.242M.20prize.20fund/with/561250531\">#Machine Learning for Theorem Proving &gt; Kaggle, 38/50 already via open models, $2M prize fund</a></p>",
        "id": 561250833,
        "sender_full_name": "Deleted User 968128",
        "timestamp": 1764615243
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"878646\">@Gerben Koopman</span> :</p>\n<p>Two followups:</p>\n<ol>\n<li>\n<p>I could not find a separate ReProver paper. Is <a href=\"https://arxiv.org/pdf/2306.15626\">https://arxiv.org/pdf/2306.15626</a> (the LeanDojo paper; section 5) the best description of ReProver ?</p>\n</li>\n<li>\n<p>Is there a benchmark somewhere of ReProver vs any of the IMO gold medals? (unreleased OpenAI, gemini, Harmonic, recent DeepSeek v2) ; I'm curious how this compares vs SOTA. The LeanDojo paper makes a comparison vs GPT4, but that is a few generations behind SOTA.</p>\n</li>\n</ol>\n<p>Thanks!</p>",
        "id": 561277552,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764624288
    },
    {
        "content": "<p>Yeah sorry that wasn't entirely clear. That is indeed the right paper. LeanDojo is the gym-like for ReProver. As for the benchmark, not that I'm aware of. And I don't think ReProver compares to SOTA anymore.</p>",
        "id": 561337703,
        "sender_full_name": "Gerben Koopman",
        "timestamp": 1764659164
    },
    {
        "content": "<p>This was a very instructive discussion (measured by the number of technical beliefs you changed my views on). Thank you for your time. Cheers!</p>",
        "id": 561350747,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764664441
    }
]