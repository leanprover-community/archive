[
    {
        "content": "<p>I've been wondering about this for a while now: to what extent can the task of automated theorem proving be interpreted as a task in program synthesis? The vast majority of Lean theorems are proven using tactics, which are metaprograms operating on the proof state (specifically, in Lean's <code>MetaM</code> monad). Could the task of general automated theorem proving be framed as one of synthesizing a provably correct <code>MetaM</code> program (i.e. sequence of tactics) that brings the proof state from some initial state, consisting of the initial goal (originating from the theorem's annotated type), to a final state where all goals have been solved?</p>\n<p>One obvious benefit of this approach could be that, in the context of program correctness, the task of automated proving is provided with the stateful semantics of metaprograms in the form of tactic specifications. The AI agent is <em>entirely aware</em> of the effect that different tactics have on the proof state, and effectively solves the problem of \"tactic selection\" (analagous to premise selection) to narrow down the search space of possibly applicable tactics given the current proof state. This is could improve on techniques used by other AI agents such as AlphaProof, which (as far as I understand) develop some notion of the effect of tactics through repeated trial and error -- though I'm not 100% sure it's enough to \"close the gap\" between the automation offered by proof assistants and the more haphazard nature of AI agents, that operate largely by \"throwing stuff at the wall to see what sticks\" and making incremental progress towards a goal in that way.</p>\n<p>I'm not sure exactly what the \"shortest path\" to this dream could be. But one thing that seems pretty clear to me is that, sooner or later, we'll have to start writing tactic specifications. Though I don't necessarily envision a grand effort to specify every Lean tactic that has ever been written. We'll probably want to start with a few simpler tactics, just enough the \"flesh out\" the definitions, tooling, etc. for specifying tactics -- some of what's already been done in Lean4Lean will very likely be relevant here. Then, we could maybe attempt to train an AI to do some kind of \"specification inference\" on other tactics. Or instead, perhaps, in attemting to synthesize tactic sequences for proving theorems from an initial, very limited set of tactics, alight upon probable specifications for certain \"highly desired\" tactics towards which we can direct program synthesis for constructing the tactics themselves (i.e. \"tactic synthesis\").</p>\n<p>Thoughts?</p>",
        "id": 521435152,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1748691694
    },
    {
        "content": "<p>Another thing I've been thinking about: when proving the correctness of these metaprograms in solving goals, it may be very useful to assume a large set of axioms that make the task of program synthesis easier. Some of these axioms may be unsound, but still useful in setting up the proper proof state for directing program synthesis. We could perhaps also have some basic safeguards to ensure that this unsoundness isn't exploited. The kicker: even if the proof of correctness of a metaprogram is based on unsound foundations, it still may produce a proof term that is correct in the original theory (with no reliance on the axioms that were used to prove the program correct).</p>",
        "id": 521437263,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1748693435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"373814\">Rish Vaishnav</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Automated.20theorem.20proving.20as.20program.20synthesis.3F/near/521435152\">said</a>:</p>\n<blockquote>\n<p>Or instead, perhaps, in attemting to synthesize tactic sequences for proving theorems from an initial, very limited set of tactics, alight upon probable specifications for certain \"highly desired\" tactics towards which we can direct program synthesis for constructing the tactics themselves (i.e. \"tactic synthesis\").</p>\n</blockquote>\n<p>To elaborate a bit further on this: I can imagine a \"sorry tactic\" that operates on the meta level, where the effect of the tactic is specified in stateful preconditions and postconditions, which the AI agent can insert when it \"gives up\" on trying to find an applicable tactic. The postconditions of the tactic represent the AI's \"guess\" at what the next proof state should be. This effectively opens up this approach to the Draft-Sketch-Prove strategy. Applying the AI across many different theorems, we could possibly identify common patterns in the sorry tactics that it inserts, and determine an encompassing tactic specification that we send to a program synthesizer. If the synthesizer fails, then there's a good chance that we <em>can't</em> design a program satisfying the specification, which signals to the AI to try to find a different one, or possibly take another step back and change the specifications/instances of the sorry tactics themselves.</p>",
        "id": 521443392,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1748698623
    },
    {
        "content": "<p>Or rather, the sorry tactic I have in mind would be more like a generalized version of the <code>sorry</code> tactic we already have. While the existing <code>sorry</code> tactic always takes you to the \"current subgoal completed\" state, this generalized <code>sorry' [state]</code> tactic would take as its argument the <em>exact next <code>MetaM</code> state</em> to transition to (not pre- and postconditions as I said above). After writing the sketches for a set of theorems, the AI would then go over all of the instances of <code>sorry'</code>, look at the states before and after running them, and perform some kind of \"clustering\" on them followed by an attempt to come up with a tactic specification (i.e. Hoare Triple, that is, the preconditions and postconditions) of a tactic that covers all of them. This triple is then input to a program synthesizer. And if at any point we fail, we can backtrack to each of the previous steps, retrying in turn the specification synthesis, clustering, or initial tactic proof sketching.</p>",
        "id": 521446719,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1748701424
    },
    {
        "content": "<p>Coming back here to contradict myself yet again. I think that some of what I was getting at with the <code>sorry' [state]</code> tactic above is in fact quite general to the problem of program synthesis, not specific to synthesizing tactic sequences. Let me try to lay things out quite explicitly here.</p>\n<p>Suppose we have a program with a \"monadic hole\" <code>?X</code>:</p>\n<p><code>F = A &gt;&gt;= fun a =&gt; ?X a &gt;&gt;= fun x =&gt; B a x</code></p>\n<p>We are trying to synthesize <code>F</code> such that it obeys the specifications <code>{F1} F {F2}</code> (using Hoare triple syntax, where <code>{P} R {fun r =&gt; Q r}</code> means that under the stateful precondition <code>P</code>, the return value (bound by <code>r</code>) and resulting state of running <code>R</code> satisfies the postcondition <code>Q</code>).<br>\nSuppose that we already have a proof of <code>{F1} A {fun a =&gt; A2 a}</code> and <code>∀ a x, {B1 x} B a x {F2}</code>.<br>\nIt sufficies to find some program <code>M</code> to fill in the hole such that <code>∀ a, {A2 a} M a {B1 a}</code>, but we can do better than that -- we can try to find <code>M</code> satisfying the spec <code>{M1 a} M a {M2 a}</code> with weaker preconditions (such that <code>A2 a</code> implies <code>M1 a</code>) and stronger postconditions (such that <code>M2 a</code> implies <code>B1 a</code>).<br>\nI did a small formalization of this using the <a href=\"https://github.com/sgraf812/mpl\">new monadic program logic library</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">MPL</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PostShape</span><span class=\"bp\">.</span><span class=\"n\">arg</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">PostShape</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"o\">)</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">F1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Assertion</span><span class=\"w\"> </span><span class=\"n\">ps</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">F2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PostCond</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">ps</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">A2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PostCond</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">ps</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">B1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PostCond</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">ps</span>\n\n<span class=\"c1\">-- suppose `A` and `B` are programs with known specs</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">StateM</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">StateM</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">hA</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">F1</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">A2</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">⦄</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">hB</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">⦃(</span><span class=\"n\">B1</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">F2</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">⦄</span>\n\n<span class=\"c1\">-- code sketch; `X` is a hole</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">StateM</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"c1\">-- the hole spec must \"slot into\" the postcondition of `A` and the precondition of `B`</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hF</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">StateM</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">A2</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B1</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">⦄)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">F1</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">F2</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">F</span>\n<span class=\"w\">  </span><span class=\"n\">mintro</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"n\">mspec</span><span class=\"w\"> </span><span class=\"n\">hA</span>\n<span class=\"w\">  </span><span class=\"n\">mspec</span><span class=\"w\"> </span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">r'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">mspec</span><span class=\"w\"> </span><span class=\"n\">hB</span><span class=\"w\"> </span><span class=\"n\">r'</span><span class=\"w\"> </span><span class=\"n\">r</span>\n\n<span class=\"c1\">-- now, suppose we can synthesize `M1` and `M2` such that:</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">M1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Assertion</span><span class=\"w\"> </span><span class=\"n\">ps</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">M2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PostCond</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">ps</span>\n<span class=\"c1\">-- M1 is a weaker precondition</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hM1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A2</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊢ₛ</span><span class=\"w\"> </span><span class=\"n\">M1</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"c1\">-- M2 is a stronger postcondition</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hM2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M2</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊢ₚ</span><span class=\"w\"> </span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B1</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- we try to synthesize `M` such that:</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">StateM</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">hM</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">M1</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">M2</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">⦄</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">F1</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">F2</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">hF</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">mintro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">mwp</span>\n<span class=\"w\">  </span><span class=\"n\">mspec</span><span class=\"w\"> </span><span class=\"n\">hM</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hM2</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hM1</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>In order to arrive at a general subroutine <code>M</code> that we can use elsewhere in our code, we'd want the preconditions to be as weak as possible, and postconditions to be as strong as possible. That might be one of the main challenges here. The \"clustering\" scheme I talked about above of grouping similar hole specs together, comparing their similarities and then arriving at a general spec to encompass all of them might be one way to go about this.</p>\n<p>Anyways, this is just something I wanted to write down for myself/throw into the ether and possibly return to a bit later on. If anyone found my monologue intriguing, or knows of any existing work that goes in this direction, please do let me know!</p>",
        "id": 521589974,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1748805096
    },
    {
        "content": "<p>This work uses GenAI for Program Synthesis (in F*)<br>\n<a href=\"https://arxiv.org/pdf/2405.01787\">https://arxiv.org/pdf/2405.01787</a></p>",
        "id": 521716321,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1748862768
    }
]