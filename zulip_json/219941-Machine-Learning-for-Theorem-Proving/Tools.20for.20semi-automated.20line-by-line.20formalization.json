[
    {
        "content": "<p>This is a spinoff of a thread <a class=\"stream-topic\" data-stream-id=\"458659\" href=\"/#narrow/channel/458659-Equational/topic/Alternative.20proofs.20of.20E1689.E2.8A.A2E2/with/517189582\">#Equational &gt; Alternative proofs of E1689âŠ¢E2</a> in the Equational Theories Project.  In that thread, I <a href=\"https://www.youtube.com/watch?v=cyyR7j2ChCI\">posted a recording</a> I made of formalizing a <a href=\"#narrow/channel/458659-Equational/topic/Alternative.20proofs.20of.20E1689.E2.8A.A2E2/near/517189582\">20-30 line informal proof</a> of one of the implications in the project into Lean in a semi-automated and mostly mechanical \"line-by-line\" fashion, in which I (with the assistance of Github Copilot) translated each line of the informal proof to a couple lines of Lean (with sorries), and then relied on finishing tactics like <code>exact?</code> and <code>canonical</code> to try to fill each sorry, turning to manual simplification of these subgoals with tactics (most notably <code>convert</code>) if the automated tools did not work.  As one can see in the video, the full formalization took 33 minutes, or roughly one and a half minutes per line (I did not attempt to precisely define what a \"line\" is in this context, so this is an extremely approximate estimate).</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"cyyR7j2ChCI\" href=\"https://www.youtube.com/watch?v=cyyR7j2ChCI\"><img src=\"https://uploads.zulipusercontent.net/0e5c80efbd7c87269bd3e04884f14b4765b18460/68747470733a2f2f692e7974696d672e636f6d2f76692f63797952376a32436843492f6d7164656661756c742e6a7067\"></a></div><p>I am curious to hear of other tools that might be suitable for this type of formalization task, where a relatively detailed informal proof already exists, to the point where each line can be formalized mostly mechanically, without significant knowledge of the broader proof strategy or context required, and where library search is not the bottleneck (this proof did not use any Mathlib lemmas other than tactics).  I chose Github Copilot and canonical because I was already familiar with the former and curious about the latter, and both tools were easily integrated into my IDE (VSCode on Windows), but perhaps there are other workflows (e.g., using other modes of Copilot or similar tools than simply autocompletion of text at the cursor location) that would be worth testing out here.</p>",
        "id": 517582936,
        "sender_full_name": "Terence Tao",
        "timestamp": 1747063424
    },
    {
        "content": "<p>If you want to go beyond autocomplete and try letting the LLM attempt to prove some of the goals, my <a href=\"https://github.com/GasStationManager/LeanTool\">LeanTool</a> is worth trying. It exposes the feedback from Lean to the LLM, to allow it to fix its errors interactively. Works with most LLMs and most coding assistants. Some of the current LLMs are worth trying, e.g. Claude Sonnet, Gemini-2.5, and DeepSeek. However, most LLMs don't know about Canonical (or some of the most recent Lean tools), so will need to be prompted into using it. Then it depends on how well the LLM is able to follow prompt instructions...</p>\n<p>Another workflow to try: ask the LLM to read the document containing the informal proof, then ask it to formalize it into Lean, perhaps initially with sorrys for the subgoals. I don't know if it will work well for this domain, but doesn't hurt to try. This could be done in an interactive coding assistant like Cursor with agent mode, or something less interactive like Claude Code. Both supports using LeanTool.</p>",
        "id": 517638482,
        "sender_full_name": "GasStationManager",
        "timestamp": 1747076988
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span> Have you tried benchmarking any LLMs using LeanTool?</p>",
        "id": 517656461,
        "sender_full_name": "Justin Asher",
        "timestamp": 1747081981
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"780541\">@Justin Asher</span> I have not tried it with the math proof benchmarks. But if anyone is interested in how the current LLMs are doing, and has a bit of budget to spend on API costs,  I'm happy to collaborate!</p>",
        "id": 517669333,
        "sender_full_name": "GasStationManager",
        "timestamp": 1747085576
    },
    {
        "content": "<p>I made a second video in which I showed the previously informal and formal proofs to both Claude and o4, and then asked them to formalize a second informal proof of the same result that <span class=\"user-mention\" data-user-id=\"773643\">@Bruno Le Floch</span> had also contributed: <a href=\"https://www.youtube.com/watch?v=zZr54G7ec7A\">https://www.youtube.com/watch?v=zZr54G7ec7A</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"zZr54G7ec7A\" href=\"https://www.youtube.com/watch?v=zZr54G7ec7A\"><img src=\"https://uploads.zulipusercontent.net/ee2c1aeb6ed93b07173e2bbffd2c02ad91afb614/68747470733a2f2f692e7974696d672e636f6d2f76692f7a5a7235344737656337412f6d7164656661756c742e6a7067\"></a></div>",
        "id": 517743262,
        "sender_full_name": "Terence Tao",
        "timestamp": 1747116097
    },
    {
        "content": "<p>I found Gemini 2.5 Pro to be extremely helpful at writing Lean metaprogramming code involving data extraction. I know this is not quite the same, but the underlying theme was that when provided with the appropriate <strong>context</strong>, the model is extremely capable of figuring out how to produce the desired code. All it took was a few attempts at feeding the compiler errors back to it before the code was worked out.</p>\n<p>Context was extremely important here: Gemini would often hallucinate if you did not provide it with the source files. Thankfully, it has an extremely large context window, so you can input almost as much as you would like (not considering costs). This is something Noam Shazeer and Jeff Dean have talked about trying to build: being able to put an entire code base into the context window of an LLM (for instance, all of Mathlib + Lean).</p>\n<p>Hence, I want to take a model like Gemini and provide it with appropriate <a href=\"https://www.leanexplore.com/\">search tools</a> along with compiler / Lean feedback (similar to LeanTool <span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span> ). Then, the LLM can query the environment and figure out how to best formalize and prove given statements on its own, using the feedback as guidance.</p>\n<p>I think this would be able to do most of the tasks you asked of Claude and ChatGPT to do.</p>",
        "id": 517749092,
        "sender_full_name": "Justin Asher",
        "timestamp": 1747118626
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span>, <span class=\"user-mention\" data-user-id=\"436568\">@Josh Clune</span> and I tried <a href=\"https://drops.dagstuhl.de/storage/00lipics/lipics-vol309-itp2024/LIPIcs.ITP.2024.10/LIPIcs.ITP.2024.10.pdf\">Duper</a> on your example. The experiment is here:<br>\n<a href=\"https://github.com/avigad/EquationalTest\">https://github.com/avigad/EquationalTest</a><br>\n<a href=\"https://github.com/avigad/EquationalTest/blob/main/EquationalTest/Basic.lean\">https://github.com/avigad/EquationalTest/blob/main/EquationalTest/Basic.lean</a><br>\nWe are pleased that not only does it easily prove each of the lemmas, but it even proves the theorem easily without the lemmas. (You can delete the definitions of <code>S</code> and <code>f</code> and all the lemmas from the file.) The proofs are inscrutable, but as far as verifying correctness, it does pretty well.</p>",
        "id": 518434166,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1747361577
    },
    {
        "content": "<p>Nice!  In the ETP we did solve some other implications of this sort using Duper, though it took some effort to then convert them to non-Duper proofs: <a class=\"stream-topic\" data-stream-id=\"458659\" href=\"/#narrow/channel/458659-Equational/topic/FINITE.3A.20The.20Lean.2BDuper.20implications/with/486375689\">#Equational &gt; FINITE: The Lean+Duper implications</a> </p>\n<p>In general saturation techniques worked pretty well for the positive implications in the ETP.  For instance Vampire was able to resolve this implication in 0.003 seconds: <a class=\"message-link\" href=\"/#narrow/channel/458659-Equational/topic/What.20are.20the.20hardest.20positive.20implications.20for.20an.20ATP.3F/near/484163714\">#Equational &gt; What are the hardest positive implications for an ATP? @ ðŸ’¬</a></p>",
        "id": 518443614,
        "sender_full_name": "Terence Tao",
        "timestamp": 1747366988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"780541\">Justin Asher</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Tools.20for.20semi-automated.20line-by-line.20formalization/near/517749092\">said</a>:</p>\n<blockquote>\n<p>Hence, I want to take a model like Gemini and provide it with appropriate <a href=\"https://www.leanexplore.com/\">search tools</a> along with compiler / Lean feedback (similar to LeanTool <span class=\"user-mention silent\" data-user-id=\"776090\">GasStationManager</span> ). Then, the LLM can query the environment and figure out how to best formalize and prove given statements on its own, using the feedback as guidance.</p>\n</blockquote>\n<p>I have created such a tool box as an MCP, which you can integrate with VSCode (agent mode) or Cursor:<br>\n<a href=\"https://github.com/oOo0oOo/lean-lsp-mcp\">lean-lsp-mcp</a></p>\n<p>It allows an LLM to interact with Lean, mainly via the language server protocol. E.g.:</p>\n<ul>\n<li>Query the proof goal or term goal at any position </li>\n<li>Access hover info (inline documentation) at any position</li>\n<li>Code completions: Find available identifiers or import suggestions</li>\n<li>Query <a href=\"http://leansearch.net\">leansearch.net</a> using natural language search</li>\n</ul>\n<p>I find this kind of context information allows the model to make better code suggestions.</p>\n<p>On a side note, I would be happy to include a tool to query <a href=\"http://leanexplore.com\">leanexplore.com</a> if you provide an API and are OK with it.</p>",
        "id": 518518760,
        "sender_full_name": "Oliver Dressler",
        "timestamp": 1747394541
    },
    {
        "content": "<p>Why were the Lean+Duper proofs called conjectures, and why was there a need to convert them to non-Duper proofs? Duper is not as powerful as Vampire, but its selling point is that it constructs Lean proof terms that are checked by Lean's kernel. In that sense, it is like using <code>simp</code>, <code>omega</code>, or <code>linarith</code>. Like those tools, however, the proof terms that Duper produces are large and not meant for human consumption. A strength of <code>canonical</code> is that it produces terms that are much more efficient.</p>",
        "id": 518545827,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1747402331
    },
    {
        "content": "<p>The objective of the Equational Theories Project was to formalize ~22 million implications/anti-implications (of which \"Equation 1689 implies Equation 2\" was an example) in a common formal framework.  Early on, we chose that framework to be Lean + Mathlib with no further packages.  It's true that we could have in principle switched over to Lean+Mathlib+Duper, but this might have been logistically complicated since all participants on the formalization side of the project have to use the same framework (also it may have complicated the mathlib bump process, and possibly also created issues with <code>leanchecker</code>).  See <a class=\"stream-topic\" data-stream-id=\"458659\" href=\"/#narrow/channel/458659-Equational/topic/Future.20of.20Using.20ATPs/with/475298037\">#Equational &gt; Future of Using ATPs</a>  for more discussion.</p>\n<p>As discussed in that thread, there was a similar issue involving proofs discovered using <code>egg</code>, which we had <a href=\"#narrow/channel/458659-Equational/topic/Adding.20the.20egg.20repository.20as.20a.20dependency\">temporarily added to the framework</a> but then later <a href=\"#narrow/channel/458659-Equational/topic/Adding.20the.20egg.20repository.20as.20a.20dependency/near/473352680\">decided</a> <a href=\"https://github.com/teorth/equational_theories/pull/190\">to remove</a>.  One could have perhaps replaced the <code>egg</code> or <code>duper</code> proofs with their Lean proof terms, but I think there were concerns on scaling this out to 22 million implications (actually in practice we only formalized a generating set of ~600,000 of them) while keeping the compilation time to a reasonable size. (As you mention, the proof terms generated by <code>canonical</code> are significantly shorter and so one could in principle have used <code>canonical</code> in the ETP, though perhaps only installed on forks of the project, with the proofs migrated after being converted into proof terms that would compile without <code>canonical</code>.)  (As an aside, <code>egg</code> <a href=\"#narrow/channel/458659-Equational/topic/Adding.20the.20egg.20repository.20as.20a.20dependency/near/474359913\">could also handle</a> the 1689=&gt;2 implication, with just one intermediate statement required.  We have many proofs of this fact now!  1689=&gt;2 is far from the most difficult implication/anti-implication in the ETP -- that honor goes to 1729 !=&gt; 255 (or the still unresolved 677=&gt;255 for finite magmas) -- but I think it serves as a good toy problem (at our current state of the art) to make apples-to-apples comparisons of various formalization strategies, as it is just complicated enough to be non-trivial, but not so hard that most of the current automated tools simply fail to make progress on it.)</p>\n<p>In the ETP we <a href=\"#narrow/channel/458659-Equational/topic/Lean.20script.20for.20extracting.20current.20set.20of.20implications/near/473366747\">needed a Lean keyword</a> (similar to <code>proof_wanted</code>) for results that had not yet been formalized within our chosen framework, but had been established by other means, e.g., Lean+Duper, Vampire, Z3, or an informal human written proof.   We decided to create a keyword <code>conjecture</code> for this (it won out over the competing proposals <code>claim</code> and <code>proof_wanted'</code>).  Because of this, we began informally referring to these results as 'conjectures\" in our project, even though technically most of them had actually met quite high standards of proof.  So for us, \"conjecture\" was an abbreviation for \"conjecture relative to the formal framework used for our project\".</p>\n<p>ADDED LATER: If you want to try a harder challenge than 1689=&gt;2 to test out Duper, <a href=\"https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAWQIYwBYBtgCMB0AVJAYxmEICgzD0kBnGxJAcxCTgApBG4DgC448BPMAFM4AfQCUcAO6ohUIWThwIYHnC6AkwnVwtHCsAB2AM2AAPbgDYArHABEcQOOkduAF4AfA2ZIcKikixY8gBucACiAI4ArijAEAbWAAzsAOK8AsJikgDayF5wyQC6PC5wgABEcKZw/HAAXmrJADQVrs1ObNVtbHVOppJO/OLifgHBYVExcQAskwAcKWmCIhJwOUws+UXcJeWV1XW8jc0llW0d7N3sJ7WDQ2RoQtBCIGPRJHGJoqBgmEI0ohGvWIGaZzNipPiLTIrXLrQrsVC8AETeJWJLJSSI8ZvYGzfLFOBYfiKOA0aBQfhAA\">one natural candidate is 650=&gt;448</a>, where <a href=\"https://github.com/teorth/equational_theories/blob/main/equational_theories/Generated/VampireProven/Proofs11.lean#L1878\">our current proof</a> is a long conversion of a Vampire proof (which <a href=\"#narrow/channel/458659-Equational/topic/What.20are.20the.20hardest.20positive.20implications.20for.20an.20ATP.3F/near/484163341\">took 3.6 seconds</a> for at least one choice of Vampire parameters).</p>",
        "id": 518551272,
        "sender_full_name": "Terence Tao",
        "timestamp": 1747403681
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"802311\">@Oliver Dressler</span> API is on the way. I will check out your project in more detail when I get the chance.</p>",
        "id": 518685483,
        "sender_full_name": "Justin Asher",
        "timestamp": 1747407537
    },
    {
        "content": "<p>The point is to not only provide the model with the ability to search for statements, but to also exploit dependency information to automatically generate a rich and resourceful context around the proof or document that it is working on.</p>",
        "id": 518687925,
        "sender_full_name": "Justin Asher",
        "timestamp": 1747408142
    },
    {
        "content": "<p>Terry, thanks for the detailed explanation. That makes perfect sense. </p>\n<p>Duper can't come close to competing with Vampire, but I took up your challenge anyhow. First, I imported the proof of 650=&gt;448 and replaced every call to <code>superposition</code> and the other specialized tactics with a call to <code>duper</code>:<br>\n<a href=\"https://github.com/avigad/EquationalTest/blob/main/EquationalTest/Equation650_implies_Equation448.lean\">https://github.com/avigad/EquationalTest/blob/main/EquationalTest/Equation650_implies_Equation448.lean</a><br>\nThen I minimized it by hand, combining and deleting steps. I could shorten the proof somewhat, but not much, and only by increasing <code>maxHeartbeats</code>.<br>\n<a href=\"https://github.com/avigad/EquationalTest/blob/main/EquationalTest/Equation650_implies_Equation448_minimized.lean\">https://github.com/avigad/EquationalTest/blob/main/EquationalTest/Equation650_implies_Equation448_minimized.lean</a></p>\n<p>Anyhow, Duper is not designed to compete with Vampire, but, rather, to serve the purpose announced in the topic of this thread, i.e. automatically fill in small steps in a proof. We are currently working on a sledgehammer for Lean that will use neural and symbolic methods to select background facts from the library and <a href=\"https://github.com/leanprover-community/lean-auto\">Lean-auto</a> to instantiate type classes and export the problem to external provers like Zipperposition and cvc5. Duper (among other methods) will be used to reconstruct proofs in Lean. Chase and I are also hopeful that with premise selection and a method to instantiate type classes, Canonical will provide a complementary approach. And we are all excited about getting even further by combining neural and symbolic methods.</p>",
        "id": 518752247,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1747431873
    },
    {
        "content": "<p>A small note: the file name starts with Equation550 which should be 650.  I think everywhere else the number is correct.</p>",
        "id": 518787944,
        "sender_full_name": "Bruno Le Floch",
        "timestamp": 1747461392
    },
    {
        "content": "<p>Thanks! I fixed it.</p>",
        "id": 518837554,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1747502822
    }
]