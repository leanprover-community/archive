[
    {
        "content": "<p>I want to say that I found this thing called linear logic and game semantics almost a year ago. It seems to be able to rigorously interpret logic as some games like Go or Tic-Tac-Toe, which should be what reinforcement learning is good at. It sees logic as a debate (or dialogue) between proponent/opponent (prover/falsifier, programmer/user, function callee/caller).</p>\n<p>(Specifically, this refers to a two-player zero-sum game. That is, there can't be three or more players, and when one wins, the other loses. I also think the players play in turn in the theory. I'm not sure.)</p>\n<p>Here are some relevant links I found:<br>\n<a href=\"https://plato.stanford.edu/entries/logic-games/\">https://plato.stanford.edu/entries/logic-games/</a><br>\n<a href=\"https://en.wikipedia.org/wiki/Linear_logic\">https://en.wikipedia.org/wiki/Linear_logic</a><br>\n<a href=\"https://ncatlab.org/nlab/show/linear+logic\">https://ncatlab.org/nlab/show/linear+logic</a><br>\n<a href=\"https://www.youtube.com/watch?v=t-5SzAAh6oY&amp;pp=ygUMbGluZWFyIGxvZ2lj\">https://www.youtube.com/watch?v=t-5SzAAh6oY&amp;pp=ygUMbGluZWFyIGxvZ2lj</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"t-5SzAAh6oY\" href=\"https://www.youtube.com/watch?v=t-5SzAAh6oY&amp;pp=ygUMbGluZWFyIGxvZ2lj\"><img src=\"https://uploads.zulipusercontent.net/d495d022b3a96477ced2274177db7b9047e01f71/68747470733a2f2f692e7974696d672e636f6d2f76692f742d35537a414168366f592f64656661756c742e6a7067\"></a></div><p>Someone on Zulip mentioned game semantics 5 years ago...<br>\n<a href=\"#narrow/stream/113488-general/topic/A.20newcomer's.20opinion/near/164799600\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/A.20newcomer's.20opinion/near/164799600</a></p>\n<p>I spent some time trying to understand this, and I think I understand the equivalence, but I still lack some prerequisite knowledge...</p>\n<p>Game semantics gives you two similar but different concepts.</p>\n<ol>\n<li>\"You have a winning strategy for a certain game rule\" is equivalent to being able to prove a certain theorem.</li>\n<li>\"You happen to defeat an opponent once under a certain rule\" is equivalent to proving a special case of a certain theorem, or successfully avoiding doubts about your theorem.</li>\n</ol>\n<p>For example, <code>∀ n : ℕ, ∃ m : ℕ, m &gt; n</code> (for any natural number there is a larger natural number), the rule for this proposition is as follows: your opponent first points out an <code>n</code> that it thinks makes <code>∃ m : ℕ, m &gt; n</code> false (trying to give a counterexample), then you are responsible for finding m, and then you are responsible for proving that for the <code>n</code> and <code>m</code> chosen by the two of you, <code>m &gt; n</code>.</p>\n<p>Below are two examples of a game process of <code>∀ n : ℕ, ∃ m : ℕ, m &gt; n</code>:<br>\nFirst:<br>\nOpponent: I think this is not true for n = 5<br>\nMe: I found m = 6<br>\nMe: 6 &gt; 5 is obvious (maybe you can write a Lean norm_num to expand the definition of natural numbers to prove this...)<br>\n(Now the opponent can't refute it. I won the game.)</p>\n<p>Second:<br>\nOpponent: I think this is not true for n = 5<br>\nMe: I found m = 4<br>\n(Now I can't prove 4 &gt; 5, I failed.)</p>\n<p>In fact, <code>∀ n : ℕ, ∃ m : ℕ, m &gt; n</code> is a true proposition. But you can see that even if the game corresponds to a true proposition, the prover (me in the example) will still lose the game if he is stupid and does not follow the winning strategy. The above two game processes do not correspond to \"proof\", but only to exploring special cases.</p>\n<p>The following is the correct proof of <code>∀ n : ℕ, ∃ m : ℕ, m &gt; n</code>, or the winning strategy:<br>\nOpponent: I think this is not right for n<br>\nMe: ​​I found m = n+1<br>\nMe: m = n + 1 &gt; n is obvious<br>\n(Now the opponent can't refute it, I won the game.)</p>\n<p>I won the debate without knowing the specific n chosen by the opponent and without using any information about it. Now this game process can be fixed into a strategy to win any new <code>∀ n : ℕ, ∃ m : ℕ, m &gt; n</code> game. A neural network should be rewarded more for finding a complete proof than just an example.</p>\n<p>Also, you can swap the <code>∀ n, ∃ m</code> in the original proposition <code>∀ n : ℕ, ∃ m : ℕ, m &gt; n</code> to get <code>∃ m : ℕ, ∀ n : ℕ, m &gt; n</code> (There is an integer bigger than any other integer). This game is now harder to win for me. Originally, when I chose <code>m</code>, the opponent has already chosen <code>n</code>, so I know what <code>n</code> was, and choosing <code>m = n + 1</code> (defining <code>m</code> with the variable <code>n</code>) is valid. For the newer theorem, when I am choosing <code>m</code>, this is before the opponent choose <code>n</code>, so I don't know what <code>n</code> is. My chosen <code>m</code> has to work for all possible <code>n</code> my opponent can possibly choose. In fact, this new proposition becomes false and my opponent has a winning strategy.</p>\n<p>Game semantics seems to be particularly helpful to correctly implement trial and error in theorem provers, just like AlphaGo tries various possible game states of Go, without having to prove that its method is absolutely correct and can beat any opponent (in fact, it cannot prove it). </p>\n<p>Neural networks should first explore and understand curcial special cases of a theorem, and learn the complete proof after that. The training goal of these neural network provers should not be to convince Lean directly, but to convince the same neural network falsifier first. Maybe this will give us a more diversed loss punishment value (determined by whether you have a complete proof, or you have proved a specific example of the theorem, or you have been falsified by a counterexample. Even things like you found a specific example of a counterexample of a specific example of the theorem. You can nest these).</p>\n<p>If you simply train a neural network to try a tree search, and use whether the proof succeeds as your loss, when the model is not really smart yet, the only feedback you get might be that the proof failed most of the time, so the model may not learn much because the loss value is almost always the same, maybe -1, and a constant loss punishment does not tell the model how to improve. However, if you make a model debate with itself about a theorem, you can check whether it wins the debate and use that as your loss value. Now the game is somewhat more symmetric because the opponent is also the model itself, not the lean checker, just like the self-play in AlphaGo, and winning the opponent model should be much easier than completing a successful tree search. Now the loss will not be a constant of -1, but a more diversed value. Even if the model is not smart enough to prove the theorem, it can still learn how to improve a specific debate process, and gradually obtain the complete winning strategy as a real proof. Given a proposition, you should also be able to count the number of winning / losing debates, and take the ratio, to \"guess\" whether a proof is probably true or not, and examine how well the model is learning.</p>\n<p>Translating <code>And Or True False</code> into a game is similar to ∀ and ∃.<br>\n<code>A and B</code> is equivalent to this game: your opponent first chooses the one he thinks is incorrect between A and B (questioning you), and then you are responsible for proving the goal chosen by the opponent. <code>A or B</code> is equivalent to this game: you have the right to (and must) choose one between A and B to prove. <code>False</code> corresponds to a game you always lose. <code>True</code> corresponds to a game you always win.</p>\n<p>The continuity of the function defined by epsilon-delta can also be understood rigorously:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MyContinuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x₀</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">x₀</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x₀</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ε</span>\n</code></pre></div>\n<p>For any epsilon (maximum error of y) required by your opponent, you can require delta (maximum error of x) so that any x within the error range can make f(x) within the error.<br>\nFor another example, the composition of continuous functions is continuous, which is equivalent to others questioning you whether g ∘ f is continuous, while you can question hf and hg and ask them whether f and g are continuous.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">comp_continuous</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyContinuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyContinuous</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyContinuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">MyContinuous</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x₀</span><span class=\"w\"> </span><span class=\"c1\">-- we are given x₀ anywhere on the real line</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">dz</span><span class=\"w\"> </span><span class=\"n\">hdz</span><span class=\"w\"> </span><span class=\"c1\">-- we are given dz &gt; 0, the wanted error of z, ie g(f(x))</span>\n<span class=\"w\">  </span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">dy</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">hdy</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"bp\">⟩⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x₀</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">dz</span><span class=\"w\"> </span><span class=\"n\">hdz</span><span class=\"w\"> </span><span class=\"c1\">-- With dz, `MyContinuous g` will tell us dy &gt; 0, the wanted error of y, ie g(x)</span>\n<span class=\"w\">  </span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">dx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">hdx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"bp\">⟩⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"n\">x₀</span><span class=\"w\"> </span><span class=\"n\">dy</span><span class=\"w\"> </span><span class=\"n\">hdy</span><span class=\"w\"> </span><span class=\"c1\">-- With dy, `MyContinuous x` will tell us dx &gt; 0, the wanted error of x</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">dx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hdx</span><span class=\"w\"> </span><span class=\"c1\">-- we answer dx &gt; 0 to be the wanted error of x</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"c1\">-- given x where |x - x₀| &lt; dx</span>\n<span class=\"w\">  </span><span class=\"c1\">-- we are given hx ==&gt; x has the error that hf wants ==&gt; f(x) has the error that hg wants ==&gt; g(f(x)) has the error that we want</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"c1\">-- hover on parantheses to see the statements</span>\n</code></pre></div>",
        "id": 456162705,
        "sender_full_name": "Deming Xu",
        "timestamp": 1722693400
    },
    {
        "content": "<p><a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Linear.20logic.20and.20game.20semantics/near/456162705\">A message</a> was moved here from <a class=\"stream-topic\" data-stream-id=\"219941\" href=\"/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Reinforcement.20learning.20for.20solving.20a.20single.20theorem\">#Machine Learning for Theorem Proving &gt; Reinforcement learning for solving a single theorem</a> by <span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span>.</p>",
        "id": 456410417,
        "sender_full_name": "Notification Bot",
        "timestamp": 1722818140
    },
    {
        "content": "<p>There's an even neater connection here: if you train neutral nets to play the game semantics of a particular statement, the way to turn a successful neural net into a proof is to do (mechanistic) interpretation of the learned algorithm to prove that it is a winning strategy.</p>",
        "id": 456791473,
        "sender_full_name": "Jason Gross",
        "timestamp": 1722930962
    },
    {
        "content": "<p>This is probably very off-topic, but I'd like to share something interesting: There's an online platform called <a href=\"http://Kialo.com\">Kialo.com</a> that aims to provide a tool for rigorous debate. It organizes different sides of an argument recursively as a tree, allowing any sub-argument to be further expanded with additional support or counterarguments. This structure is somewhat similar to game semantics, where two players engage in a back-and-forth, attempting to identify flaws in each other's reasoning.</p>\n<p>Random example from Kialo: <a href=\"https://www.kialo.com/the-institution-of-american-football-is-socially-harmful-10143.5?path=10143.0~10143.1_10143.5\">https://www.kialo.com/the-institution-of-american-football-is-socially-harmful-10143.5?path=10143.0~10143.1_10143.5</a></p>",
        "id": 467155917,
        "sender_full_name": "Qian Hong",
        "timestamp": 1725348797
    }
]