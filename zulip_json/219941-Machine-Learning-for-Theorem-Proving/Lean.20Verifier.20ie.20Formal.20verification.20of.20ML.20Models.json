[
    {
        "content": "<p>Has anyone taken a look at this: <a href=\"https://github.com/fraware/leanverifier\">https://github.com/fraware/leanverifier</a>? It seems interesting, what are your all thoughts on this? Not sure if the main author is on the zulip channel to tag him.</p>",
        "id": 507840888,
        "sender_full_name": "Robert",
        "timestamp": 1742838629
    },
    {
        "content": "<p>The demo app is just a web app mockup, where everything is just a link back to repo?</p>",
        "id": 508220372,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1742981253
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"782569\">Robert</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Lean.20Verifier.20ie.20Formal.20verification.20of.20ML.20Models/near/507840888\">ha scritto</a>:</p>\n<blockquote>\n<p>Has anyone taken a look at this: <a href=\"https://github.com/fraware/leanverifier\">https://github.com/fraware/leanverifier</a>? It seems interesting, what are your all thoughts on this? Not sure if the main author is on the zulip channel to tag him.</p>\n</blockquote>\n<p>interesting but it seems to be at an early stage and uses mixed Lean3/Lean 4 syntax, I'm not sure it compiles</p>",
        "id": 508243148,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1742987147
    },
    {
        "content": "<p>I was curious about their definition of \"robustness\" of a model:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">Robust classification property:</span>\n<span class=\"sd\">A classification function f is robust at level ε if any two inputs within ε (L2 norm) yield the same output.</span>\n<span class=\"sd\">--/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">robustClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">distL2</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x'</span>\n</code></pre></div>\n<p>So you can perturb the input by an vector of norm at most ε and the output must be unchanged. But ... that implies that the function is constant, because you can just keep perturbing by ε and over. I was even more confused when they actually proved that some model was robust, in the same repo! But it <a href=\"https://github.com/fraware/leanverifier/blob/201bef3479b73789c69395cbc02ec213b89f76e5/lean/FormalVerifML/proofs/example_robustness_proof.lean#L31\">turns out</a> that they assumed, as <code>axiom</code>s, that the model was (1) Lipschitz, and (2) has a margin property. Lipschitz implies that it's a continuous function. The margin property states that the classifier is always at least 0.1, or at most -0.1. But if you take a continuous function with the margin property, then it must also be a constant classifier. So the proof checks out!</p>",
        "id": 508275768,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742995779
    },
    {
        "content": "<p>but the pipeline on a whole looks like a pretty neat idea, a good way to \"import\" models from a JSON to Lean, and then you can write proofs about them? but it looks pretty early</p>",
        "id": 508276204,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1742995832
    }
]