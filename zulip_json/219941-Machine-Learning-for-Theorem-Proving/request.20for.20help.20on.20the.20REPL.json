[
    {
        "content": "<p>I've been busy, and have not yet upgraded the REPL to v4.15.0-rc1. Would anyone be interested in looking into this?</p>\n<p>There is an open PR at <a href=\"https://github.com/leanprover-community/repl/pull/61\">https://github.com/leanprover-community/repl/pull/61</a>, and the CI errors show what needs to be fixed.</p>\n<p>The underlying causes are </p>\n<ul>\n<li><a href=\"https://github.com/leanprover/lean4/pull/6051\">lean#6051</a> (making <code>Meta.Context.config</code> private) and </li>\n<li><a href=\"https://github.com/leanprover/lean4/pull/5835\">lean#5835</a>  feat: structure auto-completion &amp; partial InfoTrees</li>\n</ul>",
        "id": 492418731,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736299951
    },
    {
        "content": "<p>I've pushed a commit fixing the second bulletpoint, but I'm at a loss for the first one.</p>",
        "id": 492422065,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1736302249
    },
    {
        "content": "<p>A bit sketchy but here's a workaround for the first bulletpoint: <a href=\"https://github.com/leanprover-community/repl/pull/64/files\">https://github.com/leanprover-community/repl/pull/64/files</a></p>",
        "id": 492432525,
        "sender_full_name": "llllvvuu",
        "timestamp": 1736310461
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> and <span class=\"user-mention\" data-user-id=\"607118\">@llllvvuu</span>, putting those together gets us to <code>v4.15.0-rc1</code>. I merged, and cut tags for <code>v4.15.0-rc1</code> and <code>v4.15.0</code>.</p>",
        "id": 492438875,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736315410
    },
    {
        "content": "<p>Anyone, perhaps <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> or <span class=\"user-mention\" data-user-id=\"607118\">@llllvvuu</span>, interested in having a look at <a href=\"https://github.com/leanprover-community/repl/pull/67\">https://github.com/leanprover-community/repl/pull/67</a>, the failing REPL bump to v4.16.0-rc1? Proof states are being duplicated.</p>",
        "id": 493513831,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736832946
    },
    {
        "content": "<p>I can take a look around this time tomorrow</p>",
        "id": 493524013,
        "sender_full_name": "llllvvuu",
        "timestamp": 1736838748
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/repl/pull/68\">repl#68</a></p>",
        "id": 493891477,
        "sender_full_name": "llllvvuu",
        "timestamp": 1736936434
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"607118\">@llllvvuu</span>, nice, thank you!</p>",
        "id": 493904221,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736940659
    },
    {
        "content": "<p>I've just put up <a href=\"https://github.com/leanprover-community/repl/pull/79\">https://github.com/leanprover-community/repl/pull/79</a>, which attempts to move the repl up to v4.19.0-rc2, but this still has some failing tests.</p>",
        "id": 509897137,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1743675319
    },
    {
        "content": "<p>Would anyone be interested in taking a look at this?</p>",
        "id": 509897172,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1743675327
    },
    {
        "content": "<p>Separately, a few people have contacted me recently about wanting to help fix various known problems with the REPL. May I suggest that discussion about this happens here? I don't have a lot of time for the REPL at the moment, and I hope that others who are using it can take over.</p>\n<p>Pinging <span class=\"user-mention\" data-user-id=\"321854\">@Auguste Poiroux</span> and <span class=\"user-mention\" data-user-id=\"872000\">@Matěj Kripner</span> as two people who have expressed such interest recently! :-)</p>",
        "id": 509897552,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1743675468
    },
    {
        "content": "<p>I find it very valuable to have REPL included in the lean core release cycle, always up to date with the latest lean release. So as one of the REPL 'users' I wanted to say <em>thank you</em> to everybody who has helped and will help making this possible!</p>",
        "id": 509967803,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1743693051
    },
    {
        "content": "<p>A quick fix to pass the failing tests is to revert the change of default behavior for <code>importModules</code>(see <a href=\"https://github.com/leanprover/lean4/pull/6325\">https://github.com/leanprover/lean4/pull/6325</a>). I made a pull request in the Lean REPL repo <a href=\"https://github.com/leanprover-community/repl/pull/80\">here</a>.</p>",
        "id": 509972041,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1743694033
    },
    {
        "content": "<p>It is problematic that unpickling can be done more than once in a single process but this likely is not worse than in previous Lean versions. Otherwise the PR looks good to me.</p>",
        "id": 509975094,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1743694710
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"321854\">@Auguste Poiroux</span> for the quick fix. The REPL is now available on v4.19.0-rc2 (including with a toolchain tag <code>v4.19.0-rc2</code>.</p>",
        "id": 510053975,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1743723124
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> Thank you for the ping! Unfortunately, the REPL sometimes accepts incorrect proofs - see these examples:</p>\n<p><a href=\"https://github.com/leanprover-community/repl/issues/44#issuecomment-2694743268\">https://github.com/leanprover-community/repl/issues/44#issuecomment-2694743268</a><br>\n<a href=\"https://github.com/leanprover-community/repl/issues/44#issuecomment-2789411256\">https://github.com/leanprover-community/repl/issues/44#issuecomment-2789411256</a></p>\n<p>I will repost some of them here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">succ</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases'</span><span class=\"w\"> </span><span class=\"n\">exists_ne</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">self_application</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">self_application</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I'm currently reading through the REPL code, but so far I have no idea how to fix this. Any help is appreciated!</p>",
        "id": 511153468,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744200353
    },
    {
        "content": "<p>Yes, the basic problem is that proofs done in \"tactic mode\" in the REPL are never sent to the kernel for checking.</p>",
        "id": 511153824,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744200439
    },
    {
        "content": "<p>I think you do these in \"command\" mode (i.e. give it the whole declaration at once) then it is sent to the kernel, and the error is correctly reported. Does that agree with your understanding?</p>",
        "id": 511153977,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744200481
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/request.20for.20help.20on.20the.20REPL/near/511153824\">said</a>:</p>\n<blockquote>\n<p>Yes, the basic problem is that proofs done in \"tactic mode\" in the REPL are never sent to the kernel for checking.</p>\n</blockquote>\n<p>I did not realize that this is the case. Do you think it is doable to send the proof to kernel after each tactic invocation in tactic mode? Not using the kernel at all seems problematic.</p>",
        "id": 511155092,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744200775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/request.20for.20help.20on.20the.20REPL/near/511153977\">said</a>:</p>\n<blockquote>\n<p>I think you do these in \"command\" mode (i.e. give it the whole declaration at once) then it is sent to the kernel, and the error is correctly reported. Does that agree with your understanding?</p>\n</blockquote>\n<p>Yes, the errors are reported in command mode but not in tactic mode.</p>",
        "id": 511155227,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744200812
    },
    {
        "content": "<p>The problem is that you can only send complete proofs --- in tactic mode, if you are not finished yet, then the proof term has metavariables still (and so the kernel will reject it).</p>",
        "id": 511155420,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744200859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/request.20for.20help.20on.20the.20REPL/near/511155420\">said</a>:</p>\n<blockquote>\n<p>The problem is that you can only send complete proofs --- in tactic mode, if you are not finished yet, then the proof term has metavariables still (and so the kernel will reject it).</p>\n</blockquote>\n<p>I see. Do you think there is a way to reject these incorrect proofs in tactic mode without calling the kernel? Or is it necessary to think of a way to make the kernel verify even incomplete proofs?</p>\n<p>At first glance it seems that even incomplete proofs could be sent to the kernel if we add <code>sorry</code> at the end - that is what we do all the time when writing proofs in Lean.</p>",
        "id": 511159700,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744201937
    },
    {
        "content": "<p>Yes, the \"right\" fix (the REPL is, at this point, a pile of hacks, so what is one more?) is perhaps to have a custom tactic (probably make use of the existing <code>done</code> tactic) that the REPL intercepts, and sends the currently proof term to the kernel for checking.</p>",
        "id": 511161399,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744202375
    },
    {
        "content": "<p>Actually, sorry, that is dumb.</p>",
        "id": 511161460,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744202392
    },
    {
        "content": "<p>The right thing is just to have the REPL detect when there are no more goals (/no more metavariables in the proof term) and send it to the kernel then. Currently there is just no step in tactic mode that does this.</p>",
        "id": 511161646,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744202430
    },
    {
        "content": "<p>In the LeanDojo repl, they indeed send the proof to the kernel once there are no more goals. See this <a href=\"https://github.com/lean-dojo/LeanDojo/blob/main/src/lean_dojo/interaction/Lean4Repl.lean\">file</a>. LeanDojo repl is unfortunately not compatible with Lean &gt;= 4.12.0 (<a href=\"https://github.com/lean-dojo/LeanDojo/issues/211\">issue</a>). I started implementing a similar idea  for the Lean REPL in this <a href=\"https://github.com/leanprover-community/repl/pull/63\">PR</a> a few months ago, but I got stuck because of my limited understanding of the problem ^^</p>",
        "id": 511164405,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744203051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/request.20for.20help.20on.20the.20REPL/near/511161399\">said</a>:</p>\n<blockquote>\n<p>Yes, the \"right\" fix (the REPL is, at this point, a pile of hacks, so what is one more?) is perhaps to have a custom tactic (probably make use of the existing <code>done</code> tactic) that the REPL intercepts, and sends the currently proof term to the kernel for checking.</p>\n</blockquote>\n<p>I think this first idea is nicer, because it rejects invalid tactics immediately instead of waiting for the proof to finish.</p>",
        "id": 511174828,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744205598
    },
    {
        "content": "<p>All <code>done</code> does is check whether there are any unsolved goals. I don’t think it involves the kernel.</p>",
        "id": 511175248,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744205697
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Tactic.done#doc\">docs#Lean.Elab.Tactic.done</a></p>",
        "id": 511175304,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744205714
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321854\">Auguste Poiroux</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/request.20for.20help.20on.20the.20REPL/near/511164405\">said</a>:</p>\n<blockquote>\n<p>In the LeanDojo repl, they indeed send the proof to the kernel once there are no more goals. See this <a href=\"https://github.com/lean-dojo/LeanDojo/blob/main/src/lean_dojo/interaction/Lean4Repl.lean\">file</a>. LeanDojo repl is unfortunately not compatible with Lean &gt;= 4.12.0 (<a href=\"https://github.com/lean-dojo/LeanDojo/issues/211\">issue</a>). I started implementing a similar idea  for the Lean REPL in this <a href=\"https://github.com/leanprover-community/repl/pull/63\">PR</a> a few months ago, but I got stuck because of my limited understanding of the problem ^^</p>\n</blockquote>\n<p>The PR looks very promising! I think we should try to finish it. Do you have time to discuss the approach you tried and why it does not work yet?<br>\nIf you prefer, we can arrange a call - maybe <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> and anyone interested can join.</p>",
        "id": 511177414,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744206230
    },
    {
        "content": "<p>I just updated the PR with new tests corresponding to <span class=\"user-mention\" data-user-id=\"872000\">@Matěj Kripner</span> minimal examples. I have found that the code in the PR correctly catches all these cases. It also catches this example from <span class=\"user-mention\" data-user-id=\"572535\">@RexWang</span>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"cmd\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"import Mathlib\"</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"cmd\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"theorem amc12a_2002_p12 (f : ℝ → ℝ) (k : ℝ) (a b : ℕ) (h₀ : ∀ x, f x = x ^ 2 - 63 * x + k)</span><span class=\"se\">\\n</span><span class=\"s2\">    (h₁ : f a = 0 ∧ f b = 0) (h₂ : a ≠ b) (h₃ : Nat.Prime a ∧ Nat.Prime b) : k = 122 := by sorry\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"env\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"apply (mul_right_inj' (sub_ne_zero.2 ?_)).1\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"ring_nf at h₁ h₂ ⊢\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Apparently it wasn't caught before (see <a href=\"https://github.com/leanprover-community/repl/issues/44#issuecomment-2670829169\">issue</a>).<br>\nError messages might be different from the ones provided in the command mode or in the Lean IDE. The code in the PR runs some checks before doing a kernel check, resulting sometimes in an uninformative error <code>Incomplete: contains metavariable(s)</code>.<br>\nHowever, the code still doesn't catch the following  self-application issue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">   </span><span class=\"n\">exact?</span>\n</code></pre></div>\n<p>It is also the only case I know where it fails to catch the issue so far.</p>",
        "id": 511196927,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744210697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321854\">Auguste Poiroux</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/request.20for.20help.20on.20the.20REPL/near/511196927\">said</a>:</p>\n<blockquote>\n<p>I just updated the PR with new tests corresponding to <span class=\"user-mention silent\" data-user-id=\"872000\">Matěj Kripner</span> minimal examples. I have found that the code in the PR correctly catches all these cases. It also catches this example from <span class=\"user-mention silent\" data-user-id=\"572535\">RexWang</span>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"cmd\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"import Mathlib\"</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"cmd\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"theorem amc12a_2002_p12 (f : ℝ → ℝ) (k : ℝ) (a b : ℕ) (h₀ : ∀ x, f x = x ^ 2 - 63 * x + k)</span><span class=\"se\">\\n</span><span class=\"s2\">    (h₁ : f a = 0 ∧ f b = 0) (h₂ : a ≠ b) (h₃ : Nat.Prime a ∧ Nat.Prime b) : k = 122 := by sorry\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"env\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"apply (mul_right_inj' (sub_ne_zero.2 ?_)).1\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"ring_nf at h₁ h₂ ⊢\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Apparently it wasn't caught before (see <a href=\"https://github.com/leanprover-community/repl/issues/44#issuecomment-2670829169\">issue</a>).<br>\nError messages might be different from the ones provided in the command mode or in the Lean IDE. The code in the PR runs some checks before doing a kernel check, resulting sometimes in an uninformative error <code>Incomplete: contains metavariable(s)</code>.<br>\nHowever, the code still doesn't catch the following  self-application issue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">   </span><span class=\"n\">exact?</span>\n</code></pre></div>\n<p>It is also the only case I know where it fails to catch the issue so far.</p>\n</blockquote>\n<p>This looks great! I think this is generally the correct approach and it's well-tested. Even if it fails for <code>exact?</code> and similar, it still dramatically decreases the \"attack surface\" of the REPL.</p>\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> do you think it would be possible to merge it?</p>",
        "id": 511220473,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744216850
    },
    {
        "content": "<p>I also like the idea of <code>rootGoals</code>. For theorem provers, it removes the need to manually replace <code>by</code> blocks with <code>sorry</code> when starting a proof.</p>",
        "id": 511220800,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744216942
    },
    {
        "content": "<p>Tests are currently failing, but yes, after that, happy to take a look and hopefully merge.</p>",
        "id": 511285525,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744244590
    },
    {
        "content": "<p>Tests are now passing. Tests for cases mentioned in this <a href=\"https://github.com/leanprover-community/repl/issues/44\">issue</a> are implemented in the PR, except the <code>exact?</code> self-application issue, which is now removed.</p>",
        "id": 511341821,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744272702
    },
    {
        "content": "<p>On a related note, I think it could be nice to store somewhere tests that don't pass yet, either in a separate branch or in a folder.</p>",
        "id": 511341996,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744272745
    },
    {
        "content": "<p>There are in fact some disabled tests -- if there is no matching <code>.expected.out</code> file then the test framework doesn't check anything.</p>",
        "id": 511344522,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744273461
    },
    {
        "content": "<p>I've merged the PR. Thank you, <span class=\"user-mention\" data-user-id=\"321854\">@Auguste Poiroux</span>, for fixing this for us all!</p>",
        "id": 511344666,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744273502
    },
    {
        "content": "<p>We might have merged the previous PR a bit too fast. It turns out that this PR is rejecting a large class of valid proofs. I created a new PR fixing this, along with new tests to check for slightly more complex proofs (all tests are passing): <a href=\"https://github.com/leanprover-community/repl/pull/82\">link</a>.</p>",
        "id": 511419296,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744293620
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321854\">@Auguste Poiroux</span> Thank you, this is a great step forward. The <a href=\"https://github.com/leanprover-community/repl/pull/82\">new PR</a> looks sensible.</p>\n<p>One practical issue I came across is that <code>proofStatus</code> is \"Incomplete\" even when the goals introduced by <code>sorry</code> are solved. E.g. when using <code>have</code>, you would send something like:</p>\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"p\">{</span><span class=\"nt\">\"tactic\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"have h : x &gt; 0 := by sorry\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nt\">\"proofState\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">}</span>\n</code></pre></div>\n<p>(as in <a href=\"https://github.com/leanprover-community/repl/blob/master/test/name_generator.in\">https://github.com/leanprover-community/repl/blob/master/test/name_generator.in</a>)<br>\nEven after finishing the proof, <code>proofStatus</code> stays \"Incomplete\" (see <a href=\"https://github.com/leanprover-community/repl/blob/master/test/name_generator.expected.out\">https://github.com/leanprover-community/repl/blob/master/test/name_generator.expected.out</a>).</p>",
        "id": 511457197,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744302777
    },
    {
        "content": "<p>This is a good point. At the moment, only linear sequences of proofsteps, with each proofstep depending on the previous one, are checked. Let's call this a branch in the proof search. Each branch are independent from each other, and thus cannot influence each other proofStates. The thing with \"have ... := sorry\" is that this creates a new branch. So when you send proofSteps to this branch, the main branch is not aware of it. The main branch will always have the \"have ... := sorry\" proofstep.<br>\nHmm, I don't know how other REPL-like tools solve this ^^'</p>",
        "id": 511458961,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744303274
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321854\">Auguste Poiroux</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/request.20for.20help.20on.20the.20REPL/near/511458961\">said</a>:</p>\n<blockquote>\n<p>This is a good point. At the moment, only linear sequences of proofsteps, with each proofstep depending on the previous one, are checked. Let's call this a branch in the proof search. Each branch are independent from each other, and thus cannot influence each other proofStates. The thing with \"have ... := sorry\" is that this creates a new branch. So when you send proofSteps to this branch, the main branch is not aware of it. The main branch will always have the \"have ... := sorry\" proofstep.<br>\nHmm, I don't know how other REPL-like tools solve this ^^'</p>\n</blockquote>\n<p>Yeah, I don't see a way around that either. The branches have to be independent. But <code>sorries</code> are already reported by the REPL, so maybe we can just remove the <code>pf.hasSorry</code> check and not report the \"Incomplete: contains sorry\" error?</p>",
        "id": 511461676,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744304125
    },
    {
        "content": "<p>I think we prefer to have false negatives rather than false positives when doing proof verification, so I wouldn't remove the <code>pf.hasSorry</code> check. But you can consider that \"Incomplete: the proof contains sorries\" is \"Completed\" for your use case, if you know that you have a correct proof for your branch.<br>\nAnother external workaround would be to first finish the proof associated to the <code>sorry</code> introduced by <code>have</code>, and then to send <code>{\"tactic\": \"have h : x &gt; 0 := by &lt;your successful proof here&gt;\", \"proofState\": 0}</code>. You can then continue with the main proof and you won't have a sorry issue.</p>",
        "id": 511462530,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744304364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321854\">Auguste Poiroux</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/request.20for.20help.20on.20the.20REPL/near/511462530\">said</a>:</p>\n<blockquote>\n<p>I think we prefer to have false negatives rather than false positives when doing proof verification, so I wouldn't remove the <code>pf.hasSorry</code> check. But you can consider that \"Incomplete: the proof contains sorries\" is \"Completed\" for your use case, if you know that you have a correct proof for your branch.<br>\nAnother external workaround would be to first finish the proof associated to the <code>sorry</code> introduced by <code>have</code>, and then to send <code>{\"tactic\": \"have h : x &gt; 0 := by &lt;your successful proof here&gt;\", \"proofState\": 0}</code>. You can then continue with the main proof and you won't have a sorry issue.</p>\n</blockquote>\n<p>In that case can we move the <code>pf.hasSorry</code> down so that it is the last check before \"Completed\"? Because otherwise it is not safe to ignore it as it might shadow e.g. the kernel check.</p>",
        "id": 511464764,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744305044
    },
    {
        "content": "<p>I see your point, ok doing that in the current <a href=\"https://github.com/leanprover-community/repl/pull/82\">PR</a> <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 511469609,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744306123
    },
    {
        "content": "<p>I updated the <a href=\"https://github.com/leanprover-community/repl/pull/82\">PR</a>, the <code>exact?</code> self-application issue is now resolved as well. I believe we don't have any invalid proofs that are accepted in tactic mode now.</p>\n<p>As <a href=\"https://github.com/leanprover-community/repl/issues/44#issuecomment-2576957855\">mentioned</a> by <span class=\"user-mention\" data-user-id=\"607118\">@llllvvuu</span>, the <code>exact?</code> issue has already been partially resolved in this <a href=\"https://github.com/leanprover-community/repl/commit/66515025d9ccffa2be29718d31b816edd0675202\">commit</a>. It is a question of which environment is provided to the tactic. The previous commit solved the problem for all commands starting from an existing environment state. In the PR, we now solve it for the initial commands as well.</p>",
        "id": 511480354,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744308548
    },
    {
        "content": "<p>merged, thank you!</p>",
        "id": 511530662,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744329847
    },
    {
        "content": "<p>For people interested in having all the latest features and bug fixes of Lean REPL backported to older Lean versions, I am maintaining a fork doing that. Essentially, I’m decoupling Lean versions from REPL versions.<br>\nFor instance, in the latest version <a href=\"https://github.com/augustepoiroux/repl/tree/v1.0.6\">v1.0.6</a>, the recently merged proof validation feature has been backported and tested for all Lean versions between v4.7.0-rc1 and v4.19.0-rc2.</p>",
        "id": 511635891,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744373601
    },
    {
        "content": "<p>How it works: each REPL version lives in its own branch, and each commit within that branch corresponds to a specific Lean version. Whenever the official REPL is updated, I copy my latest branch and rebase it on the new REPL using <a href=\"https://stacked-git.github.io/\">stacked-git</a>. This workflow is generally efficient and only requires a few manual fixes in most cases.</p>",
        "id": 511635917,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744373606
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321854\">@Auguste Poiroux</span> I think there is still one more issue with the <code>pf.hasExprMVar</code> check in <code>getProofStatus</code>. It can be seen here:</p>\n<p><a href=\"https://github.com/leanprover-community/repl/blob/master/test/name_generator.in\">https://github.com/leanprover-community/repl/blob/master/test/name_generator.in</a><br>\n<a href=\"https://github.com/leanprover-community/repl/blob/master/test/name_generator.expected.out\">https://github.com/leanprover-community/repl/blob/master/test/name_generator.expected.out</a></p>\n<p>When we execute <code>{\"tactic\": \"have h : x &gt; 0 := by sorry\", \"proofState\": 0}</code> and descend into the branch given in <code>sorries</code>, we can never get to a \"Completed\" state (I think) because goals in the main branch will be unsolved from our perspective. This is again the problem of isolation between branches. However, while \"contains sorries\" can perhaps be safely ignored, \"contains metavariables\" cannot, because then some invalid proofs might get accepted.</p>\n<p>Do you see a way how this could be resolved?</p>",
        "id": 512109176,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744644293
    },
    {
        "content": "<p>This check is not really necessary since <code>addDecl</code> a few line later fails in a similar way (aside that it is probably more efficient to do this check before doing a kernel check?). In the <a href=\"http://name_generator.in\">name_generator.in</a> example, we get <code>\"Error: kernel type check failed: (kernel) declaration has metavariables '[anonymous]'\"</code> instead of <code>\"Incomplete: contains metavariable(s)\"</code> if we remove the <code>pf.hasExprMVar</code> check. I am not sure why we get this error instead of <code>\"Incomplete: contains sorry\"</code>. People with more experience will probably know better than me about the combination of <code>addDecl</code> method with <code>have ... := sorry</code> :)</p>",
        "id": 512114564,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744645644
    },
    {
        "content": "<p>For this branching problem, on top of the <code>{\"tactic\": \"have h : x &gt; 0 := by &lt;your successful proof here&gt;\", \"proofState\": 0}</code> strategy, another way to enforce complete proof check would be to change the repl behavior when a sorry is run through tactic mode.<br>\nThe general idea would be to remember all open goals in one repl proofstate once we are in tactic mode, in particular including those opened by <code>have</code>-like tactics starting new subproofs (<code>calc</code> is another example I am thinking of). This is by opposition to the current way it works where, for each sorry encountered in tactic mode, a new proofstate is instantiated. This way, we remove the branching problem.<br>\nFrom a user point of view, that would be quite nice I believe, however implementation-wise I am not sure how hard it would be to have this.</p>",
        "id": 512119020,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744646822
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321854\">@Auguste Poiroux</span> I think the problem stems from the fact that <code>getProofStatus</code> attempts to verify the whole proof (ie whether the whole proof term currently type-checks against the goal in <code>proofState.rootGoals</code>). This way, when we are in the <code>sorry</code> branch of <code>have ... := by sorry</code>, the whole proof term will always have a metavariable in the place of the main proof branch.<br>\nWouldn't it make more sense to instead verify only the new assignment created in the current step? Ie in <code>createProofStepResponse</code>, look at which goals are newly assigned in <code>proofState</code> which weren't assigned in <code>old</code>, and run type checks for them. If all these assignments are correct, the final proof term should be correct as well.<br>\nAs a bonus, this approach might be faster since the size of the type-checked term is not growing linearly.<br>\nDo you think this approach makes sense?</p>",
        "id": 512344549,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744729230
    },
    {
        "content": "<p>Interesting idea, so you mean that in <code>getProofStatus</code>, instead of checking the whole proof up to the <code>rootGoals</code> <a href=\"https://github.com/leanprover-community/repl/blob/506a6f35d7198e2ed3dcffe8dbd5750ee3fb906f/REPL/Main.lean#L186\">here</a>, we instead compare to the previous goal? I am not sure how this will behave, but this is definitely worth a try. I am a bit worried that it will introduce false positives. Do you have time to test this idea?</p>",
        "id": 512351017,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744730680
    },
    {
        "content": "<p>I think the verification of step <code>(old :: ProofSnapshot, new :: ProofSnapshot)</code> could work something like this:</p>\n<ul>\n<li>(1) Look at all goals in <code>old</code> which no longer exist in <code>new</code>. For each one:<ul>\n<li>(2) Retrieve it's assignment in <code>new</code>. For each metavariable in the assignment:<ul>\n<li>(3) If it is a goal which exists in <code>new</code>, it's fine and we do nothing since we can assume it will be solved in future steps. In this case, we replace it with <code>sorry</code> in the assignment so that the expression can be sent to kernel.</li>\n<li>(4) Otherwise, it's an error since there is a metavariable which won't be assigned in the future.</li>\n</ul>\n</li>\n<li>(5) Send the assignment with metavariables replaced by <code>sorry</code> to kernel for a type check.</li>\n</ul>\n</li>\n</ul>\n<p>I created an initial pull request here: <a href=\"https://github.com/leanprover-community/repl/pull/85\">https://github.com/leanprover-community/repl/pull/85</a>, but it's very much work in progress (doesn't work yet). Any improvements are welcome.</p>\n<p>Do you think this is a valid approach? If it works, it's probably the cleanest solution and avoids false negatives like <a href=\"https://github.com/leanprover-community/repl/blob/master/test/name_generator.in\">https://github.com/leanprover-community/repl/blob/master/test/name_generator.in</a></p>",
        "id": 512601727,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744822227
    },
    {
        "content": "<p>Currently, the problem is that I probably don't understand how terms are assigned during a tactic proof execution. I hoped that when I apply a tactic to a goal <code>G</code> and get a list of goals <code>G_1, ..., G_n</code>, what it means is that we assign to <code>G</code> an expression which contains metavariables <code>G_1, ..., G_n</code>. However, when I use <code>MetavarContext.getExprAssignmentCore</code> to get the expression assigned to <code>G</code> after the tactic and then  <code>Meta.collectMVars</code> on the result, I get many more metavariables than how many goals are created.</p>",
        "id": 512605585,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744822800
    },
    {
        "content": "<p>This looks like a good idea to me, but I must admit I will be of limited help here as this reaches my knowledge limits. One thing though is that metavariables are used for other things than just goals, hence <em>I get many more metavariables than how many goals are created</em>.</p>",
        "id": 512678117,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744834343
    },
    {
        "content": "<p>Here is a concrete example. REPL input:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"cmd\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"example : 1 = 0 := by sorry\"</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"cases 1\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>The initial goal from <code>sorry</code> is <code>_uniq.65</code>. After the tactic is executed, the two new goals are <code>_uniq.67.56</code> (zero) and <code>_uniq.67.70</code> (succ), and the old goal has this assignment (obtained using <code>proofState.metaState.mctx.getExprAssignmentCore?</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">65</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">23</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">instOfNatNat</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Running <code>Meta.collectMVars</code> on this expression yields:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">23</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">41</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">47</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">59</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">52</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">56</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">62</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">70</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Note that the two new goals (<code>_uniq.67.56</code> and <code>_uniq.67.70</code>) are listed as expected (and have neither assignment nor delayed assignment). Also note that all other listed mvars except these two have a delayed assignment, specifically:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Delayed</span><span class=\"w\"> </span><span class=\"n\">assignment</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">23</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">22</span>\n<span class=\"n\">Delayed</span><span class=\"w\"> </span><span class=\"n\">assignment</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">41</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">40</span>\n<span class=\"n\">Delayed</span><span class=\"w\"> </span><span class=\"n\">assignment</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">47</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">46</span>\n<span class=\"n\">Delayed</span><span class=\"w\"> </span><span class=\"n\">assignment</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">59</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">58</span>\n<span class=\"n\">Delayed</span><span class=\"w\"> </span><span class=\"n\">assignment</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">52</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">51</span>\n<span class=\"n\">Delayed</span><span class=\"w\"> </span><span class=\"n\">assignment</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">62</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">61</span>\n<span class=\"n\">Delayed</span><span class=\"w\"> </span><span class=\"n\">assignment</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">uniq</span><span class=\"bp\">.</span><span class=\"m\">67</span><span class=\"bp\">.</span><span class=\"m\">66</span>\n</code></pre></div>\n<p>So an updated version of the algorithm looks at all mvars in the assignment <code>E</code> of a goal <code>G</code> which have no assignment or delayed assignment, checks that they are goals in the new proofSnapshot (so that we know they will be assigned later if the proof finishes) and replaces them with <code>sorry</code> so that <code>E</code> can be checked by the kernel.<br>\nThe problem is that the mvars are not explicitly visible in <code>E</code> - in our case<code>E = ?_uniq.67.23 (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))</code>. So we cannot easily replace them with <code>sorry</code>. They are only retrieved by <code>Meta.collectMVars</code>, traversing all the delayed assignments.</p>\n<p>My issue is that I don't understand delayed assignment. Maybe we are retrieving <code>ContextInfo</code> incorrectly? How do we \"instantiate\" the delayed assignments?</p>\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> Do you know someone who could help us here? TLDR is that we are trying to type-check each new goal assignment after each tactic execution so that at the end of the proof we can be sure the whole proof term is correct.</p>",
        "id": 512791872,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744885681
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321854\">Auguste Poiroux</span> </p>\n<blockquote>\n<p>I think we prefer to have false negatives rather than false positives when doing proof verification, so I wouldn't remove the <code>pf.hasSorry</code> check.</p>\n</blockquote>\n<p>I have a different perspective on this matter.<br>\nFor validation purposes, command mode can be used to double-check proofs and prevent false positives once the proof is complete. However, false negatives are less acceptable as they might prevent exploration of correct proof paths.<br>\nMeanwhile, tactic mode provides considerable performance benefits. We should weigh the trade-off between rigorous validation and computational efficiency.<br>\nBenchmark results would help determine whether the additional validation effort justifies the performance cost.</p>",
        "id": 512917121,
        "sender_full_name": "RexWang",
        "timestamp": 1744924657
    },
    {
        "content": "<p>I see what you mean. One option is to just ignore the <code>proofStatus</code> attribute I guess, right? Or is your idea to add an option to completely skip the kernel check?</p>",
        "id": 512919623,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744925791
    },
    {
        "content": "<p>The current changes looks good to me with low overhead. I just wanted to emphasize that we should also take efficiency into consideration while addressing the FPs.</p>",
        "id": 512923916,
        "sender_full_name": "RexWang",
        "timestamp": 1744927509
    },
    {
        "content": "<p>I do agree with what you said in the first message. We went from having a few false positives to having a few false negatives instead, which is a bit annoying. Hopefully we can fix them.<br>\nRegarding efficiency, I don't know if we can make the kernel check faster. But I do think that having an option to skip the kernel check sounds reasonable.</p>",
        "id": 512927152,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744929018
    },
    {
        "content": "<p>I agree that there should be an option to skip the kernel check to preserve low overhead. I also agree that the false negatives should be resolved. Currently, false negatives occur basically every time there is branching (e.g. using <code>have ... := by ...</code>). Concretely, for input:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"cmd\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"example : 1 = 1 := by sorry\"</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"have : 2 = 2 := by sorry\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"rfl\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"rfl\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>The first <code>rfl</code> closes the <code>have</code> branch, but we get <code>\"proofStatus\": \"Incomplete: contains metavariable(s)\"</code> (because the main branch is not resolved in the <code>have</code> branch - note that this would also be the case if we swapped the two <code>rfl</code>s since the branches are independent). The second <code>rfl</code> closes the main branch, but we get <code>\"proofStatus\": \"Incomplete: contains sorry\"</code> (which can safely be ignored, so that's OK).</p>\n<p>I see two ways to resolve this. Either we keep the current approach of type checking the whole proof term, but then we need to substitute <code>sorry</code> for each side branch that gets created so that the proof term does not contain their metavariables. Or we can switch to verifying only the goal assignments that happen in the current step, thus ensuring that the whole proof term is valid as well.</p>",
        "id": 512991587,
        "sender_full_name": "Matěj Kripner",
        "timestamp": 1744963831
    },
    {
        "content": "<p>To me, regarding the branching issue, there is also a third option we should consider. The idea is to linearize the proofstates, i.e. applying a tactic should yield at most one proofstate. How? By stacking all the goals in one proofState. Concretely, in the example above, after running</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"have : 2 = 2 := by sorry\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>we would get</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"bp\">'</span><span class=\"n\">proofStatus'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Incomplete</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">goals</span><span class=\"w\"> </span><span class=\"n\">remain'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">proofState'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">goals'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">'</span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">\\</span><span class=\"n\">n</span><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">'⊢</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">'</span><span class=\"o\">]}</span>\n</code></pre></div>\n<p>instead of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"bp\">'</span><span class=\"n\">sorries'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[{</span><span class=\"bp\">'</span><span class=\"n\">proofState'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">goal'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">'⊢</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">'</span><span class=\"o\">}],</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">proofStatus'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Incomplete</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">goals</span><span class=\"w\"> </span><span class=\"n\">remain'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">proofState'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">goals'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">'</span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">\\</span><span class=\"n\">n</span><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">'</span><span class=\"o\">]}</span>\n</code></pre></div>\n<p>Beyond the potential difficulty of implementing this, there is also the fact that the command mode should act in a similar way. For instance, if a given proof inside a command contains several sorries, then all these sorries must be collected in one proofstate. In short, we should have exactly one proofstate per declaration.</p>",
        "id": 513016000,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744975331
    },
    {
        "content": "<p>Oh I just realized, I think this is roughly what <a href=\"https://arxiv.org/pdf/2410.16429\">Pantograph</a> does if I am not mistaken <span class=\"user-mention\" data-user-id=\"599027\">@Leni Aniva</span> right? (among other new amazing features)</p>",
        "id": 513016682,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1744975723
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321854\">Auguste Poiroux</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/request.20for.20help.20on.20the.20REPL/near/513016682\">said</a>:</p>\n<blockquote>\n<p>Oh I just realized, I think this is roughly what <a href=\"https://arxiv.org/pdf/2410.16429\">Pantograph</a> does if I am not mistaken <span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> right? (among other new amazing features)</p>\n</blockquote>\n<p>yes this is one of the reasons why pantograph exists</p>",
        "id": 513058704,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1744992609
    },
    {
        "content": "<p>Pantograph has a solution for the problem discussed above, and it can verify the proof state at the end as well.</p>",
        "id": 513061513,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1744993803
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"872000\">@Matěj Kripner</span> <span class=\"user-mention\" data-user-id=\"572535\">@RexWang</span> here is a <a href=\"https://github.com/leanprover-community/repl/pull/90\">draft PR</a> attempting to solve the branching problem. It uses an approach similar to <a href=\"https://github.com/lenianiva/Pantograph/\">Pantograph</a> (I am in fact using the <code>sorryToHole</code> method from Pantograph to achieve that). Here is an example:<br>\nInput:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"cmd\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"example : 1 = 1 := by sorry\"</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"have h : 2 = 2 := by sorry\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"rfl\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"rfl\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Output:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"sorries\"</span><span class=\"o\">:</span>\n<span class=\"w\"> </span><span class=\"o\">[{</span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"w\">   </span><span class=\"s2\">\"pos\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"column\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">22</span><span class=\"o\">},</span>\n<span class=\"w\">   </span><span class=\"s2\">\"goal\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"⊢ 1 = 1\"</span><span class=\"o\">,</span>\n<span class=\"w\">   </span><span class=\"s2\">\"endPos\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"column\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">27</span><span class=\"o\">}}],</span>\n<span class=\"w\"> </span><span class=\"s2\">\"messages\"</span><span class=\"o\">:</span>\n<span class=\"w\"> </span><span class=\"o\">[{</span><span class=\"s2\">\"severity\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"warning\"</span><span class=\"o\">,</span>\n<span class=\"w\">   </span><span class=\"s2\">\"pos\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"column\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">},</span>\n<span class=\"w\">   </span><span class=\"s2\">\"endPos\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"column\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"o\">},</span>\n<span class=\"w\">   </span><span class=\"s2\">\"data\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"declaration uses 'sorry'\"</span><span class=\"o\">}],</span>\n<span class=\"w\"> </span><span class=\"s2\">\"env\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"proofStatus\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"Incomplete: open goals remain\"</span><span class=\"o\">,</span>\n<span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span>\n<span class=\"w\"> </span><span class=\"s2\">\"goals\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"this : 2 = 2</span><span class=\"se\">\\n</span><span class=\"s2\">⊢ 1 = 1\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"⊢ 2 = 2\"</span><span class=\"o\">]}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"proofStatus\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"Incomplete: open goals remain\"</span><span class=\"o\">,</span>\n<span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span>\n<span class=\"w\"> </span><span class=\"s2\">\"goals\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"⊢ 2 = 2\"</span><span class=\"o\">]}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"proofStatus\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"Completed\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"goals\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[]}</span>\n</code></pre></div>\n<p>This is work in progress, but feel free to try it and suggest improvements :)</p>",
        "id": 513382064,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1745233133
    },
    {
        "content": "<p>I was wondering how it is going to behave with <code>all_goals</code>, and it seems to work better than I expected (unless I am missing something):<br>\nInput:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"cmd\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"example : 1 = 1 := by sorry\"</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"have : 2 = 2 := by sorry\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"all_goals rfl\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Output:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"sorries\"</span><span class=\"o\">:</span>\n<span class=\"w\"> </span><span class=\"o\">[{</span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"w\">   </span><span class=\"s2\">\"pos\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"column\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">22</span><span class=\"o\">},</span>\n<span class=\"w\">   </span><span class=\"s2\">\"goal\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"⊢ 1 = 1\"</span><span class=\"o\">,</span>\n<span class=\"w\">   </span><span class=\"s2\">\"endPos\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"column\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">27</span><span class=\"o\">}}],</span>\n<span class=\"w\"> </span><span class=\"s2\">\"messages\"</span><span class=\"o\">:</span>\n<span class=\"w\"> </span><span class=\"o\">[{</span><span class=\"s2\">\"severity\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"warning\"</span><span class=\"o\">,</span>\n<span class=\"w\">   </span><span class=\"s2\">\"pos\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"column\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">},</span>\n<span class=\"w\">   </span><span class=\"s2\">\"endPos\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"column\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"o\">},</span>\n<span class=\"w\">   </span><span class=\"s2\">\"data\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"declaration uses 'sorry'\"</span><span class=\"o\">}],</span>\n<span class=\"w\"> </span><span class=\"s2\">\"env\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"proofStatus\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"Incomplete: open goals remain\"</span><span class=\"o\">,</span>\n<span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span>\n<span class=\"w\"> </span><span class=\"s2\">\"goals\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"this : 2 = 2</span><span class=\"se\">\\n</span><span class=\"s2\">⊢ 1 = 1\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"⊢ 2 = 2\"</span><span class=\"o\">]}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"proofStatus\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"Completed\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"goals\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[]}</span>\n</code></pre></div>",
        "id": 513416522,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1745248144
    },
    {
        "content": "<p>Another way to address branching would be disentangling individual goals completely (apart from Metavariables), and copying goals if needed similar to Aesop. I believe this was the idea used in ABEL.</p>",
        "id": 513440690,
        "sender_full_name": "Simon Sorg",
        "timestamp": 1745256792
    },
    {
        "content": "<p>Yes indeed, if I understood well, <span class=\"user-mention\" data-user-id=\"872000\">@Matěj Kripner</span> is trying to implement that. I believe there is room and interest for both approaches. We can probably have both in the REPL, with an attribute to toggle one or the other. What do you think <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span>?</p>",
        "id": 513449675,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1745260383
    },
    {
        "content": "<p>An idea for later: we can use Lean <code>Task</code> to implement parallelized processing of multiple requests. I imagine this could be very useful in tactic mode for example. We could run <code>n</code> tactics in parallel on a goal within a single REPL instance.</p>",
        "id": 513652613,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1745338917
    },
    {
        "content": "<p>Just finished implementing the collection of sorry goals into one proof state per declaration in command mode in the <a href=\"https://github.com/leanprover-community/repl/pull/90\">draft PR</a>.<br>\nConcretely, this means that we should be able to implement <a href=\"https://arxiv.org/abs/2210.12283\">Draft, Sketch, and Prove</a> using Lean REPL and applying it to actual Lean projects in the wild.</p>\n<p>Example: let's say we have the following file:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>File content</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">add_comm_proved_formal_sketch</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_base</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_symm</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">      </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">add_rfl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">add_rfl2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n</div></div>\n<p>Then using <code>{\"path\": \"sketch_file.lean\", \"sorries\": \"grouped\"}</code>, we get one proof state with 4 goals for <code>add_comm_proved_formal_sketch</code> and one proof state with one goal for <code>add_rfl2</code>.</p>",
        "id": 513980065,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1745450737
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>REPL-output</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"sorries\"</span>:\n<span class=\"w\"> </span><span class=\"o\">[{</span><span class=\"s2\">\"proofState\"</span>:<span class=\"w\"> </span><span class=\"m\">0</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"pos\"</span>:<span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span>:<span class=\"w\"> </span><span class=\"m\">1</span>,<span class=\"w\"> </span><span class=\"s2\">\"column\"</span>:<span class=\"w\"> </span><span class=\"m\">70</span><span class=\"o\">}</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"parentDecl\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"add_comm_proved_formal_sketch\"</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"goals\"</span>:\n<span class=\"w\">   </span><span class=\"o\">[</span><span class=\"s2\">\"m : Nat\\n⊢ 0 + m = m\"</span>,\n<span class=\"w\">    </span><span class=\"s2\">\"m : Nat\\nh_base : 0 + m = m\\nh_symm : m + 0 = m\\n⊢ 0 + m = m + 0\"</span>,\n<span class=\"w\">    </span><span class=\"s2\">\"m n : Nat\\nih : n + m = m + n\\n⊢ n + 1 + m = m + (n + 1)\"</span>,\n<span class=\"w\">    </span><span class=\"s2\">\"m : Nat\\nh_base : 0 + m = m\\n⊢ m + 0 = m\"</span><span class=\"o\">]</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"endPos\"</span>:<span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span>:<span class=\"w\"> </span><span class=\"m\">8</span>,<span class=\"w\"> </span><span class=\"s2\">\"column\"</span>:<span class=\"w\"> </span><span class=\"m\">24</span><span class=\"o\">}}</span>,\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"s2\">\"proofState\"</span>:<span class=\"w\"> </span><span class=\"m\">1</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"pos\"</span>:<span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span>:<span class=\"w\"> </span><span class=\"m\">11</span>,<span class=\"w\"> </span><span class=\"s2\">\"column\"</span>:<span class=\"w\"> </span><span class=\"m\">49</span><span class=\"o\">}</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"parentDecl\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"add_rfl2\"</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"goals\"</span>:<span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"⊢ ∀ (n m : Nat), n + m = n + m\"</span><span class=\"o\">]</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"endPos\"</span>:<span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span>:<span class=\"w\"> </span><span class=\"m\">11</span>,<span class=\"w\"> </span><span class=\"s2\">\"column\"</span>:<span class=\"w\"> </span><span class=\"m\">57</span><span class=\"o\">}}]</span>,\n<span class=\"w\"> </span><span class=\"s2\">\"messages\"</span>:\n<span class=\"w\"> </span><span class=\"o\">[{</span><span class=\"s2\">\"severity\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"warning\"</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"pos\"</span>:<span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span>:<span class=\"w\"> </span><span class=\"m\">1</span>,<span class=\"w\"> </span><span class=\"s2\">\"column\"</span>:<span class=\"w\"> </span><span class=\"m\">8</span><span class=\"o\">}</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"endPos\"</span>:<span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span>:<span class=\"w\"> </span><span class=\"m\">1</span>,<span class=\"w\"> </span><span class=\"s2\">\"column\"</span>:<span class=\"w\"> </span><span class=\"m\">37</span><span class=\"o\">}</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"data\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"declaration uses 'sorry'\"</span><span class=\"o\">}</span>,\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"s2\">\"severity\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"info\"</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"pos\"</span>:<span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span>:<span class=\"w\"> </span><span class=\"m\">10</span>,<span class=\"w\"> </span><span class=\"s2\">\"column\"</span>:<span class=\"w\"> </span><span class=\"m\">0</span><span class=\"o\">}</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"endPos\"</span>:<span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span>:<span class=\"w\"> </span><span class=\"m\">10</span>,<span class=\"w\"> </span><span class=\"s2\">\"column\"</span>:<span class=\"w\"> </span><span class=\"m\">62</span><span class=\"o\">}</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"data\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"Goals accomplished!\"</span><span class=\"o\">}</span>,\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"s2\">\"severity\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"warning\"</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"pos\"</span>:<span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span>:<span class=\"w\"> </span><span class=\"m\">11</span>,<span class=\"w\"> </span><span class=\"s2\">\"column\"</span>:<span class=\"w\"> </span><span class=\"m\">8</span><span class=\"o\">}</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"endPos\"</span>:<span class=\"w\"> </span><span class=\"o\">{</span><span class=\"s2\">\"line\"</span>:<span class=\"w\"> </span><span class=\"m\">11</span>,<span class=\"w\"> </span><span class=\"s2\">\"column\"</span>:<span class=\"w\"> </span><span class=\"m\">16</span><span class=\"o\">}</span>,\n<span class=\"w\">   </span><span class=\"s2\">\"data\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"declaration uses 'sorry'\"</span><span class=\"o\">}]</span>,\n<span class=\"w\"> </span><span class=\"s2\">\"env\"</span>:<span class=\"w\"> </span><span class=\"m\">0</span><span class=\"o\">}</span>\n</code></pre></div>\n</div></div>\n<p>We can then prove, with kernel check at the end, the two theorems as follows:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Input-commands</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"apply Nat.zero_add\"</span>,<span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span>:<span class=\"w\"> </span><span class=\"m\">0</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"rw [h_base, h_symm]\"</span>,<span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span>:<span class=\"w\"> </span><span class=\"m\">2</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"rw [Nat.succ_add, Nat.add_succ, ih]\"</span>,<span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span>:<span class=\"w\"> </span><span class=\"m\">3</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"apply Nat.add_zero\"</span>,<span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span>:<span class=\"w\"> </span><span class=\"m\">4</span><span class=\"o\">}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"tactic\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"(\\nintros; rfl)\"</span>,<span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span>:<span class=\"w\"> </span><span class=\"m\">1</span><span class=\"o\">}</span>\n</code></pre></div>\n</div></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Output</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code><span class=\"o\">{</span><span class=\"s2\">\"proofStatus\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"Incomplete: open goals remain\"</span>,\n<span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span>:<span class=\"w\"> </span><span class=\"m\">2</span>,\n<span class=\"w\"> </span><span class=\"s2\">\"goals\"</span>:\n<span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"m : Nat\\nh_base : 0 + m = m\\nh_symm : m + 0 = m\\n⊢ 0 + m = m + 0\"</span>,\n<span class=\"w\">  </span><span class=\"s2\">\"m n : Nat\\nih : n + m = m + n\\n⊢ n + 1 + m = m + (n + 1)\"</span>,\n<span class=\"w\">  </span><span class=\"s2\">\"m : Nat\\nh_base : 0 + m = m\\n⊢ m + 0 = m\"</span><span class=\"o\">]}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"proofStatus\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"Incomplete: open goals remain\"</span>,\n<span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span>:<span class=\"w\"> </span><span class=\"m\">3</span>,\n<span class=\"w\"> </span><span class=\"s2\">\"goals\"</span>:\n<span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"m n : Nat\\nih : n + m = m + n\\n⊢ n + 1 + m = m + (n + 1)\"</span>,\n<span class=\"w\">  </span><span class=\"s2\">\"m : Nat\\nh_base : 0 + m = m\\n⊢ m + 0 = m\"</span><span class=\"o\">]}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"proofStatus\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"Incomplete: open goals remain\"</span>,\n<span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span>:<span class=\"w\"> </span><span class=\"m\">4</span>,\n<span class=\"w\"> </span><span class=\"s2\">\"goals\"</span>:<span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"m : Nat\\nh_base : 0 + m = m\\n⊢ m + 0 = m\"</span><span class=\"o\">]}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"proofStatus\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"Completed\"</span>,<span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span>:<span class=\"w\"> </span><span class=\"m\">5</span>,<span class=\"w\"> </span><span class=\"s2\">\"goals\"</span>:<span class=\"w\"> </span><span class=\"o\">[]}</span>\n\n<span class=\"o\">{</span><span class=\"s2\">\"proofStatus\"</span>:<span class=\"w\"> </span><span class=\"s2\">\"Completed\"</span>,<span class=\"w\"> </span><span class=\"s2\">\"proofState\"</span>:<span class=\"w\"> </span><span class=\"m\">6</span>,<span class=\"w\"> </span><span class=\"s2\">\"goals\"</span>:<span class=\"w\"> </span><span class=\"o\">[]}</span>\n</code></pre></div>\n</div></div>\n<p>Since the tactic mode also support sketching (i.e. collecting sorry goals), we can do recursive sketching, i.e. applying the Draft, Sketch, and Prove approach recursively on the sub-lemmas it creates.</p>",
        "id": 513980155,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1745450783
    },
    {
        "content": "<p>I created a batch repl command that supports multithreading via the <code>Task</code> monad: <a href=\"https://github.com/leanprover-community/repl/pull/93\">https://github.com/leanprover-community/repl/pull/93</a></p>",
        "id": 514841724,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1745853613
    },
    {
        "content": "<p>I'd like to again ask for help getting the REPL working on <code>v4.20.0-rc2</code>. I've created <a href=\"https://github.com/leanprover-community/repl/pull/100\">https://github.com/leanprover-community/repl/pull/100</a> doing the basics, but tests are failing: when we unpickle a state the values of definitions are not available.</p>\n<p>This is surely a result of the new work on the module system, but I can't immediately see what is wrong: in particular whenever we call <code>importModules</code> the default value of <code>level : OLeanLevel</code> should be <code>private</code>, giving us access to everything.</p>",
        "id": 516148267,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1746437263
    }
]