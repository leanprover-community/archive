[
    {
        "content": "<p>I am starting a <a href=\"https://github.com/GasStationManager/ArtificialAlgorithms\">repo</a> of verified algorithms in Lean, implemented and proved by AIs. Primary goal of the repo is to serve as a place for sharing examples, recipes, and experiences on AI-assisted coding and verification of code. Secondary goal is to be potentially useful as building blocks.</p>\n<p>Contributions are welcome and appreciated! (Already got one from <span class=\"user-mention\" data-user-id=\"511228\">@Huỳnh Trần Khanh</span>). PRs welcome. Just do your favorite algorithm! Rule is: human-verified specification, machine-checked proofs. Please document your process.</p>",
        "id": 531902412,
        "sender_full_name": "GasStationManager",
        "timestamp": 1753899402
    },
    {
        "content": "<p>Is it necessary to use AI assistance?</p>",
        "id": 531906802,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1753901020
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Artificial.20Algorithms/near/531906802\">said</a>:</p>\n<blockquote>\n<p>Is it necessary to use AI assistance?</p>\n</blockquote>\n<p>This repo is pretty AI-focused, but I am also open to human-implemented verified algorithms if they can be used by AIs: E.g. if you implement a verified algorithm, and then demonstrate that an AI can be taught to use your algorithm to solve a task, that counts too.</p>",
        "id": 531910635,
        "sender_full_name": "GasStationManager",
        "timestamp": 1753902368
    },
    {
        "content": "<p>Or, demonstrations of algorithmic and/or proving techniques that could be generalized by AIs to solve other tasks. E.g. <a href=\"https://github.com/GasStationManager/ArtificialAlgorithms/blob/main/ArtificialAlgorithms/DynamicProgramming/Memoization.lean\">here</a> I manually did an example of memoization with correctness proof, and then prompted Sonnet to solve something else with memoization. Could something similar be done for, eg greedy methods?</p>",
        "id": 531944305,
        "sender_full_name": "GasStationManager",
        "timestamp": 1753915169
    },
    {
        "content": "<p>do these models \"remember\" something if I name it. For example, if I explain memoization and ask it to assign the name \"memoization\" to the technique, can it recall what I explained?</p>",
        "id": 532021346,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1753953298
    },
    {
        "content": "<p>you can tell Claude to take notes in a file</p>",
        "id": 532021665,
        "sender_full_name": "(deleted)",
        "timestamp": 1753953389
    },
    {
        "content": "<p>this repo is in a very early stage</p>",
        "id": 532021988,
        "sender_full_name": "(deleted)",
        "timestamp": 1753953482
    },
    {
        "content": "<p>:&lt;</p>",
        "id": 532021995,
        "sender_full_name": "(deleted)",
        "timestamp": 1753953483
    },
    {
        "content": "<p>I have my own full time job <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span> and GasStationManager also works full time. I probably know more about proving the correctness of algorithms than the average person</p>",
        "id": 532022212,
        "sender_full_name": "(deleted)",
        "timestamp": 1753953543
    },
    {
        "content": "<p>speaking of greedy methods</p>",
        "id": 532023214,
        "sender_full_name": "(deleted)",
        "timestamp": 1753953821
    },
    {
        "content": "<p>every greedy algorithm is its own beast. I'm not even sure if the base knowledge of existing LLMs can handle greedy algorithms</p>",
        "id": 532023378,
        "sender_full_name": "(deleted)",
        "timestamp": 1753953862
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span> I feel like you must video record the process of using AI to prove algorithms. Because looks like you keep achieving amazing results while I achieved very little with generic LLMs.</p>",
        "id": 532025076,
        "sender_full_name": "(deleted)",
        "timestamp": 1753954335
    },
    {
        "content": "<p>I believe it's possible to achieve amazing feats with LLMs. But work must be done to create the perfect environment</p>",
        "id": 532026110,
        "sender_full_name": "(deleted)",
        "timestamp": 1753954611
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"511228\">@Huỳnh Trần Khanh</span> those would currently be extremely long videos :&lt;<br>\nI had to upgrade to the $100 Max plan for Claude. Even then it took multiple sessions over multiple days to do one of the divide-and-conquer algorithms.</p>\n<p>(I do think proving divide-and-conquer algorithms can be sometimes trickier, as you usually need some additional insight as to why the algorithm works; usually taking advantage of some underlying mathematical structure, e.g. transitivity of <code>&lt;</code> for binary search and quickselect, and associativity of addition for max subarray sum.) </p>\n<p>Part of the motivation for doing these exercises is to identify the pain points, and perhaps improving the tooling. One observation is that as the source code gets long, the LLMs will struggle to keep it in their context window. One thing I found sometimes helpful is to (ask the AI to) factor out lemmas and then send them to be proved separately (one can imagine automating this in an agentic framework). But the AI may later forget those lemmas existed. It would be helpful to provide the AI with a \"summary overview\" of the file to keep in its context. The crude version would be to ask the AI to include a <code>#check</code> for each lemma / theorem it created.</p>",
        "id": 532053381,
        "sender_full_name": "GasStationManager",
        "timestamp": 1753963015
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> The memory capabilities of current AIs are not very mature yet. You could ask Claude to take notes but may want to inspect the notes afterwards to make sure. Alternatively, once this repo becomes more comprehensive, could get it indexed by a search tool e.g. <a href=\"https://www.leanexplore.com/\">LeanExplore</a>, so that when the AI search for \"memoization\", it will retrieve the example.</p>",
        "id": 532057888,
        "sender_full_name": "GasStationManager",
        "timestamp": 1753964134
    },
    {
        "content": "<p>Here's one that might be of interest to others: I was trying to formalize the value iteration algorithm for Markov Decision Processes (and hoping to make the AIs do most of the work). </p>\n<p>I wanted the code to be runnable, while still possible to prove properties about, so chose to do the implementation in rational numbers (Rat). We were able to prove that the map contracts; but to prove convergence, traditionally the proof will need the Banach fixed point theorem, which would only work for Real numbers (and hence noncomputable). We ended up going with the following plan:  prove convergence using a (noncomputable) definition of the value iteration algorithm with Reals, then have a computable definition of the algorithm with rationals, then prove that the rational version and the Real version give equal results, when given a rational input.</p>\n<p><a href=\"https://github.com/GasStationManager/ArtificialAlgorithms/blob/main/ArtificialAlgorithms/AI/ValueIterationComplete.lean\">Here's the proof</a>.  Much of it done in Claude Code. It took quite a while, and was helped somewhat by the recent release of Opus 4.1 and GPT 5 which made progress on individual lemmas.</p>",
        "id": 534850849,
        "sender_full_name": "GasStationManager",
        "timestamp": 1755470360
    },
    {
        "content": "<p>This does make me more hopeful that some of the more \"numerical\" algorithms could be runnable and verifiable at the same time; e.g. if we want to use gradient descent, we could have a computable version and an equivalent Real version, and use theory from <a href=\"https://github.com/optsuite/optlib?tab=readme-ov-file\">optlib</a> to prove optimality.</p>",
        "id": 534851024,
        "sender_full_name": "GasStationManager",
        "timestamp": 1755470634
    },
    {
        "content": "<p><a href=\"https://www.asciinema.org/\">https://www.asciinema.org/</a></p>",
        "id": 534870530,
        "sender_full_name": "(deleted)",
        "timestamp": 1755493268
    },
    {
        "content": "<p>Consider using this so I can learn your tricks</p>",
        "id": 534870543,
        "sender_full_name": "(deleted)",
        "timestamp": 1755493276
    },
    {
        "content": "<p>Or you can just export the Claude Code conversation</p>",
        "id": 534870665,
        "sender_full_name": "(deleted)",
        "timestamp": 1755493399
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776090\">GasStationManager</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Artificial.20Algorithms/near/534850849\">said</a>:</p>\n<blockquote>\n<p>I wanted the code to be runnable, while still possible to prove properties about, so chose to do the implementation in rational numbers (Rat).</p>\n</blockquote>\n<p>As a style point, I think it’s better work over the combination of the reals and floats rather than try for an intermediate. I.e., state algorithms that can work over either, prove theorems over reals, then use that as informal evidence that a similar property has some chance of being true over floats. The intermediate thing of proving theorems about rationals is not that interesting, as the theorem is that there is an exponentially slower version of the algorithm you care about and the slow version has some property; one might as replace exponential with infinite.</p>",
        "id": 534929307,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1755516748
    },
    {
        "content": "<p>Yeah. I think proving the algorithm works with IEEE 754 floats would be interesting</p>",
        "id": 534933121,
        "sender_full_name": "(deleted)",
        "timestamp": 1755517936
    },
    {
        "content": "<p>Hmm... Do we have an IEEE 754 library for Lean?</p>",
        "id": 534933315,
        "sender_full_name": "(deleted)",
        "timestamp": 1755517974
    },
    {
        "content": "<p>Not really, no:<br>\n<a href=\"#narrow/channel/270676-lean4/topic/IEEE.20754.20Float/near/395456271\">https://leanprover.zulipchat.com/#narrow/channel/270676-lean4/topic/IEEE.20754.20Float/near/395456271</a></p>\n<p><a href=\"#narrow/channel/113489-new-members/topic/Polymorphic.20Round.20Function/near/509046509\">https://leanprover.zulipchat.com/#narrow/channel/113489-new-members/topic/Polymorphic.20Round.20Function/near/509046509</a></p>\n<p><a href=\"#narrow/channel/113489-new-members/topic/Proofs.20about.20floats.20and.20verifiable.20software/near/427956048\">https://leanprover.zulipchat.com/#narrow/channel/113489-new-members/topic/Proofs.20about.20floats.20and.20verifiable.20software/near/427956048</a></p>",
        "id": 534977511,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755531605
    },
    {
        "content": "<p>It's one of those that everyone says we should do, but no one has, because it's painful and the rewards (the theorems you can prove) are few :)</p>",
        "id": 534977606,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755531635
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"514145\">@Geoffrey Irving</span> it is a good point; this is a proof of concept,  I do want to eventually do this with floating point numbers, but be able to formally prove an error bound between the float and the Real version. Was meaning to ask you, would it be possible to use the floating number of the interval library to prove guarantees about algorithms using floats?</p>",
        "id": 534977608,
        "sender_full_name": "GasStationManager",
        "timestamp": 1755531636
    },
    {
        "content": "<p>an early stage version with the prerequisites and some core API and theorems for Floats are here,<br>\n<a href=\"https://github.com/mkaratarakis/HopfieldNet/blob/master/HopfieldNet/floats/Flocqv2.lean\">https://github.com/mkaratarakis/HopfieldNet/blob/master/HopfieldNet/floats/Flocqv2.lean</a></p>",
        "id": 534979486,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1755532235
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Artificial.20Algorithms/near/534977606\">said</a>:</p>\n<blockquote>\n<p>It's one of those that everyone says we should do, but no one has, because it's painful and the rewards (the theorems you can prove) are few :)</p>\n</blockquote>\n<p>It's 2025 and the field of formally verifying software is still small. We can't confidently say anything yet.</p>",
        "id": 534981341,
        "sender_full_name": "(deleted)",
        "timestamp": 1755532830
    },
    {
        "content": "<p>We don't even have a repository of formalized Codeforces problems.</p>",
        "id": 534981482,
        "sender_full_name": "(deleted)",
        "timestamp": 1755532876
    },
    {
        "content": "<p>I tried to make one, then my professor made me tweak the compiler so it emits blockchain code—as he believed there was no value in such a repository, and blockchain technology was more useful, and then the repository now serves as a general demonstration of how software verification can be done.</p>",
        "id": 534981880,
        "sender_full_name": "(deleted)",
        "timestamp": 1755533003
    },
    {
        "content": "<p><span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span> maybe this repository could achieve what I couldn't achieve</p>",
        "id": 534982231,
        "sender_full_name": "(deleted)",
        "timestamp": 1755533116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776090\">GasStationManager</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Artificial.20Algorithms/near/534977608\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span> it is a good point; this is a proof of concept,  I do want to eventually do this with floating point numbers, but be able to formally prove an error bound between the float and the Real version. Was meaning to ask you, would it be possible to use the floating number of the interval library to prove guarantees about algorithms using floats?</p>\n</blockquote>\n<p>This is misinterpreting what I said: I’m not claiming you should prove something over floats, but rather than you should replace your Rat proofs with Real.</p>\n<p>To your question, though: unfortunately the interval library doesn’t help in its current form, as it doesn’t establish tightness of the bounds.</p>",
        "id": 534984160,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1755533854
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"514145\">@Geoffrey Irving</span> Much of the proof is over Reals; the Rat part is just to show equivalence between the Rat and Real versions of the algorithm. To make this work for floats, one just need to replace the latter part. </p>\n<p>And the bounds do not need to be tight. E.g. we can start with something like for a: float and b: float, the difference between (a+b) and (a:Real)+(b:Real) is bounded by some c:float. (Note that the value iteration algorithn only uses +, * and max). And with numerical algorithms, we expect the quality of the bounds will depend on some kind of condition number on the  inputs.</p>",
        "id": 534987656,
        "sender_full_name": "GasStationManager",
        "timestamp": 1755535388
    },
    {
        "content": "<p>Right, and my claim is that the Rat part is providing no value and can be deleted. :)</p>",
        "id": 534987786,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1755535462
    },
    {
        "content": "<p>I think using Rat is just an arbitrary decision. Not good, but not worse than Real.</p>",
        "id": 534987983,
        "sender_full_name": "(deleted)",
        "timestamp": 1755535547
    },
    {
        "content": "<p>To clarify, it’s not just that the interval library doesn’t show the bounds are tight: all the theorems allow them to be <em>arbitrarily</em> loose. In fact they are pretty tight, but this is checked only via unit test.</p>",
        "id": 534988015,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1755535559
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"511228\">Huỳnh Trần Khanh</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Artificial.20Algorithms/near/534987983\">said</a>:</p>\n<blockquote>\n<p>I think using Rat is just an arbitrary decision. Not good, but not worse than Real.</p>\n</blockquote>\n<p>It will be much worse as soon as you take an exp. :)</p>",
        "id": 534988077,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1755535583
    },
    {
        "content": "<p>I think the value of the Rat part is to go from a noncomputable algorithm over the Reals to a computable algorithm. Granted that it would be exponential and not something that we want to run in practice. And that's why I am very interested in making a float version with error bounds. Will check out the work linked by <span class=\"user-mention\" data-user-id=\"779253\">@Matteo Cipollina</span>  as well.</p>",
        "id": 534990821,
        "sender_full_name": "GasStationManager",
        "timestamp": 1755536881
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span> yes, combining classical and computable reals is feasible, we did it in the corn/math-classes library some in Rocq, some 20years ago.<br>\n<a href=\"https://c-corn.github.io/pub.html\">https://c-corn.github.io/pub.html</a><br>\n<a href=\"https://math-classes.github.io/\">https://math-classes.github.io/</a> (this also introduced the way type classes are now used in Lean)</p>\n<p>Specifically, in this paper:<br>\nCezary Kaliszyk and Russell O'Connor. Computing with Classical Real Numbers. Journal of Formalized Reasoning, Vol. 2, No. 1, 2009, Pages 27--39<br>\nIdeally, one would want proof transfer in the style of HoTT or Trocq (<span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span> ), but the full automation of this is still in progress.</p>\n<p>One gets reasonable computation speed by using \"dyadic\" rationals (akin to floats, but simpler): the denominators are factors of 2.<br>\nComputer certified efficient exact reals in Coq, Robbert Krebbers and Bas Spitters. In Proceedings of Calculemus/MKM 2011, volume 6824 of LNAI, pages 90–106, 2011.<br>\n<a href=\"http://arxiv.org/abs/1105.2751\">http://arxiv.org/abs/1105.2751</a></p>\n<p>There is some interest in implementing these in Lean (<span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> ).</p>\n<p><span class=\"user-mention\" data-user-id=\"514145\">@Geoffrey Irving</span>  There is an enormous amount of work, and a book, on formalizing floats in the Rocq ecosystem: <br>\n<a href=\"https://guillaume.melquiond.fr/\">https://guillaume.melquiond.fr/</a><br>\n<a href=\"https://pages.saclay.inria.fr/sylvie.boldo/\">https://pages.saclay.inria.fr/sylvie.boldo/</a></p>\n<p>The capla language is one of Guillaume's latest projects:<br>\n<a href=\"https://fresco.gitlabpages.inria.fr/capla/language/\">https://fresco.gitlabpages.inria.fr/capla/language/</a></p>",
        "id": 535073043,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1755589879
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> Thanks for the helpful pointers!<br>\nI am interested in practical computation that can also be verified, so would be looking particularly into floats and dyadic rationals. Do you know of papers / examples of formalizing numerical algorithms, perhaps built on top of the float libary in rocq?</p>",
        "id": 535212107,
        "sender_full_name": "GasStationManager",
        "timestamp": 1755642977
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span>, I have a preliminary implementation of dyadic rationals at <a href=\"https://github.com/leanprover/lean4/pull/9993\">lean#9993</a>. If you'd like to take a look at that and push proofs for any of the sorries that would be lovely! (Or anyone else, of course. I've just  spun up a claude session that is working on it, but I have low expectations that it will make any progress without close supervision.)</p>",
        "id": 535213059,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1755643816
    },
    {
        "content": "<p>How do I push</p>",
        "id": 535213202,
        "sender_full_name": "(deleted)",
        "timestamp": 1755643932
    },
    {
        "content": "<p>I want to try</p>",
        "id": 535213227,
        "sender_full_name": "(deleted)",
        "timestamp": 1755643953
    },
    {
        "content": "<p>You can try just by pulling, you only need to push if you make progress. :-)</p>",
        "id": 535213444,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1755644126
    },
    {
        "content": "<p>Looks like it means I'll just post my code here when I make progress. Given that there's already a force push.</p>",
        "id": 535213625,
        "sender_full_name": "(deleted)",
        "timestamp": 1755644299
    },
    {
        "content": "<p>Let's give Claude Code a chance. Maybe clever prompting really helps. Maybe not. Let's see. If Claude Code can't do it I can</p>",
        "id": 535213976,
        "sender_full_name": "(deleted)",
        "timestamp": 1755644533
    },
    {
        "content": "<p>Here's the first theorem (Opus 4.1, Claude desktop with LeanTool and LeanExplore):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">trailingZeros_two_mul_add_one</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">trailingZeros</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">trailingZeros</span><span class=\"w\"> </span><span class=\"n\">trailingZeros</span><span class=\"bp\">.</span><span class=\"n\">aux</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Key fact: (2 * i + 1) % 2 = 1</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">add_emod</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">mul_emod_right</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Now we need to handle the match on k</span>\n<span class=\"w\">  </span><span class=\"n\">split</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"c1\">-- Case k = 0</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"c1\">-- Case k = succ n for some n</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 535215041,
        "sender_full_name": "GasStationManager",
        "timestamp": 1755645514
    },
    {
        "content": "<p>It is having some trouble with the second theorem <code>theorem trailingZeros_two_mul (i : Int) : Int.trailingZeros (2 * i) = Int.trailingZeros i + 1 := sorry</code>, as it doesn't know what to do when i=0.</p>\n<p>Should the statement have a special case for i=0?</p>",
        "id": 535215144,
        "sender_full_name": "GasStationManager",
        "timestamp": 1755645590
    },
    {
        "content": "<p>yes definitely</p>",
        "id": 535216327,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755646688
    },
    {
        "content": "<p>take a hypothesis that <code>i ≠ 0</code> (and then make <code>i</code> implicit)</p>",
        "id": 535216354,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755646708
    },
    {
        "content": "<p>Thanks. I'd golf that to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">trailingZeros_two_mul_add_one</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">trailingZeros</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">trailingZeros</span><span class=\"w\"> </span><span class=\"n\">trailingZeros</span><span class=\"bp\">.</span><span class=\"n\">aux</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span>\n</code></pre></div>\n<p>I've commited that, as well as my Claude sessions which filled in 3/4 sorries in <code>toRat</code>. (It didn't do much before returning control to me, and I was elsewhere.)</p>",
        "id": 535219087,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1755649043
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span> There are a number of options for numerical computation. We use Cauchy sequences/nets of dyadics/floats here:</p>\n<ul>\n<li><strong>Computer certified efficient exact reals in Coq</strong>, Robbert Krebbers and Bas Spitters. In <em>Proceedings of Calculemus/MKM 2011</em>, volume 6824 of <em>LNAI</em>, pages 90–106, 2011. [<a href=\"http://arxiv.org/abs/1105.2751\">arXiv</a>]</li>\n</ul>\n<p>It's fairly efficient, see the timings in the paper (and correct for Moore's law... ;-) ).</p>\n<p>Interval computation is faster. For that one would look at coq-interval by Guillaume or the PhD-thesis of Fabian Immler in Isabelle.</p>\n<p>Cauchy sequences compute the error backwards (epsilon-delta), one can also use forward error propagation. Just use interval computation, if the resulting error is too big, restart with a small interval. This is implemented in IRRAM for instance. This leads to realizability approach to real computation.<br>\nThis approach is followed here:<br>\n<a href=\"https://arxiv.org/abs/2202.00891\">https://arxiv.org/abs/2202.00891</a><br>\n<a href=\"https://arxiv.org/abs/2410.13508\">https://arxiv.org/abs/2410.13508</a></p>\n<p>For floats there is the verinum project: <a href=\"https://verinum.org/\">https://verinum.org/</a></p>",
        "id": 535265655,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1755679201
    },
    {
        "content": "<p>Since Markov Decision Processes and floating point numbers were mentioned, I think this paper by some colleagues might be interesting, even though they use Isabelle: <a href=\"https://arxiv.org/abs/2501.10127\">https://arxiv.org/abs/2501.10127</a></p>",
        "id": 535354420,
        "sender_full_name": "Benedikt Peterseim",
        "timestamp": 1755708147
    },
    {
        "content": "<p>I did a bit of further explorations on Value Iteration and computation. Recall that a drawback of the exact value iteration implementation with rationals above is that computation cost (in time and space) could blow up.</p>\n<p>In <a href=\"https://github.com/GasStationManager/ArtificialAlgorithms/blob/main/ArtificialAlgorithms/AI/ApproxValueIterationInt.lean\">this file</a>, I asked Codex CLI to formalize an approximate variant of value iteration with the simplest rounding scheme: do the Bellman operator computation in exact Rational arithmetic, then round to the nearest integer. Then repeat. This ends up working sufficiently well for value iteration (and other contraction maps): the rounding errors accumulate but gets squashed by the discount factor, so we end up with a constant error bound that depends on the discount factor. In practice you would pre- scale up the reward function by an appropriate amount so that this is acceptable. (Or equivalently round to the nearest integer multiple of some h.)</p>\n<p>This was done mainly in Codex CLI by GPT-5 (med and high), with two lemmas solved separately by Sonnet 4. My first time trying Codex CLI on a larger Lean proof, and I must say I liked the experience. OpenAI's models have always been strong at informal reasoning, now their Lean ability seems to be catching up to Claude.</p>\n<p>Will continue exploring as I learn more about the various numerical approached mentioned earlier this thread. For value iteration, much of the current proof could be adapted, e.g. if we instead use dyadics / or a future float library, as long as one can prove a constant error bound for one step of the Bellman iteration implementation, the rest of the proof can  be reused to show a constant error bound on value iteration.</p>",
        "id": 540545167,
        "sender_full_name": "GasStationManager",
        "timestamp": 1758324970
    },
    {
        "content": "<p>Regarding computable reals, in CoRN there is a notion for the reals called Real Number Structure (RNS) which defines any instance of the reals as a complete ordered Archimedean field. AFAIK the history is roughly as follows : Russel had a version of the constructible reals <code>fast</code> and he tried to prove that they form an RNS. However, it was easier to instead build a bijection between his reals and an existing model of the reals in CoRN by Niqui using a theorem that all real number structures are isomorphic. Then Robbert and Bas  optimized Russel's code using typeclasses resulting in another implementation called <code>faster</code> . Conceptually, one can vary the base field - for example, by working over machine integers instead of integers. However, the \"faster\" implementation was not shown to be an RNS.</p>\n<p>Together with <span class=\"user-mention\" data-user-id=\"779253\">@Matteo Cipollina</span> , we have been working on constructible reals and on porting CoRN's RNS and <code>fast</code>. In addition, Russel provides a Haskell implementation at the end of his paper, which we have already ported into Lean. <span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> , I heard from Freek that you've been working on constructible reals too. There is also <span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span> 's <code>ComputableReals</code> that follows a different approach. </p>\n<p>This raises the question: do we want the notion of RNS in mathlib too? Presumably we would need the bijection between the computable and noncomputable reals. Maybe the work of defining this and showing that it is an isomorphism is similar to showing that all RNSs are isomorphic?</p>",
        "id": 540856254,
        "sender_full_name": "Michail Karatarakis",
        "timestamp": 1758560287
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"454183\">Michail Karatarakis</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Artificial.20Algorithms/near/540856254\">said</a>:</p>\n<blockquote>\n<p>This raises the question: do we want the notion of RNS in mathlib too? Presumably we would need the bijection between the computable and noncomputable reals. Maybe the work of defining this and showing that it is an isomorphism is similar to showing that all RNSs are isomorphic?</p>\n</blockquote>\n<p>Is this similar to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConditionallyCompleteLinearOrderedField#doc\">docs#ConditionallyCompleteLinearOrderedField</a></p>",
        "id": 540875106,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758567116
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"454183\">@Michail Karatarakis</span> Thanks for the summary. That's roughly correct. For context, Russell did his PhD with me.<br>\nThen we did developed <a href=\"https://math-classes.github.io/\">math-classes</a>,  type classes for maths, with Eelis (<a href=\"http://dx.doi.org/10.1017/S0960129511000119\">http://dx.doi.org/10.1017/S0960129511000119</a>), which is the basis for type classes usage in Lean. <br>\nWe used this work with Robbert to make a faster and more modular implementation of the reals in math-classes .<br>\n<a href=\"https://c-corn.github.io/pub.html\">https://c-corn.github.io/pub.html</a></p>\n<p>Great you're porting the reals to Lean! <br>\nWhy did you choose to not to use the faster, type class based implementation?</p>\n<p>One more bit of information, the classical reals in the Rocq stdlib are now based on the constructive reals. Classical logic is only added in the end.</p>\n<p>Since you asked, I'm not porting the reals myself (but I'm very happy you are!). I was discussing with <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> (and others) that it would facilitate some of the issues they were having in their proofs.</p>\n<p>I'd be happy to discuss more...</p>",
        "id": 540958552,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1758616877
    },
    {
        "content": "<p><a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Discussion.3A.20ComputableReal/with/511549014\">#general &gt; Discussion: ComputableReal</a></p>",
        "id": 540967667,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1758619567
    }
]