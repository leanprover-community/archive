[
    {
        "content": "<p>Hi people! I noticed that many people didn't know about the <a href=\"https://centaur.stanford.edu/PyPantograph/frontend.html#track-checking\">track checking function</a> in Pantograph. It is useful for testing whole-file proofs.</p>\n<p>It checks whether a proof conforms to a spec file:</p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">def f : Nat -&gt; Nat := sorry</span>\n<span class=\"s2\">theorem property (n : Nat) : f n = n + 1 := sorry</span>\n<span class=\"s2\">\"\"\"</span>\n<span class=\"n\">dst</span> <span class=\"o\">=</span> <span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">def f (x : Nat) := x + 1</span>\n<span class=\"s2\">theorem property (n : Nat) : f n = n + 1 := rfl</span>\n<span class=\"s2\">\"\"\"</span>\n<span class=\"k\">await</span> <span class=\"n\">server</span><span class=\"o\">.</span><span class=\"n\">check_track_async</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>it detects tampering of definitions and introduction of additional axioms, but axioms that are present in both files are fine.</p>",
        "id": 554504339,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1762628998
    },
    {
        "content": "<p>Does it allow this?</p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">import Mathlib</span>\n\n<span class=\"s2\">theorem foo : { (x, y) | x * y &lt; 0} = ∅ := by</span>\n<span class=\"s2\">  sorry</span>\n<span class=\"s2\">\"\"\"</span>\n<span class=\"n\">dst</span> <span class=\"o\">=</span> <span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">import Mathlib</span>\n\n<span class=\"s2\">def bar := { (x, y) | x * y &lt; 0}</span>\n\n<span class=\"s2\">theorem foo : { (x, y) | x * y &lt; 0} = ∅ := by</span>\n<span class=\"s2\">  simp</span>\n<span class=\"s2\">\"\"\"</span>\n<span class=\"k\">await</span> <span class=\"n\">server</span><span class=\"o\">.</span><span class=\"n\">check_track_async</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">)</span>\n</code></pre></div>",
        "id": 554514152,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762639612
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Track.20checking.20function.20in.20Pantograph/near/554514152\">said</a>:</p>\n<blockquote>\n<p>Does it allow this?</p>\n<p><div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">import Mathlib</span>\n\n<span class=\"s2\">theorem foo : { (x, y) | x * y &lt; 0} = ∅ := by</span>\n<span class=\"s2\">  sorry</span>\n<span class=\"s2\">\"\"\"</span>\n<span class=\"n\">dst</span> <span class=\"o\">=</span> <span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">import Mathlib</span>\n\n<span class=\"s2\">def bar := { (x, y) | x * y &lt; 0}</span>\n\n<span class=\"s2\">theorem foo : { (x, y) | x * y &lt; 0} = ∅ := by</span>\n<span class=\"s2\">  simp</span>\n<span class=\"s2\">\"\"\"</span>\n<span class=\"k\">await</span> <span class=\"n\">server</span><span class=\"o\">.</span><span class=\"n\">check_track_async</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Yes. You're free to introduce as many non-axiom definitions as you want. Auxiliary inductives and structures are allowed too</p>",
        "id": 554515543,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1762641195
    },
    {
        "content": "<p>Right, the key thing there is that the meaning of the <code>|</code> changes as a result of the added <code>bar</code></p>",
        "id": 554515582,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762641244
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Track.20checking.20function.20in.20Pantograph/near/554515582\">said</a>:</p>\n<blockquote>\n<p>Right, the key thing there is that the meaning of the <code>|</code> changes as a result of the added <code>bar</code></p>\n</blockquote>\n<p>if it maps to a different symbol then check track will raise an error about tampering</p>",
        "id": 554515619,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1762641268
    },
    {
        "content": "<p>So just to check, that's \"yes, I checked\", and not \"yes, I'd hope so\"?</p>",
        "id": 554515626,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762641271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Track.20checking.20function.20in.20Pantograph/near/554515626\">said</a>:</p>\n<blockquote>\n<p>So just to check, that's \"yes, I checked\", and not \"yes, I'd hope so\"?</p>\n</blockquote>\n<p>There are unit tests in the Pantograph repo concerning this use case if you're interested</p>",
        "id": 554515655,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1762641295
    },
    {
        "content": "<p>To be super clear; in the first case the theorem is about <code>foo._match_1</code>, in the second case it is about <code>bar._match_1</code>. The two are equal, but not without agressive (and possibly in more contrived examples, recursive) unfolding</p>",
        "id": 554515673,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762641320
    },
    {
        "content": "<p>It is possible to do such unfolding but it is not enabled for this use case. Any divergence in the symbol representation will lead to an error</p>",
        "id": 554515815,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1762641496
    },
    {
        "content": "<p>So for my code sample above I guess the answer is \"no, it rejects it\"</p>",
        "id": 554516324,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762642028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Track.20checking.20function.20in.20Pantograph/near/554516324\">said</a>:</p>\n<blockquote>\n<p>So for my code sample above I guess the answer is \"no, it rejects it\"</p>\n</blockquote>\n<p>Yes. It is rejected. I'm testing if the existing matcher unfolding function can make it an acceptance instead</p>",
        "id": 554516885,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1762642672
    },
    {
        "content": "<blockquote>\n<p>The two are equal</p>\n</blockquote>\n<p>To be clear, you are saying the two versions of <code>foo</code> are <em>definitionally</em> equal?  Or something a bit nicer than that?  And to check this this, you would have to check for such equality between the before and after terms.  It is not enough alone to look just at the terms because one term has <code>foo._match_1</code> and the other has <code>bar._match_1</code>, right?</p>\n<p><span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span> How does <a href=\"https://github.com/GasStationManager/SafeVerify\">SafeVerify</a> behave on this example?  <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> how will <a href=\"#narrow/channel/270676-lean4/topic/FRO's.20new.20verifier/with/546672858\">your upcoming tool</a> behave on this example?</p>",
        "id": 554516974,
        "sender_full_name": "Jason Rute",
        "timestamp": 1762642796
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"599027\">@Leni Aniva</span> Is this tool similar to those two tools I just mentioned?  Can it verify multi-file proofs (something the current version of SafeVerify can't do)?</p>",
        "id": 554516989,
        "sender_full_name": "Jason Rute",
        "timestamp": 1762642807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Track.20checking.20function.20in.20Pantograph/near/554516989\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> Is this tool similar to those too I mentioned above.  Can it verify multi-file proofs (something the current version of SafeVerify can't do).?</p>\n</blockquote>\n<p>No it cannot verify multifile proofs because it would mean importing two Lean repos with the same name at the same time. I don't think Lean will allow this kind of operation.</p>",
        "id": 554517093,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1762642887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Track.20checking.20function.20in.20Pantograph/near/554516974\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>The two are equal</p>\n</blockquote>\n<p>To be clear, you are saying the two versions of <code>foo</code> are <em>definitionally</em> equal?  Or something a bit nicer than that?  And to check this this, you would have to check for such equality between the before and after terms.  It is not enough alone to look just at the terms because one term has <code>foo._match_1</code> and the other has <code>bar._match_1</code>, right?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"776090\">GasStationManager</span> How does <a href=\"https://github.com/GasStationManager/SafeVerify\">SafeVerify</a> behave on this example?  <span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> how will <a href=\"#narrow/channel/270676-lean4/topic/FRO's.20new.20verifier/with/546672858\">your upcoming tool</a> behave on this example?</p>\n</blockquote>\n<p>reject</p>",
        "id": 554517766,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1762643462
    },
    {
        "content": "<p>SafeVerify will reject too</p>",
        "id": 554517801,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1762643499
    },
    {
        "content": "<p>And they are not definitionally equal, they are at best provably equal. This kind of side effect from introducing other definitions is a bit tricky.</p>",
        "id": 554517850,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1762643547
    },
    {
        "content": "<p>Maybe aggressive matcher unfolding can lead to these two exprs being equal</p>",
        "id": 554517925,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1762643654
    },
    {
        "content": "<p>Note that you should not unfold using <code>matchMatcherApp?</code> if you want to be a trustworthy checker, it relies on unverified informations from env extensions</p>",
        "id": 554518138,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1762643907
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Track.20checking.20function.20in.20Pantograph/near/554518138\">said</a>:</p>\n<blockquote>\n<p>Note that you should not unfold using <code>matchMatcherApp?</code> if you want to be a trustworthy checker, it relies on unverified informations from env extensions</p>\n</blockquote>\n<p>Then how can this system unfold matchers in this case?</p>\n<p>Maybe the checker should just unfold every definition that is not present in the spec file.</p>",
        "id": 554518203,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1762643985
    },
    {
        "content": "<p>With my OpenBSD-paranoia-hat on I would say just don't do anything clever and reject, tricks like this will likely bite a trustworthy checker somewhere down the line. If you really want to unfold and avoid looking at env extensions at the same time you can just inspect the definition of the matcher from the environment.</p>",
        "id": 554518287,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1762644074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Track.20checking.20function.20in.20Pantograph/near/554518287\">said</a>:</p>\n<blockquote>\n<p>With my OpenBSD-paranoia-hat on I would say just don't do anything clever and reject, tricks like this will likely bite a trustworthy checker somewhere down the line. If you really want to unfold and avoid looking at env extensions at the same time you can just inspect the definition of the matcher from the environment.</p>\n</blockquote>\n<p>What if I just make unfolding of matchers an optional feature? All the constants still have to go through <code>replay</code> so they'll be checked for their type correctness</p>",
        "id": 554518974,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1762644758
    },
    {
        "content": "<p>Pantograph's definition unfolding function could make this example into an accept</p>",
        "id": 554518997,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1762644791
    },
    {
        "content": "<p>I found a way to achieve acceptance of this example without querying env extensions. The method is to unfold all definitions which are not in the intersection of spec and proof files.</p>",
        "id": 554519226,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1762645068
    },
    {
        "content": "<blockquote>\n<p>With my OpenBSD-paranoia-hat on</p>\n</blockquote>\n<p>I'm constantly trying to balance being paranoid of AI hacks and paranoid that I'm being too paranoid of AI hacks and thereby rejecting perfectly good code.  (Maybe I just need to switch to Metamath. <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span>)</p>",
        "id": 554519378,
        "sender_full_name": "Jason Rute",
        "timestamp": 1762645259
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Track.20checking.20function.20in.20Pantograph/near/554515673\">said</a>:</p>\n<blockquote>\n<p>To be super clear; in the first case the theorem is about <code>foo._match_1</code>, in the second case it is about <code>bar._match_1</code>. The two are equal, but not without agressive (and possibly in more contrived examples, recursive) unfolding</p>\n</blockquote>\n<p>Can you elaborate a bit more on what are the differences here?</p>\n<blockquote>\n<p>the meaning of the <code>|</code> changes as a result of the added <code>bar</code></p>\n</blockquote>\n<p>In which way does the meaning changes due to adding <code>bar</code>?</p>",
        "id": 563285346,
        "sender_full_name": "Marcelo Fornet",
        "timestamp": 1765488363
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456449\">Marcelo Fornet</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Track.20checking.20function.20in.20Pantograph/near/563285346\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Track.20checking.20function.20in.20Pantograph/near/554515673\">said</a>:</p>\n<blockquote>\n<p>To be super clear; in the first case the theorem is about <code>foo._match_1</code>, in the second case it is about <code>bar._match_1</code>. The two are equal, but not without agressive (and possibly in more contrived examples, recursive) unfolding</p>\n</blockquote>\n<p>Can you elaborate a bit more on what are the differences here?</p>\n<blockquote>\n<p>the meaning of the <code>|</code> changes as a result of the added <code>bar</code></p>\n</blockquote>\n<p>In which way does the meaning changes due to adding <code>bar</code>?</p>\n</blockquote>\n<p>Adding the <code>bar</code> definition changes how Lean internally represents <code>foo</code></p>",
        "id": 563285426,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1765488400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Track.20checking.20function.20in.20Pantograph/near/563285426\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"456449\">Marcelo Fornet</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Track.20checking.20function.20in.20Pantograph/near/563285346\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Track.20checking.20function.20in.20Pantograph/near/554515673\">said</a>:</p>\n<blockquote>\n<p>To be super clear; in the first case the theorem is about <code>foo._match_1</code>, in the second case it is about <code>bar._match_1</code>. The two are equal, but not without agressive (and possibly in more contrived examples, recursive) unfolding</p>\n</blockquote>\n<p>Can you elaborate a bit more on what are the differences here?</p>\n<blockquote>\n<p>the meaning of the <code>|</code> changes as a result of the added <code>bar</code></p>\n</blockquote>\n<p>In which way does the meaning changes due to adding <code>bar</code>?</p>\n</blockquote>\n<p>Adding the <code>bar</code> definition changes how Lean internally represents <code>foo</code></p>\n</blockquote>\n<p>why is that the case?</p>\n<p>sorry for being annoying, I'm genuinely curious about it</p>",
        "id": 563292662,
        "sender_full_name": "Marcelo Fornet",
        "timestamp": 1765491585
    },
    {
        "content": "<p>it has something to do with the elaborator generating auxiliary definitions. im not sure whats the exact process</p>",
        "id": 563292714,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1765491610
    },
    {
        "content": "<p>Auxiliary definitions are cached within a file based on their value, I think</p>",
        "id": 563751431,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1765784915
    },
    {
        "content": "<p>Note that one can work around this by keeping the target statement in a separate file as a definition that you just don't touch.</p>",
        "id": 563751533,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1765784954
    }
]