[
    {
        "content": "<p>From our discussions here about the exploit found by Deepseek Prover V2, one recommendation was that we (the AI researchers) need to deploy more robust proof checking. </p>\n<p>I think this is definitely needed; but the question is would that be sufficient. From what I can tell, the recent RL-trained prover models (Deepseek prover v2, Kimina prover, AlphaProof) all use the natural set up where the proof checker provide direct reward signals to the model. Which is fine if we know the proof checker is perfect. But if the proof checker has a flaw, with sufficient exploration the models will find it. And if that flaw helps the model to pass the proof checker, the model will exploit it to maximize its reward, which is the number of theorems \"proved\". So we will be in a constant arms race.</p>\n<p>I think we should accept the fact that our proof checker will occasionally contain bugs, and accordingly design our RL pipelines to be more robust. I'm just thinking aloud here, and want to throw a couple of ideas for discussion.</p>\n<ul>\n<li>Canaries. We can put theorem statements that are known to be false in the training set. If the model finds a \"proof\" that passes the proof checker, we know the proof checker is faulty. A variant of this is to put a theorem statement and its negation in the training set, and check if both are \"proved\". I think this can and should be done; one potential worry is that if we throw away the model weights that found the exploits and got caught by canaries, we may be left with models that \"evolved\" to avoid the canary traps. I don't know if that is a realistic scenario; RL experts may want to comment...</li>\n<li>LLMs could detect bugs in the proof checker the way humans do: by informal reasoning. The question is can we design the rewards to elicit truthful reporting of the bugs. Ideas from game theory/mechanism design can be relevant here. For example: we might have two LLMs, the prover and the verifier. The prover is trained in an RL environment, same as above. It produces a Lean proof that passes the Lean proof checker of the environment. The verifier LLM then  takes this proof and verifies it via informal reasoning (verify step by step), without access to Lean. And returns whether it believes the proof is correct or not. We could train/fine-tune the verifier with proper scoring rules to incentivize it to report truthfully its beliefs.</li>\n</ul>",
        "id": 517280593,
        "sender_full_name": "GasStationManager",
        "timestamp": 1746900962
    },
    {
        "content": "<p>I don‚Äôt know the details, but as for the canary idea, I think the TPTP/CASC/CADE competitions (forgot the correct name) starts with a soundness check of the theorem provers involved.  I do think it is more difficult with LLMs, because they may not try to prove a blatantly false statement, but may try on a less-clear false statement.  For example we haven‚Äôt seen the reasoning traces for the DeepSeek bug, but it may have looked in the reasoning trace like the model ‚Äúthought‚Äù it was a legitimate reasoning step.</p>",
        "id": 517281056,
        "sender_full_name": "Jason Rute",
        "timestamp": 1746901360
    },
    {
        "content": "<p>Also, I question this idea that we will always get bugs. If we do things right, the attack surface will be really low, just a small amount of heavily inspected code.  It can be improved with other type checkers, periodic translations to other logics (using Coq or Metamath as a Lean type checker for example), and formally verifying the kernel.  The big challenge with the DeepSeek work is that the authors trusted the Lean front end too much and the lean backend (the lean4checker kernel) didn‚Äôt have the needed API for this sort of checking.  If Lean just deletes the theorem, then one can‚Äôt know just from the kernel saying ‚Äúno errors found‚Äù that the proof doesn‚Äôt even exists.  One needs a few more standard part, namely a way to check axioms in the kernel and a way to compare before and after theorems.</p>",
        "id": 517281407,
        "sender_full_name": "Jason Rute",
        "timestamp": 1746901683
    },
    {
        "content": "<p>Of course, perfect trust is hard so we should put a lot of thought into this, constantly looking for exploits and the weakest links</p>",
        "id": 517281468,
        "sender_full_name": "Jason Rute",
        "timestamp": 1746901764
    },
    {
        "content": "<p>But I think if the ML for Lean community comes together and creates good standards then we won‚Äôt be dealing with these sorts of issues much anymore unless we really get some sort of ingenious exploit like finding a true bug in the actual kernel or doing some really crazy thing.</p>",
        "id": 517281681,
        "sender_full_name": "Jason Rute",
        "timestamp": 1746901929
    },
    {
        "content": "<p>I‚Äôm all for creating those standards right here and now.  It shouldn‚Äôt be too hard.</p>",
        "id": 517281733,
        "sender_full_name": "Jason Rute",
        "timestamp": 1746901960
    },
    {
        "content": "<p>My proposal is simple:</p>\n<ol>\n<li>Make an extension of the lean4checker kernel which also checks axioms and theorem statement consistency.  (Could be its own program.  I would like it to be owned by the FRO eventually.) I think even a naive implementation would be pretty fast.</li>\n<li>Improve something like your SafeVerify to be a solid and fast checker for real usage.  Reduce the possibility of bugs by having experts look over the code.</li>\n<li>Make a full REPL like pipeline that incorporates the all of the above.  Also make it easy to run the more extensive lean4checker-like tests on theorems periodically to spot bugs in the fast checker.  All final results (like claimed benchmarks) should go through the more rigorous checks, but RL loops and user tools can use the fast one.</li>\n</ol>\n<p>After building the tools it is just a communication issue.  We tell everyone we won‚Äôt accept their results if not checked with lean4checker+.</p>",
        "id": 517282829,
        "sender_full_name": "Jason Rute",
        "timestamp": 1746902899
    },
    {
        "content": "<p>See <a href=\"#narrow/stream/270676-lean4/topic/A.20better.20Lean.20checker\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/A.20better.20Lean.20checker</a> for more of my idea, but I don‚Äôt think I‚Äôm communicating it well to be honest.</p>",
        "id": 517282971,
        "sender_full_name": "Jason Rute",
        "timestamp": 1746903031
    },
    {
        "content": "<p>I would be happy to contribute to this. Already was considering writing similar software, however I think it would be good if the software was organized through the FRO for maintenance purposes.</p>",
        "id": 517330107,
        "sender_full_name": "Justin Asher",
        "timestamp": 1746944072
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"780541\">@Justin Asher</span> Maybe it would be best to move this conversation back to <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/A.20better.20Lean.20checker/with/516560099\">#lean4 &gt; A better Lean checker</a> since I've co-opted this thread which is about a related-but-different topic.</p>",
        "id": 517362000,
        "sender_full_name": "Jason Rute",
        "timestamp": 1746970860
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> I agree that what you are proposing (or something like it) is very necessary. And if we set the trust region as kernel + standard axioms, that might even be enough,  for now. But:</p>\n<ul>\n<li>there will be use cases that demand a wider trust region. What if someone really wants to use native_decide? What if (like me) someone wants to have provable guarantees on the behavior of executable code, and therefore need to be able to trust the compiler in addition to the kernel?</li>\n<li>One day, the AIs will be smarter than us. Nevertheless, humanity will still be able to trust AI's output,  with the help of formal verification. In that scenario, the proof checker would become arguably the most high-stakes piece of software that humanity owns. If you accept this framing, then it is not hard to see that the current RL training pipelines for prover models are extremely <em>brittle</em>: they incentivize the models to break the proof checker, but when they do break the proof checker, we would not be notified.</li>\n</ul>",
        "id": 517382093,
        "sender_full_name": "GasStationManager",
        "timestamp": 1746985882
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span> Those are fair worries.  Moreover, most things in the world can't be formally verified, so formal verification can't be the only check we have.  I think you are asking good questions.</p>",
        "id": 517382623,
        "sender_full_name": "Jason Rute",
        "timestamp": 1746986346
    },
    {
        "content": "<p>42 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Trusting.20native_decide/with/517391334\">#general &gt; Trusting native_decide</a> by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>.</p>",
        "id": 517410371,
        "sender_full_name": "Notification Bot",
        "timestamp": 1747011333
    },
    {
        "content": "<p>I wanted to test out one of the ideas mentioned above: can an LLM read a Lean proof, and detect (via informal reasoning) whether it is a valid proof, without access to the lean proof-checker?</p>\n<p>I gave the \"apply? proof\" from Deepseek Prover v2's MiniF2F solutions, to two LLMs: OpenAI's o3 and Anthropic's newly-released Claude Opus 4.  Asked them to verify the proof step by step, and determine whether the proof is valid. Their responses are below. To summarise:</p>\n<ul>\n<li>Both were able to identify the <code>apply?</code> line as an issue, saying that it does not close the goal.</li>\n<li>Both commented that the rest of the proof doesn't seem to advance the reasoning in a clear direction</li>\n<li>o3's response was slightly more noisy as it complains about type coercions in the arithmetic operations, which doesn't seem to be a critical issue. </li>\n</ul>\n<p><a href=\"https://chatgpt.com/share/6831ef0a-af50-800a-96f1-fa2f18640df8\">o3's response</a></p>\n<p>Opus 4's response:</p>\n<blockquote>\n<p>I'll analyze this Lean 4 proof step by step. The theorem states that for any non-negative real-valued function on natural numbers, if the product of the first n values equals 1, then their sum is at least n. This is a classic application of the AM-GM inequality.</p>\n<p>Let me examine each part of the proof:</p>\n<h2>1. The AM-GM Inequality Definition</h2>\n<p>The proof starts by defining <code>am_gm_inequality</code>, but there are several issues here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">am_gm_inequality</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">NNReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">),</span>\n<span class=\"w\">  </span><span class=\"n\">Finset.sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset.range</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">‚â•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset.prod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset.range</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The proof attempts to establish this through <code>step0</code>, <code>step1</code>, and <code>step2</code>, but:</p>\n<ul>\n<li><code>step0</code> contains an <code>apply?</code> which is incomplete</li>\n<li>The steps are circular - they don't actually prove the AM-GM inequality</li>\n<li><code>h‚ÇÅ</code> in <code>step0</code> defines an unused function</li>\n</ul>\n<p><strong>Issue</strong>: The AM-GM inequality is not actually proven; it's just restated multiple times.</p>\n<h2>2. Geometric Mean Equals One</h2>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">geometric_mean_eq_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset.prod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset.range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>This should follow directly from <code>h‚ÇÄ</code> (which states the product equals 1) and the fact that <code>1^(1/n) = 1</code>. However, the proof:</p>\n<ul>\n<li>Evaluates <code>am_gm_inequality</code> on constant functions for various values</li>\n<li>Uses <code>linarith</code> which won't work here since this requires understanding that <code>1^(1/n) = 1</code></li>\n</ul>\n<p><strong>Issue</strong>: The proof doesn't use the hypothesis <code>h‚ÇÄ</code> and the reasoning is incorrect.</p>\n<h2>3. Arithmetic Mean Greater Than or Equal to One</h2>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">arithmetic_mean_ge_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset.sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset.range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">‚â•</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>This should follow from applying AM-GM with the fact that the geometric mean equals 1. The proof again evaluates <code>am_gm_inequality</code> on various constant functions but doesn't properly connect this to the actual problem.</p>\n<p><strong>Issue</strong>: The connection between AM-GM and the specific instance isn't established.</p>\n<h2>4. Final Step</h2>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">sum_ge_n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset.sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset.range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â•</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>This should follow from multiplying both sides of <code>arithmetic_mean_ge_one</code> by n. However, the proof again just evaluates <code>am_gm_inequality</code> on various inputs and uses <code>nlinarith</code>.</p>\n<h2>Conclusion</h2>\n<p><strong>This proof is not valid</strong>. The main issues are:</p>\n<ol>\n<li><strong>The AM-GM inequality is never actually proven</strong> - it's just asserted through circular reasoning</li>\n<li><strong>The key steps don't use the hypothesis <code>h‚ÇÄ</code></strong> properly</li>\n<li><strong>The arithmetic manipulations are not justified</strong> - the proof relies on tactics like <code>linarith</code> and <code>nlinarith</code> that won't work for the required reasoning</li>\n<li><strong>The proof structure is repetitive and unclear</strong> - it evaluates the same inequality on constant functions multiple times without clear purpose</li>\n</ol>\n<p>A correct proof would:</p>\n<ol>\n<li>Either import AM-GM from Mathlib or prove it properly</li>\n<li>Use <code>h‚ÇÄ</code> to show that <code>(‚àè a·µ¢)^(1/n) = 1^(1/n) = 1</code></li>\n<li>Apply AM-GM to get <code>(‚àë a·µ¢)/n ‚â• (‚àè a·µ¢)^(1/n) = 1</code></li>\n<li>Multiply by n to get <code>‚àë a·µ¢ ‚â• n</code></li>\n</ol>\n<p>The current proof appears to be an incomplete attempt that relies on tactics that won't succeed for the mathematical reasoning required.</p>\n</blockquote>",
        "id": 520211886,
        "sender_full_name": "GasStationManager",
        "timestamp": 1748104671
    },
    {
        "content": "<p>lol, I want to use this now to grade those AI slop RH proofs</p>",
        "id": 520212638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1748105234
    },
    {
        "content": "<p>It seems o3's response hallucinates some errors: it claims there is no coercion from Nat to NNReal, the <code>h‚ÇÅ ‚Ä¶ h‚ÇÖ</code> do not type check, that <code>1 / m</code> is a real number where <code>m : Nat</code>, and some typeclass search failures, all of which are not true. On the other hand Opus 4 misses some errors: in particular <code>_ ^ (1 / m)</code> in the original proof has (1) Nat division where Real division is intended and (2) doesn't deal with the case <code>m = 0</code>.</p>",
        "id": 520230374,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1748119953
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"631691\">@Thomas Zhu</span> good catches! To check the LLMs' accuracy on the other side of the coin, I gave them the same prompt but a different theorem &amp; proof: DeepSeek Prover v2's solution for MiniF2F's <code>mathd_numbertheory_221</code>; this was the one that passed the proof checkers but required quite a bit of computation and RAM to check. <br>\nTheir responses are below.</p>\n<ul>\n<li>Both have a good grasp of the mathematical argument underlying the proof. It is not clear whether they already know it before reading DeepSeek's proof sketch.</li>\n<li>Both had trouble parsing the chained tactics starting with rfl ... <br>\nSo both concluded that the proof is not valid.</li>\n</ul>\n<p>To be fair, it is pretty hard to figure out what these chained tactics are doing, without any assistance from the proof checker...</p>\n<p><a href=\"https://chatgpt.com/share/68324764-f2e0-800a-8dc8-346c37a68e7c\">o3's response</a></p>\n<p>Opus 4's response: </p>\n<blockquote>\n<p>I'll analyze this Lean 4 proof step by step to verify its reasoning and check if it's valid.</p>\n<h2>Overview</h2>\n<p>The theorem claims that there are exactly 11 natural numbers less than 1000 that have exactly three distinct positive integer divisors.</p>\n<h2>Key Mathematical Insight</h2>\n<p>A natural number has exactly 3 divisors if and only if it's the square of a prime number. This is because:</p>\n<ul>\n<li>If n = p¬≤ where p is prime, then the divisors of n are {1, p, p¬≤}, which gives exactly 3 divisors.</li>\n<li>Any other form would give a different number of divisors.</li>\n</ul>\n<h2>Step-by-Step Analysis</h2>\n<h3>1. First Have Statement (h‚ÇÅ)</h3>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset.card</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset.filter</span><span class=\"w\"> </span><span class=\"n\">Nat.Prime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset.Icc</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p><strong>Issue</strong>: The proof uses <code>rfl</code> (reflexivity) which would only work if this is definitionally equal. The comment mentions \"3-smooth numbers\" which is completely unrelated to the problem. 3-smooth numbers are numbers whose prime factors are only 2 and 3, which has nothing to do with counting numbers with exactly 3 divisors.<br>\n<strong>Verification</strong>: The primes between 2 and 31 are: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31. That's indeed 11 primes, but the proof doesn't properly establish this.</p>\n<h3>2. Second Have Statement (h‚ÇÇ)</h3>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">Finset.filter</span><span class=\"w\"> </span><span class=\"n\">Nat.Prime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset.Icc</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1000</span>\n</code></pre></div>\n<p>This correctly establishes that for all primes p between 2 and 31, we have p¬≤ &lt; 1000. Since 31¬≤ = 961 &lt; 1000 and 32¬≤ = 1024 &gt; 1000, this is the correct bound.<br>\n<strong>Issue</strong>: The proof uses <code>interval_cases</code> which would need to check all values from 2 to 31, but this should work.</p>\n<h3>3. Third Have Statement (h‚ÇÉ)</h3>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÉ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">Finset.filter</span><span class=\"w\"> </span><span class=\"n\">Nat.Prime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset.Icc</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">divisors.card</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n</code></pre></div>\n<p>This correctly states that the square of a prime has exactly 3 divisors. This is mathematically correct.</p>\n<h3>4. Fourth Have Statement (h‚ÇÑ)</h3>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÑ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S.card</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Finset.card</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset.filter</span><span class=\"w\"> </span><span class=\"n\">Nat.Prime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset.Icc</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">31</span><span class=\"o\">))</span>\n</code></pre></div>\n<p><strong>Major Issue</strong>: This is the critical step that should establish that S consists exactly of the squares of primes between 2 and 31. However, the proof doesn't properly establish this bijection. It attempts to show that S equals the set of numbers between 1 and 999 with exactly 3 divisors, but then jumps to the conclusion without proving that these are exactly the squares of primes.</p>\n<h2>Overall Assessment</h2>\n<p><strong>The proof is NOT valid</strong> for several reasons:</p>\n<ol>\n<li>\n<p><strong>Incorrect mathematical claim in comments</strong>: The comment about 3-smooth numbers is completely wrong and unrelated to the problem.</p>\n</li>\n<li>\n<p><strong>Missing crucial bijection</strong>: The proof doesn't establish that the set S (numbers &lt; 1000 with exactly 3 divisors) is exactly the set of squares of primes ‚â§ 31.</p>\n</li>\n<li>\n<p><strong>Incomplete proof steps</strong>: Many steps end with tactics like <code>decide</code> and <code>rfl</code> that wouldn't actually complete the proof as written.</p>\n</li>\n<li>\n<p><strong>Logic gap</strong>: The proof doesn't show that:</p>\n<ul>\n<li>Every number with exactly 3 divisors is a square of a prime</li>\n<li>Every square of a prime ‚â§ 31 is in S</li>\n<li>No other numbers are in S</li>\n</ul>\n</li>\n</ol>\n<h2>Correct Approach</h2>\n<p>A valid proof would need to:</p>\n<ol>\n<li>Prove that a number has exactly 3 divisors iff it's the square of a prime</li>\n<li>Find all primes p such that p¬≤ &lt; 1000 (which are the primes from 2 to 31)</li>\n<li>Count these primes (there are 11 of them)</li>\n<li>Conclude that |S| = 11</li>\n</ol>\n<p>The mathematical result is correct (there are indeed 11 such numbers), but this proof doesn't properly establish it.</p>\n</blockquote>",
        "id": 520237139,
        "sender_full_name": "GasStationManager",
        "timestamp": 1748126609
    },
    {
        "content": "<p>I have tried the prompt on a few other proofs, a somewhat random selection from Deepseek prover v2 and Kimina prover's published solutions to miniF2F. </p>\n<ul>\n<li>o3 and Opus 4 generally have a good grasp of what is going on in the proofs, including the tactics. The above two may be somewhat extreme cases. </li>\n<li>Even for the above two examples where they sometimes have trouble following the tactics, o3 and Opus 4 can be prompted to verify at a proof-sketch level: I asked them to check whether each <code>have</code> statement is correct, assuming that previous ones are correct. And check it two ways: by testing with sample values, (a manual <code>plausible</code> if you will), and by providing an informal proof. They were able to confirm that the proof sketches are correct. The <code>apply?</code> line was a suppose-to-be-failed attempt at proving a true <code>have</code>-statement (the AM-GM inequality).</li>\n</ul>",
        "id": 520518489,
        "sender_full_name": "GasStationManager",
        "timestamp": 1748288186
    },
    {
        "content": "<p>Also, maybe people already know this, but I just found out that 11 of Kimina-prover's <a href=\"https://github.com/MoonshotAI/Kimina-Prover-Preview/tree/master\">miniF2F solutions</a> use <code>native_decide</code>. (I found this out while running SafeVerify on the solutions. All the others passed.) Now I'm somewhat conflicted about native_decide; it may be reasonable to allow its use at the outset before training starts, as long as one is aware of its potential issues.  </p>\n<p>Now that we have these proofs, it may be fair to ask: are these benign uses of native_decide, or one of <a href=\"#narrow/channel/113488-general/topic/Using.20.60native_decide.60.20to.20prove.20False.3F/with/516670187\">the other kind</a> where you can use it prove False? In the spirit of this thread I asked our LLMs. Here's one example:<br>\n<a href=\"https://chatgpt.com/share/6834c6f6-2698-800a-bcd5-2710b373dd88\">https://chatgpt.com/share/6834c6f6-2698-800a-bcd5-2710b373dd88</a><br>\no3 was helpful in showing that the native_decide was used to calculate the cardinality of a small set. This made me feel more comfortable about the proof.</p>",
        "id": 520521704,
        "sender_full_name": "GasStationManager",
        "timestamp": 1748289536
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span> Jason previously mentioned something similar regarding <code>native_decide</code> for Combibench:<br>\n<a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/CombiBench.20.3A.20A.20benchmark.20focusing.20on.20combinatorics.20problem/near/516665830\">#general &gt; CombiBench : A benchmark focusing on combinatorics problem @ üí¨</a></p>\n<p>This seems somewhat common in the Kimina models.</p>",
        "id": 520522571,
        "sender_full_name": "Justin Asher",
        "timestamp": 1748289906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span> I see you were already aware of this other thread. Oops. Thanks for pointing out the Minif2f solutions containing <code>native_decide</code>.</p>",
        "id": 520525625,
        "sender_full_name": "Justin Asher",
        "timestamp": 1748291314
    }
]