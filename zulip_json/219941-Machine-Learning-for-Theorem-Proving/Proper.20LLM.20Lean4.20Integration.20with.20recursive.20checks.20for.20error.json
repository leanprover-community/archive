[
    {
        "content": "<p><a href=\"/user_uploads/3121/_W0D274AjIXSaqVLts99nPRa/image.png\">image.png</a><br>\nWould love to see somebody in the community working on this. <br>\nOpenai O1 + Lean4 terminal integration as a source of truth could be powerful.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/_W0D274AjIXSaqVLts99nPRa/image.png\" title=\"image.png\"><img data-original-dimensions=\"1018x1185\" src=\"/user_uploads/thumbnail/3121/_W0D274AjIXSaqVLts99nPRa/image.png/840x560.webp\"></a></div><p>I myself dont have time to work on this, but I can consult. I have experience creating multi agent systems.</p>\n<p>I propose using Autogen with <a href=\"https://github.com/microsoft/trace\">https://github.com/microsoft/trace</a></p>\n<p>You'd first want to create a prototype without trace and just autogen.</p>\n<ol>\n<li>Have one agent that creates the lean4 theorem statement and tries to prove the statement with lean4 statements.</li>\n<li>Agent 2 runs the theorem with the terminal. If error comes up, pass back to agent 1 to correct the error and so on.</li>\n</ol>\n<p>It's very simple to create that prototype. Shouldnt be more than 40 - 50 hours of work.</p>",
        "id": 474389446,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1727900194
    },
    {
        "content": "<p>Many people have run GPT-4 on standard Lean and Coq benchmarks, using various agentic (and less agentic) approaches.  You can probably start with some of those benchmarks, but note this could get really expensive.  That is I think one of the main things holding people back.</p>",
        "id": 474397521,
        "sender_full_name": "Jason Rute",
        "timestamp": 1727903325
    },
    {
        "content": "<p>To flesh out what I said above, I think we are in interesting times where basically two types of people can do similar levels of \"original research\".  (1) A ML researcher could do a carefully controlled experiment on a benchmark using some particular agentic/prompting strategy with a particular frontier model and try to publish the results (either as the main result or as a baseline comparing some other approach).  (2) A practitioner could just make a tool using their expert ability to prompt the model.  Honestly, I see no reason a person in category (2) couldn't make just as good of a tool as one in category (1).  As <span class=\"user-mention\" data-user-id=\"734274\">@Gridiron Player</span> said, making a first attempt at these tools would be relatively fast.  Of course, those in category (2) might not have the funding to properly benchmark their creation.</p>",
        "id": 474449611,
        "sender_full_name": "Jason Rute",
        "timestamp": 1727923457
    },
    {
        "content": "<p>Here are some existing projects.  (I think only Sagredo was category (2) in that it was never published and there were never proper benchmarks for it, probably because it was too costly.  Maybe CoqPilot and LeanLLM also fit in this category, although CoqPilot has a paper.)</p>\n<ul>\n<li><a href=\"https://arxiv.org/abs/2303.04910\">Baldur</a><ul>\n<li>LLM: Minerva (fine-tuned on Isabelle data)</li>\n<li>ITP: Isabelle</li>\n<li>Similar to <span class=\"user-mention\" data-user-id=\"734274\">@Gridiron Player</span>'s suggested approach, where there are rounds of proof correction trying to fix errors.</li>\n</ul>\n</li>\n<li><a href=\"https://arxiv.org/abs/2210.12283\">Draft-Sketch-Prove</a> and <a href=\"https://arxiv.org/abs/2305.16366\">Subgoal Learning</a>)<ul>\n<li>LLM: Codex (and ChatGPT  for Subgoal Learning)</li>\n<li>ITP: Isabelle</li>\n<li>Produce natural language proof, and then use that to build formal proof sketch.  SledgeHammer ATP is used to fill in missing details.  (No proof correction, but it uses 100 attempts.)</li>\n</ul>\n</li>\n<li><a href=\"https://www.youtube.com/watch?v=CEwRMT0GpKo\">Sagredo</a><ul>\n<li>LLM: GPT-4</li>\n<li>ITP: Lean</li>\n<li>A real-world project that never took off since it was probably too expensive.  It did the traditional approach of applying an LLM at every proof step which is pricey for GPT-4.</li>\n</ul>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"CEwRMT0GpKo\" href=\"https://www.youtube.com/watch?v=CEwRMT0GpKo\"><img src=\"https://uploads.zulipusercontent.net/334dd3177945ef6955a1e621087a23617632651b/68747470733a2f2f692e7974696d672e636f6d2f76692f434577524d543047704b6f2f64656661756c742e6a7067\"></a></div></li>\n<li>Number of paper baselines: Use frontier models to synthesize whole proofs<ul>\n<li>LLMs: Code Llamma, GPT-4, GPT-4o, DeepSeek-Math</li>\n<li>ITPs: Isabelle, Lean, Coq</li>\n<li>The prompts may differ, but the idea is like code generation.  Just generate a proof from the theorem statement.  Often with multiple passes (everything from 1 to 128 passes).</li>\n</ul>\n</li>\n<li><a href=\"https://arxiv.org/abs/2309.15806\">Lyra</a><ul>\n<li>LLM: GPT-4</li>\n<li>ITP: Isabelle</li>\n<li>I think it is an extension of Draft-Sketch-Prove., but with two correction methods to fix failing proofs.  The first, Tool Correction, is automatic and doesn't require using an LLM.  The second, Conjecture Correction, is similar to <span class=\"user-mention\" data-user-id=\"734274\">@Gridiron Player</span>'s suggestion and prompts GPT-4 with the error message to fix the error.</li>\n</ul>\n</li>\n<li><a href=\"https://arxiv.org/abs/2310.00656\">LEGO-Prover</a><ul>\n<li>LLM: GPT-4</li>\n<li>Builds on Draft-Sketch-Prove by building a library of \"skills\" (small, reusable lemmas).  Retrieves skills to help with proof synthesis.</li>\n</ul>\n</li>\n<li><a href=\"https://arxiv.org/abs/2310.04353\">Copra</a>:<ul>\n<li>LLMs: GPT-4 and GPT-4o </li>\n<li>ITPs: Lean and Coq</li>\n<li>A fully agentic solution, using lots of available information, but quite pricey since it prompts the LLM at every proof state (if I recall correctly) in a tree search.</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/JetBrains-Research/coqpilot\">CoqPilot</a> (<a href=\"https://github.com/anlun/publicFiles/raw/master/papers/Kozyrev-al-ASE24.pdf\">Paper</a>:<ul>\n<li>LLMs: GPT-3.5, GPT-4o, LLaMa-2, Claude</li>\n<li>ITP: Coq</li>\n<li>First tries whole proof synthesis (I think with premise selection to suggest lemmas), and if fails it does proof correction through a \"multi-round communication process with an LLM\" (the details are unclear to me).</li>\n</ul>\n</li>\n<li><a href=\"https://www.arxiv.org/abs/2408.08152\">DeepSeekProver v1.5</a><ul>\n<li>LLM: DeepSeek-Prover (fine-tuned on synthetic Lean data)</li>\n<li>ITP: Lean</li>\n<li>Whole proof generation, but uses Monte-Carlo tree search to fix errors, only branching only on errors in the proofs (instead of branching on all proof states like some searched-based approaches).  Not that different to what <span class=\"user-mention\" data-user-id=\"734274\">@Gridiron Player</span> is suggesting, but a bit more complicated.  (<a href=\"https://arxiv.org/abs/2405.14333\">DeepSeek-Prover v1</a> just did whole proof generation with thousands of attempts, with the main innovation being in how the model was trained with RL on synthetic Lean data.)</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/cmu-l3/llmlean\">LLMLean</a><ul>\n<li>LLMs: GPT models, mistral models, or any model callable through <a href=\"http://together.ai\">together.ai</a> API (also support for locally run models)</li>\n<li>ITP: Lean</li>\n<li><code>llmqed</code> tactic for whole-proof generation.  (I don't think it is iterative, but I could be mistaken.  I think it just tries multiple attempts.)</li>\n</ul>\n</li>\n<li><a href=\"https://www.arxiv.org/abs/2408.03350\">MiniCXT</a>:<ul>\n<li>LLMs: fine-tuned DeepSeek-Coder-1.3b models (and a GPT-4 baseline)</li>\n<li>ITP: Lean</li>\n<li>Experiments using whole files as prompts, both on GPT-4 base and a fine-tuned DeepSeek-Coder-1.3b (using their novel file-tuning method).</li>\n</ul>\n</li>\n<li><a href=\"https://arxiv.org/abs/2409.14274v1\">PALM</a><ul>\n<li>LLM: LLaMa, GPT-3.5, GPT-4o</li>\n<li>ITP: Coq</li>\n<li>They do whole-proof generation using retrieved lemmas (from premise selection).  Then they do multiple rounds of error correction (similar to what <span class=\"user-mention\" data-user-id=\"734274\">@Gridiron Player</span> was suggesting).  (Edit: PALM’s error correction is fully symbolic so it doesn’t call the LLM again.)</li>\n</ul>\n</li>\n</ul>",
        "id": 474449773,
        "sender_full_name": "Jason Rute",
        "timestamp": 1727923518
    },
    {
        "content": "<p>I just fixed and expanded my list above.  I tried to stick to solutions using instruction-tuned models (or other models which require general purpose prompting).  After making the summary, the main thing I've come to is that whole proof search is too simple, and tree search branching on tactics is too expensive (for instruction-tuned models, unless you can really take advantage of prompt caching).  The happy middle ground used in Baldur, Lyra, CoqPilot, DeepSeek-Prover v1.5, and PALM is to correct errors as they appear.</p>",
        "id": 474561192,
        "sender_full_name": "Jason Rute",
        "timestamp": 1727953775
    },
    {
        "content": "<p>Also, reading the tweet again, I realize the OP was probably looking for something in the other direction, where the LLM calls Lean as a tool.  A good paper in that direction is <a href=\"https://arxiv.org/pdf/2403.18120\">Don't Trust: Verify -- Grounding LLM Quantitative Reasoning with Autoformalization</a>.  I'd love to see this approach made practical.</p>",
        "id": 474570977,
        "sender_full_name": "Jason Rute",
        "timestamp": 1727956596
    },
    {
        "content": "<p>Thanks for your comment. Yes, I was looking for a system that calls Lean4 as a tool, correct. I believe that the only way to make LLM's not hallucinate is to have a source of truth, like lean. The same problem arises with humans by the way. Humans need peer review too. You can't blindly trust someone's math paper.</p>\n<p>Formalizing and testing someone's math paper with lean4 would be even better than peer review, right? (Correct me if I'm wrong, I'm not a math researcher)</p>\n<p>I'm trying to take the same approach to LLM's.</p>\n<p>I am currently working on an agentic system that automatically creates unit tests for a FinTech application at my company. The verifying part is to run the unit tests and see if there are errors or exceptions, and then it will self-repair the unit tests based on those errors.</p>\n<p>My proposed approach with Lean would be similar: If the LLM runs into lean errors, there must be some sort of mistake and then it can recursively try to fix it. If there are no lean errors, the proof should be mathematically correct, right?</p>\n<p>As I gain experience with the unit testing system, I might be able to give the Lean thing a go too. But obviously it would also be cool to see other people working on this because I only have so much time in the day.</p>\n<p>With my experience with some of the multi agent LLM's library, I'd be able to consult.</p>",
        "id": 475585878,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1728399008
    },
    {
        "content": "<p>Yes, formalizing someone's math paper with Lean 4 would be better than peer review. Unfortuately this is out of reach at the minute, because for example formalising definitions is hard and most modern maths papers will use definitions which aren't currently in mathlib. Another issue is that even though this is a translation problem (which LLMs are good at) there's not enough good quality data to train on.</p>",
        "id": 475638481,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728412381
    },
    {
        "content": "<p>Thats a non issue. You dont have to fine tune an LLM for this. In fact, finetuning is overrated. You can just hook it up to the lean4 documentation or some vector database that maps the nautral language description of the theorem to its respective lean4 command in the mathlib.</p>\n<p>But I dont think you even need a vector database. If the mathlib codebase is sufficiently commented out with natural language, that would take care of this.</p>\n<p>That said, fitting the entire codebase into one prompt might be a challenge lol. So a vector database might still be necessary.</p>\n<p>Also, as of my experience, most bigger LLM's are already pretty proficient at lean4 if you combine it with a compilation step.</p>\n<p>Many options here without having to fine tune.</p>\n<p>And then error descriptions of the lean4 compiler would take care of the rest.</p>",
        "id": 475643882,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1728413782
    },
    {
        "content": "<p>Well if you want to knock off Lean proofs of the lemmas which don't have ticks by them in <a href=\"https://imperialcollegelondon.github.io/FLT/blueprint/Frobenius_project.html\">the FLT project</a> that would be great! Here we have human-readable LaTeX but no Lean yet (although humans are working on it).</p>",
        "id": 475644430,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728413913
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  I might work on it at some point like I said. Just thinking outloud here and presenting options</p>",
        "id": 475644684,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1728413984
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Proper.20LLM.20Lean4.20Integration.20with.20recursive.20checks.20for.20error/near/474449773\">said</a>:</p>\n<blockquote>\n<p>Here are some existing projects.  (I think only Sagredo was category (2) in that it was never published and there were never proper benchmarks for it, probably because it was too costly.  Maybe CoqPilot and LeanLLM also fit in this category, although CoqPilot has a paper.)</p>\n<ul>\n<li><a href=\"https://arxiv.org/abs/2303.04910\">Baldur</a><ul>\n<li>LLM: Minerva (fine-tuned on Isabelle data)</li>\n<li>ITP: Isabelle</li>\n<li>Similar to <span class=\"user-mention silent\" data-user-id=\"734274\">Gridiron Player</span>'s suggested approach, where there are rounds of proof correction trying to fix errors.</li>\n</ul>\n</li>\n<li><a href=\"https://arxiv.org/abs/2210.12283\">Draft-Sketch-Prove</a> and <a href=\"https://arxiv.org/abs/2305.16366\">Subgoal Learning</a>)<ul>\n<li>LLM: Codex (and ChatGPT  for Subgoal Learning)</li>\n<li>ITP: Isabelle</li>\n<li>Produce natural language proof, and then use that to build formal proof sketch.  SledgeHammer ATP is used to fill in missing details.  (No proof correction, but it uses 100 attempts.)</li>\n</ul>\n</li>\n<li><a href=\"https://www.youtube.com/watch?v=CEwRMT0GpKo\">Sagredo</a><ul>\n<li>LLM: GPT-4</li>\n<li>ITP: Lean</li>\n<li>A real-world project that never took off since it was probably too expensive.  It did the traditional approach of applying an LLM at every proof step which is pricey for GPT-4.</li>\n</ul>\n</li>\n<li>Number of paper baselines: Use frontier models to synthesize whole proofs<ul>\n<li>LLMs: Code Llamma, GPT-4, GPT-4o, DeepSeek-Math</li>\n<li>ITPs: Isabelle, Lean, Coq</li>\n<li>The prompts may differ, but the idea is like code generation.  Just generate a proof from the theorem statement.  Often with multiple passes (everything from 1 to 128 passes).</li>\n</ul>\n</li>\n<li><a href=\"https://arxiv.org/abs/2309.15806\">Lyra</a><ul>\n<li>LLM: GPT-4</li>\n<li>ITP: Isabelle</li>\n<li>I think it is an extension of Draft-Sketch-Prove., but with two correction methods to fix failing proofs.  The first, Tool Correction, is automatic and doesn't require using an LLM.  The second, Conjecture Correction, is similar to <span class=\"user-mention silent\" data-user-id=\"734274\">Gridiron Player</span>'s suggestion and prompts GPT-4 with the error message to fix the error.</li>\n</ul>\n</li>\n<li><a href=\"https://arxiv.org/abs/2310.00656\">LEGO-Prover</a><ul>\n<li>LLM: GPT-4</li>\n<li>Builds on Draft-Sketch-Prove by building a library of \"skills\" (small, reusable lemmas).  Retrieves skills to help with proof synthesis.</li>\n</ul>\n</li>\n<li><a href=\"https://arxiv.org/abs/2310.04353\">Copra</a>:<ul>\n<li>LLMs: GPT-4 and GPT-4o </li>\n<li>ITPs: Lean and Coq</li>\n<li>A fully agentic solution, using lots of available information, but quite pricey since it prompts the LLM at every proof state (if I recall correctly) in a tree search.</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/JetBrains-Research/coqpilot\">CoqPilot</a> (<a href=\"https://github.com/anlun/publicFiles/raw/master/papers/Kozyrev-al-ASE24.pdf\">Paper</a>:<ul>\n<li>LLMs: GPT-3.5, GPT-4o, LLaMa-2, Claude</li>\n<li>ITP: Coq</li>\n<li>First tries whole proof synthesis (I think with premise selection to suggest lemmas), and if fails it does proof correction through a \"multi-round communication process with an LLM\" (the details are unclear to me).</li>\n</ul>\n</li>\n<li><a href=\"https://www.arxiv.org/abs/2408.08152\">DeepSeekProver v1.5</a><ul>\n<li>LLM: DeepSeek-Prover (fine-tuned on synthetic Lean data)</li>\n<li>ITP: Lean</li>\n<li>Whole proof generation, but uses Monte-Carlo tree search to fix errors, only branching only on errors in the proofs (instead of branching on all proof states like some searched-based approaches).  Not that different to what <span class=\"user-mention silent\" data-user-id=\"734274\">Gridiron Player</span> is suggesting, but a bit more complicated.  (<a href=\"https://arxiv.org/abs/2405.14333\">DeepSeek-Prover v1</a> just did whole proof generation with thousands of attempts, with the main innovation being in how the model was trained with RL on synthetic Lean data.)</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/cmu-l3/llmlean\">LLMLean</a><ul>\n<li>LLMs: GPT models, mistral models, or any model callable through <a href=\"http://together.ai\">together.ai</a> API (also support for locally run models)</li>\n<li>ITP: Lean</li>\n<li><code>llmqed</code> tactic for whole-proof generation.  (I don't think it is iterative, but I could be mistaken.  I think it just tries multiple attempts.)</li>\n</ul>\n</li>\n<li><a href=\"https://www.arxiv.org/abs/2408.03350\">MiniCXT</a>:<ul>\n<li>LLMs: fine-tuned DeepSeek-Coder-1.3b models (and a GPT-4 baseline)</li>\n<li>ITP: Lean</li>\n<li>Experiments using whole files as prompts, both on GPT-4 base and a fine-tuned DeepSeek-Coder-1.3b (using their novel file-tuning method).</li>\n</ul>\n</li>\n<li><a href=\"https://arxiv.org/abs/2409.14274v1\">PALM</a><ul>\n<li>LLM: LLaMa, GPT-3.5, GPT-4o</li>\n<li>ITP: Coq</li>\n<li>They do whole-proof generation using retrieved lemmas (from premise selection).  Then they do multiple rounds of error correction (similar to what <span class=\"user-mention silent\" data-user-id=\"734274\">Gridiron Player</span> was suggesting).  (Edit: PALM’s error correction is fully symbolic so it doesn’t call the LLM again.)</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>The Sagredo video is actually nice because it points out some of the challenges. I dont think they are anything that can't be overcome but helpful nonetheless <span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span></p>\n<p>It is however a bit concerning that with a simple proof like the quadratic equation one that it struggled so much. A lot of it though seemed to be confusions with lean3. Also, Openai O1 is a lot better at math than gpt4, so we'll see!</p>",
        "id": 475667445,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1728419977
    },
    {
        "content": "<p>2 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"219941\" href=\"/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/LeanAgent\">#Machine Learning for Theorem Proving &gt; LeanAgent</a> by <span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span>.</p>",
        "id": 476470840,
        "sender_full_name": "Notification Bot",
        "timestamp": 1728687952
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> i wonder about sagredo now if one used gemini flash or one of the cheaper models as price has come down</p>",
        "id": 479776087,
        "sender_full_name": "Alok Singh",
        "timestamp": 1730328831
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"337670\">@Alok Singh</span> Maybe, but Sagredo never really has been tested.  Also, I think a better thing than a cheap per-token model would be a model with prompt caching since that would make it cheaper overall.  Thoughts <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span>?</p>",
        "id": 479792934,
        "sender_full_name": "Jason Rute",
        "timestamp": 1730341020
    },
    {
        "content": "<p>Gemini has caching under name context caching but seems the same</p>",
        "id": 479816159,
        "sender_full_name": "Alok Singh",
        "timestamp": 1730358321
    }
]