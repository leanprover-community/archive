[
    {
        "content": "<ol>\n<li>\n<p>Congrats!</p>\n</li>\n<li>\n<p>How long until we can point Aristotle at <a href=\"https://github.com/leanprover/lean4/tree/master/src/runtime\">https://github.com/leanprover/lean4/tree/master/src/runtime</a> and have it rewrite it in Rust ? 2 years? 3 years?</p>\n</li>\n</ol>",
        "id": 561779446,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764811581
    },
    {
        "content": "<p>Leaving aside anything to do with whether it's a good idea entirely, that doesn't seem to have anything to do with Aristotle's capabilities, does it?</p>",
        "id": 561782843,
        "sender_full_name": "Julian Berman",
        "timestamp": 1764814093
    },
    {
        "content": "<p>The Aristotle blog post is \"Aristotle Learns to Code\"; the benchmark they are testing on is about code synthesis (though I think Aristotle was only tested on the \"ProofGen\" task, which takes input code + spec, and generates proofs).</p>\n<p>To me, much like some of the cool demos in image/video is \"take this existing image/video, but stylze it / make one modification\", I think one of the big use cases / demos of Math ASL / Formally Verified Code is going to be taking libraries from language A and porting it to language B, all done by the LLM/Agent itself.</p>\n<p>IMHO one of the big use cases of Math ASL is being able to replace \"vibe coding\" with something that not only generates code, but also generates lean proof (of satisfying correctness, runtime, memory usage) along with it. Imho, this is the <a href=\"https://github.com/leanprover-community/mathlib4/pull/1\">#1</a> problem with vibe coding -- almost correct code -- which synthesizing code w/ proofs eliminates.</p>\n<p>Claude / OpenAI might say \"here is a rust repo of the lean4 runtime\", but with Math ASL, we can get something of the form \"here is a rust repo of the lean4 runtime, and here is a lean4 proof of equiv of the Rust/C++ code, under these Rust/C++ semantics.\"</p>",
        "id": 561785547,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764816316
    },
    {
        "content": "<p>I think the MathBenchmarks went<br>\nSAT/ASHME -&gt; AIME -&gt; IMO/Putnam -&gt; Research/Erdos problems</p>\n<p>I'm not sure if the proofs have increased in line count significantly (most seem to be &lt; 2 pages), but I think it's fairly well accepted the \"thinking time\" has increased from seconds to minutes to hours/days.</p>\n<p>Similarly, the benchmark that Aristotle just solved is <a href=\"https://arxiv.org/pdf/2505.23135\">https://arxiv.org/pdf/2505.23135</a> -- which looks like problems on the ~100 LOC level. If we take similar extrapolations, and using lean4 to ensure the output is correct / not BS, it does not seem unrealistic to me that we 10x in 1 year to 1000 LOC code output (with lean4 proofs), and 100x in 2 years to 10k LOC (also with lean4 proofs) -- and at that level, assuming a formalized C++/Rust semantics, it doesn't seem out of the question to ask Aristotle to rewrite 20-30k loc of C++ into Rust. Especially because on a first draft, it could probably do 1 C++ func &lt;-&gt; 1 unsafe Rust func, and prove its equivalence there.</p>",
        "id": 561786329,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764816994
    },
    {
        "content": "<p>\"assuming a formalized C++/Rust semantics\" is a big assumption, given that the informal C++ standard is somewhere around 2000 pages</p>",
        "id": 561789819,
        "sender_full_name": "Niels Voss",
        "timestamp": 1764820062
    },
    {
        "content": "<p>... and no compiler follows the standard to the letter.</p>",
        "id": 561793770,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1764823192
    },
    {
        "content": "<p>(based on my struggles with different C++ compilers while preparing <a href=\"https://github.com/Newclid/Newclid/tree/main/yuclid\">https://github.com/Newclid/Newclid/tree/main/yuclid</a> for a release)</p>",
        "id": 561793866,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1764823273
    },
    {
        "content": "<p>There's three counter arguments I see to this:</p>\n<h2>We probably only need a small subset.</h2>\n<p>I think the counter argument is that most decent Rust/C++ programmers probably</p>\n<ol>\n<li>can't write down Rust or C++'s formal grammar</li>\n<li>never read C++ / Rust (if one exists)'s formal spec</li>\n<li>never wrote a parser for either</li>\n<li>definitely never wrote a Rust type checker</li>\n<li>never wrote a compiler for either</li>\n</ol>\n<p>and despite this, they can write decent C++/Rust; so I suspect there exists some small subset of the C++/Rust spec where if you get this right, it covers a large percent of day to day C++/Rust.</p>\n<h2>IOI Models</h2>\n<p>There exists models that can win IOI gold. And those models are doing \"English -&gt; C++\". Intuitively, I feel for programs of same out length, \"English -&gt; C++\" should be harder than \"C++ -&gt; Rust\".</p>\n<h2>$$$ spent on human labeling</h2>\n<p>I do not know how big the \"small core\" in point 1 is -- but I suspect it's not large compared to the revenue of ScaleAI / Mercor / Turing; it feels like a one time (possibly partially automated) cost/investment well within the funding poured into AI.</p>\n<p>I just finished all the InsertionSort proofs at <a href=\"https://softwarefoundations.cis.upenn.edu/vfa-current/Sort.html\">https://softwarefoundations.cis.upenn.edu/vfa-current/Sort.html</a> at <a href=\"https://github.com/tkxue/func_algo/blob/main/FuncAlgo/C01_Sort.lean\">https://github.com/tkxue/func_algo/blob/main/FuncAlgo/C01_Sort.lean</a></p>\n<p>The proofs were a bit tedious, and probably do-able in half the length. However, it's not clear to me at all why this would not scale up. In fact, (without offending programmers), I feel like scaling up code translation is \"easier\" than solving Erdos problems in that: (1) not all programmers can solve Erdos problems, (2) most who have solved Erdos problems can probably pickup programming, and (3) solving Erdos problems feels like Aristotle need to be able to \"find spark of genius / insight\"; whereas translating code from one language to another \"merely\" requires Aristotle to do lots of rote engineering task (and much simpler proofs).</p>",
        "id": 561805208,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764831343
    },
    {
        "content": "<p>Can this discussion be moved to another thread? I don't see how this has anything to do with VERINA</p>",
        "id": 561805623,
        "sender_full_name": "Niels Voss",
        "timestamp": 1764831580
    },
    {
        "content": "<p>9 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"219941\" href=\"/#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Aristotle.20achieves.20SOTA.2096.2E8.25.20proof.20generation.20on.20VERINA/with/561746570\">#Machine Learning for Theorem Proving &gt; Aristotle achieves SOTA 96.8% proof generation on VERINA</a> by <span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span>.</p>",
        "id": 561819402,
        "sender_full_name": "Notification Bot",
        "timestamp": 1764837301
    },
    {
        "content": "<p>Darpa has a project to translate C to Rust:<br>\n<a href=\"https://www.darpa.mil/research/programs/translating-all-c-to-rust\">https://www.darpa.mil/research/programs/translating-all-c-to-rust</a></p>",
        "id": 561823201,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1764838467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Aristotle.20writing.20rust.3F/near/561782843\">said</a>:</p>\n<blockquote>\n<p>Leaving aside anything to do with whether it's a good idea entirely, that doesn't seem to have anything to do with Aristotle's capabilities, does it?</p>\n</blockquote>\n<p>Solana smart contracts are written in rust, which has about a $4B daily trading volume.   Smart  contracts are an ideal use case for verification.   </p>\n<p>It's an interesting question though,  the potential synergies in verification and correct code generation.</p>",
        "id": 561946397,
        "sender_full_name": "Deleted User 968128",
        "timestamp": 1764872007
    },
    {
        "content": "<p><a href=\"https://arxiv.org/html/2509.19153v1\">https://arxiv.org/html/2509.19153v1</a> (Solidity is not rust, but the rest is relevant.  Imho, this is a great tool calling use case.  There is this massive capability and value chasm that could be bridged quickly, but LLMs keep pushing AGI and threaten to bridge it singlehandedly.)</p>",
        "id": 561951461,
        "sender_full_name": "Deleted User 968128",
        "timestamp": 1764873658
    },
    {
        "content": "<p>I don't think anyone needs to be convinced that a system which can automatically formally verify rust code would have immense value. The question was about whether formally verified transpilation from C++ to Rust would be useful, and whether it is feasible.</p>",
        "id": 561969143,
        "sender_full_name": "Niels Voss",
        "timestamp": 1764880224
    },
    {
        "content": "<p>Well, at least we know C++ is more valuable than Rust.  :)</p>",
        "id": 561983026,
        "sender_full_name": "Deleted User 968128",
        "timestamp": 1764886153
    },
    {
        "content": "<p>I suppose I take this improperly on assumption that everyone is aware, when discussing this topic, but hard truth is that a minority of senior engineers are writing code these days, and soon it will be fewer still.  </p>\n<p>Rather they will drive architecture, but the traditional perspective of the code writing SWE is rapidly coming to an end.  It will be more computer scientists and 'engineers' in the traditional sense.  I can see them becoming fully credentialed, insured and required to legally sign off on what is delivered.</p>\n<p>It's a challenging transitional period for everyone and I truly empathize with the difficult emotions going around.</p>\n<p>Tools like Aristotle won't stop at verification, because it isn't what anyone really wants.  They want generated correct code.</p>",
        "id": 561992079,
        "sender_full_name": "Deleted User 968128",
        "timestamp": 1764890848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"968128\">Tim Shephard</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Aristotle.20writing.20rust.3F/near/561992079\">said</a>:</p>\n<blockquote>\n<p>Tools like Aristotle won't stop at verification, because it isn't what anyone really wants.  They want generated correct code.</p>\n</blockquote>\n<p>I can not imagine any of the \"Math SuperIntellitgence\" startups (atleast 3 of which claimed Erdos 124/481 in past week) to decide \"Hey, let's stop at Math, and not go after the code-gen / Cursor / Claude-4.5 / Codex market.\"</p>",
        "id": 562007983,
        "sender_full_name": "TongKe Xue",
        "timestamp": 1764900157
    },
    {
        "content": "<p>probably influenced by sources of funding I guess? Though would honestly be nice if they were more focused.</p>",
        "id": 562017447,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1764907860
    },
    {
        "content": "<p>With a strong verification system, they will be able to do RLVR in a way no other lab can.  There are other important synergies.  <a href=\"https://arxiv.org/html/2310.17807v4\">https://arxiv.org/html/2310.17807v4</a>  <a href=\"https://arxiv.org/abs/2412.06176\">https://arxiv.org/abs/2412.06176</a> <a href=\"https://arxiv.org/abs/2507.15822\">https://arxiv.org/abs/2507.15822</a></p>\n<p>However, I don't believe they will put the cart before the horse.  I've seen a number of examples now of teams who realized only after trying to solve the second problem that they had to go back and solve the first.</p>\n<p>Probably the real question in all of this is whether they will get acquired (or duplicated) by a frontier lab or if this will remain niche.  The former would be pretty exciting, though would prefer to see an acquisition.</p>",
        "id": 562028259,
        "sender_full_name": "Deleted User 968128",
        "timestamp": 1764915362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"968128\">Tim Shephard</span> <a href=\"#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Aristotle.20writing.20rust.3F/near/561946397\">said</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Solana</span><span class=\"w\"> </span><span class=\"n\">smart</span><span class=\"w\"> </span><span class=\"n\">contracts</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">written</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">rust</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">which</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">about</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"mi\">4</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">daily</span><span class=\"w\"> </span><span class=\"n\">trading</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"bp\">.</span><span class=\"w\">   </span><span class=\"n\">Smart</span><span class=\"w\">  </span><span class=\"n\">contracts</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">ideal</span><span class=\"w\"> </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">verification</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>We've been working on Rust smart contract verification (in Rocq), and found a number of bugs in the process. This includes a verified compiler to wasm.<br>\n<a href=\"https://github.com/AU-COBRA/ConCert/?tab=readme-ov-file#papers\">https://github.com/AU-COBRA/ConCert/?tab=readme-ov-file#papers</a></p>\n<p>Part of this tooling has already been ported to Lean (Hax, <a href=\"https://peregrine-project.github.io/\">https://peregrine-project.github.io/</a>).</p>",
        "id": 562093808,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1764939245
    }
]