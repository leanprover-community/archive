[
    {
        "content": "<p>Looking through the various ML-for-theorem-proving type research, it seems like a lot of work is around tasks of the form, here's a theorem, now prove it. But a lot of mathematical tasks are more like, \"here's an expression, can you simplify it\". For example, you could simply be asking \"what's 1234 + 5678\", or a more complicated problem like, find a closed form for </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mo fence=\"true\">(</mo><mfrac linethickness=\"0px\"><mi>n</mi><mi>k</mi></mfrac><mo fence=\"true\">)</mo></mrow></mrow><annotation encoding=\"application/x-tex\">\\sum_{k=1}^{n} \\binom{n}{k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.9535em;vertical-align:-1.3021em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6514em;\"><span style=\"top:-1.8479em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.05em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3021em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">(</span></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1076em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">)</span></span></span></span></span></span></span></p>\n<p>Is there any research work around how to make ML do this sort of \"simplification\" problem?</p>",
        "id": 406816757,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1702060290
    },
    {
        "content": "<p>I don't think so. E-graphs with rewrite rules are the best expression simplifiers we have right now I think, but they're pretty good. Are you thinking of using ML to search the space of valid rewrites for the simplest expression, or ML to discover new sound rewrite rules?</p>",
        "id": 406825235,
        "sender_full_name": "Alex Sanchez-Stern",
        "timestamp": 1702063783
    },
    {
        "content": "<p><a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/.22simplify.22.20tasks.20rather.20than.20.22prove.20a.20theorem.22.20tasks.3F/near/406825235\">A message</a> was moved here from <a class=\"stream-topic\" data-stream-id=\"219941\" href=\"/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/ML.20for.20Theorem.20Proving.20Tutorial.20-.20NeurIPS.202023\">#Machine Learning for Theorem Proving &gt; ML for Theorem Proving Tutorial - NeurIPS 2023</a> by <span class=\"user-mention silent\" data-user-id=\"659851\">Alex Sanchez-Stern</span>.</p>",
        "id": 406825300,
        "sender_full_name": "Notification Bot",
        "timestamp": 1702063803
    },
    {
        "content": "<p>In the age of LLMs, including ChatGPT, Bard, and the stuff at Morph for Lean, there is a general purpose tool which you can use to try to do any of this stuff, namely with the right prompt, just ask the model to do you task for you.  Or if you have a lot of data, you could train a transformer or other language model to do you task.  One early work in this direction were the papers by François Charton, the first of which showed that Transformer models can solve integrals and differential equations with fairly high acceracy.</p>\n<p>The nice thing about chat bots like ChatGPT, Bard, and the Morph stuff is that you can just try it yourself and see if it does anything interesting.</p>\n<p>But I think you have to ask the following questions:</p>\n<ol>\n<li>\n<p>Why ML?  There is no reason to need ML to solve 1234 + 5678.  You have calculators for that, and you also have other symbolic tools.  So I think there are some possibilities for an answer:</p>\n<ul>\n<li>You need an ML tool to decide what computation tool applies.</li>\n<li>You need an ML tool to speed up the computation tool with a good heuristic for search (like how we use ML inside tree search for theorem proving to speed up the tree search).</li>\n<li>You want ML because you are too lazy to build the symbolic tool.  For example, maybe it is easier to ask a chatbot to simplify that sum instead of asking wolfram alpha.</li>\n</ul>\n</li>\n<li>\n<p>How comfortable are you with the fact that AI can be wrong?  Possibly answers:</p>\n<ul>\n<li>It is fine, because I'll verify/check the answer myself.  This is the current paradigm with code generation.</li>\n<li>I will incorporate the ML into something else which will guarantee a correct response.  This is how neural guided tree search works.  The model spits out lots of suggestions, and Lean runs them.  Only the good paths in the search tree lead to proofs.</li>\n<li>I have an automatic way to check for correctness.  The example of integration is like this.  It is often easier to automatically check an integral symbolically that solve it.</li>\n</ul>\n</li>\n<li>\n<p>How can you go above and beyond the plug it into an LLM approach?  The best solutions are where AI and other methods are working hand-in-hand, or at least where the AI is a bit smarter than a pure LLM solution.</p>\n</li>\n</ol>",
        "id": 406829621,
        "sender_full_name": "Jason Rute",
        "timestamp": 1702065667
    },
    {
        "content": "<p>I'm just curious, really. I was looking through the 2023 IMO and noticing that three of the problems are of the form \"prove X\" and three of the problems are of the form \"simplify X\". Designing an objective function for a proof search seems straightforward - did you find a proof, or not - but designing an objective function for a simplification task does not seem straightforward.</p>",
        "id": 406845758,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1702073243
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"659851\">Alex Sanchez-Stern</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/.22simplify.22.20tasks.20rather.20than.20.22prove.20a.20theorem.22.20tasks.3F/near/406825235\">said</a>:</p>\n<blockquote>\n<p>I don't think so. E-graphs with rewrite rules are the best expression simplifiers we have right now I think, but they're pretty good. Are you thinking of using ML to search the space of valid rewrites for the simplest expression, or ML to discover new sound rewrite rules?</p>\n</blockquote>\n<p>I think it would have to be finding new rules - many simplification problems probably can't be expressed as a series of rewrites. Like, given that a natural number n satisfies n &gt; 3 and n &lt; 5, can you rewrite it into n = 4? I don't think so, but the simplest form for n would just be \"4\".</p>",
        "id": 406846930,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1702073853
    },
    {
        "content": "<p>Yeah, I think I misunderstood you were talking about simplifying with a proof, and hard simplification problems, not just trivial calculations.  As trivial as proof search seems, I think to make real headway, we do have to build AI that can do other tasks.  Simplifying, building lemmas, conjecturing, finding the right abstraction or invariant, and just exploring are all probably needed components.</p>",
        "id": 406851954,
        "sender_full_name": "Jason Rute",
        "timestamp": 1702076707
    },
    {
        "content": "<p>To be quite frank, this whole \"simplify\" issue is why I don't really see how to make any progress with the Formal to Formal version of the IMO challenge (the \"IMO Grand Challenge\"); you have to give information to the computer which the human doesn't have, or compromise the question in some other way.</p>",
        "id": 406853547,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702077613
    },
    {
        "content": "<p>While this doesn't necessarily help with _practically_ solving \"simplify\" problems, if we're working in a constructive setting they can almost always be expressed as theorems in the form of: given some target function <code>T(n) : Nat -&gt; Nat</code> and some \"program\" class <code>P</code> with an interpretation function <code>eval(\\cdot, n): P -&gt; Nat</code>, prove the theorem</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi mathvariant=\"normal\">∃</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo>:</mo><mi>P</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∀</mi><mi>n</mi><mo separator=\"true\">,</mo><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo separator=\"true\">,</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\exists (p : P), \\forall n, eval(p, n) = T(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∃</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>In the binomial theorem example, the program class would be an inductive set of expressions that includes constants, sums, products and powers, but not the summation function.<br>\nOne limitation of this approach is that it requires us to choose the allowed program class ourselves when formalizing the statement, and finding a good class might be hard. Plus, it doesn't rule out stupid answers like <code>(1 + r)^n + r - r</code>, or smart answers that are nevertheless more complicated than <code>(1 + r)^n</code>. But it does allow us to do some fun things, like creating a sequence of theorems \"simplify the expression to some program <code>p \\in P</code>\", \"simplify it to <code>p</code> s.t. <code>|p| &lt; 100</code>, \"... s.t. <code>|p| &lt; 50</code>\" etc.</p>",
        "id": 406857315,
        "sender_full_name": "Zygimantas Straznickas",
        "timestamp": 1702079798
    },
    {
        "content": "<p>even if you were to only focus on \"prove a theorem\" tasks, it seems like from a human point of view, \"simplifying an expression\" is often something you want to do as a subtask during the task of a proving a theorem. for example let's say you are trying to prove</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mo fence=\"true\">(</mo><mfrac linethickness=\"0px\"><mi>n</mi><mi>k</mi></mfrac><mo fence=\"true\">)</mo></mrow><mo>&lt;</mo><msup><mn>5</mn><mfrac><mi>n</mi><mn>2</mn></mfrac></msup></mrow><annotation encoding=\"application/x-tex\">\\sum_{k=1}^{n} \\binom{n}{k} &lt; 5^{\\frac{n}{2}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.9535em;vertical-align:-1.3021em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6514em;\"><span style=\"top:-1.8479em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.05em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3021em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">(</span></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1076em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">)</span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8971em;\"></span><span class=\"mord\"><span class=\"mord\">5</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8971em;\"><span style=\"top:-3.413em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mopen nulldelimiter sizing reset-size3 size6\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6915em;\"><span style=\"top:-2.656em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.2255em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line mtight\" style=\"border-bottom-width:0.049em;\"></span></span><span style=\"top:-3.384em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.344em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter sizing reset-size3 size6\"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>directly attacking this with tactics is kind of nuts, is that ever going to work? it makes a lot more sense to first figure out how to simplify the expressions on each side, at which point the proof is not so hard. any proof of the form \"prove complicated expression 1 is not equal to complicated but totally unrelated expression 2\" will work the same way.</p>\n<p>so, this is kind of roundabout, but this is why it seems to me like expressing a \"simplify X\" task as a \"prove X\" task is not really sufficient, there needs to be some inherent goal of simplifying an expression (beyond just rewrites).</p>\n<p>(although, as a caveat, ChatGPT-4 does actually solve this specific problem)</p>",
        "id": 406877339,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1702091342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/.22simplify.22.20tasks.20rather.20than.20.22prove.20a.20theorem.22.20tasks.3F/near/406853547\">said</a>:</p>\n<blockquote>\n<p>To be quite frank, this whole \"simplify\" issue is why I don't really see how to make any progress with the Formal to Formal version of the IMO challenge (the \"IMO Grand Challenge\"); you have to give information to the computer which the human doesn't have, or compromise the question in some other way.</p>\n</blockquote>\n<p>I think there is plenty that can be done here. It just means that we'll need more meta-programs that decide which <code>Expr</code> they want to submit as the solution of the simplification. These meta programs can make use of AI in whatever way they wish.<br>\nAnd yes, a human will have to \"grade\" the solution, and decide if the submitted <code>Expr</code> does indeed qualify as \"simple\".<br>\nThe remainder of the solution can be a formal proof, which would not have to be checked by humans.</p>",
        "id": 406890038,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1702098652
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/.22simplify.22.20tasks.20rather.20than.20.22prove.20a.20theorem.22.20tasks.3F/near/406851954\">said</a>:</p>\n<blockquote>\n<p>Yeah, I think I misunderstood you were talking about simplifying with a proof, and hard simplification problems, not just trivial calculations.  As trivial as proof search seems, I think to make real headway, we do have to build AI that can do other tasks.  Simplifying, building lemmas, conjecturing, finding the right abstraction or invariant, and just exploring are all probably needed components.</p>\n</blockquote>\n<p>I've always assumed that a model needs good \"intuition\" for pure calculations in order to be good at conjecturing sub lemmas. Although pushing calculations out to dedicated tools is usually the better option, the model probably still needs to be good at doing them for \"internal reasoning\" purposes. Anthropomorphic terms used carelessly.</p>",
        "id": 406919145,
        "sender_full_name": "Sam",
        "timestamp": 1702116825
    }
]