[
    {
        "content": "<p>I noticed that in Lean 4, when proving <code>0 ≠ n.succ</code>, <code>Nat.noConfusionType</code> is used. It is defined as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">noConfusionType</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n_1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n_1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span>\n</code></pre></div>\n<p>My understanding is that this expression is equivalent to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">P</span>\n<span class=\"k\">else</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span>\n</code></pre></div>\n<p>This essentially requires first defining when <code>n = 0</code> and when <code>n ≠ 0</code>. So, is using <code>Nat.noConfusionType</code> to prove <code>0 ≠ n.succ</code> a form of circular reasoning?</p>",
        "id": 504238904,
        "sender_full_name": "Lingwei Peng (彭灵伟)",
        "timestamp": 1741413155
    },
    {
        "content": "<p>No it's definitely not circular reasoning -- that is not allowed in lean. The axiom of recursion says that you can define a function on natural numbers by saying what to do with zero and what to do with successors, and you're just noticing that this axiom is enough to imply noConfusion.</p>",
        "id": 504249698,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741422083
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"489247\">colorlessboy</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Is.20.60Nat.2EnoConfusionType.60.20in.20Lean.204.20Circular.20Reasoning.20When.20P/near/504238904\">said</a>:</p>\n<blockquote>\n<p>My understanding is that this expression is equivalent to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">P</span>\n<span class=\"k\">else</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span>\n</code></pre></div>\n<p>This essentially requires first defining when <code>n = 0</code> and when <code>n ≠ 0</code>. So, is using <code>Nat.noConfusionType</code> to prove <code>0 ≠ n.succ</code> a form of circular reasoning?</p>\n</blockquote>\n<p>It is not equivalent: <code>casesOn</code> uses the recursor of Nat, for which Lean has a built-in computation rule, while <code>if ... then ... else</code> works in a much more roundabout way: under the hood it's application of the <code>ite</code> function which uses an instance of the <code>Decidable</code> inferred for the given proposition.</p>",
        "id": 504252699,
        "sender_full_name": "suhr",
        "timestamp": 1741422861
    },
    {
        "content": "<p>Here's an example (open it in Lean 4 playground):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">P</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"w\">  </span><span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n</code></pre></div>\n<p>You can click on <code>ite</code> to see the implicit arguments.</p>",
        "id": 504253028,
        "sender_full_name": "suhr",
        "timestamp": 1741423138
    },
    {
        "content": "<p>Thanks. Do you mean Decidable n = 0?</p>",
        "id": 504253052,
        "sender_full_name": "Lingwei Peng (彭灵伟)",
        "timestamp": 1741423169
    },
    {
        "content": "<p><code>Decidable (v1 = 0)</code>, but yeah. By the way, you can find the instance with <code>#synth ∀n: Nat, Decidable (n = 0)</code>.</p>",
        "id": 504253236,
        "sender_full_name": "suhr",
        "timestamp": 1741423284
    },
    {
        "content": "<p>By the way, here are computation rules for Nat.rec:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span><span class=\"w\">   </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"n\">z</span>\n<span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Which also imply that <code>Nat.rec</code> has the following type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">  </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\">  </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">t</span>\n</code></pre></div>\n<p>In the same way one can deduce the computation rules and the type of the recursor for any other inductive type.</p>",
        "id": 504253791,
        "sender_full_name": "suhr",
        "timestamp": 1741423704
    },
    {
        "content": "<p>Works for type families too. For example, computation rules for Nat.le.rec:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\">     </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>And the type of the recursor:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">},</span>\n<span class=\"w\">  </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 504254297,
        "sender_full_name": "suhr",
        "timestamp": 1741424116
    },
    {
        "content": "<p>I find this chain of reasoning quite complex: Decidable n = 0 → instDecidableEqNat → Nat.decEq → Nat.eq_of_beq_eq_true, and I think it is related to some implicit kernel behaviors. I understand the recursor, but I don’t fully understand why noConfusion can be derived from it. It seems more like a language rule for inductive types rather than a theorem (such as injectivity and disjointness of constructors).</p>",
        "id": 504255216,
        "sender_full_name": "Lingwei Peng (彭灵伟)",
        "timestamp": 1741424836
    },
    {
        "content": "<p>The recursor is a much more powerful tool than it initially appears. Peano's original axioms included things like zero != n.succ and injectivity of succ but they can all be derived from the recursor</p>",
        "id": 504255332,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741424930
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"489247\">colorlessboy</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Is.20.60Nat.2EnoConfusionType.60.20in.20Lean.204.20Circular.20Reasoning.20When.20P/near/504255216\">said</a>:</p>\n<blockquote>\n<p>It seems more like a language rule for inductive types rather than a theorem (such as injectivity and disjointness of constructors).</p>\n</blockquote>\n<p>Remember that the Lean core is not a logic but a theory of constructions. Propositions and proofs are merely special cases of mathematical constructions.</p>",
        "id": 504255526,
        "sender_full_name": "suhr",
        "timestamp": 1741425051
    },
    {
        "content": "<p>Here's an example for booleans with some annotations:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">noConfusionType</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">noConfusionType</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\">  </span><span class=\"c1\">-- False → False</span>\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">noConfusionType</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\">   </span><span class=\"c1\">-- False</span>\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">noConfusionType</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\">   </span><span class=\"c1\">-- False</span>\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">noConfusionType</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\">    </span><span class=\"c1\">-- False → False</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bool_d</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">noConfusionType</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"bp\">λ</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">noConfusionType</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"bp\">λ</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">noConfusionType</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Bool.noConfusionType False false true ≡ False</span>\n<span class=\"w\">  </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">noConfusionType</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">from</span>\n<span class=\"w\">    </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">subst</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">noConfusionType</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">bool_d</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">noConfusionType</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Computationally equal types are the same... and that's the key for <code>noConfusion</code>.</p>",
        "id": 504256352,
        "sender_full_name": "suhr",
        "timestamp": 1741425710
    },
    {
        "content": "<p>Computationally equal types are the same. This is clear. But I cannot understand the other part: why computationally different types are considered to be different. </p>\n<p>I think the second part is more like an implicit axiom implemented in the kernel, rather than a theorem. But I am not sure.</p>\n<p>The Lean 4 kernel has many implicit axioms that are not explicitly coded. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Quot</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">f_respects</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">mod7Rel</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This <code>rfl</code> works because the kernel automatically simplifies <code>Quot.lift f f_respects (Quot.mk mod7Rel a)</code> into <code>f a</code>, which looks like a provable theorem but is actually an axiom.</p>",
        "id": 504259779,
        "sender_full_name": "Lingwei Peng (彭灵伟)",
        "timestamp": 1741428174
    },
    {
        "content": "<p>It's again not an axiom but a computation rule. These are indeed are documented rather poorly in Lean.</p>",
        "id": 504261747,
        "sender_full_name": "suhr",
        "timestamp": 1741429727
    },
    {
        "content": "<p>The Lean Reference merely mentions the reduction rule for inductive types: <a href=\"https://lean-lang.org/doc/reference/latest//The-Type-System/Inductive-Types/#iota-reduction\">https://lean-lang.org/doc/reference/latest//The-Type-System/Inductive-Types/#iota-reduction</a>. And I don't see a reduction rule for quotients in the reference.</p>",
        "id": 504262038,
        "sender_full_name": "suhr",
        "timestamp": 1741429943
    },
    {
        "content": "<p>\"Reduction\" is mentioned many times in the quotient chapter</p>",
        "id": 504262480,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1741430288
    },
    {
        "content": "<p>Oh, it's mentioned en passant:</p>\n<p><a href=\"https://lean-lang.org/doc/reference/latest//The-Type-System/Quotients/#Quot___sound\">https://lean-lang.org/doc/reference/latest//The-Type-System/Quotients/#Quot___sound</a></p>\n<blockquote>\n<p>In addition to the above constants, Lean's kernel contains a reduction rule for Quot.lift that causes it to reduce when used with <a href=\"http://Quot.mk\">Quot.mk</a>, analogous to ι-reduction for inductive types. Given a relation r over α, a function f from α to β, and a proof resp that f respects r, the term Quot.lift f resp (<a href=\"http://Quot.mk\">Quot.mk</a> r x) is definitionally equal to f x.</p>\n</blockquote>",
        "id": 504262494,
        "sender_full_name": "suhr",
        "timestamp": 1741430305
    },
    {
        "content": "<p>By the way, Coq documentation is more straightforward: <a href=\"https://coq.inria.fr/doc/v8.19/refman/language/core/conversion.html\">it lists all reduction rules in a separate section</a>, and gives <a href=\"https://coq.inria.fr/doc/v8.19/refman/language/core/inductive.html#reduction-rule\">an example for ι-reduction</a> while discussing inductive types.</p>",
        "id": 504262845,
        "sender_full_name": "suhr",
        "timestamp": 1741430577
    },
    {
        "content": "<p>Yes, it is quite complex for beginners like me. When I eagerly look into which axioms are used after a theorem, I often encounter things I can’t fully grasp. The result is usually some kernel behavior hidden in the corners of the documentation.</p>\n<p>Thanks for the Coq documentation.</p>\n<p>I think noConfusion might be more complicated than the reduction example above. I’ll need more time to understand it.</p>",
        "id": 504263579,
        "sender_full_name": "Lingwei Peng (彭灵伟)",
        "timestamp": 1741431155
    },
    {
        "content": "<p><code>Nat.noConfusion</code> and <code>Bool.noConfusion</code> are very similar (you can see this by <code>#print Bool.noConfusion</code> and <code>#print Nat.noConfusion</code>) so if you understand how the example for <code>Bool</code> works you will be able to do the same for <code>Nat</code>.</p>\n<blockquote>\n<p>Thanks for the Coq documentation.</p>\n</blockquote>\n<p>Keep in mind that theories of Coq and Lean are slightly different: for example, Lean uses recursors while Coq uses fixpoints.</p>",
        "id": 504264342,
        "sender_full_name": "suhr",
        "timestamp": 1741431706
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Is.20.60Nat.2EnoConfusionType.60.20in.20Lean.204.20Circular.20Reasoning.20When.20P/near/504264342\">said</a>:</p>\n<blockquote>\n<p><code>Nat.noConfusion</code> and <code>Bool.noConfusion</code> are very similar (you can see this by <code>#print Bool.noConfusion</code> and <code>#print Nat.noConfusion</code>) so if you understand how the example for <code>Bool</code> works you will be able to do the same for <code>Nat</code>.</p>\n<blockquote>\n<p>Thanks for the Coq documentation.</p>\n</blockquote>\n<p>Keep in mind that theories of Coq and Lean are slightly different: for example, Lean uses recursors while Coq uses fixpoints.</p>\n</blockquote>\n<p>Thanks a lot! The Bool example is very clear.</p>",
        "id": 504271638,
        "sender_full_name": "Lingwei Peng (彭灵伟)",
        "timestamp": 1741437103
    }
]