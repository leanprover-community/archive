[
    {
        "content": "<p>Does someone have ideas for this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Combo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"c1\">-- Goal: function that singles out the *last* element of a list.</span>\n<span class=\"c1\">-- This works, but does not seem nice:</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Combo</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">([],</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">ys</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"c1\">-- none</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">--  ([], 1)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">--  ([1], 2)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">--  ([1,2], 3)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">7</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"mi\">42</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">--  ([2,7,4,5], 42)</span>\n\n<span class=\"c1\">-- How can I do this nicely?</span>\n<span class=\"c1\">-- Can we introduce a new pattern to split a non-empty list</span>\n<span class=\"c1\">-- into the `init` parth and the `last` element?</span>\n\n<span class=\"c1\">-- Ideally, with a `:::` operator I would want to write this:</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">def f' : List Nat → Option Combo</span>\n<span class=\"cm\">| [] =&gt; none</span>\n<span class=\"cm\">| (xs ::: x) =&gt; some (xs, x)</span>\n<span class=\"cm\">-/</span>\n<span class=\"c1\">-- And Lean should see that [] and ::: are mutually exclusive and covering all cases ;-)</span>\n</code></pre></div>\n<p>(This is a silly MW example of course, in <a href=\"https://github.com/m4lvin/lean4-pdl/blob/a49612b70672fe41f26e2e2c557944544e781342/Pdl/UnfoldDia.lean#L657\">my real use case</a> there is a type change happening instead of the <code>Option</code>.)</p>",
        "id": 466912229,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1725274882
    },
    {
        "content": "<p>See <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Concat.20as.20match.20pattern\">#Is there code for X? &gt; Concat as match pattern</a>  for why this is not possible</p>",
        "id": 466912616,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725274964
    },
    {
        "content": "<p>Ah, and there is no magic to make \"patterns\" that do computation beyond constructor applications?</p>",
        "id": 466913069,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1725275060
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 466913214,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1725275107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"422703\">Malvin Gattinger</span> has marked this topic as resolved.</p>",
        "id": 466913219,
        "sender_full_name": "Notification Bot",
        "timestamp": 1725275108
    },
    {
        "content": "<p>Indeed not. We have been wanting match notation to be able to use custom recursors, but this hasn't happened yet</p>",
        "id": 466913278,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725275128
    },
    {
        "content": "<p>You can also piggy-back on the <code>Array</code> API:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Combo</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">toArray</span>\n<span class=\"w\">  </span><span class=\"n\">arr</span><span class=\"bp\">.</span><span class=\"n\">back?</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">arr</span><span class=\"bp\">.</span><span class=\"n\">pop</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 466914418,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725275417
    },
    {
        "content": "<p>Looks funny. But I guess this will be a bit hard to then prove stuff about it. For now I will use this helper function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">splitLast</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">splitLast</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">([],</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">ys</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 466914903,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1725275532
    },
    {
        "content": "<p>Just so you know, your <code>splitLast</code> is basically the same as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.getLast%3F#doc\">docs#List.getLast?</a> along with what I would call <code>List.init</code> (defined by <code>l.init := l.reverse.tail.reverse</code>) but which seems to be missing</p>",
        "id": 466915745,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725275730
    },
    {
        "content": "<p>Ah, but shouldn't it be<code>l.init = l.reverse.tail.reverse</code>?</p>",
        "id": 466916212,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1725275838
    },
    {
        "content": "<p>Corrected</p>",
        "id": 466916371,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725275881
    },
    {
        "content": "<p>My use case is that I can now do <code>match splitLast xs with ...</code> in other functions and get two cases. I guess I could also do <code>match (xs.init?, xs.getLast?) with ...</code> but that gives four cases / obliges me to prove that two of them don't happen, right?</p>",
        "id": 466916656,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1725275947
    },
    {
        "content": "<p>(Oh, and my Haskell-traumatized subconciousness wants a safe <code>init?</code> <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>)</p>",
        "id": 466916819,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1725275987
    },
    {
        "content": "<p>Ah yes, I would just say to define <code>[].init := []</code></p>",
        "id": 466917005,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725276020
    },
    {
        "content": "<p>Isn't that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.dropLast#doc\">docs#List.dropLast</a> ?</p>",
        "id": 467005806,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725297075
    },
    {
        "content": "<p>Ohh, indeed! Thanks! (I even proved the same lemmas as given there already...) That goes on my Haskell-to-Lean translation list.</p>",
        "id": 467019414,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1725301546
    }
]