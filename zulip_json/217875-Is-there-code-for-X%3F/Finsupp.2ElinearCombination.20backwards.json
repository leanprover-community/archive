[
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.linearCombination#doc\">docs#Finsupp.linearCombination</a> has the following type signature: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">linearCombination</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→₀</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M</span>\n</code></pre></div>\n<p>Is there an easy way to talk about the natural linear map with the order of arguments reversed? Something like the following: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">linearCombinationReverse</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→₀</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M</span>\n</code></pre></div>",
        "id": 500871151,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1740056172
    },
    {
        "content": "<p>The easiest way to get this would be to make the term of type <code>(α → M) →ₗ[R] (α →₀ R) →ₗ[R] M</code> and then use API which already exists with names like flip or swap.</p>",
        "id": 500886011,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740060178
    },
    {
        "content": "<p>...and when I started trying to do this I ran into the fact that <code>R</code> wasn't commutative so perhaps that approach is off the table (assuming you care about the non-commutative case)</p>",
        "id": 500886449,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740060286
    },
    {
        "content": "<p>I think you're looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Finsupp/LSum.html#Finsupp.llift\">Finsupp.llift</a>. The SMulCommClass accommodates the non-commutative case (where the map isn't R-linear but you can still take e.g. S=Nat). <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/BilinearMap.html#LinearMap.flip\">LinearMap.flip</a> also works under a SMulCommClass assumption.</p>",
        "id": 500898350,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1740063109
    },
    {
        "content": "<p>So you don't need <code>CommSemiring R</code> for that but you do need <code>[SMulCommClass R R M]</code> which is basically the same thing? (\"R acts on M via a commutative quotient\")</p>",
        "id": 500899358,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740063362
    },
    {
        "content": "<p>I edited the post; I think in the noncommutative case you simply don't have a linear <code>(α → M) → M</code> but it's still an additive map which you can get by setting S=Nat.</p>",
        "id": 500899927,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1740063486
    },
    {
        "content": "<p>aah so Peter is trolling us!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">linearCombinationReverse</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→₀</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">linearCombination</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">map_add'</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">map_smul'</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">induction_linear</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hadd</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hsingle</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span>\n<span class=\"w\">        </span><span class=\"c1\">-- ⊢ s • r • φ a = r • s • φ a</span>\n<span class=\"w\">        </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 500924804,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740069867
    },
    {
        "content": "<p>Sorry! I hadn't given thought to commutativity at all - I just copy-pasted the type signature from docs.</p>",
        "id": 500925047,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1740069933
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Finsupp.2ElinearCombination.20backwards/near/500899358\">said</a>:</p>\n<blockquote>\n<p>So you don't need <code>CommSemiring R</code> for that but you do need <code>[SMulCommClass R R M]</code> which is basically the same thing? (\"R acts on M via a commutative quotient\")</p>\n</blockquote>\n<p>But you can pick <code>S = MulOpposite R</code></p>",
        "id": 500946703,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740076903
    },
    {
        "content": "<p>The reason I stopped was that I was waiting for Peter to clarify if they were only interested in the commutative case</p>",
        "id": 500972976,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740087151
    },
    {
        "content": "<p>I wonder whether the stuff we have for weighted degrees of polynomials isn't related to you question.</p>",
        "id": 501527848,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1740399605
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finsupp/Weight.html#Finsupp.weight\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finsupp/Weight.html#Finsupp.weight</a></p>",
        "id": 501528039,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1740399671
    },
    {
        "content": "<p>Is there a way to refactor <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.linearCombination#doc\">docs#Finsupp.linearCombination</a> to a general bilinear map that would get both cases at once? (Unclear)</p>",
        "id": 501529333,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1740400041
    }
]