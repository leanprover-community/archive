[
    {
        "content": "<p>Is there a class for types that support something like a 'freshElement' function? Specifically, I want a function that, given a Finset α, returns something of type α that is not in the Finset.</p>",
        "id": 527953971,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752090048
    },
    {
        "content": "<p>Such a function cannot exist in general:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fresh</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ohno</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fresh</span><span class=\"w\"> </span><span class=\"o\">({()}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n</code></pre></div>",
        "id": 527954260,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1752090183
    },
    {
        "content": "<p>I agree! That's why I'm asking for a class.</p>",
        "id": 527954404,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752090252
    },
    {
        "content": "<p>For example, Nat trivially supports it (get the maximum and apply succ). With more work (lexicographic ordering), it can be done for String, etc.</p>",
        "id": 527954576,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752090339
    },
    {
        "content": "<p>More generally, any discrete infinite type with some ordering that allows for a 'max' and 'next' functions should be fine.</p>",
        "id": 527954831,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752090454
    },
    {
        "content": "<p>I think the class is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Infinite#doc\">docs#Infinite</a> and the construction <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Infinite.exists_notMem_finset#doc\">docs#Infinite.exists_notMem_finset</a> ?</p>",
        "id": 527955840,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1752090857
    },
    {
        "content": "<p>Or is the point that you want something computable?</p>",
        "id": 527955927,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1752090882
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> it should be sufficient to have a (computable) embedding from N to your type A, and for A to have decidable equality -- that is if you care about computability.</p>\n<p>If you don't, then use what Eric suggested.</p>",
        "id": 527965204,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752094806
    },
    {
        "content": "<p>or just make it into a class, and make a constructor given my conditions above</p>",
        "id": 527965269,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752094828
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">FreshElement</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fresh</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">fresh_notMem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fresh</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FreshElement</span><span class=\"bp\">.</span><span class=\"n\">ofNatEmbed</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">↪</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FreshElement</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fresh</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">fresh_notMem</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find_spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>",
        "id": 527965813,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752095028
    },
    {
        "content": "<p>How is that different from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Encodable#doc\">docs#Encodable</a></p>",
        "id": 528020496,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1752133968
    },
    {
        "content": "<p>Thanks all for pitching in.<br>\nWhat <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> suggested is basically what I meant (I've called it <code>ComputableFresh</code> for now). It seems it's not anywhere yet then. I've proven that it can be instantiated for Nat, I'm satisfied with that for now.</p>",
        "id": 528020820,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752134093
    },
    {
        "content": "<p>What do you want the computable version for?</p>",
        "id": 528046614,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1752142551
    },
    {
        "content": "<p>The application at hand is defining a function for capture-avoiding substitution for lambda-calculus.<br>\nWhen we risk capturing, we rename the bound variable to a 'fresh' variable to avoid it: <a href=\"https://github.com/cs-lean/cslib/blob/2439f43103a78c5dc02f8530b7923248cf8795d3/Cslib/Computability/LambdaCalculus/Untyped/Basic.lean#L95\">https://github.com/cs-lean/cslib/blob/2439f43103a78c5dc02f8530b7923248cf8795d3/Cslib/Computability/LambdaCalculus/Untyped/Basic.lean#L95</a></p>",
        "id": 528047044,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752142680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Get.20a.20'fresh'.20element.20not.20in.20a.20Finset/near/528020496\">said</a>:</p>\n<blockquote>\n<p>How is that different from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Encodable#doc\">docs#Encodable</a></p>\n</blockquote>\n<p>I think what I actually could use as a sufficient hypothesis for a constructor is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Denumerable#doc\">docs#Denumerable</a></p>",
        "id": 528080875,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752153747
    },
    {
        "content": "<p>This is the code I have, by the way:<br>\n<a href=\"https://cs-lean.github.io/Cslib/Data/HasFresh.html\">https://cs-lean.github.io/Cslib/Data/HasFresh.html</a> (edit: was ComputableFresh)</p>\n<p>I wonder whether I should call it HasComputableFresh instead? Is there a naming tradition in mathlib for this kind of classes?</p>\n<p>(I'm trying to stay consistent with mathlib's style since the lib depends on it a lot.)</p>",
        "id": 528127433,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752167515
    },
    {
        "content": "<p>(or just HasFresh, that's shorter)</p>",
        "id": 528128275,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752167867
    },
    {
        "content": "<p>We already have stuff like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.HasAntidiagonal#doc\">docs#Finset.HasAntidiagonal</a>, so the name seems fine enough</p>",
        "id": 528129010,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752168149
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> has marked this topic as resolved.</p>",
        "id": 528146727,
        "sender_full_name": "Notification Bot",
        "timestamp": 1752175679
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> \"HasX\" is also sometimes used for the Prop version, so that's one thing to consider; what do you think about the alternative constructor in my original code (using embed Nat -&gt; X)?</p>",
        "id": 528176723,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752192443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Get.20a.20'fresh'.20element.20not.20in.20a.20Finset/near/528176723\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> what do you think about the alternative constructor in my original code (using embed Nat -&gt; X)?</p>\n</blockquote>\n<p>I think the idea is pretty nice, thank you!<br>\nI haven't had time yet to write the right incantation for replacing the <code>sorry</code> in your code. If you have an idea for that  already, feel free to make a PR to this file (adding your name) or just post it here and I'll do it myself:<br>\n<a href=\"https://github.com/cs-lean/cslib/blob/main/Cslib%2FData%2FHasFresh.lean\">https://github.com/cs-lean/cslib/blob/main/Cslib%2FData%2FHasFresh.lean</a></p>",
        "id": 528195742,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752209246
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> done; i have two proofs and i don't know which one is better</p>",
        "id": 528314603,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752232002
    },
    {
        "content": "<p><a href=\"https://github.com/cs-lean/cslib/pull/1\">https://github.com/cs-lean/cslib/pull/1</a></p>",
        "id": 528314626,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752232010
    },
    {
        "content": "<p>first PR <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 528314638,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752232014
    },
    {
        "content": "<p>Lovely! It's hard to decide between them, but I think I'd go for the second. Even if it's longer, I find it easy to follow. (I was informally thinking of looking at the preimage myself.)</p>",
        "id": 528316244,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752232549
    },
    {
        "content": "<p>I'm gonna merge it and slap some doc on it. Thank you very much. :)</p>",
        "id": 528316613,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752232663
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> two more PR's :D</p>",
        "id": 528321675,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752234515
    },
    {
        "content": "<p>but in the real context of lambda calculus do you actually always want to use the smallest one? or the biggest one?</p>",
        "id": 528322222,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752234706
    },
    {
        "content": "<p>There's no definitive answer afaik.</p>\n<p>For theorems, it doesn't matter. <br>\nFor computation, whatever we can compute the fastest, I guess.<br>\nFor ergonomics in examples and debugging, there are arguments both for always getting a the successor of the biggest element in the set (so that we always see new elements not used before when we use fresh) and for reusing smaller ones if possible (so that we don't get absurdly big numbers, if possible).</p>",
        "id": 528324797,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752235473
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Get.20a.20'fresh'.20element.20not.20in.20a.20Finset/near/528324797\">said</a>:</p>\n<blockquote>\n<p>whatever we can compute the fastest</p>\n</blockquote>\n<p>if you want to actually compute then you need to think about the complexity, I think for <code>Nat</code>, <code>Nat.find</code> would actually have the smallest complexity</p>",
        "id": 528325271,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752235619
    },
    {
        "content": "<p>the max+1 approach has constant complexity O(n), but the Nat.find approach has best complexity O(1)</p>",
        "id": 528325345,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752235646
    },
    {
        "content": "<p>but I'm asking because I have run into problems before with substituting first-order formulas</p>",
        "id": 528325446,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752235684
    },
    {
        "content": "<p>Agree that Nat.find is good.</p>\n<p>What problems with substituting first-order formulas? Could they be relevant here?</p>",
        "id": 528325676,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752235774
    },
    {
        "content": "<p>ah no it isn't O(n) or O(1) because deciding if x is in a finset s is O(n)...</p>",
        "id": 528325822,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752235819
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Get.20a.20'fresh'.20element.20not.20in.20a.20Finset/near/528325676\">said</a>:</p>\n<blockquote>\n<p>Agree that Nat.find is good.</p>\n<p>What problems with substituting first-order formulas? Could they be relevant here?</p>\n</blockquote>\n<p>The algorithm mathlib is using just basically pushes every variable out of the way</p>\n<p>so if you have <code>all x4, all x5, x4 + x5 = x0</code> (<code>ring.BoundedFormula Empty 4</code>, i.e. bounded formula with no parameters and 4 free variables) and you want to make a bounded formula with 6 variables by substituting x0 with x0+x3+x5 then it will become <code>all x6, all x7, x6 + x7 = x0 + x3 + x5</code></p>",
        "id": 528326203,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752235943
    },
    {
        "content": "<p>so update, I think for Nat the max algorithm is constant O(n) and the Nat.find algorithm is actually more like O(n^2)</p>",
        "id": 528326307,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752235977
    },
    {
        "content": "<p>Ah, so there might be value in using something similar (maybe tweaked? I don't remember it exactly) to what I had before for the Nat instance</p>",
        "id": 528326691,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752236103
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> PR incoming XD</p>",
        "id": 528331785,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752237761
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> i also constructed a HasFresh for an uncountable type</p>",
        "id": 528335751,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752238971
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> the lemma there has been merged to mathlib but i tried to bump mathlib and got quite a few errors because they changed the definition of <code>Rel</code> like 5 days ago from A -&gt; B -&gt; Prop to Set (A x B) so this is a heads up</p>",
        "id": 528389383,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752258849
    },
    {
        "content": "<p>Ouch, that's gonna affect a lot of stuff.</p>",
        "id": 528395944,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752262107
    },
    {
        "content": "<p>But more importantly, I guess now we gotta choose between Rel and the plain-old formulation. (As assumed in Relation.)</p>",
        "id": 528396418,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752262370
    }
]