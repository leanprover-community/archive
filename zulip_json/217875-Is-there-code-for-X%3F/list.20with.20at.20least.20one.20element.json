[
    {
        "content": "<p>so i can do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">theFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ilist</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">]</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">theFun</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>that would give \"missing cases\"if it were list</p>",
        "id": 456244471,
        "sender_full_name": "Jared green",
        "timestamp": 1722731193
    },
    {
        "content": "<p>You could use a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype#doc\">docs#Subtype</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">IList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[]}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">theFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IList</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>edit: though this doesn't help for the recursive case</p>",
        "id": 456245047,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722731531
    },
    {
        "content": "<p>is this not already in mathlib or the builtins?</p>",
        "id": 456245479,
        "sender_full_name": "Jared green",
        "timestamp": 1722731804
    },
    {
        "content": "<p>I'm pretty sure it's not</p>",
        "id": 456246679,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722732530
    },
    {
        "content": "<p>Probably you will have a better time using a custom <code>inductive</code> than what I do above</p>",
        "id": 456246709,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722732556
    },
    {
        "content": "<p>can that be done while also getting the already implemented functionality of list?</p>",
        "id": 456246883,
        "sender_full_name": "Jared green",
        "timestamp": 1722732669
    },
    {
        "content": "<p>That functionality isn't going to come for free whatever you do. If you care about compilation, then my approach above will be fastest, and you have to deal with not being able to use <code>match</code> syntax for recursion</p>",
        "id": 456249094,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722733299
    },
    {
        "content": "<p>If you don't care about compilation, you can write a pair of<code>IList.toList</code>  and <code>IList.mk l hl</code> functions and use the inductive APi</p>",
        "id": 456249306,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722733343
    },
    {
        "content": "<p>what do you mean 'if you care about compilation'</p>",
        "id": 456249381,
        "sender_full_name": "Jared green",
        "timestamp": 1722733426
    },
    {
        "content": "<p>I mean \"if you are building executable code, and want conversion between IList and List to be free\"</p>",
        "id": 456250104,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722733663
    },
    {
        "content": "<p>If you use the inductive spelling without some very clever FFI hacks, the cost of the conversion would be O(n)</p>",
        "id": 456250391,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722733717
    },
    {
        "content": "<p>i need it to run, and i need recursion. i dont know how to use ffi at all, though there should ideally be optimization in the compiler so the conversion doesnt actually occur, which is the least of my worries.</p>",
        "id": 456251169,
        "sender_full_name": "Jared green",
        "timestamp": 1722734246
    },
    {
        "content": "<p>specifically i need something like fold, which would look like this if i was to build it: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fold</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IList</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\">  </span><span class=\"bp\">-&gt;</span><span class=\"w\">  </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\">  </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">d</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">d</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ds</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\">  </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fold</span><span class=\"w\"> </span><span class=\"n\">ds</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 456252024,
        "sender_full_name": "Jared green",
        "timestamp": 1722734870
    },
    {
        "content": "<p>i also need to take things that come in the form of lists and use them in that way</p>",
        "id": 456252589,
        "sender_full_name": "Jared green",
        "timestamp": 1722735434
    },
    {
        "content": "<p>See also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FreeSemigroup#doc\">docs#FreeSemigroup</a></p>",
        "id": 456256730,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722737977
    },
    {
        "content": "<p>i went with inductive. got stuck on ofList</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Init</span><span class=\"bp\">.</span><span class=\"n\">Prelude</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Init</span><span class=\"bp\">.</span><span class=\"n\">Coe</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">IList</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">IList</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">IList</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">IList</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IList</span><span class=\"bp\">.</span><span class=\"n\">ofList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IList</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IList</span><span class=\"bp\">.</span><span class=\"n\">ofList</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">       </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">]</span>\n<span class=\"w\">       </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">length_tail</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hi</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">eq_add_of_sub_eq</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hi</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hi</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hi</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">hj</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hj</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hj</span><span class=\"w\">  </span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>i needed the if statement to complete the proof, but now i need a termination proof</p>",
        "id": 456398441,
        "sender_full_name": "Jared green",
        "timestamp": 1722809376
    },
    {
        "content": "<p>Here's a simple version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IList</span><span class=\"bp\">.</span><span class=\"n\">ofList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IList</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IList</span><span class=\"bp\">.</span><span class=\"n\">ofList</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 456398706,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722809624
    },
    {
        "content": "<p>A slightly neater spelling might be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IList</span><span class=\"bp\">.</span><span class=\"n\">ofList?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IList</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">IList</span><span class=\"bp\">.</span><span class=\"n\">ofList?</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">ixs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">ixs</span>\n</code></pre></div>",
        "id": 456398885,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722809769
    },
    {
        "content": "<p>what other imports are needed for the first one?</p>",
        "id": 456399964,
        "sender_full_name": "Jared green",
        "timestamp": 1722810763
    },
    {
        "content": "<p>Any reason not to do this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IList</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">toIList</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 456400092,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722810879
    },
    {
        "content": "<p>i was making toList and ofList as coercions with {l : List a // l ≠ [] } so that i can treat them as the same.</p>",
        "id": 456400371,
        "sender_full_name": "Jared green",
        "timestamp": 1722811123
    },
    {
        "content": "<blockquote>\n<p>Any reason not to do this?</p>\n</blockquote>\n<p>You lose the ability to pattern match on a <code>.cons</code> constructor (you can make <code>.single</code> work with <code>@[match_pattern]</code>)</p>",
        "id": 456400445,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722811192
    },
    {
        "content": "<p>I think this would take some concrete use cases to evaluate, but that's true.</p>\n<p>A big benefit to my <code>IList</code> is that you don't have to rebuild the List to convert it.</p>",
        "id": 456400635,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722811338
    },
    {
        "content": "<p>Arguably <code>{l : List a // l ≠ [] }</code> also has that property, and is likely to make things like <code>(IList.map l f).toList = l.toList.map f</code> defeq</p>",
        "id": 456400767,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722811454
    },
    {
        "content": "<p>Yeah, the subtype is likely the best version</p>",
        "id": 456400782,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1722811475
    },
    {
        "content": "<p>But as you say, there are tradeoffs to be made here, informed by the concrete use case we don't know!</p>",
        "id": 456400802,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722811501
    },
    {
        "content": "<p>(I think custom match patterns would remove the need  for some tradeoffs, but that sounds like a massive design challenge; especially if such a scheme were to be compatible with <code>~q</code> matching!)</p>",
        "id": 456400896,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722811565
    },
    {
        "content": "<p>in fact i have not implemented <a href=\"http://IList.map\">IList.map</a>, mainly because my application doesnt call for it.</p>",
        "id": 456402170,
        "sender_full_name": "Jared green",
        "timestamp": 1722812650
    }
]