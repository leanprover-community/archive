[
    {
        "content": "<p>Do we have anything like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">replicateRecOn</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Basically, I want to split my list into parts repeating a single element and induct on those parts.</p>",
        "id": 470243550,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726360269
    },
    {
        "content": "<p>You can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.groupBy#doc\">docs#List.groupBy</a>, although there doesn't seem to be any API for it</p>",
        "id": 470247852,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726364371
    },
    {
        "content": "<p>You just need to prove that every list is either [], a replicate, or of the form <code>replicate n a ++ b :: l</code> for some <code>a \\ne b</code>.</p>",
        "id": 470275833,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726375745
    },
    {
        "content": "<p>Yeah, I was able to prove this myself. Just asking if something like this already existed, or whether it'd be worth adding in Mathlib.</p>",
        "id": 470275869,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726375776
    },
    {
        "content": "<p>I'll add </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">eq_replicate_or_eq_replicate_append_cons</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∨</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">l'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l'</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 470277082,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726376637
    },
    {
        "content": "<p>Nice! I think a way to generate data from this might also be valuable.</p>",
        "id": 470277346,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726376723
    },
    {
        "content": "<p>Do you mean the Sort valued version of what you wrote above?</p>",
        "id": 470277410,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726376746
    },
    {
        "content": "<p>Yep</p>",
        "id": 470277438,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726376757
    },
    {
        "content": "<p>Hmm, what theorem would you want characterising the data producing one?</p>",
        "id": 470277938,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726376990
    },
    {
        "content": "<p>I don't really see a good statement except in terms of <code>groupBy</code>, in which case one should just use <code>groupBy</code> to begin with ...</p>",
        "id": 470277991,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726377018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Induction.20on.20repeated.20elements.20in.20list/near/470277938\">said</a>:</p>\n<blockquote>\n<p>Hmm, what theorem would you want characterising the data producing one?</p>\n</blockquote>\n<p>The expected stuff, such as <code>replicateRecOn [] = h0</code>, <code>replicateRecOn (replicate n a) = hr a n</code>, etc.</p>",
        "id": 470278060,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726377108
    },
    {
        "content": "<p>How would this work in terms of <code>groupBy</code>? I'm a bit confused on how to apply it to my use case.</p>",
        "id": 470278109,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726377123
    },
    {
        "content": "<p>what's the etc :-)</p>",
        "id": 470278112,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726377123
    },
    {
        "content": "<p><code>(h : a ≠ b) → replicateRecOn (replicate n a ++ b :: l) = hi _ _ _ _ h (replicateRecOn (b :: l))</code></p>",
        "id": 470278172,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726377194
    },
    {
        "content": "<p>Slightly tedious to use <code>groupBy</code>, because it is not obvious that the runs have positive length, and different elements.</p>",
        "id": 470278183,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726377213
    },
    {
        "content": "<p>One might want to define <code>runLengthEncoding</code> which packages that.</p>",
        "id": 470278239,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726377244
    },
    {
        "content": "<p>That would be great! I think it's a much better way to work with this.</p>",
        "id": 470278278,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726377276
    },
    {
        "content": "<p>induction principles are fun, but not always the answer :-)</p>",
        "id": 470278336,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726377347
    },
    {
        "content": "<p>Apologies the <code>groupBy</code> API is non-existent still.</p>",
        "id": 470278386,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726377365
    },
    {
        "content": "<p>Would <code>Data/List/RunLength</code> be fine for this? I'll gladly add a definition and some basic API.</p>",
        "id": 470278433,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726377433
    },
    {
        "content": "<p>I'm having trouble understanding the definition of <code>groupBy</code>. What's this <code>loop</code> function doing?<br>\n<a href=\"/user_uploads/3121/ISsOB57tPzEQ9muYNmCH88sj/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/ISsOB57tPzEQ9muYNmCH88sj/image.png\" title=\"image.png\"><img data-original-dimensions=\"726x224\" src=\"/user_uploads/thumbnail/3121/ISsOB57tPzEQ9muYNmCH88sj/image.png/840x560.webp\"></a></div>",
        "id": 470279948,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726378258
    },
    {
        "content": "<p>It's written like that to be tail-recursive.</p>",
        "id": 470280205,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726378322
    },
    {
        "content": "<p><code>g</code> is the group we are building up at the moment</p>",
        "id": 470280237,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726378335
    },
    {
        "content": "<p><code>gs</code> are the groups we're finished with</p>",
        "id": 470280240,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726378341
    },
    {
        "content": "<p>and <code>ag</code> is the \"previous\" element we've considered</p>",
        "id": 470280284,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726378385
    },
    {
        "content": "<p>So in particular the missing theorems about <code>groupBy</code> are:</p>\n<ul>\n<li><code>(l.groupBy r).join = l</code></li>\n<li>each list is not []</li>\n<li>each list satisfies <code>Chain r</code></li>\n<li>the last element of each list is not related to the first element of the next</li>\n</ul>",
        "id": 470281361,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726379168
    },
    {
        "content": "<p>and then might be fun to show that those properties uniquely characterize <code>l.groupBy</code></p>",
        "id": 470281395,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726379198
    },
    {
        "content": "<p>It's quite confusing how <code>loop</code> assembles both each individual group and the list of groups backwards. But I think I can figure this out.</p>",
        "id": 470282403,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726379928
    },
    {
        "content": "<p>Should the API for <code>groupBy</code> go in this <code>RunLength</code> file? Or do I first make a <code>GroupBy</code> file where I prove these characterizations?</p>",
        "id": 470282471,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726379950
    },
    {
        "content": "<p>I'd first make a <code>GroupBy</code>. I would love to steal it to move to the core repository, to be honest. <code>GroupBy</code> has been low on my list, but I'll get there eventually. :-)</p>",
        "id": 470282580,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726379990
    },
    {
        "content": "<p>There's an issue with stating the <code>Chain'</code> condition - <code>List.Chain'</code> expects <code>α → α → Prop</code>, while <code>List.groupBy</code> expects <code>α → α → Bool</code>.</p>",
        "id": 470285554,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726381311
    },
    {
        "content": "<p>Ah nevermind, apparently <code>Bool</code> can be casted to <code>Prop</code>.</p>",
        "id": 470285859,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726381384
    },
    {
        "content": "<p>I'm getting the hang of this! <code>nil_not_mem_groupBy</code> and <code>chain'_of_mem_groupBy</code> have been proven!</p>",
        "id": 470293207,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726384333
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Pairwise#doc\">docs#List.Pairwise</a> might be a better conclusion, and it should be easy from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.chain%27_iff_pairwise#doc\">docs#List.chain'_iff_pairwise</a></p>",
        "id": 470294483,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726385492
    },
    {
        "content": "<p>Only if the relation is transitive.</p>",
        "id": 470294493,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726385505
    },
    {
        "content": "<p><code>groupBy</code> still works and is sometimes even useful for non-transitive relations, so best to use Chain</p>",
        "id": 470294549,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726385524
    },
    {
        "content": "<p>Oh, right, the relation isn't always equality</p>",
        "id": 470294553,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726385531
    },
    {
        "content": "<p>Rather than <code>nil_not_mem_groupBy</code> I'd prove that if you're in groupBy, you're not nil. More useful.</p>",
        "id": 470294573,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726385558
    },
    {
        "content": "<p>I think both are potentially useful statements</p>",
        "id": 470294737,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726385681
    },
    {
        "content": "<p><code>join_groupBy</code> has been proven too!</p>",
        "id": 470294770,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726385725
    },
    {
        "content": "<p>I'm not quite sure what the best way to state this last theorem is. Maybe like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">chain'_last_ne_head_groupBy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">groupBy</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Chain'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">getLast?</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">head?</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 470295193,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726386104
    },
    {
        "content": "<p>Perhaps <code>(l.groupBy r).Chain' (fun a b ↦ ∃ ha hb, ¬r (a.getLast ha) (b.head hb))</code>?</p>",
        "id": 470295398,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726386294
    },
    {
        "content": "<p>That seems more useful, since we get to assert both that the lists are non-empty and that the last and first element are distinct</p>",
        "id": 470295502,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726386377
    },
    {
        "content": "<p>Also yeah, should have used <code>r</code> instead of <code>≠</code></p>",
        "id": 470295514,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726386392
    },
    {
        "content": "<p>Proven! All I'm missing is the characterization theorem, and then I'll submit a PR.</p>",
        "id": 470306686,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726391123
    },
    {
        "content": "<p>Actually, I'm finding the characterization a bit hard to prove. It's also getting quite late over here, so I'll just PR the rest and I'll try and prove the characterization later down the line, if it's needed.</p>",
        "id": 470310455,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726393614
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/16818\">#16818</a></p>",
        "id": 470310704,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726393728
    },
    {
        "content": "<p>Left some comments.</p>",
        "id": 470399856,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726442657
    },
    {
        "content": "<p>If you want to prove the characterisation, then the first step is <code>theorem groupBy_join</code>, which is that if you have a <code>List (List X)</code> satisfying some hypotheses, and you join it and then groupBy it, you get back the original <code>List (List X)</code>.</p>\n<p>After that, one can prove <code>theorem groupBy_eq_iff : l.groupBy = L \\iff ...</code>.</p>",
        "id": 470400169,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726442751
    },
    {
        "content": "<p>The result on <code>attach</code> you mention can actually be generalized:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">chain'_attachWith</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">attachWith</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Chain'</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">Chain'</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I'm having some trouble proving this due to some missing API though. For instance, I wanted to use this theorem</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">head?_attachWith</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">attachWith</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">head?</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">head?</span><span class=\"bp\">.</span><span class=\"n\">attach</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">mem_of_mem_head?</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Here <code>attach</code> is <code>Option.attach : Π a : Option α, Option {x // x ∈ a}</code>, which judging by how the analogous <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=getLast%3F#doc\">docs#getLast?</a>_attach is written, doesn't seem to exist either...</p>",
        "id": 470405092,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726446300
    },
    {
        "content": "<p>The definition would just be this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">attach</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 470405266,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726446440
    },
    {
        "content": "<p>Another basic theorem on <code>attachWith</code> seemingly missing is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">attachWith_cons</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">attachWith</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_cons_self</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">::</span>\n<span class=\"w\">      </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">attachWith</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_cons_of_mem</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 470406097,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726447018
    },
    {
        "content": "<p>Oh, good catch, the API for <code>attach</code> is developed much further than the API for <code>attachWith</code>.</p>",
        "id": 470407280,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726447716
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span>, would you mind taking a look at <a href=\"https://github.com/leanprover/lean4/pull/5352\">lean#5352</a> and seeing if that fills the gaps you noticed?</p>\n<p>I did not (yet?) introduce <code>Option.attach</code>, but I'll consider that for later.</p>",
        "id": 470412213,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726450748
    },
    {
        "content": "<p>Yeah, I think that fills in the gaps for at least the lemmas I need.</p>",
        "id": 470413388,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726451449
    },
    {
        "content": "<p>I also noticed something similar happening with <code>head!</code> and <code>head</code>. In particular, we don't have these two lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">head_mem_self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[]),</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">contradiction</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">mem_cons_self</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">head_mem_head?</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[]),</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">head?</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">contradiction</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 470413428,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726451481
    },
    {
        "content": "<p>The first is just <code>List.head_mem</code>. I agree the second is missing, and I'll add that now.</p>",
        "id": 470420374,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726454348
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/5353\">lean#5353</a></p>",
        "id": 470421135,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726454521
    },
    {
        "content": "<p>By the way, I've been able to simplify the proofs about <code>groupBy</code> a bit by proving this first</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">groupBy_loop_eq_append</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">gs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">groupBy</span><span class=\"bp\">.</span><span class=\"n\">loop</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">gs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">gs</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">groupBy</span><span class=\"bp\">.</span><span class=\"n\">loop</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 470435489,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726458330
    },
    {
        "content": "<p>I'll put that in the PR shortly</p>",
        "id": 470435518,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726458335
    },
    {
        "content": "<p>I proved the characterization!</p>",
        "id": 470444760,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726460681
    },
    {
        "content": "<p>It's about 100 extra lines of code, so I think it'll have to go in a subsequent PR.</p>",
        "id": 470445341,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726460818
    },
    {
        "content": "<p>I ended up using this auxiliary lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">join_head</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hl'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">hl</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">join</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">join_ne_nil</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">head_mem</span><span class=\"w\"> </span><span class=\"n\">hl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hl'</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">hl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">hl'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">contradiction</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">join_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">head_cons</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">head_append_of_ne_nil</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>Is this something we want in Mathlib, or is it too specific? In the former case, where should I put it?</p>",
        "id": 470445489,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726460851
    },
    {
        "content": "<p>For now I've put the characterization in <a href=\"https://github.com/leanprover-community/mathlib4/pull/16837\">#16837</a>. I imagine it will have to stay as a WIP until a new core update drops.</p>",
        "id": 470446992,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726461217
    },
    {
        "content": "<p>Looks good to me. Lemma should be called <code>head_join</code>, however, and probably should be <code>head_join_of_head_ne_nil</code>, as one could imagine a more complicated result that went looking for the first thing that wasn't <code>[]</code>, and took its head!</p>",
        "id": 470459709,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726465105
    },
    {
        "content": "<p>Once <code>bump/v4.13.0</code> is on a sufficiently recent nightly (usually within 24 hours of release), I don't see why you couldn't make a PR direct to that, and have that reviewed in the usual manner. It's not how we usually do things, but it seems better than waiting.</p>",
        "id": 470459863,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726465166
    },
    {
        "content": "<p>e.g. <code>head_join</code> itself would have RHS <code>((l.filter (\\. \\ne [])).head sorry).head sorry</code></p>",
        "id": 470460199,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1726465289
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> Is it ok for <a href=\"https://github.com/leanprover-community/mathlib4/pull/16818\">#16818</a> to land as is (modulo further review), and for me to add the version of <code>chain'_last_ne_head_groupBy</code> without the existential once we have <code>chain'_attachWith</code>?</p>",
        "id": 472137781,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1727072422
    },
    {
        "content": "<p>i'd like to note that <a href=\"https://github.com/leanprover-community/batteries/pull/948\">batteries#948</a> would benefit from the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.ne_nil_of_mem_groupBy#doc\">docs#List.ne_nil_of_mem_groupBy</a> lemma being upstreamed, as it would provide a proof enableing prefix search for library notes, rather than exact search.</p>",
        "id": 477194172,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1729079155
    },
    {
        "content": "<p>This is meta code: using <code>head!</code> is completely acceptable. :-)</p>",
        "id": 477321299,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1729123088
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Induction.20on.20repeated.20elements.20in.20list/near/470243550\">said</a>:</p>\n<blockquote>\n<p>Do we have anything like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">replicateRecOn</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Basically, I want to split my list into parts repeating a single element and induct on those parts.</p>\n</blockquote>\n<p>Just by curiosity, what application do you have in mind?</p>",
        "id": 477363644,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1729147016
    },
    {
        "content": "<p>I use this in my Rubik's cube project to define the \"deduplication\" of a sequence of moves, i.e. the list where any sequence of four consecutive moves gets deleted</p>",
        "id": 477373868,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729150377
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/16837\">#16837</a> is now review-ready!</p>",
        "id": 479629616,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730277251
    }
]