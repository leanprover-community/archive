[
    {
        "content": "<p>Do we have rooted trees in Mathlib? I'm interested in formalizing Kruskal's tree theorem</p>",
        "id": 462170098,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723569756
    },
    {
        "content": "<p>No we do not</p>",
        "id": 462174298,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723571233
    },
    {
        "content": "<p>What would be the best way to define it? </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>makes the kernel complain, and is also restricted to finite trees (which is fine for Kruskal's theorem, but something more generic might be better for Mathlib). It's possible to make this from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.IsTree#doc\">docs#SimpleGraph.IsTree</a>, but I fear it would be annoying to work with</p>",
        "id": 462176362,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723572051
    },
    {
        "content": "<p>Or perhaps <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PredOrder#doc\">docs#PredOrder</a> could be used as a base?</p>",
        "id": 462342332,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723640896
    },
    {
        "content": "<p>Actually, isn't a PredOrder with an OrderBot exactly a rooted tree?</p>",
        "id": 462342791,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723641062
    },
    {
        "content": "<p>It is, yes (at least so long as you don't care about infinite dangling bits). But from your description it's not very clear how exactly you want to manipulate rooted trees</p>",
        "id": 462343055,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723641147
    },
    {
        "content": "<p>I'm not quite sure yet, but I'm looking for something which could eventually be added to Mathlib. Looking at it like an order does seem promising, though - a tree homeomorphism is an injective <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=InfHom#doc\">docs#InfHom</a>, for instance, if I'm not mistaken</p>",
        "id": 462346075,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723641902
    },
    {
        "content": "<p>To exclude infinite dangling bits you can just add <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LocallyFiniteOrder#doc\">docs#LocallyFiniteOrder</a>, right?</p>",
        "id": 462346370,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723641990
    },
    {
        "content": "<p>... or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsPredArchimedean#doc\">docs#IsPredArchimedean</a></p>",
        "id": 462346697,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723642106
    },
    {
        "content": "<p>Oh, I didn't notice it's only about comparable elements</p>",
        "id": 462346988,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723642218
    },
    {
        "content": "<p>Although I do need to look at subtrees, and I'm not sure how nice that is with orders</p>",
        "id": 462348410,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723642757
    },
    {
        "content": "<p><code>Ici a</code> should be the subtree rooted at  <code>a</code></p>",
        "id": 462348485,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723642794
    },
    {
        "content": "<p>Yes, but that's a set</p>",
        "id": 462348634,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723642842
    },
    {
        "content": "<p>Sure, but it can be coerced to a type with <code>PredOrder (Ici a)</code> and <code>IsPredArchimedean (Ici a)</code></p>",
        "id": 462348724,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723642876
    },
    {
        "content": "<p>Hmm. I'll try to prove Kruskal's theorem with this</p>",
        "id": 462349019,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723642993
    },
    {
        "content": "<p>Again, \"look at subtrees\" could mean</p>\n<ol>\n<li>Needing to construct a subtree</li>\n<li>Stating that an existing object is a subtree</li>\n<li>Considering the overall collection of subtrees</li>\n<li>etc...</li>\n</ol>\n<p>and it's really hard for me to help you if you don't tell me which one(s) you are after</p>",
        "id": 462349128,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723643038
    },
    {
        "content": "<p>I think the main things I need to do with subtrees are</p>\n<ol>\n<li>look at the set of (immediate) subtrees of a <code>Fintype</code> tree as a <code>Finset</code> (or maybe <code>Multiset</code>, it depends on how tree equality is defined) of trees, let's call this <code>subtrees t</code></li>\n<li><del>I have a function <code>f : subtrees a → subtrees b</code> and a function <code>g : (s : subtrees a) → s → f s</code> and I need to extend it to a function <code>a → b</code> by mapping the root to the root, and mapping other elements using <code>g</code> for their subtree</del> I think this is just finding the subtree a non-root element is contained in</li>\n</ol>",
        "id": 462351421,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723643841
    },
    {
        "content": "<p>Okay so in the paradigm I'm offering the immediate subtrees would be indexed by the atoms of the order, which might be convenient enough?</p>",
        "id": 462351983,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723644007
    },
    {
        "content": "<p>I want to talk about sequences of trees, so I think it would be best if everything was bundled, right?</p>",
        "id": 462352507,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723644147
    },
    {
        "content": "<p>To find the subtree of an element I can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsPredArchimedean#doc\">docs#IsPredArchimedean</a> with bot and apply <code>pred</code> <code>n-1</code> times, would that work well?</p>",
        "id": 462352871,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723644257
    },
    {
        "content": "<p>The subtrees are just <code>Set.Ici '' Set.Iic x</code> I think.</p>",
        "id": 462353496,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1723644452
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/rooted.20trees/near/462352507\">said</a>:</p>\n<blockquote>\n<p>I want to talk about sequences of trees, so I think it would be best if everything was bundled, right?</p>\n</blockquote>\n<p>Sequences of trees, or sequences of subtrees?</p>",
        "id": 462356115,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723645137
    },
    {
        "content": "<p>Sequences of trees</p>",
        "id": 462358852,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723646019
    },
    {
        "content": "<p>Do I need <code>DecidableEq α</code> to define <code>Set.Ici.predOrder</code>, or is there a way to avoid it?</p>",
        "id": 462362704,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723647275
    },
    {
        "content": "<p>Yes, I would think you need it</p>",
        "id": 462362892,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723647356
    },
    {
        "content": "<p>I'm almost done with the proof, but there's a problem with my definition of Tree.subtrees - I want all of those<code>Tree</code>s to be different, but they are types, so their equality doesn't behave nicely at all. What's a good alternative way to do that?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">order</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SemilatticeInf</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">bot</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OrderBot</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PredOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">pred_archimedean</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsPredArchimedean</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">coeSort</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeSort</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">RootedTree</span><span class=\"bp\">.</span><span class=\"n\">α</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SemilatticeInf</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">order</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PredOrder</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">pred</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OrderBot</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">bot</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsPredArchimedean</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">pred_archimedean</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ici</span><span class=\"bp\">.</span><span class=\"n\">predOrder</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PredOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PredOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ici</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ici</span><span class=\"bp\">.</span><span class=\"n\">isPredArchimedean</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PredOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">IsPredArchimedean</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsPredArchimedean</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ici</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"bp\">.</span><span class=\"n\">subtree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ici</span><span class=\"w\"> </span><span class=\"n\">r</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"bp\">.</span><span class=\"n\">subtrees</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">subtree</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">IsAtom</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 462389335,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723656339
    },
    {
        "content": "<p>You could force <code>α</code> to be of the form <code>Fin n</code> for some <code>n</code></p>",
        "id": 462389537,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723656426
    },
    {
        "content": "<p>How would that help? I want all of the subtrees to appear in the set, without some getting deduplicated</p>",
        "id": 462389822,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723656559
    },
    {
        "content": "<p>I can use <code>{x // IsAtom x} → RootedTree</code> in place of <code>Set</code>, but I'm not sure how convenient that is</p>",
        "id": 462391466,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723657246
    },
    {
        "content": "<p>I think I settled on defining a type synonym <code>SubRootedTree</code>, and then I define</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeOut</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SubRootedTree</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ici</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">root</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>but it delaborates weirdly - <code>#check (t.subtree r : RootedTree)</code> prints <code>RootedTree.mk ↑(Set.Ici (t.subtree r).root) : RootedTree</code> instead of <code>↑(t.subtree r) : RootedTree</code>. How can I fix this?</p>",
        "id": 462474258,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723699459
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">PrettyPrinter</span><span class=\"w\"> </span><span class=\"n\">Delaborator</span><span class=\"w\"> </span><span class=\"n\">SubExpr</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">delab</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"bp\">.</span><span class=\"n\">RootedTree</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">delabRTMk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Delab</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getExpr</span>\n<span class=\"w\">  </span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">isAppOfArity'</span><span class=\"w\"> </span><span class=\"ss\">``RootedTree.mk</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n<span class=\"w\">  </span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">getArg!'</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isAppOfArity'</span><span class=\"w\"> </span><span class=\"ss\">``Set.Elem</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">getArg!'</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getArg!'</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isAppOfArity'</span><span class=\"w\"> </span><span class=\"ss\">``Set.Ici</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">withAppArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">withAppArg</span><span class=\"w\"> </span><span class=\"n\">delab</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">↑$</span><span class=\"n\">arg</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>seems to work, I couldn't get an unexpander working there for some reason</p>",
        "id": 462481236,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723702776
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubRootedTree</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\">  </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ici</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">root</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeOut</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SubRootedTree</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">coe</span>\n</code></pre></div>\n<p>should do</p>",
        "id": 462486121,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723704439
    },
    {
        "content": "<p><del>That works, thanks</del> Now it writes <code>coe t (t.subtree r)</code></p>",
        "id": 462486674,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723704602
    },
    {
        "content": "<p>I'm having a problem with handling subtrees - I define</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeOut</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SubRootedTree</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ici</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">root</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubRootedTree</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeOut</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"bp\">.</span><span class=\"n\">subtrees</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">SubRootedTree</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">IsAtom</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">root</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"bp\">.</span><span class=\"n\">subtreeOf</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">subtrees</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">RootedTree</span><span class=\"bp\">.</span><span class=\"n\">mem_subtreeOf</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">subtreeOf</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">hr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>and now I have an embedding <code>f : a.subtrees ↪ b.subtrees</code> and a function <code>g : (t : a.subtrees) → t ↪ (f t)</code>, and I define a function by<br>\n<code>g' (x : a) : b := if h : x = ⊥ then ⊥ else g (a.subtreeOf x h) (a.mem_subtreeOf x h)</code><br>\nnow I need to show that this <code>g'</code> is injective, but when neither <code>x</code> or <code>y</code> are the root and <code>g' x = g' y</code>, I can show that the subtrees are equal (apply <code>subtreeOf</code>, show this gives <code>f (a.subtreeOf x h1) = f (a.subtreeOf y h2)</code> and apply <code>f</code>'s injectivity), but I can't rewrite with that equality because they're types. What's a better way to handle all of this?</p>",
        "id": 462499512,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723709077
    },
    {
        "content": "<p>I think changing <code>g</code> to <code>a.subtrees -&gt; a -&gt; b</code> (filling everything irrelevant with junk values) and using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.InjOn#doc\">docs#Set.InjOn</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.MapsTo#doc\">docs#Set.MapsTo</a> could work</p>",
        "id": 462537836,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723724194
    },
    {
        "content": "<p>33 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/weaker.20SuccOrder.2FPredOrder\">#mathlib4 &gt; weaker SuccOrder/PredOrder</a> by <span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span>.</p>",
        "id": 462981057,
        "sender_full_name": "Notification Bot",
        "timestamp": 1723900139
    },
    {
        "content": "<p>A rooted tree (<code>PredOrder</code> + <code>IsPredArchimedean</code> + <code>OrderBot</code>) is uniquely an <code>InfSemilattice</code> where <code>inf</code> is the LCA in the tree. What's the proper way to state this result?</p>",
        "id": 464282007,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724310711
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">PredOrder</span><span class=\"bp\">.</span><span class=\"n\">toSemilatticeInf</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PredOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsPredArchimedean</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OrderBot</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SemilatticeInf</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>",
        "id": 464282701,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724311028
    },
    {
        "content": "<p>Couldn't that cause defeqness issues if there's already a SemilatticeInf instance, as it's data?</p>",
        "id": 464285067,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724311911
    },
    {
        "content": "<p>No, because <code>abbrev</code> too is data</p>",
        "id": 464286081,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724312155
    },
    {
        "content": "<p>I made a PR defining rooted trees, <a href=\"https://github.com/leanprover-community/mathlib4/pull/16272\">#16272</a></p>",
        "id": 466087407,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724956721
    }
]