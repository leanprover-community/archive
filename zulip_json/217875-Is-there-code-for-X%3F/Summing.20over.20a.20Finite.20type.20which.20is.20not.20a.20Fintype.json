[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/34584\">#34584</a>, I was asked to refactor <a href=\"https://tqft.net/mathlib4files/Mathlib/RepresentationTheory/Maschke\">file#Mathlib/RepresentationTheory/Maschke</a> to only assume <code>[Finite G]</code> instead of <code>[Fintype G]</code>. This file uses a lot of expressions of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mrow><mi>g</mi><mo>∈</mo><mi>G</mi></mrow></msub><mi>f</mi><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\sum_{g \\in G} f(g)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\">G</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span></span></span></span>, which are implemented using <code>Finset.sum</code>. <br>\nMy understanding is that a <code>Finset</code> is a finite set together with a specified ordering, and <code>Finset.sum</code> is the sum in that order. However, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> takes values in a commutative additive monoid, the order should not matter, and it's really annoying to use <code>Finset.sum</code>, which requires one. Is there another sum function in Mathlib, which sums over finite sets directly instead?<br>\nIf not, I could always define a new sum which sums over a finite set in the order given by <code>Fintype.ofFinite</code>, and try developing some API for it. Would it be a good design choice?</p>",
        "id": 572437081,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770400939
    },
    {
        "content": "<p>I don't think <code>Finset</code> has any order, it's an element of the quotient of lists with no duplicates over the list permutation relation. So while you can take out a representative list (which might be how Lean will compile the code), the <code>Finset</code> itself is all possible orderings at the same time.<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sum#doc\">docs#Finset.sum</a> already requires commutativity precisely for that reason, otherwise the sum wouldn't be well defined.</p>",
        "id": 572438040,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770401250
    },
    {
        "content": "<p>Then what is the difference between <code>Finset</code> and <code>Set.Finite</code>?</p>",
        "id": 572438201,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770401311
    },
    {
        "content": "<p>I need to make sense of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow></msub><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\sum_{x \\in X} f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0771em;vertical-align:-0.3271em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3271em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, where <code>(X A : Type*) [Finite X] [AddCommGroup A] (f : X -&gt; A)</code>.</p>",
        "id": 572438537,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770401428
    },
    {
        "content": "<p>And as it currently stands, I need to lift <code>X</code> to a <code>Fintype</code>. If it's not picking an ordering, what does it actually do?</p>",
        "id": 572438715,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770401485
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finite#doc\">docs#Finite</a>: a proof that a type is finite, which originated from a specific ordering (a bijection with <code>Fin n</code> for some <code>n</code>), but it's impossible to recover that order<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite#doc\">docs#Set.Finite</a>: converts the <code>Set</code> to a <code>Subtype</code> (aka an element + a proof it's in the set), then applies <code>Finite</code> on it<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset#doc\">docs#Finset</a>: an equivalence class of lists with no duplicates under the \"is a permutation of\" relation<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype#doc\">docs#Fintype</a>: a <code>Finset</code> plus a proof that it's everything in the type</p>",
        "id": 572439309,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770401714
    },
    {
        "content": "<p>Maybe <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finsum#doc\">docs#finsum</a> ?</p>\n<p>It says</p>\n<blockquote>\n<p>We define products and sums over types and subsets of types, with no finiteness hypotheses. All infinite products and sums are defined to be junk values (i.e. one or zero). This approach is sometimes easier to use than <code>Finset.sum</code>, when issues arise with <code>Finset</code> and <code>Fintype</code> being data.</p>\n</blockquote>\n<p>so it seems like it was created exactly for your use case?</p>",
        "id": 572439333,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1770401722
    },
    {
        "content": "<p>Where do you need sums? In the statement or the proof? If it's the statement, use <code>Fintype</code> instead or otherwise you'll get instance diamonds</p>",
        "id": 572439538,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1770401805
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 572439556,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1770401815
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Summing.20over.20a.20Finite.20type.20which.20is.20not.20a.20Fintype/near/572439333\">said</a>:</p>\n<blockquote>\n<p>Maybe <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finsum#doc\">docs#finsum</a> ?</p>\n</blockquote>\n<p>This looks exactly like what I had in mind. Does mathlib have any specific conventions for preferring <code>Finset.sum</code> in some cases?</p>",
        "id": 572439571,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770401822
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407114\">Stepan Nesterov</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Summing.20over.20a.20Finite.20type.20which.20is.20not.20a.20Fintype/near/572438715\">said</a>:</p>\n<blockquote>\n<p>If it's not picking an ordering, what does it actually do?</p>\n</blockquote>\n<p>It's summing every possible list with no duplicates, and proving that permutations don't change the result, therefore the sum is well-defined as a function from equivalence classes (aka Finsets)</p>",
        "id": 572439652,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770401852
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Summing.20over.20a.20Finite.20type.20which.20is.20not.20a.20Fintype/near/572439538\">said</a>:</p>\n<blockquote>\n<p>Where do you need sums? In the statement or the proof? If it's the statement, use <code>Fintype</code> instead or otherwise you'll get instance diamonds</p>\n</blockquote>\n<p>I guess it's the statement. I need to make heavy use of averages: if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> is a finite group, and it acts on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>, then I look at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mrow><mi>g</mi><mo>∈</mo><mi>G</mi></mrow></msub><mi>g</mi><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">\\sum_{g \\in G} gv</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\">G</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">gv</span></span></span></span> and prove some things about it. But I'm told that all the modern parts of the group theory library use <code>[Finite G]</code>, and I cannot <code>local instance : Fintype G := Fintype.ofFinite G</code> because it'll cause diamonds. So I'm looking to avoid <code>Finset.sum</code>.</p>",
        "id": 572440202,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770402051
    },
    {
        "content": "<p>AFAIK you should <code>Fintype</code> for defs and <code>Finite</code> for theorems</p>",
        "id": 572440455,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770402143
    },
    {
        "content": "<p>But what is the point of having two definitions of the same thing, one for defs and one for theorems?</p>",
        "id": 572440682,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770402242
    },
    {
        "content": "<p>It's not two separate defs, only one def</p>",
        "id": 572440842,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770402308
    },
    {
        "content": "<p>When you want to prove stuff about it, you can <code>Fintype.ofFinite</code></p>",
        "id": 572440876,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770402326
    },
    {
        "content": "<p>According to <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> you should try to use <code>Finite</code> in def if possible.</p>",
        "id": 572441032,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1770402383
    },
    {
        "content": "<p>This says: I assumed <code>Finite</code> so surely there's a <code>Finset</code> which contains all the elements, please give me that set so I can sum with it</p>",
        "id": 572441058,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770402397
    },
    {
        "content": "<p>You can use <code>Finite</code> in defs but it requires jumping through hoops, e.g. <code>open Classical in</code></p>",
        "id": 572441197,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770402440
    },
    {
        "content": "<p>But why couldn't people just choose one of Fintype and Finite and stick with it throughout mathlib? When <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> reviewed my PR it sounded like Fintype is just an old thing which shouldn't be used anymore, now I'm confused</p>",
        "id": 572441522,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770402579
    },
    {
        "content": "<p>That makes sense, because it's confusing :)</p>",
        "id": 572441661,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1770402617
    },
    {
        "content": "<p>There's advantages to both. If you're going to be dealing with finite sums, probably the Finset API is better developed</p>",
        "id": 572441801,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1770402671
    },
    {
        "content": "<p>Is it ok to do something like this or is it a diamond?</p>\n<p>variable (X : Type*) [Finite X]</p>\n<p>lemma something_about_sums [Fintype X] : …</p>",
        "id": 572442295,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770402867
    },
    {
        "content": "<p>If I’m gonna take this approach seriously, I’m going to have half the lemmas in a file assume Finite and half of them Fintype</p>",
        "id": 572442371,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770402899
    },
    {
        "content": "<p>And I know that working with a [Monoid G] and then changing your mind in some lemmas to make it a group is very annoying, and you probably had to open a new section when this happens</p>",
        "id": 572442555,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770402961
    },
    {
        "content": "<p>That might be fine but redundant</p>",
        "id": 572444953,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1770403906
    },
    {
        "content": "<p>Wha would be a better way to switch between Finite and Fintype assumptions in-between lemmas?</p>",
        "id": 572445807,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770404215
    },
    {
        "content": "<p>Group the lemmas by which assumption they need, or just don't use <code>variable</code>?</p>",
        "id": 572445963,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1770404273
    },
    {
        "content": "<p>You can also <code>omit [Finite X] in</code> but it gets annoying</p>",
        "id": 572452391,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770406956
    },
    {
        "content": "<p>My take on it would be to use Finite everywhere and finsum everywhere. Finite in definitions is better than Fintype because it's more general -- Fintype implies Finite immediately via typeclass inference with no fuss. If there is missing API in finsum then add it. I would love to see Fintype completely banished from finite group theory.</p>",
        "id": 572479726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770421333
    },
    {
        "content": "<p>The history of finsum was that I was proving Sylow's theorems with an undergraduate and we found Fintype/Finset really annoying and confusing to use, so we switched to Finite and Set.finite and then couldn't do finite sums, so we PRed finsum and when making the basic API we ended up deducing everything from Finset.sum and ended up learning the tricks for Finset and Fintype and then found that actually they weren't bad to use after all so I stopped pushing for more finsum stuff. But recently it's begun to bug me again, it's kind of embedded in group homology because this needs a lot of Finsupp :-/ so now I occasionally dream of making a nonconstructive Finsupp :-/</p>",
        "id": 572480082,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770421633
    },
    {
        "content": "<p>The selling point of Fintype is that you can #eval but given that representation theory traditionally takes place over the complexes you're not going to be able to eval anything anyway. Basically there's a trade off between making things easier for beginners and making things computable.</p>",
        "id": 572480233,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770421777
    },
    {
        "content": "<p>I think there's slightly more to the tradeoff than that, but that's certainly the most prominent dimension of it</p>",
        "id": 572481404,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1770422760
    },
    {
        "content": "<p>IMO the advantage of <code>Finset.sum</code> or <code>Finsupp</code> over <code>finsum</code> is the fact that finiteness is bundled so automation works a lot better. In my experience, when working with<code>finsum</code>s one would need to prove finitely supported again and again by hand and it was quite annoying.</p>",
        "id": 572496738,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1770436886
    },
    {
        "content": "<p>Should there be a <code>Set.Finite.sum</code>?</p>",
        "id": 572514047,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1770456491
    },
    {
        "content": "<p>(or a <code>Finite.sum</code>?)</p>",
        "id": 572514066,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1770456523
    },
    {
        "content": "<p>Or classical bundled finite subsets? Or both? :-)</p>",
        "id": 572546533,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770480467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Summing.20over.20a.20Finite.20type.20which.20is.20not.20a.20Fintype/near/572546533\">said</a>:</p>\n<blockquote>\n<p>Or classical bundled finite subsets? Or both? :-)</p>\n</blockquote>\n<p>I think that's what was discussed here <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/Why.20Finset.3F/with/555667068\">#new members &gt; Why Finset?</a> .</p>",
        "id": 572613858,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1770550032
    }
]