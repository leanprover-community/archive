[
    {
        "content": "<p>Are there Galois categories (in the sense of SGA1) in mathlib4?</p>",
        "id": 399362491,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698693131
    },
    {
        "content": "<p>No</p>",
        "id": 399363892,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698693765
    },
    {
        "content": "<p>What do you think would be the best approach defininig them? I was thinking of going the stacks project way, i.e. defining a galois category to be a pair of a category <code>C</code> and a functor <code>F</code> from <code>C</code> to Sets satisfiying some axioms and then show the fundamental theorem. The SGA1 way would be to define a galois category as a category equivalent to Finite-G-Sets for some profinite group G.</p>",
        "id": 399364828,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698694208
    },
    {
        "content": "<p>The definition should be the category and functor (the \"constructive definition\") and then you should make a definition of the profinite group attached to the Galois category and then prove the theorem that it's isomorphic to the reps of that group. </p>\n<p>One nice extra twist which you don't see in set theory is that in Lean you will be able to let C be in Type u and the target of the functor being Type v and then you can see whether universes always match up in your equivalence.</p>",
        "id": 399367627,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698695603
    },
    {
        "content": "<p>I agree that this would be a really cool project. Please feel free to post some tentative definitions before you leap into proving theorems -- if you get the definitions right then the theorems get easier to prove.</p>",
        "id": 399367887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698695720
    },
    {
        "content": "<p>I suppose the advantage of the SGA1 definition is, that it does not fix a fundamental functor. So in the notation of SGA1 a galois category is a category satisfying some axioms (G1)-(G3) such that there exists a fundemantal functor satisfying some more axioms (G4)-(G6). This lets you naturally speak of different fundamental functors of one galois category. The stacks project definition (and if I understand you correctly also your suggestion) says a galois category is a category satisfying axioms with a fixed fundamental functor.</p>",
        "id": 399369196,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698696215
    },
    {
        "content": "<p>But it does...</p>",
        "id": 399370158,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698696617
    },
    {
        "content": "<p>I mean the SGA definition does implicitly fix a fibre functor, namely the composition of the equivalence with the forgetful functor from G-FSet to FSet.</p>",
        "id": 399370239,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698696661
    },
    {
        "content": "<p>I don't know of a definition in the literature that does not somehow fix a fibre functor (the only variant I can think of that does this is more sophisticated involving some ideas from etale homotopy theory which are beyond what's currently possible to formalize)</p>",
        "id": 399370278,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698696701
    },
    {
        "content": "<p>wait I'm confused. What's the SGA definition?</p>",
        "id": 399370416,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698696759
    },
    {
        "content": "<p>above you said that it uses an equivalence with G-sets.</p>",
        "id": 399370478,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698696795
    },
    {
        "content": "<p>The SGA definition is the following: A galois category is a category <code>C</code> equivalent to the category of Finite-G-Sets where <code>G</code> is a profinite group. I interpret this in the sense that the equivalence is not fixed, i.e. it is just an existence claim.</p>",
        "id": 399370608,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698696847
    },
    {
        "content": "<p>They say: (ad hoc translation from french) \"a category C is galois if and only if it satisfies axioms (G1) - (G3) and if there exists a functor from C to finite Sets satisfying axioms (G4)-(G6)\"</p>",
        "id": 399370796,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698696950
    },
    {
        "content": "<p>Ok I see what you meant.</p>",
        "id": 399370798,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698696951
    },
    {
        "content": "<p>But then you can just claim the existence of a fibre functor with the Stack's definition.</p>",
        "id": 399370915,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698696999
    },
    {
        "content": "<p>Yes, I was just asking you on your opinion whether a galois category should be a pair of a category and a fibre functor or just a category for which a fibre functor exists.</p>",
        "id": 399371012,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698697055
    },
    {
        "content": "<p>I think what Kevin says makes good sense. Take a category <code>C</code> with a functor <code>F</code> satisfying some axioms. Then <em>define</em> <code>G</code> as <code>Aut(F)</code>, show that <code>G</code> is profinite, and then assert that the canonical functor is an equivalence.</p>",
        "id": 399371181,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698697133
    },
    {
        "content": "<p>I guess there is a canonical functor from <code>C</code> to <code>Aut(F)-FSets</code>.</p>",
        "id": 399371267,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698697174
    },
    {
        "content": "<p>And the assertion that this is an equivalence is actually a <code>Prop</code> if you use the fully-faithful essentially surjective approach.</p>",
        "id": 399371359,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698697205
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Galois.20categories/near/399371267\">said</a>:</p>\n<blockquote>\n<p>I guess there is a canonical functor from <code>C</code> to <code>Aut(F)-FSets</code>.</p>\n</blockquote>\n<p>Yes, induced by <code>F</code>.</p>",
        "id": 399371528,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698697282
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Galois.20categories/near/399371359\">said</a>:</p>\n<blockquote>\n<p>And the assertion that this is an equivalence is actually a <code>Prop</code> if you use the fully-faithful essentially surjective approach.</p>\n</blockquote>\n<p>I'll see, SGA1 constructs an actual quasi-inverse.</p>",
        "id": 399371590,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698697313
    },
    {
        "content": "<p>Are there continuous group actions somewhere, i.e. <code>G</code> actions on a category <code>C</code> where for every <code>X : C</code> the canonical map <code>G × X → X</code> is continuous when <code>X</code> is equipped with the discrete topology?</p>",
        "id": 399528547,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698761082
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118107\">@Amelia Livingston</span> did you run into this with Galois cohomology?</p>",
        "id": 399528731,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698761132
    },
    {
        "content": "<p>Searching for Galois cohomology was also my first idea, but that is not in mathlib right?</p>",
        "id": 399528903,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698761180
    },
    {
        "content": "<p>That's right -- Amelia has not yet begun to PR her work in that area.</p>",
        "id": 399529107,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698761254
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousSMul#doc\">docs#ContinuousSMul</a></p>",
        "id": 399536806,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698763608
    },
    {
        "content": "<p>I think that's about all we have right now.</p>",
        "id": 399536978,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698763664
    },
    {
        "content": "<p>I would say that the most important mathematical result to formalize is not the definition of Galois categories, but it is proving the main result in SGA 1 V 4 <em>Conditions axiomatiques d'une théorie de Galois</em> which are axioms in order to turn a functor to finite sets into an equivalence of categories with finite <code>G</code>-sets (as it was mentionned above). Then, eventually, we may have a debate about whether Galois categories should be equipped with a fibre functor or not...</p>",
        "id": 399540665,
        "sender_full_name": "Joël Riou",
        "timestamp": 1698764676
    },
    {
        "content": "<p>I'll wait then if Amelia answers, because I suppose she probably has then already defined the category of continuous actions. So my current (wrong) definition (without the continuity) is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Functor.Hom</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Limits.Shapes.FiniteProducts</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Limits.Shapes.Products</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Limits.Preserves.Finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Algebra.Group.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.RepresentationTheory.Action</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.FintypeCat</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">w</span> <span class=\"n\">v₁</span> <span class=\"n\">u₁</span> <span class=\"n\">u₂</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span> <span class=\"n\">Limits</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ConnectedObject</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">notInitial</span> <span class=\"o\">:</span> <span class=\"n\">IsInitial</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">False</span>\n  <span class=\"n\">noTrivialComponent</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Mono</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">IsIso</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">IsInitial</span> <span class=\"n\">Y</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Stacks Project Definition 0BMY -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">GaloisCategory</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">v₁</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"c1\">-- properties of C</span>\n  <span class=\"n\">hasFiniteLimits</span> <span class=\"o\">:</span> <span class=\"n\">HasFiniteLimits</span> <span class=\"n\">C</span>\n  <span class=\"n\">hasFiniteColimits</span> <span class=\"o\">:</span> <span class=\"n\">HasFiniteColimits</span> <span class=\"n\">C</span>\n  <span class=\"n\">asFiniteCoproductOfConnected</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">ConnectedObject</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)),</span>\n    <span class=\"n\">IsIsomorphic</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"bp\">∐</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n  <span class=\"c1\">-- properties of F</span>\n  <span class=\"n\">imageFinite</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n  <span class=\"n\">reflectsIsos</span> <span class=\"o\">:</span> <span class=\"n\">ReflectsIsomorphisms</span> <span class=\"n\">F</span>\n  <span class=\"n\">leftExact</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteLimits</span> <span class=\"n\">F</span>\n  <span class=\"n\">rightExact</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteColimits</span> <span class=\"n\">F</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">v₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">GaloisCategory</span> <span class=\"n\">C</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">GaloisCategory.imageFinite</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fundamentalGroup</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">v₁</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">v₁</span> <span class=\"n\">v₁</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Aut</span> <span class=\"n\">F</span>\n\n<span class=\"c1\">-- inherit group instance from automorphism group</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">fundamentalGroup</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">show</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">Aut</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n  <span class=\"n\">exact</span> <span class=\"n\">inferInstance</span>\n\n<span class=\"c1\">-- the fundamental group is a profinite group</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"o\">(</span><span class=\"n\">fundamentalGroup</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalGroup</span> <span class=\"o\">(</span><span class=\"n\">fundamentalGroup</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CompactSpace</span> <span class=\"o\">(</span><span class=\"n\">fundamentalGroup</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">TotallyDisconnectedSpace</span> <span class=\"o\">(</span><span class=\"n\">fundamentalGroup</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">T2Space</span> <span class=\"o\">(</span><span class=\"n\">fundamentalGroup</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">πTypes</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Action</span> <span class=\"o\">(</span><span class=\"n\">FintypeCat.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">MonCat.of</span> <span class=\"o\">(</span><span class=\"n\">fundamentalGroup</span> <span class=\"n\">F</span><span class=\"o\">)))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fibreFunctor</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">πTypes</span> <span class=\"n\">F</span> <span class=\"n\">where</span>\n  <span class=\"n\">obj</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">FintypeCat.of</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n    <span class=\"n\">ρ</span> <span class=\"o\">:=</span> <span class=\"n\">MonCat.ofHom</span> <span class=\"o\">{</span>\n      <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">fundamentalGroup</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"n\">g.hom.app</span> <span class=\"n\">X</span>\n      <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n      <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n  <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span>\n    <span class=\"n\">comm</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">g</span>\n      <span class=\"n\">exact</span> <span class=\"n\">symm</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">g.hom.naturality</span> <span class=\"n\">f</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">fibreFunctor</span> <span class=\"n\">F</span> <span class=\"bp\">⋙</span> <span class=\"n\">forget</span> <span class=\"o\">(</span><span class=\"n\">πTypes</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">fundamental</span> <span class=\"o\">:</span> <span class=\"n\">IsEquivalence</span> <span class=\"o\">(</span><span class=\"n\">fibreFunctor</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 399541051,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698764779
    },
    {
        "content": "<p>I adopted the stronger definition of Galois categories of the stacks project, because this makes it simpler to state (in the end, the definition is equivalent to the SGA definition). In particular I ask for all finite limits and finite colimits instead of only asking for fibre products, finite sums and quotients by finite automorphism groups. Do you think this is fine or should we go with the SGA definition (Lenstra in Galois theory for schemes also follows the SGA definition)?</p>",
        "id": 399541882,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698765019
    },
    {
        "content": "<p>There is a comment at the end of SGA 1 V 4 saying that the proof of the main theorm is easier assuming stronger axioms. However, In the case of the étale fundamental group, the verification of the weaker axioms is much easier. I think it would be a problem if we end up with a formalization of Galois categories that cannot eventually be applied to the étale fundamental group, then I think that the formalization should rely on the weaker axioms. (Eventually, we may also have an alternate constructor taking stronger axioms as assumptions...)</p>",
        "id": 399545554,
        "sender_full_name": "Joël Riou",
        "timestamp": 1698766073
    },
    {
        "content": "<p>I agree, but the stacks project also shows that the category of finite etale morphisms of a connected scheme form a galois category in the stronger sense (0BNB), so I don't know if this is actually a big restriction.</p>",
        "id": 399548435,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698766906
    },
    {
        "content": "<p>I prefer the SGA 1 axioms because there are slightly more geometric (with the stress of the action of a finite group <code>G</code> on a scheme <code>X</code> and the study of the quotient <code>X/G</code>), but the proof in the stacks project does not seem to use too much material, so that both ways should be ok.</p>",
        "id": 399554101,
        "sender_full_name": "Joël Riou",
        "timestamp": 1698768034
    },
    {
        "content": "<p>I typed the SGA definition (actually the one in Lenstra which is slightly different since it does not talk about strict epimorphisms):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">quotientDiagram</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"o\">(</span><span class=\"n\">Aut</span> <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span> <span class=\"n\">where</span>\n  <span class=\"n\">obj</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">Aut</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n  <span class=\"n\">map</span> <span class=\"n\">ϕ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">⟩</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">ϕ</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">Aut</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">ϕ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">Category.assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">hf</span> <span class=\"n\">σ</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">ϕ</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">quotientByAutGroup</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"o\">(</span><span class=\"n\">Aut</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n    <span class=\"o\">[</span><span class=\"n\">Corepresentable</span> <span class=\"o\">(</span><span class=\"n\">quotientDiagram</span> <span class=\"n\">X</span> <span class=\"n\">G</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n  <span class=\"n\">coreprX</span> <span class=\"o\">(</span><span class=\"n\">quotientDiagram</span> <span class=\"n\">X</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">coyonedaOfFofQuot</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"o\">(</span><span class=\"n\">Aut</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n    <span class=\"o\">[</span><span class=\"n\">Corepresentable</span> <span class=\"o\">(</span><span class=\"n\">quotientDiagram</span> <span class=\"n\">X</span> <span class=\"n\">G</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n  <span class=\"n\">coyoneda.obj</span> <span class=\"o\">(</span><span class=\"n\">Opposite.op</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">F.obj</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">quotientByAutGroup</span> <span class=\"n\">X</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Lenstra -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">GaloisCategory</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"c1\">-- (G0)</span>\n  <span class=\"n\">imageFinite</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n  <span class=\"c1\">-- (G1)</span>\n  <span class=\"n\">hasTerminalObject</span> <span class=\"o\">:</span> <span class=\"n\">HasTerminal</span> <span class=\"n\">C</span>\n  <span class=\"n\">hasPullbacks</span> <span class=\"o\">:</span> <span class=\"n\">HasPullbacks</span> <span class=\"n\">C</span>\n  <span class=\"c1\">-- (G2)</span>\n  <span class=\"n\">hasFiniteCoproducts</span> <span class=\"o\">:</span> <span class=\"n\">HasFiniteCoproducts</span> <span class=\"n\">C</span>\n  <span class=\"c1\">-- quotient by finite group of automorphisms</span>\n  <span class=\"n\">hasQuotientsByFiniteAutGroups</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"o\">(</span><span class=\"n\">Aut</span> <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">Corepresentable</span> <span class=\"o\">(</span><span class=\"n\">quotientDiagram</span> <span class=\"n\">X</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n  <span class=\"c1\">-- (G3)</span>\n  <span class=\"n\">epiMonoFactorisation</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">),</span>\n    <span class=\"n\">Epi</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">Mono</span> <span class=\"n\">i</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"bp\">≫</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">f</span>\n  <span class=\"n\">monoInducesIsoOnDirectSummand</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Mono</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">IsColimit</span> <span class=\"o\">(</span><span class=\"n\">BinaryCofan.mk</span> <span class=\"n\">i</span> <span class=\"n\">u</span><span class=\"o\">)),</span> <span class=\"n\">True</span>\n\n  <span class=\"c1\">-- (G4)</span>\n  <span class=\"n\">preservesTerminalObjects</span><span class=\"o\">:</span> <span class=\"n\">PreservesLimitsOfShape</span> <span class=\"o\">(</span><span class=\"n\">CategoryTheory.Discrete</span> <span class=\"n\">PEmpty.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">})</span> <span class=\"n\">F</span>\n  <span class=\"n\">preservesPullbacks</span> <span class=\"o\">:</span> <span class=\"n\">PreservesLimitsOfShape</span> <span class=\"n\">WalkingCospan</span> <span class=\"n\">F</span>\n  <span class=\"c1\">-- (G5)</span>\n  <span class=\"n\">preservesFiniteCoproducts</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteCoproducts</span> <span class=\"n\">F</span>\n  <span class=\"n\">preservesEpis</span> <span class=\"o\">:</span> <span class=\"n\">Functor.PreservesEpimorphisms</span> <span class=\"n\">F</span>\n  <span class=\"n\">preservesQuotientsByFiniteAutGroups</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"o\">(</span><span class=\"n\">Aut</span> <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">coyoneda.obj</span> <span class=\"o\">(</span><span class=\"n\">Opposite.op</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">F.obj</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">quotientByAutGroup</span> <span class=\"n\">X</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n           <span class=\"bp\">⟶</span> <span class=\"n\">quotientDiagram</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Subgroup.map</span> <span class=\"o\">(</span><span class=\"n\">mapAut</span> <span class=\"n\">X</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">G</span><span class=\"o\">)),</span>\n    <span class=\"n\">IsIso</span> <span class=\"n\">t</span>\n  <span class=\"c1\">-- (G6)</span>\n  <span class=\"n\">reflectsIsos</span> <span class=\"o\">:</span> <span class=\"n\">ReflectsIsomorphisms</span> <span class=\"n\">F</span>\n</code></pre></div>\n<p>I am very unsure about the way I asked for quotients by finite subgroups of the automorphism group. I first wanted to define this as as some <code>HasColimitsOfShape</code> and <code>PreservesColimitsOfShape</code>, but defining the correct index category for this colimit seemed annoying. So I went with the <code>Corepresentable</code> approach. Do you have any thoughts on this?</p>",
        "id": 399577114,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698775948
    },
    {
        "content": "<p>Also the <code>monoInducesIsoOnDirectSummand</code> seems ugly, is there a better way to formulate this? The issue here is that <code>IsColimit</code> is not a <code>Prop</code>.</p>",
        "id": 399577788,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698776194
    },
    {
        "content": "<p>I think that <code>Has/PreservesColimitsOfShape</code> would be ok, if you consider colimits indexed by the category <code>BG</code> (I am not sure we have it in mathlib?) for any group <code>G : Type v</code>. (Also, I am not sure these fields absolutely need to be <code>Prop</code>s: for example <code>PreservesFiniteCoproducts</code> is not a <code>Prop</code>!) It seems that even Grothendieck was not happy with <code>monoInducesIsoOnDirectSummand</code> and was wondering whether this assumption could be removed...</p>",
        "id": 399582566,
        "sender_full_name": "Joël Riou",
        "timestamp": 1698777845
    },
    {
        "content": "<p>What is the definition of <code>BG</code>?</p>",
        "id": 399584281,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698778470
    },
    {
        "content": "<p><code>BG</code> is the category with one object whose endomorphisms identify to <code>G</code> (this also makes sense for a monoid instead of a group). Then, a functor from <code>BG</code> to a category corresponds to an action of <code>G</code> on an object <code>X</code>, and the colimit of this functor is the quotient by the action of <code>G</code> (here, we do not need to assume <code>G</code> injects in the automorphisms of <code>X</code>).</p>",
        "id": 399586036,
        "sender_full_name": "Joël Riou",
        "timestamp": 1698779066
    },
    {
        "content": "<p>I suppose this: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.SingleObj#doc\">docs#CategoryTheory.SingleObj</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.SingleObj.groupoid#doc\">docs#CategoryTheory.SingleObj.groupoid</a> is sufficient then?</p>",
        "id": 399586630,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698779342
    },
    {
        "content": "<p>Yes.</p>",
        "id": 399595551,
        "sender_full_name": "Joël Riou",
        "timestamp": 1698783451
    },
    {
        "content": "<p>If someone wants to write the string \"BG\" into the doc-string for <code>SingleObj</code> that would be great. :-)</p>",
        "id": 399621265,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1698795917
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Galois.20categories/near/399528547\">said</a>:</p>\n<blockquote>\n<p>Are there continuous group actions somewhere, i.e. <code>G</code> actions on a category <code>C</code> where for every <code>X : C</code> the canonical map <code>G × X → X</code> is continuous when <code>X</code> is equipped with the discrete topology?</p>\n</blockquote>\n<p>Sorry for my slow reply - I have defined these but only in Lean 3. I can start porting &amp; tidying it up for PR.</p>",
        "id": 399692886,
        "sender_full_name": "Amelia Livingston",
        "timestamp": 1698832952
    },
    {
        "content": "<p>That would be great!</p>",
        "id": 399696457,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698834178
    },
    {
        "content": "<p>So I decided to go the harder way, i.e. using the SGA definition.</p>",
        "id": 399703084,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698836546
    },
    {
        "content": "<p>I started to be worried that the typeclasses are not <code>Prop</code> valued, because it makes type class instance inference annoying (I always have to explicitly pass <code>inst : GaloisCategory C F</code>). I suppose making <code>GaloisCategory C F</code> <code>Prop</code> valued is a nightmare, because the only solution I can imagine is formulating everything indirectly, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">preservesFiniteCoproducts</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">PreservesFiniteCoproducts</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">False</span>\n</code></pre></div>\n<p>Alternatively I could state the explicit isomorphisms, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">preservesTerminalObjects</span> <span class=\"o\">:</span> <span class=\"n\">IsIsomorphic</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span><span class=\"n\">_</span> <span class=\"n\">C</span><span class=\"o\">))</span> <span class=\"n\">PUnit</span>\n</code></pre></div>\n<p>But doing this for <code>preservesFiniteCoproducts</code> would mean that deriving things like <code>preservesInitialObject (O : C) (_ : IsInitial O) : IsInitial (F.obj O)</code> is tedious.</p>\n<p>Can I somehow circumvent this by helping the typeclass inference algorithm by stating somewhere in the beginning of files that every instance of <code>GaloisCategory C F</code> should just be the one fixed in the beginning?</p>",
        "id": 399704953,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698837357
    },
    {
        "content": "<p>The same problem arises for <code>ConnectedObject</code> which I initially defined as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">ConnectedObject</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">notInitial</span> <span class=\"o\">:</span> <span class=\"n\">IsInitial</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">False</span>\n  <span class=\"n\">noTrivialComponent</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Mono</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">IsIso</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">IsInitial</span> <span class=\"n\">Y</span>\n</code></pre></div>\n<p>At some point I need to define the subtype <code>ConnectedObjects</code> of <code>C</code>, which with this definition is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ConnectedObjects</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"o\">{</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ConnectedObject</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">True</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>and which \"should be\"</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ConnectedObjects</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">|</span> <span class=\"n\">ConnectedObject</span> <span class=\"n\">A</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>So I changed this to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">ConnectedObject</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">notInitial</span> <span class=\"o\">:</span> <span class=\"n\">IsInitial</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">False</span>\n  <span class=\"n\">noTrivialComponent</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Mono</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"bp\">¬</span> <span class=\"n\">IsIso</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">IsInitial</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">False</span>\n</code></pre></div>\n<p>which again feels a bit silly. Do you have any suggestions on this? I currently prefer the second version, but I am happy to hear your opinions on this.</p>",
        "id": 399705848,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698837830
    },
    {
        "content": "<p>Why not the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">IsConnectedObject</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">notInitial</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">IsInitial</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n  <span class=\"n\">noTrivialComponent</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Mono</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hY</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">IsInitial</span> <span class=\"n\">Y</span><span class=\"o\">)))</span> <span class=\"o\">:</span> <span class=\"n\">IsIso</span> <span class=\"n\">i</span>\n</code></pre></div>",
        "id": 399713190,
        "sender_full_name": "Joël Riou",
        "timestamp": 1698840768
    },
    {
        "content": "<p>Does the first one actually make the usage easier? <code>¬ Nonempty (IsInitial X)</code> is just <code>Nonempty (IsInitial X) → False</code> which seems less simple than <code>IsInitial X  → False</code>. The second one is certainly an improvement, I think I would still rewrite it as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">noTrivialComponent</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Mono</span> <span class=\"n\">i</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hY</span> <span class=\"o\">:</span> <span class=\"n\">IsInitial</span> <span class=\"bp\">→</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsIso</span> <span class=\"n\">i</span>\n</code></pre></div>",
        "id": 399718862,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698843047
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Galois.20categories/near/399704953\">said</a>:</p>\n<blockquote>\n<p>I started to be worried that the typeclasses are not <code>Prop</code> valued, because it makes type class instance inference annoying (I always have to explicitly pass <code>inst : GaloisCategory C F</code>). I suppose making <code>GaloisCategory C F</code> <code>Prop</code> valued is a nightmare, because the only solution I can imagine is formulating everything indirectly, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">preservesFiniteCoproducts</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">PreservesFiniteCoproducts</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">False</span>\n</code></pre></div>\n<p>Alternatively I could state the explicit isomorphisms, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">preservesTerminalObjects</span> <span class=\"o\">:</span> <span class=\"n\">IsIsomorphic</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span><span class=\"n\">_</span> <span class=\"n\">C</span><span class=\"o\">))</span> <span class=\"n\">PUnit</span>\n</code></pre></div>\n<p>But doing this for <code>preservesFiniteCoproducts</code> would mean that deriving things like <code>preservesInitialObject (O : C) (_ : IsInitial O) : IsInitial (F.obj O)</code> is tedious.</p>\n<p>Can I somehow circumvent this by helping the typeclass inference algorithm by stating somewhere in the beginning of files that every instance of <code>GaloisCategory C F</code> should just be the one fixed in the beginning?</p>\n</blockquote>\n<p>I think the main issue preventing instance inference from working properly here is that the first three axioms of <code>GaloisCategory C F</code> don't depend on <code>F</code>, so it can't infer the instance <code>GaloisCategory C F</code> in any statement that does not explicitly involve <code>F</code>. My suggestions is thus to split the definition in two typeclasses:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span> <span class=\"n\">Limits</span> <span class=\"n\">Functor</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Lenstra (G1)-(G3) -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">PreGaloisCategory</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"c1\">-- (G1)</span>\n  <span class=\"n\">hasTerminalObject</span> <span class=\"o\">:</span> <span class=\"n\">HasTerminal</span> <span class=\"n\">C</span>\n  <span class=\"n\">hasPullbacks</span> <span class=\"o\">:</span> <span class=\"n\">HasPullbacks</span> <span class=\"n\">C</span>\n  <span class=\"c1\">-- (G2)</span>\n  <span class=\"n\">hasFiniteCoproducts</span> <span class=\"o\">:</span> <span class=\"n\">HasFiniteCoproducts</span> <span class=\"n\">C</span>\n  <span class=\"n\">hasQuotientsByFiniteGroups</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">HasColimitsOfShape</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">SingleObj</span> <span class=\"n\">G</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- (G3)</span>\n  <span class=\"n\">epiMonoFactorisation</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">),</span>\n    <span class=\"n\">Epi</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">Mono</span> <span class=\"n\">i</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"bp\">≫</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">f</span>\n  <span class=\"n\">monoInducesIsoOnDirectSummand</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Mono</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">IsColimit</span> <span class=\"o\">(</span><span class=\"n\">BinaryCofan.mk</span> <span class=\"n\">i</span> <span class=\"n\">u</span><span class=\"o\">)),</span> <span class=\"n\">True</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Lenstra (G4)-(G6) -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">FundamentalFunctor</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">PreGaloisCategory</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"c1\">-- (G0)</span>\n  <span class=\"n\">imageFinite</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- (G4)</span>\n  <span class=\"n\">preservesTerminalObjects</span> <span class=\"o\">:</span> <span class=\"n\">PreservesLimitsOfShape</span> <span class=\"o\">(</span><span class=\"n\">CategoryTheory.Discrete</span> <span class=\"n\">PEmpty.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">})</span> <span class=\"n\">F</span>\n  <span class=\"c1\">--preservesTerminalObjects : IsIsomorphic (F.obj (⊤_ C)) PUnit</span>\n  <span class=\"n\">preservesPullbacks</span> <span class=\"o\">:</span> <span class=\"n\">PreservesLimitsOfShape</span> <span class=\"n\">WalkingCospan</span> <span class=\"n\">F</span>\n  <span class=\"c1\">-- (G5)</span>\n  <span class=\"n\">preservesFiniteCoproducts</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteCoproducts</span> <span class=\"n\">F</span>\n  <span class=\"n\">preservesEpis</span> <span class=\"o\">:</span> <span class=\"n\">Functor.PreservesEpimorphisms</span> <span class=\"n\">F</span>\n  <span class=\"n\">preservesQuotientsByFiniteGroups</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">PreservesColimitsOfShape</span> <span class=\"o\">(</span><span class=\"n\">SingleObj</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">F</span>\n <span class=\"c1\">-- (G6)</span>\n  <span class=\"n\">reflectsIsos</span> <span class=\"o\">:</span> <span class=\"n\">ReflectsIsomorphisms</span> <span class=\"n\">F</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ConnectedObject</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">notInitial</span> <span class=\"o\">:</span> <span class=\"n\">IsInitial</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">False</span>\n  <span class=\"n\">noTrivialComponent</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Mono</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">IsIso</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">IsInitial</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">False</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">PreGaloisCategory</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">hasTerminal</span> <span class=\"o\">:</span> <span class=\"n\">HasTerminal</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">PreGaloisCategory.hasTerminalObject</span>\n<span class=\"kd\">instance</span> <span class=\"n\">hasPullbacks</span> <span class=\"o\">:</span> <span class=\"n\">HasPullbacks</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">PreGaloisCategory.hasPullbacks</span>\n<span class=\"kd\">instance</span> <span class=\"n\">hasFiniteLimits</span> <span class=\"o\">:</span> <span class=\"n\">HasFiniteLimits</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">hasFiniteLimits_of_hasTerminal_and_pullbacks</span>\n<span class=\"kd\">instance</span> <span class=\"n\">hasBinaryProducts</span>  <span class=\"o\">:</span> <span class=\"n\">HasBinaryProducts</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">hasBinaryProducts_of_hasTerminal_and_pullbacks</span> <span class=\"n\">C</span>\n<span class=\"kd\">instance</span> <span class=\"n\">hasEqualizers</span> <span class=\"o\">:</span> <span class=\"n\">HasEqualizers</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">hasEqualizers_of_hasPullbacks_and_binary_products</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">PreGaloisCategory</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FundamentalFunctor</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">FundamentalFunctor.imageFinite</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">PreservesLimitsOfShape</span> <span class=\"o\">(</span><span class=\"n\">CategoryTheory.Discrete</span> <span class=\"n\">PEmpty.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">})</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"n\">FundamentalFunctor.preservesTerminalObjects</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">PreservesLimitsOfShape</span> <span class=\"n\">WalkingCospan</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"n\">FundamentalFunctor.preservesPullbacks</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteCoproducts</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"n\">FundamentalFunctor.preservesFiniteCoproducts</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">PreservesColimitsOfShape</span> <span class=\"o\">(</span><span class=\"n\">Discrete</span> <span class=\"n\">PEmpty.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">})</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"n\">FundamentalFunctor.preservesFiniteCoproducts.preserves</span> <span class=\"n\">PEmpty</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ReflectsIsomorphisms</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"n\">FundamentalFunctor.reflectsIsos</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">preservesFiniteLimits</span> <span class=\"o\">:</span> <span class=\"n\">PreservesFiniteLimits</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"n\">preservesFiniteLimitsOfPreservesTerminalAndPullbacks</span> <span class=\"n\">F</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">preservesInitialObject</span> <span class=\"o\">(</span><span class=\"n\">O</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsInitial</span> <span class=\"n\">O</span> <span class=\"bp\">→</span> <span class=\"n\">IsInitial</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">O</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">IsInitial.isInitialObj</span> <span class=\"n\">F</span> <span class=\"n\">O</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">preservesMonomorphisms</span> <span class=\"o\">:</span> <span class=\"n\">PreservesMonomorphisms</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"n\">preservesMonomorphisms_of_preservesLimitsOfShape</span> <span class=\"n\">F</span>\n</code></pre></div>\n<p>As you can see instance inference now works properly and subsequent proofs become way cleaner, because all instances are automatically inferred. What do you think about the split?</p>",
        "id": 399912150,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698923862
    },
    {
        "content": "<p><code>FundamentalFunctor</code> presumably isn't a Prop because you used constructive finiteness (<code>Fintype</code>) instead of <code>Finite</code>. I don't know what is best.</p>",
        "id": 399925670,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698928454
    },
    {
        "content": "<p>I think <code>FundamentalFunctor</code> can't reasonably become a <code>Prop</code> because all the <code>PreservesFiniteCoproducts F</code> etc. are no <code>Props</code>.</p>",
        "id": 399932533,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698930503
    },
    {
        "content": "<p>You know that we have the category of finite types, right? <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FintypeCat#doc\">docs#FintypeCat</a> I think?</p>",
        "id": 399950944,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698935639
    },
    {
        "content": "<p>So you should probably just take your fibre functor to take values in this category</p>",
        "id": 399951108,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698935680
    },
    {
        "content": "<p>Also, I think <code>Fib(re/er)Functor</code> (for some choice of <code>re</code> or <code>er</code>) is the standard name, as opposed to <code>FundamentalFunctor</code>.</p>",
        "id": 399951309,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698935744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Galois.20categories/near/399932533\">said</a>:</p>\n<blockquote>\n<p>I think <code>FundamentalFunctor</code> can't reasonably become a <code>Prop</code> because all the <code>PreservesFiniteCoproducts F</code> etc. are no <code>Props</code>.</p>\n</blockquote>\n<p>This should be refactored at some point...</p>",
        "id": 399951930,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698935897
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Galois.20categories/near/399950944\">said</a>:</p>\n<blockquote>\n<p>You know that we have the category of finite types, right? <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FintypeCat#doc\">docs#FintypeCat</a> I think?</p>\n</blockquote>\n<p>I thought about this, but decided against it, because I assumed there was more solid API for the category of types, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.injective_of_mono#doc\">docs#CategoryTheory.injective_of_mono</a> works in <code>Type w</code> but not in <code>FintypeCat</code> and I was afraid that there are more of these.</p>",
        "id": 399958142,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698937212
    },
    {
        "content": "<p>That's strange... we should have something for concrete categories where the forgetful functor reflects monos. If we don't have such an API, then it should be added anyway</p>",
        "id": 399959212,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698937367
    },
    {
        "content": "<p>Anyway, I would <em>very strongly</em> suggest that you use <code>FintypeCat</code>. If some API is missing, we should add it.</p>",
        "id": 399959839,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698937460
    },
    {
        "content": "<p>For example, what if at some point you want to compose your fibre functor with the inclusion from <code>FSet</code> to <code>Profinite</code>? That doesn't seem unreasonable, and making the fibre functor land in <code>Type _</code> would make this very difficult, but it would be trivial if instead it landed in <code>FintypeCat</code>.</p>",
        "id": 399960653,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698937612
    },
    {
        "content": "<p>Can you say <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SplitMonoCategory#doc\">docs#SplitMonoCategory</a> + <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsIdempotentComplete#doc\">docs#IsIdempotentComplete</a> in place of the mono splitting condition?</p>",
        "id": 399977557,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1698941729
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Galois.20categories/near/399977557\">said</a>:</p>\n<blockquote>\n<p>Can you say <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SplitMonoCategory#doc\">docs#SplitMonoCategory</a> + <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsIdempotentComplete#doc\">docs#IsIdempotentComplete</a> in place of the mono splitting condition?</p>\n</blockquote>\n<p>Sorry, why is this equivalent? At least <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.IsIdempotentComplete#doc\">docs#CategoryTheory.IsIdempotentComplete</a> is already implied by the rest, since <code>C</code> has finite limits (since it has a terminal object and pullbacks).</p>",
        "id": 399985416,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698944275
    },
    {
        "content": "<p>If every mono is the composition of an isomorphism and the inclusion of a summand, then you have your splitting from the splitting of the summand and the inverse. If every mono is split, then you get a summand from idempotent completeness.</p>",
        "id": 399987171,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1698944780
    },
    {
        "content": "<p>I still can't follow: why is the inclusion of a summand split?</p>",
        "id": 399990128,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698945865
    },
    {
        "content": "<p>The category of finite sets with the identity as fibre functor is Galois but the inclusion of the empty set into a singleton is a monomorphism that does not split, since there simply is no map in the other direction.</p>",
        "id": 399991305,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698946317
    },
    {
        "content": "<p>Ah ok. I didn't read carefully terminal \\neq initial here.</p>",
        "id": 399992115,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1698946624
    },
    {
        "content": "<p>Also why I phrased it as a question :)</p>",
        "id": 399992144,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1698946637
    },
    {
        "content": "<p>But there should be something cleaner than <code>∃ (Z : C) (u : Z ⟶ Y)\n    (_ : IsColimit (BinaryCofan.mk i u)), True</code></p>",
        "id": 399992322,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1698946697
    },
    {
        "content": "<p>I agree, one could say <code>∃ (Z : C) (f : coprod X Z ≅ Y), f.hom ≫ coprod.inl = i</code> instead, but the current statement is closer to \"there is some object <code>Z</code> and some map <code>u : Z ⟶ Y</code> such that (Y,i,u) is the coproduct of <code>X</code> and <code>Z</code>\" (which seems to me the better formulation)</p>",
        "id": 399993689,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698947213
    },
    {
        "content": "<p>You don't want to use <code>Nonempty</code>?</p>",
        "id": 399997068,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1698948564
    },
    {
        "content": "<p>I have collected most of the arguments to show that a fibre functor <code>F</code> is pro-corepresentable. Now I don't really know how to say this. There does not seem to be a notion of pro category or pro-corepresentability yet. I suppose that approach would be the most elegant?</p>\n<p>That is the current setup (I left out some implementations, since that is not releveant to my question)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">FintypeCat.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">[</span><span class=\"n\">PreGaloisCategory</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FibreFunctor</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ConnectedObjects</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">|</span> <span class=\"n\">ConnectedObject</span> <span class=\"n\">A</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Idx</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">ConnectedObjects</span> <span class=\"n\">C</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">F.obj</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Category</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">diag</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Idx</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n    <span class=\"n\">exact</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span>\n</code></pre></div>\n<p>Then the statement would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">colimit</span> <span class=\"o\">(</span><span class=\"n\">diag</span> <span class=\"n\">F</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">≅</span> <span class=\"o\">(</span><span class=\"n\">FintypeCat.incl.obj</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(from this I can then of course deduce that the left hand side is actually finite and that therefore the colimit already exists in <code>FintypeCat</code> and that we obtain the iso in <code>FintypeCat</code> )</p>\n<p>Do you have any suggestions on this? Is someone working on pro-categories / pro-corepresentability?</p>",
        "id": 402328609,
        "sender_full_name": "Christian Merten",
        "timestamp": 1700082723
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span> has a rather elegant formalisation in lean 3 which was never PRed of ind-categories, so it would be just a case of (a) remembering where it was (b) porting it (manually, should be straightforward) and (c) changing the direction of the arrows (d) PRing it. My guess is that this is a viable approach which will work well if we can get past (a,)</p>",
        "id": 402419451,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700125685
    },
    {
        "content": "<p>I suggest something along the lines of:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Limits.Types</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Limits.HasLimits</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span> <span class=\"n\">Limits</span> <span class=\"n\">Functor</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">Constructions</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">SmallCategory</span> <span class=\"n\">J</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"n\">obj</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">X.obj</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">⟩</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span>\n  <span class=\"n\">map</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">}</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">g</span>\n    <span class=\"k\">show</span> <span class=\"n\">X.obj</span> <span class=\"o\">{</span> <span class=\"n\">unop</span> <span class=\"o\">:=</span> <span class=\"n\">j</span> <span class=\"o\">}</span>  <span class=\"bp\">⟶</span> <span class=\"n\">Y</span>\n    <span class=\"n\">exact</span> <span class=\"n\">X.map</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">⟩</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span>\n  <span class=\"n\">map_id</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X.obj</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">⟩</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n    <span class=\"k\">show</span> <span class=\"n\">X.map</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">⟩)</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">g</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">CategoryTheory.Functor.map_id</span><span class=\"o\">,</span> <span class=\"n\">Category.id_comp</span><span class=\"o\">]</span>\n  <span class=\"n\">map_comp</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">}</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X.obj</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">⟩</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n    <span class=\"k\">show</span> <span class=\"n\">X.map</span> <span class=\"o\">(⟨</span><span class=\"n\">g</span><span class=\"o\">⟩</span> <span class=\"bp\">≫</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">⟩)</span> <span class=\"bp\">≫</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">X.map</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">⟩</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">X.map</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">⟩</span> <span class=\"bp\">≫</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">map_comp</span><span class=\"o\">,</span> <span class=\"n\">Category.assoc</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">D_obj_eq</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">X.obj</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">⟩</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Dtrans</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">D</span> <span class=\"n\">X</span> <span class=\"n\">Z</span> <span class=\"n\">where</span>\n  <span class=\"n\">app</span> <span class=\"n\">i</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">g</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span>\n  <span class=\"n\">naturality</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X.obj</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">⟩</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n    <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">X.map</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">⟩</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">X.map</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">⟩</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Category.assoc</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Dtrans_app_eq</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">Dtrans</span> <span class=\"n\">X</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">i</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Dtrans_id_eq</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Dtrans</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X.obj</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">⟩</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n  <span class=\"k\">show</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"mi\">𝟙</span> <span class=\"n\">Y</span> <span class=\"bp\">=</span> <span class=\"n\">f</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Category.comp_id</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Dtrans_comp_eq</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">⟶</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Dtrans</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Dtrans</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">Dtrans</span> <span class=\"n\">X</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">X.obj</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">⟩</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n  <span class=\"k\">show</span> <span class=\"n\">u</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">≫</span>  <span class=\"n\">g</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Category.assoc</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">colimMapIdentity</span> <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">HasColimit</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n    <span class=\"o\">:</span> <span class=\"n\">colimMap</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"n\">colimit</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">aesop</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">colimMapComp</span> <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">HasColimit</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">HasColimit</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasColimit</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">⟶</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">⟶</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"n\">colimMap</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">≫</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">colimMap</span> <span class=\"n\">t</span> <span class=\"bp\">≫</span> <span class=\"n\">colimMap</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">aesop</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"n\">obj</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">colimit</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n  <span class=\"n\">map</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">show</span> <span class=\"n\">colimit</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">colimit</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">X</span> <span class=\"n\">Z</span><span class=\"o\">)</span>\n    <span class=\"n\">exact</span> <span class=\"n\">colim.map</span> <span class=\"o\">(</span><span class=\"n\">Dtrans</span> <span class=\"n\">X</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"n\">map_id</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">colim_map</span><span class=\"o\">,</span> <span class=\"n\">Dtrans_id_eq</span><span class=\"o\">,</span> <span class=\"n\">colimMapIdentity</span><span class=\"o\">]</span>\n  <span class=\"n\">map_comp</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"n\">W</span><span class=\"o\">}</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">colim_map</span><span class=\"o\">,</span> <span class=\"n\">Dtrans_comp_eq</span><span class=\"o\">,</span> <span class=\"n\">colimMapComp</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">h_map_eq</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X.obj</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">⟩</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)):</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">colimit.ι</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">colimit.ι</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">X</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">≫</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">procoyonedaLemma</span> <span class=\"o\">[</span><span class=\"n\">IsFiltered</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">limit</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⋙</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">refine</span> <span class=\"n\">Types.Limit.mk</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⋙</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n    <span class=\"n\">intro</span> <span class=\"n\">i</span>\n    <span class=\"n\">exact</span> <span class=\"n\">t.app</span> <span class=\"o\">(</span><span class=\"n\">X.obj</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">colimit.ι</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">X.obj</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"n\">i.unop</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"n\">X.obj</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n    <span class=\"n\">intro</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">u</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">t.naturality</span> <span class=\"o\">(</span><span class=\"n\">X.map</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">colimit.ι</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">X.obj</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"n\">i.unop</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"n\">X.obj</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n    <span class=\"n\">simp</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">this</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">colimit.ι</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">X.obj</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"n\">i.unop</span> <span class=\"o\">(</span><span class=\"n\">X.map</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n        <span class=\"n\">colimit.ι</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">X.obj</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"n\">j.unop</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"n\">X.obj</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"c1\">--apply (Types.FilteredColimit.colimit_eq_iff (D X (X.obj j))).mpr</span>\n      <span class=\"gr\">admit</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Constructions</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Proobject</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n  <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">Jcategory</span> <span class=\"o\">:</span> <span class=\"n\">SmallCategory</span> <span class=\"n\">J</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Jfiltered</span> <span class=\"o\">:</span> <span class=\"n\">IsFiltered</span> <span class=\"n\">J</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Proobject</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">SmallCategory</span> <span class=\"n\">X.J</span> <span class=\"o\">:=</span> <span class=\"n\">X.Jcategory</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Proobject</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsFiltered</span> <span class=\"n\">X.J</span> <span class=\"o\">:=</span> <span class=\"n\">X.Jfiltered</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Category</span> <span class=\"o\">(</span><span class=\"n\">Proobject</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">Hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">limit</span> <span class=\"o\">(</span><span class=\"n\">Y.X</span> <span class=\"bp\">⋙</span> <span class=\"n\">h</span> <span class=\"n\">X.X</span><span class=\"o\">)</span>\n  <span class=\"n\">id</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">procoyonedaLemma</span> <span class=\"n\">X.X</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">X.X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">X.X</span><span class=\"o\">))</span>\n  <span class=\"n\">comp</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"n\">Z.X</span> <span class=\"bp\">⟶</span> <span class=\"n\">h</span> <span class=\"n\">Y.X</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">procoyonedaLemma</span> <span class=\"n\">Z.X</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">Y.X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">g</span>\n    <span class=\"k\">let</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"n\">Y.X</span> <span class=\"bp\">⟶</span> <span class=\"n\">h</span> <span class=\"n\">X.X</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">procoyonedaLemma</span> <span class=\"n\">Y.X</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">X.X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">f</span>\n    <span class=\"n\">exact</span> <span class=\"n\">procoyonedaLemma</span> <span class=\"n\">Z.X</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">X.X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">≫</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Procorepresentable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">has_procorepresentation</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Proobject</span> <span class=\"n\">C</span><span class=\"o\">),</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">X.X</span> <span class=\"bp\">≅</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I defined a proobject as an inverse system instead of the associated covariant functor to <code>Type u</code>, the category instance by construction makes the procoyoneda embedding fully faithful.</p>",
        "id": 402439142,
        "sender_full_name": "Christian Merten",
        "timestamp": 1700131457
    },
    {
        "content": "<p>The universes need to be generalised, some universe problem also currently prevents me from using <code>Types.FilteredColimit.colimit_eq_iff</code> in one of the sorried helpers.</p>",
        "id": 402439448,
        "sender_full_name": "Christian Merten",
        "timestamp": 1700131543
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Galois.20categories/near/402419451\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> has a rather elegant formalisation in lean 3 which was never PRed of ind-categories, so it would be just a case of (a) remembering where it was (b) porting it (manually, should be straightforward) and (c) changing the direction of the arrows (d) PRing it. My guess is that this is a viable approach which will work well if we can get past (a,)</p>\n</blockquote>\n<p>I don't remember formalising ind-categories. Perhaps you were thinking about this small formalisation of the poset version? <a href=\"https://gist.github.com/dwarn/038887d7a9d5d7d6147fbbada2571f63\">https://gist.github.com/dwarn/038887d7a9d5d7d6147fbbada2571f63</a></p>",
        "id": 402443694,
        "sender_full_name": "David Wärn",
        "timestamp": 1700132769
    },
    {
        "content": "<p>Ok I'll do some hunting because I was definitely not thinking of that :-) Maybe my mind is playing tricks on me but I'm still half confident</p>",
        "id": 402468981,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700141043
    },
    {
        "content": "<p>I remember <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> working on ind categories</p>",
        "id": 402472408,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700142107
    },
    {
        "content": "<p>OK Apologies for summoning you David, I've now looked back at some DMs and I am instead going to summon <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> with the claim that _they_ wrote ind-categories in Lean 3. How am I doing this time?</p>",
        "id": 402486650,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700146084
    },
    {
        "content": "<p>Are you referencing this commit? <a href=\"https://github.com/leanprover-community/mathlib/compare/master...ind_object\">https://github.com/leanprover-community/mathlib/compare/master...ind_object</a></p>",
        "id": 402487461,
        "sender_full_name": "Christian Merten",
        "timestamp": 1700146317
    },
    {
        "content": "<p>I have this: <a href=\"https://github.com/leanprover-community/mathlib4/blob/coyoneda-extended/Mathlib/CategoryTheory/Limits/Indization/IndObject.lean\">https://github.com/leanprover-community/mathlib4/blob/coyoneda-extended/Mathlib/CategoryTheory/Limits/Indization/IndObject.lean</a> It follows Kashiwara-Schapira. I am planning to develop this much further, my goal is to show that Pro(C) (or was it Ind(C)? Not sure) is Grothendieck if C is abelian. I am expecting to (finally) get back to this in December.</p>",
        "id": 402490710,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1700147092
    },
    {
        "content": "<p>Do you plan to define <code>Ind C</code> as the full subcategory of indrepresentable presheafs? Or as inductive systems, i.e. <code>(J : Type w) [IsFiltered J] (X : J ⥤ C)</code> as in FGA?</p>",
        "id": 402495006,
        "sender_full_name": "Christian Merten",
        "timestamp": 1700148204
    },
    {
        "content": "<p>I still have a bunch of things that I want to do before I even get to defining the category structure, but an argument against defining it as a full subcategory is that the universes for morphisms are too large and you would have to work with <code>LocallySmall</code> everywhere. So I'm leaning towards your more explicit definition above.</p>",
        "id": 402498812,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1700149217
    },
    {
        "content": "<p>I wrote (because I needed this direction) a category instance on <code>Pro C</code> using a <code>procoyonedaLemma</code> (I posted a preliminary version above, that I have worked out in the meantime). Is this similar to what you had in mind for defining the category instance?</p>",
        "id": 402499768,
        "sender_full_name": "Christian Merten",
        "timestamp": 1700149468
    },
    {
        "content": "<p>I was thinking of the 'as diagrams' definition in <a href=\"https://ncatlab.org/nlab/show/ind-object\">https://ncatlab.org/nlab/show/ind-object</a>, which at least looks similar to what you have</p>",
        "id": 402500950,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1700149803
    },
    {
        "content": "<p>Oh great to see it's in Lean 4 now! :D</p>",
        "id": 402501757,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700150028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Galois.20categories/near/402500950\">said</a>:</p>\n<blockquote>\n<p>I was thinking of the 'as diagrams' definition in <a href=\"https://ncatlab.org/nlab/show/ind-object\">https://ncatlab.org/nlab/show/ind-object</a>, which at least looks similar to what you have</p>\n</blockquote>\n<p>That should be the dual of what I did: the composition law is then just composing the corresponding natural transformations via (ind/pro) yoneda.</p>",
        "id": 402501978,
        "sender_full_name": "Christian Merten",
        "timestamp": 1700150092
    },
    {
        "content": "<p>For the formalization of ind/pro-objects, I would prefer we follow <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> definition as a full subcategory of the category of presheaves of sets, and that we provide a constructor which would take as an input a functor from a filtered category.</p>",
        "id": 402537628,
        "sender_full_name": "Joël Riou",
        "timestamp": 1700161692
    },
    {
        "content": "<p>You mean the definition as in <a href=\"https://github.com/leanprover-community/mathlib/compare/master...ind_object\">https://github.com/leanprover-community/mathlib/compare/master...ind_object</a>? Not the one Markus mentioned earlier in this thread.</p>",
        "id": 402538255,
        "sender_full_name": "Christian Merten",
        "timestamp": 1700161975
    },
    {
        "content": "<p>Yes, this one.</p>",
        "id": 402538853,
        "sender_full_name": "Joël Riou",
        "timestamp": 1700162189
    },
    {
        "content": "<p>Certainly for stating that a presheaf is pro-representable one does not need pro-categories, but rather just state that there is a cofiltered diagram in <code>C</code> and a cone in presheaves with cone point the given presheaf over the functor composing the diagram with the yoneda embedding, then assert that this cone is a limit.</p>",
        "id": 402540339,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700162718
    },
    {
        "content": "<p>Something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsProRepresentable</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">cond</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_h</span> <span class=\"o\">:</span> <span class=\"n\">SmallCategory</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">IsCofiltered</span> <span class=\"n\">J</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Functor.const</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">F</span> <span class=\"bp\">⟶</span> <span class=\"n\">E</span> <span class=\"bp\">⋙</span> <span class=\"n\">yoneda</span><span class=\"o\">),</span>\n    <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">Limits.IsLimit</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">app</span><span class=\"o\">⟩)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CategoryTheory</span>\n</code></pre></div>",
        "id": 402541514,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700163201
    },
    {
        "content": "<p>Thanks Adam. I think I'll go for some variant of this. Since I need this for covariant functors: Given <code>J : Type w</code> with <code>[IsFiltered J]</code>, a diagram <code>X : Jᵒᵖ ⥤ C</code> does not compose with <code>coyoneda</code>. Should I put the <code>ᵒᵖ</code> on the <code>C</code> then?</p>",
        "id": 402541980,
        "sender_full_name": "Christian Merten",
        "timestamp": 1700163383
    },
    {
        "content": "<p>I'm confused... why do you need covariant functors?</p>",
        "id": 402542126,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700163451
    },
    {
        "content": "<p>Because the fibre functor is covariant.</p>",
        "id": 402542183,
        "sender_full_name": "Christian Merten",
        "timestamp": 1700163475
    },
    {
        "content": "<p>Ok in that case I would use <code>coyoneda</code> and interchange <code>C</code> and <code>Cop</code>.</p>",
        "id": 402542365,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700163536
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">IsProRepresentable</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">cond</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_h</span> <span class=\"o\">:</span> <span class=\"n\">SmallCategory</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">IsCofiltered</span> <span class=\"n\">J</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Functor.const</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">F</span> <span class=\"bp\">⟶</span> <span class=\"n\">E</span> <span class=\"bp\">⋙</span> <span class=\"n\">coyoneda</span><span class=\"o\">),</span>\n    <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">Limits.IsLimit</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">app</span><span class=\"o\">⟩)</span>\n</code></pre></div>",
        "id": 402542462,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700163572
    },
    {
        "content": "<p>Oh but I guess in this case one should indeed assume <code>Filtered</code> as opposed to `Cofiltered</p>",
        "id": 402542606,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700163614
    },
    {
        "content": "<p>So something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">IsProRepresentable</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">cond</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_h</span> <span class=\"o\">:</span> <span class=\"n\">SmallCategory</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">IsFiltered</span> <span class=\"n\">J</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Functor.const</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">F</span> <span class=\"bp\">⟶</span> <span class=\"n\">E</span> <span class=\"bp\">⋙</span> <span class=\"n\">coyoneda</span><span class=\"o\">),</span>\n    <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">Limits.IsLimit</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">app</span><span class=\"o\">⟩)</span>\n</code></pre></div>",
        "id": 402542667,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700163644
    },
    {
        "content": "<p>I was just going to ask about this :D But I am not sure, too many reversals of arrows at the same time.</p>",
        "id": 402542671,
        "sender_full_name": "Christian Merten",
        "timestamp": 1700163646
    },
    {
        "content": "<p>yeah I'm confused too :)</p>",
        "id": 402542692,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700163657
    },
    {
        "content": "<p>Ah and doesn't <code>app</code> need to go in the other direction as well? When I plug in a <code>Y : C</code>, I want <code>colim Hom(X_i, Y) ≅ F(Y)</code> (in mixed lean paper notation).</p>",
        "id": 402543669,
        "sender_full_name": "Christian Merten",
        "timestamp": 1700164046
    },
    {
        "content": "<p>yeah you're right, and <code>IsLimit</code> should be <code>IsColimit</code>.</p>",
        "id": 402543919,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700164142
    },
    {
        "content": "<p>Thank you :)</p>",
        "id": 402549878,
        "sender_full_name": "Christian Merten",
        "timestamp": 1700166178
    },
    {
        "content": "<p>I did work on ind- and pro-objects, but I don't remember enough of the details off the top of my head to be that helpful here. I mostly just worked off nlab and its references, and I trust Markus to have good definitions!</p>",
        "id": 402570790,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1700175058
    }
]