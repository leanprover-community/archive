[
    {
        "content": "<p>Someone asked me about planar graphs in Mathlib; I couldn't find anything after a quick search in docs, and then google found this: <a href=\"https://manifold.markets/tfae/will-lean-mathlib-have-a-definition?play=true\">https://manifold.markets/tfae/will-lean-mathlib-have-a-definition?play=true</a>. Do we really not have them? Naively, I would think you do something like this (cobbled together with help from GPT, untested!):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- Edge relations, no further assumptions like simplicity, finiteness, etc</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PlaneEmbedding</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- Edge relation</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">embedding</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- Map vertices to points in ‚Ñù¬≤</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">edge_curves</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Map each edge to a curve</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">edge_continuous</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">edge_curves</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Curves must be continuous</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">edge_ends</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">edge_curves</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">embedding</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">edge_curves</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">embedding</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Curve endpoints match vertex positions</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">non_intersecting</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">w‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">v‚ÇÇ</span><span class=\"w\"> </span><span class=\"n\">w‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h‚ÇÅ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">v‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">w‚ÇÅ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">v‚ÇÇ</span><span class=\"w\"> </span><span class=\"n\">w‚ÇÇ</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">v‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"n\">v‚ÇÇ</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">w‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"n\">w‚ÇÇ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span>\n<span class=\"w\">    </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">PairwiseDisjoint</span>\n<span class=\"w\">      </span><span class=\"o\">{</span><span class=\"n\">t‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">edge_curves</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">t‚ÇÅ</span><span class=\"o\">}</span>\n<span class=\"w\">      </span><span class=\"o\">{</span><span class=\"n\">t‚ÇÇ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">edge_curves</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÇ</span><span class=\"w\"> </span><span class=\"n\">t‚ÇÇ</span><span class=\"o\">})</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Edges do not intersect, except possibly at endpoints</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PlaneEmbedding</span><span class=\"bp\">.</span><span class=\"n\">toGraph</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">emb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PlaneEmbedding</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">‚ü®</span><span class=\"n\">emb</span><span class=\"bp\">.</span><span class=\"n\">E</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsPlanar</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Graph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">emb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PlaneEmbedding</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">emb</span><span class=\"bp\">.</span><span class=\"n\">toGraph</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">G</span>\n</code></pre></div>\n<p>The <code>PlaneEmbedding</code> structure isn't quite right yet (especially <code>non-intersecting</code>). But it certainly doesn't seem not doable...? What am I missing? Thanks!</p>",
        "id": 492352425,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1736270190
    },
    {
        "content": "<p>I would think that you would want to define planar graphs in terms of the equivalent graph-theoretic properties (i.e., does not contain a subgraph isomorphic to K_5 or K_{3,3}, IIRC). Then you would prove a theorem that this is equivalent to the <code>PlaneEmbedding</code> version you describe.</p>",
        "id": 492353146,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1736270468
    },
    {
        "content": "<p>But I can't imagine <code>PlaneEmbedding</code> being particularly nice to work with in practice.</p>",
        "id": 492353228,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1736270505
    },
    {
        "content": "<p>I agree that there could be situations in which it is easier to work with the forbidden minor characterization, but I don't see why it follows that it should be the definition.</p>",
        "id": 492357641,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1736272176
    },
    {
        "content": "<p>I would imagine that it should be the definition because it's <em>intrinsic</em>, and therefore doesn't require importing anything about <code>‚Ñù</code>. This is common practice throughout Mathlib, and formalization more generally.</p>",
        "id": 492358409,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1736272461
    },
    {
        "content": "<p>What about this: a planar graph is the 1-skeleton of a CW complex which is homeomorphic to the 2-sphere.</p>",
        "id": 492359700,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1736272932
    },
    {
        "content": "<p>I know this isn't intrinsic either, but I suspect it is easier to work with in a lot of situations</p>",
        "id": 492359754,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1736272953
    },
    {
        "content": "<p>My initial inclination would again be: why not just make that a theorem? In any case, it's not really my area of Mathlib, so I'll shut up now.</p>",
        "id": 492360402,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1736273189
    },
    {
        "content": "<p>I guess it's worth pointing out the obvious: Gonthier already thought about this question a lot (and wasn't his answer \"combinatorial hypermaps\"?)</p>",
        "id": 492367041,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1736275781
    },
    {
        "content": "<p>Defining combinatorial maps is straightforward (and may have been done outside mathlib, though in mathlib we might want a maximally general version covering spaces in more than two dimensions etc.), and it seems they are convenient for formal proof. Defining plane embeddings of graphs is also straightforward. Linking the two, so that you can use results proved with combinatorial maps on graphs / maps given as plane embeddings (which is something I'll want eventually for AperiodicMonotilesLean - Euler's theorem for plane maps on actual (polygonal) maps in the plane), requires a lot more work (the Jordan curve theorem).</p>",
        "id": 492389421,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1736284808
    },
    {
        "content": "<p>I think Wagner's and Kuratowski's theorems should definitely be theorems about planar graphs, not definitions.</p>",
        "id": 492389626,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1736284912
    },
    {
        "content": "<p>Yes, the definition should certainly be combinatorial, either Gonthier's approach, or just lots of explicit incidence data about edges and faces.</p>",
        "id": 492401148,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736289924
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"373986\">@Kalle Kyt√∂l√§</span> who has been thinking about combinatorial maps in Lean</p>",
        "id": 492412076,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1736295747
    },
    {
        "content": "<p>As a semi-intrinsic definition, I like Euler characteristic: say a combinatorial map is planar if V - E + F is twice the number of connected components. Then, say a graph is planar if it is the skeleton of a planar combinatorial map.</p>\n<p>Connecting this up to a topological definition requires the Jordan curve theorem, some homology, and some bit of the classification of compact closed surfaces. But, at least on paper, I find it to be a lot more workable than the Kuratowski criterion.</p>",
        "id": 492421667,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1736301945
    },
    {
        "content": "<p>Note that the idea of planar graphs had been reworked out by Gonthier and his team when they formalized the 4-colour theorem. I suspect that mathlib could/should make good profit of their work.</p>",
        "id": 492551430,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1736356804
    },
    {
        "content": "<p>Indeed, they use the Euler characteristic in the definition of a planar map. (<a href=\"https://inria.hal.science/hal-04034866/document\">https://inria.hal.science/hal-04034866/document</a>)</p>",
        "id": 492557304,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1736358933
    },
    {
        "content": "<p>I'm surprised that the list of 100 theorems to formalize doesn't include proving that (connected) planar graphs have Euler characteristic = 2. (In which case, you can't solve it by definition!...) Seems like the kind of result that should have been included...?</p>",
        "id": 492804807,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1736452000
    },
    {
        "content": "<p>It seems Gonthier has an approach for proving this Euler characteristic property that bypasses the Jordan curve theorem.</p>\n<p>Gonthier also has a very general topological definition of planar maps that allows regions in the map whose boundaries aren't made up of Jordan arcs (see the discussion of corners not necessarily being isolated points, which is not something you can get with a locally finite map where each region's boundary is made up of finitely many Jordan arcs, disjoint except at endpoints).</p>",
        "id": 492862158,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1736476284
    },
    {
        "content": "<p>The existence of an ‚Äúabstract dual‚Äù of a graph is one way to define planarity. But this needs to be done at a level that allows for multigraphs.</p>",
        "id": 497273031,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738515760
    },
    {
        "content": "<p>More concretely: a definition of planarity that doesn‚Äôt allow for duality (for each embedding there is a dual embedding where faces and vertices are swapped) is the wrong definition - it would mean that the dual version of every theorem about planar graphs would have to be proved separately.</p>\n<p>And any definition of planarity that has duality needs to allow for non-simple graphs, since degree-2 primal vertices correspond to parallel edges in the dual. </p>\n<p>Combinatorial hypermaps are one way to do this, and are probably the right one, because they encode precisely the combinatorially relevant geometric information about an embedding. Abstracts duals are a ‚Äòlighter‚Äô way to give the same definition.</p>\n<p>I keep banging this multigraph drum because I am constantly worried about certain things in graph theory being developed only for simple graphs, which will mean redoing a lot of stuff down the line.</p>",
        "id": 497273841,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738516462
    },
    {
        "content": "<p>I tried to formalize planar graphs a while ago but then got busy with other things. But after seeing this topic I decided to work on it again, so here is a draft PR with a definition of planar graphs using combinatorial maps: <a href=\"https://github.com/leanprover-community/mathlib4/pull/16074\">#16074</a><br>\nI realize that this code has many issues, please feel free to suggest improvements.</p>",
        "id": 497348889,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1738567780
    },
    {
        "content": "<p>I think characterizing planarity using Euler's formula is not well-suited for infinite graphs, this is unfortunate as some people have shown interest in formalizing results related to infinite planar graphs, and it seems that if we want to do that we will need to come up with different ideas.</p>",
        "id": 497349499,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1738567963
    },
    {
        "content": "<p>I have reason to believe this is true: if every finite connected sub-map is planar, then the map is planar.</p>",
        "id": 497351227,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738568561
    },
    {
        "content": "<p>Perhaps there are counterexamples in the general case, but it should be true at least for locally finite maps (ones with finite degree and finite face sizes)</p>",
        "id": 497351360,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738568611
    },
    {
        "content": "<p>Ah that is true! I'll work on this as soon as I get some free time again.</p>",
        "id": 497351828,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1738568755
    },
    {
        "content": "<p>If that's the case, does that mean the main PR is unblocked? Since the infinite case builds upon the finite case; it does not obsolete it.</p>",
        "id": 497352378,
        "sender_full_name": "Chris Wong",
        "timestamp": 1738568923
    },
    {
        "content": "<p>Though I am interested in how much we can generalize to infinite things, since IIRC the Coq version assumes everything is Fintype, which is good for the four color theorem but might not be the most general form.</p>",
        "id": 497352851,
        "sender_full_name": "Chris Wong",
        "timestamp": 1738569078
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"294142\">@Chris Wong</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.nonempty_hom_of_forall_finite_subgraph_hom#doc\">docs#SimpleGraph.nonempty_hom_of_forall_finite_subgraph_hom</a> is anticipating this. The finite case is all you need, since there's a compactness argument to lift the result to the infinite case.</p>",
        "id": 497358882,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738570785
    },
    {
        "content": "<p>This finiteness/compactness machinery will cause issues with duality, though, because of pictures like this: <a href=\"/user_uploads/3121/opitzhVBiu1-TMUcROqEq0Q_/34157D36-B21C-4129-B09F-82EF80606993.jpg\">34157D36-B21C-4129-B09F-82EF80606993.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/opitzhVBiu1-TMUcROqEq0Q_/34157D36-B21C-4129-B09F-82EF80606993.jpg\" title=\"34157D36-B21C-4129-B09F-82EF80606993.jpg\"><img data-original-content-type=\"image/jpeg\" data-original-dimensions=\"242x237\" src=\"/user_uploads/thumbnail/3121/opitzhVBiu1-TMUcROqEq0Q_/34157D36-B21C-4129-B09F-82EF80606993.jpg/840x560.webp\"></a></div><p>Local finiteness is not preserved by duality. </p>\n<p>I think that ‚Äògraph-like spaces‚Äô might be the appropriate objects to give you both infinite graphs and planar duality.</p>",
        "id": 497409933,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738582986
    },
    {
        "content": "<p>Picture taken from here: <a href=\"https://www.sciencedirect.com/science/article/pii/S0012365X09003823\">https://www.sciencedirect.com/science/article/pii/S0012365X09003823</a></p>",
        "id": 497410263,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738583080
    },
    {
        "content": "<p>This paper also clarifies some of these issues, possibly without needing to define a new object. </p>\n<p><a href=\"https://www.uni-ulm.de/fileadmin/website_uni_ulm/mawi.inst.081/Henning/Duality.pdf\">https://www.uni-ulm.de/fileadmin/website_uni_ulm/mawi.inst.081/Henning/Duality.pdf</a></p>\n<p>I think that a ‚Äòdual map exists‚Äô definition of planarity will extend fine to infinite graphs. The subtle question is to what extent that definition actually relates to the plane as a manifold.</p>",
        "id": 497412178,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738583602
    },
    {
        "content": "<p>I'm trying to understand what that picture has to do with planar graphs. It seems like this is not a graph embedding, since the underlying graph has its top two vertices being adjacent only to the top edge, right? The induced topology is very different. Why does this cause issues for planar embeddings of infinite graphs?</p>\n<hr>\n<p>That Bruhn-Diestel paper reminds me of some of the details of Stalling's theorem on ends of groups (<a href=\"https://math.uchicago.edu/~dannyc/courses/3manifolds_2014/3_manifolds_notes.pdf\">notes</a>, starts on page 7), where for infinite locally-finite graphs, the finitely-supported 1-cocycles are related to ends.</p>",
        "id": 497421821,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738586089
    },
    {
        "content": "<p>That picture isn‚Äôt a planar graph, but I think its ‚Äòtopological dual‚Äô is a planar graph.</p>",
        "id": 497433889,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738588984
    },
    {
        "content": "<p>(I‚Äôm certainly not claiming to be an expert on this stuff, but I‚Äôve been exposed to enough of it that I know that reconciling infinite graphs, plane embeddings and duality in a satisfying way is not easy)</p>",
        "id": 497434392,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738589110
    },
    {
        "content": "<p>Ah, ok, got it. I guess at least it's the dual of a planar graph that's not locally finite.</p>",
        "id": 497436599,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738589652
    },
    {
        "content": "<p>I expected to use the fact that the edges permutation of a combinatorial map have no fixed points in order to prove the irreflexive property of the simple graph it induces, but I couldn't find a nice way to do this. Here is the current code (from the PR above):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">fromCombinatorialMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CombinatorialMap</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">M.vertices</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">v‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">v‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">d‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">d‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M.dartVertex</span><span class=\"w\"> </span><span class=\"n\">d‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">M.dartVertex</span><span class=\"w\"> </span><span class=\"n\">d‚ÇÇ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v‚ÇÇ</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">M.Œ±</span><span class=\"w\"> </span><span class=\"n\">d‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">d‚ÇÇ</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">v‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"n\">v‚ÇÇ</span>\n<span class=\"w\">  </span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">v‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">v‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">‚ü®</span><span class=\"n\">d‚ÇÅ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d‚ÇÇ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÇ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÉ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÑ</span><span class=\"o\">‚ü©</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">d‚ÇÇ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d‚ÇÅ</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">‚ü®</span><span class=\"n\">h‚ÇÇ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M.involutive.eq_iff.mp</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÉ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÑ.symm</span><span class=\"o\">‚ü©</span>\n<span class=\"w\">  </span><span class=\"n\">loopless</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">tauto</span>\n</code></pre></div>\n<p>Does anybody have  an idea on how to induce a <code>SimpleGraph</code> from a <code>CombinatorialMap</code> in a way that uses <code>M.fixedPoints_isEmpty</code> instead of relying on <code>v‚ÇÅ ‚â† v‚ÇÇ</code>?</p>",
        "id": 497502791,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1738606345
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"695266\">Mitchell Lee</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/planar.20graphs/near/492359700\">said</a>:</p>\n<blockquote>\n<p>What about this: a planar graph is the 1-skeleton of a CW complex which is homeomorphic to the 2-sphere.</p>\n</blockquote>\n<p>I've been playing around with planar graphs in Mathlib for my own purposes (can't easily make a properly diagrammatic proof widget for foo-monoidal categories without being able to talk about the topology of a graph), and this approximately was the approach I was working with. Or rather, I used <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quiv#doc\">docs#Quiv</a> for my graph representation, showed that it had all pullbacks, and then defined a functor <code>Quiv ‚•§ TopCat</code> by following the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CWComplex#doc\">docs#CWComplex</a> model, pulling the vertex-level map back over <code>ùïä 0 ‚Üí ùîª 1</code>.  Then a planar graph is just a graph whose corresponding object in <code>TopCat</code> has a mono into <code>EuclideanSpace ‚Ñù 2</code>. </p>\n<p>(Working with <code>Quiv</code> also has the nice feature that multigraphs are automatically allowed... though rather than the current suggestion of using <code>Quiv.{0}</code> for simple graphs, the usual issues with handling <code>Sort 0</code> and  <code>Sort (u + 1)</code> homogenously led me to prefer using <code>Quiv.{1}</code> and just defining homs in <code>Squash</code>.) </p>\n<p>I <em>think</em> you can get dual graphs out of this fairly easily as well -- just build an appropriate pair of natural transformations between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Hom</mi><mo>‚Å°</mo><mo stretchy=\"false\">(</mo><msup><mi mathvariant=\"double-struck\">D</mi><mn>0</mn></msup><mo separator=\"true\">,</mo><mo>‚àí</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Hom}(\\mathbb{D}^0, -)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathbb\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">‚àí</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Hom</mi><mo>‚Å°</mo><mo stretchy=\"false\">(</mo><msup><mi mathvariant=\"double-struck\">D</mi><mn>2</mn></msup><mo separator=\"true\">,</mo><mo>‚àí</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Hom}(\\mathbb{D}^2, -)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathbb\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">‚àí</span><span class=\"mclose\">)</span></span></span></span> -- but I'm not entirely sure, and at any rate my graph theory chops are probably not really up to providing results in the proper generality ^.^;</p>",
        "id": 497593574,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1738651693
    },
    {
        "content": "<p>How would you state Euler‚Äôs genus formula for planar multigraphs in that language? (Not suggesting it can‚Äôt be done, but seeing a statement would give me a better understanding of the approach you outline)</p>",
        "id": 497872431,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738755627
    },
    {
        "content": "<p>Well, you can brute-force it just by asking for the cardinality of <code>{f : ùîª n ‚ü∂ G // Mono f}</code> for a graph topology <code>G</code> and <code>n = 0, 1, 2</code></p>\n<p>But Euler characteristic can be defined in a pure categorical way, and upon doing so can be generalized significantly to enriched categeories and certain suitably well behaved infinite objects, if I'm understanding what ncatLab is calling \"dualizable\" right: <a href=\"https://ncatlab.org/nlab/show/Euler+characteristic\">https://ncatlab.org/nlab/show/Euler+characteristic</a></p>",
        "id": 497893646,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1738762430
    },
    {
        "content": "<p>So I'd probably do it by defining the Euler characteristic of a dualizable object in a symmetric monoidal category, then expressing the genus formula in reference to the graph as an object in <code>Quiv</code> directly</p>",
        "id": 497894234,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1738762618
    },
    {
        "content": "<p>I suppose what I'm getting at is that graph theorists tend to want to use things like Euler's formula in calculations, and I would worry that, while possible with this approach, this is very far from ergonomic. </p>\n<p>As a concrete example, one of the first lemmas one proves about colouring planar graphs is that every planar graph has a vertex of degree at most 5. This follows from Euler's formula and the handshake lemma. How much DTT and abstraction needs to be waded through to produce this proof?</p>",
        "id": 497935247,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738773215
    },
    {
        "content": "<p>I've dusted off <a href=\"https://github.com/leanprover-community/mathlib4/pull/16074\">#16074</a>, and would like to add an initial API for planar graphs to it (including the lemma Peter mentions above). I have two questions and would really appreciate if someone can take a look at the file containing the planar graph definition in the PR and help:</p>\n<ul>\n<li>Currently combinatorial maps don't include isolated points. Is there a way to circumvent this and prove something such as:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">bot_isPlanar</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsPlanar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚ä•</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<ul>\n<li>Notice how I had to add (D := D) above. The planarity of a graph shouldn't depend on some type unrelated to its vertices, so it doesn't make sense to add <code>D</code> as an explicit variable, is there a way to not require us to choose a type <code>D</code> first? For example, would it make since to add an existential quantifier in the definition of <code>Graph.IsPlanar</code> that takes a <code>D : Type</code> and a condition <code>Fintype D</code>?</li>\n</ul>",
        "id": 514634826,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1745751697
    },
    {
        "content": "<p>I think both point are symptom of combinatorial maps and <code>SimpleGraph</code> not fitting together well - maps are screaming for multigraphs with an abstract edge type!</p>\n<p>Instead of using a graph isomorphism, could you ask for an edge bijection and an injection from the vertices of the map to those of the graph with certain properties, where isolated vertices are elements outside the image?</p>",
        "id": 514640216,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1745755957
    },
    {
        "content": "<p>Why do you need the <code>Fintype</code>?</p>\n<p>Presumably you can put the <code>D</code> behind an existential quantifier with the same universe as <code>V</code>. That way planarity is an intrinsic property.</p>",
        "id": 514658674,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1745769480
    },
    {
        "content": "<p>The reason I'm adding <code>Fintype</code> is so I can write the <code>eulerCharacteristic</code> in terms  of <code>Fintype.card</code>s of faces, edges, and vertices.</p>\n<p>But maybe that is not as valuable as I thought it is and I can do something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The Euler characteristic of a `CombinatorialMap`. -/</span>\n<span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">eulerCharacteristic</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñ§</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Nat.card</span><span class=\"w\"> </span><span class=\"n\">M.Vertex</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">Nat.card</span><span class=\"w\"> </span><span class=\"n\">M.Edge</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">Nat.card</span><span class=\"w\"> </span><span class=\"n\">M.Face</span>\n</code></pre></div>",
        "id": 514711993,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1745809953
    },
    {
        "content": "<p>Assuming I put <code>D</code> behind an existential quantifier, do I need to assume any additional conditions, for example, non-emptiness?</p>",
        "id": 514712033,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1745809994
    }
]