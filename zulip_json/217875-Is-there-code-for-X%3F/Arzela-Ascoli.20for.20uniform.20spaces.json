[
    {
        "content": "<p>Does mathlib have this statement of Arzela-Ascoli for uniform spaces?<br>\n<a href=\"https://en.wikipedia.org/wiki/Arzel%C3%A0%E2%80%93Ascoli_theorem#Functions_on_non-compact_spaces\">https://en.wikipedia.org/wiki/Arzel%C3%A0%E2%80%93Ascoli_theorem#Functions_on_non-compact_spaces</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">arzeli_ascoli</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UniformSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">Equicontinuous</span> <span class=\"o\">((</span><span class=\"bp\">‚Üë</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsCompact</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(perhaps with extra hypotheses)</p>",
        "id": 386170745,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1692496116
    },
    {
        "content": "<p>Here is some code that <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> wrote, initially for lean3 but that I adapted for lean4. AFAIK this is not yet in Mathlib?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">Copyright (c) 2022 Anatole Dedecker. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: Anatole Dedecker</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.UniformSpace.Equicontinuity</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span> <span class=\"n\">Filter</span> <span class=\"n\">Uniformity</span> <span class=\"n\">Function</span> <span class=\"n\">UniformConvergence</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">supr_sUnion</span> <span class=\"o\">[</span><span class=\"n\">CompleteLattice</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">‚®Ü</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">‚®Ü</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sUnion_eq_iUnion</span><span class=\"o\">,</span> <span class=\"n\">iSup_iUnion</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">iSup_subtype''</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">infi_sUnion</span> <span class=\"o\">[</span><span class=\"n\">CompleteLattice</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">‚®Ö</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">‚®Ö</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sUnion_eq_iUnion</span><span class=\"o\">,</span> <span class=\"n\">iInf_iUnion</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">iInf_subtype''</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">forall_sUnion</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">‚Üî</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">iInf_Prop_eq</span><span class=\"o\">,</span> <span class=\"n\">infi_sUnion</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cauchy_of_ne_bot</span> <span class=\"o\">[</span><span class=\"n\">UniformSpace</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">NeBot</span> <span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Cauchy</span> <span class=\"n\">l</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">l</span> <span class=\"bp\">√óÀ¢</span> <span class=\"n\">l</span> <span class=\"bp\">‚â§</span> <span class=\"bp\">ùì§</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Cauchy</span><span class=\"o\">,</span> <span class=\"n\">hl</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cauchy_pi</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">UniformSpace</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"o\">(</span><span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Œ±</span> <span class=\"n\">i</span><span class=\"o\">)}</span> <span class=\"o\">[</span><span class=\"n\">NeBot</span> <span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">Cauchy</span> <span class=\"n\">l</span> <span class=\"bp\">‚Üî</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Cauchy</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">Function.eval</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">cauchy_of_ne_bot</span><span class=\"o\">,</span> <span class=\"n\">prod_map_map_eq</span><span class=\"o\">,</span> <span class=\"n\">map_le_iff_le_comap</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniformity</span><span class=\"o\">,</span> <span class=\"n\">le_iInf_iff</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cauchy_infi</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">UniformSpace</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NeBot</span> <span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">Cauchy</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">‚®Ö</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"bp\">‚Üî</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">Cauchy</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">NeBot</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">assumption</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Cauchy</span><span class=\"o\">,</span> <span class=\"n\">iInf_uniformity</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cauchy_map_iff_comap</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">UniformSpace</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">Cauchy</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">‚Üî</span> <span class=\"bp\">@</span><span class=\"n\">Cauchy</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">UniformSpace.comap</span> <span class=\"n\">f</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Cauchy</span><span class=\"o\">,</span> <span class=\"n\">map_neBot_iff</span><span class=\"o\">,</span> <span class=\"n\">prod_map_map_eq</span><span class=\"o\">,</span> <span class=\"n\">map_le_iff_le_comap</span><span class=\"o\">,</span> <span class=\"n\">uniformity_comap</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UniformSpace</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">theorem1</span> <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">Equicontinuous</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">UniformFun.uniformSpace</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniformSpace</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">UniformSpace.comap_mono</span> <span class=\"o\">(</span><span class=\"n\">le_iff_uniformContinuous_id.mpr</span> <span class=\"n\">UniformFun.uniformContinuous_toFun</span><span class=\"o\">))</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">change</span> <span class=\"n\">comap</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">‚â§</span> <span class=\"n\">comap</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniformity</span><span class=\"o\">,</span> <span class=\"n\">Filter.comap_iInf</span><span class=\"o\">,</span> <span class=\"n\">Filter.comap_comap</span><span class=\"o\">,</span> <span class=\"n\">Function.comp</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"o\">((</span><span class=\"n\">UniformFun.hasBasis_uniformity</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">Prod.map</span> <span class=\"n\">F</span> <span class=\"n\">F</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">ge_iff.mpr</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">intro</span> <span class=\"n\">U</span> <span class=\"n\">hU</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">comp_comp_symm_mem_uniformity_sets</span> <span class=\"n\">hU</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">hV</span><span class=\"o\">,</span> <span class=\"n\">Vsymm</span><span class=\"o\">,</span> <span class=\"n\">hVU</span><span class=\"o\">‚ü©</span>\n  <span class=\"k\">let</span> <span class=\"bp\">Œ©</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">|</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">i</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">‚àà</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">CompactSpace.elim_nhds_subcover</span> <span class=\"bp\">Œ©</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">hF</span> <span class=\"n\">x</span> <span class=\"n\">V</span> <span class=\"n\">hV</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">Scover</span><span class=\"o\">‚ü©</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">‚ãÇ</span> <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">ij</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">√ó</span> <span class=\"n\">Œπ</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">ij.1</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">ij.2</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">‚àà</span> <span class=\"n\">V</span><span class=\"o\">})</span> <span class=\"bp\">‚äÜ</span> <span class=\"o\">(</span><span class=\"n\">Prod.map</span> <span class=\"n\">F</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">‚Åª¬π'</span> <span class=\"n\">UniformFun.gen</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">‚ü®</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">‚ü©</span> <span class=\"n\">hij</span> <span class=\"n\">x</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_iInter‚ÇÇ</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hij</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">mem_iUnion‚ÇÇ.mp</span> <span class=\"o\">(</span><span class=\"n\">Scover.symm.subset</span> <span class=\"bp\">$</span> <span class=\"n\">mem_univ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">hsx</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hVU</span> <span class=\"o\">(</span><span class=\"n\">prod_mk_mem_compRel</span> <span class=\"o\">(</span><span class=\"n\">prod_mk_mem_compRel</span> <span class=\"o\">(</span><span class=\"n\">Vsymm.mk_mem_comm.mp</span> <span class=\"o\">(</span><span class=\"n\">hsx</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hij</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hsx</span> <span class=\"n\">j</span><span class=\"o\">))</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mem_of_superset</span> <span class=\"o\">(</span><span class=\"n\">S.iInter_mem_sets.mpr</span> <span class=\"bp\">$</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mem_iInf_of_mem</span> <span class=\"n\">x</span> <span class=\"bp\">$</span> <span class=\"n\">preimage_mem_comap</span> <span class=\"n\">hV</span><span class=\"o\">)</span> <span class=\"n\">this</span>\n\n<span class=\"c1\">-- TODO: this is too long</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">theorem1'</span> <span class=\"o\">{</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">K</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">K</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">Equicontinuous</span> <span class=\"o\">((</span><span class=\"n\">K.restrict</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span> <span class=\"bp\">‚àò</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">UniformOnFun.uniformSpace</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span> <span class=\"bp\">ùîñ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">F</span> <span class=\"bp\">=</span>\n      <span class=\"o\">(</span><span class=\"bp\">‚®Ö</span> <span class=\"n\">K</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"bp\">‚®Ö</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"o\">‚Äπ</span><span class=\"n\">UniformSpace</span> <span class=\"n\">Œ±</span><span class=\"o\">‚Ä∫</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">x</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">UniformOnFun.uniformSpace</span><span class=\"o\">]</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">UniformSpace.comap_iInf</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">UniformSpace.comap_comap</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"n\">iInf_congr</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">K</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">iInf_congr</span> <span class=\"bp\">$</span> <span class=\"bp\">Œª</span> <span class=\"n\">hK</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">CompactSpace</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"n\">isCompact_iff_compactSpace.mp</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">ùîñ</span> <span class=\"n\">K</span> <span class=\"n\">hK</span><span class=\"o\">)</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">theorem1</span> <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"n\">K</span> <span class=\"n\">hK</span><span class=\"o\">),</span> <span class=\"n\">UniformSpace.comap_comap</span><span class=\"o\">,</span>\n            <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniformSpace</span><span class=\"o\">,</span> <span class=\"n\">UniformSpace.ofCoreEq_toCore</span><span class=\"o\">,</span> <span class=\"n\">UniformSpace.comap_iInf</span><span class=\"o\">,</span> <span class=\"n\">iInf_subtype</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"n\">iInf_congr</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">iInf_congr</span> <span class=\"bp\">$</span> <span class=\"bp\">Œª</span> <span class=\"n\">hx</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congr_arg</span> <span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">UniformSpace.comap_comap</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">theorem1''</span> <span class=\"o\">{</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hcover</span> <span class=\"o\">:</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"bp\">ùîñ</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">K</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">K</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">Equicontinuous</span> <span class=\"o\">((</span><span class=\"n\">K.restrict</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span> <span class=\"bp\">‚àò</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">UniformOnFun.uniformSpace</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span> <span class=\"bp\">ùîñ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniformSpace</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">theorem1'</span> <span class=\"n\">h</span><span class=\"bp\">ùîñ</span> <span class=\"n\">hF</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniformSpace</span><span class=\"o\">,</span> <span class=\"n\">UniformSpace.ofCoreEq_toCore</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span><span class=\"n\">infi_sUnion</span><span class=\"o\">,</span> <span class=\"n\">hcover</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ascoli‚ÇÄ</span> <span class=\"o\">{</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí·µ§</span><span class=\"o\">[</span><span class=\"bp\">ùîñ</span><span class=\"o\">]</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Œπ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NeBot</span> <span class=\"n\">l</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">Equicontinuous</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Set.restrict</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">Cauchy</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"bp\">‚àò</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">Cauchy</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">F</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">e1</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">Cauchy</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">‚®Ö</span> <span class=\"n\">K</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"bp\">‚®Ö</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"o\">‚Äπ</span><span class=\"n\">UniformSpace</span> <span class=\"n\">_</span><span class=\"o\">‚Ä∫</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">F</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">cauchy_infi</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">cauchy_map_iff_comap</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">forall_sUnion</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h3</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">e1</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">e2</span><span class=\"o\">,</span> <span class=\"n\">e3</span><span class=\"o\">‚ü©</span>\n  <span class=\"n\">refine</span> <span class=\"o\">‚ü®</span><span class=\"n\">e2</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">‚ü©</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">prod_map_map_eq</span><span class=\"o\">,</span> <span class=\"n\">map_le_iff_le_comap</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">e3</span> <span class=\"bp\">‚ä¢</span>\n  <span class=\"n\">exact</span> <span class=\"n\">e3.trans</span> <span class=\"o\">(</span><span class=\"n\">theorem1'</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ge</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ascoli</span> <span class=\"o\">{</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí·µ§</span><span class=\"o\">[</span><span class=\"bp\">ùîñ</span><span class=\"o\">]</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">Equicontinuous</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Set.restrict</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">TotallyBounded</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">F</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n    <span class=\"n\">TotallyBounded</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">totallyBounded_iff_ultrafilter</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h3</span> <span class=\"bp\">‚ä¢</span>\n  <span class=\"n\">intro</span> <span class=\"n\">f</span> <span class=\"n\">hf</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">''</span> <span class=\"n\">univ</span> <span class=\"bp\">‚àà</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">image_univ</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">Ultrafilter.mem_coe</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">le_principal_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">Ultrafilter.ofComapInfPrincipal_eq_of_map</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n  <span class=\"n\">set</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">Ultrafilter.ofComapInfPrincipal</span> <span class=\"n\">this</span>\n  <span class=\"n\">apply</span> <span class=\"n\">ascoli‚ÇÄ</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h3</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"o\">(</span><span class=\"n\">g.map</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"bp\">‚àò</span> <span class=\"n\">F</span><span class=\"o\">))</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">le_principal_iff.mpr</span> <span class=\"n\">range_mem_map</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 386204482,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1692524113
    },
    {
        "content": "<p>Indeed this is not in mathlib yet. The reason is that, although total boundedness is fairly self contained, proving the completeness part to get compactness was easier with some tweaks to the API that I didn‚Äôt want to do while the port was going on. I tried an ad-hoc version but ended up never PR-ing it.</p>",
        "id": 386211439,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692529735
    },
    {
        "content": "<p>But I definitely want to go back to this now that the port is over. Does any of you two need the result in mathlib soon‚Ñ¢Ô∏è ?</p>",
        "id": 386211688,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692529831
    },
    {
        "content": "<p>Thanks for porting to Lean4 btw!</p>",
        "id": 386211781,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692529910
    },
    {
        "content": "<p>I would be more interested in a port of <a href=\"https://github.com/leanprover-community/mathlib/pull/18017\">!3#18017</a></p>",
        "id": 386212618,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1692530389
    },
    {
        "content": "<p>Okay, will work on that!</p>",
        "id": 386212886,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692530521
    },
    {
        "content": "<p>But it is not urgent at all</p>",
        "id": 386213171,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1692530755
    },
    {
        "content": "<p>I hacked together a proof of what I needed at <a href=\"https://github.com/leanprover-community/mathlib4/tree/tb_pontryagin_dual\">branch#tb_pontryagin_dual</a>. I'll PR it eventually, since I need it for local compactness of the Pontryagin dual. But I don't really understand this subject well. <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> Are there are any major strategy changes that you would suggest in the proof I wrote?</p>",
        "id": 386239908,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1692548801
    },
    {
        "content": "<p>Well my advice would have been to use my code above, now I feel very bad for not PR-ing it (although in my defense there is a WIP mathlib3 PR on that). I still think that it would be nicer to wait a bit for my version, how quick do you need it?</p>",
        "id": 386241818,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692550451
    },
    {
        "content": "<p>Now that I'm diving back into this I have the feeling that I missed a big shortcut by relying too much on Bourbaki: the <code>theorem1'</code> in my code above should allow to get directly the compactness result without going through total boundedness and completeness, simply by reducing it to Tychonoff's theorem like Thomas does in his proof. Of course we'll want the completeness results anyways, so maybe the shortcut doesn't actually bring anything, but it still means that I could have provided a stronger statement to Vinvent to begin with...</p>",
        "id": 386247440,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692555514
    },
    {
        "content": "<p>Is compactness done (e.g., as stated in my branch)? Not sure whether it's an easy consequence of totally bounded, or requires some additional work.</p>",
        "id": 386261693,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1692567493
    },
    {
        "content": "<p>The way Bourbaki does it is by combining total boundedness and completeness, but as I said there is a shortcut which allows to get compactness directly. They probably don't use it because, well, they have to prove the completeness anyway (and we'll have to do it), but this shortcut means that I should have a ready-for-review PR with almost exactly your statement in a few days (or at least a general statement that easily applies in your case)</p>",
        "id": 386261814,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692567630
    },
    {
        "content": "<p>If we had to go through completeness it would take more time because that involves a slight refactor of the <code>UniformOnFun</code> file</p>",
        "id": 386261840,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692567672
    },
    {
        "content": "<p>The idea is to use my <code>theorem1'</code> instead of your <code>suffices</code></p>",
        "id": 386261906,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692567733
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/6693\">#6693</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/6694\">#6694</a> are the two first prerequisite PRs, maybe there will be a third but probably not more</p>",
        "id": 386262473,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692568325
    },
    {
        "content": "<p>Oh great, thanks!</p>",
        "id": 386262758,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1692568607
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 386263395,
        "sender_full_name": "Dean Young",
        "timestamp": 1692569334
    },
    {
        "content": "<p>It took more time than expected (of course...), but I think I've now got <a href=\"https://github.com/leanprover-community/mathlib4/pull/6844\">#6844</a> to a pretty good situation. There is still a bit of glue to get to Thomas' precise statement, but it's just a matter of reformulating the content of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/UniformSpace/CompactConvergence.html\">Topology.UniformSpace.CompactConvergence</a> in terms of the newer <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformOnFun#doc\">docs#UniformOnFun</a> (we should actually rewrite this file, but maybe that's less urgent). <span class=\"user-mention\" data-user-id=\"253861\">@Thomas Browning</span> <span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span> could you check if the results seem usable enough?<br>\nI don't know how much time I will have to take care of this in the near future, so if you want to add some documentation, a module docstring, or simplify some proofs, please have a go!</p>",
        "id": 389292862,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1693952156
    },
    {
        "content": "<p>Thanks for your help! I'll take a closer look over this next week when I have time.</p>",
        "id": 389303345,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1693958156
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> I was wondering how you were planning on getting from your PR to my statement? The issue that I'm having is deducing the inducing assumption present in your formulations from an equicontinuity assumption. I have a painful proof here: <a href=\"https://github.com/leanprover-community/mathlib4/compare/AD_ascoli_part1...tb_ascoli\">https://github.com/leanprover-community/mathlib4/compare/AD_ascoli_part1...tb_ascoli</a>, but I suspect there might be a way to use your work to streamline this a bit?</p>",
        "id": 402800526,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1700265978
    }
]