[
    {
        "content": "<p>Is there a reason we don't already have an instance for synthesizing <code>[HasBinary(Co)Products C]</code> from a <code>[Has(Co)Products C]</code>, or is this something I should PR?</p>",
        "id": 522671209,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1749158477
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">Preserves</span><span class=\"bp\">.</span><span class=\"n\">Shapes</span><span class=\"bp\">.</span><span class=\"n\">BinaryProducts</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">Preserves</span><span class=\"bp\">.</span><span class=\"n\">Shapes</span><span class=\"bp\">.</span><span class=\"n\">Products</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasProducts</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">HasBinaryProducts</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">infer_instance</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasProducts</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">HasBinaryProducts</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">infer_instance</span><span class=\"w\"> </span><span class=\"c1\">--fails</span>\n</code></pre></div>\n<p>I guess the issue is that <code>HasProducts</code> is an abbrev for <code>∀ J : Type w, HasLimitsOfShape (Discrete J) C</code>, and <br>\n<code>HasBinaryProducts</code> for <code>HasLimitsOfShape (Discrete WalkingPair) C</code>, but the walking pair is in <code>Type</code>...</p>",
        "id": 522766404,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749212682
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">has_smallest_products_of_hasProducts</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasProducts</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">HasBinaryProducts</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>works, and if you import <code>Limits.Shapes.Countable</code>, then it also works (without the local instance) because <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.hasCountableProducts_of_hasProducts#doc\">docs#CategoryTheory.Limits.hasCountableProducts_of_hasProducts</a> (which uses this local instance behind the scene) is in scope then.<br>\nMaybe <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.has_smallest_products_of_hasProducts#doc\">docs#CategoryTheory.Limits.has_smallest_products_of_hasProducts</a> was not made a global instance for perf reasons?</p>",
        "id": 522779198,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749216896
    },
    {
        "content": "<p>The discussion in <a href=\"https://github.com/leanprover-community/mathlib/pull/15067\">!3#15067</a> seems to suggest at the time there was a potential instance loop when making it an instance.</p>",
        "id": 522780115,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749217148
    },
    {
        "content": "<p>Also, since things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.hasCountableProducts_of_hasProducts#doc\">docs#CategoryTheory.Limits.hasCountableProducts_of_hasProducts</a> have to exist and be explicitly recorded and are instances, I guess this means that it would make sense to add an instance <code>CategoryTheory.Limits.hasBinaryProducts_of_hasProducts</code>, but it’s probably best if a maintainer confirms.</p>",
        "id": 522798464,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749222758
    }
]