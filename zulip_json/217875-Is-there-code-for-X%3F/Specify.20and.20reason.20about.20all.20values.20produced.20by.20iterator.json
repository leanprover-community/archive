[
    {
        "content": "<p>Is there any approach to specifying and reasoning about the collection of all values produced by an iterator? For example, is there a way to specify that \"the iterator never produces the same value twice\" or \"the iterator produces all possible values of this type\"? I searched on Loogle and didn't find any related definitions. It seems that one indirect way to do so is to specify over the iterator<code>.toList</code>, but I'm not sure if that's a good one.</p>",
        "id": 571331860,
        "sender_full_name": "Qiyuan Zhao",
        "timestamp": 1769995932
    },
    {
        "content": "<p>When you say \"iterator\" are you referring to iterated function application (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.iterate#doc\">docs#Nat.iterate</a>)?</p>",
        "id": 571344305,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1770005943
    },
    {
        "content": "<p>Oh sorry, I forgot to mention that the \"iterator\" here refers to <a href=\"https://lean-lang.org/doc/reference/latest/Iterators/#iterators\">the iterators in <code>Std.Data.Iterators</code></a>.</p>",
        "id": 571347624,
        "sender_full_name": "Qiyuan Zhao",
        "timestamp": 1770008291
    },
    {
        "content": "<p>As long as you're only working on finite iterators (and if your iterators don't have side effects; <code>Iter</code> not <code>IterM</code>), then I'd say specifying these kinds of behaviors using <code>toList</code> is a robust solution. Does that restriction apply to your use case?</p>\n<p>We still need to find out how such properties can conveniently be verified for non-finite or monadic iterators. The iterators have complicated dependent types and have an ill-behaved equality and we can't change that for efficiency reasons. One approach I'd like to try out in the future is to introduce noncomputable, bundled iterators. On these, it becomes easier to apply equational reasoning, and we might provide a library for LTL-style predicates on these. But this is very much an open question.</p>",
        "id": 571875852,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1770202044
    },
    {
        "content": "<p>For the \"the iterator produces all possible values of this type\", maybe something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Iter</span><span class=\"bp\">.</span><span class=\"n\">IsComplete</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Iterator</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Iter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"bp\">.</span><span class=\"n\">IsPlausibleIndirectOutput</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>",
        "id": 572352371,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1770377159
    },
    {
        "content": "<p>That generally works, but such predicates relying on <code>IsPlausibleIndirectOutput</code> don't compose well. We can't express <code>(it.filter f).IsComplete</code> in terms of <code>it.IsComplete</code> or even <code>IsPlausibleIndirectOutput</code> (I think, at least not easily). This is where the LTL idea comes from. (We'd also want a way to apply the same predicate on iterators of different types, which is difficult to achieve without bundled iterators.)</p>\n<p>If you're only interested in finite iterators, I'd go with the <code>toList</code>-based formulation because you will get API lemmas that compose better.</p>",
        "id": 572354949,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1770378016
    }
]