[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.GroupTheory.MonoidLocalization.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.SetTheory.Cardinal.Basic</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Localization</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The cardinality of the `Localization` of `M` at `S` is at most `#M * #S`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"s2\">\"The cardinality of the `AddLocalization` of `M` at `S` is at most `#M * #S`.\"</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">card_le'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cardinal.mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Localization</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Cardinal.mk</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">Cardinal.mk</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Localization</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Localization.mk</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function.Surjective</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Quotient.surjective_Quotient_mk''</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"n\">Cardinal.mk_le_of_surjective</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"sd\">/-- The cardinality of the `Localization` of `M` at `S` is at most `#M * #M`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"s2\">\"The cardinality of the `AddLocalization` of `M` at `S` is at most `#M * #M`.\"</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">card_le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cardinal.mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Localization</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Cardinal.mk</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">Cardinal.mk</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Localization.card_le'</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">gcongr</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Cardinal.mk_subtype_le</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span><span class=\"w\"> </span><span class=\"n\">Localization</span>\n</code></pre></div>\n<p>Do we have these in mathlib?</p>\n<p>In fact, what result I need to use is the cardinality of total fraction ring. But it turns out that mathlib has stronger result for this: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsLocalization.card#doc\">docs#IsLocalization.card</a>. Do we want <code>FractionRing.card</code> or <code>IsFractionRing.card</code> which is a direct application of this?</p>",
        "id": 477424118,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729166004
    },
    {
        "content": "<p>If it's a direct application, I don't think it needs to be separately stated</p>",
        "id": 477433592,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1729168880
    },
    {
        "content": "<p>Basically it is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- TODO: move to suitable place</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">_root_.FractionRing.card</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Cardinal.mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FractionRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Cardinal.mk</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">IsLocalization.card</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FractionRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nonZeroDivisors</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_refl</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>\n<p>and it's convenient to write <code>rw [FractionRing.card]</code>. Otherwise it can be <code>rw [← IsLocalization.card (FractionRing _) (nonZeroDivisors _) (le_refl _)]</code> which is a little bit longer I think.</p>",
        "id": 477435170,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729169287
    },
    {
        "content": "<p>Yeah, that's complicated enough to make it a separate lemma.<br>\nAdditional benefit: you can tag it with <code>@[simp]</code></p>",
        "id": 477435498,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1729169401
    },
    {
        "content": "<p><code>(le_refl _)</code> can simply be <code>le_rfl</code></p>",
        "id": 477436184,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729169605
    },
    {
        "content": "<p>Do you think there should be a stronger version of <code>Cardinal.mk (Localization S) ≤ Cardinal.mk M * Cardinal.mk S</code>? My current version is only a very rough estimation.</p>",
        "id": 477436764,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729169764
    },
    {
        "content": "<p>Note that for infinite <code>M</code>, <code>#M * #M = #M</code></p>",
        "id": 477437026,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729169852
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Localization.2Ecard_le/near/477435498\">said</a>:</p>\n<blockquote>\n<p>Yeah, that's complicated enough to make it a separate lemma.<br>\nAdditional benefit: you can tag it with <code>@[simp]</code></p>\n</blockquote>\n<p>Next question is: What file should it stay? I believe that <code>Mathlib.RingTheory.Localization.Cardinality</code> does not import <code>FractionRing</code>, vice versa.</p>",
        "id": 477437360,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729169949
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Localization.2Ecard_le/near/477437026\">said</a>:</p>\n<blockquote>\n<p>Note that for infinite <code>M</code>, <code>#M * #M = #M</code></p>\n</blockquote>\n<p>I know this. The <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsLocalization.card_le#doc\">docs#IsLocalization.card_le</a> actually suggests that <code>Cardinal.mk (Localization S) ≤ Cardinal.mk M</code>, at least for rings. But what about the original setup of <code>Localization</code>?</p>",
        "id": 477437746,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729170053
    },
    {
        "content": "<p>I think it should go in a new file.</p>",
        "id": 477438124,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1729170152
    },
    {
        "content": "<p>For a finite commutative monoid, it is also true that the canonical map to any localization is surjective. The reason is that for any element <code>m</code> in the submonoid, there exists natural numbers <code>i &gt; j</code> such that <code>m ^ i = m ^ j</code>, by finiteness. Since <code>m</code> becomes invertible in the localization, we can check that <code>m ^ (i - j - 1)</code> maps to the inverse of <code>m</code> in the localization, so the localization is not adjoining any new element.</p>\n<p>My proof of the same fact for finite comm. rings <a href=\"https://github.com/leanprover-community/mathlib3/pull/12285/commits/70c717a571521733146442148d4d055c498d2d09#diff-73747c5c440ceb6756bae4125fa0a70e178d9fbf3f9942a18812cd367bb23b59R42-R52\">in mathlib3</a> follows roughly the same idea, but it uses finiteness of the localization instead. The proof was later replaced by the more general fact for Artinian comm. rings, so it's no longer in mathlib4.</p>",
        "id": 477649500,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1729256131
    },
    {
        "content": "<p>What about non-commutative monoid? In this case the multiplicative subset should satisfy certain condition (Ore condition) and we should use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OreLocalization#doc\">docs#OreLocalization</a> instead. Is it still true in this case?</p>",
        "id": 477672074,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729262776
    },
    {
        "content": "<p>Yeah I think the argument still works. The inverses of elements in the submonoid still generate the localized monoid over the original monoid.</p>",
        "id": 477696194,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1729270853
    },
    {
        "content": "<p>Here it goes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.GroupTheory.OreLocalization.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.Fintype.Card</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">OreLocalization</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">numeratorHom_surj_of_finite</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submonoid</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OreSet</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function.Surjective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">numeratorHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">OreLocalization.ind</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">_</span>\n<span class=\"w\">  </span><span class=\"n\">obtain</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hne</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">heq</span><span class=\"o\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finite.exists_ne_map_eq_of_infinite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">wlog</span><span class=\"w\"> </span><span class=\"n\">hlt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">hne.symm</span><span class=\"w\"> </span><span class=\"n\">heq.symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hne.lt_of_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">not_lt</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">hlt</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">numeratorHom_apply</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">oreDiv_eq_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">heq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">SubmonoidClass.coe_pow</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">pow_add</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat.sub_sub</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">Nat.add_sub_cancel'</span><span class=\"w\"> </span><span class=\"n\">hlt</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SubmonoidClass.coe_pow</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">OneMemClass.coe_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pow_succ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span><span class=\"w\"> </span><span class=\"n\">OreLocalization</span>\n</code></pre></div>\n<p>But I need to use <code>Finite.exists_ne_map_eq_of_infinite</code> from <code>Mathlib.Data.Fintype.Card</code>. Should this be added to <code>Mathlib.GroupTheory.OreLocalization.Basic</code> or a new file?</p>",
        "id": 477775292,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729315668
    },
    {
        "content": "<p>Another problem: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OreLocalization#doc\">docs#OreLocalization</a> can also define localization of modules; is <code>#X[S⁻¹] ≤ #X</code> still true? The above proof also works in this case if <code>#S</code> or <code>#X</code> is finite. But I have no idea when both of them are infinite, since there are no assumptions on the comparison of <code>#S</code> and <code>#X</code>.</p>",
        "id": 477784964,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729324988
    },
    {
        "content": "<p>one has Card (localization) at most Card(X)xCard(S) hence at most Card(X) when X is infinite (Hessenberg).</p>",
        "id": 477823386,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1729357676
    },
    {
        "content": "<p>a more general result holds even without the Ore condition: if X to Y is a morphism of monoids and Y is generated by its image and a subset of cardinality at most Card(X),  then Card(Y) is at most Card(X).<br>\nThis bound can be used to prove that a localization exists even when the Ore condition doesn't hold— the natural direct limit can be bounded over a set.</p>",
        "id": 477823733,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1729357980
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Localization.2Ecard_le/near/477823386\">said</a>:</p>\n<blockquote>\n<p>Card(X)xCard(S) hence at most Card(X)</p>\n</blockquote>\n<p>Note that <code>X</code> is only an <code>R</code>-module, but not the ring <code>R</code> itself. So a priori it's possible that <code>R</code> and its multiplicative subset <code>S</code> are uncountable, but <code>X</code> is countable, and this argument breaks.</p>",
        "id": 477823851,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729358081
    },
    {
        "content": "<p>I think it's still true but I need a different arguments.</p>",
        "id": 477823938,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729358163
    },
    {
        "content": "<p>i was thinking about the case of monoids. if you have a module, you first need to consider the quotient ring that acts faithfully (and won't be larger than X)</p>",
        "id": 477837381,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1729371187
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Localization.2Ecard_le/near/477837381\">said</a>:</p>\n<blockquote>\n<p>ring that acts faithfully (and won't be larger than X)</p>\n</blockquote>\n<p>I can't prove the last step; if <code>R</code> acts faithfully on <code>X</code> I can only conclude that <code>R</code> injects into <code>End(X)</code> which is of cardinality <code>2 ^ #X</code> I think.</p>",
        "id": 477856148,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729390352
    },
    {
        "content": "<p>My plan is to prove <code>#{x/s | s \\in S} ≤ #X</code> for each <code>x \\in X</code>. Suppose <code>s x = s' x</code> then I want to prove <code>x/s = x/s'</code>. I can only prove this if <code>s</code> and <code>s'</code> commutes. Otherwise I have no idea on it; I try to back and forth using Ore's condition, but till now there is no progress.</p>",
        "id": 477856491,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729390514
    },
    {
        "content": "<p>FYI This is the formalized code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.GroupTheory.OreLocalization.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.SetTheory.Cardinal.Arithmetic</span>\n\n<span class=\"kd\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Cardinal</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">OreLocalization</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submonoid</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OreLocalization.OreSet</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">oreDiv_one_surj_of_finite_right</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Function.Surjective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">/ₒ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">OreLocalization</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">OreLocalization.ind</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">_</span>\n<span class=\"w\">  </span><span class=\"n\">obtain</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hne</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">heq</span><span class=\"o\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finite.exists_ne_map_eq_of_infinite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">wlog</span><span class=\"w\"> </span><span class=\"n\">hlt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">hne.symm</span><span class=\"w\"> </span><span class=\"n\">heq.symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hne.lt_of_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">not_lt</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">hlt</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">oreDiv_eq_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mul_smul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">pow_add</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat.add_sub_cancel'</span><span class=\"w\"> </span><span class=\"n\">hlt</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">heq</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SubmonoidClass.coe_pow</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">OneMemClass.coe_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pow_succ</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- TODO How to remove the Commute condition</span>\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">card_le_lift_card_of_commute</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Commute</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">OreLocalization</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">lift</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">finite_or_infinite</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">_</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">lift_mk_le_lift_mk_of_surjective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">oreDiv_one_surj_of_finite_right</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">rwa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">lift_umax</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">lift_id'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Commute</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">/ₒ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">/ₒ</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">oreDiv_eq_iff</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact_mod_cast</span><span class=\"w\"> </span><span class=\"n\">hc</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/ₒ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hsurj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function.Surjective</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Quotient.surjective_Quotient_mk''</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Function.rightInverse_surjInv</span><span class=\"w\"> </span><span class=\"n\">hsurj</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">Function.surjInv</span><span class=\"w\"> </span><span class=\"n\">hsurj</span>\n<span class=\"w\">  </span><span class=\"k\">suffices</span><span class=\"w\"> </span><span class=\"n\">Function.Injective</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">lift_mk_le_lift_mk_of_injective</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">    </span><span class=\"n\">rwa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">lift_umax</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">lift_id'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mk_prod</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lift_id</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lift_mul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_eq_self</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">y'</span><span class=\"w\"> </span><span class=\"n\">heq</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"n\">y'</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Function.comp_apply</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Prod.ext_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">heq</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Function.surjInv</span><span class=\"w\"> </span><span class=\"n\">hsurj</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">  </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Function.surjInv</span><span class=\"w\"> </span><span class=\"n\">hsurj</span><span class=\"w\"> </span><span class=\"n\">y'</span>\n<span class=\"w\">  </span><span class=\"n\">obtain</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"o\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">heq</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"bp\">⊢</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span><span class=\"w\"> </span><span class=\"n\">OreLocalization</span>\n</code></pre></div>",
        "id": 477894499,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729429946
    },
    {
        "content": "<p>PR created as <a href=\"https://github.com/leanprover-community/mathlib4/pull/18004\">#18004</a>.</p>",
        "id": 478043577,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729512644
    },
    {
        "content": "<p>For the noncommutative case, there's still a description of localized module as a filtered colimit of copies of X (DirectLimit in mathlib): see <a href=\"https://ocw.mit.edu/courses/18-706-noncommutative-algebra-spring-2023/mit18_706_s23_lec20.pdf\">https://ocw.mit.edu/courses/18-706-noncommutative-algebra-spring-2023/mit18_706_s23_lec20.pdf</a> However, I don't know how one could bound this particular colimit.</p>",
        "id": 478805600,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1729807214
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Localization.2Ecard_le/near/478805600\">said</a>:</p>\n<blockquote>\n<p>there's still a description of localized module as a filtered colimit of copies of X</p>\n</blockquote>\n<p>It's the <code>#S</code> copies of <code>X</code>. So it seems to be a restatement of <code>S × X / ~</code>... but I don't know if there are new insights.</p>",
        "id": 478847618,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729836508
    },
    {
        "content": "<p>Unfortunately, using mathlib's definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/GroupTheory/OreLocalization/OreSet.html#OreLocalization.OreSet\">OreLocalization.OreSet</a> I can't prove that it forms a filtered system. More precisely, for <code>s, t \\in S</code> I can't find <code>u, v \\in S</code> such that <code>u s = v t</code>; mathlib's definition only gives <code>v \\in R</code>. Did I miss something?</p>",
        "id": 478857828,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729841579
    },
    {
        "content": "<p>in the mathlib definition of an Ore set, i can't recognize that the docstring says the same as the definition.</p>",
        "id": 478862226,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1729843296
    },
    {
        "content": "<p>Mathlib's definition coincides with Wikipedia's (modulo left Ore vs right Ore). I think it's the lecture note which is too sloppy on this.</p>\n<p>Anyways, I think the filtered or not does not significantly change the nature of the question.</p>",
        "id": 478864737,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729844166
    },
    {
        "content": "<p>OK I think I'll give up on this and keep PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/18004\">#18004</a> as its current form. Any comments on it?</p>",
        "id": 478865699,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729844510
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Localization.2Ecard_le/near/478857828\">said</a>:</p>\n<blockquote>\n<p>Unfortunately, using mathlib's definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/GroupTheory/OreLocalization/OreSet.html#OreLocalization.OreSet\">OreLocalization.OreSet</a> I can't prove that it forms a filtered system. More precisely, for <code>s, t \\in S</code> I can't find <code>u, v \\in S</code> such that <code>u s = v t</code>; mathlib's definition only gives <code>v \\in R</code>. Did I miss something?</p>\n</blockquote>\n<p>I think we may need to take the saturation of the Ore set, as explained in <a href=\"https://www.math.rwth-aachen.de/homes/Viktor.Levandovskyy/filez/MasterThesisHoffmann.pdf\">this thesis</a>.<br>\n<a href=\"/user_uploads/3121/jC1P6l-r7BF55-l1D1imKwlY/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/jC1P6l-r7BF55-l1D1imKwlY/image.png\" title=\"image.png\"><img data-original-dimensions=\"1189x816\" src=\"/user_uploads/thumbnail/3121/jC1P6l-r7BF55-l1D1imKwlY/image.png/840x560.webp\"></a></div>",
        "id": 478867512,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1729845107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Localization.2Ecard_le/near/477784964\">said</a>:</p>\n<blockquote>\n<p>Another problem: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OreLocalization#doc\">docs#OreLocalization</a> can also define localization of modules; is <code>#X[S⁻¹] ≤ #X</code> still true? The above proof also works in this case if <code>#S</code> or <code>#X</code> is finite. But I have no idea when both of them are infinite, since there are no assumptions on the comparison of <code>#S</code> and <code>#X</code>.</p>\n</blockquote>\n<p>Two observations: 1) if you get a counterexample for a monoid M acting on a set X, you can probably linearize it to get a counterexample for the ring R[M] acting on R[X], for a commutative ring R. 2) we may assume X is \"cyclic\" (generated by one element over M), so it's a \"quotient\" of M (we have been implicitly restricting to the \"orbit\" of x, but this change of viewpoint might still help).</p>",
        "id": 478869011,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1729845615
    },
    {
        "content": "<p>Mathlib should really refrain using Wikipedia as a reference for mathematical definitions. One difficult aspect of a unified library of mathematics such as mathlib lies in providing a long-range consistency of definitions/notation, while Wikipedia (despite its tremendous usefulness) has no such constraint.</p>",
        "id": 478887644,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1729851687
    },
    {
        "content": "<p>I'm not sure I'd go that far - we should use the definitions that work best and agree as much as is reasonable with the literature - including tertiary sources like wikipedia (which will probably be the first definition many people see)</p>",
        "id": 478888205,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1729851914
    },
    {
        "content": "<p>My claim is that Wikipedia has no relevance as for definitions that work best on the long term. (They could even be incompatible from one page to another.)</p>",
        "id": 478888443,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1729852012
    },
    {
        "content": "<p>I don't really see how the purported poor consistency of Wikipedia definitions undermines it as a reference. References don't have to be followed closely</p>",
        "id": 478889250,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729852292
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Localization.2Ecard_le/near/478867512\">said</a>:</p>\n<blockquote>\n<p>I think we may need to take the saturation of the Ore set, as explained in <a href=\"https://www.math.rwth-aachen.de/homes/Viktor.Levandovskyy/filez/MasterThesisHoffmann.pdf\">this thesis</a>.</p>\n</blockquote>\n<p>Great! Maybe I'll come back to this later.</p>",
        "id": 478893394,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729853836
    },
    {
        "content": "<p>Interesting. We only have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subgroup.Saturated#doc\">docs#Subgroup.Saturated</a> and it is not used in other parts of mathlib. Now we need <code>Submonoid.Saturated</code>(or even <code>Subsemigroup.Saturated</code>), and the saturation (of a multiplicative subset, which I think is used frequently in commutative algebra --- don't we have this in mathlib ??).</p>",
        "id": 478895720,
        "sender_full_name": "Jz Pan",
        "timestamp": 1729854723
    },
    {
        "content": "<p>Note that Subgroup.Saturated is a distinct notion, see <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Closure.20of.20Submonoid.20in.20CommMonoids/near/419878781\">previous discussion</a>. In noncommutative setting there's notions of left/right-saturated.</p>",
        "id": 478917214,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1729862243
    },
    {
        "content": "<p><strong>ping</strong> any new comments on PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/18004\">#18004</a>? Besides <code>cardinal_mk</code> vs <code>cardinalMk</code> debate...</p>",
        "id": 481524190,
        "sender_full_name": "Jz Pan",
        "timestamp": 1731212195
    },
    {
        "content": "<p>borsified</p>",
        "id": 481665321,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1731315303
    }
]