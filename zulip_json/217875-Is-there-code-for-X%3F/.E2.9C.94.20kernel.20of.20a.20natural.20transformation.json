[
    {
        "content": "<p>If I have two functors from <code>A</code> to an abelian (or weaker) category <code>B</code>, and a natural transformation <code>F</code> from one functor to the other, then is there a definition for the functor taking <code>a : A</code> to <code>kernel (F.app a)</code> (and similarly with cokernels etc.) ?</p>",
        "id": 517506338,
        "sender_full_name": "Richard Hill",
        "timestamp": 1747048249
    },
    {
        "content": "<p>that should just be (isomorphic to) the kernel of the natural transformation. is that sufficient for you, or do you really need it pointwise?</p>",
        "id": 517709893,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1747100369
    },
    {
        "content": "<p>See for example <a href=\"https://tqft.net/mathlib4files/CategoryTheory/Limits/FunctorCategory/Shapes/Pullbacks\">file#CategoryTheory/Limits/FunctorCategory/Shapes/Pullbacks</a>. The equivalent constructions for equalizers and kernels aren't in mathlib, but they should be straightforward to add.</p>",
        "id": 517738775,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1747113423
    },
    {
        "content": "<p>Many thanks to both of you. I didn't realize that I can just use the kernel of the natural transformation. It's a little surprising because there's no instance of <code>Zero</code> for <code>NatTrans</code>, i.e.  something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasZeroMorphisms</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">NatTrans</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"n\">naturality</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">comp_zero</span><span class=\"o\">,</span><span class=\"n\">zero_comp</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 518697043,
        "sender_full_name": "Richard Hill",
        "timestamp": 1747410750
    },
    {
        "content": "<p>It's not <code>Zero</code> that you want, rather it's <code>HasZeroMorphisms</code> (for the functor category)</p>",
        "id": 518700511,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1747411782
    },
    {
        "content": "<p>... and of course this instance already exists in mathlib.</p>",
        "id": 518700710,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1747411862
    },
    {
        "content": "<p>Well I certainly want that, but I would also like to say that the composition of a natural transformation with its kernel is the zero natural transformation.</p>",
        "id": 518711476,
        "sender_full_name": "Richard Hill",
        "timestamp": 1747415499
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n\n<span class=\"kd\">variable</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Abelian</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">η</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">kernel.ι</span><span class=\"w\"> </span><span class=\"n\">η</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">η</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 518715673,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1747416914
    },
    {
        "content": "<p>You could probably minimize the typeclass assumptions to something weaker than <code>Abelian</code>.</p>",
        "id": 518715835,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1747416969
    },
    {
        "content": "<p>Here's something a bit more minimal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.Limits.FunctorCategory.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.Limits.Shapes.Kernels</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Combinatorics.Quiver.ReflQuiver</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n\n<span class=\"kd\">variable</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasZeroMorphisms</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasEqualizers</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">foobar</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">η</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">kernel.ι</span><span class=\"w\"> </span><span class=\"n\">η</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">η</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>(Edit: now with the imports minimized as well)</p>",
        "id": 518715998,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1747417037
    },
    {
        "content": "<p>Thanks. I understand now. I was using NatTrans instead of the functor category.</p>",
        "id": 518723325,
        "sender_full_name": "Richard Hill",
        "timestamp": 1747419604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"424936\">Richard Hill</span> has marked this topic as resolved.</p>",
        "id": 518828362,
        "sender_full_name": "Notification Bot",
        "timestamp": 1747495467
    }
]