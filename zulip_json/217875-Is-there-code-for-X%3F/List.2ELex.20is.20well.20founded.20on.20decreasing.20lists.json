[
    {
        "content": "<p>I want to prove the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.Lex</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsWellFounded</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">·&lt;·</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">IsWellFounded</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">l.Chain'</span> <span class=\"o\">(</span><span class=\"bp\">·&gt;·</span><span class=\"o\">)}</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"n\">m</span> <span class=\"bp\">↦</span> <span class=\"n\">List.Lex</span> <span class=\"o\">(</span><span class=\"bp\">·&lt;·</span><span class=\"o\">)</span> <span class=\"n\">l.val</span> <span class=\"n\">m.val</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The mathematical proof I have in mind is the following: </p>\n<p>Take a strictly decreasing sequence <code>l : ℕ →  {l : List α // l.Chain' (·&gt;·)}</code>. Then because <code>[IsWellFounded α (·&lt;·)]</code>, the decreasing sequence <code>(l n).head!</code> is eventually constant, denote its limit by <code>a</code>. </p>\n<p>The sequence <code>(l n).tail</code>, starting from the point from which all elements of the original sequence have the same <code>head!</code> is again strictly decreasing, and again the sequence of <code>head!</code>'s is decreasing and hence eventually constant; denote its limit by <code>b</code>. </p>\n<p>Then <code>a &gt; b</code> because of the <code>List.Chain'</code> condition. We keep going like this and get a strictly decreasing sequence in <code>α</code>, contradiction. </p>\n<p>This proof seems really annoying to do in Lean. Does anyone have a better idea or can point me to something useful in the library?</p>",
        "id": 380304529,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1690803395
    },
    {
        "content": "<p>I don't know that this is in the library, but I'm not the right person to ask. :-) It ought to be.</p>\n<p>I wouldn't mention <code>head!</code> and <code>tail</code>. Define the predicate <code>P</code> on a strictly decreasing sequence <code>L</code> (maybe worth defining a type synonym for such sequences): \"forall n, there exists an M : Nat and S : List α so M ≤ m implies (L m).take n = P\". Now prove three lemmas:</p>\n<ol>\n<li>you can prove <code>P L</code> by proving <code>P (L (· + k))</code> for some <code>k : ℕ</code>. </li>\n<li>if <code>∀ m, (L m).take n = S</code>, then <code>fun m =&gt; (L m).drop n</code> is strictly decreasing </li>\n<li>again if <code>∀ m, (L m).take n = S</code>, you can prove <code>P L</code> by proving <code>P fun m =&gt; (L m).drop n</code>.</li>\n</ol>\n<p>Now <code>P L</code> should be amenable to proof by induction on <code>n</code>.<br>\nOnce you have <code>P L</code> extracting the strictly decreasing sequence in <code>α</code> is hopefully not too bad. Maybe even easier if you tweak <code>P</code> so <code>M</code> depends monotonically on <code>n</code>, then you don't need to take any maxs at this point.</p>\n<p>It's a bit late for writing real code here, but hopefully this will help provoke someone into writing something better!</p>",
        "id": 380316990,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690805626
    },
    {
        "content": "<p>Note that we usually use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Sorted#doc\">docs#List.Sorted</a> instead of <code>List.Chain'</code> for sorted lists.</p>",
        "id": 380525548,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1690850372
    },
    {
        "content": "<p>(I couldn't resist, and wrote down most of this proof. <span class=\"user-mention\" data-user-id=\"519559\">@Dagur Asgeirsson</span>, if you want detailed spoilers let me know. :-)</p>",
        "id": 380544370,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690857974
    },
    {
        "content": "<p>The parts I didn't do are</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Monotone.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Antitone.eventually_constant</span> <span class=\"o\">[</span><span class=\"n\">WellFoundedLT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Antitone</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">N</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">N</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">wellFoundedLT_iff_not_strictAnti</span> <span class=\"o\">:</span> <span class=\"n\">WellFoundedLT</span> <span class=\"n\">α</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">StrictAnti</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>which perhaps are already in Mathlib?</p>",
        "id": 380546999,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690859463
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/6278\">#6278</a></p>",
        "id": 380550568,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690861474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/List.2ELex.20is.20well.20founded.20on.20decreasing.20lists/near/380550568\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/6278\">#6278</a></p>\n</blockquote>\n<p>Both sorries are done now</p>",
        "id": 380607717,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1690879733
    },
    {
        "content": "<p>It turns out this can be done in 30 lines using the <code>Acc</code> (accessibility) primitive, i.e. directly using the definition of <code>WellFounded</code> without passing to the antitone sequence characterization (no need to invoke dependent choice!). In my experience (e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFounded.cutExpand#doc\">docs#WellFounded.cutExpand</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFinsupp.Lex.wellFounded#doc\">docs#DFinsupp.Lex.wellFounded</a>), proofs using <code>Acc</code> are usually much shorter and more elegant, <del>which is probably why <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RelEmbedding.wellFounded_iff_no_descending_seq#doc\">docs#RelEmbedding.wellFounded_iff_no_descending_seq</a> is rarely used and forgotten</del> (oh it's actually <a href=\"https://github.com/leanprover-community/mathlib4/pull/6361/files#diff-1d6e9102ebec04f1d702ffef68445fa574ac5c8b80c9a9e9c577c6b47a5e6625R244\">used</a>). This proof is actually even simpler than I originally thought as it doesn't require the construction of a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Relation.Fibration#doc\">docs#Relation.Fibration</a> and the self-similarity can be captured using a (slightly convoluted) double induction.</p>\n<p>I have stated the theorem using <code>Chain'</code> as in Dagur's original formalization because it's more general, requiring the relation <code>r</code> be satisfied only by adjacent elements in the list rather than all pairs of elements. The two are equivalent via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.chain%27_iff_pairwise#doc\">docs#List.chain'_iff_pairwise</a> for a transitive relation.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.Chain</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">WellFounded.list_chain'</span> <span class=\"o\">(</span><span class=\"n\">hwf</span> <span class=\"o\">:</span> <span class=\"n\">WellFounded</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">WellFounded</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">l.Chain'</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">r</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"n\">m</span> <span class=\"bp\">↦</span> <span class=\"n\">List.Lex</span> <span class=\"n\">r</span> <span class=\"n\">l.val</span> <span class=\"n\">m.val</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">hl</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">cases'</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">l</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">Acc.intro</span><span class=\"bp\">;</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">induction</span> <span class=\"n\">hwf.apply</span> <span class=\"n\">a</span> <span class=\"n\">generalizing</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"n\">hl'</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">List.chain'_cons'.1</span> <span class=\"n\">hl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n    <span class=\"k\">let</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"bp\">//</span> <span class=\"n\">l.Chain'</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">r</span><span class=\"o\">)}</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">hl'</span><span class=\"o\">⟩</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Acc</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"n\">m</span> <span class=\"bp\">↦</span> <span class=\"n\">List.Lex</span> <span class=\"n\">r</span> <span class=\"n\">l.val</span> <span class=\"n\">m.val</span><span class=\"o\">)</span> <span class=\"n\">l'</span>\n    <span class=\"bp\">·</span> <span class=\"n\">cases'</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">b</span> <span class=\"n\">l</span>\n      <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">Acc.intro</span><span class=\"bp\">;</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n      <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">ih</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">List.chain'_cons.1</span> <span class=\"n\">hl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n    <span class=\"n\">revert</span> <span class=\"n\">hl</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[(</span><span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">l'.1</span><span class=\"o\">)]</span>\n    <span class=\"n\">clear_value</span> <span class=\"n\">l'</span>\n    <span class=\"n\">induction</span> <span class=\"n\">this</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"n\">l</span> <span class=\"n\">_</span> <span class=\"n\">ihl</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">intro</span> <span class=\"n\">hl</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Acc.intro</span>\n      <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">⟩,</span> <span class=\"n\">hm</span><span class=\"o\">⟩</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">hr</span> <span class=\"bp\">|</span> <span class=\"n\">hr</span><span class=\"o\">)</span>\n      <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">Acc.intro</span><span class=\"bp\">;</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n      <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">ihl</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">List.chain'_cons'.1</span> <span class=\"n\">hm</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">⟩</span> <span class=\"n\">hr</span>\n      <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">ih</span> <span class=\"n\">b</span> <span class=\"n\">hr</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">hwf</span> <span class=\"o\">:</span> <span class=\"n\">IsWellFounded</span> <span class=\"n\">α</span> <span class=\"n\">r</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsWellFounded</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">l.Chain'</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">r</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"n\">m</span> <span class=\"bp\">↦</span> <span class=\"n\">List.Lex</span> <span class=\"n\">r</span> <span class=\"n\">l.val</span> <span class=\"n\">m.val</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">hwf.wf.list_chain'</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 382708025,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1691428365
    },
    {
        "content": "<p>Wow, thanks!</p>",
        "id": 382734481,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1691434821
    },
    {
        "content": "<p>Can you update the PR? Otherwise I can do it tonight. Do we still want some of the small intermediate results from Scott's proof?</p>",
        "id": 382734715,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1691434876
    },
    {
        "content": "<p>I'd hesitate to update the PR myself as I have no idea which lemmas are just for the proof and which are of independent interest; Scott would know better. I also don't know which other forms of the theorem you'd like, e.g. do you prefer <code>Sorted</code>? You're welcome to update the PR with my new proof, but I could open a separate PR if you want; it would be a short one adding a theorem and an instance to Mathlib.Data.List.Chain, which would be easy to review.</p>",
        "id": 382739391,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1691436191
    },
    {
        "content": "<p>Ok I think it’s best if you just open a new, short PR, and then I can go through the old one and see if there are any results there that we want to keep. I prefer <code>Chain'</code>.</p>",
        "id": 382743660,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1691437521
    },
    {
        "content": "<p>This is now <a href=\"https://github.com/leanprover-community/mathlib4/pull/6432\">#6432</a></p>\n<p>Let me add some comment about the <code>Acc</code> predicate (which seems inadequately addressed in major texts like <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html?highlight=accessible#well-founded-recursion-and-induction\">TPIL</a> and hitchhiker's guide etc.) and about my proof:</p>\n<p>The usual mathematical definition of a well-founded relation <code>r</code> on a type <code>α</code> says that for every nonempty subset <code>s : set α</code>, there exists a <code>r</code>-minimal element in <code>s</code> (i.e. <code>∃ a ∈ s, ∀ b ∈ s, ¬ r b a</code>, see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFounded.has_min#doc\">docs#WellFounded.has_min</a>), if we think of <code>r a b</code> as saying that <code>a</code> is less than <code>b</code>. Equivalently, if <code>s</code> doesn't have a <code>r</code>-minimal element, then it must be empty: <code>∀ s : set α, (∀ a ∈ s, ∃ b ∈ s, r b a) → s = ∅</code>. Replacing <code>s</code> by its complement <code>sᶜ</code>, this is furthermore equivalent to <code>∀ s : set α, (∀ a ∉ s, ∃ b ∉ s, r b a) → s = set.univ</code>. Taking contrapositives twice, we see that <code>∀ a ∉ s, ∃ b ∉ s, r b a</code> is equivalent to <code>∀ a, (∀ b, r b a → b ∈ s) → a ∈ s</code>; let's call a subset <code>s</code> satisfying this condition an <code>r</code>-inductive subset.</p>\n<p>We define an inductive (\"accessibility\") predicate <code>Acc r</code> with a single constructor of type <code>∀ a, (∀ b, r b a → Acc r b) → Acc r a</code>, then <code>{a | Acc r a}</code> is the smallest <code>r</code>-inductive subset by the way inductive predicates work (basically, the recursor of an inductive predicate states precisely this minimality). Well-foundedness says every <code>r</code>-inductive subset must be the whole type, which is equivalent to saying the smallest such subset, <code>{a | Acc r a}</code>, is the whole type. (Note: the smallest such subset exists since the intersection of any set of subsets satisfying the condition itself satisfies the condition.) Therefore, well-foundedness is equivalent to <code>∀ a, Acc r a</code>, which is taken to be the definition of well-foundedness in type theory. Minimality of <code>Acc r</code> means that to prove <code>∀ a, Acc r a → p a</code>, it suffices to show <code>{a | p a}</code> is an <code>r</code>-inductive set, i.e. <code>∀ a, (∀ b, r b a → p b) → p a</code>. In other words, <code>Acc r a</code> allows us to assume <code>p b</code> for all \"<code>b &lt; a</code>\" when proving <code>p a</code>.</p>\n<p>In this particular proof, we want to show the relation <code>rel := fun l m ↦ List.Lex r l.val m.val</code> on <code>{l : List α // l.Chain' (flip r)}</code> is well-founded, i.e. every element is accessible. A list is either <code>nil</code> or of the form <code>a :: l</code>, and <code>List.nil</code> is <code>rel</code>-minimal (\"bottom element\") and therefore trivially accessible (such goals are solved by <code>apply Acc.intro; rintro ⟨_⟩ ⟨_⟩</code> in the proof). In the <code>a :: l</code> case we apply <code>r</code>-induction on <code>a</code> and assume that <code>b :: m</code> is accessible for all \"<code>b &lt; a</code>\", which in particular implies that <code>l</code> is accessible because <code>l.head &lt; a</code> if it's not <code>nil</code>. Due to accessibility of <code>l</code>, we may do induction on <code>l</code> and assume <code>a :: m</code> is accessible for all <code>m</code> such that <code>rel m l</code>. Finally, to show <code>a :: l</code> is accessible, consider all <code>n</code> such that <code>rel n (a :: l)</code>: if <code>n ≠ nil</code> then either <code>n.head &lt; a</code> or <code>n = a :: m</code> for some <code>m</code> satisfying <code>rel m l</code>, and we see in both cases <code>n</code> is accessible by the inductive hypotheses.</p>\n<p>The main tricky thing is that we need to do induction on <code>l'</code> which is <code>l</code> combined with a proof <code>hl</code> that it's a chain under <code>flip r</code>, and is not a free variable that we can directly do induction on. The whole <code>have hl</code>, <code>revert hl</code>, <code>clear_value l'</code> business has the sole purpose to massage <code>l' := ⟨l, hl⟩</code> into a free variable.</p>",
        "id": 382766415,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1691445138
    }
]