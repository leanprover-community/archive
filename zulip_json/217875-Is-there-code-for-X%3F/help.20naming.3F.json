[
    {
        "content": "<p>Can someone suggest a name for this mouthful:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">min_eq_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">w</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">w</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exfalso</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">lt_irrefl</span> <span class=\"n\">a</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>(Or what the canonical proof is?)</p>\n<p>To <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>, I have some fact of the form <code>w : min a b = c</code>, and would like to \"upgrade\" it to <code>b = c</code>, by creating a side-goal <code>c &lt; a</code> that I plan on dispatching before continuing on with the new fact.</p>",
        "id": 374559221,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1689156687
    },
    {
        "content": "<p>I would instead prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">min_lt_left</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 374560849,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1689156990
    },
    {
        "content": "<p>I'm not sure how I would then use that in my <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>.</p>",
        "id": 374566740,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1689157888
    },
    {
        "content": "<p>Here's a Lean 3 demo (because that's what I have open</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">min_lt_left</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">min_eq_right</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n  <span class=\"n\">swap</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">min_lt_left.1</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  α:  Type u_1</span>\n<span class=\"cm\">  _inst_1 : linear_order α</span>\n<span class=\"cm\">  a b c : α</span>\n<span class=\"cm\">  hc : min a b = c</span>\n<span class=\"cm\">  ⊢ c &lt; a</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  α : Type u_1</span>\n<span class=\"cm\">  _inst_1 : linear_order α</span>\n<span class=\"cm\">  a b c : α</span>\n<span class=\"cm\">  hc : b = c</span>\n<span class=\"cm\">  ⊢ true</span>\n<span class=\"cm\">  -/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 374579602,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1689160458
    },
    {
        "content": "<p>If you don't mind the slight obfuscation, you can get it down to one-line:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">min_eq_right</span> <span class=\"o\">(</span><span class=\"n\">min_lt_left.1</span> <span class=\"bp\">$</span> <span class=\"n\">hc.trans_lt</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span> <span class=\"n\">at</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>... except for the fact that <code>rw</code> won't rewrite <code>hc</code> with a term containing itself. Has that changed in Lean 4?</p>",
        "id": 374579930,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1689160534
    },
    {
        "content": "<p>Hmm, that seems like a lot of <code>rw</code> and <code>refine</code> compared to what I want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">min_eq_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">w</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">w</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exfalso</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">lt_irrefl</span> <span class=\"n\">a</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">replace</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span> <span class=\"n\">w</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"c1\">-- Now I can use the stronger result</span>\n  <span class=\"n\">exact</span> <span class=\"n\">w</span>\n  <span class=\"c1\">-- But I have to prove the inequality at some point:</span>\n  <span class=\"bp\">·</span> <span class=\"n\">guard_target</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 374589420,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1689162654
    },
    {
        "content": "<p>Maybe, but I don't think we want your lemma in mathlib. There's a reason why we never have lemmas that assume an equality with one side being a free variable.</p>",
        "id": 374593053,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1689163365
    },
    {
        "content": "<p>What is that reason?</p>",
        "id": 374594732,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1689163668
    },
    {
        "content": "<p>Usually, because the caller could just <code>rw</code> by it first</p>",
        "id": 374612087,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689166979
    },
    {
        "content": "<p>An example of a lemma that mathlib wouldn't have is<code>mul_distrib_of_eq_add (a b c ab) (hab : a + b = ab) : ab * c = a * c + b * c</code>, because the caller should just <code>rw hab</code> first.</p>",
        "id": 374612524,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689167065
    },
    {
        "content": "<p>The exceptions to the rule are usually <code>congr</code> lemmas or places where dependent types make that <code>rw</code> unpleasant</p>",
        "id": 374612704,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689167094
    },
    {
        "content": "<p>... and lemmas used by tactics (eg <code>norm_num</code>)</p>",
        "id": 374615964,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1689167734
    },
    {
        "content": "<p>If we included your particular lemma, then we would also have to include many more for completeness. And I don't think the following is so offputting (my first version was pedagogical, not optimal):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">min_eq_right</span> <span class=\"o\">(</span><span class=\"n\">min_lt_left.1</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span> <span class=\"n\">at</span> <span class=\"n\">hc</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">hc.trans_lt</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 374617053,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1689167971
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>, I'm finding your <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>'s hard to follow due to the use of <code>: true</code></p>",
        "id": 374623792,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689169314
    },
    {
        "content": "<p>Why? My point was to show that I neither needed to act on the goal nor to have the hypothesis <code>c &lt; a</code> laying around to do what Scott wanted.</p>",
        "id": 374624088,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1689169369
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Do you have an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> for your <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>?</p>",
        "id": 374746410,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689196358
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>, for a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, I think what I have above:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.MinMax</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">min_eq_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">w</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">w</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exfalso</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">lt_irrefl</span> <span class=\"n\">a</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">replace</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span> <span class=\"n\">w</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"c1\">-- Now I can use the stronger result:</span>\n  <span class=\"n\">exact</span> <span class=\"n\">w</span>\n  <span class=\"c1\">-- But I have to prove the inequality at some point:</span>\n  <span class=\"bp\">·</span> <span class=\"n\">guard_target</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The desiderata is:</p>\n<ul>\n<li>at the line that is currently <code>replace w := foo w ?_</code> I want something that is:<ul>\n<li>short,</li>\n<li>ideally readably indicates what the new state will be</li>\n</ul>\n</li>\n<li>after that line, we have <ul>\n<li><code>b = c</code> in the context</li>\n<li>a side goal of <code>c &lt; a</code></li>\n<li>I don't particularly mind the order of the goals, although would slightly prefer (unlike the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>) the side goal to come first.</li>\n</ul>\n</li>\n</ul>\n<p>Maybe it's also clearer if you just imagine <code>c = 0</code> in all of this.</p>",
        "id": 374763107,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1689203789
    },
    {
        "content": "<p>As for the actual <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>, I'm not sure I can usefully minimise it right now, but the place this came up was on <a href=\"https://github.com/leanprover-community/mathlib4/tree/edit_distance\">branch#edit_distance</a>, at <a href=\"https://github.com/leanprover-community/mathlib4/blob/85d0c28e0d45f64e79083a08a5dd71cfd0422838/Mathlib/Data/List/EditDistance.lean#L549\">this line</a>.</p>\n<p>I have a hypothesis that looks like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"o\">(</span><span class=\"n\">Cost.insert</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">levenshtein</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Cost.substitute</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>and at this point in the proof the reasoning should be:</p>\n<ul>\n<li>\"Clearly <code>Cost.insert y</code> is positive, and levenshtein is non-negative</li>\n<li>so the first alternative can't be the minimum, and </li>\n<li>we can conclude <code>Cost.substitute x y + levenshtein xs ys = 0</code>.</li>\n</ul>",
        "id": 374763813,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1689204192
    },
    {
        "content": "<p>What are the types?</p>",
        "id": 374764345,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689204515
    },
    {
        "content": "<p>Does <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=min_eq_iff#doc\">docs#min_eq_iff</a> help?</p>",
        "id": 374764403,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689204563
    },
    {
        "content": "<p>Also, if you live in <code>NNReal</code> or <code>Nat</code>, then we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=min_eq_bot#doc\">docs#min_eq_bot</a></p>",
        "id": 374764526,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689204648
    },
    {
        "content": "<p>Looking at the code, did you consider adding a requirement that the codomain is a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CanonicallyOrderedAddMonoid#doc\">docs#CanonicallyOrderedAddMonoid</a> ?</p>",
        "id": 374764858,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689204849
    },
    {
        "content": "<p>is there code for theorem my_lemma : ∀ x y ε : ℝ , 0 &lt; ε → ε ≤ 1 → ∣ x ∣ &lt; ε → ∣ y ∣ &lt; ε → ∣ x * y ∣ &lt; ε :=<br>\n  sorry</p>",
        "id": 375130434,
        "sender_full_name": "tsuki  hao",
        "timestamp": 1689313642
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_lt_of_lt_of_le_one_of_nonneg#doc\">docs#mul_lt_of_lt_of_le_one_of_nonneg</a></p>",
        "id": 375378103,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689365308
    },
    {
        "content": "<p>(after rewriting <code>abs_mul</code>)</p>",
        "id": 375378135,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689365315
    },
    {
        "content": "<p>The assumption on <code>y</code> can be weakend to <code>|y| ≤ 1</code></p>",
        "id": 375378257,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689365343
    }
]