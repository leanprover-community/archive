[
    {
        "content": "<p>I am working on a quantum library that works with dot products between two bitvectors, and I believe definitions like below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foldr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">fold</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">init</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">weight</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">foldr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">dot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">weight</span>\n</code></pre></div>\n<p>would be useful to have in the standard library. Is that true?</p>",
        "id": 516744839,
        "sender_full_name": "Fady Adal",
        "timestamp": 1746643464
    },
    {
        "content": "<p>I think the argument is that <code>fold</code> is  more general than <code>foldr</code>, so the latter isn't needed</p>",
        "id": 516745358,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746643665
    },
    {
        "content": "<p><code>weight</code> might be better called <code>popcount</code> to match <code>gmp_popcount</code>; which is also to say that it could have a native-ish implementation</p>",
        "id": 516745572,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746643739
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> . Thanks for the reply. Where is <code>BitVec.fold</code> defined?</p>",
        "id": 516745703,
        "sender_full_name": "Fady Adal",
        "timestamp": 1746643800
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BitVec.fold#doc\">docs#BitVec.fold</a></p>",
        "id": 516746126,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746643955
    },
    {
        "content": "<p>Oh, I thought you were saying it already existed</p>",
        "id": 516746176,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746643972
    },
    {
        "content": "<p>Did an LLM hallucinate it above?</p>",
        "id": 516746187,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746643977
    },
    {
        "content": "<p>Above I'm folding on the <code>w : Nat</code> that is the width of the <code>BitVec</code>. The only fold-related operation that I can find on <code>BitVec</code>s is <code>BitVec.iunfoldr</code>, which doesn't really accomplish the intention here. Would this be a useful construct to add?</p>",
        "id": 516746993,
        "sender_full_name": "Fady Adal",
        "timestamp": 1746644241
    },
    {
        "content": "<p>Sorry for my garbage comment above, your suggestion makes sense now!</p>",
        "id": 516747562,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746644437
    },
    {
        "content": "<p>No worries! Sorry I wasn't very clear with my suggestion</p>",
        "id": 516747827,
        "sender_full_name": "Fady Adal",
        "timestamp": 1746644542
    },
    {
        "content": "<p>On a more helpful note, you can write <code>dot</code> as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">dot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">hammingDist</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">getLsb'</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">getLsb'</span>\n</code></pre></div>\n<p>which comes with some lemmas</p>",
        "id": 516749248,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746645093
    },
    {
        "content": "<p>I think this is more like <code>(x ^^^ y).weight</code>, but I didn't know about that function! I think <code>hammingDist (x &amp;&amp;&amp; y).getLsb' 0</code> should do the job. Thanks for pointing it out.</p>",
        "id": 516971021,
        "sender_full_name": "Fady Adal",
        "timestamp": 1746734394
    },
    {
        "content": "<p>So far we have very little theory about <code>BitVec</code> as a container type, rather than <code>BitVec</code> as an algebraic/logical type.</p>\n<p>The fact we are missing <code>fold</code> is a consequence of this.</p>\n<p>We're generally open to such additions in the Lean4 standard library, although I'd like to see any additional functions coming equipped with fairly complete theory as well, so we don't get further behind.</p>\n<p>To start treating <code>BitVec</code> as a container we need a lot of basic infrastructure, e.g. <code>ofFnLE</code> <code>ofVector</code>, <code>toVector</code>, ...</p>",
        "id": 517101956,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1746794501
    },
    {
        "content": "<p><code>toVector</code> is <code>Vector.mk bv.getLsb'</code>, right?</p>",
        "id": 517102313,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746794600
    },
    {
        "content": "<p>Yes. I think it nevertheless deserves a name.</p>",
        "id": 517102968,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1746794785
    },
    {
        "content": "<p>(despite my usual aversion to increasing API surface area --- basic conversion functions are needed for sanity)</p>",
        "id": 517103073,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1746794816
    },
    {
        "content": "<p>I guess my argument is that conversion to vector is expensive, and actually working directly with the tuple returned by <code>getLsb'</code> is likely to lead to more efficient code</p>",
        "id": 517103409,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746794913
    },
    {
        "content": "<p>But perhaps that's just what the docstring for <code>toVector</code> should say</p>",
        "id": 517103463,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746794933
    },
    {
        "content": "<p>I'd be happy to mark <code>toVector</code> noncomputable, and explain that it is for theory only.</p>",
        "id": 517103524,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1746794954
    },
    {
        "content": "<p>That also sounds like a bad idea, there are situation where it really is what you want</p>",
        "id": 517110015,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746796897
    },
    {
        "content": "<p>I have opened a draft PR with container operations for BitVec: <a href=\"https://github.com/leanprover/lean4/pull/11329\">https://github.com/leanprover/lean4/pull/11329</a>. Looking forward to your feedback!</p>",
        "id": 558925733,
        "sender_full_name": "Fady Adal",
        "timestamp": 1763935209
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Why.20isn't.20there.20code.20for.20.60BitVec.2Efoldr.60.3F/near/517103524\">said</a>:</p>\n<blockquote>\n<p>I'd be happy to mark <code>toVector</code> noncomputable, and explain that it is for theory only.</p>\n</blockquote>\n<p>I can think of very real applications where one wants a vector of bits. Though you're more likely of course to want a bytearray in practice...</p>",
        "id": 559103179,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764003778
    },
    {
        "content": "<p>Being able to unpack/pack a bytearray to a bitvec would be quite useful for some things.</p>",
        "id": 559105275,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764004285
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Why.20isn't.20there.20code.20for.20.60BitVec.2Efoldr.60.3F/near/559105275\">said</a>:</p>\n<blockquote>\n<p>Being able to unpack/pack a bytearray to a bitvec would be quite useful for some things.</p>\n</blockquote>\n<p>I would be interested in adding that as well! It would be a nice feature. We'd need to decide on conventions for endianness and how to handle packing/unpacking bitvectors whose length isn't a multiple of 8. I'm open to exploring a C++ vs pure Lean implementation for it, too.</p>",
        "id": 560551876,
        "sender_full_name": "Fady Adal",
        "timestamp": 1764236275
    },
    {
        "content": "<p>I think BitVec itself takes a big-endian convention so I would suggest doing the same here!</p>",
        "id": 560577645,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1764243986
    },
    {
        "content": "<p>BitVec actually aspires to mostly allow both endianness conventions. It's only <code>getElem</code> that is biased.</p>",
        "id": 560870687,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1764378412
    },
    {
        "content": "<p>I don't agree with that; when working with big endian bit vectors in verilog (eg <code>wire x [7:0]</code>), <code>x[0]</code> is still the LSB.</p>",
        "id": 560870859,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1764378632
    },
    {
        "content": "<p>The bias arguably resides in <code>++</code>, or perhaps <code>toList</code></p>",
        "id": 560870907,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1764378703
    },
    {
        "content": "<p>In the PR, I added both <code>toList</code> and <code>toListBE</code> to complement <code>ofBoolListLE</code> and <code>ofBoolListBE</code>. I left <code>toList</code> without a suffix so that <code>bv[i]</code> and <code>bv.toList[i]</code> would align, but I’m open to adding a suffix if the goal is to keep the API fully endianness-agnostic. I also only added <code>toArray</code> and <code>toVector</code> for the same reason, but I can include the big-endian variants if that would be more consistent.</p>",
        "id": 560871626,
        "sender_full_name": "Fady Adal",
        "timestamp": 1764379596
    },
    {
        "content": "<p>I've implemented the <code>ByteArray</code> conversions we discussed. I added both Little Endian and Big Endian variants to support different use cases:</p>\n<ul>\n<li><strong>To ByteArray</strong>: <code>toBytesLE</code> and <code>toBytesBE</code> convert a BitVec w to a ByteArray of size (w + 7) / 8.<ul>\n<li><strong>Padding</strong>: Since BitVec width might not be a multiple of 8, I handled padding as follows:<ul>\n<li><code>LE</code>: Zero-padding goes in the high bits of the last byte.</li>\n<li><code>BE</code>: Zero-padding goes in the high bits of the first byte.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>From ByteArray</strong>: <code>ofBytesLE</code> and <code>ofBytesBE</code> convert a ByteArray back to a BitVec.</p>\n<ul>\n<li>The resulting BitVec always has width <code>bytes.size * 8</code>.</li>\n</ul>\n</li>\n<li>\n<p><strong>Round-trips</strong>:</p>\n<ul>\n<li><code>toBytes (ofBytes bytes)</code> is an exact round-trip.</li>\n<li><code>ofBytes (toBytes bv)</code> results in <code>bv.zeroExtend</code> if the original width wasn't a multiple of 8 (since the byte array forgets the exact original bit width).</li>\n</ul>\n</li>\n</ul>\n<p>I also included proofs of the round-trip properties and injectivity. The next steps will likely involve extending the theory to cover these conversions when used alongside <code>BitVec</code> algebraic operations such as <code>&amp;&amp;&amp;</code>, shifts, and related constructs. Let me know what you think!</p>",
        "id": 562877950,
        "sender_full_name": "Fady Adal",
        "timestamp": 1765350240
    },
    {
        "content": "<p>Maybe there should be a function to get the nth limb in the GMP implementation. Then we can implement <code>BitVec.toBytes</code>, <code>Nat.popcount</code>, <code>Nat.testBit</code>, etc. efficiently directly in Lean.</p>",
        "id": 563101284,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1765425971
    }
]