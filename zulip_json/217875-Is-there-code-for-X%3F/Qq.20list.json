[
    {
        "content": "<p>Do we have something which can accomplish something similar to the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">Qq.list</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Level</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"bp\">$</span><span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"bp\">$</span><span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">whnf</span> <span class=\"n\">L</span>\n  <span class=\"k\">match</span> <span class=\"n\">L</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">([])</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Qq.list</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"Failed\"</span>\n</code></pre></div>",
        "id": 404001640,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700847028
    },
    {
        "content": "<p>I doubt it; though we might have the reverse direction</p>",
        "id": 404004217,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700848617
    },
    {
        "content": "<p>Sure, the reverse direction is more \"obvious\" i guess.</p>",
        "id": 404004241,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700848631
    },
    {
        "content": "<p>In general I guess you could generate something like this for any parameterized inductive type?</p>",
        "id": 404004418,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700848773
    },
    {
        "content": "<p>What are parameterized inductive types?</p>",
        "id": 404004437,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700848794
    },
    {
        "content": "<p>Oh you mean just an inductive type with parameters.</p>",
        "id": 404004496,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700848810
    },
    {
        "content": "<p>yes</p>",
        "id": 404004502,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700848811
    },
    {
        "content": "<p>But such a function would be more complicated, as one would have to obtain the constructors of that type inside of <code>MetaM</code>, etc.</p>",
        "id": 404004548,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700848842
    },
    {
        "content": "<p>Reflection like this wouldn't work for all inductive types, but it seems like it should for a large class of them (For example, what if your inductive type <code>T</code> has a constructor with a <code>Nat -&gt; T</code> argument?)</p>\n<p>By the way, Qq pattern matching does defeq tests, so if you care about efficiency you probably would want to match on constructors directly.</p>\n<p>Here's just some messing around, adding a couple more of these functions to be able to evaluate Finsets too.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Multiset.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Qq</span>\n\n<span class=\"sd\">/-- Reduce the spine of a List expression to yield a List of expressions. -/</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">Qq.list</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Level</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"bp\">$</span><span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"bp\">←</span> <span class=\"n\">whnf</span> <span class=\"n\">L</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">List.nil</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">List.cons</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">S</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"bp\">$</span><span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">return</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Qq.list</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">L'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"Failed to reduce List expression. Got{indentD L'}\"</span>\n\n<span class=\"sd\">/-- Reduce a Multiset expression to give its underlying List of expressions. -/</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">Qq.multiset</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Level</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Multiset</span> <span class=\"bp\">$</span><span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"bp\">←</span> <span class=\"n\">whnfD</span> <span class=\"n\">m</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Quot.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"bp\">$</span><span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Qq.list</span> <span class=\"n\">L</span>\n  <span class=\"bp\">|</span> <span class=\"n\">m'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"Failed to reduce Multiset to a `Quot.mk` application. Got{indentD m'}\"</span>\n\n<span class=\"sd\">/-- Reduce a Multiset expression to give its underlying List of expressions. -/</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">Qq.finset</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Level</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"bp\">$</span><span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"bp\">←</span> <span class=\"n\">whnf</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Finset.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Multiset</span> <span class=\"bp\">$</span><span class=\"n\">S</span><span class=\"o\">)))</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Qq.multiset</span> <span class=\"n\">m</span>\n  <span class=\"bp\">|</span> <span class=\"n\">s'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"Failed to reduce Finset to a constructor application. Got{indentD s'}\"</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Bool</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">l</span> <span class=\"bp\">←</span> <span class=\"n\">Qq.finset</span> <span class=\"n\">e</span>\n  <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"Elements: {l}\"</span>\n  <span class=\"c1\">-- Elements: [Bool.true, Bool.false]</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Finset.range</span> <span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">l</span> <span class=\"bp\">←</span> <span class=\"n\">Qq.finset</span> <span class=\"n\">e</span>\n  <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"Elements: {l}\"</span>\n  <span class=\"c1\">-- Elements: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>\n</code></pre></div>",
        "id": 404012211,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700854199
    },
    {
        "content": "<p>It would be kind of neat to use a simp-like procedure to do whnf, so that way you can do bigger steps in reduction if you happen to know special properties of a function (or even to be able to reduce things that the kernel can't reduce), while also generating a proof that the result actually represents the original list.</p>",
        "id": 404012502,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700854367
    },
    {
        "content": "<p>Btw, I did something like this (the non-Qq <code>List</code> version) way back when for <code>tfae</code>; I’m on mobile but I believe it’s called something like <code>getExplicitList</code>! (It might be missing a <code>whnf</code> though…) If you’re PRing something feel free to factor it out, rename it, and/or improve it. :)</p>",
        "id": 404018592,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700859090
    },
    {
        "content": "<p>We have the non-recursive matching step as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Meta.List.proveNilOrCons#doc\">docs#Mathlib.Meta.List.proveNilOrCons</a>. I used a definition like you proposed in the Lean 3 norm_num big operators plugin. I found out that it was nicer to only do the case distinction and handle recursion in the tactic itself.</p>",
        "id": 404368657,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1701077269
    }
]