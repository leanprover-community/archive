[
    {
        "content": "<p>So, I'm using the really helpful <code>mod_cases</code> tactic, and it's leaving  me a few subgoals which all have assumptions of the form <code>h : p ≡ k [MOD 3]</code>. It would be really helpful if I could rewrite that as <code>∃ k : ℕ, 3 * k + 1 = p</code> but I'm not seeing anything in <code>Mathlib.Data.Nat.ModEq</code> that would enable me to do that easily. Is there something I'm missing here?</p>",
        "id": 452159292,
        "sender_full_name": "Sophia C",
        "timestamp": 1721241666
    },
    {
        "content": "<p>I'm a bit confused by the <code>k</code> becoming existentially quantified. But if you are trying to get out of ModEq I would think your best bet would be to apply <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Nat/ModEq.html#Nat.modEq_iff_dvd\">Nat.modEq_iff_dvd</a> and then go from there.</p>",
        "id": 452169601,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1721244719
    }
]