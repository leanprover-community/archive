[
    {
        "content": "<p>I’m having a hard time counting the number of possible values of a structure containing a function from Fun k under a certain condition. I have a Lemma that gives me a (finite) upper bound on the possible values for each function value under the condition. Since the type is not finite I’m using ENat.card and Set.encard. So essentially what I’m looking for is an extension of Set.encard_prod from pairs to arbitrary tuples. I had a look at Cardinality which might have it, but I’m a but lost in the notation and would appreciate any help! Thanks!</p>",
        "id": 561116201,
        "sender_full_name": "chris477",
        "timestamp": 1764583979
    },
    {
        "content": "<p>Can you post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ? This is the best way to ask questions on this forum.</p>",
        "id": 561119175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764584826
    },
    {
        "content": "<p>Sure! We have in mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">card_prod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and I would like to extend this to arbitrary tuples of sets as follows (or rather use an existing lemma of course):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">card_fin_k_prod</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">sets</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">sets</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∏</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">sets</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Here, lean complains that <code>ENat.card</code> is not applicable. I might also be confusing cardinality of types and cardinality of sets.</p>",
        "id": 561123490,
        "sender_full_name": "chris477",
        "timestamp": 1764585914
    },
    {
        "content": "<p>You have <code>sets</code> which is a k-tuple of subsets of <code>α</code>. You are trying to say that the cardinality of <code>sets</code> (which is a k-tuple) is equal to the product of the cardinalities of its components. Do you understand why that statement doesn't make sense?</p>",
        "id": 561130290,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764587706
    },
    {
        "content": "<p>Actually, in some way I understand it, in some way I don't. :D I think the issue comes from the fact that sometimes, ENat.card seems to be applied to values (when talking about the cardinality of a set) and sometimes it seems to be applied to types (when talking about the number of values that inhabit the type). But it might also be that my concept of a set is completely wrong.</p>\n<p>But to maybe make some progress here, I think I can work with <code>ENat.card_fun</code> because the cardinalities can all be bounded by the same number in practice.</p>\n<p>Thanks for your help!</p>",
        "id": 561136342,
        "sender_full_name": "chris477",
        "timestamp": 1764589587
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"948935\">chris477</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/cardinality.20of.20functions.20from.20Fin.20k/near/561136342\">said</a>:</p>\n<blockquote>\n<p>Actually, in some way I understand it, in some way I don't. :D I think the issue comes from the fact that sometimes, ENat.card seems to be applied to values (when talking about the cardinality of a set) and sometimes it seems to be applied to types (when talking about the number of values that inhabit the type).</p>\n</blockquote>\n<p>That's because if you have a <code>s : Set α</code> and you put it in a place where it's expecting a type Lean does a coercion so that <code>Set.Elem s</code> is inserted there instead of <code>s</code>, and <code>Set.Elem s</code> is a type (the type of elements of <code>s</code>).</p>",
        "id": 561136773,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764589712
    },
    {
        "content": "<p>oh, I didn't expect that, thanks! Is that because of the <code>@[coe]</code> annotation of Elem?</p>",
        "id": 561137315,
        "sender_full_name": "chris477",
        "timestamp": 1764589885
    },
    {
        "content": "<p>the <code>@[coe]</code> annotation of <code>Set.Elem</code> only affects the pretty printer, so that you see <code>↑s</code> instead of <code>Set.Elem s</code> in the pretty printer output. It's the instance that comes right after, which is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.instCoeSortType#doc\">docs#Set.instCoeSortType</a>, that lets Lean find it as a coercion.</p>",
        "id": 561138021,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764590100
    },
    {
        "content": "<p>Nice, thanks!</p>",
        "id": 561138117,
        "sender_full_name": "chris477",
        "timestamp": 1764590128
    },
    {
        "content": "<p>Unfortunately, I'm still coming back to this issue. I was able to show</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">card_fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"w\"> </span><span class=\"bp\">≤</span>\n<span class=\"w\">    </span><span class=\"bp\">∏</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Cardinal</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>but not the corresponding lemma for <code>encard</code>, essentially because an analog of <code>Cardinal.prod_eq_of_fintype</code> is missing (and the fact that <code>Set.encard</code> can not be applied to tuples of sets).</p>\n<p>Maybe another way to state the question would also be: The documentation in <code>Data/Set/Card.lean</code> explains the advantages and disadvantages of Set.encard, Set.ncard and Finset.card, but it does not mention <code>Cardinal</code> at all. I agree that <code>Finset.card</code> is super cumbersome to use if the type is not obviously finite, but should I rather work with Cardinal instead since it seems to have some lemmas that are missing from encard, or should encard be extended instead?</p>",
        "id": 562644674,
        "sender_full_name": "chris477",
        "timestamp": 1765275475
    },
    {
        "content": "<p>I created a pull request here for the encard version of the lemma: <a href=\"https://github.com/leanprover-community/mathlib4/pull/32644\">https://github.com/leanprover-community/mathlib4/pull/32644</a></p>",
        "id": 562655665,
        "sender_full_name": "chris477",
        "timestamp": 1765278467
    }
]