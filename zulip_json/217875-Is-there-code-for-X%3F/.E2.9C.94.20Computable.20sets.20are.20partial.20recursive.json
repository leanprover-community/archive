[
    {
        "content": "<p>Hello - I'm working on formalizing a result in computability theory, which uses the fact that finite sets are partial recursive.</p>\n<p>Is there already code for this somewhere? I poked around Partrec.lean but didn't find any mention of finite sets.</p>",
        "id": 519249329,
        "sender_full_name": "David J. Webb",
        "timestamp": 1747698124
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"347475\">@Bjørn Kjos-Hanssen</span> it's the cohesive/Pi^0_1-immunity lemma from my dissertation :D</p>",
        "id": 519249422,
        "sender_full_name": "David J. Webb",
        "timestamp": 1747698170
    },
    {
        "content": "<p>I haven't seen that in Mathlib. There's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Computable.const#doc\">docs#Computable.const</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ComputablePred.ite#doc\">docs#ComputablePred.ite</a> which could maybe be used to prove by induction on <code>n</code> that every set of cardinality <code>n</code> is computable.</p>",
        "id": 519250772,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1747698728
    },
    {
        "content": "<p>Oh that could work! I'll try proving that as a lemma</p>",
        "id": 519252257,
        "sender_full_name": "David J. Webb",
        "timestamp": 1747699391
    },
    {
        "content": "<p>(you should prove it is <code>PrimRec</code>, the proof is the same and the result is stronger)</p>",
        "id": 519364070,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747741781
    },
    {
        "content": "<p>Good idea, then I'll just hit it with <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/Partrec.html#Nat.Partrec.of_primrec\">Nat.Partrec.of_primrec</a>!</p>",
        "id": 519366981,
        "sender_full_name": "David J. Webb",
        "timestamp": 1747742681
    },
    {
        "content": "<p>I'm keen to work with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"normal\">Σ</mi><mn>1</mn><mn>0</mn></msubsup></mrow><annotation encoding=\"application/x-tex\">\\Sigma^0_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0622em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord\">Σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-2.4519em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span></span></span></span> sets, so I can deal with complements and subsets, so my current definition is </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"bp\">Σ</span><span class=\"mi\">01</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→.</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Partrec</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">Dom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X</span>\n</code></pre></div>\n<p>to move away from dealing with partial recursive functions.</p>",
        "id": 519367074,
        "sender_full_name": "David J. Webb",
        "timestamp": 1747742715
    },
    {
        "content": "<p>Why not define the whole hierarchy while you are at it?</p>",
        "id": 519368180,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747743010
    },
    {
        "content": "<p>After I get these first lemmas working, that's the plan!</p>",
        "id": 519369257,
        "sender_full_name": "David J. Webb",
        "timestamp": 1747743309
    },
    {
        "content": "<p>Okay, the project is rapidly growing in scope, but these are all definitions that needed to be formalized anyway:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">set_Primrec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">set_Computable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Computable</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">set_Partrec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→.</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Partrec</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">Dom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X</span>\n</code></pre></div>\n<p>I've got that primitive recursive sets are computable, that wasn't too bad.</p>\n<p>Trying to prove that computable sets are partial recursive is proving to be slightly thorny for me - I have convert my witnessing function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>  from a total function on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>⊆</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">X\\subseteq\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> to a partial function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">f&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9463em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> by writing</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→.</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Part</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">Part</span><span class=\"bp\">.</span><span class=\"n\">none</span>\n</code></pre></div>\n<p>but showing that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">f&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9463em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> is partial recursive is giving me trouble.</p>\n<p>I think I'm just unfamiliar with how to use PartRec <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 519742937,
        "sender_full_name": "David J. Webb",
        "timestamp": 1747886846
    },
    {
        "content": "<p>check out <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Partrec.cond#doc\">docs#Partrec.cond</a></p>",
        "id": 519747348,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1747889967
    },
    {
        "content": "<p>have you already proved that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is computable?</p>",
        "id": 519747462,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1747890026
    },
    {
        "content": "<p>Yes, I have that by assumption</p>",
        "id": 519749209,
        "sender_full_name": "David J. Webb",
        "timestamp": 1747891257
    },
    {
        "content": "<p>Ah, I see, I should be able to use the fact that f is computable, and Part.some and Part.none are partial recursive</p>\n<p>Should just be a syntax thing on my end, then</p>",
        "id": 519749359,
        "sender_full_name": "David J. Webb",
        "timestamp": 1747891356
    },
    {
        "content": "<p>Yep, dumb syntax thing - an extra</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Primcodable</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Primcodable</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>had slipped in from my brief experiment with Github Copilot</p>",
        "id": 519777963,
        "sender_full_name": "David J. Webb",
        "timestamp": 1747903187
    },
    {
        "content": "<p>Got it! :D</p>\n<p>Current goals are to show <del>singletons are primitive recursive, and that PrimRec is closed under union.</del> (done!)</p>",
        "id": 519782017,
        "sender_full_name": "David J. Webb",
        "timestamp": 1747904335
    },
    {
        "content": "<p>Why not use <code>ℕ →. Unit</code> instead of <code>ℕ →. Bool</code> if it's not carrying any information?</p>",
        "id": 519831387,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747919398
    },
    {
        "content": "<p>Because I didn't think of it, to be honest!</p>\n<p>Not a bad idea, I can see how that would change the proofs later.</p>",
        "id": 519836834,
        "sender_full_name": "David J. Webb",
        "timestamp": 1747920741
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"381517\">@David J. Webb</span> No idea if this is helpful at all, but there are a number of lemmas about list operations being primrec (like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/Primrec.html#Primrec.list_idxOf%E2%82%81\">Primrec.list_idxOf₁</a>), and these can be used to prove that finite set membership is primrec.</p>\n<p>For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">list_mem</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Primcodable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimrecPred</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">list_idxOf₁</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">not</span><span class=\"bp\">.</span><span class=\"n\">of_eq</span>\n<span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">idxOf_eq_length_iff</span><span class=\"o\">])</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">finset_mem</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Primcodable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimrecPred</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">list_mem</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">of_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">set_Primrec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">set_Primrec</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">hX</span><span class=\"bp\">.</span><span class=\"n\">toFinset</span><span class=\"o\">),</span>\n<span class=\"w\">  </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">finset_mem</span><span class=\"w\"> </span><span class=\"n\">hX</span><span class=\"bp\">.</span><span class=\"n\">toFinset</span><span class=\"o\">,</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 519930139,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1747952834
    },
    {
        "content": "<p>however, I understand that this probably isn't as satisfying as proving it from the ground up</p>",
        "id": 519930332,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1747952966
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Computable.20sets.20are.20partial.20recursive/near/519831387\">said</a>:</p>\n<blockquote>\n<p>Why not use <code>ℕ →. Unit</code> instead of <code>ℕ →. Bool</code> if it's not carrying any information?</p>\n</blockquote>\n<p>A good tip, I've changed the definition of Partrec to use Option Unit now</p>",
        "id": 520020656,
        "sender_full_name": "David J. Webb",
        "timestamp": 1747996374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"381517\">David J. Webb</span> has marked this topic as resolved.</p>",
        "id": 521092728,
        "sender_full_name": "Notification Bot",
        "timestamp": 1748524663
    }
]