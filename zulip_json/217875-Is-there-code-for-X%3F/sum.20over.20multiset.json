[
    {
        "content": "<p>In <a class=\"message-link\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/Algebra.2ETensorProduct.2Eassoc/near/536033517\">#Is there code for X? &gt; Algebra.TensorProduct.assoc @ üí¨</a> , I wondered whether one should have a notation for summation over a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset#doc\">docs#Multiset</a>, analogous, and more general than the notation for summation over a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset#doc\">docs#Finset</a>. <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> seemed to agree, <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> was not so sure about it. For the moment, working with sums over multisets is syntactically a bit awkward, one needs to compose <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.map#doc\">docs#Multiset.map</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.sum#doc\">docs#Multiset.sum</a>. What do people think?</p>",
        "id": 536175930,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1756193576
    },
    {
        "content": "<p>I'm slightly torn here, in that I'm also sometimes frustrated by the notation for multiset sums. But on the other hand, let me point out that <code>{s : Finset a} {f : a -&gt; b}</code> with a non-injective <code>f</code> does allow summation with duplicates (in that it builds the multiset s.image f), and oftentimes this is actually the more convenient notion.</p>",
        "id": 536176512,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1756193801
    },
    {
        "content": "<p>One possible intermediate is to generalise <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.sum#doc\">docs#Multiset.sum</a> to be closer to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sum#doc\">docs#Finset.sum</a>, by giving it a function argument as well. Then the syntax would be <code>s.sum f</code> rather than <code>(s.map f).sum</code>, which feels more ergonomic to me. (But then again, I remember the days when that's how we wrote finset sums too, before the notation!)</p>",
        "id": 536176666,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1756193861
    },
    {
        "content": "<p>My take is that adding an argument to sum might be a bad idea since then we have to deal with <code>(s.map f).sum id</code> vs <code>s.sum f</code>, but maybe notation is still worthwhile</p>",
        "id": 536177348,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756194169
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/sum.20over.20multiset/near/536177348\">said</a>:</p>\n<blockquote>\n<p>My take is that adding an argument to sum might be a bad idea since then we have to deal with <code>(s.map f).sum id</code> vs <code>s.sum f</code>, but maybe notation is still worthwhile</p>\n</blockquote>\n<p>We already have this with finsets though, and in the multiset case we can just <code>simp</code> the former into the latter. But I agree that the full measure negates the need for the half measure.</p>",
        "id": 536178187,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1756194540
    },
    {
        "content": "<p>The issue with such a notation would be that you can't change a single value anymore. Every time I thought \"would be nice to have notation for <code>Multiset.sum</code>\" (quite a few times!), I was caught a few lines later by this subtlety, and every time it turned out much better to index by a finset rather than a multiset</p>",
        "id": 536195811,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1756200756
    },
    {
        "content": "<p>This is why I think such a notation would be actively damaging: It would drag beginners into the trap</p>",
        "id": 536195975,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1756200795
    },
    {
        "content": "<p>Can you elaborate on what that trap is?</p>",
        "id": 536196041,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756200810
    },
    {
        "content": "<p>Do you mean change a single value in the multiset, or change a single point of the function? Surely in the former case, you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.erase#doc\">docs#Multiset.erase</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.insert#doc\">docs#Multiset.insert</a>, and in the latter you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.update#doc\">docs#Function.update</a></p>",
        "id": 536196567,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1756200915
    },
    {
        "content": "<p>If you have <code>2 + 2</code> written as <code>({2, 2}.map id).sum</code>, then you cannot change the function to make the sum be <code>2 + 3</code> instead</p>",
        "id": 536197664,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1756201139
    },
    {
        "content": "<p>Oh, I think I understand what Ya√´l means now, it's eg if we have the multiset <code>{1, 2, 2}</code> and we want the two 2s to map to different things.</p>",
        "id": 536197691,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1756201144
    },
    {
        "content": "<p>I agree this is a deficiency of this notation, but I also think it's not that much of a beginner trap; it's relatively clear informally speaking that 2+3 isn't a sum over the multiset {2,2}. So the notation isn't really leading anyone astray, since informally there's also no multiset sum going on</p>",
        "id": 536198574,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1756201336
    },
    {
        "content": "<p>The only reasonable solution here is to reindex the multiset by a finset (which is painful on top of going against the point of introducing multiset sum notation in the first place). The alternative of modifying the multiset is awkward, as you need to find a value that's not yet used in your multiset (which isn't even always possible if the ground type is finite) and simultaneously make sure that that new value is mapped to what you want it to be.</p>",
        "id": 536198606,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1756201346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/sum.20over.20multiset/near/536198574\">said</a>:</p>\n<blockquote>\n<p>I agree this is a deficiency of this notation, but I also think it's not that much of a beginner trap; it's relatively clear informally speaking that 2+3 isn't a sum over the multiset {2,2}. So the notation isn't really leading anyone astray, since informally there's also no multiset sum going on</p>\n</blockquote>\n<p>Say what you want, but I fell in the trap three/four times myself!</p>",
        "id": 536198822,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1756201419
    },
    {
        "content": "<p>You're not a beginner, so that confirms it's not a beginner trap ;)</p>",
        "id": 536198901,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1756201449
    },
    {
        "content": "<p>I was a beginner in 2021-2022 <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 536198979,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1756201474
    },
    {
        "content": "<p>I personally think all we gain with this multiset sum notation is a footgun to shoot ourselves with</p>",
        "id": 536199141,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1756201528
    },
    {
        "content": "<p>I think the key takeaway from this example is that this notation is actually less general than the finset version, even though it a priori feels more general: any multiset sum can be written as a finset sum by taking an arbitrary <code>Type 0</code>, but not every finset sum can be written nicely as a multiset sum, as Ya√´l describes above.</p>",
        "id": 536199367,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1756201604
    },
    {
        "content": "<p>I've learnt and forgotten this fact before, perhaps it should be added to the docstring of multiset.sum or something?</p>",
        "id": 536200239,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756201919
    },
    {
        "content": "<p>And this pattern of indexing by <code>Type 0</code> exists in mathlib in at least a couple of places already, eg one as pointed out by Aaron <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CommGroup.equiv_prod_multiplicative_zmod_of_finite#doc\">docs#CommGroup.equiv_prod_multiplicative_zmod_of_finite</a>, and another here <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=convexHull_eq#doc\">docs#convexHull_eq</a> (importantly, see its docstring and that for the next two lemmas too). I agree it's not always immediate to guess that <code>Type 0</code> does work (and as Aaron explained yesterday, and these examples show, it does always work for finite sums), but hopefully this too can be fixed with documentation</p>",
        "id": 536200509,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1756202025
    },
    {
        "content": "<p>I've been using it for ages:<br>\n<a href=\"https://github.com/madvorak/vcsp/blob/f738bc6655a9fd6f3c5b4184ccfbff942f3aafac/VCSP/Basic.lean#L9\">https://github.com/madvorak/vcsp/blob/f738bc6655a9fd6f3c5b4184ccfbff942f3aafac/VCSP/Basic.lean#L9</a></p>\n<p>I am ambivalent about whether it should be and in which form (definition or notation or both) in Mathlib.</p>",
        "id": 536203806,
        "sender_full_name": "Martin Dvo≈ô√°k",
        "timestamp": 1756203285
    },
    {
        "content": "<p>I was actually just thinking about this today, after encountering a situation where I expected to be able to use sum notation with a multiset and could not.</p>\n<p>This is the theorem draft I formalized:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">If z is a root of the derivative of a polynomial p, but not a root of p itself,</span>\n<span class=\"sd\">then the sum of the inverses of the differences between x and each root of p is zero.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">sum_inv_sub_roots_eq_zero</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚ÑÇ</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hz_mem_derivative</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">derivative</span><span class=\"bp\">.</span><span class=\"n\">roots</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hz_not_mem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">‚àâ</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">roots</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ‚àë a ‚àà p.roots, (z - a)‚Åª¬π = 0 -- gives error</span>\n<span class=\"w\">    </span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">roots</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Reading the above, I don't think I quite get the argument against having a multiset sum notation. Is there some issue that I'm going to fall into here if I would write my theorem like (a set summation notation version of) this?</p>",
        "id": 536321735,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1756247909
    },
    {
        "content": "<p>For context, this is a step in the proof of <a href=\"https://en.wikipedia.org/wiki/Gauss%E2%80%93Lucas_theorem\">the Gauss-Lucas theorem</a>.</p>",
        "id": 536321857,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1756247983
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/sum.20over.20multiset/near/536199141\">said</a>:</p>\n<blockquote>\n<p>I personally think all we gain with this multiset sum notation is a footgun to shoot ourselves with</p>\n</blockquote>\n<p>It sounds like you're also claiming that <code>Multiset</code> itself is a footgun? I'm still not convinced here, I think the only hazard is \"Multiset and Finset behave differently\", which is... what you'd expect?</p>",
        "id": 536497165,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756329284
    },
    {
        "content": "<p>If you want to duplicate (rather than replace) an element in the finite sum, then the Multiset version is <em>easier</em> to work with than the Finset one.</p>",
        "id": 536497250,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756329322
    },
    {
        "content": "<p>Not worrying perhaps about it being the best way, what is <em>a</em> way to take a sum over a multiset? By random happenstance I saw this thread at precisely when I need to do this for the first time :)</p>",
        "id": 536514525,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1756342060
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.sum#doc\">docs#Multiset.sum</a></p>",
        "id": 536515552,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756342843
    },
    {
        "content": "<p>One can also use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.toFinsupp#doc\">docs#Multiset.toFinsupp</a> with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.sum#doc\">docs#Finsupp.sum</a> to get access to the counts when summing</p>",
        "id": 536517941,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1756345211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/sum.20over.20multiset/near/536497165\">said</a>:</p>\n<blockquote>\n<p>It sounds like you're also claiming that <code>Multiset</code> itself is a footgun?</p>\n</blockquote>\n<p>I am claiming that the pair <code>m : Multiset Œπ</code> + <code>f : Œπ ‚Üí Œ±</code> is a footgun, and should be replaced by <code>s : Finset Œπ</code> + <code>f : Œπ ‚Üí Œ±</code></p>",
        "id": 536533059,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1756358730
    },
    {
        "content": "<p>either that or use <code>m.map f : Multiset Œ±</code>, probably</p>",
        "id": 536590965,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1756382722
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/sum.20over.20multiset/near/536517941\">said</a>:</p>\n<blockquote>\n<p>One can also use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.toFinsupp#doc\">docs#Multiset.toFinsupp</a> with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.sum#doc\">docs#Finsupp.sum</a> to get access to the counts when summing</p>\n</blockquote>\n<p>This seems like a good idea. Question though: if I convert to Finsupp can I write my sum with indexed summation notation? I need to establish some inequalities for the sum of my multiset.</p>",
        "id": 536653480,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1756401875
    },
    {
        "content": "<p>One odd solution here is to use the Multiset's CoeSort instance.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>Inside the sum, <code>x</code> is a pair consisting of an element of <code>Œ±</code> and a unique value that distinguishes it if there's multiplicity. I think this somewhat addresses the issue that <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> mentioned.</p>\n<p>A version that avoids dependent types is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">toEnumFinset</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n</code></pre></div>\n<p>Its benefit is that <code>x</code> is of type <code>Œ± √ó ‚Ñï</code> (independent of <code>s</code>) rather than <code>Multiset.ToType s</code> (which is <code>(x : Œ±) √ó Fin (s.count x)</code>, so there's also a second dependence in this second field).</p>",
        "id": 536659281,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756404149
    }
]