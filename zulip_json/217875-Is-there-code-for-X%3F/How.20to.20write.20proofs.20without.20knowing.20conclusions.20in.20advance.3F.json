[
    {
        "content": "<p>In informal proofs there is a proof style that looks something like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Assume</span> <span class=\"n\">that</span> <span class=\"n\">proposition</span> <span class=\"n\">P</span> <span class=\"n\">is</span> <span class=\"n\">true.</span>\n<span class=\"o\">(</span><span class=\"n\">run</span> <span class=\"n\">a</span> <span class=\"n\">complicated</span> <span class=\"n\">argument</span> <span class=\"n\">using</span> <span class=\"n\">P</span> <span class=\"n\">as</span> <span class=\"n\">a</span> <span class=\"n\">hypothesis</span><span class=\"o\">)</span>\n<span class=\"n\">We</span> <span class=\"n\">conclude</span> <span class=\"n\">that</span> <span class=\"n\">complicated_conclusion_Q</span> <span class=\"n\">is</span> <span class=\"n\">true.</span>\n<span class=\"n\">To</span> <span class=\"n\">summarize</span><span class=\"o\">,</span> <span class=\"n\">we</span> <span class=\"k\">have</span> <span class=\"n\">shown</span> <span class=\"n\">that</span> <span class=\"n\">P</span> <span class=\"n\">implies</span> <span class=\"n\">complicated_conclusion_Q.</span>\n<span class=\"o\">(</span><span class=\"n\">continue</span> <span class=\"n\">the</span> <span class=\"n\">argument</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>In many cases, it is not immediately clear in advance what <code>complicated_conclusion_Q</code> will be; it is something that comes out of the complicated argument.</p>\n<p>One way to formalize this sort of thing in Lean is to do something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">\\</span><span class=\"n\">imp</span> <span class=\"n\">complicated_conclusion_Q</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n  <span class=\"c1\">-- apply a complicated argument</span>\n<span class=\"c1\">-- continue the argument</span>\n</code></pre></div>\n<p>but this requires one to know what <code>complicated_conclusion_Q</code> is in advance, or at least to go back and state it early in the proof.</p>\n<p>Is there a style of writing in Lean that more closely resembles the informal style mentioned above?  Something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">assume</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n      <span class=\"c1\">-- this introduces hp : P as a hypothesis, and creates a new goal that is something like `_ assuming hp`</span>\n      <span class=\"c1\">-- run a complicated argument that produces a conclusion hc : complicated_conclusion_Q</span>\n     <span class=\"n\">conclude</span> <span class=\"n\">hc</span> <span class=\"c1\">-- this closes the assumption goal and inserts a new hypothesis hc : P \\imp complicated_conclusion_Q</span>\n  <span class=\"c1\">-- continuation of the argument</span>\n</code></pre></div>\n<p>although this proposal would presumably require a major reworking of how Lean manages goals and is not feasible.  But is there some other Lean-compatible syntax  that could achieve something like this?</p>",
        "id": 397754840,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697824719
    },
    {
        "content": "<p>The closest thing I can think of is that you can write a have statement with a named metavariable for your <code>Q</code><br>\nfor example </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">50</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">10</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"bp\">?</span><span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"c1\">-- complicated argument that proves something that will become Q</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">5</span> <span class=\"bp\">≤</span> <span class=\"mi\">10</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this.trans_lt</span> <span class=\"n\">h</span>\n  <span class=\"c1\">-- now I have 10 &lt; x → 5 &lt; x in context without having spelt out ahead of time what I was proving</span>\n</code></pre></div>\n<p>It still requires some knowing in advance what sort of structure you have, and isn't particularly reminiscent of the stream of conciousness style you are after, but if the statement of <code>Q</code> is annoying enough it may be a solution.</p>",
        "id": 397756133,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1697825401
    },
    {
        "content": "<p>The biggest issue with this is that without a goal, many tactics won't work very well or at all (e.g., <code>apply</code> and <code>refine</code> are useless). However, one place where this is certainly relevant is in calculations, and with those it would be extremely simple to support this framework. Note, that there isn't really a need for named metavariables necessarily. The reason this works is that in a <code>calc</code> proof, you are incrementally providing the new goals to Lean, so it never has to guess. For an oversimplified toy example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">key₁</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"k\">calc</span>\n    <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span>     <span class=\"o\">:=</span> <span class=\"n\">mul_nonneg</span> <span class=\"n\">hx</span> <span class=\"n\">hx</span>\n    <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sq</span><span class=\"o\">]</span>\n    <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">gcongr</span><span class=\"bp\">;</span> <span class=\"n\">norm_num</span>\n  <span class=\"k\">have</span> <span class=\"n\">key₂</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">0</span> <span class=\"bp\">↦</span> <span class=\"k\">calc</span>\n    <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span>     <span class=\"o\">:=</span> <span class=\"n\">mul_nonneg_of_nonpos_of_nonpos</span> <span class=\"n\">hx</span> <span class=\"n\">hx</span>\n    <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sq</span><span class=\"o\">]</span>\n    <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">gcongr</span><span class=\"bp\">;</span> <span class=\"n\">norm_num</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">key₁</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">exact</span> <span class=\"n\">key₂</span> <span class=\"n\">h.le</span>\n</code></pre></div>\n<p>In these <code>calc</code> proofs above, you can just keep adding lines, and the type of the established <code>key₁</code> or <code>key₂</code> is updated accordingly (although of course that would break the remainder of the proof I have provided, but that's irrelevant).</p>",
        "id": 397759458,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697827121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/How.20to.20write.20proofs.20without.20knowing.20conclusions.20in.20advance.3F/near/397756133\">said</a>:</p>\n<blockquote>\n<p>The closest thing I can think of is that you can write a have statement with a named metavariable for your <code>Q</code><br>\nfor example </p>\n</blockquote>\n<p>Thanks, this basically does what I wanted!  in general, the syntax would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">hPQ</span><span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span>  <span class=\"bp\">?</span><span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hP</span>\n  <span class=\"c1\">-- run a complicated argument to conclude a conclusion hQ : Q</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hQ</span>\n</code></pre></div>\n<p>and this will add a hypothesis <code>hPQ: P →  Q</code> without having to ever write down <code>Q</code> explicitly.  The only additional thing perhaps is to add some syntactic sugar to replace the first two lines <code>have hPQ: P →  ?Q := by</code> and <code>intro hP</code> by something shorter such as <code>suppose P</code> (given that <code>assume</code> is already taken), but otherwise this feels like a satisfactory solution.</p>",
        "id": 397766288,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697830686
    },
    {
        "content": "<p>There is also the variant</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- run a complicated argument to conclude a conclusion hQ : Q</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hQ</span>\n</code></pre></div>\n<p>where one starts a stream-of-consciousness argument, perhaps not knowing in advance exactly where one will end up, until one reaches a satisfactory conclusion and declares victory, producing a new hypothesis h:Q as a result. (The point being that any intermediate facts produced in the course of establishing hQ pass out of scope when closing the <code>have h</code> block, so that the tactic state is conceptually cleaner.)</p>",
        "id": 397767262,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697831148
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/How.20to.20write.20proofs.20without.20knowing.20conclusions.20in.20advance.3F/near/397759458\">said</a>:</p>\n<blockquote>\n<p>The biggest issue with this is that without a goal, many tactics won't work very well or at all (e.g., <code>apply</code> and <code>refine</code> are useless).</p>\n</blockquote>\n<p>I think a closely related issue, if not actually the same issue, is that the tactic language definitely has a preference for backward reasoning over forward reasoning. Maybe it's worth thinking through what tactics do work purely on hypotheses:</p>\n<ul>\n<li><code>rw [...] at h</code></li>\n<li>normalization tactics like <code>ring_nf at h</code>, <code>norm_num at h</code>, <code>norm_cast at h</code>, ...</li>\n<li><code>have := congr(1 + $h1 + $h2 * $h3)</code></li>\n<li>specialize, obtain/rcases, ...</li>\n</ul>",
        "id": 397767751,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697831396
    },
    {
        "content": "<p>There are other forward-reasoning tactics which you could imagine existing:</p>\n<ul>\n<li><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> weren't you working on a \"factor\" tactic?</li>\n<li>for teaching I have a hacky \"cancel\" tactic which e.g. simplifies a hypothesis <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mo stretchy=\"false\">)</mo><mi>a</mi><mo>&lt;</mo><mo stretchy=\"false\">(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mo stretchy=\"false\">)</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">(x ^ 2 + 3)a&lt;(x^2+3)b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">3</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">3</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">b</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a&lt;b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></li>\n</ul>",
        "id": 397768373,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697831740
    },
    {
        "content": "<ul>\n<li><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> has proposed an \"isolate x\" tactic which takes an equation whose LHS is a complicated expression involving x and reorganizes it so that x is alone on the LHS</li>\n</ul>",
        "id": 397770788,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1697832970
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> just wrote <code>apply ... at h</code>, but it hasn't been merged yet: <a href=\"https://github.com/leanprover-community/mathlib4/pull/7527\">#7527</a></p>",
        "id": 397770877,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697833031
    },
    {
        "content": "<p>One can always combine the first two lines <code>have</code> and <code>intro</code> into one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">key_step</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.lt_one_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hP</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hP</span>\n  <span class=\"n\">tauto</span>\n</code></pre></div>",
        "id": 397775359,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1697835499
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/How.20to.20write.20proofs.20without.20knowing.20conclusions.20in.20advance.3F/near/397767751\">said</a>:</p>\n<blockquote>\n<p>I think a closely related issue, if not actually the same issue, is that the tactic language definitely has a preference for backward reasoning over forward reasoning. Maybe it's worth thinking through what tactics do work purely on hypotheses:</p>\n</blockquote>\n<p>A preference is fine, so long as contrary preferences are <em>supported</em> by the software, with only mild aesthetic and logistical costs.  But it seems Lean4 is in fact expressive enough to support forward reasoning as well as backwards (or various combinations of the two); it's just that the tools for doing so are not as well documented or developed always.</p>",
        "id": 397781882,
        "sender_full_name": "Terence Tao",
        "timestamp": 1697839799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/How.20to.20write.20proofs.20without.20knowing.20conclusions.20in.20advance.3F/near/397768373\">said</a>:</p>\n<blockquote>\n<ul>\n<li><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> weren't you working on a \"factor\" tactic?</li>\n</ul>\n</blockquote>\n<p>Yes I think there is a lot of potential for \"put this element in a form with X property\" tactics, I just got a bit interrupted by the Lean 4 switch but hope to get back to them, one could imagine e.g. factoring polynomials, some matrix decompositions / normal forms, sums of squares for proving positivity etc.  etc. One thing that one also needs doing for most proofs using these forms though is also introducing the properties they have, there is no point factoring polynomials if there is no good way to prove those factors irreducible. This seems to require some more domain specific thought to find and verify good certificates of such properties though.</p>",
        "id": 397782407,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1697840133
    },
    {
        "content": "<p>If you work on sos then you should coordinate with Rob who may have a student working on this.</p>",
        "id": 397782941,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1697840452
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/How.20to.20write.20proofs.20without.20knowing.20conclusions.20in.20advance.3F/near/397782407\">said</a>:</p>\n<blockquote>\n<p>One thing that one also needs doing for most proofs using these forms though is also introducing the properties they have, there is no point factoring polynomials if there is no good way to prove those factors irreducible. </p>\n</blockquote>\n<p>Automatically factoring expressions can be very useful even if you don't have the proof that the factors are irreducible. For example, for proving  (in)equalities. A toy example could be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span>  <span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"mi\">0</span> <span class=\"bp\">≤</span>  <span class=\"mi\">16</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"mi\">48</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">^</span> <span class=\"mi\">3</span> <span class=\"bp\">+</span> <span class=\"mi\">36</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">^</span> <span class=\"mi\">4</span> <span class=\"bp\">+</span> <span class=\"mi\">8</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"mi\">12</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">^</span> <span class=\"mi\">3</span>  <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">factor</span>\n  <span class=\"c1\">-- goal becomes  0 ≤ (6 * c ^ 2 - 4 * a * c - c) ^ 2</span>\n  <span class=\"n\">apply</span> <span class=\"n\">sq_nonneg</span>\n</code></pre></div>",
        "id": 399051934,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1698500299
    },
    {
        "content": "<p>I suspect that the least painful way to make this kind of tactic is to go down the <code>polyrith</code> route -- farm the polynomial out to SageMath, ask it nicely to factor it, and then check its answer using <code>ring</code>. <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> or <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> -- how easy is such a tactic to write, given that we must already have a bunch of machinery needed to make the bridge?</p>",
        "id": 399054080,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698501811
    },
    {
        "content": "<p>The polyrith route isn't ideal because it isn't something we can actually commit to mathlib (as it needs a network connection)</p>",
        "id": 399054377,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698502068
    },
    {
        "content": "<p>I mean \"write a new tactic like polyrith which factors stuff\". That should be OK, right?</p>",
        "id": 399055505,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698502892
    },
    {
        "content": "<p>Yes, that ought to be very doable</p>",
        "id": 399056248,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698503399
    },
    {
        "content": "<p>Probably it would make sense to adapt the existing polyrith infrastructure rather than try to write a new copy from scratch</p>",
        "id": 399056327,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698503437
    },
    {
        "content": "<p>Maybe some partial factorizations  can be done inside Lean without too much pain. For example, the squarefree factorization for univariate polynomials requires only to compute derivatives and extended euclidean algorithm. For the multivariate case, you have to reduce to one variable and then do Hensel lifting (which basically involves linear algebra).</p>\n<p>If you want to go farther, you have to reduce modulo a prime, factor there and then do Hensel lifting again and rational reconstruction. That can be a bit tricky.</p>\n<p>Another option would be to use a local installation of Sage (or your favourite CAS).</p>",
        "id": 399057677,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1698504402
    },
    {
        "content": "<p>yeah you could definitely do some stuff in Lean, but I imagine it would be quite a challenging project. I suspect that the \"use the internet\" approach would be much easier in practice (but attach a low significance to my imagining because I know essentially nothing about writing tactics).</p>",
        "id": 399059073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698505342
    },
    {
        "content": "<p>One has to look at the practicalities here, and basically when am I using Lean and not connected to the internet? \"between stations on the Picadilly line\" was the answer to this a year or two ago, but now they're talking about WiFi between stations so even that won't be happening soon.</p>",
        "id": 399059216,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698505425
    }
]