[
    {
        "content": "<p>Is there any extensional finite map that I can use in an inductive definition?</p>",
        "id": 565086993,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1766451690
    },
    {
        "content": "<p>i.e. <code>gmap</code> from Rocq stdpp.</p>",
        "id": 565087043,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1766451735
    },
    {
        "content": "<p>Is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Data/ExtTreeMap/Basic.html#Std.ExtTreeMap\">Std.ExtTreeMap</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Data/ExtHashMap/Basic.html#Std.ExtHashMap\">Std.ExtHashMap</a> what you need?<br>\nThere's <a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Data/ExtTreeMap/Lemmas.html#Std.ExtTreeMap.ext_getElem?\">Std.ExtTreeMap.ext_getElem?</a> and analogous for hash map.</p>",
        "id": 565089992,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766455315
    },
    {
        "content": "<p>Let me forward the message here.<br>\n<span class=\"user-mention silent\" data-user-id=\"939203\">Ka Wing Li</span> <a href=\"#narrow/channel/490604-iris-lean/topic/stdpp/near/565085805\">said</a>:</p>\n<blockquote>\n<p>I tried the following but get error \"application type mismatch\"</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">vl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">vl</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtTreeMap</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">vl</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">vl</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 565090074,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1766455405
    },
    {
        "content": "<p>It seems <code>Ext(D)TreeMap</code> and <code>Ext(D)HashMap</code> cannot be used inside inductive definition.</p>",
        "id": 565090152,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1766455493
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Data/DTreeMap/Raw/Basic.html#Std.DTreeMap.Raw\">Std.DTreeMap.Raw</a></p>",
        "id": 565090293,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766455645
    },
    {
        "content": "<p>Yes, they cannot, you need Raw.</p>",
        "id": 565090309,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766455658
    },
    {
        "content": "<p>But it is not extensional.</p>",
        "id": 565090334,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1766455695
    },
    {
        "content": "<p>Hm, you're right.</p>",
        "id": 565090386,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766455751
    },
    {
        "content": "<p>It would be much easier if you included what you already know in your question. :)</p>",
        "id": 565090417,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766455805
    },
    {
        "content": "<p>See <a href=\"https://plv.mpi-sws.org/coqdoc/stdpp/stdpp.gmap.html\">stdpp gmap</a> desciption:</p>\n<ul>\n<li>It guarantees logarithmic-time <a href=\"https://plv.mpi-sws.org/coqdoc/stdpp/stdpp.base.html#lookup\">lookup</a> and <a href=\"https://plv.mpi-sws.org/coqdoc/stdpp/stdpp.base.html#partial_alter\">partial_alter</a>, and linear-time <a href=\"https://plv.mpi-sws.org/coqdoc/stdpp/stdpp.fin_maps.html#theorems.merge\">merge</a>. It has a low constant factor for computation in Coq compared to other versions (see the Appel and Leroy paper for benchmarks).</li>\n<li>It satisfies <strong><em>extensional equality</em></strong> (∀ i, m1 !! i = m2 !! i) → m1 = m2.</li>\n<li>It can be used in <strong><em>nested recursive definitions</em></strong>, e.g., Inductive test := Test : <a href=\"https://plv.mpi-sws.org/coqdoc/stdpp/stdpp.gmap.html#gmap\">gmap</a> test → test. This is possible because we do <em>not</em> use a Sigma type to ensure canonical representations (a Sigma type would break Coq's strict positivity check).</li>\n</ul>",
        "id": 565090487,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1766455867
    },
    {
        "content": "<blockquote>\n<p>It would be much easier if you included what you already know in your question. :)</p>\n</blockquote>\n<p>Sorry, it's my fault that I thought mentioning both \"extensional\" and \"inductive definitions\", as well as ExtDTreeMap in another channel, is sufficient.</p>",
        "id": 565090616,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1766455991
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"939203\">Ka Wing Li</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/extensional.20finite.20map.20inside.20inductive.20definition/near/565090616\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>It would be much easier if you included what you already know in your question. :)</p>\n</blockquote>\n<p>Sorry, it's my fault that I thought mentioning both \"extensional\" and \"inductive definitions\", as well as ExtDTreeMap in another channel, is sufficient.</p>\n</blockquote>\n<p>I think it's ok, but I haven't seen your other message in another topic. And it's my bad for not noticing that the Raw version in not extensional.</p>",
        "id": 565091435,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766456872
    },
    {
        "content": "<p>Unrelated to the question, but HOAS might of interest to you. It lets you represent dsl abstraction using lean's native abstraction. <a href=\"https://lean-lang.org/examples/1900-1-1-parametric-higherorder-abstract-syntax/\">https://lean-lang.org/examples/1900-1-1-parametric-higherorder-abstract-syntax/</a></p>",
        "id": 565092575,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766458302
    },
    {
        "content": "<p>Do you need both extensionability and logarithmic operations though? You can use a type that is not extensionable for programming, and the extensionable model of it in proofs. Though, even without that requirement I couldn't find an implementation of key-value store that is both extensionable and can be used in inductives.</p>",
        "id": 565100093,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766467210
    },
    {
        "content": "<p>You could write the below code. But that makes <code>vl</code> type harder to use and it's overly complicated. I think that we should have extensional key-value store usable in inductives. I don't think it's necessary for it to have logarithmic operations, but it would be useful to have.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">vl'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">vl'</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"bp\">.</span><span class=\"n\">Raw</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">vl'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">vl'</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">vl'</span><span class=\"bp\">.</span><span class=\"n\">isSetoid</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">vl'</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">r</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"n\">ctx'</span><span class=\"w\"> </span><span class=\"n\">t'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"bp\">.</span><span class=\"n\">Equiv</span><span class=\"w\"> </span><span class=\"n\">ctx'</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">t'</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v'</span>\n\n<span class=\"w\">  </span><span class=\"n\">iseqv</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">iseqv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"bp\">.</span><span class=\"n\">Raw</span><span class=\"bp\">.</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">comm</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp_all</span>\n<span class=\"w\">  </span><span class=\"n\">iseqv</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">vl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"n\">vl'</span><span class=\"bp\">.</span><span class=\"n\">isSetoid</span>\n</code></pre></div>",
        "id": 565122842,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766481519
    },
    {
        "content": "<p>Interesting, stdpp tries their best to avoid the need of setoid. I faced a little difficulty in proving transitivity, but figured it out anyway.</p>",
        "id": 565304606,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1766597962
    },
    {
        "content": "<p>logarithmic is preferable if possible as it was used for functional big step as in CakeML. Yet for proving metatheory it is still ok.</p>",
        "id": 565304747,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1766598078
    },
    {
        "content": "<p>Being extensional is beneficial for rewrite, like idempotent of insert and commuting fmap and insert.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">tmp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">cmp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">LawfulCmp</span><span class=\"w\"> </span><span class=\"n\">cmp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtTreeMap</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">cmp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>",
        "id": 565307837,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1766600603
    },
    {
        "content": "<p>Non-logarithmic should be I think not too hard by using <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/List/AList.html#AList\">AList</a> with additional assumption that the list is sorted.</p>",
        "id": 565318367,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766610486
    }
]