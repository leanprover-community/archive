[
    {
        "content": "<p>I'm learning about the Peano Axioms and I wanted to see if I could create a version of them in Lean. I know you can also do it using inductive but how would I define the natural numbers like this?<br>\n<a href=\"/user_uploads/3121/4pLBDBPxq5iIHip0xHBna04U/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/4pLBDBPxq5iIHip0xHBna04U/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/4pLBDBPxq5iIHip0xHBna04U/image.png\"></a></div>",
        "id": 396267536,
        "sender_full_name": "shortc1rcuit",
        "timestamp": 1697109561
    },
    {
        "content": "<p>In Lean, the natural numbers are defined like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n</code></pre></div>\n<p>Then axioms 1/2/3 are true almost by construction, and 4 can be shown by induction (<code>induction</code> tactic).</p>\n<p>(Note that the Peano axioms are not a definition of <code>ℕ</code>: these are axioms)</p>",
        "id": 396283563,
        "sender_full_name": "Joël Riou",
        "timestamp": 1697115749
    },
    {
        "content": "<p>Joel, they're asking if it's possible to define them from the axioms - they seem to understand that it is possible with an inductive type already.</p>",
        "id": 396283703,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1697115810
    },
    {
        "content": "<p>(I have added a note accordingly.)</p>",
        "id": 396284092,
        "sender_full_name": "Joël Riou",
        "timestamp": 1697115946
    },
    {
        "content": "<p>It is certainly possible to formulate that a Type <code>N</code> equipped with <code>0 : N</code> and <code>succ : N → N</code> satisfy the Peano axioms. We know that Lean's  <code>Nat</code> (ie. <code>ℕ</code>) satisfy these. Then, the interesting question is, can you show that there is a bijection <code>ℕ ≃ N</code> that is compatible with the zero and the successor?</p>",
        "id": 396287187,
        "sender_full_name": "Joël Riou",
        "timestamp": 1697117004
    },
    {
        "content": "<p>Defining them via axioms would not be idiomatic Lean (in mathlib there are no axioms at all), but there's nothing stopping you writing down <code>constant N : Type</code>, <code>constant one : N</code> , <code>axiom ind : \\forall S : Set N...</code> etc.</p>",
        "id": 396306895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697122844
    },
    {
        "content": "<p>You could also do something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">IsPeanoNat</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Zero</span> <span class=\"n\">X</span> <span class=\"n\">where</span>\n  <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n  <span class=\"n\">succ_inj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">},</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n  <span class=\"n\">succ_ne_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span>\n  <span class=\"n\">induction</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">zero</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 396308888,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1697123432
    },
    {
        "content": "<p>s/zero/one</p>",
        "id": 396311569,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697124130
    },
    {
        "content": "<p>(the source seems to be using the British Natural Numbers)</p>",
        "id": 396311724,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697124169
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Axiomatic.20definition.20of.20the.20natural.20numbers/near/396308888\">said</a>:</p>\n<blockquote>\n<p>You could also do something like this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">IsPeanoNat</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Zero</span> <span class=\"n\">X</span> <span class=\"n\">where</span>\n  <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n  <span class=\"n\">succ_inj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">},</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n  <span class=\"n\">succ_ne_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span>\n  <span class=\"n\">induction</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">zero</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">x</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Yeah I was thinking of using something like that but then it might get difficult later on when I'm trying to contruct the integers from the naturals</p>",
        "id": 396314220,
        "sender_full_name": "shortc1rcuit",
        "timestamp": 1697124837
    },
    {
        "content": "<p>Your principle of recursion wouldn't be computable but I don't see why it would be hard to define the integers.</p>",
        "id": 396316265,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697125449
    },
    {
        "content": "<p>That might just be a case of me not knowing enough about Lean</p>",
        "id": 396316738,
        "sender_full_name": "shortc1rcuit",
        "timestamp": 1697125592
    },
    {
        "content": "<p>It depends on how you want to define the type of integers <code>ℤ</code>. In Lean/mathlib it is defined in a quite interesting way: an element of <code>ℤ</code> is either \"+n\" for some <code>n : ℕ</code> or \"-(1+n)\" for some <code>n : ℕ</code>. You could certainly do the same using the <code>IsPeanoNat X</code> definition.</p>\n<p>However, if you want to define <code>ℤ</code> as equivalence classes of formal differences \"x - y\" with <code>x</code> and <code>y</code> in <code>X</code>, you need to know a few things about the addition on <code>X</code>. For that: you would obviously need to have a definition of the addition on <code>X</code>. In Lean, it is easy to define the addition <code>ℕ → ℕ → ℕ</code> using a native Lean inductive definition, but it is not clear to me how we would define the addition <code>X → X → X</code> using only <code>[IsPeanoNat X]</code>.</p>",
        "id": 396326595,
        "sender_full_name": "Joël Riou",
        "timestamp": 1697128846
    },
    {
        "content": "<p>It seems like the induction (or \"recursion\") field needs to support eliminating into Sort*</p>",
        "id": 396331958,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1697130812
    },
    {
        "content": "<p>or <code>IsPeanoNat</code> could include a field for an addition function and some axioms describing it</p>",
        "id": 396358449,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1697141951
    },
    {
        "content": "<p>including a recursion principle which could be used to construct data would look something like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsPeanoNat</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Zero</span> <span class=\"n\">X</span> <span class=\"n\">where</span>\n  <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n  <span class=\"n\">succ_inj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">},</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n  <span class=\"n\">succ_ne_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">zero</span>\n  <span class=\"n\">recursion</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">zero</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">x</span>\n  <span class=\"n\">rec_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">x</span><span class=\"o\">)),</span> <span class=\"n\">recursion</span> <span class=\"n\">zero</span> <span class=\"n\">z</span> <span class=\"n\">step</span> <span class=\"bp\">=</span> <span class=\"n\">z</span>\n  <span class=\"n\">rec_succ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">x</span><span class=\"o\">)),</span> <span class=\"n\">recursion</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"n\">step</span> <span class=\"bp\">=</span> <span class=\"n\">step</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">recursion</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"n\">step</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but I think this runs into universe issues because the universe you can eliminate into, <code>v</code>, is fixed for a given <code>IsPeanoNat</code> instance</p>",
        "id": 396361348,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1697143254
    },
    {
        "content": "<p>With the prop version you can construct a bijection from the usual Nat to X and use that to define a general recursion principle</p>",
        "id": 396361443,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1697143309
    },
    {
        "content": "<p>Yes, but it would be noncomputable (not that this would matter) because to get the map from X to N+ you need to invert a bijection.</p>",
        "id": 396362284,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697143733
    },
    {
        "content": "<p>I suppose if you just want Peano Arithmetic, you only need to be able to use recursion to define natural number-valued functions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">IsPeanoNat</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Zero</span> <span class=\"n\">X</span> <span class=\"n\">where</span>\n  <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n  <span class=\"n\">succ_inj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">},</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n  <span class=\"n\">succ_ne_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n  <span class=\"n\">induction</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">x</span>\n  <span class=\"n\">recursion</span> <span class=\"o\">(</span><span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n  <span class=\"n\">rec_zero</span> <span class=\"o\">(</span><span class=\"n\">base</span> <span class=\"n\">step</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">recursion</span> <span class=\"n\">base</span> <span class=\"n\">step</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">base</span>\n  <span class=\"n\">rec_succ</span> <span class=\"o\">(</span><span class=\"n\">base</span> <span class=\"n\">step</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">recursion</span> <span class=\"n\">base</span> <span class=\"n\">step</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">step</span> <span class=\"o\">(</span><span class=\"n\">recursion</span> <span class=\"n\">base</span> <span class=\"n\">step</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 396365674,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1697145371
    },
    {
        "content": "<p>If you want a computable recursor you can just eliminate into Type. That will let you define a computable equivalence with Nat, and you can get the general thing using that.</p>",
        "id": 396370378,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1697147939
    },
    {
        "content": "<p>And if you allow the full recursor that lean's nat has them you don't need succ_inj and succ_ne_zero, you can prove them using pred and is_zero</p>",
        "id": 396370605,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697148068
    },
    {
        "content": "<p>Wouldn't this be actually too strong because <code>motive</code> can involve arbitrarily high order expressions instead of being restricted to first order predicates?</p>",
        "id": 396455713,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1697185805
    },
    {
        "content": "<p>This is a very unidiomatic way to define the natural numbers in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">N</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">N</span> <span class=\"mi\">1</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"n\">one</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">one_ne_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≠</span> <span class=\"n\">succ</span> <span class=\"n\">n</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">succ_inj</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">induction</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">N</span>\n</code></pre></div>\n<p>Correction: <code>S = N</code> in the axiom <code>induction</code> should be <code>S = ⊤</code>, where <code>⊤</code> is <code>@Set.univ (Set N)</code>.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Corrected axioms</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">N</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">N</span> <span class=\"mi\">1</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"n\">one</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">one_ne_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≠</span> <span class=\"n\">succ</span> <span class=\"n\">n</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">succ_inj</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">induction</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span>\n</code></pre></div>\n</div></div>",
        "id": 396507999,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1697204362
    },
    {
        "content": "<p>So far I've done this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsPeanoNat</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n  <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">N</span>\n  <span class=\"n\">one_ne_succ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">one</span>\n  <span class=\"n\">succ_inj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n  <span class=\"n\">induction</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">one</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">N</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prop_induction</span> <span class=\"o\">[</span><span class=\"n\">IsPeanoNat</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_one</span><span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">one</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_succ</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">k</span> <span class=\"bp\">⇒</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">k</span><span class=\"o\">)):</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But h_succ seems to be incorrect in some way.<br>\n<a href=\"/user_uploads/3121/b5jPA-rSpO1gGYH30sIlQ5FI/image.png\">image.png</a><br>\nWhat am I doing wrong?</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/b5jPA-rSpO1gGYH30sIlQ5FI/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/b5jPA-rSpO1gGYH30sIlQ5FI/image.png\"></a></div>",
        "id": 396577399,
        "sender_full_name": "shortc1rcuit",
        "timestamp": 1697235162
    },
    {
        "content": "<p>Your induction field shouldn’t type check</p>",
        "id": 396577466,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1697235210
    },
    {
        "content": "<p>Lean for \"implies\" is <code>\\to</code> not (whatever symbol you have used there). And you need to <code>open IsPeanoNat</code> to ensure that <code>succ</code> means the <code>succ</code> in your class.</p>",
        "id": 396577773,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697235373
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsPeanoNat</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n  <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">N</span>\n  <span class=\"n\">one_ne_succ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">one</span>\n  <span class=\"n\">succ_inj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n  <span class=\"n\">induction</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">one</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">N</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">IsPeanoNat</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prop_induction</span> <span class=\"o\">[</span><span class=\"n\">IsPeanoNat</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_one</span><span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">one</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h_succ</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">k</span><span class=\"o\">)):</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 396577811,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697235402
    },
    {
        "content": "<p>Oh and <code>S = N</code> is not correct (I think this is what Adam was getting at). Equality of types is not a thing. You mean <code>S = ⊤</code>, the \"top subset of N\". <code>S</code> is a subset, not a type itself.</p>",
        "id": 396577996,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697235537
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsPeanoNat</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n  <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">N</span>\n  <span class=\"n\">one_ne_succ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">one</span>\n  <span class=\"n\">succ_inj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n  <span class=\"n\">induction</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">one</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">IsPeanoNat</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">prop_induction</span> <span class=\"o\">[</span><span class=\"n\">IsPeanoNat</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_one</span><span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">one</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h_succ</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">k</span><span class=\"o\">)):</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>my solution</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">intro</span> <span class=\"n\">n</span>\n  <span class=\"n\">change</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">induction</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"n\">h_one</span> <span class=\"n\">h_succ</span><span class=\"o\">]</span>\n  <span class=\"n\">trivial</span>\n</code></pre></div>\n</div></div>",
        "id": 396578612,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697236012
    },
    {
        "content": "<p>Cool.<br>\nNow to somehow define addition.<br>\nI'm assuming just using inductive won't work.<br>\nIf there's a need for a proof that addition is defined for all inputs then I have one of those.</p>",
        "id": 396580141,
        "sender_full_name": "shortc1rcuit",
        "timestamp": 1697237348
    },
    {
        "content": "<p>Right, you have not got a recursion axiom so you will need to transport to a type with a recursion axiom like Lean's inductively defined nat. This is one of the reasons why what you're trying to do is so painful.</p>",
        "id": 396581182,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697238258
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsPeanoNat</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n  <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">N</span>\n  <span class=\"n\">one_ne_succ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">one</span>\n  <span class=\"n\">succ_inj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n  <span class=\"n\">induction</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">one</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">IsPeanoNat</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">IsPeanoNat</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ofNat</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">one</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ofNat_surjective</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">ofNat</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">induction</span> <span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"bp\">·</span> <span class=\"n\">use</span> <span class=\"mi\">0</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"n\">k</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"n\">use</span> <span class=\"n\">m.succ</span>\n    <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ofNat_surjective'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">ofNat</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">change</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">ofNat</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ofNat_surjective</span><span class=\"o\">]</span>\n  <span class=\"n\">trivial</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">toNat</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ofNat_surjective'</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"o\">:=</span> <span class=\"n\">ofNat</span> <span class=\"o\">(</span><span class=\"n\">toNat</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">toNat</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"c1\">-- + 1 because you started at 1</span>\n</code></pre></div>\n<p>Now it will be a pain proving anything about <code>add</code> -- first you'll have to prove ofNat is bijective and toNat is the two-sided inverse. But then all your theorems about <code>add</code> will just be immediately derivable from <code>Nat.add</code>. This is just an awful way to do it. If you want to do it this way you should at least give yourself recursion as an axiom, but even then you won't be able to benefit from Lean's inbuilt support for recursors for inductive types (e.g. what I used for the definition of ofNat).</p>",
        "id": 396582050,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697238990
    },
    {
        "content": "<p>Yeah I see your point.<br>\nI might just put in my document \"from now on we'll use the normal lean definition of Nat to simplify things\", and continue from there. I don't think I'll need anything else from the original rules.</p>",
        "id": 396641545,
        "sender_full_name": "shortc1rcuit",
        "timestamp": 1697281731
    }
]