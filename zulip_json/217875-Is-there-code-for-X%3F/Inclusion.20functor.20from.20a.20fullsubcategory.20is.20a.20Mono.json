[
    {
        "content": "<p>I would like to use the cancellation property of the inclusion functor to prove equalities of functors that go into a full subcategory. Surprisingly, I do not find any theorem in <br>\n<code>Mathlib.CategoryTheory.FullSubcategory</code> saying that the inclusion functor defined as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fullSubcategoryInclusion</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FullSubcategory</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">inducedFunctor</span><span class=\"w\"> </span><span class=\"n\">FullSubcategory</span><span class=\"bp\">.</span><span class=\"n\">obj</span>\n</code></pre></div>\n<p>is a mono. </p>\n<p>May I please ask if it is proven to be a mono somewhere?</p>",
        "id": 514041132,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745481668
    },
    {
        "content": "<p>I am aware that despite the absense of \"Mono\", there is something called \"FullyFaithful\" in that file. But as my goal is working with strict equality instead of equivalence, it seems not to be what I want because all I can get from <code>Mathlib.CategoryTheory.Functor.FullyFaithful</code> seems to be equivalence.</p>",
        "id": 514041807,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745481754
    },
    {
        "content": "<p>I am not yet familiar enough with this library so maybe I am wrong with this (in which case thanks for correcting me!) But I aim to find an approach to use the fact that the inclusion functor from a full subcategory is a mono to prove strict equalities between functors to a full subcategory. Are there any devices that I could try?</p>",
        "id": 514042736,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745481867
    },
    {
        "content": "<p>I believe that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.fullyFaithfulFullSubcategoryInclusion#doc\">docs#CategoryTheory.fullyFaithfulFullSubcategoryInclusion</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.fullyFaithfulCancelRight#doc\">docs#CategoryTheory.Functor.fullyFaithfulCancelRight</a> is the best that mathlib has to offer here. Mathlib doesn't really develop equality of functors, because it's almost never a good idea to work with equality of functors unless the equality is definitional. Equality of functors (or, more fundamentally, equality of objects in a category) quicky leads to problems in practice because of what is commonly known as \"DTT hell\".</p>",
        "id": 514044237,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1745482181
    },
    {
        "content": "<p>Thanks for the swift response!! I am searching for that precisely because I want to obtain equations between functors without the DTT hell, so I am trying to detour this. If I cannot do that, is there any hope that this equivalence is already connected to some theorems with eqToHom?</p>",
        "id": 514045031,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745482392
    },
    {
        "content": "<p>I think it would be easier to point you toward useful tools in mathlib if you shared a bit more code that shows what you're trying to achieve.</p>",
        "id": 514045441,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1745482503
    },
    {
        "content": "<p>Sure. Thank you! I will try to write in more detail what I am trying to do later today.</p>",
        "id": 514045675,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745482567
    },
    {
        "content": "<p>basically I am working on (this project)[https://github.com/sinhp/groupoid_model_in_lean4] which has 2-category stuff.</p>",
        "id": 514045788,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745482606
    },
    {
        "content": "<p>It would take quite a while to phrase the original question. So I am sketching the outline of the problem. I wonder if my case is the kind of stuff that witnesses the necessity of the \"almost\" in \"almost never a good idea\"... Please retort if someone has something to say.</p>\n<p>I have two ambient categories A1 and A2, and I have full subcategories S1 and S2 siting in A1 and A2, via inclusions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>:</mo><msub><mi>S</mi><mn>1</mn></msub><mo>→</mo><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1:S_1\\to A_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub><mo>:</mo><msub><mi>S</mi><mn>2</mn></msub><mo>→</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_2:S_2\\to A_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, respectively. I have two functors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>F</mi><mn>2</mn></msub><mo>:</mo><msub><mi>S</mi><mn>1</mn></msub><mo>⇒</mo><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">F_1,F_2:S_1\\Rightarrow S_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. My aim is to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><msub><mi>F</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">F_1= F_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>\n<p>There is something called Functor.ext, but I do not want to use it. I hope the following works:</p>\n<p>I prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>:</mo><msub><mi>i</mi><mn>2</mn></msub><mo>∘</mo><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><mi>F</mi><mo>:</mo><msub><mi>A</mi><mn>1</mn></msub><mo>⇒</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">e_1:i_2\\circ F_1 = F:A_1\\Rightarrow A_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and   <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msub><mi>i</mi><mn>2</mn></msub><mo>∘</mo><msub><mi>F</mi><mn>2</mn></msub><mo>=</mo><mi>F</mi><mo>:</mo><msub><mi>A</mi><mn>1</mn></msub><mo>⇒</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">e_2:i_2\\circ F_2 = F:A_1\\Rightarrow A_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> for some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>:</mo><msub><mi>A</mi><mn>1</mn></msub><mo>⇒</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">F:A_1\\Rightarrow A_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. (Specifically, the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">F_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> here I have is defined using <code>CategoryTheory.FullSubcategory.lift</code>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">F_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is a simpler description of it. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">F_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is just <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> for the domain and codomain restricted to full subcategories.) </p>\n<p>So I will have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub><mo>∘</mo><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><mo>:</mo><msub><mi>i</mi><mn>2</mn></msub><mo>∘</mo><msub><mi>F</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_2\\circ F_1 = :i_2\\circ F_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is monic, I can cancel the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> to obtain <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><msub><mi>F</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">F_1 = F_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, which I want.</p>",
        "id": 514058346,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745485227
    },
    {
        "content": "<p>To clarify, the picture looks like this:</p>",
        "id": 514058476,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745485264
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/uy023oewzENHfqCYnBdqGLzj/37d9da1a-cb6c-4262-9081-c3d05e712ce7.jpg\">37d9da1a-cb6c-4262-9081-c3d05e712ce7.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/uy023oewzENHfqCYnBdqGLzj/37d9da1a-cb6c-4262-9081-c3d05e712ce7.jpg\" title=\"37d9da1a-cb6c-4262-9081-c3d05e712ce7.jpg\"><img data-original-content-type=\"image/jpeg\" data-original-dimensions=\"1840x4096\" src=\"/user_uploads/thumbnail/3121/uy023oewzENHfqCYnBdqGLzj/37d9da1a-cb6c-4262-9081-c3d05e712ce7.jpg/840x560.webp\"></a></div>",
        "id": 514058521,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745485275
    },
    {
        "content": "<p>In the (very sad) case that mathlib really do not want me to do that, I would still prefer to prove something about <strong>functor</strong> being monic, and how is this connected to <code>eqToHom</code>, instead of calling Funtor.ext here. So please suggest something if there are some hints on this direction!</p>",
        "id": 514059193,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745485445
    },
    {
        "content": "<p>Why would you want to prove that two functors are equal though? This is an evil statement because it relies on the concept of equality of objects in a category, which is not preserved under equivalence of categories. Why don't you just write down a morphism between the functors and prove it's a natural isomorphism?</p>",
        "id": 514070050,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745487789
    },
    {
        "content": "<p>If I ask \"Why should we insist using natural isos instead of equalities\", I (naively) guess that the structuralisms would say \"because that is enough, categorical reasoning should not rely on equality\". But in practice, we are dealing with lots of strict pullbacks, I guess they are too many of them, and the natural isomorphims are not an interesting piece of information to keep record of along the proof. So, in my turn, I would ask \"if we can get a neat equation between functors to easily get things type checked, since it is doable in Lean, why should we still insist on using isos everywhere just because the philosophy?\" I am not claim that natural isos are impossible, but just my two cents, it is not clear that it deserves all the additional work. And as a user, I prefer to read thms with equalities, rather than have to pass through the isos explicitly even when reading a simple statement.</p>",
        "id": 514072863,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745488533
    },
    {
        "content": "<p>Disclaimer: I respect those who takes that piece of philosophy as belief and develop elegant proofs that avoid equalities once possible. But I disagree that pursing the convenience of equality between objects when working with a functor category id undesirable.</p>",
        "id": 514074481,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745488969
    },
    {
        "content": "<p>Equality in Lean's type theory is a very complicated thing. For example <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>=</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\N=\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> is an undecidable statement in Lean -- it can neither be proved nor disproved, and indeed there are models of Lean's type theory in which it's true, and models in which it's false. So if you want to stick with equality of functors (and hence equality of objects), be warned. It might be possible to get it working and if so, then great! But maybe what is really needed here is better tooling to deal with natural isomorphisms.</p>",
        "id": 514074525,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745488983
    },
    {
        "content": "<p>Thanks for the warning, makes sense! I would be excited if a well-developed flow of working with natural isomorphism appears one day. I think for \"working with equalities vs isos\", the answer should be \"intensional \" rather than \"extensional\" :-) , i.e., addressing \"in which manner\" rather than merely \"making a choice\". Even if we get natural isos to work well, if the isos themselves appear everywhere in every thm and every proof, I am afraid that it would be a pain. I am curious how things go in both of these two directions.</p>",
        "id": 514082804,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745490791
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776892\">Yiming Xu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Inclusion.20functor.20from.20a.20fullsubcategory.20is.20a.20Mono/near/514074481\">said</a>:</p>\n<blockquote>\n<p>Disclaimer: I respect those who takes that piece of philosophy as belief and develop elegant proofs that avoid equalities once possible. But I disagree that pursing the convenience of equality between objects when working with a functor category id undesirable.</p>\n</blockquote>\n<p>Experience shows that in most cases, things go much smoother using isomorphisms of functors (+ conditions satisfied by these isomorphisms) instead of equalities of functors. There are a few situations where we do need to use equalities of functors. For example, when studying the nerve of a category, when we say that two <code>n</code>-simplices are equal, we actually mean that two functors are equal (and for this, we have some lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/ComposableArrows.html#CategoryTheory.ComposableArrows.ext%E2%82%85\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/ComposableArrows.html#CategoryTheory.ComposableArrows.ext%E2%82%85</a>)<br>\nIn the context of the localization of categories, there is a certain universal property (in the category of categories) which requires using equalities of functors <a href=\"https://github.com/leanprover-community/mathlib4/blob/dad08fa365650bbf2f7aed844722fea2c735069c/Mathlib/CategoryTheory/Localization/Predicate.lean#L68-L79\">https://github.com/leanprover-community/mathlib4/blob/dad08fa365650bbf2f7aed844722fea2c735069c/Mathlib/CategoryTheory/Localization/Predicate.lean#L68-L79</a> (see the <code>fac</code> and <code>uniq</code> fields) but it is used only in the internals of the API in order to prove safer statements involving isomorphisms rather than equalities. Otherwise, equalities of functors are kind of ok in the conclusion of lemmas when they are definitional equalities.<br>\nI can understand you would like to state equalities of functors, but I feel it is absurd to be reluctant to use the most appropriate lemma to do so, which is <code>Functor.ext</code>...</p>",
        "id": 514210003,
        "sender_full_name": "Joël Riou",
        "timestamp": 1745521499
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Inclusion.20functor.20from.20a.20fullsubcategory.20is.20a.20Mono/near/514210003\">said</a>:</p>\n<blockquote>\n<p>In the context of the localization of categories, there is a certain universal property (in the category of categories) which requires using equalities of functors <a href=\"https://github.com/leanprover-community/mathlib4/blob/dad08fa365650bbf2f7aed844722fea2c735069c/Mathlib/CategoryTheory/Localization/Predicate.lean#L68-L79\">https://github.com/leanprover-community/mathlib4/blob/dad08fa365650bbf2f7aed844722fea2c735069c/Mathlib/CategoryTheory/Localization/Predicate.lean#L68-L79</a> (see the <code>fac</code> and <code>uniq</code> fields) but it is used only in the internals of the API in order to prove safer statements involving isomorphisms rather than equalities.</p>\n</blockquote>\n<p>I don’t want to derail the discussion too much here, but is there a particular reason you picked this universal property for localizations, rather than the one you’d have with natural isomorphism everywhere rather than equality (which would be the localization in the (2,1)-categorical sense)? (of course, given the rest of what’s in the file, using <code>Lifting</code>, you get something equivalent, but I’m curious about not making it the definition.)</p>",
        "id": 514218893,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1745524829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Inclusion.20functor.20from.20a.20fullsubcategory.20is.20a.20Mono/near/514210003\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"776892\">Yiming Xu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Inclusion.20functor.20from.20a.20fullsubcategory.20is.20a.20Mono/near/514074481\">said</a>:</p>\n<blockquote>\n<p>Disclaimer: I respect those who takes that piece of philosophy as belief and develop elegant proofs that avoid equalities once possible. But I disagree that pursing the convenience of equality between objects when working with a functor category id undesirable.</p>\n</blockquote>\n<p>Experience shows that in most cases, things go much smoother using isomorphisms of functors (+ conditions satisfied by these isomorphisms) instead of equalities of functors. There are a few situations where we do need to use equalities of functors. For example, when studying the nerve of a category, when we say that two <code>n</code>-simplices are equal, we actually mean that two functors are equal (and for this, we have some lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/ComposableArrows.html#CategoryTheory.ComposableArrows.ext%E2%82%85\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/ComposableArrows.html#CategoryTheory.ComposableArrows.ext%E2%82%85</a>)<br>\nIn the context of the localization of categories, there is a certain universal property (in the category of categories) which requires using equalities of functors <a href=\"https://github.com/leanprover-community/mathlib4/blob/dad08fa365650bbf2f7aed844722fea2c735069c/Mathlib/CategoryTheory/Localization/Predicate.lean#L68-L79\">https://github.com/leanprover-community/mathlib4/blob/dad08fa365650bbf2f7aed844722fea2c735069c/Mathlib/CategoryTheory/Localization/Predicate.lean#L68-L79</a> (see the <code>fac</code> and <code>uniq</code> fields) but it is used only in the internals of the API in order to prove safer statements involving isomorphisms rather than equalities. Otherwise, equalities of functors are kind of ok in the conclusion of lemmas when they are definitional equalities.<br>\nI can understand you would like to state equalities of functors, but I feel it is absurd to be reluctant to use the most appropriate lemma to do so, which is <code>Functor.ext</code>...</p>\n</blockquote>\n<p>The core reason is that when we prove there is a functor between functor categories, there are fields of the construction of instance/structure that explicitly ask us to prove equality between functors instead of allowing us to compose with any equivalence. I believe what we meet now is like your case for the 2-cells (or higher cells) between simplices.</p>\n<p>What I am attempting to do is to develop some lemmas which minimize the direct usage of Functor.ext. For instance, in the case that the functors to compare are on a subcategory, at least Functor.ext should not be called directly on these two functors. The first step of this attempt is to reduce the problem I outlined into proving:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">fullSubcategoryInclusion_Mono</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Z</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"n\">Mono</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">homOf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fullSubcategoryInclusion</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>May I please ask if you could suggest something obvious to try according to your experience? And, as you said that you find it absurd to use Functor.ext too much, is there anything you may summarize as the first things to try to avoid Functor.ext to get equalities between functors? It would be ideal if we could develop an API addressing the common cases of the usage of Functor.ext. (No worries if not obvious at all! Just in case that you may say something about that.)</p>",
        "id": 514220023,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745525324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Inclusion.20functor.20from.20a.20fullsubcategory.20is.20a.20Mono/near/514210003\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"776892\">Yiming Xu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Inclusion.20functor.20from.20a.20fullsubcategory.20is.20a.20Mono/near/514074481\">said</a>:</p>\n<blockquote>\n<p>Disclaimer: I respect those who takes that piece of philosophy as belief and develop elegant proofs that avoid equalities once possible. But I disagree that pursing the convenience of equality between objects when working with a functor category id undesirable.</p>\n</blockquote>\n<p>Experience shows that in most cases, things go much smoother using isomorphisms of functors (+ conditions satisfied by these isomorphisms) instead of equalities of functors. There are a few situations where we do need to use equalities of functors. For example, when studying the nerve of a category, when we say that two <code>n</code>-simplices are equal, we actually mean that two functors are equal (and for this, we have some lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/ComposableArrows.html#CategoryTheory.ComposableArrows.ext%E2%82%85\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/ComposableArrows.html#CategoryTheory.ComposableArrows.ext%E2%82%85</a>)<br>\nIn the context of the localization of categories, there is a certain universal property (in the category of categories) which requires using equalities of functors <a href=\"https://github.com/leanprover-community/mathlib4/blob/dad08fa365650bbf2f7aed844722fea2c735069c/Mathlib/CategoryTheory/Localization/Predicate.lean#L68-L79\">https://github.com/leanprover-community/mathlib4/blob/dad08fa365650bbf2f7aed844722fea2c735069c/Mathlib/CategoryTheory/Localization/Predicate.lean#L68-L79</a> (see the <code>fac</code> and <code>uniq</code> fields) but it is used only in the internals of the API in order to prove safer statements involving isomorphisms rather than equalities. Otherwise, equalities of functors are kind of ok in the conclusion of lemmas when they are definitional equalities.<br>\nI can understand you would like to state equalities of functors, but I feel it is absurd to be reluctant to use the most appropriate lemma to do so, which is <code>Functor.ext</code>...</p>\n</blockquote>\n<p>Thanks a lot for this elaboration! I will try to devote some time to reading the links.</p>",
        "id": 514220129,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745525378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Inclusion.20functor.20from.20a.20fullsubcategory.20is.20a.20Mono/near/514218893\">said</a>:</p>\n<blockquote>\n<p>I don’t want to derail the discussion too much here, but is there a particular reason you picked this universal property for localizations, rather than the one you’d have with natural isomorphism everywhere rather than equality (which would be the localization in the (2,1)-categorical sense)? (of course, given the rest of what’s in the file, using <code>Lifting</code>, you get something equivalent, but I’m curious about not making it the definition.)</p>\n</blockquote>\n<p>My definition of <code>L.IsLocalization W</code> does not use the strict universal property either, but the property that the functor from the \"constructed localization\" is an equivalence (then, <code>IsLocalization</code> behaves well with respect to equivalences of categories, not just isomorphisms of categories). I only provide a constructor for <code>IsLocalization</code> which uses <code>StrictUniversalPropertyFixedTarget</code> as an input. <br>\nHere are two reasons not to use the relaxed universal property in the definition:</p>\n<ul>\n<li>the \"relaxed\" universal property which is stated as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Localization.functorEquivalence#doc\">docs#CategoryTheory.Localization.functorEquivalence</a> has to hold for all universes (and we cannot say \"let us fix the universes once for all\", because the localization may increase the universe levels), and if it was stated only for a fixed big enough universe, it would not be so easy to develop the API...</li>\n<li>if we were to use that relaxed universal property as the definition of <code>F.IsLocalization W</code>, the proofs of <a href=\"https://github.com/leanprover-community/mathlib4/blob/dad08fa365650bbf2f7aed844722fea2c735069c/Mathlib/CategoryTheory/Localization/Prod.lean#L98-L105\">https://github.com/leanprover-community/mathlib4/blob/dad08fa365650bbf2f7aed844722fea2c735069c/Mathlib/CategoryTheory/Localization/Prod.lean#L98-L105</a><br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/dad08fa365650bbf2f7aed844722fea2c735069c/Mathlib/CategoryTheory/Localization/Opposite.lean#L28-L41\">https://github.com/leanprover-community/mathlib4/blob/dad08fa365650bbf2f7aed844722fea2c735069c/Mathlib/CategoryTheory/Localization/Opposite.lean#L28-L41</a> and <a href=\"https://github.com/leanprover-community/mathlib4/blob/dad08fa365650bbf2f7aed844722fea2c735069c/Mathlib/CategoryTheory/Localization/Composition.lean#L33-L46\">https://github.com/leanprover-community/mathlib4/blob/dad08fa365650bbf2f7aed844722fea2c735069c/Mathlib/CategoryTheory/Localization/Composition.lean#L33-L46</a> would be more complicated, as the burden of proof would be much more important: the proofs would probably have to include some of the ingredients which appear in the relatively nontrivial proof of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Localization.Construction.whiskeringLeftEquivalence#doc\">docs#CategoryTheory.Localization.Construction.whiskeringLeftEquivalence</a> for the constructed localized category (the key lemma is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Localization.Construction.morphismProperty_is_top#doc\">docs#CategoryTheory.Localization.Construction.morphismProperty_is_top</a> which is about the fully faithfulness of the functor given by the precomposition with the localization functor)</li>\n</ul>",
        "id": 514231843,
        "sender_full_name": "Joël Riou",
        "timestamp": 1745530129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Inclusion.20functor.20from.20a.20fullsubcategory.20is.20a.20Mono/near/514070050\">said</a>:</p>\n<blockquote>\n<p>Why would you want to prove that two functors are equal though? This is an evil statement because it relies on the concept of equality of objects in a category, which is not preserved under equivalence of categories. Why don't you just write down a morphism between the functors and prove it's a natural isomorphism?</p>\n</blockquote>\n<p>I certainly agree that in category theory in general (and in math that's using it), it's better to work up to isomorphism than up to equality!  But for this particular project (<a href=\"https://sinhp.github.io/groupoid_model_in_lean4/\">HoTTLean</a>), we are using categories and functors as <em>algebraic</em> objects, in order to strictly model the rules of dependent type theory, as explained in <a href=\"https://arxiv.org/abs/1406.3219\">this paper</a>.</p>\n<p>Thanks for any advice you (all) can give on how to make Lean do what we want!</p>",
        "id": 514233464,
        "sender_full_name": "Steve Awodey",
        "timestamp": 1745530954
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776892\">Yiming Xu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Inclusion.20functor.20from.20a.20fullsubcategory.20is.20a.20Mono/near/514220023\">said</a>:</p>\n<blockquote>\n<p>And, as you said that you find it absurd to use Functor.ext too much</p>\n</blockquote>\n<p>No, what I find absurd is that you insist on proving equalities of functors and at the same time you do not want to use the essentially unique tool we have to do it, which is <code>Functor.ext</code>.<br>\nAs <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> has implied above, if there are any functors <code>I : C ⥤ D</code> which deserve to be the analogues of monomorphisms, these are the functors such the postcomposition with <code>I</code> give fully faithful functors <code>(E ⥤ C) ⥤ (E ⥤ D)</code> for any category <code>E</code>. (Similarly as a monomorphism <code>i : c ⟶ d</code> in a category is a morphism such the postcomposition with <code>i</code> gives an injective map <code>(e ⟶ c) → (e ⟶ d)</code> for any object <code>e</code>.) It turns out that the functors <code>I</code> as above are exactly the fully faithful functors.</p>",
        "id": 514233691,
        "sender_full_name": "Joël Riou",
        "timestamp": 1745531064
    },
    {
        "content": "<p>I mean we should make attempt to call Functor.ext in an organized way instead of everywhere. It is a pain to \"get into dependent rw once we have chance to encounter it\". It should be only called on the most managable defs and thms. The above I wrote is again an abstraction to some particular case which is less managable.</p>",
        "id": 514234395,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745531445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"730421\">Steve Awodey</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Inclusion.20functor.20from.20a.20fullsubcategory.20is.20a.20Mono/near/514233464\">said</a>:</p>\n<blockquote>\n<p>I certainly agree that in category theory in general (and in math that's using it), it's better to work up to isomorphism than up to equality!  But for this particular project (<a href=\"https://sinhp.github.io/groupoid_model_in_lean4/\">HoTTLean</a>), we are using categories and functors as <em>algebraic</em> objects, in order to strictly model the rules of dependent type theory, as explained in <a href=\"https://arxiv.org/abs/1406.3219\">this paper</a>.</p>\n<p>Thanks for any advice you (all) can give on how to make Lean do what we want!</p>\n</blockquote>\n<p>There are genuine situations where we need strict commutations of diagrams of categories and functors (e.g. this happens when \"sheafifying\" algebraic K-theory in the works by Brown-Gersten and Thomason), and in order to do so we may even have to \"strictify\" certain pseudofunctors to get actual functors. In such situations, I would say that the end justifies the means.</p>",
        "id": 514236313,
        "sender_full_name": "Joël Riou",
        "timestamp": 1745532541
    },
    {
        "content": "<p>If you need to prove an equality of functors, I would say that the best practice would be to define an isomorphism first, and then only to use the lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.ext_of_iso#doc\">docs#CategoryTheory.Functor.ext_of_iso</a> in order to get an equality.</p>",
        "id": 514236696,
        "sender_full_name": "Joël Riou",
        "timestamp": 1745532790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Inclusion.20functor.20from.20a.20fullsubcategory.20is.20a.20Mono/near/514231843\">said</a>:</p>\n<blockquote>\n<p>[...]</p>\n</blockquote>\n<p>Thanks for the in-depth explanation!</p>",
        "id": 514240498,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1745535098
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Inclusion.20functor.20from.20a.20fullsubcategory.20is.20a.20Mono/near/514236696\">said</a>:</p>\n<blockquote>\n<p>If you need to prove an equality of functors, I would say that the best practice would be to define an isomorphism first, and then only to use the lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.ext_of_iso#doc\">docs#CategoryTheory.Functor.ext_of_iso</a> in order to get an equality.</p>\n</blockquote>\n<p>Many many thanks! I checked your links above. Your project is so (impressively!) large that I cannot find a case of the usage of Functor.ext_of_iso. If it is easy enough to identify, could you please point to a place that Functor.ext_of_iso is used, and you are satisfied with the proof, so we can consult that as a reference?</p>",
        "id": 514288313,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745558954
    },
    {
        "content": "<p>There are good examples in <code>CategoryTheory.Category.Quiv</code>.</p>",
        "id": 514303130,
        "sender_full_name": "Joël Riou",
        "timestamp": 1745564891
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Inclusion.20functor.20from.20a.20fullsubcategory.20is.20a.20Mono/near/514303130\">said</a>:</p>\n<blockquote>\n<p>There are good examples in <code>CategoryTheory.Category.Quiv</code>.</p>\n</blockquote>\n<p>Sorry! I do not spot a any occurrence of ext_of_iso in this file. May I please confirm that you are suggesting this one?<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Category/Quiv.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Category/Quiv.html</a></p>",
        "id": 514335371,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745573521
    },
    {
        "content": "<p><code>rg 'Functor.ext_of_iso'</code> gives the following 5 matches: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">/</span><span class=\"n\">Category</span><span class=\"bp\">/</span><span class=\"n\">Quiv</span><span class=\"bp\">.</span><span class=\"n\">lean</span>\n<span class=\"mi\">92</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">ext_of_iso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">freeMapIdIso</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"mi\">108</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">ext_of_iso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">freeMapCompIso</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">/</span><span class=\"n\">ComposableArrows</span><span class=\"bp\">.</span><span class=\"n\">lean</span>\n<span class=\"mi\">207</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">ext_of_iso</span>\n<span class=\"mi\">275</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">ext_of_iso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isoMk₁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eqToIso</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eqToIso</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">map'_eq_hom₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">]))</span>\n<span class=\"mi\">540</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">ext_of_iso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isoMkSucc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eqToIso</span><span class=\"w\"> </span><span class=\"n\">h₀</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eqToIso</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span>\n</code></pre></div>",
        "id": 514336451,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1745573872
    },
    {
        "content": "<p>Thank you! I do not see any of them, it is indicating that I should update my mathlib!! Good reminder.</p>",
        "id": 514336933,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1745574025
    }
]