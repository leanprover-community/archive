[
    {
        "content": "<p>Ints: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.csSup_of_not_bdd_above#doc\">docs#Int.csSup_of_not_bdd_above</a><br>\nReals: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.sSup_of_not_bddAbove#doc\">docs#Real.sSup_of_not_bddAbove</a><br>\nNNReals: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NNReal.sSup_of_not_bddAbove#doc\">docs#NNReal.sSup_of_not_bddAbove</a></p>\n<p>I'm looking for a <code>Nat</code> version, but surely this theorem can be generalized, rather than having a version for each numeric type, no?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sSup_of_not_bdd_above</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">BddAbove</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Infinite</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sSup_eq_zero</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">infinite_of_not_bddAbove</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>A <code>SupSet</code> instance isn't enough to get this property, but maybe some lattice instance can? Is there some property that's true for the <code>SupSet</code>s of <code>Nat</code>/<code>Int</code>/<code>Rat</code>/<code>NNRat</code>/<code>Real</code>/<code>NNReal</code> that implies such a theorem?<br>\n(and maybe even for <code>ENat</code>/<code>ENNReal</code>)</p>",
        "id": 565267688,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766572130
    },
    {
        "content": "<p>No, this would need a new type class, I think</p>",
        "id": 565268560,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1766572681
    },
    {
        "content": "<p>There's also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.sSup_mem#doc\">docs#Nat.sSup_mem</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.csSup_mem#doc\">docs#Int.csSup_mem</a> for when the set <em>is</em> <code>BddAbove</code>,<br>\nthen we get <code>s = ∅ ∨ sSup s = 0 ∨ sSup s ∈ s</code> by excluded-middle on <code>BddAbove</code>,<br>\nthough I'm not sure if one property implies the other</p>",
        "id": 565268958,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766572944
    },
    {
        "content": "<p>i think this would be a bad typeclass, in the sense that the choice of <code>0</code> for this default is (prima facie) completely arbitrary... if there were to be a typeclass for this, i think it'd need to at least have some proof field which is only inhabited because 0 is the right choice of default value...</p>",
        "id": 565269471,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1766573218
    },
    {
        "content": "<p>Well we can say <code>sSup ∅</code> is the default value without mentioning 0, that's a pretty sensible default I think</p>",
        "id": 565269616,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766573294
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConditionallyCompleteLinearOrderBot#doc\">docs#ConditionallyCompleteLinearOrderBot</a> is pretty close to what you're asking for</p>",
        "id": 565269665,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1766573332
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.60.C2.ACBddAbove.20s.20.E2.86.92.20sSup.20s.20.3D.200.60/near/565269616\">said</a>:</p>\n<blockquote>\n<p>Well we can say <code>sSup ∅</code> is the default value without mentioning 0, that's a pretty sensible default I think</p>\n</blockquote>\n<p>that looks like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=csSup_of_not_bddAbove#doc\">docs#csSup_of_not_bddAbove</a> to me...</p>",
        "id": 565270256,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1766573743
    },
    {
        "content": "<p>so the class you're looking for seems to be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConditionallyCompleteLinearOrder#doc\">docs#ConditionallyCompleteLinearOrder</a></p>",
        "id": 565270392,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1766573849
    },
    {
        "content": "<p>Looks about right, so just <code>sSup ∅ = 0</code> is missing now. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=csSup_zero#doc\">docs#csSup_zero</a> seems close but doesn't work.<br>\nAlso, there's no <code>ConditionallyCompleteLinearOrder</code> instance for <code>Rat</code>/<code>NNRat</code> (which makes sense) but I think the statement is still true for rationals</p>",
        "id": 565271544,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766574667
    },
    {
        "content": "<p>I don't think you can state the statement for rationals</p>",
        "id": 565271655,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766574771
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=csSup_mem_of_not_isSuccPrelimit#doc\">docs#csSup_mem_of_not_isSuccPrelimit</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Nonempty.csSup_mem#doc\">docs#Set.Nonempty.csSup_mem</a> are also close to <code>BddAbove s → sSup s ∈ s</code> but not quite the same</p>",
        "id": 565271684,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766574796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.60.C2.ACBddAbove.20s.20.E2.86.92.20sSup.20s.20.3D.200.60/near/565271655\">said</a>:</p>\n<blockquote>\n<p>I don't think you can state the statement for rationals</p>\n</blockquote>\n<p>Oh I guess it makes sense, <code>SupSet</code> doesn't allow the sup to be of a different type</p>",
        "id": 565271786,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766574857
    },
    {
        "content": "<p>No actually why isn't there a <code>SupSet ℚ</code> instance that returns 0 for cases such as Dedekind cuts of irrationals?</p>",
        "id": 565271939,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766574975
    },
    {
        "content": "<p>similar to how an unbounded set returns the junk value 0</p>",
        "id": 565271966,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766575009
    },
    {
        "content": "<p>What would be the point? If you want to take sups of rationals, you should expect to get a real number</p>",
        "id": 565271977,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1766575019
    },
    {
        "content": "<p>If I want a real number I can cast the set to the reals first, then take the sup</p>",
        "id": 565272057,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766575069
    },
    {
        "content": "<p>this is what one has to do now anyways</p>",
        "id": 565272079,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766575085
    },
    {
        "content": "<p>Again, why would you want a supremum of rational numbers to be a rational number? This isn't a sensible operation.</p>",
        "id": 565272377,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1766575298
    },
    {
        "content": "<p>The fact that this isn't a sensible operation is precisely <em>why</em> the real numbers were invented in the first place.</p>",
        "id": 565272411,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1766575323
    },
    {
        "content": "<p>Since such a <code>SupSet</code> definition isn't a <code>ConditionallyCompleteLinearOrder</code> I guess it really isn't that useful</p>",
        "id": 565273582,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766576029
    },
    {
        "content": "<p>So with regards to <code>Nat</code>s, should I PR the <code>¬BddAbove s → sSup s = 0</code> theorem? Or is there a more general <code>[ConditionallyCompleteLinearOrder α] [Zero α]</code> theorem that's possible?</p>",
        "id": 565273759,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766576134
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=csSup_zero#doc\">docs#csSup_zero</a> gives <code>sSup 0 = 0</code> for <code>[ConditionallyCompleteLattice α] [Zero α]</code>, but it isn't the same as <code>sSup ∅ = 0</code> apparently</p>",
        "id": 565273903,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766576235
    },
    {
        "content": "<p>Oh <code>csSup_empty</code> works for <code>Nat</code>s as they are a <code>ConditionallyCompleteLinearOrderBot</code> and their bot is zero, but that doesn't work for reals/ints</p>",
        "id": 565274365,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1766576532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.60.C2.ACBddAbove.20s.20.E2.86.92.20sSup.20s.20.3D.200.60/near/565273759\">said</a>:</p>\n<blockquote>\n<p>with regards to <code>Nat</code>s, should I PR the <code>¬BddAbove s → sSup s = 0</code> theorem?</p>\n</blockquote>\n<p>Yes sure, why not. I wouldn't bother about generalising</p>",
        "id": 565275221,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1766577155
    },
    {
        "content": "<p>I think every type implementing <code>SupSet</code> and <code>InfSet</code> should be free to use whichever junk values make sense whenever these are not defined. It doesn't really make sense to mandate any specific choices.</p>",
        "id": 565465269,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1766776071
    }
]