[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ConditionallyCompleteLattice</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ConditionallyCompleteLattice</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">OrderIso</span><span class=\"bp\">.</span><span class=\"n\">csSup_image</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">OrderIso</span><span class=\"bp\">.</span><span class=\"n\">csInf_image</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This exists for <code>CompleteLattice</code> for arbitrary functions, but surely an <code>OrderIso</code> means we don't need any assumptions on <code>α</code> and <code>β</code> other than something linking their <code>LE</code> and <code>SupSet</code> instances?<br>\nWhat's the most general version of this?</p>",
        "id": 575208609,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1771809012
    },
    {
        "content": "<p><code>ConditionallyConpleteLattice</code> doesn't impose any requirements on what <code>sSup s</code> can be when <code>s</code> is empty or not bounded above, except that it's consistent across all sets which are empty or not bounded above. So you would need to be able to control what happens in that case for this to be true.</p>",
        "id": 575209176,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1771809204
    },
    {
        "content": "<p>Makes sense, but is the general case true? (i.e. if I require <code>(_ : Nonempty s) (_ : BddAbove s) (_ : BddBelow s) (_ : BddAbove (f '' s)) (_ : BddBelow (f '' s))</code>)</p>",
        "id": 575209596,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1771809345
    },
    {
        "content": "<p>See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderIso.map_csSup%27#doc\">docs#OrderIso.map_csSup'</a></p>",
        "id": 575210322,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771809594
    },
    {
        "content": "<p>Thanks! Is there a chance a similar statement is true for <code>OrderHom</code>, in particular <code>Nat.cast</code> to some <code>α</code>?</p>",
        "id": 575210608,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1771809750
    },
    {
        "content": "<p>(not to mention I also couldn't find anything about <code>Nat.cast</code> being an <code>OrderHom</code>/<code>OrderEmbedding</code>/<code>OrderIso</code>)</p>",
        "id": 575210670,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1771809806
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> Nat.cast, StrictMono</p>",
        "id": 575210736,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771809860
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Order/Group/Unbundled/Int.html#Int.natCast_strictMono\">Int.natCast_strictMono</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Nat/Cast/Order/Basic.html#Nat.strictMono_cast\">Nat.strictMono_cast</a>, and <a href=\"https://loogle.lean-lang.org/?q=Nat.cast%2C%20StrictMono\">7 more</a></p>",
        "id": 575210738,
        "sender_full_name": "loogle",
        "timestamp": 1771809861
    },
    {
        "content": "<p>This isn't true for any monotone function. E.g., the embedding of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>∪</mo><mo stretchy=\"false\">{</mo><mn>2</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">[0, 1) \\cup \\{2\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">2</span><span class=\"mclose\">}</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> doesn't satisfy this property. For natural numbers, you know that a bounded set is finite, thus its supremum is its greatest element, which survives under a monotone map.</p>",
        "id": 575210890,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771809992
    },
    {
        "content": "<p>See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BddAbove.finite#doc\">docs#BddAbove.finite</a></p>",
        "id": 575210993,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771810063
    },
    {
        "content": "<p>It looks like we don't have a version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsCompact.isGreatest_sSup#doc\">docs#IsCompact.isGreatest_sSup</a> for a finite set.</p>",
        "id": 575211035,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771810099
    },
    {
        "content": "<p>See also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Monotone.map_isGreatest#doc\">docs#Monotone.map_isGreatest</a></p>",
        "id": 575211057,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771810120
    },
    {
        "content": "<p>a function can commute with suprema if it's normal (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.IsNormal.map_sSup#doc\">docs#Order.IsNormal.map_sSup</a>)</p>",
        "id": 575211270,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1771810338
    },
    {
        "content": "<blockquote>\n<p>(not to mention I also couldn't find anything about <code>Nat.cast</code> being an <code>OrderHom</code>/<code>OrderEmbedding</code>/<code>OrderIso</code>)</p>\n</blockquote>\n<p>I could be wrong but I don't think <code>Nat.cast</code> has any restrictions on how it behaves</p>",
        "id": 575213318,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1771811880
    },
    {
        "content": "<p>It does if you assume stronger typeclasses</p>",
        "id": 575224526,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1771821632
    },
    {
        "content": "<p>I ended up using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Monotone.csSup_image_le#doc\">docs#Monotone.csSup_image_le</a> to get <code>sSup (f '' s) ≤ f (sSup s)</code>, and the other direction is true given a finite nonempty set and a monotone function from <code>ConditionallyCompleteLinearOrder</code> to <code>ConditionallyCompleteLattice</code> (<a href=\"https://github.com/leanprover-community/mathlib4/pull/35669\">#35669</a>)</p>",
        "id": 575268012,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1771842710
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 575268052,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1771842721
    }
]