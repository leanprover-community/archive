[
    {
        "content": "<p>Is there any way I can construct an explicit bijection between Finset and Fin n , where n is the cardinality of the Finset? Does it already exist?</p>",
        "id": 510376771,
        "sender_full_name": "Swarnava Chakraborty",
        "timestamp": 1743862306
    },
    {
        "content": "<p>What do you mean by \"explicit\"? Anyway we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Fintype/EquivFin.html#Finset.equivFin\">Finset.equivFin</a> and friends.</p>",
        "id": 510376982,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1743862437
    },
    {
        "content": "<p>If you want to actually compute with it there is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Fintype/EquivFin.html#Fintype.truncEquivFin\">Fintype.truncEquivFin</a></p>",
        "id": 510377124,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1743862532
    },
    {
        "content": "<p>Thanks. I am new to Lean and do not really understand the function type <code>≃</code> notation.My question was how to construct a bijection. What equivFin does is I think gives all the possible bijections, right?</p>",
        "id": 510475221,
        "sender_full_name": "Swarnava Chakraborty",
        "timestamp": 1743940019
    },
    {
        "content": "<p>it does not. it just uses choice to get one</p>",
        "id": 510475718,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743940437
    },
    {
        "content": "<p>the <code>≃</code> notation refers to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv#doc\">docs#Equiv</a>, which is a datastructure containing maps either way and a proof that these are left and right inverse to eachother. This means that <code>equivFin</code> contains a map <code>s -&gt; Fin s.card</code> and a map <code>Fin s.card -&gt; s</code> which are eachothers inverse. it produces this map by using choice, so there is no telling what <code>0:Fin s.card</code> concretely maps to in <code>s</code>.</p>",
        "id": 510475930,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743940638
    },
    {
        "content": "<p><code>truncEquivFin</code> refers to the fact that, because <code>Fintype</code> stores the concrete elements of the type up to permutation, if you choose a permutation, you can also computably get a concrete bijection. This allows for making computable functions which evaluate such a bijection, so long as the return value doesn't change no matter which bijection you pick.</p>",
        "id": 510476728,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743941227
    }
]