[
    {
        "content": "<p>Do we have a way to do induction on a basis? That is, I would like to argue that if <code>b : Basis ι R M</code> and I have some predicate  <code>P : M → Prop</code> that holds for the basis vectors and is closed under addition and scalar multiplication, then it holds on the entire module <code>M</code>. Note: I realize that I could say that <code>x : M</code> means <code>x ∈ (⊤ : Submodule R M)</code> which is <code>x ∈ (span R (Set.range b))</code> and then do <code>Submodule.induction_on</code>, but I'm trying to avoid the hoop jumping.</p>",
        "id": 407812062,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1702502358
    },
    {
        "content": "<p>I claim that usually the most effective hoops to jump through are the ones where you express <code>P x</code> as <code>f x = g x</code> for some morphisms <code>f</code> and <code>g</code>, then use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Basis.ext#doc\">docs#Basis.ext</a></p>",
        "id": 407813327,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702502925
    },
    {
        "content": "<p><code>apply Submodule.span_induction (b.mem_span x)</code> should be what you need?</p>",
        "id": 407813409,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1702502977
    },
    {
        "content": "<p>Eric, I don't think that approach works in my use case.</p>",
        "id": 407813576,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1702503036
    }
]