[
    {
        "content": "<p>Is there an easy way to get the <code>Lean.Expr</code> for <code>0:R</code> and <code>1:R</code> for a ring <code>R</code>?</p>",
        "id": 510409420,
        "sender_full_name": "Riyaz Ahuja",
        "timestamp": 1743885252
    },
    {
        "content": "<p>in what context?</p>",
        "id": 510409763,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743885513
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.mkNumeral#doc\">docs#Lean.Meta.mkNumeral</a></p>",
        "id": 510409764,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743885513
    },
    {
        "content": "<p>if you're doing Qq stuff, i imagine there is a more obvious way?</p>",
        "id": 510410040,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743885612
    },
    {
        "content": "<p>i.e. something along the lines of <code>one (R : Q(Type u)) : Q($R) := q(1:$R)</code>? idk, i haven't used Qq that much yet</p>",
        "id": 510410203,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743885752
    },
    {
        "content": "<p>This works in the web editor</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">R</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"bp\">$</span><span class=\"n\">R</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 510410432,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743885901
    },
    {
        "content": "<p>There's a difference between <code>mkNumeral</code> and this Qq-based <code>one</code>. The <code>mkNumeral</code> function resolves the instance at run time, getting the OfNat instance directly, but <code>one</code> causes the instance to go through the <code>Ring</code> instance.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Level</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">R</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"bp\">$</span><span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">synthInstanceQ</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">))</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">(((Expr.const `OfNat.ofNat [Level.zero]).app (Expr.const `Int [])).app (Expr.lit (Literal.natVal 1))).app</span>\n<span class=\"cm\">  (((Expr.const `One.toOfNat1 [Level.zero]).app (Expr.const `Int [])).app</span>\n<span class=\"cm\">    (((Expr.const `AddMonoidWithOne.toOne [Level.zero]).app (Expr.const `Int [])).app</span>\n<span class=\"cm\">      (((Expr.const `AddGroupWithOne.toAddMonoidWithOne [Level.zero]).app (Expr.const `Int [])).app</span>\n<span class=\"cm\">        (((Expr.const `Ring.toAddGroupWithOne [Level.zero]).app (Expr.const `Int [])).app</span>\n<span class=\"cm\">          (Expr.const `Int.instRing [])))))</span>\n<span class=\"cm\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">mkNumeral</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">(((Expr.const `OfNat.ofNat [Level.zero]).app (Expr.const `Int [])).app (Expr.lit (Literal.natVal 1))).app</span>\n<span class=\"cm\">  ((Expr.const `instOfNat []).app (Expr.lit (Literal.natVal 1)))</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 510410937,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743886219
    },
    {
        "content": "<p>It probably doesn't matter in practice, but the fact the instance is resolved at compile time for <code>one</code> is worth knowing.</p>",
        "id": 510411020,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743886291
    }
]