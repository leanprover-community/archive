[
    {
        "content": "<p>Do we have the canonical ring homomorphism ℤ/nℤ → ℤ/mℤ when m divides n?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∣</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→+*</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">suggest</span>\n</code></pre></div>\n<p>comes up with only</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Try</span> <span class=\"n\">this</span><span class=\"o\">:</span> <span class=\"n\">refine</span> <span class=\"n\">ring_equiv.to_ring_hom</span> <span class=\"n\">_</span>\n<span class=\"n\">Try</span> <span class=\"n\">this</span><span class=\"o\">:</span> <span class=\"n\">refine</span> <span class=\"n\">ring_hom.mk'</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"n\">Try</span> <span class=\"n\">this</span><span class=\"o\">:</span> <span class=\"n\">refine</span> <span class=\"n\">ring_hom.copy</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"n\">Try</span> <span class=\"n\">this</span><span class=\"o\">:</span> <span class=\"n\">refine</span> <span class=\"o\">{</span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 358835866,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1684267213
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/zmod.lift\">docs#zmod.lift</a></p>",
        "id": 358836390,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684267304
    },
    {
        "content": "<p>That says</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"kd\">def</span> <span class=\"n\">zmod.lift</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"bp\">//</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"bp\">↑</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">n</span> <span class=\"bp\">→+</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"n\">The</span> <span class=\"n\">map</span> <span class=\"k\">from</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span> <span class=\"n\">induced</span> <span class=\"kd\">by</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→+</span> <span class=\"n\">A</span> <span class=\"n\">that</span> <span class=\"n\">maps</span> <span class=\"n\">n</span> <span class=\"n\">to</span> <span class=\"mi\">0</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>which does not seem to be what I want.</p>",
        "id": 358836999,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1684267389
    },
    {
        "content": "<p>It is only about maps preserving addition, not ring homomorphisms.</p>",
        "id": 358837143,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1684267441
    },
    {
        "content": "<p>is there a <code>zmod.lift_ring_hom</code> or something?</p>",
        "id": 358837340,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1684267515
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/zmod.cast_hom\">docs#zmod.cast_hom</a></p>",
        "id": 358837351,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684267518
    },
    {
        "content": "<p>OK, that looks better!</p>",
        "id": 358837422,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1684267549
    },
    {
        "content": "<p>I wonder why <code>suggest</code> did not pick this up?</p>",
        "id": 358837533,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1684267590
    },
    {
        "content": "<p>Does <code>library_search</code>?</p>",
        "id": 358837572,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684267608
    },
    {
        "content": "<p>No (with or without <code>!</code>). But</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∣</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→+*</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">zmod.cast_hom</span> <span class=\"n\">h</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>works...</p>",
        "id": 358837795,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1684267682
    },
    {
        "content": "<p>I wonder if <code>propose</code> works in mathlib4?</p>",
        "id": 358838261,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1684267874
    },
    {
        "content": "<p>But I'm surprised <code>library_search</code> didn't get it.</p>",
        "id": 358838343,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1684267911
    },
    {
        "content": "<p>The reason <code>library_search</code> is not getting this is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">∣</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→+*</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">ZMod.castHom</span>\n</code></pre></div>\n<p>fails with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span>\n  <span class=\"n\">CharP</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">m</span>\n</code></pre></div>",
        "id": 359696206,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1684509999
    },
    {
        "content": "<p>It never gets to the stage of using <code>h : m ∣ n</code> because the <code>apply</code> fails, because at that point it doesn't know which characteristic <code>?m</code> to expect.</p>",
        "id": 359696450,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1684510047
    },
    {
        "content": "<p>Sad, but I'm not sure there is a systematic way to improve this.</p>",
        "id": 359696498,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1684510062
    },
    {
        "content": "<p><code>library_search</code> <em>wants</em> to try this lemma: with the current heuristics, it is in fact the very first lemma it tries!</p>",
        "id": 359696671,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1684510093
    },
    {
        "content": "<p>Is this the <code>apply</code> bug?</p>",
        "id": 359696921,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684510152
    },
    {
        "content": "<p>Could library_search learn to use <code>refine</code> instead?</p>",
        "id": 359696958,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684510161
    },
    {
        "content": "<p>I guess there is something systematic you could do:</p>\n<ul>\n<li>While applying the lemmas, postpone any typeclass goals that involve metavariables.</li>\n<li>Then try to solve these during the <code>solveByElim</code> stage.</li>\n</ul>",
        "id": 359696976,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1684510165
    },
    {
        "content": "<p>Oh! Sure, can you point me to the discussion on this?</p>",
        "id": 359697081,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1684510191
    },
    {
        "content": "<p>That was mostly a joke; <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> always complains about \"the apply bug\" in Lean 3, which I think is usually just complaining that <code>apply foo</code> fails when <code>refine foo _ _ _</code> with apropriately many <code>_</code>s works</p>",
        "id": 359697390,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684510242
    },
    {
        "content": "<p>I have no data indicating whether this sort of thing happens in Lean4 other than your post above</p>",
        "id": 359697472,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684510258
    },
    {
        "content": "<p>I don't think I know how to modify <code>apply</code> to return typeclass args with metavariables rather than failing on them. If anyone is interested in thinking about that, I would love to hear any outcome.</p>",
        "id": 359698438,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1684510476
    },
    {
        "content": "<p>I guess we could also solve this by making <code>char_p</code> use an <code>out_param</code></p>",
        "id": 359698675,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684510531
    },
    {
        "content": "<p>But I think there's some annoying defeq reason about <code>char_p R (ring_char R)</code> that makes this a bad idea, and it's been discussed before.</p>",
        "id": 359698782,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684510559
    },
    {
        "content": "<p>I claim <code>char_p R (ring_char R)</code> is an unfriendly citizen anyways. Very locally, you can use it. But if you have a lot of rings floating around that should have the same characteristic, then it's a lot better to have an abstract <code>p</code> once and for all.</p>",
        "id": 359811334,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1684560980
    },
    {
        "content": "<p>Maybe then we could have a typeclass CanonicalCharP with an out param that provides an instance of CharP. Rather than modifying CharP itself and dealing with that. The idea would be the truly nice CharP instances like CharP (ZMod m) m or CharZero K to CharP K 0 can be upgraded to CanonicalCharP.</p>",
        "id": 359842759,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1684574647
    }
]