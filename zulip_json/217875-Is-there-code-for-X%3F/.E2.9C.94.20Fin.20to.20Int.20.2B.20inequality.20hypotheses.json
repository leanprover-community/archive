[
    {
        "content": "<p>Supposing <code>a : Fin n</code>, is there a way to replace <code>a</code> with <code>a' : Int</code> wherever it's used, and simultaneously introduce the hypotheses <code>a' &gt;= 0</code> and <code>a' &lt; n</code>?</p>",
        "id": 517200605,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1746833060
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">\\&lt;</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">\\&gt;</span>\n<span class=\"n\">zify</span>\n</code></pre></div>",
        "id": 517201115,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1746833444
    },
    {
        "content": "<p>Depending on what your larger goal is</p>",
        "id": 517201129,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1746833462
    },
    {
        "content": "<p>You could also do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">ha'</span>\n<span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">anonneg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">positivity</span>\n<span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">abounded</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact_mod_cast</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">isLt</span>\n</code></pre></div>",
        "id": 517201292,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1746833616
    },
    {
        "content": "<p>I'm assuming you're using mathlib. If not, similar approaches will work, just with less powerful tactics</p>",
        "id": 517201418,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1746833701
    },
    {
        "content": "<p>The <code>rcases</code> approach gets me partway: after <code>zify</code> I have  <code>a' : ℕ</code> rather than <code>a': ℤ</code> as desired, and also there are a bunch of places where <code>⟨a', ha'⟩</code>is embedded in the goal expression! (<code>zify</code> and/or <code>simp</code> gets rid of _some_ of these, but not all.)</p>\n<p><code>have anonneg : 0 &lt;= a' := by positivity</code> fails with an unhelpful error (\"failed to prove positivity/nonnegativity/nonzeroness\").</p>",
        "id": 517202855,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1746834957
    },
    {
        "content": "<p>As I am on mobile, I am not very precise. I think with the way I wrote it, one has to rewrite with the ha' definitional hypothesis before positivity will work. Positivity doesn't do searching for rewrites</p>",
        "id": 517204627,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1746836407
    },
    {
        "content": "<p>Perhaps by simp [ha'] is enough.</p>",
        "id": 517204675,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1746836474
    },
    {
        "content": "<p>Re \"there are a bunch of places where &lt;a,ha&gt; is embedded in the goal expression\" -- what are you expecting to happen instead? In general there is surely no way of avoiding this?</p>",
        "id": 517230728,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746859277
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Like I said up top, I have a proof goal involving <code>a: Fin n</code> and I want a way to replace <code>a</code> with <code>a': Int</code> throughout the goal, simultaneously introducing <code>ha': a' ≥ 0 ∧ a' &lt; n</code> into the proof context.  I did not want <code>⟨a', ha'⟩</code> to appear within the goal. I don't understand what it means to have <code>⟨a', ha'⟩</code> embedded in the middle of an equation and I have no idea how to work with it.</p>\n<p>Perhaps this would be clearer if I give a concrete example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Conversion factor from seconds to nanoseconds (10⁹)</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Nsec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span>\n\n<span class=\"c1\">-- this is the kind of thing I'm trying to prove</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">equiv_1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nsec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">an</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">or</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> an &lt; bn ↔ an &lt; bn -/</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">tauto</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> m ≤ an - bn ↔ bn + m ≤ an -/</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">-- it might be useful to be able to assert that an ≥ bn in this</span>\n<span class=\"w\">    </span><span class=\"c1\">-- case but I don't know how</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- if we could turn an, bn, and m into Int then we could use</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Int's inequality lemmas (see below)</span>\n\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> Yakov suggestion 1:</span>\n<span class=\"cm\">    rcases an with ⟨an', han'⟩</span>\n<span class=\"cm\">    rcases bn with ⟨bn', hbn'⟩</span>\n<span class=\"cm\">    rcases m with ⟨m', hm'⟩</span>\n<span class=\"cm\">    -- at this point we have (an' bn' m': ℕ) and</span>\n<span class=\"cm\">    -- ⊢ ⟨m', hm'⟩ ≤ ⟨an', han'⟩ - ⟨bn', hbn'⟩ ↔ ⟨bn', hbn'⟩ + ⟨m', hm'⟩ ≤ ⟨an', han'⟩</span>\n<span class=\"cm\">    -- I want (an' bn' m': ℤ) and I don't understand what it means to have</span>\n<span class=\"cm\">    -- ⟨x, hx⟩ embedded in the goal</span>\n<span class=\"cm\">    zify [han', hbn', hm']</span>\n<span class=\"cm\">    -- zify has no effect; 'simp made no progress' diagnostic</span>\n<span class=\"cm\">    -/</span>\n\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> Yakov suggestion 2:</span>\n<span class=\"cm\">    set an': Int := ↑an with ha' -- added the ↑ to correct a type mismatch error</span>\n<span class=\"cm\">    have an_nonneg: 0 ≤ an' := by positivity -- this works</span>\n<span class=\"cm\">    have an_bounded: an' &lt; ONE_S_IN_NS := by exact_mod_cast an.isLt</span>\n<span class=\"cm\">       -- mod_cast has type ↑an &lt; ONE_S_IN_NS : Prop but is expected to have type an' &lt; 1000000000 : Prop</span>\n<span class=\"cm\">    rewrite [← ha'] -- tactic 'rewrite' failed, did not find instance of [↑↑an] in the target expression</span>\n<span class=\"cm\">    simp [← ha'] -- simp made no progress</span>\n<span class=\"cm\">    -/</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- this would go through if an, bn, m were Int</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">add_le_of_le_sub_left</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">le_sub_left_of_add_le</span>\n</code></pre></div>",
        "id": 517257687,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1746882906
    },
    {
        "content": "<p>A term of type <code>Fin n</code> is a pair, consisting of a natural number and a proof that it's less than n. If you have a variable <code>x : Fin n</code> then <code>x</code> prints as <code>x</code> but secretly it's a pair. However if you have a natural <code>a'</code> and a proof <code>ha'</code> that <code>a' &lt; n</code> then the way to express the corresponding term of type <code>Fin n</code> is <code>⟨a', ha'⟩</code>. </p>\n<p>What is <em>not</em> true is that a term of type <code>Fin n</code> <em>is</em> a natural. So if Lean has some function or theorem statement which involves a term of type <code>Fin n</code>, then you cannot just replace this with a natural, because this would not typecheck. So as far as I can see, what you are asking for is impossible in Lean's type theory. A term of type <code>Fin n</code> is a pair, not a natural or an integer.</p>\n<p>In set theory, a natural which is less than n is a natural. But in type theory, distinct types are disjoint, and type theory cannot even <em>express</em> the idea <code>x = a'</code> if <code>x : Fin n</code> and <code>a' : Nat</code> -- this is a meaningless statement in type theory, as <code>x = y</code> only makes sense if <code>x</code> and <code>y</code> have the same type. This is a key difference between type theory and set theory.</p>",
        "id": 517259260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746884258
    },
    {
        "content": "<p>I think I understand <code>⟨a', ha'⟩</code> a little better now.</p>\n<p>However, I don't see why it would be impossible in Lean's type theory to rewrite an expression involving terms of type <code>Fin n</code> as an expression involving terms of type Nat (or Int) plus the proofs.  In computational terms, \"all\" I am asking for is a higher-order function whose input is <code>Prop[Fin n]</code> and whose output is <code>Prop[Nat]</code> or <code>Prop[Int]</code>  (where <code>Prop[X]</code> indicates type parametrization).  In fact, knowing that a <code>Fin</code> is a 2-tuple of <code>Nat</code> and a proof of limited range, that makes it sound like it should be <em>easy</em>.</p>",
        "id": 517260071,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1746884963
    },
    {
        "content": "<p>The proof you posted reduces the question to (amongst other things)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">an</span>\n</code></pre></div>\n<p>where the variables are all terms of type <code>Fin 1000000000</code>. But this goal is simply not true. it's true for integers, but it's not true for <code>Fin 1000000000</code> because addition and subtraction \"wrap\", so the sum of two big things can be a small thing. As an explicit counterexample try an=0, bn=1 and m=100. Thenn an-bn=999999999 . Perhaps this is a clearer explanation why your hopes that you can just replace a term of type Fin n with an integer can't possibly work.</p>",
        "id": 517260380,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746885217
    },
    {
        "content": "<blockquote>\n<p>\"all\" I am asking for is a higher-order function whose input is <code>Prop[Fin n]</code> and whose output is <code>Prop[Nat]</code></p>\n</blockquote>\n<p>What if the statement you're making about Fin n simply doesn't make sense for general naturals, for example what if it involves something like a real number x such that sin(x) = a/n? This is fine if a&lt; n but doesn't make sense in general. This is exactly why you have to carry around the proof that a &lt; n, and that's why you can see <code>ha'</code> in your goal.</p>",
        "id": 517260525,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746885349
    },
    {
        "content": "<p>I guess I oversimplified the example a bit too much, then.  It <em>is</em> true, because of known constraints on the variables (in this case of the proof, we know <code>an - bn &gt;= 0</code>, because if that weren't true we would be on the other side of the disjunction) and because the <em>arithmetic</em> is (supposed to be) carried out in ℤ even though the input variables are all Fin.</p>",
        "id": 517260752,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1746885511
    },
    {
        "content": "<p>You still need to prove it's true</p>",
        "id": 517264229,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746888347
    },
    {
        "content": "<p>Can we please not wander off into the weeds from the original questIon? The problem I'm having is not proving the statement on paper.  The problem I'm having is conveying the proof to Lean in a way that it accepts.</p>",
        "id": 517264465,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1746888512
    },
    {
        "content": "<p>Sure, but can you tell us what things appear in your proof? What people have been telling you so far is that whether what you are asking for is possible depends on what functions appear in your proof</p>",
        "id": 517264672,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1746888675
    },
    {
        "content": "<p>I posted the whole thing just now (as much as I have) in the program verification channel</p>",
        "id": 517264806,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1746888803
    },
    {
        "content": "<p><a class=\"stream-topic\" data-stream-id=\"236449\" href=\"/#narrow/channel/236449-Program-verification/topic/Proving.20equivalence.20of.20two.20versions.20of.20a.20function/with/517263346\">#Program verification &gt; Proving equivalence of two versions of a function</a> for those who are not subscribed</p>",
        "id": 517264942,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1746888905
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"902878\">Zack Weinberg</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Fin.20to.20Int.20.2B.20inequality.20hypotheses/near/517260752\">said</a>:</p>\n<blockquote>\n<p>I guess I oversimplified the example a bit too much, then. </p>\n</blockquote>\n<p>Yes, you threw away the hypothesis which you need.</p>\n<blockquote>\n<p>It <em>is</em> true, because of known constraints on the variables (in this case of the proof, we know <code>an - bn &gt;= 0</code></p>\n</blockquote>\n<p>You are not thinking clearly enough here. The statement <code>an - bn &gt;= 0</code> is <em>always</em> true, whatever the values of an and bn, in Lean, because <code>an - bn</code> is a term of type <code>Fin 1000000000</code> and all terms of this type are <code>&gt;= 0</code>. Whether you do the subtraction in <code>Fin 1000000000</code> or in the integers really matters here. Lean is keeping careful track of whether you're talking about integers or terms of type <code>Fin 1000000000</code>, and if you want to prove this result in Lean then you have to do this too.</p>\n<blockquote>\n<p>, because if that weren't true we would be on the other side of the disjunction) and because the <em>arithmetic</em> is (supposed to be) carried out in ℤ even though the input variables are all Fin.</p>\n</blockquote>\n<p>You say that, but the subtraction in your question is <em>not</em> carried out in ℤ. It is carried out in <code>Fin 1000000000</code>. It is not easy to move between the two types whilst doing arithmetic (addition and subtraction) because they do not agree in general. Have you formalized the statement of what you want to prove correctly? Perhaps this is your problem?</p>\n<blockquote>\n<p>Can we please not wander off into the weeds from the original questIon?</p>\n</blockquote>\n<p>I'm afraid that the very nature of formalization is that one has to have a super-precise understanding of exactly what one is talking about. Your entire thesis in this conversation has been \"I want to freely switch between <code>Fin n</code> and integers and everything should be fine\" and this is simply not true -- the weeds are there. Addition and subtraction depend on which type you're operating on and give different answers. Are you clear that 0 - 1 = 999999999 in <code>Fin 1000000000</code>? And that it is not true that a &lt;= b implies a + t &lt;= b + t in <code>Fin 1000000000</code>?</p>",
        "id": 517269360,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746892132
    },
    {
        "content": "<p>What would you expect to happen if the goal had a <code>Fin</code>-specific function like <code>Fin.rev</code> in it?</p>",
        "id": 517811106,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1747137723
    },
    {
        "content": "<p>So It Turns Out That a whole lot of the problem I was having boiled down to I <em>thought</em> <code>Fin</code> addition would produce a number with a raised bound, but actually it wraps! Therefore my original conversion from C to Lean was wrong.</p>\n<p>I could swear I read documentation that specifically said if you add <code>a: Fin m</code> to <code>b: Fin n</code> the addition is carried out in <code>Nat</code> and the result has type <code>Fin (m + n)</code>.  I can't find it anymore though.  Perhaps it was Lean 3 documentation?</p>",
        "id": 518137925,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1747248750
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"902878\">Zack Weinberg</span> has marked this topic as resolved.</p>",
        "id": 518138737,
        "sender_full_name": "Notification Bot",
        "timestamp": 1747249027
    },
    {
        "content": "<p>Maybe you read <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.addNat#doc\">docs#Fin.addNat</a> ? Otherwise <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.add#doc\">docs#Fin.add</a> pretty clearly says that addition is taken mod n</p>",
        "id": 518138818,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1747249062
    },
    {
        "content": "<p>It was not either of those. It was an overview of <code>Fin</code>, not the reference for any specific operator.</p>",
        "id": 518139706,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1747249338
    },
    {
        "content": "<p>Ah I see! If you find it again, let us know so that we can <span aria-label=\"fire\" class=\"emoji emoji-1f525\" role=\"img\" title=\"fire\">:fire:</span> it</p>",
        "id": 518140000,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1747249443
    }
]