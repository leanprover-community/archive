[
    {
        "content": "<p>Is there a way to prove this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">nan</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">0</span>\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">nan</span><span class=\"w\"> </span><span class=\"bp\">!=</span><span class=\"w\"> </span><span class=\"n\">nan</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">nan</span><span class=\"w\"> </span><span class=\"bp\">!=</span><span class=\"w\"> </span><span class=\"n\">nan</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span>\n</code></pre></div>\n<p>Evaluating <code>nan != nan</code> directly gives a boolean answer</p>",
        "id": 499119436,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1739318347
    },
    {
        "content": "<p>no</p>",
        "id": 499120354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739318784
    },
    {
        "content": "<p>well, you can use <code>native_decide</code></p>",
        "id": 499120366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739318792
    },
    {
        "content": "<p>but the float functions are otherwise opaque</p>",
        "id": 499120403,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739318809
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Proving.20nan.20!.3D.20nan/near/499120366\">said</a>:</p>\n<blockquote>\n<p>well, you can use <code>native_decide</code></p>\n</blockquote>\n<p>How does this thing work? When I use <code>#print</code> I only see an <code>_auxLemma</code></p>",
        "id": 499120574,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1739318901
    },
    {
        "content": "<p>it runs eval and trusts the result</p>",
        "id": 499120817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739319077
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> has marked this topic as resolved.</p>",
        "id": 499120859,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739319118
    },
    {
        "content": "<p>the underlying mechanism is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.reduceBool#doc\">docs#Lean.reduceBool</a>, which is an opaque function which, when reduced in the kernel, will run the interpreter on the argument, plus an axiom saying that it is the identity function (and hence the eval result is consistent with the actual definition of the function)</p>",
        "id": 499120976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739319178
    },
    {
        "content": "<p>Apologies for unresolving the topic.</p>\n<p>I'm trying to understand if it is ok to use <code>==</code> in my theorems. An example theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"o\">:</span><span class=\"mf\">2.0</span><span class=\"bp\">==</span><span class=\"mf\">2.0</span><span class=\"o\">:=</span><span class=\"n\">bysafe_tactic_please</span>\n</code></pre></div>\n<p>But the description of <code>native_decide</code> sounds scary:</p>\n<div class=\"codehilite\" data-code-language=\"txt\"><pre><span></span><code>native_decide is a synonym for decide +native. It will attempt to prove a goal of type p by synthesizing an instance of Decidable p and then evaluating it to isTrue ... Unlike decide, this uses #eval to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted part, and the axiom Lean.ofReduceBool will show up in #print axioms for theorems using this method or anything that transitively depends on them. Nevertheless, because it is compiled, this can be significantly more efficient than using decide, and for very large computations this is one way to run external programs and trust the result.\n\nexample : (List.range 1000).length = 1000 := by native_decide\n</code></pre></div>\n<p>is it really safe to use <code>native_decide</code>?</p>",
        "id": 499313955,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739389044
    },
    {
        "content": "<p>if I want to make a universal theorem about floats, is the approach to do: </p>\n<blockquote>\n<p>For all floats except nan, some property f holds?</p>\n</blockquote>\n<p>eg pseudo Lean4</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">uni</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"k\">forall</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mf\">0.0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"w\"> </span><span class=\"mf\">1.0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mf\">0.0</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"c1\">-- 1 native_decide</span>\n<span class=\"c1\">-- 2, 3 more tactics that work</span>\n</code></pre></div>\n<p>PS: How do I say, except Nan? Or make theorems about floats?</p>",
        "id": 499314707,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739389277
    },
    {
        "content": "<p>Floats are tricky to prove anything about, since they're opaque and have no axioms. Using <code>native_decide</code> pulls in the runtime characteristics of <code>Float</code> to prove things.</p>\n<p>Something you might consider instead is to work with some abstract type that has the axioms you need (maybe a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearOrderedRing#doc\">docs#LinearOrderedRing</a> ?), then you can pretend that <code>Float</code> satisfies these axioms at evaluation time. It's not 100% correct to do this though, since it's an approximation (for example, with floats <code>a + b = a</code> does not imply <code>b = 0</code>). I think <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> has experience with this in SciLean.</p>",
        "id": 499316586,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739389928
    },
    {
        "content": "<p>Not ideal, but I think I'm ok for now to use runtime characteristics to do proofs (or at least theorems). What I'm confused is that I can't seem to identify the pattern of when to use <code>=</code> vs <code>==</code>. Eg</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"mf\">2.0</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mf\">2.0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mf\">2.0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"c1\">-- example : 2.0 = 2.0 := by native_decide -- FAILS</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"mf\">2.0</span>\n<span class=\"c1\">-- example : 2.0 == 2.0 := by rfl -- FAILS</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mf\">2.0</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mf\">2.0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n</code></pre></div>",
        "id": 499319316,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739390878
    },
    {
        "content": "<p><del>Ok so from my above \"experiment\" I think <code>==</code> and <code>by native_decide</code> seems to always work while <code>rfl</code> does not always work.</del></p>",
        "id": 499319561,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739390981
    },
    {
        "content": "<p>Ok I think <code>==</code> with <code>by naitve_decide</code> seems to satisfy the English specs I said (\"I'm ok with run time evals\")</p>",
        "id": 499319782,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739391056
    },
    {
        "content": "<p>Since decidable equality with floats doesn't exist so I think <code>=</code> and <code>rfl</code> doesn't always work? (though idk of an example).</p>",
        "id": 499319878,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739391101
    },
    {
        "content": "<p><code>rfl</code> can prove <code>2.0 = 2.0</code> since the LHS and RHS are identical, so <code>Eq.refl</code> can apply.</p>\n<p>You're correct that there's no DecidableEq instance for <code>Float</code>, so it's not possible to synthesize an algorithm to calculate whether or not <code>2.0 = 2.0</code>.</p>\n<p>The reason <code>2.0 == 2.0</code> can be evaluated is that <code>==</code> is Bool-valued, so there's no need to synthesize an algorithm (<code>==</code> is already an algorithm, and it uses the runtime <code>==</code> for <code>Float</code>)</p>",
        "id": 499320501,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739391352
    },
    {
        "content": "<p>Ignoring the <code>nan</code> issue (ie <code>nan != nan</code>), which is a big issue I think for my goals (doing universal theorems about floats). Can universal theorems about floats be made with <code>==</code>?</p>\n<p>E.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">truncateNumber</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">.</span><span class=\"n\">floor</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">truncateNumber_correct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">truncateNumber</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">.</span><span class=\"n\">floor</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">truncateNumber</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">truncateNumber</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Is <code>=</code> or <code>==</code> the right thing to do?</p>\n<p>PS: I know it's a little silly, but I'm just trying to figure out how to make universal theorems about floats that are sensible (even if not perfect). If possible.</p>",
        "id": 499322183,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739391909
    },
    {
        "content": "<p>I'd think this isn't possible</p>",
        "id": 499322786,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739392136
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Proving.20nan.20!.3D.20nan/near/499322786\">said</a>:</p>\n<blockquote>\n<p>I'd think this isn't possible</p>\n</blockquote>\n<p>what about this hack?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nan</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mf\">0.0</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mf\">0.0</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">truncateNumber_correct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">nan</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">truncateNumber</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">.</span><span class=\"n\">floor</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">truncateNumber</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">truncateNumber</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>since <code>rfl</code> works on floats per your comment, it seems the above is an ok candidate?</p>",
        "id": 499323760,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739392496
    },
    {
        "content": "<p>(Potentially one could admit a decision procedure as an extra axiom that checks your theorem for all possible <code>x</code>; there are at most 2^64 values, which is theoretically possible to exhaust, but practically you might not want to wait that long.)</p>",
        "id": 499323777,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739392501
    },
    {
        "content": "<p>ah I see, so the issue is that evaluate needs an actual float to work.</p>",
        "id": 499323861,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739392535
    },
    {
        "content": "<p>In <code>truncateNumber_correct</code>, you can prove <code>truncateNumber x = x - Float.floor x</code> using <code>rfl</code> (that's true by definition of <code>truncateNumber</code>), but you can't get the inequalities without additional Float axioms.</p>",
        "id": 499324108,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739392619
    },
    {
        "content": "<p>You could add Float axioms yourself though. Maybe it's worth doing? You'll have to be very careful since these won't be machine-verified; though with some effort you could do some testing to see they aren't immediately refuted.</p>",
        "id": 499324394,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739392727
    },
    {
        "content": "<p>I don't know if I have time to do that (or if I'm the right person). Let me think about it. I think I'm ok at least with a sorry proof that uses the correct version of <code>=</code> or <code>==</code> for now.</p>",
        "id": 499325034,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739392967
    },
    {
        "content": "<p>as a ugly hack I could do an existential quantifier and use <code>==</code> for the first one, but it wouldn't fix the inequalities issues (since the rest of the infrastructure for floats doesn't exist)</p>",
        "id": 499325980,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739393359
    },
    {
        "content": "<p>actually even an existential might work for inequalities:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- 1) Basic test case: 3.5 → 0.5</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">truncateNumber</span><span class=\"w\"> </span><span class=\"mf\">3.5</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">truncateNumber</span><span class=\"w\"> </span><span class=\"mf\">3.5</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mf\">0.5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n\n<span class=\"c1\">-- 2) Small decimal part: 1.33 → 0.33</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">truncateNumber</span><span class=\"w\"> </span><span class=\"mf\">1.33</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">.</span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">truncateNumber</span><span class=\"w\"> </span><span class=\"mf\">1.33</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mf\">0.33</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"n\">e</span><span class=\"bp\">-</span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">native_decide</span>\n</code></pre></div>\n<p>but it's very hacky</p>",
        "id": 499326198,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739393447
    },
    {
        "content": "<p>I think </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">truncateNumber_correct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">.</span><span class=\"n\">isNaN</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">.</span><span class=\"n\">isInf</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">  </span><span class=\"n\">truncateNumber</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">.</span><span class=\"n\">floor</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">truncateNumber</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">truncateNumber</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>is ok? (after I hypothetically make the Floats library properly some day)</p>",
        "id": 499327177,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739393873
    },
    {
        "content": "<p>does floats exist in Isabelle or Coq perhaps to help me?</p>",
        "id": 499327198,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739393882
    },
    {
        "content": "<p>or a close language to Lean 4</p>",
        "id": 499327253,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739393891
    },
    {
        "content": "<p>coq has a nice float library called flocq</p>",
        "id": 499339793,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739399000
    },
    {
        "content": "<p>Just curious, why do you need theorems about <code>Float</code>s?</p>",
        "id": 499349306,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1739403667
    },
    {
        "content": "<p>as far as I know, Real numbers don't exist in real programs used in practice and I wanted to formalize programs more similar to real programs used in practice in Lean 4 (I admit I'd likely start with very toy examples)</p>",
        "id": 499354534,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739406760
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Proving.20nan.20!.3D.20nan/near/499339793\">said</a>:</p>\n<blockquote>\n<p>coq has a nice float library called flocq</p>\n</blockquote>\n<p>amazing! thank you Mario!</p>",
        "id": 499354558,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1739406778
    },
    {
        "content": "<p>Skimming the flocq docs, it looks like it builds a model of floating point from scratch, without referencing the native type.</p>",
        "id": 499361264,
        "sender_full_name": "Chris Wong",
        "timestamp": 1739411040
    },
    {
        "content": "<p>You can try to write axioms about <code>Float</code> that implement some official specifications.</p>",
        "id": 499362324,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1739411742
    },
    {
        "content": "<p>Or you can write a type class <code>LawfulFloat</code> and assume it whenever you prove something about floats.</p>",
        "id": 499362439,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1739411824
    },
    {
        "content": "<p>Then one can verify your axioms for a specific system (hardware, OS, compiler) by checking all possible values (probably, takes a lot of time).</p>",
        "id": 499362568,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1739411929
    },
    {
        "content": "<p>What about writing an IEEE754 float implementation in Lean? Just like software float library in C/C++ which uses int64 to simulate double.</p>",
        "id": 499382252,
        "sender_full_name": "Jz Pan",
        "timestamp": 1739424401
    },
    {
        "content": "<p>AFAIU, you can do it but it won't use the hardware/OS/compiler-provided float, so it will be slower.</p>",
        "id": 499384356,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1739425866
    },
    {
        "content": "<p>Possibly, you can have both, but I don't know how to do it.</p>",
        "id": 499384377,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1739425884
    },
    {
        "content": "<p>I seem to recall someone actually working on a verified implementation of float?</p>",
        "id": 499390755,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739429543
    },
    {
        "content": "<p>Right, discord user rob_23oba mentioned working on IEEE-754 compliant floats</p>",
        "id": 499391685,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739430009
    },
    {
        "content": "<p>If at some point there is a successful community library that exposes a typeclass like <code>IsIEEECompliantFloat</code>, provides an instance of this class using a pure Lean implementation of IEEE-754 floats (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FP.Float#doc\">docs#FP.Float</a> ?) and proves useful theorems about floats, then the FRO will be very interested in exploring ways of modifying Lean's native <code>Float</code> type so that it is possible to instantiate <code>IsIEEECompliantFloat Float</code>.</p>",
        "id": 499394462,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1739431356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Proving.20nan.20!.3D.20nan/near/499394462\">said</a>:</p>\n<blockquote>\n<p><code>IsIEEECompliantFloat Float</code></p>\n</blockquote>\n<p>I don't think this makes sense, as it's not the type <code>Float</code> being IEEE-754 compliant, but the functions on <code>Float</code> are IEEE-754 compliant: add, subtract, etc., and sin, cos, ...</p>",
        "id": 499494307,
        "sender_full_name": "Jz Pan",
        "timestamp": 1739458581
    },
    {
        "content": "<p>Is this declaration ABI correct?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">unbox</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">MyFloat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ofRaw</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">toRaw</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span>\n</code></pre></div>",
        "id": 499497586,
        "sender_full_name": "Jz Pan",
        "timestamp": 1739459368
    },
    {
        "content": "<p>no, it would need to be wrapping a <code>Float</code></p>",
        "id": 499509666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739461874
    },
    {
        "content": "<p><code>float</code> and <code>double</code> are different from <code>uintN_t</code> in the C ABI</p>",
        "id": 499509779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739461901
    },
    {
        "content": "<p>e.g on intel floats are passed in the float registers in the calling convention</p>",
        "id": 499509991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739461937
    },
    {
        "content": "<p>If your structure wraps an integer, that would also imply that you're formalizing at IEEE specification level 4, where the choices of NaN payloads are significant (and those often differ between implementations - and even between different instructions on the same architecture, e.g. x87 and SSE floating point have different rules for choosing the payload resulting from an operation between two NaNs). IEEE specification level 3, where most (not all) things are fully specified in IEEE 754, is probably a better option for formalization for most purposes.</p>",
        "id": 499612633,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1739493349
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Proving.20nan.20!.3D.20nan/near/499494307\">schrieb</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Proving.20nan.20!.3D.20nan/near/499394462\">said</a>:</p>\n<blockquote>\n<p><code>IsIEEECompliantFloat Float</code></p>\n</blockquote>\n<p>I don't think this makes sense, as it's not the type <code>Float</code> being IEEE-754 compliant, but the functions on <code>Float</code> are IEEE-754 compliant: add, subtract, etc., and sin, cos, ...</p>\n</blockquote>\n<p>I'd think that <code>IsIEEECompliantFloat α</code> would be a type class like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsIEEECompliantFloat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fmt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BinaryFloatFormat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Sub</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Neg</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Div</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">BinaryFloat</span><span class=\"w\"> </span><span class=\"n\">fmt</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">apply_add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">  </span><span class=\"n\">apply_sub</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ...</span>\n<span class=\"w\">  </span><span class=\"n\">apply_sqrt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span>\n</code></pre></div>\n<p>And then you could make an instance of it with all of <code>Float</code>s normal functions/instances and there you have your assertion that the <code>Float</code> functions work.<br>\n(note that <code>sin</code>, <code>cos</code>, <code>pow</code>, etc. are weird cases because the standard doesn't define them and they are usually defined from the other existing functions, so we don't put those here)</p>",
        "id": 500039343,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739735251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Proving.20nan.20!.3D.20nan/near/499497586\">schrieb</a>:</p>\n<blockquote>\n<p>Is this declaration ABI correct?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">unbox</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">MyFloat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ofRaw</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">toRaw</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Lean already makes a special case for <code>Float</code>s, <code>UInt</code>s, etc. so while this is not correct as an ABI, the compiler will take care of that (if your type would be called <code>Float</code>, that is). Like Joseph said, this would imply multiple NaNs which can get in the way of proofs (e.g. proving <code>x + nan = nan</code> would be impossible because it actually isn't true on some platforms where the left hand side would turn out to be a different NaN than the right hand side). I thought of an approach that might solve this though: separate <code>Float</code> into a <code>NativeFloat</code> with multiple NaNs which has a similar definition as yours and then the normal <code>Float</code> which is merely a quotient on <code>NativeFloat</code> that makes all NaNs equal. The advantage of this approach is that we can treat <code>Float</code> and <code>NativeFloat</code> as normal types and use <code>match</code> and everything like usual, similar to how <code>Array</code> works. A definition as an inductive would make this more difficult because then you'd need to emit code that checks <code>isNaN</code>, <code>isInf</code>, etc. and decode everything.</p>",
        "id": 500040459,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739736090
    },
    {
        "content": "<p>Lean's functions on <code>Float</code> already check for nans and ensure that you can't get at payload bits using e.g. <code>toBits</code>, which would otherwise result in nondeterminism in opaque functions and hence UB (because lean logical functions must be deterministic)</p>",
        "id": 500042122,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739737531
    },
    {
        "content": "<p>The inductive type which is isomorphic to <code>Float</code> is the one where there is exactly one <code>nan</code> value</p>",
        "id": 500042205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739737581
    },
    {
        "content": "<p>I would encourage anyone wanting to improve the state of lean floats to PR something to Batteries</p>",
        "id": 500042337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739737693
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Proving.20nan.20!.3D.20nan/near/500039343\">said</a>:</p>\n<blockquote>\n<p>(note that <code>sin</code>, <code>cos</code>, <code>pow</code>, etc. are weird cases because the standard doesn't define them and they are usually defined from the other existing functions, so we don't put those here)</p>\n</blockquote>\n<p>The standard does define them, as recommended operations (see subclause 9.2). I don't think the difference between recommended and required operations is very important for formalization, except that IEEE 754 is a complicated enough standard that there are many more important operations that would be higher priority. (And if you wanted computable definitions rather than just relying on tactics for computation, computable versions of those functions would be a lot more complicated to write than either noncomputable versions or computable versions of the required operations.)</p>",
        "id": 500061456,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1739754087
    },
    {
        "content": "<p>I think the IEEE754 standard permits different NaNs, at least there are sNaN and qNaN, both of them can have payloads, see <a href=\"https://en.wikipedia.org/wiki/Double-precision_floating-point_format\">https://en.wikipedia.org/wiki/Double-precision_floating-point_format</a> and <a href=\"https://en.wikipedia.org/wiki/NaN\">https://en.wikipedia.org/wiki/NaN</a></p>",
        "id": 500102283,
        "sender_full_name": "Jz Pan",
        "timestamp": 1739777551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Proving.20nan.20!.3D.20nan/near/500061456\">schrieb</a>:</p>\n<blockquote>\n<p>The standard does define them, as recommended operations</p>\n</blockquote>\n<p>Yes but pretty much no implementation of floating point will actually give you the <em>exact</em> result, they will all be incorrect by 1 ulp in a few places. So writing a definition of <code>sin</code> that e.g. works as rounding <code>Real.sin</code> would be probably correct per specification but will still differ from the implementations that are provided by math libraries. This makes it pretty difficult to formalize, since you'd somehow have to write a definition that allows for rounding errors in the actual implementation. Besides, <code>Real.sin</code> is not in core lean, so you'd have to still write some of it yourself.</p>",
        "id": 500104113,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739778166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Proving.20nan.20!.3D.20nan/near/500102283\">schrieb</a>:</p>\n<blockquote>\n<p>I think the IEEE754 standard permits different NaNs, at least there are sNaN and qNaN, both of them can have payloads, see <a href=\"https://en.wikipedia.org/wiki/Double-precision_floating-point_format\">https://en.wikipedia.org/wiki/Double-precision_floating-point_format</a> and <a href=\"https://en.wikipedia.org/wiki/NaN\">https://en.wikipedia.org/wiki/NaN</a></p>\n</blockquote>\n<p>Yes, but multiple NaNs get in the way of proofs because different implementations handle them differently, so <code>nan:0x403124 + nan:0x341003</code> might be <code>nan:0x403124</code> or <code>nan:0x741003</code> or <code>-nan:0x400000</code> or whatever. You can't really prove useful things about NaN with such a definition.</p>",
        "id": 500105252,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739778505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Proving.20nan.20!.3D.20nan/near/500105252\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Proving.20nan.20!.3D.20nan/near/500102283\">schrieb</a>:</p>\n<blockquote>\n<p>I think the IEEE754 standard permits different NaNs, at least there are sNaN and qNaN, both of them can have payloads, see <a href=\"https://en.wikipedia.org/wiki/Double-precision_floating-point_format\">https://en.wikipedia.org/wiki/Double-precision_floating-point_format</a> and <a href=\"https://en.wikipedia.org/wiki/NaN\">https://en.wikipedia.org/wiki/NaN</a></p>\n</blockquote>\n<p>Yes, but multiple NaNs get in the way of proofs because different implementations handle them differently, so <code>nan:0x403124 + nan:0x341003</code> might be <code>nan:0x403124</code> or <code>nan:0x741003</code> or <code>-nan:0x400000</code> or whatever. You can't really prove useful things about NaN with such a definition.</p>\n</blockquote>\n<p>You can only prove things for a specific <strong>software</strong> IEEE-754 float implementation. But not the hardware <code>Float</code>.</p>",
        "id": 500218726,
        "sender_full_name": "Jz Pan",
        "timestamp": 1739806064
    },
    {
        "content": "<p>Optionally, <code>native_decide</code> can add axiom that software float is coincide with hardware float when there are no NaNs.</p>",
        "id": 500219031,
        "sender_full_name": "Jz Pan",
        "timestamp": 1739806134
    },
    {
        "content": "<p>... and that could probably prove <code>False</code> easily.</p>",
        "id": 500219123,
        "sender_full_name": "Jz Pan",
        "timestamp": 1739806157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> has marked this topic as unresolved.</p>",
        "id": 500224039,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739807300
    },
    {
        "content": "<p>Instead of adding an axiom, you can add a typeclass <code>[LawfulFloat Float]</code> as outlined above. Then your theorems will be conditional to <code>Float</code> being lawful.</p>",
        "id": 500224226,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1739807351
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Proving.20nan.20!.3D.20nan/near/500104113\">said</a>:</p>\n<blockquote>\n<p>Yes but pretty much no implementation of floating point will actually give you the <em>exact</em> result, they will all be incorrect by 1 ulp in a few places.</p>\n</blockquote>\n<p>IIRC <code>Float.sin</code> is off by <a href=\"https://randomascii.wordpress.com/2014/10/09/intel-underestimates-error-bounds-by-1-3-quintillion/\">much more than 1 ulp</a> on intel because they got pi wrong in the argument reduction step. I think this is in the spec now(!)</p>",
        "id": 500282257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739830346
    },
    {
        "content": "<p>Is that like the Indiana pi bill?</p>",
        "id": 500283049,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1739830768
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Proving.20nan.20!.3D.20nan/near/500042337\">schrieb</a>:</p>\n<blockquote>\n<p>I would encourage anyone wanting to improve the state of lean floats to PR something to Batteries</p>\n</blockquote>\n<p>I'd be happy to PR something to Batteries! However, I tried defining a type similar to flocq and ran into issues writing the proof required for the <code>finite</code> constructor (I ended up using <code>Mathlib.Algebra.Order.Ring.Rat</code> and such). The scope for something in batteries would probably rather be an axiomatic definition of the common operations with some lemmas about <code>0</code>, <code>inf</code> and <code>nan</code> and perhaps some simprocs for reducing the float operations. This would probably mean that there'd be some code duplication for <code>Float</code> vs <code>Float32</code> though...<br>\nFor the implementation I'm thinking:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Returns whether `x` is a NaN bit pattern, that is `Float.ofBits x = Float.nan` -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">.</span><span class=\"n\">isNaNBits</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">52</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;&amp;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"n\">x7FF</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"n\">x7FF</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;&amp;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"n\">x000F_FFFF_FFFF_FFFF</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">.</span><span class=\"n\">ofBits_toBits</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ofBits</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toBits</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">.</span><span class=\"n\">toBits_ofBits_of_not_isNaNBits</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">isNaNBits</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ofBits</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toBits</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">.</span><span class=\"n\">toBits_ofBits_of_isNaNBits</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">isNaNBits</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ofBits</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toBits</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"n\">x7FF8_0000_0000_0000</span>\n</code></pre></div>\n<p>This would still leave it open how we actually define <code>Float</code> (as an inductive, a wrapper around <code>Quot (fun x y =&gt; Float.isNaNBits x ∧ Float.isNaNBits y)</code> or as quotient around a float with multiple NaNs or whatever).<br>\nThen everything else can be defined using <code>toBits</code> and <code>ofBits</code>.</p>",
        "id": 500445289,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739896916
    },
    {
        "content": "<p>I've now put my first wip draft with the simplest definitions (<code>ofBits</code>, <code>toBits</code>, <code>isNaN</code>, <code>isFinite</code>, <code>isInf</code> and <code>neg</code>) as <a href=\"https://github.com/leanprover-community/batteries/pull/1141\">batteries#1141</a> and will probably continue adding definitions and theorems. <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, if you're interested, I encourage you to take a look.</p>",
        "id": 500708711,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739987429
    },
    {
        "content": "<p>I've now proven <code>nan != nan</code> within my PR lol</p>",
        "id": 500711847,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739988439
    },
    {
        "content": "<p>You should probably merge what you have with FP.Basic in mathlib first</p>",
        "id": 500712148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739988530
    },
    {
        "content": "<p>because that's basically a port of the first few definitions in flocq</p>",
        "id": 500712198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739988545
    },
    {
        "content": "<p>I rewrote <code>FP.Basic</code> but I needed <code>Mathlib.Algebra.Order.Ring.Rat</code>. You can probably do it without but it felt too complicated otherwise.</p>",
        "id": 500712491,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739988649
    },
    {
        "content": "<p>You know, the current definition is full of <code>unsafe</code>s</p>",
        "id": 500712560,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739988673
    },
    {
        "content": "<p>the unsafes are just because someone was lazy and didn't want to prove some proof obligations</p>",
        "id": 500712628,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739988699
    },
    {
        "content": "<p>it's a <code>sorry</code> that gets past the mathlib linter</p>",
        "id": 500712753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739988737
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/zMw0O_hfFsmj_b2xWsMsDJAg/Basic.lean\">Basic.lean</a><br>\nif you're interested, the proofs aren't particularly nice though</p>",
        "id": 500712788,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739988749
    },
    {
        "content": "<p>Maybe you have some ideas how this could be ported to batteries / have a nicer proof.</p>",
        "id": 500713295,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739988922
    },
    {
        "content": "<p>hm, it might be better to PR to mathlib first then, if the maintainers are alright with it. I would like to separate out the part about upstreaming bits of rat ring theorems</p>",
        "id": 500713536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739988986
    },
    {
        "content": "<p>it might also be that this is just too annoying without an algebraic hierarchy, in which case it will have to stay in mathlib for the time being</p>",
        "id": 500713672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739989028
    },
    {
        "content": "<p>I feel like the most important things for <code>Float</code> are its relationships with <code>Rat</code> or <code>Real</code> and <code>Rat</code> doesn't have a proof framework on batteries, only on mathlib.</p>",
        "id": 500713932,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739989099
    },
    {
        "content": "<p>The basic theorems about rat should be upstreamed</p>",
        "id": 500714074,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739989136
    },
    {
        "content": "<p>that won't be enough if you need to use <code>ring</code> and <code>linarith</code>, but you can at least do manual proofs using the ring axioms that way</p>",
        "id": 500714275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739989178
    },
    {
        "content": "<p>Yeah that would probably be enough for most of what I was doing here (I mean it was mostly a manual proof)</p>",
        "id": 500714537,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739989252
    },
    {
        "content": "<p>What do you think should happen with the batteries draft PR then? Should I rather put this into a PR to mathlib?</p>",
        "id": 500715637,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739989578
    },
    {
        "content": "<p>I think so</p>",
        "id": 500716181,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739989744
    },
    {
        "content": "<p>Oh, there is also one more thing: I used <code>Nat.divFloat</code> in my definition (for convenience) but not your definition (which was wrong for subnormals and used e.g. <code>scaleB</code> and <code>div</code> through <code>inf</code> and <code>nan</code> which are things we wanted to define). Should I then just make a duplicate <code>Nat.divFloat'</code> in the mathlib pr?</p>",
        "id": 500717055,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739990018
    },
    {
        "content": "<p>I'm not sure I follow</p>",
        "id": 500717325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739990108
    },
    {
        "content": "<p>Well, you know <code>Nat.divFloat</code> from <code>Batteries.Lean.Float</code> (<a href=\"https://github.com/leanprover-community/batteries/blob/main/Batteries/Lean/Float.lean#L80\">this one</a>). I defined my own version of it that is (hopefully) correct and works with <code>toBits</code> and <code>ofBits</code> only. However, these two definitions would conflict.</p>",
        "id": 500717745,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739990240
    },
    {
        "content": "<p>I don't think the definition should use <code>Float</code> at all</p>",
        "id": 500717908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739990294
    },
    {
        "content": "<p>everything should be about the ordinary non-opaque type <code>FP.Float</code></p>",
        "id": 500717981,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739990324
    },
    {
        "content": "<p>I mean the axiomatic redefinition.</p>",
        "id": 500718013,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739990335
    },
    {
        "content": "<p>Or should I just not care about that right now?</p>",
        "id": 500718062,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739990355
    },
    {
        "content": "<p>the first task is to have a good theory of floats completely independent of lean's <code>Float</code> type</p>",
        "id": 500718148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739990381
    },
    {
        "content": "<p>once we have that we can look into what we would need to do to retrofit the theory onto <code>Float</code> via some refactoring and shuffling of theorems between repos</p>",
        "id": 500718253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739990420
    },
    {
        "content": "<p>oh, okay, yeah we can do that</p>",
        "id": 500718299,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739990443
    },
    {
        "content": "<p>so basically we just want a definition with the right mathematical properties to be a putative alternative definition of <code>Float</code></p>",
        "id": 500718363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739990474
    },
    {
        "content": "<p>ignoring issues about data representation of inductive types in the compiler</p>",
        "id": 500718416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739990494
    },
    {
        "content": "<p>Also, there was an idea I had, which is, instead of defining float (<code>FP.Float</code>) operations through natural number division, define them through an auxiliary <code>PositiveBinaryRealApprox</code> (I have not come up with a better name lol) which is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PositiveBinaryRealApprox</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">log2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"n\">approx_correct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"n\">approx_exact_iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;&lt;&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n<span class=\"w\">  </span><span class=\"n\">log2_correct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">log2</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>The reason for it being computability and having a simple connection to <code>Real</code> and making it easier to have <em>one</em> rounding function <code>def FP.Float.round (x : PositiveBinaryRealApprox) (rm : RoundingMode) : FP.Float</code>. Do you think this is a good idea?</p>",
        "id": 500719854,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1739990981
    },
    {
        "content": "<p>couldn't you use <code>Rat</code> in place of <code>PositiveBinaryRealApprox</code> for a much simpler spec?</p>",
        "id": 500976454,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1740088610
    },
    {
        "content": "<p>it also sounds kind of like you are reinventing computable reals</p>",
        "id": 500976667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1740088687
    },
    {
        "content": "<p>There's <code>sqrt</code> though</p>",
        "id": 501032048,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1740120349
    },
    {
        "content": "<p>And yes, the intention is basically computable reals but this particular version makes rounding simplest I think:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FP</span><span class=\"bp\">.</span><span class=\"n\">Float</span><span class=\"bp\">.</span><span class=\"n\">round</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sign</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PositiveBinaryRealApprox</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RoundingMode</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FP</span><span class=\"bp\">.</span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"n\">fmt</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">hinf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fmt</span><span class=\"bp\">.</span><span class=\"n\">maxExp</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">log2</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inf</span><span class=\"w\"> </span><span class=\"n\">sign</span><span class=\"w\"> </span><span class=\"k\">else</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">log2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">fmt</span><span class=\"bp\">.</span><span class=\"n\">precision</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">fmt</span><span class=\"bp\">.</span><span class=\"n\">minExp</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rounded</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">rm</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ceil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"n\">sign</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">floor</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sign</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nearest_inf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nearest_even</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">rounded</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">fmt</span><span class=\"bp\">.</span><span class=\"n\">precision</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"c1\">-- overflow</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"w\"> </span><span class=\"n\">sign</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"n\">rounded</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 501033122,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1740120915
    },
    {
        "content": "<p>The intention is obviously that we treat <code>PositiveBinaryRealApprox</code> like <code>{ x : Real // 0 &lt; x }</code> in proofs while having a computable definition.</p>",
        "id": 501033279,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1740121011
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Proving.20nan.20!.3D.20nan/near/501032048\">schrieb</a>:</p>\n<blockquote>\n<p>There's <code>sqrt</code> though</p>\n</blockquote>\n<p>While <code>sin</code>, <code>cos</code> probably won't be supported through a computable definition, <code>sqrt</code> is still one of the operations that is supported exactly on pretty much all platforms (iirc) and we should have a definition for it.</p>",
        "id": 501033722,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1740121206
    },
    {
        "content": "<p>Also rounding reals in general would also be nice</p>",
        "id": 501033797,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1740121238
    },
    {
        "content": "<p>so round reals then</p>",
        "id": 501046443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1740126070
    },
    {
        "content": "<p>no need to use computable reals here</p>",
        "id": 501046472,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1740126085
    },
    {
        "content": "<p>I guess you're right, we don't have any obligations to make this computable, this just needs to exist for specification and proof purposes. I just feel like it is weird to have everything marked <code>noncomputable</code> when you <em>can</em> compute it in theory. But you're probably right that the spec should probably be just a noncomputable definition and then you can do <code>@[csimp]</code> and whatever for computable definitions later.</p>",
        "id": 501178502,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1740168362
    },
    {
        "content": "<p>Sorry to necro this thread, but now that <code>Rat</code> is in the <code>lean4</code> repository, and we have the ability to do <code>ring</code> / <code>linarith</code> calculations using <code>grind</code>, is there more material from <code>Mathlib.Algebra.Order.Ring.Rat</code> that would need to be upstreamed in order to unblock work on a <code>Float</code> model?</p>",
        "id": 547838905,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761787764
    },
    {
        "content": "<p>(deleted) <br>\n(Sorry. I replied with misunderstand, without following the context well.)</p>",
        "id": 547856516,
        "sender_full_name": "Hagb (Junyu Guo)",
        "timestamp": 1761803421
    },
    {
        "content": "<p>Oh, I <em>do</em> have <a href=\"https://github.com/leanprover/lean4/compare/master...Rob23oba:lean4:define-float\">https://github.com/leanprover/lean4/compare/master...Rob23oba:lean4:define-float</a> if you're interested. I just haven't gotten around to putting some of the stuff in a library yet</p>",
        "id": 548012706,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1761850644
    },
    {
        "content": "<p>I haven't looked closely, but could this be done in CSLib? A floating point library there would be a great achievement.</p>",
        "id": 548037086,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761860343
    },
    {
        "content": "<p>Somewhere it would be good to have a floating-point library that's designed to be able to handle the full generality of IEEE 754 (so including in particular exceptions, rounding modes and decimal floating point), even if it doesn't handle all that to start with, so that it can be used in validating floating-point algorithms for contexts that care about those things. But that's probably larger and more complicated than would be appropriate for core Lean / Batteries (even apart from all the recommended operations whose definitions would need to depend on mathlib).</p>",
        "id": 548052301,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1761868806
    },
    {
        "content": "<p>CSLib already depends on Mathlib, so a Float library there would have access to all of Mathlib's machinery. :-)</p>",
        "id": 548067687,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761879524
    }
]