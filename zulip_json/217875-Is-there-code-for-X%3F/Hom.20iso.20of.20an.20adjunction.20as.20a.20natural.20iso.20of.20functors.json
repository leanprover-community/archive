[
    {
        "content": "<p>Do we really not have this for adjunctions? Or am I just not capable of finding it?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u₁</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u₁</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hFG</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">⊣</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">coyoneda</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">coyoneda</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">whiskeringLeft</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 471228000,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1726656449
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519559\">@Dagur Asgeirsson</span> <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span></p>",
        "id": 471228021,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1726656467
    },
    {
        "content": "<p><code>NatIso.ofComponents (fun _ ↦ NatIso.ofComponents (fun _ ↦ (hFG.homEquiv _ _).toIso))</code> works, I'm not sure if we have this as a definition in mathlib</p>",
        "id": 471228600,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1726656653
    },
    {
        "content": "<p>I think I'll add it under the def of <code>Adjunction.homEquiv</code>...</p>",
        "id": 471238021,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1726659834
    },
    {
        "content": "<p>Do we generally prefer to chain isos in e.g. <code>Cᵒᵖ ⥤ D ⥤ Type v₁</code> instead of chaining type equivalences in proofs? Feels to me that from an aesthetic point of view the former is preferrable, but I'm not sure about performance...</p>",
        "id": 471238613,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1726660013
    },
    {
        "content": "<p>In a similar vein I think we also could use a version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.colimCoyoneda#doc\">docs#CategoryTheory.Limits.colimCoyoneda</a> which for the case where the lift isn't required</p>",
        "id": 471257483,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1726665524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Hom.20iso.20of.20an.20adjunction.20as.20a.20natural.20iso.20of.20functors/near/471238613\">said</a>:</p>\n<blockquote>\n<p>Do we generally prefer to chain isos in e.g. <code>Cᵒᵖ ⥤ D ⥤ Type v₁</code> instead of chaining type equivalences in proofs? Feels to me that from an aesthetic point of view the former is preferrable, but I'm not sure about performance...</p>\n</blockquote>\n<p>As long as you do not need to evaluate morphisms at elements (i.e. everything works as if <code>Type _</code> was replaced by any generic category), it is certainly ok to use isos, but otherwise, I prefer type equivalences over isomorphisms in <code>Type*</code> (one of the reasons is that it is possible to phrase equivalences between types in different universes...). For example, I was very much in favor of the refactor part of <a href=\"https://github.com/leanprover-community/mathlib4/pull/12041\">#12041</a>, where <code>yonedaEquiv</code> was redefined directly as an equivalence rather than obtained from an isomorphism in <code>Type _</code>.</p>",
        "id": 471269851,
        "sender_full_name": "Joël Riou",
        "timestamp": 1726668692
    },
    {
        "content": "<p>Not sure if I understand what you mean, I wasn't talking about equivs vs isos in <code>Type _</code></p>",
        "id": 471271074,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1726669023
    },
    {
        "content": "<p>But about proving things pointwise when they can be proven pointfree (not sure if that is the correct term)</p>",
        "id": 471271379,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1726669099
    },
    {
        "content": "<p>The above example is the \"pointfree\" version of what <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Adjunction.homEquiv#doc\">docs#CategoryTheory.Adjunction.homEquiv</a> is pointwise. When constructing more complex <code>NatIso</code>s , the choice is between using <code>NatIso.ofComponents</code> on the whole composite chain of type equivalences vs to use building blocks like the example above.</p>",
        "id": 471272350,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1726669377
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 471272803,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1726669501
    }
]