[
    {
        "content": "<p>Do we have any existing code for quotients of semimodules <code>Module R S</code>s without <code>AddCommGroup S</code>? In the process of writing <code>⨂[R] i, A i ≃ FreeProduct R A</code> (assuming commutativity) I've yak-shaved myself into proving the first isomorphism theorem for noncommutative semirings, and finding myself reinventing a bunch of the <code>Submodule.Quotient</code> API in the process.</p>\n<p>(I'm essentially writing down an API for <code>Ideal</code>s of <code>Semiring</code>s that can be used with <code>RingQuot</code> more freely.)</p>",
        "id": 455498450,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722465240
    },
    {
        "content": "<p>Also <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> how's that Lawvere theory PR coming along :p</p>",
        "id": 455498549,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722465260
    },
    {
        "content": "<p>Sorry! I’ve been crazy busy lately. But I’m working on it slowly but surely</p>",
        "id": 455498949,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1722465436
    },
    {
        "content": "<p>All good, heh. I probably wouldn't be able to use it here anyway since Mathlib seems to want to <em>avoid</em> making everything depend on category theory for some reason... (which seems like it kind of nullifies the best strengths of category theory, that you can get a whole bunch of deep/important and very general theorems about structure without having to drill down into the structure, but oh well!)</p>",
        "id": 455499146,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722465533
    },
    {
        "content": "<p>But it'd be nice to be able to at least check if whatever subgoal I'm trying to prove is in fact <em>true</em> if I'm unsure :V</p>",
        "id": 455499194,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722465561
    },
    {
        "content": "<p>I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddCon.Quotient#doc\">docs#AddCon.Quotient</a> might be what you want?</p>",
        "id": 455778168,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722555973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/API.20for.20quotient.20semimodules.3F/near/455778168\">said</a>:</p>\n<blockquote>\n<p>I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddCon.Quotient#doc\">docs#AddCon.Quotient</a> might be what you want?</p>\n</blockquote>\n<p>Not quite, that's <em>too</em> loose. I need compatibility with scalar multiplication -- semimodule, not semigroup. Thanks tho!</p>",
        "id": 455794741,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722561006
    },
    {
        "content": "<p>Ah right, I was tricked by the fact that quotients by _submodules_ are implemented as the quotient by the underlying subgroup. I think I have a PR somewhere that adds a typeclass indicating an action is compatible with a congruence relation</p>",
        "id": 455801995,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722564747
    },
    {
        "content": "<p>(if you copy the existing pattern directly, you need a smul version of each of the three existing <code>Con</code>s)</p>",
        "id": 455802080,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722564792
    }
]