[
    {
        "content": "<p>The category theory library has a useful attribute, <code>@[reassoc]</code>, to generate a lemma <code>f â‰« (g â‰« a) = h â‰« a</code> from <code>f â‰« g = h</code>; <code>simp</code> can apply the former but not the latter after reassociating to the right. Another thing that sometimes happens is that we want to apply <code>F.map f â‰« F.map g = F.map h</code> as a simp rule, but this also will not trigger from just the original lemma; is there an attribute to automatically generate this (perhaps quantifying over all <code>F</code>)?</p>",
        "id": 514464901,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1745616463
    },
    {
        "content": "<p>i think <code>grind</code> is supposed to eesolve all such issues</p>",
        "id": 514473919,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1745622099
    },
    {
        "content": "<p>but the answer is no.</p>",
        "id": 514474008,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1745622149
    },
    {
        "content": "<p>Is there a writeup anywhere of how <code>grind</code> will deal with situations like this one? In the meantime, I <a href=\"https://gist.github.com/Vtec234/3e7320861fc2ec3b147f6d2ca193ed48\">wrote the attribute</a> by copy-pasting <code>reassoc</code>.</p>",
        "id": 514474230,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1745622321
    },
    {
        "content": "<p>Just to flag that <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> have the same thought as you in the context of Toric</p>",
        "id": 514541974,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1745676163
    },
    {
        "content": "<p>I suggest we have this in mathlib and tag every category theory lemma with this.</p>",
        "id": 514542137,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1745676277
    },
    {
        "content": "<p>It would be quite a lot of lemmas added to the <code>simp</code> set.. I am mostly using these in a particular situation where we work with <code>yoneda.map</code> a lot. You also run into the funny situation of needing all of <code>f â‰« g = h</code>, <code>f â‰« (g â‰« a) = h â‰« a</code>, <code>F.map f â‰« F.map g = F.map h</code>, and <code>F.map f â‰« (F.map g â‰« a) = F.map h â‰« a</code> which is achieved via the monstrous <code>@[functor_map (attr := reassoc (attr := simp))]</code>.</p>",
        "id": 514566441,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1745693682
    },
    {
        "content": "<p>you might call it monstrous but it's pretty cool if that works.</p>",
        "id": 514567812,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745694827
    },
    {
        "content": "<p>I think that actually the lemmas that are eligible for this new kind of auxiliary lemma generation are the same that are available for <code>reassoc</code>. So I think we don't need a new attribute at all, but merely an extension of <code>reassoc</code>.</p>",
        "id": 514574626,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1745700099
    },
    {
        "content": "<p>If you want to make it an extension of <code>reassoc</code>, be aware that I have an open PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/24303\">#24303</a>) modifying <code>reassoc</code>, so there might be some conflicts in the code.</p>",
        "id": 514628333,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1745746065
    },
    {
        "content": "<p>(push)<br>\nwe might also want attributes to convert between <code>f âˆ˜ g = h</code> and <code>f (g x) = h x</code>?</p>",
        "id": 523780237,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749741469
    },
    {
        "content": "<p>There seems to be a bunch of these sort of attributes popping up now. For example <span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> wrote <code>reassocIso</code> (which was incoporated into <code>@[reassoc]</code>), and I wrote <code>@[to_app]</code>. Both of these (essentially) do the same thing: apply a function to the type of the lemma and then apply some chosen simp lemmas. I have been wondering if there should be some more general framework/attribute for these kinds of situation. Something like <code>@[apply_fun arg]</code> where <code>arg</code> can be <code>Functor.map</code>, <code>Category.comp</code> etc.</p>\n<p>Although there will definitely be individual complications, but maybe there could be a very naive general framework that allows for specializations. For example, for <code>@[reassoc]</code> we need introduce a new morphism <code>h</code> before applying <code>.comp</code>. In <code>@[to_app]</code> we need to specialize a certain bicategory argument to <code>Cat</code> before being able to apply the function <code>NatTrans.app</code> (which also requires introducing an object <code>X</code>). The specialization here is also a bit tricky because a bicategory takes 3 universe variables, wheras <code>Cat</code> only needs two.</p>\n<p>If these were all put in the same framework then there could also maybe be some simplified notation for chaining these together in a specified way (as in <span class=\"user-mention\" data-user-id=\"128280\">@ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’</span> 's comment above). For example, it would be nice if I proved a lemma about isomorphisms in a bicategory, to be able to first specialize these using <code>.hom</code> and <code>.inv</code> and then on these new lemmas one can apply <code>NatTrans.app</code> as in <code>@[to_app]</code> (and then reassoc all the lemmas obtained).</p>",
        "id": 524057794,
        "sender_full_name": "Calle SÃ¶nne",
        "timestamp": 1749899479
    },
    {
        "content": "<p>(although I'm not sure if this can apply to <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> 's comment above, so sorry for hijacking this)</p>",
        "id": 524058018,
        "sender_full_name": "Calle SÃ¶nne",
        "timestamp": 1749899741
    },
    {
        "content": "<p>I was recently thinking about a <code>specialize</code> attribute that takes an arbitrary <code>congr()</code> pattern as its input, applies that to the lemma and runs a configurable post-processing step, e.g. apply <code>dsimp</code> on both sides. (We started hacking on this recently in our metaprogramming study group in Utrecht.)</p>",
        "id": 524067031,
        "sender_full_name": "Christian Merten",
        "timestamp": 1749909569
    },
    {
        "content": "<p>Would this be able to generate some \"simps\"-like lemmas for constructor applications? E.g  when working with sums of categories, simps can not generate lemmas that says something about a declaration specialized to an application of the constructors <code>Sum.inl</code> or <code>Sum.inr</code>, and we have to add manually lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.sum_obj_inl#doc\">docs#CategoryTheory.Functor.sum_obj_inl</a>.</p>\n<p>I guess this is applying a congr to one of the argument of the declaration rather than at its output, so might be less easy.</p>",
        "id": 524067191,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749909779
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/issues/26047\">https://github.com/leanprover-community/mathlib4/issues/26047</a></p>",
        "id": 524489815,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750177630
    },
    {
        "content": "<p>Btw there seems to be an <code>elementwise</code> attribute that I didn't know before; it automatically applies an element to an equality of commring homs</p>",
        "id": 543104982,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759599637
    }
]