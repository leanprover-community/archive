[
    {
        "content": "<p>If <code>c</code> is a partition of a type <code>α</code> (<code>setoid.is_partition c</code>), then the quotient by the equivalence relation whose classes are the elements of <code>c</code> is <code>equiv</code> to <code>c</code>, as follows, but I couldn't find it in mathlib…</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.setoid.partition</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">setoid.is_partition</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">setoid.mk_classes</span> <span class=\"n\">c</span> <span class=\"n\">hc.2</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">setoid.eqv_class_mem</span> <span class=\"n\">_</span> <span class=\"n\">c</span> <span class=\"n\">hc.2</span> <span class=\"n\">a</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">equiv.of_bijective</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">quotient.lift</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">setoid.mk_classes</span> <span class=\"n\">c</span> <span class=\"n\">hc.2</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- well defined</span>\n    <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">setoid.mk_classes</span> <span class=\"n\">c</span> <span class=\"n\">hc.2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">at</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n\n    <span class=\"n\">rw</span> <span class=\"n\">setoid.rel_iff_exists_classes</span> <span class=\"n\">at</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">setoid.classes_mk_classes</span> <span class=\"n\">at</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">hc2</span> <span class=\"o\">:=</span> <span class=\"n\">hc.2</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">setoid.eq_eqv_class_of_mem</span> <span class=\"n\">hc.2</span> <span class=\"n\">h</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">setoid.eq_eqv_class_of_mem</span> <span class=\"n\">hc.2</span> <span class=\"n\">h</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- injective</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">quotient.exists_rep</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">setoid.mk_classes</span> <span class=\"n\">c</span> <span class=\"n\">hc.2</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">quotient.exists_rep</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">setoid.mk_classes</span> <span class=\"n\">c</span> <span class=\"n\">hc.2</span><span class=\"o\">)</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">quotient.lift_mk</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">intro</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">quotient.sound</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">setoid.mk_classes</span> <span class=\"n\">c</span> <span class=\"n\">hc.2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">setoid.rel_iff_exists_classes</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">setoid.mk_classes</span> <span class=\"n\">c</span> <span class=\"n\">hc.2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">},</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">setoid.classes_mk_classes</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">setoid.eqv_class_mem</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">setoid.refl'</span> <span class=\"n\">_</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">setoid.refl'</span> <span class=\"n\">_</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- surjective</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">hu</span><span class=\"o\">⟩,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hu'</span> <span class=\"o\">:</span> <span class=\"n\">u.nonempty</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">set.nonempty_iff_ne_empty</span><span class=\"o\">,</span>\n      <span class=\"n\">intro</span> <span class=\"n\">hu'</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">hc.1</span><span class=\"o\">,</span>  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">hu'</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hu'</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"bp\">@</span><span class=\"n\">quotient.mk</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">setoid.mk_classes</span> <span class=\"n\">c</span> <span class=\"n\">hc.2</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">quotient.lift_mk</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"n\">setoid.eq_eqv_class_of_mem</span> <span class=\"n\">hc.2</span> <span class=\"n\">hu</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 355273588,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1683065123
    },
    {
        "content": "<p>The forward direction golfs to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">λ</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">q.lift_on'</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">setoid.eqv_class_mem</span> <span class=\"n\">_</span> <span class=\"n\">c</span> <span class=\"n\">hc.2</span> <span class=\"n\">a</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">subtype.ext</span> <span class=\"bp\">$</span> <span class=\"n\">set.ext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">setoid.trans'</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">setoid.trans'</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">setoid.symm'</span> <span class=\"n\">_</span> <span class=\"n\">hab</span><span class=\"o\">)⟩),</span>\n</code></pre></div>",
        "id": 355278891,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683067639
    },
    {
        "content": "<p>I have been thinking about this lately in the context of teaching, and I think the real answer is that \"the set of equivalence classes\" is not the fundamental concept in the Lean/mathlib \"foundations of mathematics\" that it is in conventional mathematics.  The lemma <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient.eq\">docs#quotient.eq</a> states that for an equivalence relation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∼</mo></mrow><annotation encoding=\"application/x-tex\">\\sim</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">∼</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, two points in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> go to the same point in the quotient <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mi mathvariant=\"normal\">/</mi><mo>∼</mo></mrow><annotation encoding=\"application/x-tex\">X/\\sim</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord\">/</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∼</span></span></span></span> if and only if they are related by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∼</mo></mrow><annotation encoding=\"application/x-tex\">\\sim</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">∼</span></span></span></span>.  In practice one uses this lemma directly without mentioning equivalence classes.</p>",
        "id": 355293665,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683076177
    },
    {
        "content": "<p>See also:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/transferring.20topological.20properties.20along.20homeomorphisms/near/275094937\">said</a>:</p>\n<blockquote>\n<p>Another thing I found strange was that we don't ever seem to use the bijection between equivalence relations and partitions (which I got Amelia to make, convinced that it would be important). My model of mathematics was that this was used absolutely everywhere; more recently I have become slightly embarrassed to even teach it to the 1st years! Someone suggested to me that it was perhaps because Lean uses type theory and has inbuilt quotients.</p>\n</blockquote>",
        "id": 355293782,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683076227
    },
    {
        "content": "<p>I actually very much prefer to teach quotients via the universal property rather than as equivalence classes (as sets). I find that students often fail to completely grasp the concept of a function (out of a quotient) being <em>well-defined</em>, and reasonably so, because (in my opinion) it's such an absurd idea. You pretend to define a function from a quotient, but really if you look you are defining a function on the prequotient and implicitly claiming it factors through the quotient. Then you say, \"wait, let's check this function is actually a function\" (??) and you proceed to prove the implicit claim. By teaching via the universal property, you force students to think about functions out of quotients as first being functions defined on the prequotient, and I think this makes it easier for them not to tie themselves in knots. </p>\n<p>My go to example for why we need to do this (i.e., define from the prequotient and check that the function respects the equivalence) is to \"define\" <code>f : ℚ → ℤ</code> by <code>f(p/q) = p + q</code>. I find that first-year students are abysmal at recognizing the problem here. I then point out the problem (e.g., what is <code>f(1/2)</code>? <code>f(2/4)</code>?), and then they understand it for that example, but they don't yet comprehend the wider issue. This then leads into an explanation that the function <code>g : ℤ × (ℤ \\ {0}) → ℤ</code> (or insert your favorite prequotient here) defined by <code>g x y := x + y</code> is perfectly valid, it just doesn't respect the equivalence relation, thereby leading to the universal property.</p>\n<p>I recently wrote up something detailing the link between Lean's <code>quotient</code> and abstract equivalence classes <code>⟦x⟧</code>, and the concrete equivalence classes as sets. It starts basically from the ground up. It purposefully mirrors some existing definitions (like <code>setoid.is_partition</code>), and even imports <code>data.setoid.partition</code>. This is only for pedagogical purposes, and it's still very rough; I basically just wrote it start-to-finish and haven't edited much, but maybe it will be useful to someone or inspire them to improve it.<br>\n<a href=\"/user_uploads/3121/c_4Fg2E_Gm3oMaRJfMF_91VK/partition.lean\">partition.lean</a></p>",
        "id": 355301658,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1683081328
    },
    {
        "content": "<p>I perfectly agree that it is not the correct point of view on the quotient.  Taking the set of equivalence classes is just a (well thought) way of constructing the quotient.</p>",
        "id": 355338870,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1683097384
    },
    {
        "content": "<p>(However, I was led to proving exactly that in Lean!)<br>\nDoes the following exist : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.setoid.partition</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">setoid.is_partition</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">finsum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"n\">nat.card</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">nat.card</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 355339162,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1683097472
    },
    {
        "content": "<p>I don’t think this lemma is true without finiteness assumptions. If you have an infinite type and take a partition with one singleton and its complement, then the rhs is zero but the lhs is one, right?</p>",
        "id": 355398433,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1683111723
    },
    {
        "content": "<p>Regarding the more general issue, I think \"use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient\">docs#quotient</a> everywhere\" is not the right approach either: the real solution is to make sure that all lemmas about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient\">docs#quotient</a> have a version for <em>a</em> quotient (i.e <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.surjective\">docs#function.surjective</a>). Then you should just prove that the function mapping an element to its class in a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/setoid.is_partition\">docs#setoid.is_partition</a> is surjective, and suddenly you wouldn’t even need to get back to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient\">docs#quotient</a> anymore</p>",
        "id": 355400854,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1683112396
    },
    {
        "content": "<p>The real reason equivalence classes aren’t the right notion is <em>not</em> that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient\">docs#quotient</a> is better. It’s that the construction that is used shouldn’t matter in the first place.</p>",
        "id": 355401299,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1683112511
    },
    {
        "content": "<p>(Except if you care about the nice definitional equalities provided by <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quot\">docs#quot</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient\">docs#quotient</a>)</p>",
        "id": 355402931,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1683112941
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/set.20of.20equivalences.20classes.20is.20equiv.20to.20quotient/near/355400854\">said</a>:</p>\n<blockquote>\n<p>the real solution is to make sure that all lemmas about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient\">docs#quotient</a> have a version for <em>a</em> quotient (i.e <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.surjective\">docs#function.surjective</a>).</p>\n</blockquote>\n<p>Often an even better solution is to have a version for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.right_inverse\">docs#function.right_inverse</a></p>",
        "id": 355421652,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683117092
    },
    {
        "content": "<p>Sure, but you can easily go from one to another in theory</p>",
        "id": 355422335,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1683117242
    },
    {
        "content": "<p>Here's a proof of the two statements with a bunch of API that feels reasonable.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.setoid.partition</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.finprod</span>\n<span class=\"kn\">import</span> <span class=\"n\">set_theory.cardinal.finite</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">setoid.classes_ker_of_surjective</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">setoid.ker</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">classes</span> <span class=\"bp\">=</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">setoid.classes</span><span class=\"o\">,</span> <span class=\"n\">set.mem_set_of</span><span class=\"o\">,</span> <span class=\"n\">set.mem_range</span><span class=\"o\">,</span> <span class=\"n\">hf.exists</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"n\">exists_congr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">],</span>\n  <span class=\"n\">refl</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">setoid.is_partition.to</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">setoid.is_partition</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">classical.some</span> <span class=\"o\">(</span><span class=\"n\">hc.2</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">exists</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">classical.some_spec</span> <span class=\"o\">(</span><span class=\"n\">hc.2</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">exists</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">setoid.is_partition.mem_to</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">setoid.is_partition</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">hc.to</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">classical.some_spec</span> <span class=\"o\">(</span><span class=\"n\">hc.2</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">exists</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">setoid.is_partition.eq_to_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">setoid.is_partition</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">hc.to</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">hc.mem_to</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hc.2</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">unique</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span><span class=\"bp\">;</span>\n  <span class=\"n\">rw</span> <span class=\"n\">exists_unique_prop</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">subtype.coe_prop</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hc.mem_to</span> <span class=\"n\">x</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">setoid.is_partition.fiber_to_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span>\n  <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">setoid.is_partition</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">hc.to</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">set.mem_preimage</span><span class=\"o\">,</span> <span class=\"n\">set.mem_singleton_iff</span><span class=\"o\">,</span> <span class=\"n\">eq_comm</span><span class=\"o\">,</span> <span class=\"n\">subtype.ext_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hc.eq_to_iff</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">subtype.coe_prop</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">setoid.is_partition.surjective_to</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span>\n  <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">setoid.is_partition</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">hc.to</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">set</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">setoid.nonempty_of_mem_partition</span> <span class=\"n\">hc</span> <span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"o\">:</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">hc.eq_to_iff</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">subtype.coe_prop</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">setoid.nonempty_of_mem_partition</span> <span class=\"n\">hc</span> <span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">setoid.is_partition.ker_to</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">setoid.is_partition</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">setoid.ker</span> <span class=\"n\">hc.to</span> <span class=\"bp\">=</span> <span class=\"n\">setoid.mk_classes</span> <span class=\"n\">c</span> <span class=\"n\">hc.2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">setoid.classes_inj.mpr</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"n\">hc.to</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hc.fiber_to_eq</span> <span class=\"n\">s</span><span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">setoid.classes_mk_classes</span><span class=\"o\">,</span> <span class=\"n\">setoid.classes_ker_of_surjective</span> <span class=\"n\">hc.surjective_to</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"n\">subtype.range_coe</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">setoid.is_partition</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">setoid.mk_classes</span> <span class=\"n\">c</span> <span class=\"n\">hc.2</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"k\">calc</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">setoid.mk_classes</span> <span class=\"n\">c</span> <span class=\"n\">hc.2</span><span class=\"o\">)</span>\n      <span class=\"bp\">≃</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">setoid.ker</span> <span class=\"n\">hc.to</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">quotient.congr_right</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">hc.ker_to</span><span class=\"o\">)</span>\n  <span class=\"bp\">...</span> <span class=\"bp\">≃</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">setoid.quotient_ker_equiv_of_surjective</span> <span class=\"n\">hc.to</span> <span class=\"n\">hc.surjective_to</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">finite</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">setoid.is_partition</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">finsum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"n\">nat.card</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">nat.card</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">fintype.of_finite</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finsum_eq_sum_of_fintype</span><span class=\"o\">,</span> <span class=\"n\">nat.card_eq_fintype_card</span><span class=\"o\">,</span>\n      <span class=\"n\">fintype.card_congr</span> <span class=\"o\">(</span><span class=\"n\">equiv.sigma_preimage_equiv</span> <span class=\"n\">hc.to</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"n\">fintype.card_sigma</span><span class=\"o\">],</span>\n  <span class=\"n\">congr</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat.card_eq_fintype_card</span><span class=\"o\">,</span> <span class=\"n\">hc.fiber_to_eq</span><span class=\"o\">],</span>\n  <span class=\"n\">refl</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 355428128,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1683118338
    },
    {
        "content": "<p>(golf welcome)</p>",
        "id": 355428180,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1683118346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/set.20of.20equivalences.20classes.20is.20equiv.20to.20quotient/near/355398433\">said</a>:</p>\n<blockquote>\n<p>I don’t think this lemma is true without finiteness assumptions. If you have an infinite type and take a partition with one singleton and its complement, then the rhs is zero but the lhs is one, right?</p>\n</blockquote>\n<p>(Of course. I corrected the lemma.)</p>",
        "id": 355539248,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1683128632
    },
    {
        "content": "<p>I think your lemma can assume the parts are finite, rather than assuming that <code>α</code> is finite.</p>",
        "id": 355540125,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1683128827
    },
    {
        "content": "<p>Yes. If the parts are finite but the set is infinite, there are infinitely many parts, <code>nat.card</code> is zero, as is the <code>finsum</code>. But mathematically, it has not the same meaning.</p>",
        "id": 355546538,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1683130355
    },
    {
        "content": "<p>I went on playing that game…</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">setoid.nat_sum</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">finite</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span>\n  <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">setoid.is_partition</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">finsum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"n\">nat.card</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">nat.card</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">fintype.of_finite</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finsum_eq_sum_of_fintype</span><span class=\"o\">,</span> <span class=\"n\">nat.card_eq_fintype_card</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">fintype.card_sigma</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">fintype.card_congr</span> <span class=\"o\">(</span><span class=\"n\">equiv.of_bijective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x.snd</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"bp\">↥</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- injectivity</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩,⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span><span class=\"o\">⟩⟩</span> <span class=\"o\">⟨⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">y</span><span class=\"o\">⟩⟩</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">hab</span> <span class=\"n\">at</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sigma.subtype_ext_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">and.intro</span> <span class=\"n\">_</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">unique_of_exists_unique</span> <span class=\"o\">(</span><span class=\"n\">hc.2</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_unique_iff_exists</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_unique_iff_exists</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩,</span>\n\n  <span class=\"c1\">-- surjectivity</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,⟨</span><span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">ha'</span><span class=\"o\">⟩,</span> <span class=\"n\">hx'</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hc.2</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"o\">⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩⟩,</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 355608231,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1683148147
    },
    {
        "content": "<p>That proof looks like it should be trivial once you extract the equivalence into its own <code>def</code> (which likely already exists somewhere)</p>",
        "id": 355614642,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683151052
    },
    {
        "content": "<p>The point is at the <code>split</code>, where I need to prove the bijectivity of the function <code>λ x, x.snd : (Σ (a : ↥c), ↥a) → α)</code>.<br>\nIf I enter <code>rw function.bijective_iff_exists_unique</code>, I am reduced to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"bp\">↥</span><span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">a.snd</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>which is very close to the definition of <code>set.is_partition c</code>, except that the latter is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>and I don't know how to change trivially one to another.</p>",
        "id": 355625836,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1683157361
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/set.20of.20equivalences.20classes.20is.20equiv.20to.20quotient/near/355614642\">said</a>:</p>\n<blockquote>\n<p>That proof looks like it should be trivial once you extract the equivalence into its own <code>def</code> (which likely already exists somewhere)</p>\n</blockquote>\n<p>I could not find the equivalence <code>(Σ (s : ↥c), ↥s) ≃ α </code> (with <code>hc : setoid.is_partition c</code>) in mathlib. <br>\nOnce we have it,  everything simplifies as you indicated:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">setoid.is_partition.equiv</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span>\n  <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">setoid.is_partition</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"bp\">↥</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n<span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x.snd</span><span class=\"o\">,</span>\n<span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">⟨⟨(</span><span class=\"n\">exists_unique.exists2</span> <span class=\"o\">(</span><span class=\"n\">hc.2</span> <span class=\"n\">a</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">exists_unique.exists2</span> <span class=\"o\">(</span><span class=\"n\">hc.2</span> <span class=\"n\">a</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">some_spec.some</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">exists_unique.exists2</span> <span class=\"o\">(</span><span class=\"n\">hc.2</span> <span class=\"n\">a</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">some_spec.some_spec</span><span class=\"o\">⟩⟩,</span>\n<span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">sigma.subtype_ext_iff</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">subtype.coe_inj</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">exists_unique.elim</span> <span class=\"o\">(</span><span class=\"n\">hc.2</span> <span class=\"n\">x.snd</span><span class=\"o\">),</span>\n    <span class=\"n\">intros</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"n\">hst</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_unique_iff_exists</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_unique_iff_exists</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">and_imp</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hst</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hst</span> <span class=\"n\">x.fst</span> <span class=\"n\">x.fst.prop</span> <span class=\"n\">x.snd.prop</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">exists_unique.exists2</span> <span class=\"o\">(</span><span class=\"n\">hc.2</span> <span class=\"o\">(</span><span class=\"n\">x.snd</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_prop</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hst</span> <span class=\"n\">_</span> <span class=\"n\">this.1</span> <span class=\"n\">this.2</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subtype.coe_mk</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span><span class=\"o\">,</span>\n<span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subtype.coe_mk</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">setoid.nat_sum'</span><span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">finite</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span>\n  <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">setoid.is_partition</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">finsum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"n\">nat.card</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">nat.card</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">fintype.of_finite</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finsum_eq_sum_of_fintype</span><span class=\"o\">,</span> <span class=\"n\">nat.card_eq_fintype_card</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">fintype.card_sigma</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">fintype.card_congr</span> <span class=\"n\">hc.equiv</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 355979933,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1683275230
    }
]