[
    {
        "content": "<p>Has anyone been able to get a version of Induction-Recursion going in Lean, or some other way of implementing a Universe ala Tarski?</p>\n<p>For those who don't know Induction Recursion is where you define an inductive type mutually with a function that pattern matches on that type. It's useful when you have, for example, a type of codes representing some collection of dependent types, where to encode dependent functions you need to parameterize the codomain over the decoding of the domain.</p>\n<p>I've heard folklore than you can fake IR by using impredicativity, but I don't know how that would actually work. I realize it won't be directly supported by Lean but I'm wondering if you can fake it.</p>",
        "id": 400565894,
        "sender_full_name": "Joey Eremondi",
        "timestamp": 1699287160
    },
    {
        "content": "<p>induction-recursion is axiomatically stronger than lean, so no you can't do it in general. Several specific kinds of inductive-recursive types can be encoded though</p>",
        "id": 400566646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699287463
    },
    {
        "content": "<p>For Tarski universes things are a little better: Universes like <code>Type u</code> are Tarski universes, so every type is an element of a Tarski universe</p>",
        "id": 400567146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699287605
    },
    {
        "content": "<p>I guess I should say that you can't do inductive-recursive types without a universe bump</p>",
        "id": 400567375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699287651
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Induction-Recursion.20or.20Universe.20ala.20Tarski.3F/near/400567146\">said</a>:</p>\n<blockquote>\n<p>For Tarski universes things are a little better: Universes like <code>Type u</code> are Tarski universes, so every type is an element of a Tarski universe</p>\n</blockquote>\n<p>I think Lean uses Russell-style universes. Tarski universes would be <code>A : Type u ‚ä¢ El(A) type u</code>.</p>",
        "id": 400611112,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1699305044
    },
    {
        "content": "<p>I mean a tarski universe in the set theoretic sense, which is more or less equivalent in strength to a Grothendieck universe which <code>Type u</code> definitely is</p>",
        "id": 400611399,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699305178
    },
    {
        "content": "<p>But it's possible I misunderstood what <span class=\"user-mention\" data-user-id=\"384488\">@Joey Eremondi</span> meant by \"Universe a la Tarski\"</p>",
        "id": 400611509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699305225
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> What I meant was a type-theoretic universe where there's a separate type of codes, and an explicit decoding function <code>El : Code -&gt; Type</code> that interprets codes to their types of elements. <span class=\"user-mention\" data-user-id=\"128280\">@Wojciech Nawrocki</span> is right that Lean has a Universe ala Russel, i.e. you can use types on both the left and right of <code>:</code> without having to explicitly decode.</p>\n<p>That said, you're not wrong, one large inaccessible cardinal (i.e. a Grothendieck Universe) is enough to give a model of induction recursion, which is enough to define a Universe ala Tarski.</p>",
        "id": 400612331,
        "sender_full_name": "Joey Eremondi",
        "timestamp": 1699305636
    }
]