[
    {
        "content": "<p>Is there code in any repo about intrepreting pairs/vectors/lists of bitvectors as a big bitvector by appending? With lemmas saying that the \"high\" bitvector is 0 if the value is low enough etc.</p>",
        "id": 508802864,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1743180925
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"122318\">@Tobias Grosser</span> <span class=\"user-mention\" data-user-id=\"395550\">@Henrik BÃ¶ving</span></p>",
        "id": 508802890,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1743180933
    },
    {
        "content": "<p>Certainly appending pairs of BitVectors is supported, just as <code>v ++ w</code>, and there is a fairly complete set of lemmas about this.</p>\n<p>I have an abandoned PR at <a href=\"https://github.com/leanprover/lean4/pull/3727\">lean#3727</a> that defined</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">flattenList</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>but it needed work.</p>\n<p>I would suggest just starting over on this, and:</p>\n<ol>\n<li>Now that the <code>Vector</code> API is fairly complete, just do it for <code>Vector n (BitVec m)</code> directly.</li>\n<li>Writing the function with signature <code>Vector.flatMapBitVec (v : Vector n \\a) (f : \\a \\to BitVec m) : BitVec (n * m)</code> first is probably best, and then defining <code>Vector.flattenBitVec</code> in terms of that.</li>\n<li>Probably it is best to define variants for both little-endian and big-endian conventions.</li>\n</ol>",
        "id": 508851473,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1743198913
    },
    {
        "content": "<p>I'll take up on this, including some analysis of the <code>.toNat</code> of flattened vectors and about carries of multiplication etc</p>",
        "id": 508909487,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1743244061
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> Any comment on <a href=\"https://github.com/leanprover/lean4/pull/7754\">lean#7754</a>? Will add the BE versions of the type equivalence if the approach seems reasonable. I think with the lemmas about <code>getElem</code> we don't even need specific lemmas for the arithmetic operations</p>",
        "id": 509399539,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1743498826
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110789\">@Jakob von Raumer</span> I left another round of review on the new APIs!</p>",
        "id": 509402807,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1743499754
    }
]