[
    {
        "content": "<p>So, uh, we don't seem to have this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">AddSemigroup</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This is despite the fact it is pretty easy to define:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">List.instAddSemigroup</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">AddSemigroup</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">List.append</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">List.append_assoc</span>\n</code></pre></div>\n<p>Indeed, we can go further:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">List.instAddMonoid</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">AddMonoid</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">List.append</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">List.append_assoc</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n  <span class=\"n\">zero_add</span> <span class=\"o\">:=</span> <span class=\"n\">List.nil_append</span>\n  <span class=\"n\">add_zero</span> <span class=\"o\">:=</span> <span class=\"n\">List.append_nil</span>\n</code></pre></div>\n<p>This would be useful to have because it would mean that you could in theory define an AddAction of lists of a type on another type, even if the first type <em>doesn't</em> have a defined monoidal structure.</p>\n<p>I also feel like on this basis something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">AddSemigroup</span> <span class=\"o\">(</span><span class=\"n\">Sigma</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>would be useful: again it would be useful to be able to have an action of Fin n -&gt; α on things in a natural way - but it might be harder to use.</p>\n<p>Do we have a different approach to this already in the library?</p>",
        "id": 402695973,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700226773
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>, any ideas/qualms? I'm in favour of the list one (even potentially replacing <code>++</code>) but not as sure about the sigma one; it seems likely to cause issues in my head.</p>",
        "id": 402698502,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1700227560
    },
    {
        "content": "<p>The sigma one definitely feels dodgy to me, there's a reason a lot of languages don't let you do this to tuples. But I am kinda in the position where it is the one that might be a bit more convenient in some ways.</p>",
        "id": 402698841,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700227646
    },
    {
        "content": "<p>Wait, how would the sigma one even work? That looks very ill-behaved</p>",
        "id": 402698856,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1700227650
    },
    {
        "content": "<p>Oh I think it probably doesn't, I'm not sure if it is possible. But certainly Fin.append exists and that's what I'm trying to point to.</p>",
        "id": 402699027,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700227690
    },
    {
        "content": "<p>(The fact that Fin.append_assoc needs a cast in it kinda shows the issue though I think.)</p>",
        "id": 402699095,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700227714
    },
    {
        "content": "<p>In theory I think that that Sigma might be isomorphic to List?</p>",
        "id": 402699271,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700227778
    },
    {
        "content": "<p>If you want <code>+</code> to mean <code>++</code>, you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FreeAddMonoid#doc\">docs#FreeAddMonoid</a></p>",
        "id": 402699641,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700227890
    },
    {
        "content": "<p>The sigma one almost exists already as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=GradedMonoid.GMul.toMul#doc\">docs#GradedMonoid.GMul.toMul</a></p>",
        "id": 402699832,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700227950
    },
    {
        "content": "<p>I suppose, but that (FreeAddMonoid) is rather harder to use. If we had another monoid structure on List I would understand it!</p>",
        "id": 402700045,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700228026
    },
    {
        "content": "<p>Why is FreeAddMonoid harder to use?</p>",
        "id": 402700679,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700228252
    },
    {
        "content": "<p>Well in this case - because all my theorems are actually written as about tuples so it's doubly hard :P</p>",
        "id": 402700820,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700228300
    },
    {
        "content": "<p>I prefer avoiding type synonyms when it isn't necessary in general.</p>",
        "id": 402700895,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700228331
    },
    {
        "content": "<p>As I say, I came to it from the perspective of \"I would like to define an action on tuples, or possibly on lists, on a type\"</p>",
        "id": 402700988,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700228373
    },
    {
        "content": "<p>(I would actually like to define an action on arrays in particular but baby steps.)</p>",
        "id": 402701292,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700228484
    },
    {
        "content": "<p>Here's another candidate for <code>*</code> on lists:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Mul</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">l₁</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">l₂</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_def</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span> <span class=\"bp\">*</span> <span class=\"n\">l₂</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">l₁</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">l₂</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">One</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"n\">return</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">one_def</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"k\">do</span> <span class=\"n\">return</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">LawfulMonad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Monoid</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">one_mul</span> <span class=\"n\">l₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">one_def</span><span class=\"o\">,</span> <span class=\"n\">mul_def</span><span class=\"o\">,</span> <span class=\"n\">pure_bind</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span><span class=\"o\">,</span> <span class=\"n\">bind_pure</span><span class=\"o\">]</span>\n  <span class=\"n\">mul_one</span> <span class=\"n\">l₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">one_def</span><span class=\"o\">,</span> <span class=\"n\">mul_def</span><span class=\"o\">,</span> <span class=\"n\">pure_bind</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"n\">bind_pure</span><span class=\"o\">]</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"n\">l₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_def</span><span class=\"o\">,</span> <span class=\"n\">bind_assoc</span><span class=\"o\">,</span> <span class=\"n\">pure_bind</span><span class=\"o\">,</span> <span class=\"n\">bind_pure</span><span class=\"o\">,</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">implies_true</span><span class=\"o\">]</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"bp\">+</span> <span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">]</span>\n<span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"bp\">*</span> <span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 402701716,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700228621
    },
    {
        "content": "<p>(or indeed, on any monad)</p>",
        "id": 402701727,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700228626
    },
    {
        "content": "<p>Yes I was going to ask, what's the * equivalent? Needs  some assumptions on the underlying type ofc but</p>",
        "id": 402701939,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700228691
    },
    {
        "content": "<p>I feel as if it should be/could be the convolution? Which I am not sure this is.</p>",
        "id": 402710523,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700231418
    },
    {
        "content": "<p>I think i agree those operations could plausibly distribute, but I think it would be bizarre to have them as the default instance on lists</p>",
        "id": 402711162,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700231631
    },
    {
        "content": "<p>Yes, that is somewhere where a type synonym might well make sense. But I would argue that '+' on lists can't really mean anything sensible except for concatenation. I suppose it could be a similar construction as that, so that [1, 2, 3] + [4, 5] = [5, 6, 6, 7, 7, 8].</p>",
        "id": 402711558,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700231741
    },
    {
        "content": "<p>But I would honestly argue that that is more perverse in some ways.</p>",
        "id": 402711608,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700231757
    },
    {
        "content": "<p>(I edited my example above so that it has that behavior)</p>",
        "id": 402712541,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700232059
    },
    {
        "content": "<p>Your one has that for multiplication, no?</p>",
        "id": 402712784,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700232138
    },
    {
        "content": "<p>It has it for both</p>",
        "id": 402713215,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700232284
    },
    {
        "content": "<p>Oh I see, the <code>to_additive</code>.</p>",
        "id": 402713273,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700232306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Algebraic.20structure.20on.20lists.20.28and.2For.20finite.20tuples.29/near/402700820\">said</a>:</p>\n<blockquote>\n<p>Well in this case - because all my theorems are actually written as about tuples so it's doubly hard :P</p>\n</blockquote>\n<p>By tuples do you mean <code>Fin n -&gt; a</code>?</p>",
        "id": 402713350,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700232332
    },
    {
        "content": "<p>Yes.</p>",
        "id": 402713393,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700232345
    },
    {
        "content": "<p>Incidentally I realise \"Python does it this way\" is a pretty poor argument for anything but as it happens:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">&gt;&gt;&gt;</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"bp\">+</span> <span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">]</span>\n<span class=\"bp\">&gt;&gt;&gt;</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"bp\">*</span> <span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">]</span>\n<span class=\"n\">Traceback</span> <span class=\"o\">(</span><span class=\"n\">most</span> <span class=\"n\">recent</span> <span class=\"n\">call</span> <span class=\"n\">last</span><span class=\"o\">):</span>\n  <span class=\"n\">File</span> <span class=\"s2\">\"&lt;stdin&gt;\"</span><span class=\"o\">,</span> <span class=\"n\">line</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">in</span> <span class=\"bp\">&lt;</span><span class=\"n\">module</span><span class=\"bp\">&gt;</span>\n<span class=\"n\">TypeError</span><span class=\"o\">:</span> <span class=\"n\">can't</span> <span class=\"n\">multiply</span> <span class=\"n\">sequence</span> <span class=\"kd\">by</span> <span class=\"n\">non</span><span class=\"bp\">-</span><span class=\"n\">int</span> <span class=\"n\">of</span> <span class=\"n\">type</span> <span class=\"bp\">'</span><span class=\"n\">list'</span>\n</code></pre></div>\n<p>Other languages with which I'm familiar only let you add lists of the same size (and in that case it's pointwise).</p>",
        "id": 402713683,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700232433
    },
    {
        "content": "<p>Python doesn't have a dedicated <code>++</code> operator</p>",
        "id": 402714398,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700232656
    },
    {
        "content": "<p>(Ok, strictly they do, it's <code>operator.concat</code>, but it is only available via the overloaded <code>+</code> operator)</p>",
        "id": 402714473,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700232682
    },
    {
        "content": "<p>Well, this is true, but I frankly see little need for ++.</p>",
        "id": 402717176,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700233490
    },
    {
        "content": "<p>Like, because ++ is the operation that makes Lists into AddMonoids, we should just use + for it. I don't see any particular benefit in having a special notation for it.</p>",
        "id": 402717318,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700233532
    },
    {
        "content": "<p>Well, you'll need to take that up with lean core, and I suspect they do not care for such bike-shedding</p>",
        "id": 402722711,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700234969
    },
    {
        "content": "<p>I'm pretty sure we copied <code>++</code> from haskell?</p>",
        "id": 402722810,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700234999
    },
    {
        "content": "<p>Indeed, it isn't worth the pain.</p>",
        "id": 402722881,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700235005
    },
    {
        "content": "<p>Yeah Haskell uses it! I like ++ in general. I just wish it was then straightforward to go \"btw ++ is also +\".</p>",
        "id": 402722985,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700235030
    },
    {
        "content": "<p>I guess fundamentally this is the point of the <code>FreeAddMonoid</code>, but it's mildly a pain that it works like that - I wish List could addact on stuff directly.</p>",
        "id": 402724147,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700235389
    },
    {
        "content": "<p>We could make <code>HAdd_add.add_add</code>, make another group heirarchy, and enhance <code>to_additive</code> to <code>to_additive_additive</code>.</p>",
        "id": 402735054,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700238799
    },
    {
        "content": "<p>oh no</p>",
        "id": 402737213,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700239601
    },
    {
        "content": "<p>yeah I'm not sure that idea will go down too well</p>",
        "id": 402750068,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700244340
    },
    {
        "content": "<p>For what it's worth I wasn't saying that!</p>",
        "id": 402750342,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700244404
    },
    {
        "content": "<p>I just think if something walks like a monoid and quacks like a monoid it's quite useful when it is one</p>",
        "id": 402750473,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700244444
    },
    {
        "content": "<p>Yes but what if something is a monoid in several ways? Then mathlib's position would probably be not to choose. Can you just make the def you want and activate it locally?</p>",
        "id": 402751565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700244786
    },
    {
        "content": "<p>Yeah, probably - I'm not even sure I need it for List as I say. Though I am not sure I know another definition of AddMonoid for it.</p>",
        "id": 402752242,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700244968
    },
    {
        "content": "<p>I agree that with ambiguity one ought not to choose.</p>",
        "id": 402752901,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700245246
    },
    {
        "content": "<p>Another definition of AddMonoid: Eric posted a plausible one above assuming an addition on the underlying type. This might well be enough to give people pause.</p>",
        "id": 402754851,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700246028
    },
    {
        "content": "<p>I suppose. I think I'm less comfortable with [0] being 0 than [] being 0?</p>",
        "id": 402755152,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700246134
    },
    {
        "content": "<p>Like the latter feels much more natural to me just for starters.</p>",
        "id": 402755304,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700246194
    },
    {
        "content": "<p>I suppose this is the argument for the FreeAddMonoid way of thinking! And the default interpretation of List is List-as-Monad.</p>",
        "id": 402755646,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700246347
    },
    {
        "content": "<p>Still, I'm not sure I can think of any programming languages where the above is the behaviour of + on lists.</p>",
        "id": 402755813,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700246410
    },
    {
        "content": "<p>(Mostly, as we have currently I guess, it simply isn't allowed.)</p>",
        "id": 402755843,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700246429
    },
    {
        "content": "<p>Right but there's nothing stopping you making it allowed in your own project, and indeed this might well be the best solution for you.</p>",
        "id": 402755913,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700246470
    },
    {
        "content": "<p>Aye. Sorry.</p>",
        "id": 402755947,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700246489
    },
    {
        "content": "<p>Like as I say I don't need it for List - I was just suggesting something that seemed to me to be natural.</p>",
        "id": 402755991,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700246510
    },
    {
        "content": "<p>But if it doesn't seem that way, and we do have it in some form, albeit via a type synonym, then the answer is - yes we have code for that.</p>",
        "id": 402756098,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700246547
    },
    {
        "content": "<p>I think it's fine if there's a <code>def</code> that gives a Monoid structure on List, and then modules can use <code>attribute [local instance]</code> if they want to use monoid notation.</p>\n<p>Of course, <code>FreeAddMonoid</code> is the one true List-as-an-additive-monoid <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> For interfacing between the <code>List</code> and <code>FreeAddMonoid</code> worlds, I guess you need to be careful to always insert <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FreeAddMonoid.toList#doc\">docs#FreeAddMonoid.toList</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FreeAddMonoid.ofList#doc\">docs#FreeAddMonoid.ofList</a> as appropriate.</p>",
        "id": 402758393,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700247551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Algebraic.20structure.20on.20lists.20.28and.2For.20finite.20tuples.29/near/402711558\">said</a>:</p>\n<blockquote>\n<p>Yes, that is somewhere where a type synonym might well make sense. But I would argue that '+' on lists can't really mean anything sensible except for concatenation. I suppose it could be a similar construction as that, so that [1, 2, 3] + [4, 5] = [5, 6, 6, 7, 7, 8].</p>\n</blockquote>\n<p>To be quite fair, when I saw the notification from eric's ping, I thought you were asking about <code>[1, 2, 3] + [4, 5] = [5, 7]</code>!</p>",
        "id": 402784175,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1700257291
    },
    {
        "content": "<p>Err I can't now remember the context of that but sorry.</p>",
        "id": 402784541,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700257502
    },
    {
        "content": "<p>I only skimmed this thread, but please do not define a global <code>+</code> operation on Lists.</p>\n<p>For me at moment, <code>[1, 2, 3] + [4, 5] = [5, 7, 3]</code> (i.e. pointwise addition, padding with zeros as needed)</p>",
        "id": 402806201,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700268444
    },
    {
        "content": "<p>(i.e. using lists as a model for finitely supported functions)</p>",
        "id": 402806264,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700268466
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Algebraic.20structure.20on.20lists.20.28and.2For.20finite.20tuples.29/near/402784175\">said</a>:</p>\n<blockquote>\n<p>To be quite fair, when I saw the notification from eric's ping, I thought you were asking about <code>[1, 2, 3] + [4, 5] = [5, 8]</code>!</p>\n</blockquote>\n<p>I cannot work out how you are defining this</p>",
        "id": 402811833,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700270557
    },
    {
        "content": "<p>I'm pretty sure Yaël's 8 is a typo for 7: the same as my addition, but truncating to the shortest list.</p>",
        "id": 402819286,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700274614
    },
    {
        "content": "<p>I'm guessing they're adding the endpoints: <code>[1+4, 3+5]</code>, though I couldn't tell you what's useful about that</p>",
        "id": 402834488,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1700284701
    },
    {
        "content": "<p>No, Scott is right. This was typo.</p>",
        "id": 402859123,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1700302427
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Algebraic.20structure.20on.20lists.20.28and.2For.20finite.20tuples.29/near/402806201\">said</a>:</p>\n<blockquote>\n<p>I only skimmed this thread, but please do not define a global <code>+</code> operation on Lists.</p>\n<p>For me at moment, <code>[1, 2, 3] + [4, 5] = [5, 7, 3]</code> (i.e. pointwise addition, padding with zeros as needed)</p>\n</blockquote>\n<p>Pointwise addition with padding is quite interesting. Wouldn't have occurred to me.</p>",
        "id": 402859203,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700302470
    },
    {
        "content": "<p>List is, on reflection, a very semantically overloaded type.</p>",
        "id": 402859224,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700302491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Algebraic.20structure.20on.20lists.20.28and.2For.20finite.20tuples.29/near/402713683\">said</a>:</p>\n<blockquote>\n<p>Incidentally I realise \"Python does it this way\" is a pretty poor argument for anything but ...</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Algebraic.20structure.20on.20lists.20.28and.2For.20finite.20tuples.29/near/402859224\">said</a>:</p>\n<blockquote>\n<p>List is, on reflection, a very semantically overloaded type.</p>\n</blockquote>\n<p>Perhaps if you're set on copying python, we should copy  \"in the face of ambiguity, refuse the temptation to guess\"</p>",
        "id": 402893088,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700325928
    },
    {
        "content": "<p>Indeed. Frankly it's weird that it does treat + as concat given that principle.</p>",
        "id": 402893970,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700326762
    },
    {
        "content": "<p>Julia uses <code>*</code> for string concatenation because multiplication is more often non-commutative</p>",
        "id": 402963550,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1700371888
    },
    {
        "content": "<p>That's fun</p>",
        "id": 402975722,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700379063
    },
    {
        "content": "<p>The only situation I know in mathematics when + isn't commutative is addition of ordinals.</p>",
        "id": 403010956,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700401153
    },
    {
        "content": "<p>I wonder, if you take ++ as *, is there some operation on lists it naturally distributes over?</p>",
        "id": 403011810,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700401764
    },
    {
        "content": "<p><code>x + y = x</code></p>",
        "id": 403065641,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700439525
    },
    {
        "content": "<p>Also, if you defined concat as <code>*</code>, then it distributes over <code>trop \\comp List.length</code>. Inspired by calculations of degrees on polynomials.</p>",
        "id": 403074124,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1700443466
    },
    {
        "content": "<p>That's very nice</p>",
        "id": 403074233,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700443540
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span>, could you spell out what you mean?</p>",
        "id": 403079255,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700446766
    },
    {
        "content": "<p>Tropical multiplication is addition in the underlying semiring. So if we have <code>l1 * l2 := l1 ++ l2</code>, then we have <code>trop (List.length (l1 * l2))) = trop (List.length l1 + List.length l2) = trop (List.length l1) * trop (List.length l2)</code>. Perhaps this is distributing in the \"wrong\" direction.</p>",
        "id": 403079521,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1700446926
    },
    {
        "content": "<p>I guess \"distribute\" isn't right here, it's more of a \"map\"</p>",
        "id": 403079588,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1700446988
    },
    {
        "content": "<p>Yes, it is not distributivity at all. :-)</p>",
        "id": 403080089,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700447300
    },
    {
        "content": "<p>My wild conjecture is that <code>x + y = x</code> and <code>x + y = y</code> are the only solutions. :-)</p>",
        "id": 403080115,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700447321
    },
    {
        "content": "<p>Taking <code>x + y</code> to be “longest common prefix of <code>x</code> and <code>y</code>” works for left-distributivity! :)</p>",
        "id": 403105774,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700464184
    },
    {
        "content": "<p>I’m too close to sleeping to check right now if this actually works, but if the “wedge” of two lists is the operation that is like concatenation but “overlaps” them as much as possible—e.g. <code>[5, 2, 3, 1]</code> wedge <code>[2, 3, 1, 6, 7]</code> is <code>[5, 2, 3, 1, 6, 7]</code>—then maybe “longest common prefix wedge longest common suffix” gets you both left and right distributivity?</p>",
        "id": 403108546,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700465404
    },
    {
        "content": "<p>(Assuming your type has decidable equality, of course. I’d tentatively back Scott’s conjecture when talking about a uniform operation over generic lists!)</p>",
        "id": 403110145,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700466012
    },
    {
        "content": "<p>(Actually we might not want to consider the wedge of longest common prefix and sufffix but instead the “longest common outfix”, generated by taking the longest common prefix and concatenating it with the longest common suffix of whatever remained after removing the longest common prefix. E.g. the longest common outfix of <code>[2,2,2]</code> and <code>[2,2,5,2,2]</code> is <code>[2,2,2]</code>, but the wedge of the longest common prefix and suffix is <code>[2,2]</code>. I’m not sure what the consequences of the difference are yet…)</p>",
        "id": 403114069,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700467444
    },
    {
        "content": "<p>Bonus points for finding literature on this question. :-)</p>",
        "id": 403130202,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700473222
    },
    {
        "content": "<p>In the case of natural numbers (i.e. lists of the singleton type), restricting attention to commutative operations, this is a well-known olympiad problem where the only solutions (with some non-triviality requirements) are min and max.</p>",
        "id": 403143159,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1700477375
    },
    {
        "content": "<p>Oh, that gives us yet another <code>+</code>! Simply choose the longest (or shortest) list, and e.g. bias left or right when the lists have the same length.</p>",
        "id": 403270786,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700527040
    },
    {
        "content": "<p>I proved that the \"longest common outfix\" notion above is a solution (given decidable equality)! :)</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.Infix</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- `LCP l₁ l₂` denotes the \"longest common prefix\" of `l₁` and `l₂`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">LCP</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">ys</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">LCP</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"k\">else</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n\n<span class=\"sd\">/-- `LCP l₁ l₂` denotes the \"longest common suffix\" of `l₁` and `l₂`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">LCS</span> <span class=\"o\">(</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">LCP</span> <span class=\"n\">l₁.reverse</span> <span class=\"n\">l₂.reverse</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">reverse</span>\n\n<span class=\"sd\">/-- `LCO l₁ l₂` denotes the \"longest common outfix\" of `l₁` and `l₂`.</span>\n<span class=\"sd\">That is, if `l = LCP l₁ l₂`, and `l₁ = l ++ l₁'`, `l₂ = l ++ l₂'`, then `LCO l₁ l₂` is `(LCP l₁ l₂) ++ LCS l₁' l₂'`.</span>\n<span class=\"sd\">Note that while this appears biased towards the prefix, it isn't; taking the `LCS` first would result in the same list. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">LCO</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">l₁</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">),</span> <span class=\"n\">l₂</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">LCO</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"k\">else</span> <span class=\"n\">LCS</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span>\n<span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">lco_self</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">LCO</span> <span class=\"n\">l</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">l</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LCO</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">lco_self</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">lcp_self</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">LCP</span> <span class=\"n\">l</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">l</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LCP</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">lcp_self</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">lcs_self</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">LCS</span> <span class=\"n\">l</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LCS</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lcp_comm</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">LCP</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"bp\">=</span> <span class=\"n\">LCP</span> <span class=\"n\">l₂</span> <span class=\"n\">l₁</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">match</span> <span class=\"n\">l₁</span><span class=\"o\">,</span> <span class=\"n\">l₂</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"o\">[]</span> <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">head</span> <span class=\"o\">::</span> <span class=\"n\">tail</span><span class=\"o\">,</span> <span class=\"n\">head'</span> <span class=\"o\">::</span> <span class=\"n\">tail'</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LCP</span><span class=\"o\">]</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">head</span> <span class=\"bp\">=</span> <span class=\"n\">head'</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">lcp_comm</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Ne.symm</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lcs_comm</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">LCS</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"bp\">=</span> <span class=\"n\">LCS</span> <span class=\"n\">l₂</span> <span class=\"n\">l₁</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">match</span> <span class=\"n\">l₁</span><span class=\"o\">,</span> <span class=\"n\">l₂</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LCS</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">lcp_comm</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lco_comm</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">LCO</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"bp\">=</span> <span class=\"n\">LCO</span> <span class=\"n\">l₂</span> <span class=\"n\">l₁</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">match</span> <span class=\"n\">l₁</span><span class=\"o\">,</span> <span class=\"n\">l₂</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"o\">[]</span> <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">head</span> <span class=\"o\">::</span> <span class=\"n\">tail</span><span class=\"o\">,</span> <span class=\"n\">head'</span> <span class=\"o\">::</span> <span class=\"n\">tail'</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LCO</span><span class=\"o\">]</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">head</span> <span class=\"bp\">=</span> <span class=\"n\">head'</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">lco_comm</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Ne.symm</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">lcs_comm</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">lcp_nil_left</span> <span class=\"o\">:</span> <span class=\"n\">LCP</span> <span class=\"o\">[]</span> <span class=\"n\">l₁</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LCP</span><span class=\"o\">]</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">lcs_nil_left</span> <span class=\"o\">:</span> <span class=\"n\">LCS</span> <span class=\"o\">[]</span> <span class=\"n\">l₁</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LCS</span><span class=\"o\">]</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">lco_nil_left</span> <span class=\"o\">:</span> <span class=\"n\">LCO</span> <span class=\"o\">[]</span> <span class=\"n\">l₁</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LCO</span><span class=\"o\">]</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">lcp_nil_right</span> <span class=\"o\">:</span> <span class=\"n\">LCP</span> <span class=\"n\">l₁</span> <span class=\"o\">[]</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">lcp_comm</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">lcs_nil_right</span> <span class=\"o\">:</span> <span class=\"n\">LCS</span> <span class=\"n\">l₁</span> <span class=\"o\">[]</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">lcs_comm</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">lco_nil_right</span> <span class=\"o\">:</span> <span class=\"n\">LCO</span> <span class=\"n\">l₁</span> <span class=\"o\">[]</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">lco_comm</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">lcs_append_after_right</span> <span class=\"o\">{</span><span class=\"n\">l₁</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">LCS</span> <span class=\"n\">l₁</span> <span class=\"o\">(</span><span class=\"n\">l₂</span> <span class=\"bp\">++</span> <span class=\"n\">l₁</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">l₁</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l₁</span> <span class=\"n\">using</span> <span class=\"n\">List.reverseRecOn</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">H0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">H1</span> <span class=\"n\">l</span> <span class=\"n\">a</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LCS</span><span class=\"o\">,</span> <span class=\"n\">LCP</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">List.reverse_append</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">ih</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">lco_append_after_right</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">LCO</span> <span class=\"n\">l₁</span> <span class=\"o\">(</span><span class=\"n\">l₂</span> <span class=\"bp\">++</span> <span class=\"n\">l₁</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">l₁</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">match</span> <span class=\"n\">l₂</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LCO</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">head</span> <span class=\"o\">::</span> <span class=\"n\">tail</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">l₁</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">head'</span> <span class=\"o\">::</span> <span class=\"n\">tail'</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">head'</span> <span class=\"bp\">=</span> <span class=\"n\">head</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">LCO</span><span class=\"o\">,</span> <span class=\"n\">LCP</span><span class=\"o\">]</span>\n      <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">List.append_cons</span><span class=\"o\">]</span>\n        <span class=\"n\">exact</span> <span class=\"n\">lco_append_after_right</span>\n      <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">List.cons_append</span><span class=\"o\">]</span>\n        <span class=\"n\">exact</span> <span class=\"n\">lcs_append_after_right</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">lcs_append_after_left</span> <span class=\"o\">{</span><span class=\"n\">l₁</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">LCS</span> <span class=\"o\">(</span><span class=\"n\">l₂</span> <span class=\"bp\">++</span> <span class=\"n\">l₁</span><span class=\"o\">)</span> <span class=\"n\">l₁</span> <span class=\"bp\">=</span> <span class=\"n\">l₁</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">lcs_comm</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">lcs_append_after_right</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">lco_append_after_left</span> <span class=\"o\">{</span><span class=\"n\">l₁</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">LCO</span> <span class=\"o\">(</span><span class=\"n\">l₂</span> <span class=\"bp\">++</span> <span class=\"n\">l₁</span><span class=\"o\">)</span> <span class=\"n\">l₁</span> <span class=\"bp\">=</span> <span class=\"n\">l₁</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">lco_comm</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">lco_append_after_right</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">lcp_singleton_of_not_eq</span> <span class=\"o\">{</span><span class=\"n\">a₁</span> <span class=\"n\">a₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a₁</span> <span class=\"bp\">≠</span> <span class=\"n\">a₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LCP</span> <span class=\"o\">[</span><span class=\"n\">a₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">a₂</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LCP</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lcp_append_left_distrib</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n    <span class=\"n\">x</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">LCP</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">LCP</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">++</span> <span class=\"n\">l₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">++</span> <span class=\"n\">l₂</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LCP</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">lcp_append_left_distrib</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lco_append_left_distrib</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n    <span class=\"n\">x</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">LCO</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">LCO</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">++</span> <span class=\"n\">l₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">++</span> <span class=\"n\">l₂</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LCO</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">lco_append_left_distrib</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lco_append_right_distrib</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">LCO</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">LCO</span> <span class=\"o\">(</span><span class=\"n\">l₁</span> <span class=\"bp\">++</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l₂</span> <span class=\"bp\">++</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">l₁</span><span class=\"o\">,</span> <span class=\"n\">l₂</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lco_self.symm</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lco_append_after_right.symm</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lco_append_after_left.symm</span>\n  <span class=\"bp\">|</span> <span class=\"n\">head</span> <span class=\"o\">::</span> <span class=\"n\">tail</span><span class=\"o\">,</span> <span class=\"n\">head'</span> <span class=\"o\">::</span> <span class=\"n\">tail'</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LCO</span><span class=\"o\">]</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">head</span> <span class=\"bp\">=</span> <span class=\"n\">head'</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">lco_append_right_distrib</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LCS</span><span class=\"o\">]</span>\n      <span class=\"k\">have</span> <span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"n\">x.reverse.reverse</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">List.reverse_reverse</span> <span class=\"n\">_</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hr</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">List.reverse_append</span><span class=\"o\">,</span> <span class=\"n\">List.reverse_inj</span><span class=\"o\">,</span> <span class=\"n\">lcp_append_left_distrib</span><span class=\"o\">]</span>\n      <span class=\"n\">simp</span>\n</code></pre></div>\n</div></div>\n<p>(The code here is just to \"get the job done\"; it's not a full treatment, and some names are wonky.)</p>",
        "id": 403305689,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700544483
    },
    {
        "content": "<p>(I'm still not sure about the wedge-based operation, but I have to admit that I have my doubts.)</p>",
        "id": 403305741,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700544524
    },
    {
        "content": "<p>Note, though, that both the longest common outfix and the wedge-based idea coincide on <code>List Unit</code>, and represent the min on natural numbers. I wonder if there's a (commutative) listified analogue of the max...?</p>",
        "id": 403306081,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700544752
    },
    {
        "content": "<p>Well this is fun.</p>",
        "id": 403346862,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700561442
    }
]