[
    {
        "content": "<p>Do we have that R is isomorphic to C as an additive group? Likely, this would be shown via an argument about the construction of a Hamel basis for C using the basis from R.</p>",
        "id": 385771490,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1692317055
    },
    {
        "content": "<p>I don't think we have this, but I don't think we even have the <code>Module.rank</code> of <code>ℝ</code> or <code>ℂ</code> over <code>ℚ</code> either. Once we prove that (which is a relatively simple cardinality argument), it follows directly from <code>LinearEquiv.ofRankEq</code>. The first lemma can definitely be generalized so that <code>R</code> and <code>M</code> don't have to live in the same universe, but I was lazy because I knew where I was headed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Module.rank_eq_cardinal_mk_of_lt</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">Module.Free</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Infinite</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">StrongRankCondition</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h_lt</span> <span class=\"o\">:</span> <span class=\"n\">Cardinal.mk</span> <span class=\"n\">R</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Cardinal.mk</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Module.rank</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"bp\">=</span> <span class=\"n\">Cardinal.mk</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Infinite</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n    <span class=\"n\">Cardinal.infinite_iff.mpr</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">Cardinal.infinite_iff.mp</span> <span class=\"n\">inferInstance</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">h_lt.le</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">Module.Free.chooseBasis</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">Module.Free.ChooseBasisIndex</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">cardinal_eq</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Cardinal.mk_finsupp_lift_of_infinite'</span><span class=\"o\">,</span> <span class=\"n\">Cardinal.lift_id'</span><span class=\"o\">,</span> <span class=\"n\">ge_iff_le</span><span class=\"o\">,</span>\n    <span class=\"bp\">←</span> <span class=\"n\">Module.Free.rank_eq_card_chooseBasisIndex</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">exact</span> <span class=\"o\">((</span><span class=\"n\">max_eq_iff.mp</span> <span class=\"n\">h.symm</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">resolve_right</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">not_and_of_not_left</span> <span class=\"n\">_</span> <span class=\"n\">h_lt.ne</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Real.rank_rat_real</span> <span class=\"o\">:</span> <span class=\"n\">Module.rank</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℝ</span> <span class=\"bp\">=</span> <span class=\"n\">Cardinal.continuum</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">Module.rank_eq_cardinal_mk_of_lt</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℝ</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">Cardinal.mk_real</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">Cardinal.mk_real</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">Cardinal.aleph0_lt_continuum</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Complex.rank_rat_complex</span> <span class=\"o\">:</span> <span class=\"n\">Module.rank</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℂ</span> <span class=\"bp\">=</span> <span class=\"n\">Cardinal.continuum</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">Module.rank_eq_cardinal_mk_of_lt</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℂ</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">mk_complex</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">Cardinal.mk_real</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">Cardinal.aleph0_lt_continuum</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Complex.linearEquiv_rat_real</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">ℚ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">LinearEquiv.ofRankEq</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℝ</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 385808414,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1692329678
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/6672\">#6672</a></p>",
        "id": 385994159,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1692395976
    }
]