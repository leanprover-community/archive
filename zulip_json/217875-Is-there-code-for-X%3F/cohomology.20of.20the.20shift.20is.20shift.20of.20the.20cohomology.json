[
    {
        "content": "<p>Richard Hill asked me this in our last London Learning Lean meeting:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CochainComplex</span><span class=\"w\"> </span><span class=\"n\">Ab</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"bp\">⟧.</span><span class=\"n\">homology</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">homology</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Is this easy with our current definitions?</p>",
        "id": 489811256,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734544091
    },
    {
        "content": "<p>This is in the file <code>Algebra.Homology.HomotopyCategory.ShiftSequence</code>.</p>",
        "id": 489812334,
        "sender_full_name": "Joël Riou",
        "timestamp": 1734544458
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CochainComplex</span><span class=\"w\"> </span><span class=\"n\">Ab</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"bp\">⟧.</span><span class=\"n\">homology</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">C.homology</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">CochainComplex.ShiftSequence.shiftIso</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Int.add_comm</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">_</span>\n</code></pre></div>",
        "id": 489812997,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1734544706
    },
    {
        "content": "<p>Probably just beyond what <code>exact?</code> can currently do :-/</p>",
        "id": 489813102,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1734544757
    },
    {
        "content": "<p>But not beyond <a class=\"stream\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F\">#Is there code for X?</a> ! Thanks a lot!</p>",
        "id": 489813288,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734544817
    },
    {
        "content": "<p>The preferred phrasing should be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">HomologicalComplex</span>\n<span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Abelian</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CochainComplex</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">C</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"bp\">⟧.</span><span class=\"n\">homology</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">C.homology</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"n\">homologyFunctor</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">shiftIso</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add_comm</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">C</span>\n</code></pre></div>",
        "id": 489814051,
        "sender_full_name": "Joël Riou",
        "timestamp": 1734545080
    },
    {
        "content": "<p>The notion <code>Functor.ShiftSequence</code> which is used here is not in the mathematical literature. It means that we attach to the functor <code>homologyFunctor _ _ 0 : CochainComplex Ab ℤ  ⥤ Ab</code> the whole series of functors <code>homologyFunctor _ _ n : CochainComplex Ab ℤ  ⥤ Ab</code> for all <code>n : ℤ</code> and we record isomorphisms about their behaviour with respect to the shift functors (and compatibilities of these isomorphisms). This is particularly useful in the triangulated context (e.g. the homotopy category, or the derived category): when we have a homological functor like <code>F : DerivedCategory A ⥤ C</code>, we should get long exact sequences like <code>FX ⟶ FY ⟶ FZ ⟶ F(X⟦1⟧)</code> for any distinguished triangle, but in the case <code>F := DerivedCategory.homologyFunctor _ 0</code>, that very exact sequence is <code>H^0 X ⟶ H^0 Y ⟶ H^0 Z ⟶ H^0(X⟦1⟧)</code>. The use of this <code>Functor.ShiftSequence</code> structure allows to get a better looking long exact sequence <code>... ⟶ H^0 X ⟶ H^0 Y ⟶ H^0 Z ⟶ H^1 X ⟶ ...</code>.</p>",
        "id": 489815852,
        "sender_full_name": "Joël Riou",
        "timestamp": 1734545766
    },
    {
        "content": "<p>Thanks, that's really useful.</p>",
        "id": 489817111,
        "sender_full_name": "Richard Hill",
        "timestamp": 1734546238
    }
]