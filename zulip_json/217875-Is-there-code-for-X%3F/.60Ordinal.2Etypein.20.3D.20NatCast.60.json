[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"n\">typein</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"n\">typein</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p><code>rfl</code> doesn't work even when <code>x = 0</code>, so this might not be true, but I think it is.</p>\n<p>btw for some reason, stating these with <code>(· &lt; ·)</code> fails to synthesize <code>IsWellOrder</code>, even though <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isWellOrder_lt#doc\">docs#isWellOrder_lt</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.Lt.isWellOrder#doc\">docs#Fin.Lt.isWellOrder</a> are spelled with it and not <code>LT.lt</code>.</p>",
        "id": 576057726,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1772120742
    },
    {
        "content": "<p>here's one solution:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"n\">typein</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"n\">type_subrel</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"n\">type_fintype</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">cast_inj</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card_of_subtype</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card_Iio</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"n\">typein</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"n\">type_subrel</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"n\">type_fintype</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">cast_inj</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card_of_subtype</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Iio</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">card_Iio</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>",
        "id": 576087940,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1772128249
    },
    {
        "content": "<p>one thing that's kind of weird is that it appears that the <code>Fintype</code> instance for <code>{ x : ℕ // x &lt; k }</code> is coming from the category theory library (specifically <code>CategoryTheory.FinCategory.fintypeObj</code>)</p>",
        "id": 576089488,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1772128725
    },
    {
        "content": "<p>that seems unintentional since <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.ofFinite#doc\">docs#Fintype.ofFinite</a> is deliberately not an instance to avoid noncomputable fintypes being automatically synthesized (which is happening here)</p>",
        "id": 576091792,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1772129386
    },
    {
        "content": "<p>Thanks! It surprises me that it's that much harder than <code>rfl</code> :)</p>",
        "id": 576093378,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1772129945
    },
    {
        "content": "<p>I could be wrong but I would think that the use of quotients would prevent <code>rfl</code> from seeing through everything</p>",
        "id": 576095324,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1772130562
    },
    {
        "content": "<p>with quotients you can have two closed terms which are equal but not defeq</p>",
        "id": 576099945,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1772131982
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/35840\">#35840</a></p>",
        "id": 576172371,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1772164335
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.60Ordinal.2Etypein.20.3D.20NatCast.60/near/576057726\">said</a>:</p>\n<blockquote>\n<p>btw for some reason, stating these with <code>(· &lt; ·)</code> fails to synthesize <code>IsWellOrder</code>, even though <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isWellOrder_lt#doc\">docs#isWellOrder_lt</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.Lt.isWellOrder#doc\">docs#Fin.Lt.isWellOrder</a> are spelled with it and not <code>LT.lt</code>.</p>\n</blockquote>\n<p>This is part of the reason I want to port the ordinal API to use bundled relations. Unbundled relations are painful.</p>",
        "id": 576172406,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1772164358
    },
    {
        "content": "<p><code>Ordinal.typein</code> and <code>Ordinal.enum</code> have very lackluster (and poor) API. If you can't immediately find something, assume it missing.</p>",
        "id": 576172556,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1772164431
    },
    {
        "content": "<p>Huh, my (short) experience so far with the ordinal API was that it's pretty complete, I found anything I searched for except for the theorems in this thread</p>",
        "id": 576172988,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1772164685
    },
    {
        "content": "<p>Perhaps it's more accurate to say ordinals have good API, order types have pretty terrible API.</p>",
        "id": 576201580,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1772180236
    }
]