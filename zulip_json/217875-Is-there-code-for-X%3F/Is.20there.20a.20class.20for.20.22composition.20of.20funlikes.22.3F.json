[
    {
        "content": "<p>So we have <code>DFunLike</code>/<code>FunLike</code>. Many <code>FunLike</code> classes have a <code>comp</code> operation which has the property that the function coercion of the composition of two members is the composition of the individual coercions. Is there a class for this?</p>",
        "id": 522353053,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749042158
    },
    {
        "content": "<p>It occurs to me that there's a lot of general theorems that essentially arise from this.</p>",
        "id": 522353095,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749042171
    },
    {
        "content": "<p>i don't think that exists as of yet...<br>\nBasically something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">FunLikeCompClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"n\">F₁</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"n\">F₂</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"n\">F₃</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F₃</span>\n<span class=\"w\">  </span><span class=\"n\">coe_comp_eq_coe_comp_coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">f₂</span><span class=\"w\"> </span><span class=\"n\">f₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">f₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"bp\">⇑</span><span class=\"n\">f₁</span>\n</code></pre></div>",
        "id": 522361487,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1749044302
    },
    {
        "content": "<p>We don't have it for a reason, which is basically that Lean can't generally infer the types. There's an issue that talks about a different design which might allow for this. It's Yury's <a href=\"https://github.com/leanprover-community/mathlib4/pull/2000\">#2000</a>-something</p>",
        "id": 522371460,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1749046649
    },
    {
        "content": "<p>(not actually 2000, it's 2xxx)</p>",
        "id": 522371554,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1749046675
    },
    {
        "content": "<p>I was just thinking that - relatedly - I was building lifts for various types, and thinking how much it felt like a general method would be useful.</p>",
        "id": 522371651,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1749046695
    },
    {
        "content": "<p>On this: I created <a href=\"https://github.com/leanprover-community/mathlib4/pull/26071\">#26071</a> just to experiment with it a little, and it seems to work with a little massaging. I realised really one could use a similar thing to generalise \"having an identity\" and generalising Equiv.symm for EquivLike, which would be quite nice.</p>",
        "id": 524650670,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750233927
    },
    {
        "content": "<p>Would appreciate thoughts and demonstrations of where this doesn't work. I didn't find <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>'s PR yet!</p>",
        "id": 524650768,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750233959
    },
    {
        "content": "<p>My approach was to replace <code>DFunLike</code> with a common structure</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">BundledHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Pred</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Y</span>\n<span class=\"w\">  </span><span class=\"n\">isValid</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pred</span><span class=\"w\"> </span><span class=\"n\">toFun</span>\n</code></pre></div>\n<p>then using classes like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">BundledHom</span><span class=\"bp\">.</span><span class=\"n\">Composable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PredYZ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PredXY</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PredXZ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">isValid_comp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PredYZ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">PredXY</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">PredXZ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I had a PR with a similar refactor for <code>SetLike</code>s (partial progress) but it wasn't merged for a few reasons:</p>\n<ul>\n<li>this would rule out, e.g., <code>Finsupp</code> and <code>Finset</code> from using this infrastructure;</li>\n<li>for bundled homs, I don't see how to make it work with equivalences;</li>\n<li>for many instances that came to my mind (e.g., a common order/lattice structure on <code>BundledSet</code>s) people came up with examples where it doesn't make sense.</li>\n</ul>",
        "id": 548182462,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1761923403
    }
]